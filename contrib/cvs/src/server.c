begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KRB_GET_ERR_TEXT
end_ifndef

begin_define
define|#
directive|define
name|krb_get_err_text
parameter_list|(
name|status
parameter_list|)
value|krb_err_txt[status]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Information we need if we are going to use Kerberos encryption.  */
end_comment

begin_decl_stmt
specifier|static
name|C_Block
name|kblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Key_schedule
name|sched
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* for select */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BSDTYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bsdtypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TIME_WITH_SYS_TIME
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|O_NDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EWOULDBLOCK is not defined by POSIX, but some BSD systems will    return it, rather than EAGAIN, for nonblocking writes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EWOULDBLOCK
end_ifdef

begin_define
define|#
directive|define
name|blocking_error
parameter_list|(
name|err
parameter_list|)
value|((err) == EWOULDBLOCK || (err) == EAGAIN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|blocking_error
parameter_list|(
name|err
parameter_list|)
value|((err) == EAGAIN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For initgroups().  */
end_comment

begin_if
if|#
directive|if
name|HAVE_INITGROUPS
end_if

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INITGROUPS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* The cvs username sent by the client, which might or might not be    the same as the system username the server eventually switches to    run as.  CVS_Username gets set iff password authentication is    successful. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|CVS_Username
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to check that same repos is transmitted in pserver auth and in    later CVS protocol.  Exported because root.c also uses. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Pserver_Repos
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* While processing requests, this buffer accumulates data to be sent to    the client, and then once we are in do_cvs_command, we use it    for all the data to be sent.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|buf_to_net
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This buffer is used to read input from the client.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|buf_from_net
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is where we stash stuff we are going to use.  Format string  * which expects a single directory within it, starting with a slash.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the original value of server_temp_dir, before any possible    changes inserted by serve_max_dotdot.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_server_temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should keep the temp directory around after we exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dont_delete_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|server_write_entries
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All server communication goes through buffer structures.  Most of    the buffers are built on top of a file descriptor.  This structure    is used as the closure field in a buffer.  */
end_comment

begin_struct
struct|struct
name|fd_buffer
block|{
comment|/* The file descriptor.  */
name|int
name|fd
decl_stmt|;
comment|/* Nonzero if the file descriptor is in blocking mode.  */
name|int
name|blocking
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|fd_buffer_initialize
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a buffer built on a file descriptor.  FD is the file    descriptor.  INPUT is nonzero if this is for input, zero if this is    for output.  MEMORY is the function to call when a memory error    occurs.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|buffer
modifier|*
name|fd_buffer_initialize
parameter_list|(
name|fd
parameter_list|,
name|input
parameter_list|,
name|memory
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|input
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|fd_buffer
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|n
operator|->
name|blocking
operator|=
literal|1
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|fd_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|fd_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|fd_buffer_flush
argument_list|,
name|fd_buffer_block
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|memory
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The buffer input function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
operator|!
name|fd
operator|->
name|blocking
condition|)
name|nbytes
operator|=
name|read
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This case is not efficient.  Fortunately, I don't think it            ever actually happens.  */
name|nbytes
operator|=
name|read
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|need
operator|==
literal|0
condition|?
literal|1
else|:
name|need
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
operator|*
name|got
operator|=
name|nbytes
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* End of file.  This assumes that we are using POSIX or BSD            style nonblocking I/O.  On System V we will get a zero            return if there is no data, even when not at EOF.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Some error occurred.  */
if|if
condition|(
name|blocking_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Everything's fine, we just didn't get any data.  */
return|return
literal|0
return|;
block|}
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* The buffer output function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|wrote
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|have
operator|>
literal|0
condition|)
block|{
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|write
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|have
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fd
operator|->
name|blocking
operator|&&
operator|(
name|nbytes
operator|==
literal|0
operator|||
name|blocking_error
argument_list|(
name|errno
argument_list|)
operator|)
condition|)
block|{
comment|/* A nonblocking write failed to write any data.  Just                    return.  */
return|return
literal|0
return|;
block|}
comment|/* Some sort of error occurred.  */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
return|return
name|errno
return|;
block|}
operator|*
name|wrote
operator|+=
name|nbytes
expr_stmt|;
name|data
operator|+=
name|nbytes
expr_stmt|;
name|have
operator|-=
name|nbytes
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer flush function for a buffer built on a file descriptor.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
comment|/* Nothing to do.  File descriptors are always flushed.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer block function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|block
condition|)
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
else|else
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|fd
operator|->
name|blocking
operator|=
name|block
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Make directory DIR, including all intermediate directories if necessary.  * Returns 0 for success or errno code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mkdir_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mkdir_p
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|retval
operator|=
literal|0
expr_stmt|;
comment|/*      * Skip over leading slash if present.  We won't bother to try to      * make '/'.      */
name|p
operator|=
name|dir
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|q
argument_list|,
name|dir
argument_list|,
name|p
operator|-
name|dir
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
name|dir
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|q
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|saved_errno
operator|!=
name|EEXIST
operator|&&
operator|(
name|saved_errno
operator|!=
name|EACCES
operator|||
operator|!
name|isdir
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|=
name|saved_errno
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print the error response for error code STATUS.  The caller is  * reponsible for making sure we get back to the command loop without  * any further output occuring.  * Must be called only in contexts where it is OK to send output.  */
end_comment

begin_function
specifier|static
name|void
name|print_error
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  "
argument_list|)
expr_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|pending_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Malloc'd text for pending error.  Each line must start with "E ".  The  * last line should not end with a newline.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pending_error_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If an error is pending, print it and return 1.  If not, return 0.    Must be called only in contexts where it is OK to send output.  */
end_comment

begin_function
specifier|static
name|int
name|print_pending_error
parameter_list|()
block|{
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|pending_error_text
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error
condition|)
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|pending_error_text
argument_list|)
expr_stmt|;
name|pending_error_text
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pending_error
condition|)
block|{
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is an error pending?  */
end_comment

begin_define
define|#
directive|define
name|error_pending
parameter_list|()
value|(pending_error || pending_error_text)
end_define

begin_decl_stmt
specifier|static
name|int
name|alloc_pending
name|PROTO
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate SIZE bytes for pending_error_text and return nonzero    if we could do it.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_pending
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
if|if
condition|(
name|error_pending
argument_list|()
condition|)
comment|/* Probably alloc_pending callers will have already checked for 	   this case.  But we might as well handle it if they don't, I 	   guess.  */
return|return
literal|0
return|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|supported_response
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|supported_response
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rs
operator|->
name|status
operator|==
name|rs_supported
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: testing support for unknown response?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_valid_responses
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* 	     * It is a response we have never heard of (and thus never 	     * will want to use).  So don't worry about it. 	     */
empty_stmt|;
else|else
name|rs
operator|->
name|status
operator|=
name|rs_supported
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_essential
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E response `"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|rs
operator|->
name|name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"' not supported by client\nerror  \n"
argument_list|)
expr_stmt|;
comment|/* FIXME: This call to buf_flush could conceivably 	       cause deadlock, as noted in server_cleanup.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	       because I'm not sure whether we want to call server_cleanup. 	       Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	       NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_optional
condition|)
name|rs
operator|->
name|status
operator|=
name|rs_not_supported
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_root
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Root %s must be an absolute pathname"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|set_local_cvsroot
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_HISTORY
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Cannot access %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|path
argument_list|)
operator|&&
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E \ Sorry, you don't have read/write access to the history file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PUTENV
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|max_dotdot_limit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is this pathname OK to recurse into when we are running as the server?    If not, call error() with a fatal error.  */
end_comment

begin_function
name|void
name|server_pathname_check
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
comment|/* An absolute pathname is almost surely a path on the *client* machine,        and is unlikely to do us any good here.  It also is probably capable        of being a security hole in the anonymous readonly case.  */
if|if
condition|(
name|isabsolute
argument_list|(
name|path
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"absolute pathname `%s' illegal for server"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname_levels
argument_list|(
name|path
argument_list|)
operator|>
name|max_dotdot_limit
condition|)
block|{
comment|/* Similar to the isabsolute case in security implications.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: `%s' contains more leading .."
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"than the %d which Max-dotdot specified"
argument_list|,
name|max_dotdot_limit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add as many directories to the temp directory as the client tells us it  * will use "..", so we never try to access something outside the temp  * directory via "..".  */
end_comment

begin_function
specifier|static
name|void
name|serve_max_dotdot
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|lim
init|=
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|lim
operator|<
literal|0
condition|)
return|return;
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|2
operator|*
name|lim
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
operator|++
name|i
control|)
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_temp_dir
operator|!=
name|orig_server_temp_dir
condition|)
name|free
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|server_temp_dir
operator|=
name|p
expr_stmt|;
name|max_dotdot_limit
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dirswitch
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|dir_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
comment|/* Check for a trailing '/'.  This is not ISDIRSEP because \ in the        protocol is an ordinary character, not a directory separator (of        course, it is perhaps unwise to use it in directory names, but that        is another issue).  */
if|if
condition|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|>
literal|0
operator|&&
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: illegal directory syntax in %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|dir_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dir_name
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
name|pending_error
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot mkdir %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|b
operator|=
name|strrchr
argument_list|(
name|dir_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
name|dir_name
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * This is pretty much like calling Create_Admin, but Create_Admin doesn't      * report errors in the right way for us.      */
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|CVSADM
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
comment|/* Don't create the files again.  */
return|return;
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_REP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|repos
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Non-remote CVS handles a module representing the entire tree        (e.g., an entry like ``world -a .'') by putting /. at the end        of the Repository file, so we do the same.  */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|&&
name|CVSroot_directory
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|CVSroot_directory
argument_list|,
name|repos
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/."
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
comment|/* We open in append mode because we don't want to clobber an        existing Entries file.  */
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_repository
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Repository request is obsolete; aborted"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|repos
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|dirswitch
argument_list|(
name|arg
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_static_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_sticky
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read SIZE bytes from buf_from_net, write them to FILE.  *  * Currently this isn't really used for receiving parts of a file --  * the file is still sent over in one chunk.  But if/when we get  * spiffy in-process gzip support working, perhaps the compressed  * pieces could be sent over as they're ready, if the network is fast  * enough.  Or something.  */
end_comment

begin_function
specifier|static
name|void
name|receive_partial_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|file
decl_stmt|;
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E premature end of file from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
return|return;
block|}
name|size
operator|-=
name|nread
expr_stmt|;
while|while
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|int
name|nwrote
decl_stmt|;
name|nwrote
operator|=
name|write
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrote
operator|<
literal|0
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E unable to write"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
comment|/* Read and discard the file data.  */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
name|size
operator|-=
name|nread
expr_stmt|;
block|}
return|return;
block|}
name|nread
operator|-=
name|nwrote
expr_stmt|;
name|data
operator|+=
name|nwrote
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Receive SIZE bytes, write to filename FILE.  */
end_comment

begin_function
specifier|static
name|void
name|receive_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|gzipped
parameter_list|)
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|gzipped
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|file
decl_stmt|;
name|pid_t
name|gzip_pid
init|=
literal|0
decl_stmt|;
name|int
name|gzip_status
decl_stmt|;
comment|/* Write the file.  */
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|arg
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
comment|/*      * FIXME: This doesn't do anything reasonable with gunzip's stderr, which      * means that if gunzip writes to stderr, it will cause all manner of      * protocol violations.      */
if|if
condition|(
name|gzipped
condition|)
name|fd
operator|=
name|filter_through_gunzip
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
name|receive_partial_file
argument_list|(
name|size
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|realloc
argument_list|(
name|pending_error_text
argument_list|,
name|strlen
argument_list|(
name|pending_error_text
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pending_error_text
operator|=
name|p
expr_stmt|;
name|sprintf
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|", file %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* else original string is supposed to be unchanged */
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|gzip_pid
condition|)
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gzip_pid
condition|)
block|{
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|!=
name|gzip_pid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gunzip process %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gunzip exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_modified
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|size_text
decl_stmt|;
name|char
modifier|*
name|mode_text
decl_stmt|;
name|int
name|gzipped
init|=
literal|0
decl_stmt|;
comment|/*      * This used to return immediately if error_pending () was true.      * However, that fails, because it causes each line of the file to      * be echoed back to the client as an unrecognized command.  The      * client isn't reading from the socket, so eventually both      * processes block trying to write to the other.  Now, we try to      * read the file if we can.      */
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|mode_text
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|size_text
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
if|if
condition|(
name|size_text
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|gzipped
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_text
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|atoi
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
block|{
comment|/* Now that we know the size, read and discard the file data.  */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
name|size
operator|-=
name|nread
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
block|{
name|receive_file
argument_list|(
name|size
argument_list|,
name|arg
argument_list|,
name|gzipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
block|}
block|{
name|int
name|status
init|=
name|change_mode
argument_list|(
name|arg
argument_list|,
name|mode_text
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_enable_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{ }
end_function

begin_struct
struct|struct
name|an_entry
block|{
name|struct
name|an_entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|an_entry
modifier|*
name|entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_unchanged
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|timefield
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
comment|/* Rewrite entries file to have `=' in timestamp field.  */
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name
operator|=
name|p
operator|->
name|entry
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|cp
operator|-
name|name
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timefield
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|timefield
operator|!=
literal|'='
condition|)
block|{
name|cp
operator|=
name|timefield
operator|+
name|strlen
argument_list|(
name|timefield
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|timefield
condition|)
block|{
operator|*
name|cp
operator|=
name|cp
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|cp
expr_stmt|;
block|}
operator|*
name|timefield
operator|=
literal|'='
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_is_modified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_is_modified
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|timefield
decl_stmt|;
comment|/* Have we found this file in "entries" yet.  */
name|int
name|found
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
comment|/* Rewrite entries file to have `M' in timestamp field.  */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name
operator|=
name|p
operator|->
name|entry
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|cp
operator|-
name|name
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timefield
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|timefield
index|[
literal|0
index|]
operator|==
literal|'M'
operator|&&
name|timefield
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp
operator|=
name|timefield
operator|+
name|strlen
argument_list|(
name|timefield
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|timefield
condition|)
block|{
operator|*
name|cp
operator|=
name|cp
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|cp
expr_stmt|;
block|}
operator|*
name|timefield
operator|=
literal|'M'
expr_stmt|;
block|}
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* We got Is-modified but no Entry.  Add a dummy entry. 	   The "D" timestamp is what makes it a dummy.  */
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|an_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|entry
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|entry
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
literal|"//D//"
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|entries
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_entry
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|an_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
comment|/* Leave space for serve_unchanged to write '=' if it wants.  */
name|cp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|cp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|entries
expr_stmt|;
name|p
operator|->
name|entry
operator|=
name|cp
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_write_entries
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* Note that we free all the entries regardless of errors.  */
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
comment|/* We open in append mode because we don't want to clobber an            existing Entries file.  If we are checking out a module            which explicitly lists more than one file in a particular            directory, then we will wind up calling            server_write_entries for each such file.  */
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|entry
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
operator|->
name|entry
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|entries
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|notify_note
block|{
comment|/* Directory in which this notification happens.  malloc'd*/
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* malloc'd.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The following three all in one malloc'd block, pointed to by TYPE.        Each '\0' terminated.  */
comment|/* "E" or "U".  */
name|char
modifier|*
name|type
decl_stmt|;
comment|/* time+host+dir */
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|watches
decl_stmt|;
name|struct
name|notify_note
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|notify_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used while building list, to point to the last node that already exists.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|last_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_notify
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_notify
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|notify_note
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|new
operator|=
operator|(
expr|struct
name|notify_note
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|notify_note
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|new
operator|->
name|dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|dir
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|new
operator|->
name|dir
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|filename
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|new
operator|->
name|filename
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|data
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading notification for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading notification for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|new
operator|->
name|type
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
literal|'\t'
condition|)
goto|goto
name|error
goto|;
name|data
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|data
operator|+
literal|2
expr_stmt|;
name|new
operator|->
name|val
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|->
name|watches
operator|=
name|cp
expr_stmt|;
comment|/* If there is another tab, ignore everything after it, 	   for future expansion.  */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_node
operator|==
name|NULL
condition|)
block|{
name|notify_list
operator|=
name|new
expr_stmt|;
block|}
else|else
name|last_node
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|last_node
operator|=
name|new
expr_stmt|;
block|}
return|return;
name|error
label|:
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error; misformed Notify request"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Process all the Notify requests that we have stored up.  Returns 0    if successful, if not prints error message (via error()) and    returns negative value.  */
end_comment

begin_function
specifier|static
name|int
name|server_notify
parameter_list|()
block|{
name|struct
name|notify_note
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
while|while
condition|(
name|notify_list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change to %s"
argument_list|,
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|repos
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lock_dir_for_write
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|fileattr_startdir
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|notify_do
argument_list|(
operator|*
name|notify_list
operator|->
name|type
argument_list|,
name|notify_list
operator|->
name|filename
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|notify_list
operator|->
name|val
argument_list|,
name|notify_list
operator|->
name|watches
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Notified "
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
name|notify_list
operator|->
name|dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|notify_list
operator|->
name|filename
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|p
operator|=
name|notify_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
argument_list|)
expr_stmt|;
name|notify_list
operator|=
name|p
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* The code used to call fflush (stdout) here, but that is no        longer necessary.  The data is now buffered in buf_to_net,        which will be flushed by the caller, do_cvs_command.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|argument_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argument_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argument_vector_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_argument
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|argument_vector_size
operator|<=
name|argument_count
condition|)
block|{
name|argument_vector_size
operator|*=
literal|2
expr_stmt|;
name|argument_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argument_vector
argument_list|,
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument_vector
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_argumentx
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|p
operator|=
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_global_option
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|arg
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|error_return
label|:
if|if
condition|(
name|alloc_pending
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: bad global option %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'n'
case|:
name|noexec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|error_return
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_set
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* FIXME: This sends errors immediately (I think); they should be        put into pending_error.  */
name|variable_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_function
specifier|static
name|void
name|serve_kerberos_encrypt
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* All future communication with the client will be encrypted.  */
name|buf_to_net
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENCRYPTION */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/* The maximum we'll queue to the remote client before blocking.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_HI_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_HI_WATER
value|(2 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_HI_WATER */
end_comment

begin_comment
comment|/* When the buffer drops to this, we restart the child */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_LO_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_LO_WATER
value|(1 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_LO_WATER */
end_comment

begin_decl_stmt
specifier|static
name|int
name|set_nonblock_fd
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
specifier|static
name|int
name|set_nonblock_fd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|serve_questionable
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_questionable
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|int
name|initted
decl_stmt|;
if|if
condition|(
operator|!
name|initted
condition|)
block|{
comment|/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server, 	   and CVSIGNORE on server.  */
name|ign_setup
argument_list|()
expr_stmt|;
name|initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Protocol error: 'Directory' missing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ign_name
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"M ? "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|dir_name
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|update_dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_case
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_case
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|ign_case
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|protocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the output which we are saving up to send to the server, in the    child process.  We will push it through, via the `protocol' buffer, when    we have a complete line.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|saved_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, but stuff which will go to stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|saved_outerr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|protocol_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process IDs of the subprocess, or negative if that subprocess  * does not exist.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|command_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|outbuf_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|"E Fatal server error\n\ error ENOMEM Virtual memory exhausted.\n"
decl_stmt|;
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
comment|/*      * We have arranged things so that printing this now either will      * be legal, or the "E fatal error" line will get glommed onto the      * end of an existing "E" or "M" response.      */
comment|/* If this gives an error, not much we could do.  syslog() it?  */
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|outbuf_memory_error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If command is legal, return 1.  * Else if command is illegal and croak_on_illegal is set, then die.  * Else just return 0 to indicate that command is illegal.  */
end_comment

begin_function
specifier|static
name|int
name|check_command_legal_p
parameter_list|(
name|cmd_name
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
block|{
comment|/* Right now, only pserver notices illegal commands -- namely,      * write attempts by a read-only user.  Therefore, if CVS_Username      * is not set, this just returns 1, because CVS_Username unset      * means pserver is not active.      */
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
if|if
condition|(
name|CVS_Username
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|lookup_command_attribute
argument_list|(
name|cmd_name
argument_list|)
operator|&
name|CVS_CMD_MODIFIES_REPOSITORY
condition|)
block|{
comment|/* This command has the potential to modify the repository, so          * we check if the user have permission to do that.          *          * (Only relevant for remote users -- local users can do          * whatever normal Unix file permissions allow them to do.)          *          * The decision method:          *          *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed          *    in it, then read-only access for user.          *          *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT          *    listed in it, then also read-only access for user.          *          *    Else read-write access for user.          */
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|int
name|num_red
init|=
literal|0
decl_stmt|;
name|size_t
name|linebuf_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
comment|/* else */
name|flen
operator|=
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_READERS
argument_list|)
operator|+
literal|3
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|flen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_READERS
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
goto|goto
name|do_writers
goto|;
else|else
comment|/* successfully opened readers file */
block|{
while|while
condition|(
operator|(
name|num_red
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Hmmm, is it worth importing my own readline                     library into CVS?  It takes care of chopping                     leading and trailing whitespace, "#" comments, and                     newlines automatically when so requested.  Would                     save some code here...  -kff */
comment|/* Chop newline by hand, for strcmp()'s sake. */
if|if
condition|(
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|CVS_Username
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|handle_illegal
goto|;
block|}
comment|/* If not listed specifically as a reader, then this user                 has write access by default unless writers are also                 specified in a file . */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|do_writers
goto|;
block|}
name|do_writers
label|:
name|flen
operator|=
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_WRITERS
argument_list|)
operator|+
literal|3
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|flen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_WRITERS
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* writers file does not exist, so everyone is a writer,                 by default */
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* else */
name|found_it
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|num_red
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Chop newline by hand, for strcmp()'s sake. */
if|if
condition|(
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|CVS_Username
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found_it
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* writers file exists, but this user not listed in it */
block|{
name|handle_illegal
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
comment|/* If ever reach end of this function, command must be legal. */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute COMMAND in a subprocess with the approriate funky things done.  */
end_comment

begin_struct
specifier|static
struct|struct
name|fd_set_wrapper
block|{
name|fd_set
name|fds
decl_stmt|;
block|}
name|command_fds_to_drain
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|max_command_fd
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|flowcontrol_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_function_decl
specifier|static
name|void
name|do_cvs_command
parameter_list|(
name|cmd_name
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*command
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*      * The following file descriptors are set to -1 if that file is not      * currently open.      */
comment|/* Data on these pipes is a series of '\n'-terminated lines.  */
name|int
name|stdout_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|stderr_pipe
index|[
literal|2
index|]
decl_stmt|;
comment|/*      * Data on this pipe is a series of counted (see buf_send_counted)      * packets.  Each packet must be processed atomically (i.e. not      * interleaved with data from stdout_pipe or stderr_pipe).      */
name|int
name|protocol_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|dev_null_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|errs
decl_stmt|;
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
goto|goto
name|free_args_and_return
goto|;
comment|/* Global `command_name' is probably "server" right now -- only        serve_export() sets it to anything else.  So we will use local        parameter `cmd_name' to determine if this command is legal for        this user.  */
if|if
condition|(
operator|!
name|check_command_legal_p
argument_list|(
name|cmd_name
argument_list|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|" [server aborted]: \""
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"\" requires write access to the repository\n\ error  \n"
argument_list|)
expr_stmt|;
goto|goto
name|free_args_and_return
goto|;
block|}
operator|(
name|void
operator|)
name|server_notify
argument_list|()
expr_stmt|;
comment|/*      * We use a child process which actually does the operation.  This      * is so we can intercept its standard output.  Even if all of CVS      * were written to go to some special routine instead of writing      * to stdout or stderr, we would still need to do the same thing      * for the RCS commands.      */
if|if
condition|(
name|pipe
argument_list|(
name|stdout_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|stderr_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|protocol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|pipe
argument_list|(
name|flowcontrol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|dev_null_fd
operator|=
name|CVS_OPEN
argument_list|(
name|DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_null_fd
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* We shouldn't have any partial lines from cvs_output and        cvs_outerr, but we handle them here in case there is a bug.  */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|saved_output
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|saved_output
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|saved_outerr
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|saved_outerr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
comment|/* Flush out any pending data.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't use vfork; we're not going to exec().  */
name|command_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_pid
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|command_pid
operator|==
literal|0
condition|)
block|{
name|int
name|exitstatus
decl_stmt|;
comment|/* Since we're in the child, and the parent is going to take 	   care of packaging up our error messages, we can clear this 	   flag.  */
name|error_use_protocol
operator|=
literal|0
expr_stmt|;
name|protocol
operator|=
name|fd_buffer_initialize
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|protocol_memory_error
argument_list|)
expr_stmt|;
comment|/* At this point we should no longer be using buf_to_net and            buf_from_net.  Instead, everything should go through            protocol.  */
name|buf_to_net
operator|=
name|NULL
expr_stmt|;
name|buf_from_net
operator|=
name|NULL
expr_stmt|;
comment|/* These were originally set up to use outbuf_memory_error.            Since we're now in the child, we should use the simpler            protocol_memory_error function.  */
name|saved_output
operator|->
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
name|saved_outerr
operator|->
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|dev_null_fd
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
comment|/* 	 * Set this in .bashrc if you want to give yourself time to attach 	 * to the subprocess with a debugger. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
condition|)
block|{
name|int
name|secs
init|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
argument_list|)
decl_stmt|;
name|sleep
argument_list|(
name|secs
argument_list|)
expr_stmt|;
block|}
name|exitstatus
operator|=
call|(
modifier|*
name|command
call|)
argument_list|(
name|argument_count
argument_list|,
name|argument_vector
argument_list|)
expr_stmt|;
comment|/* 	 * When we exit, that will close the pipes, giving an EOF to 	 * the parent. 	 */
name|exit
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
comment|/* OK, sit around getting all the input from the child.  */
block|{
name|struct
name|buffer
modifier|*
name|stdoutbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|stderrbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|protocol_inbuf
decl_stmt|;
comment|/* Number of file descriptors to check in select ().  */
name|int
name|num_to_check
decl_stmt|;
name|int
name|count_needed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|have_flowcontrolled
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
name|num_to_check
operator|=
name|stdout_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|stderr_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|protocol_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|STDOUT_FILENO
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|max_command_fd
operator|=
name|num_to_check
expr_stmt|;
comment|/* 	 * File descriptors are numbered from 0, so num_to_check needs to 	 * be one larger than the largest descriptor. 	 */
operator|++
name|num_to_check
expr_stmt|;
if|if
condition|(
name|num_to_check
operator|>
name|FD_SETSIZE
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E internal error: FD_SETSIZE not big enough.\n\ error  \n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdoutbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|stderrbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|protocol_inbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|stdoutbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|stderrbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|protocol_inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
if|if
condition|(
name|close
argument_list|(
name|dev_null_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dev_null_fd
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|fd_set
name|readfds
decl_stmt|;
name|fd_set
name|writefds
decl_stmt|;
name|int
name|numfds
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|bufmemsize
decl_stmt|;
comment|/* 	     * See if we are swamping the remote client and filling our VM. 	     * Tell child to hold off if we do. 	     */
name|bufmemsize
operator|=
name|buf_count_mem
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|>
name|SERVER_HI_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|<
name|SERVER_LO_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"G"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|buf_to_net
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
comment|/* This process of selecting on the three pipes means that 	       we might not get output in the same order in which it 	       was written, thus producing the well-known 	       "out-of-order" bug.  If the child process uses 	       cvs_output and cvs_outerr, it will send everything on 	       the protocol_pipe and avoid this problem, so the 	       solution is to use cvs_output and cvs_outerr in the 	       child process.  */
do|do
block|{
comment|/* This used to select on exceptions too, but as far                    as I know there was never any reason to do that and                    SCO doesn't let you select on exceptions on pipes.  */
name|numfds
operator|=
name|select
argument_list|(
name|num_to_check
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
condition|)
block|{
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|stdoutbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|stderrbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count_read
decl_stmt|;
name|int
name|special
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|protocol_inbuf
argument_list|,
operator|&
name|count_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 		 * We only call buf_copy_counted if we have read 		 * enough bytes to make it worthwhile.  This saves us 		 * from continually recounting the amount of data we 		 * have. 		 */
name|count_needed
operator|-=
name|count_read
expr_stmt|;
while|while
condition|(
name|count_needed
operator|<=
literal|0
condition|)
block|{
name|count_needed
operator|=
name|buf_copy_counted
argument_list|(
name|buf_to_net
argument_list|,
name|protocol_inbuf
argument_list|,
operator|&
name|special
argument_list|)
expr_stmt|;
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
comment|/* If SPECIAL got set to -1, it means that the child 		       wants us to flush the pipe.  We don't want to block 		       on the network, but we flush what we can.  If the 		       client supports the 'F' command, we send it.  */
if|if
condition|(
name|special
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|supported_response
argument_list|(
literal|"F"
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|cvs_flusherr
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * OK, we've gotten EOF on all the pipes.  If there is 	 * anything left on stdoutbuf or stderrbuf (this could only 	 * happen if there was no trailing newline), send it over. 	 */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|stdoutbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|stdoutbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|stderrbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|stderrbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|protocol_inbuf
argument_list|)
condition|)
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Protocol error: uncounted data discarded\n"
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Intentionally ignoring EINTR.  Other errors 		 * "can't happen". 		 */
continue|continue;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|errs
operator|+=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
comment|/* 		 * This is really evil, because signals might be numbered 		 * differently on the two systems.  We should be using 		 * signal names (either of the "Terminated" or the "SIGTERM" 		 * variety).  But cvs doesn't currently use libiberty...we 		 * could roll our own....  FIXME. 		 */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Terminated with fatal signal "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Test for a core dump.  Is this portable?  */
if|if
condition|(
name|status
operator|&
literal|0x80
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Core dumped; preserving "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|orig_server_temp_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|" on server.\n\ E CVS locks may need cleaning up.\n"
argument_list|)
expr_stmt|;
name|dont_delete_temp
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|errs
expr_stmt|;
block|}
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * OK, we've waited for the child.  By now all CVS locks are free 	 * and it's OK to block on the network. 	 */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
comment|/* We will have printed an error message already.  */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
goto|goto
name|free_args_and_return
goto|;
name|error_exit
label|:
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|dev_null_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free_args_and_return
label|:
comment|/* Now free the arguments.  */
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Flush out any data not yet sent.  */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Called by the child at convenient points in the server's execution for  * the server child to block.. ie: when it has no locks active.  */
end_comment

begin_function
name|void
name|server_pause_check
parameter_list|()
block|{
name|int
name|paused
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
while|while
condition|(
name|paused
condition|)
block|{
name|int
name|numfds
decl_stmt|,
name|numtocheck
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|numtocheck
operator|=
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|numfds
operator|=
name|select
argument_list|(
name|numtocheck
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|int
name|got
decl_stmt|;
while|while
condition|(
operator|(
name|got
operator|=
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
comment|/* This assumes that we are using BSD or POSIX nonblocking                I/O.  System V nonblocking I/O returns zero if there is                nothing to read.  */
if|if
condition|(
name|got
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"flow control EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|<
literal|0
operator|&&
operator|!
name|blocking_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"flow control read failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This variable commented in server.h.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|server_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|output_dir
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|server_dir
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|server_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/\n"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Entries line that we are squirreling away to send to the client when  * we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entries_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File which has been Scratch_File'd, we are squirreling away that fact  * to inform the client when we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratched_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The scratched_file will need to be removed as well as having its entry  * removed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_scratched_file
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|server_register
parameter_list|(
name|name
parameter_list|,
name|version
parameter_list|,
name|timestamp
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|conflict
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|timestamp
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|conflict
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> server_register(%s, %s, %s, %s, %s, %s, %s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
comment|/* silly */
name|name
argument_list|,
name|version
argument_list|,
name|timestamp
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|,
name|conflict
condition|?
name|conflict
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * If CVS decides to Register it more than once (which happens 	 * on "cvs update foo/foo.c" where foo and foo.c are already 	 * checked out), use the last of the entries lines Register'd. 	 */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
block|}
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      */
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|80
operator|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entries_line
argument_list|,
literal|"/%s/%s/"
argument_list|,
name|name
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|server_scratch
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      */
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"E CVS server internal error: duplicate Scratch_Entry\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
return|return;
block|}
name|scratched_file
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|kill_scratched_file
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_scratch_entry_only
parameter_list|()
block|{
name|kill_scratched_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a new entries line, from a previous server_register.  */
end_comment

begin_function
specifier|static
name|void
name|new_entries_line
parameter_list|()
block|{
if|if
condition|(
name|entries_line
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Return the error message as the Entries line.  */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"CVS server internal error: Register missing\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ci
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"commit"
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checked_in_response
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|supported_response
argument_list|(
literal|"Mode"
argument_list|)
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not clear to me why the file would fail to exist, but it 	       was happening somewhere in the testsuite.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Mode "
argument_list|)
expr_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
block|}
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Checked-in "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_checked_in
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This happens if we are now doing a "cvs remove" after a previous 	 * "cvs add" (without a "cvs ci" in between). 	 */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_update_entries
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|updated
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"New-entry"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"New-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_update
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"update"
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_diff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"diff"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_log
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"cvslog"
argument_list|,
name|cvslog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"add"
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"cvsremove"
argument_list|,
name|cvsremove
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_status
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"status"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rdiff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"patch"
argument_list|,
name|patch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_tag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"cvstag"
argument_list|,
name|cvstag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rtag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"rtag"
argument_list|,
name|rtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_import
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"import"
argument_list|,
name|import
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_admin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"admin"
argument_list|,
name|admin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_history
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"history"
argument_list|,
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_release
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"release"
argument_list|,
name|release
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_on
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_on
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch_on"
argument_list|,
name|watch_on
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_off
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_off
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch_off"
argument_list|,
name|watch_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_add
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch_add"
argument_list|,
name|watch_add
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_remove
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch_remove"
argument_list|,
name|watch_remove
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watchers
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watchers
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watchers"
argument_list|,
name|watchers
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_editors
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_editors
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"editors"
argument_list|,
name|editors
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|noop
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|noop
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_noop
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_noop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"noop"
argument_list|,
name|noop
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_init
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_init
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Root %s must be an absolute pathname"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* Fall through to do_cvs_command which will return the 	   actual error.  */
block|}
name|set_local_cvsroot
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|do_cvs_command
argument_list|(
literal|"init"
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_annotate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_annotate
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"annotate"
argument_list|,
name|annotate
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_co
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|tempdir
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
comment|/* 	 * The client has not sent a "Repository" line.  Check out 	 * into a pristine directory. 	 */
name|tempdir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|tempdir
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempdir
argument_list|,
literal|"/checkout-dir"
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Cannot create "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|tempdir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Cannot change to directory "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
block|}
comment|/* Compensate for server_export()'s setting of command_name.      *      * [It probably doesn't matter if do_cvs_command() gets "export"      *  or "checkout", but we ought to be accurate where possible.]      */
name|do_cvs_command
argument_list|(
operator|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|"export"
else|:
literal|"checkout"
argument_list|,
name|checkout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_export
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* Tell checkout() to behave like export not checkout.  */
name|command_name
operator|=
literal|"export"
expr_stmt|;
name|serve_co
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|server_copy_file
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|newfile
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|newfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Copy-file"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Copy-file "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See server.h for description.  */
end_comment

begin_function
name|void
name|server_updated
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|,
name|updated
parameter_list|,
name|file_info
parameter_list|,
name|checksum
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
name|struct
name|stat
modifier|*
name|file_info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|checksum
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|entries_line
operator|!=
name|NULL
operator|&&
name|scratched_file
operator|==
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|list
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
name|size_text
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* 		 * If we have a sticky tag for a branch on which the 		 * file is dead, and cvs update the directory, it gets 		 * a T_CHECKOUT but no file.  So in this case just 		 * forget the whole thing.  */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|int
name|checksum_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|checksum_supported
operator|==
operator|-
literal|1
condition|)
block|{
name|checksum_supported
operator|=
name|supported_response
argument_list|(
literal|"Checksum"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checksum_supported
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Checksum "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|checksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf_append_char
argument_list|(
name|protocol
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|Entnode
modifier|*
name|entnode
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|supported_response
argument_list|(
literal|"Created"
argument_list|)
operator|&&
name|supported_response
argument_list|(
literal|"Update-existing"
argument_list|)
operator|)
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Updated "
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|vers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Created "
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Update-existing "
argument_list|)
expr_stmt|;
block|}
comment|/* Now munge the entries to say that the file is unmodified, 	       in case we end up processing it again (e.g. modules3-6 	       in the testsuite).  */
name|node
operator|=
name|findnode_fn
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|entnode
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|entnode
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|entnode
operator|->
name|timestamp
operator|=
name|xstrdup
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_MERGED
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Merged "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_PATCHED
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Patched "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_RCS_DIFF
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Rcs-diff "
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|output_dir
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|{
name|char
modifier|*
name|mode_string
decl_stmt|;
comment|/* FIXME: When we check out files the umask of the server 	       (set in .bashrc if rsh is in use) affects what mode we 	       send, and it shouldn't.  */
if|if
condition|(
name|file_info
operator|!=
name|NULL
condition|)
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|file_info
operator|->
name|st_mode
argument_list|)
expr_stmt|;
else|else
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|last
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
comment|/* Throughout this section we use binary mode to read the 	       file we are sending.  The client handles any line ending 	       translation if necessary.  */
if|if
condition|(
name|file_gzip_level
comment|/* 		 * For really tiny files, the gzip process startup 		 * time will outweigh the compression savings.  This 		 * might be computable somehow; using 100 here is just 		 * a first approximation. 		 */
operator|&&
name|sb
operator|.
name|st_size
operator|>
literal|100
condition|)
block|{
name|int
name|status
decl_stmt|,
name|fd
decl_stmt|,
name|gzip_status
decl_stmt|;
name|pid_t
name|gzip_pid
decl_stmt|;
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|filter_through_gzip
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
name|file_gzip_level
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_file_to_eof
argument_list|(
name|f
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|size
operator|=
name|buf_chain_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|protocol
operator|->
name|memory_error
call|)
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gzip process %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
comment|/* Prepending length with "z" is flag for using gzip here.  */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|status
decl_stmt|;
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_file
argument_list|(
name|f
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|protocol
operator|->
name|memory_error
call|)
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|size_text
argument_list|,
literal|"%lu\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|size_text
argument_list|)
expr_stmt|;
name|buf_append_data
argument_list|(
name|protocol
argument_list|,
name|list
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Note we only send a newline here if the file ended with one.  */
comment|/* 	 * Avoid using up too much disk space for temporary files. 	 * A file which does not exist indicates that the file is up-to-date, 	 * which is now the case.  If this is SERVER_MERGED, the file is 	 * not up-to-date, and we indicate that by leaving the file there. 	 * I'm thinking of cases like "cvs update foo/foo.c foo". 	 */
if|if
condition|(
operator|(
name|updated
operator|==
name|SERVER_UPDATED
operator|||
name|updated
operator|==
name|SERVER_PATCHED
operator|||
name|updated
operator|==
name|SERVER_RCS_DIFF
operator|)
comment|/* But if we are joining, we'll need the file when we call 	       join_file.  */
operator|&&
operator|!
name|joining
argument_list|()
condition|)
name|CVS_UNLINK
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|scratched_file
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: `%s' vs. `%s' scratched"
argument_list|,
name|scratched_file
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill_scratched_file
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Removed "
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|==
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This can happen with death support if we were processing 	 * a dead file in a checkout. 	 */
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: Register *and* Scratch_Entry.\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
name|done
label|:
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether we should send patches in RCS format.  */
end_comment

begin_function
name|int
name|server_use_rcs_diff
parameter_list|()
block|{
return|return
name|supported_response
argument_list|(
literal|"Rcs-diff"
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|server_set_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|set_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set_static_supported
operator|==
operator|-
literal|1
condition|)
name|set_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_static_supported
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Set-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_clear_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|clear_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|clear_static_supported
operator|==
operator|-
literal|1
condition|)
name|clear_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Clear-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clear_static_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Clear-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|server_set_sticky
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|nonbranch
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|nonbranch
decl_stmt|;
block|{
specifier|static
name|int
name|set_sticky_supported
init|=
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
name|update_dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sticky_supported
operator|==
operator|-
literal|1
condition|)
name|set_sticky_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-sticky"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_sticky_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|tag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Clear-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Set-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nonbranch
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"N"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|template_proc_data
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Here as a static until we get around to fixing Parse_Info to pass along    a void * for it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|template_proc_data
modifier|*
name|tpd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|template_proc
parameter_list|(
name|repository
parameter_list|,
name|template
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|template_proc_data
modifier|*
name|data
init|=
name|tpd
decl_stmt|;
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Template"
argument_list|)
condition|)
comment|/* Might want to warn the user that the rcsinfo feature won't work.  */
return|return
literal|0
return|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Template "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|data
operator|->
name|update_dir
argument_list|,
name|data
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|template
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|server_template
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|struct
name|template_proc_data
name|data
decl_stmt|;
name|data
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|data
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|tpd
operator|=
operator|&
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_RCSINFO
argument_list|,
name|repository
argument_list|,
name|template_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_gzip_contents
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|level
operator|=
literal|6
expr_stmt|;
name|file_gzip_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_gzip_stream
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|level
operator|=
literal|6
expr_stmt|;
comment|/* All further communication with the client will be compressed.  */
name|buf_to_net
operator|=
name|compress_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|compress_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|level
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ignore
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/*      * Just ignore this command.  This is used to support the      * update-patches command, which is not a real command, but a signal      * to the client that update will accept the -u argument.      */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|expand_proc
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|where
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|omodule
parameter_list|,
name|msg
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|omodule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* If mwhere has been specified, the thing we're expanding is a        module -- just return its name so the client will ask for the        right thing later.  If it is an alias or a real directory,        mwhere will not be set, so send out the appropriate        expansion. */
if|if
condition|(
name|mwhere
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|mwhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We may not need to do this anymore -- check the definition            of aliases before removing */
if|if
condition|(
operator|*
name|pargc
operator|==
literal|1
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
operator|++
name|i
control|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_expand_modules
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|server_expanding
operator|=
literal|1
expr_stmt|;
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argument_count
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argument_vector
index|[
name|i
index|]
argument_list|,
name|CHECKOUT
argument_list|,
literal|"Updating"
argument_list|,
name|expand_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|server_expanding
operator|=
literal|0
expr_stmt|;
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
comment|/* We will have printed an error message already.  */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
comment|/* The client is waiting for the module expansions, so we must        send the output now.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_prog
parameter_list|(
name|dir
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|progs
name|which
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Set-checkin-prog"
argument_list|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E \ warning: this client does not support -i or -u flags in the modules file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PROG_CHECKIN
case|:
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Set-checkin-prog "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROG_UPDATE
case|:
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Set-update-prog "
argument_list|)
expr_stmt|;
break|break;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_checkin_prog
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_update_prog
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Before we do anything we need to make sure we are not in readonly        mode.  */
if|if
condition|(
operator|!
name|check_command_legal_p
argument_list|(
literal|"commit"
argument_list|)
condition|)
block|{
comment|/* I might be willing to make this a warning, except we lack the 	   machinery to do so.  */
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E Flag -u in modules not allowed in readonly mode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|serve_valid_requests
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * Parts of this table are shared with the client code,  * but the client doesn't need to know about the handler  * functions.  */
end_comment

begin_decl_stmt
name|struct
name|request
name|requests
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, f, s}
else|#
directive|else
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, s}
endif|#
directive|endif
name|REQ_LINE
argument_list|(
literal|"Root"
argument_list|,
name|serve_root
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Valid-responses"
argument_list|,
name|serve_valid_responses
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"valid-requests"
argument_list|,
name|serve_valid_requests
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Repository"
argument_list|,
name|serve_repository
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Directory"
argument_list|,
name|serve_directory
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Max-dotdot"
argument_list|,
name|serve_max_dotdot
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Static-directory"
argument_list|,
name|serve_static_directory
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Sticky"
argument_list|,
name|serve_sticky
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Checkin-prog"
argument_list|,
name|serve_checkin_prog
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Update-prog"
argument_list|,
name|serve_update_prog
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Entry"
argument_list|,
name|serve_entry
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Modified"
argument_list|,
name|serve_modified
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Is-modified"
argument_list|,
name|serve_is_modified
argument_list|,
name|rq_optional
argument_list|)
block|,
comment|/* The client must send this request to interoperate with CVS 1.5      through 1.9 servers.  The server must support it (although it can      be and is a noop) to interoperate with CVS 1.5 to 1.9 clients.  */
name|REQ_LINE
argument_list|(
literal|"UseUnchanged"
argument_list|,
name|serve_enable_unchanged
argument_list|,
name|rq_enableme
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Unchanged"
argument_list|,
name|serve_unchanged
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Notify"
argument_list|,
name|serve_notify
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Questionable"
argument_list|,
name|serve_questionable
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Case"
argument_list|,
name|serve_case
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argument"
argument_list|,
name|serve_argument
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argumentx"
argument_list|,
name|serve_argumentx
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Global_option"
argument_list|,
name|serve_global_option
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Gzip-stream"
argument_list|,
name|serve_gzip_stream
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Set"
argument_list|,
name|serve_set
argument_list|,
name|rq_optional
argument_list|)
block|,
ifdef|#
directive|ifdef
name|ENCRYPTION
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
name|REQ_LINE
argument_list|(
literal|"Kerberos-encrypt"
argument_list|,
name|serve_kerberos_encrypt
argument_list|,
name|rq_optional
argument_list|)
block|,
endif|#
directive|endif
endif|#
directive|endif
name|REQ_LINE
argument_list|(
literal|"expand-modules"
argument_list|,
name|serve_expand_modules
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"ci"
argument_list|,
name|serve_ci
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"co"
argument_list|,
name|serve_co
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update"
argument_list|,
name|serve_update
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"diff"
argument_list|,
name|serve_diff
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"log"
argument_list|,
name|serve_log
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"add"
argument_list|,
name|serve_add
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"remove"
argument_list|,
name|serve_remove
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update-patches"
argument_list|,
name|serve_ignore
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"gzip-file-contents"
argument_list|,
name|serve_gzip_contents
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"status"
argument_list|,
name|serve_status
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rdiff"
argument_list|,
name|serve_rdiff
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"tag"
argument_list|,
name|serve_tag
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rtag"
argument_list|,
name|serve_rtag
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"import"
argument_list|,
name|serve_import
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"admin"
argument_list|,
name|serve_admin
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"export"
argument_list|,
name|serve_export
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"history"
argument_list|,
name|serve_history
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"release"
argument_list|,
name|serve_release
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-on"
argument_list|,
name|serve_watch_on
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-off"
argument_list|,
name|serve_watch_off
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-add"
argument_list|,
name|serve_watch_add
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-remove"
argument_list|,
name|serve_watch_remove
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watchers"
argument_list|,
name|serve_watchers
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"editors"
argument_list|,
name|serve_editors
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"init"
argument_list|,
name|serve_init
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"annotate"
argument_list|,
name|serve_annotate
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"noop"
argument_list|,
name|serve_noop
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rq_optional
argument_list|)
undef|#
directive|undef
name|REQ_LINE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT or CLIENT_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|serve_valid_requests
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Valid-requests"
argument_list|)
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
name|rq
operator|++
control|)
block|{
if|if
condition|(
name|rq
operator|->
name|func
operator|!=
name|NULL
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|rq
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"\nok\n"
argument_list|)
expr_stmt|;
comment|/* The client is waiting for the list of valid requests, so we        must send the output now.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_comment
comment|/*  * Delete temporary files.  SIG is the signal making this happen, or  * 0 if not called as a result of a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_pid_is_dead
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|wait_sig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|r
init|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|server_cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* Do "rm -rf" on the temp directory.  */
name|int
name|status
decl_stmt|;
name|int
name|save_noexec
decl_stmt|;
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: If this is not the final call from server, this 	   could deadlock, because the client might be blocked writing 	   to us.  This should not be a problem in practice, because 	   we do not generate much output when the client is not 	   waiting for it.  */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The calls to buf_shutdown are currently only meaningful 	   when we are using compression.  First we shut down 	   BUF_FROM_NET.  That will pick up the checksum generated 	   when the client shuts down its buffer.  Then, after we have 	   generated any final output, we shut down BUF_TO_NET.  */
name|status
operator|=
name|buf_shutdown
argument_list|(
name|buf_from_net
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"shutting down buffer from client"
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dont_delete_temp
condition|)
block|{
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|buf_shutdown
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* What a bogus kludge.  This disgusting code makes all kinds of        assumptions about SunOS, and is only for a bug in that system.        So only enable it on Suns.  */
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
comment|/* To avoid crashes on SunOS due to bugs in SunOS tmpfs 	   triggered by the use of rename() in RCS, wait for the 	   subprocess to die.  Unfortunately, this means draining output 	   while waiting for it to unblock the signal we sent it.  Yuck!  */
name|int
name|status
decl_stmt|;
name|pid_t
name|r
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|wait_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
condition|)
comment|/* Perhaps SIGTERM would be more correct.  But the child 	       process will delay the SIGINT delivery until its own 	       children have exited.  */
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* The caller may also have sent a signal to command_pid, so 	   always try waiting.  First, though, check and see if it's still 	   there....  */
name|do_waitpid
label|:
name|r
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECHILD
case|:
name|command_pid_is_dead
operator|++
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
goto|goto
name|do_waitpid
goto|;
block|}
else|else
comment|/* waitpid should always return one of the above values */
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|command_pid_is_dead
condition|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|fd_set_wrapper
name|readfds
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Use a non-zero timeout to avoid eating up CPU cycles.  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|readfds
operator|=
name|command_fds_to_drain
expr_stmt|;
switch|switch
condition|(
name|select
argument_list|(
name|max_command_fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|0
case|:
comment|/* timeout */
break|break;
case|case
literal|1
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_command_fd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|)
condition|)
continue|continue;
comment|/* this fd is non-blocking */
while|while
condition|(
name|read
argument_list|(
name|i
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
literal|1
condition|)
empty_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|CVS_CHDIR
argument_list|(
name|Tmpdir
argument_list|)
expr_stmt|;
comment|/* Temporarily clear noexec, so that we clean up our temp directory        regardless of it (this could more cleanly be handled by moving        the noexec check to all the unlink_file_dir callers from        unlink_file_dir itself).  */
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
comment|/* FIXME?  Would be nice to not ignore errors.  But what should we do?        We could try to do this before we shut down the network connection,        and try to notify the client (but the client might not be waiting        for responses).  We could try something like syslog() or our own        log file.  */
name|unlink_file_dir
argument_list|(
name|orig_server_temp_dir
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|buf_shutdown
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|server_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|server_expanding
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|server
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"  Normally invoked by a cvs client on a remote machine.\n"
block|,
name|NULL
block|}
decl_stmt|;
name|usage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore argc and argv.  They might be from .cvsrc.  */
name|buf_to_net
operator|=
name|fd_buffer_initialize
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|stdio_buffer_initialize
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|,
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|saved_output
operator|=
name|buf_nonio_initialize
argument_list|(
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|saved_outerr
operator|=
name|buf_nonio_initialize
argument_list|(
name|outbuf_memory_error
argument_list|)
expr_stmt|;
comment|/* Since we're in the server parent process, error should use the        protocol to report error messages.  */
name|error_use_protocol
operator|=
literal|1
expr_stmt|;
comment|/*      * Put Rcsbin at the start of PATH, so that rcs programs can find      * themselves.      */
ifdef|#
directive|ifdef
name|HAVE_PUTENV
if|if
condition|(
name|Rcsbin
operator|!=
name|NULL
operator|&&
operator|*
name|Rcsbin
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
sizeof|sizeof
expr|"PATH=:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"PATH=%s:%s"
argument_list|,
name|Rcsbin
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
sizeof|sizeof
expr|"PATH="
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"PATH=%s"
argument_list|,
name|Rcsbin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	       because I'm not sure whether we want to call server_cleanup. 	       Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	       NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OK, now figure out where we stash our temporary files.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The code which wants to chdir into server_temp_dir is not set 	   up to deal with it being a relative path.  So give an error 	   for that case.  */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|Tmpdir
argument_list|)
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Value of %s for TMPDIR is not absolute"
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: we would like this error to be persistent, that 	       is, not cleared by print_pending_error.  The current client 	       will exit as soon as it gets an error, but the protocol spec 	       does not require a client to do so.  */
block|}
else|else
block|{
name|int
name|status
decl_stmt|;
name|server_temp_dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_temp_dir
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Strictly speaking, we're not supposed to output anything 		 * now.  But we're about to exit(), give it a try. 		 */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 		   because I'm not sure whether we want to call server_cleanup. 		   Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket 		   subsystems on NT and OS2 or dealing with windows 		   and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|server_temp_dir
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
comment|/* Remove a trailing slash from TMPDIR if present.  */
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * I wanted to use cvs-serv/PID, but then you have to worry about 	     * the permissions on the cvs-serv directory being right.  So 	     * use cvs-servPID. 	     */
name|strcat
argument_list|(
name|server_temp_dir
argument_list|,
literal|"/cvs-serv"
argument_list|)
expr_stmt|;
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|orig_server_temp_dir
operator|=
name|server_temp_dir
expr_stmt|;
comment|/* Create the temporary directory, and set the mode to                700, to discourage random people from tampering with                it.  */
name|status
operator|=
name|mkdir_p
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E can't create temporary directory"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CHMOD_BROKEN
else|else
block|{
if|if
condition|(
name|chmod
argument_list|(
name|server_temp_dir
argument_list|,
name|S_IRWXU
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E cannot change permissions on temporary directory"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now initialize our argument vector (for arguments from the client).  */
comment|/* Small for testing.  */
name|argument_vector_size
operator|=
literal|1
expr_stmt|;
name|argument_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument_vector
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Strictly speaking, we're not supposed to output anything 	 * now.  But we're about to exit(), give it a try. 	 */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	   because I'm not sure whether we want to call server_cleanup. 	   Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|argument_count
operator|=
literal|1
expr_stmt|;
comment|/* This gets printed if the client supports an option which the        server doesn't, causing the server to print a usage message.        FIXME: probably should be using program_name here.        FIXME: just a nit, I suppose, but the usage message the server        prints isn't literally true--it suggests "cvs server" followed        by options which are for a particular command.  Might be nice to        say something like "client apparently supports an option not supported        by this server" or something like that instead of usage message.  */
name|argument_vector
index|[
literal|0
index|]
operator|=
literal|"cvs server"
expr_stmt|;
name|server_active
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|orig_cmd
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|cmd
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|orig_cmd
operator|=
name|cmd
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
name|rq
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
name|cmd
operator|+=
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|cmd
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
else|else
comment|/* 		     * The first len characters match, but it's a different 		     * command.  e.g. the command is "cooperate" but we matched 		     * "co". 		     */
continue|continue;
call|(
modifier|*
name|rq
operator|->
name|func
call|)
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rq
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|print_pending_error
argument_list|()
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  unrecognized request `"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|orig_cmd
argument_list|)
expr_stmt|;
block|}
name|server_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|||
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|switch_to_user
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|switch_to_user
parameter_list|(
name|username
parameter_list|)
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	   because I'm not sure whether we want to call server_cleanup. 	   Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_INITGROUPS
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_INITGROUPS */
ifdef|#
directive|ifdef
name|SETXID_SUPPORT
comment|/* honor the setgid bit iff set*/
if|if
condition|(
name|getgid
argument_list|()
operator|!=
name|getegid
argument_list|()
condition|)
block|{
name|setgid
argument_list|(
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
else|#
directive|else
block|{
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* We don't want our umask to change file modes.  The modes should        be set by the modes used in the repository, and by the umask of        the client.  */
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_PUTENV
comment|/* Set LOGNAME and USER in the environment, in case they are        already set to something else.  */
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"LOGNAME="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"LOGNAME=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"USER="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"USER=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_PUTENV */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|crypt
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*   * 0 means no entry found for this user.  * 1 means entry found and password matches.  * 2 means entry found, but password does not match.  *  * If success, host_user_ptr will be set to point at the system  * username (i.e., the "real" identity, which may or may not be the  * CVS username) of this user; caller may free this.  Global  * CVS_Username will point at an allocated copy of cvs username (i.e.,  * the username argument below).  */
end_comment

begin_function
specifier|static
name|int
name|check_repository_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|,
name|host_user_ptr
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|,
modifier|*
modifier|*
name|host_user_ptr
decl_stmt|;
end_function

begin_block
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* We don't use CVSroot_directory because it hasn't been set yet      * -- our `repository' argument came from the authentication      * protocol, not the regular CVS protocol.      */
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_PASSWD
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_PASSWD
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for a relevant line -- one with this user's name. */
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|linebuf
argument_list|,
name|username
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|namelen
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* If found_it != 0, then linebuf contains the information we need. */
if|if
condition|(
name|found_it
condition|)
block|{
name|char
modifier|*
name|found_password
decl_stmt|,
modifier|*
name|host_user_tmp
decl_stmt|;
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|found_password
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
name|host_user_tmp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_user_tmp
operator|==
name|NULL
condition|)
name|host_user_tmp
operator|=
name|username
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|found_password
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_password
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Give host_user_ptr permanent storage. */
operator|*
name|host_user_ptr
operator|=
name|xstrdup
argument_list|(
name|host_user_tmp
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|host_user_ptr
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|host_user_ptr
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_comment
comment|/* Return a hosting username if password matches, else NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|host_user
init|=
name|NULL
decl_stmt|;
comment|/* First we see if this user has a password in the CVS-specific        password file.  If so, that's enough to authenticate with.  If        not, we'll check /etc/passwd. */
name|rc
operator|=
name|check_repository_password
argument_list|(
name|username
argument_list|,
name|password
argument_list|,
name|repository
argument_list|,
operator|&
name|host_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
return|return
name|NULL
return|;
comment|/* else */
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
comment|/* host_user already set by reference, so just return. */
goto|goto
name|handle_return
goto|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* No cvs password found, so try /etc/passwd. */
specifier|const
name|char
modifier|*
name|found_passwd
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
name|struct
name|spwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getspnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
name|found_passwd
operator|=
name|pw
operator|->
name|sp_pwdp
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
name|found_passwd
operator|=
name|pw
operator|->
name|pw_passwd
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	       because I'm not sure whether we want to call server_cleanup. 	       Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	       NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found_passwd
operator|&&
operator|*
name|found_passwd
condition|)
block|{
name|host_user
operator|=
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|found_passwd
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_passwd
argument_list|)
argument_list|)
operator|)
condition|?
name|username
else|:
name|NULL
operator|)
expr_stmt|;
goto|goto
name|handle_return
goto|;
block|}
elseif|else
if|if
condition|(
name|password
operator|&&
operator|*
name|password
condition|)
block|{
name|host_user
operator|=
name|username
expr_stmt|;
goto|goto
name|handle_return
goto|;
block|}
else|else
block|{
name|host_user
operator|=
name|NULL
expr_stmt|;
goto|goto
name|handle_return
goto|;
block|}
block|}
else|else
block|{
comment|/* Something strange happened.  We don't know what it was, but 	   we certainly won't grant authorization. */
name|host_user
operator|=
name|NULL
expr_stmt|;
goto|goto
name|handle_return
goto|;
block|}
name|handle_return
label|:
if|if
condition|(
name|host_user
condition|)
block|{
comment|/* Set CVS_Username here, in allocated space.             It might or might not be the same as host_user. */
name|CVS_Username
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|CVS_Username
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
return|return
name|host_user
return|;
block|}
end_block

begin_comment
comment|/* Read username and password from client (i.e., stdin).    If correct, then switch to run as that user and send an ACK to the    client via stdout, else send NACK and die. */
end_comment

begin_function
name|void
name|pserver_authenticate_connection
parameter_list|()
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|size_t
name|tmp_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
name|size_t
name|repository_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
name|size_t
name|username_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|size_t
name|password_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|host_user
decl_stmt|;
name|char
modifier|*
name|descrambled_password
decl_stmt|;
name|int
name|verify_and_exit
init|=
literal|0
decl_stmt|;
comment|/* The Authentication Protocol.  Client sends:      *      *   BEGIN AUTH REQUEST\n      *<REPOSITORY>\n      *<USERNAME>\n      *<PASSWORD>\n      *   END AUTH REQUEST\n      *      * Server uses above information to authenticate, then sends      *      *   I LOVE YOU\n      *      * if it grants access, else      *      *   I HATE YOU\n      *      * if it denies access (and it exits if denying).      *      * When the client is "cvs login", the user does not desire actual      * repository access, but would like to confirm the password with      * the server.  In this case, the start and stop strings are      *      *   BEGIN VERIFICATION REQUEST\n      *      *            and      *      *   END VERIFICATION REQUEST\n      *      * On a verification request, the server's responses are the same      * (with the obvious semantics), but it exits immediately after      * sending the response in both cases.      *      * Why is the repository sent?  Well, note that the actual      * client/server protocol can't start up until authentication is      * successful.  But in order to perform authentication, the server      * needs to look up the password in the special CVS passwd file,      * before trying /etc/passwd.  So the client transmits the      * repository as part of the "authentication protocol".  The      * repository will be redundantly retransmitted later, but that's no      * big deal.      */
ifdef|#
directive|ifdef
name|SO_KEEPALIVE
comment|/* Set SO_KEEPALIVE on the socket, so that we don't hang forever        if the client dies while we are waiting for input.  */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|STDIN_FILENO
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make sure the protocol starts off on the right foot... */
if|if
condition|(
name|getline
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_allocated
argument_list|,
name|stdin
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME: what?  We could try writing error/eof, but chances 	   are the network connection is dead bidirectionally.  log it 	   somewhere?  */
empty_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN VERIFICATION REQUEST\n"
argument_list|)
operator|==
literal|0
condition|)
name|verify_and_exit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN AUTH REQUEST\n"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol start: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Get the three important pieces of information in order. */
comment|/* See above comment about error handling.  */
name|getline
argument_list|(
operator|&
name|repository
argument_list|,
operator|&
name|repository_allocated
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|&
name|username
argument_list|,
operator|&
name|username_allocated
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|&
name|password
argument_list|,
operator|&
name|password_allocated
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* Make them pure. */
name|strip_trailing_newlines
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|strip_trailing_newlines
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|strip_trailing_newlines
argument_list|(
name|password
argument_list|)
expr_stmt|;
comment|/* ... and make sure the protocol ends on the right foot. */
comment|/* See above comment about error handling.  */
name|getline
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_allocated
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
name|verify_and_exit
condition|?
literal|"END VERIFICATION REQUEST\n"
else|:
literal|"END AUTH REQUEST\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol end: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* We need the real cleartext before we hash it. */
name|descrambled_password
operator|=
name|descramble
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|host_user
operator|=
name|check_password
argument_list|(
name|username
argument_list|,
name|descrambled_password
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|descrambled_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|descrambled_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descrambled_password
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_user
condition|)
block|{
name|printf
argument_list|(
literal|"I LOVE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"I HATE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	   because I'm not sure whether we want to call server_cleanup. 	   Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Don't go any farther if we're just responding to "cvs login". */
if|if
condition|(
name|verify_and_exit
condition|)
block|{
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set Pserver_Repos so that we can check later that the same        repository is sent in later client/server protocol. */
name|Pserver_Repos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Pserver_Repos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* Switch to run as this user. */
name|switch_to_user
argument_list|(
name|host_user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_function
name|void
name|kserver_authenticate_connection
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|char
name|instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|peer
decl_stmt|;
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|AUTH_DAT
name|auth
decl_stmt|;
name|char
name|version
index|[
name|KRB_SENDAUTH_VLEN
index|]
decl_stmt|;
name|char
name|user
index|[
name|ANAME_SZ
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|instance
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|peer
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peer
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
operator|||
name|getsockname
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|laddr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error %s getpeername or getsockname failed\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_KEEPALIVE
comment|/* Set SO_KEEPALIVE on the socket, so that we don't hang forever        if the client dies while we are waiting for input.  */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|STDIN_FILENO
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|krb_recvauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|STDIN_FILENO
argument_list|,
operator|&
name|ticket
argument_list|,
literal|"rcmd"
argument_list|,
name|instance
argument_list|,
operator|&
name|peer
argument_list|,
operator|&
name|laddr
argument_list|,
operator|&
name|auth
argument_list|,
literal|""
argument_list|,
name|sched
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|kblock
argument_list|,
name|auth
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the local name.  */
name|status
operator|=
name|krb_kntoln
argument_list|(
operator|&
name|auth
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: can't get local name: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Switch to run as this user. */
name|switch_to_user
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* This global variable is non-zero if the user requests encryption on    the command line.  */
end_comment

begin_decl_stmt
name|int
name|cvsencrypt
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_comment
comment|/* An encryption interface using Kerberos.  This is built on top of    the buffer structure.  We encrypt using a big endian two byte count    field followed by a block of encrypted data.  */
end_comment

begin_comment
comment|/* This structure is the closure field of a Kerberos encryption    buffer.  */
end_comment

begin_struct
struct|struct
name|krb_encrypt_buffer
block|{
comment|/* The underlying buffer.  */
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
comment|/* The Kerberos key schedule.  */
name|Key_schedule
name|sched
decl_stmt|;
comment|/* The Kerberos DES block.  */
name|C_Block
name|block
decl_stmt|;
comment|/* For an input buffer, we may have to buffer up data here.  */
comment|/* This is non-zero if the buffered data is decrypted.  Otherwise,        the buffered data is encrypted, and starts with the two byte        count.  */
name|int
name|clear
decl_stmt|;
comment|/* The amount of buffered data.  */
name|int
name|holdsize
decl_stmt|;
comment|/* The buffer allocated to hold the data.  */
name|char
modifier|*
name|holdbuf
decl_stmt|;
comment|/* The size of holdbuf.  */
name|int
name|holdbufsize
decl_stmt|;
comment|/* If clear is set, we need another data pointer to track where we        are in holdbuf.  If clear is zero, then this pointer is not        used.  */
name|char
modifier|*
name|holddata
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_buffer_shutdown
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an encryption buffer.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|krb_encrypt_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|input
parameter_list|,
name|sched
parameter_list|,
name|block
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|input
decl_stmt|;
name|Key_schedule
name|sched
decl_stmt|;
name|C_Block
name|block
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
decl_stmt|;
name|kb
operator|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|kb
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|kb
argument_list|)
expr_stmt|;
name|kb
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|memcpy
argument_list|(
name|kb
operator|->
name|sched
argument_list|,
name|sched
argument_list|,
sizeof|sizeof
argument_list|(
name|Key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kb
operator|->
name|block
argument_list|,
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
condition|)
block|{
comment|/* We add some space to the buffer to hold the length.  */
name|kb
operator|->
name|holdbufsize
operator|=
name|BUFFER_DATA_SIZE
operator|+
literal|16
expr_stmt|;
name|kb
operator|->
name|holdbuf
operator|=
name|xmalloc
argument_list|(
name|kb
operator|->
name|holdbufsize
argument_list|)
expr_stmt|;
block|}
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|krb_encrypt_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|krb_encrypt_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|krb_encrypt_buffer_flush
argument_list|,
name|krb_encrypt_buffer_block
argument_list|,
name|krb_encrypt_buffer_shutdown
argument_list|,
name|memory
argument_list|,
name|kb
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Input data from a Kerberos encryption buffer.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
init|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kb
operator|->
name|holdsize
operator|>
literal|0
operator|&&
name|kb
operator|->
name|clear
condition|)
block|{
name|int
name|copy
decl_stmt|;
name|copy
operator|=
name|kb
operator|->
name|holdsize
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|size
condition|)
block|{
name|memcpy
argument_list|(
name|data
argument_list|,
name|kb
operator|->
name|holddata
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|kb
operator|->
name|holdsize
operator|-=
name|size
expr_stmt|;
name|kb
operator|->
name|holddata
operator|+=
name|size
expr_stmt|;
operator|*
name|got
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|kb
operator|->
name|holddata
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|kb
operator|->
name|holdsize
operator|=
literal|0
expr_stmt|;
name|kb
operator|->
name|clear
operator|=
literal|0
expr_stmt|;
name|data
operator|+=
name|copy
expr_stmt|;
name|need
operator|-=
name|copy
expr_stmt|;
name|size
operator|-=
name|copy
expr_stmt|;
operator|*
name|got
operator|=
name|copy
expr_stmt|;
block|}
while|while
condition|(
name|need
operator|>
literal|0
operator|||
operator|*
name|got
operator|==
literal|0
condition|)
block|{
name|int
name|get
decl_stmt|,
name|status
decl_stmt|,
name|nread
decl_stmt|,
name|count
decl_stmt|,
name|dcount
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
name|char
name|stackoutbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
comment|/* If we don't already have the two byte count, get it.  */
if|if
condition|(
name|kb
operator|->
name|holdsize
operator|<
literal|2
condition|)
block|{
name|get
operator|=
literal|2
operator|-
name|kb
operator|->
name|holdsize
expr_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|kb
operator|->
name|buf
argument_list|,
name|get
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* buf_read_data can return -2, but a buffer input                    function is only supposed to return -1, 0, or an                    error code.  */
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|status
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
comment|/* The buffer is in nonblocking mode, and we didn't                    manage to read anything.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|get
operator|==
literal|1
condition|)
name|kb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|=
name|bytes
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|kb
operator|->
name|holdbuf
index|[
literal|0
index|]
operator|=
name|bytes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|2
condition|)
block|{
comment|/* We only got one byte, but we needed two.  Stash                        the byte we got, and try again.  */
name|kb
operator|->
name|holdsize
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|kb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|=
name|bytes
index|[
literal|1
index|]
expr_stmt|;
block|}
name|kb
operator|->
name|holdsize
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Read the encrypted block of data.  */
name|count
operator|=
operator|(
operator|(
operator|(
name|kb
operator|->
name|holdbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|kb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|2
operator|>
name|kb
operator|->
name|holdbufsize
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
comment|/* This should be impossible, since we should have 	       allocated space for the largest possible block in the 	       initialize function.  However, we handle it just in 	       case something changes in the future, so that a current 	       server can handle a later client.  */
name|n
operator|=
name|realloc
argument_list|(
name|kb
operator|->
name|holdbuf
argument_list|,
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|kb
operator|->
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|kb
operator|->
name|holdbuf
operator|=
name|n
expr_stmt|;
name|kb
operator|->
name|holdbufsize
operator|=
name|count
operator|+
literal|2
expr_stmt|;
block|}
name|get
operator|=
name|count
operator|-
operator|(
name|kb
operator|->
name|holdsize
operator|-
literal|2
operator|)
expr_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|kb
operator|->
name|buf
argument_list|,
name|get
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* buf_read_data can return -2, but a buffer input                function is only supposed to return -1, 0, or an error                code.  */
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|status
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
comment|/* We did not get any data.  Presumably the buffer is in                nonblocking mode.  */
return|return
literal|0
return|;
block|}
comment|/* FIXME: We could complicate the code here to avoid this            memcpy in the common case of kb->holdsize == 2&& nread ==            get.  */
name|memcpy
argument_list|(
name|kb
operator|->
name|holdbuf
operator|+
name|kb
operator|->
name|holdsize
argument_list|,
name|bytes
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|kb
operator|->
name|holdsize
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|nread
operator|<
name|get
condition|)
block|{
comment|/* We did not get all the data we need.  buf_read_data                does not promise to return all the bytes requested, so                we must try again.  */
continue|continue;
block|}
comment|/* We have a complete encrypted block of COUNT bytes at            KB->HOLDBUF + 2.  Decrypt it.  */
if|if
condition|(
name|count
operator|<=
sizeof|sizeof
name|stackoutbuf
condition|)
name|outbuf
operator|=
name|stackoutbuf
expr_stmt|;
else|else
block|{
comment|/* I believe this is currently impossible, but we handle                it for the benefit of future client changes.  */
name|outbuf
operator|=
name|malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|kb
operator|->
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
name|des_cbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
operator|(
name|kb
operator|->
name|holdbuf
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|outbuf
argument_list|,
name|count
argument_list|,
name|kb
operator|->
name|sched
argument_list|,
operator|&
name|kb
operator|->
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The first two bytes in the decrypted buffer are the real            (unaligned) length.  */
name|dcount
operator|=
operator|(
operator|(
name|outbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|outbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|dcount
operator|+
literal|2
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|!=
name|count
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Decryption failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcount
operator|>
name|size
condition|)
block|{
comment|/* We have too much data for the buffer.  We need to save                some of it for the next call.  */
name|memcpy
argument_list|(
name|data
argument_list|,
name|outbuf
operator|+
literal|2
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|got
operator|+=
name|size
expr_stmt|;
name|kb
operator|->
name|holdsize
operator|=
name|dcount
operator|-
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|kb
operator|->
name|holdbuf
argument_list|,
name|outbuf
operator|+
literal|2
operator|+
name|size
argument_list|,
name|dcount
operator|-
name|size
argument_list|)
expr_stmt|;
name|kb
operator|->
name|holddata
operator|=
name|kb
operator|->
name|holdbuf
expr_stmt|;
name|kb
operator|->
name|clear
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|outbuf
operator|!=
name|stackoutbuf
condition|)
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|outbuf
operator|+
literal|2
argument_list|,
name|dcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|!=
name|stackoutbuf
condition|)
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|kb
operator|->
name|holdsize
operator|=
literal|0
expr_stmt|;
name|data
operator|+=
name|dcount
expr_stmt|;
name|need
operator|-=
name|dcount
expr_stmt|;
name|size
operator|-=
name|dcount
expr_stmt|;
operator|*
name|got
operator|+=
name|dcount
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output data to a Kerberos encryption buffer.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
init|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|char
name|inbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
literal|16
index|]
decl_stmt|;
name|char
name|outbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
literal|16
index|]
decl_stmt|;
name|int
name|aligned
decl_stmt|;
if|if
condition|(
name|have
operator|>
name|BUFFER_DATA_SIZE
condition|)
block|{
comment|/* It would be easy to malloc a buffer, but I don't think this            case can ever arise.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|inbuf
index|[
literal|0
index|]
operator|=
operator|(
name|have
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|inbuf
index|[
literal|1
index|]
operator|=
name|have
operator|&
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
name|inbuf
operator|+
literal|2
argument_list|,
name|data
argument_list|,
name|have
argument_list|)
expr_stmt|;
comment|/* For security against a known plaintext attack, we should        initialize any padding bytes to random values.  Instead, we        just pick up whatever is on the stack, which is at least better        than using zero.  */
comment|/* Align (have + 2) (plus 2 for the count) to an 8 byte boundary.  */
name|aligned
operator|=
operator|(
name|have
operator|+
literal|2
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* We use des_cbc_encrypt rather than krb_mk_priv because the        latter sticks a timestamp in the block, and krb_rd_priv expects        that timestamp to be within five minutes of the current time.        Given the way the CVS server buffers up data, that can easily        fail over a long network connection.  We trust krb_recvauth to        guard against a replay attack.  */
name|des_cbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|inbuf
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
operator|(
name|outbuf
operator|+
literal|2
operator|)
argument_list|,
name|aligned
argument_list|,
name|kb
operator|->
name|sched
argument_list|,
operator|&
name|kb
operator|->
name|block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outbuf
index|[
literal|0
index|]
operator|=
operator|(
name|aligned
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|outbuf
index|[
literal|1
index|]
operator|=
name|aligned
operator|&
literal|0xff
expr_stmt|;
comment|/* FIXME: It would be more efficient to get des_cbc_encrypt to put        its output directly into a buffer_data structure, which we        could then append to kb->buf.  That would save a memcpy.  */
name|buf_output
argument_list|(
name|kb
operator|->
name|buf
argument_list|,
name|outbuf
argument_list|,
name|aligned
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|wrote
operator|=
name|have
expr_stmt|;
comment|/* We will only be here because buf_send_output was called on the        encryption buffer.  That means that we should now call        buf_send_output on the underlying buffer.  */
return|return
name|buf_send_output
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Flush data to a Kerberos encryption buffer.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
init|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|closure
decl_stmt|;
comment|/* Flush the underlying buffer.  Note that if the original call to        buf_flush passed 1 for the BLOCK argument, then the buffer will        already have been set into blocking mode, so we should always        pass 0 here.  */
return|return
name|buf_flush
argument_list|(
name|kb
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The block routine for a Kerberos encryption buffer.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
init|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|set_block
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
name|set_nonblock
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Shut down a Kerberos encryption buffer.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_buffer_shutdown
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|krb_encrypt_buffer
modifier|*
name|kb
init|=
operator|(
expr|struct
name|krb_encrypt_buffer
operator|*
operator|)
name|closure
decl_stmt|;
return|return
name|buf_shutdown
argument_list|(
name|kb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENCRYPTION */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
end_comment

begin_comment
comment|/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)    the first '\0' byte.  */
end_comment

begin_function
name|void
name|cvs_output
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
name|buf_output
argument_list|(
name|saved_output
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
name|buf_output
argument_list|(
name|saved_output
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|protocol
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like CVS_OUTPUT but output is for stderr not stdout.  */
end_comment

begin_function
name|void
name|cvs_outerr
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
name|buf_output
argument_list|(
name|saved_outerr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
name|buf_output
argument_list|(
name|saved_outerr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|protocol
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
comment|/* Make sure that output appears in order if stdout and stderr 	   point to the same place.  For the server case this is taken 	   care of by the fact that saved_outerr always holds less 	   than a line.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Flush stderr.  stderr is normally flushed automatically, of course,    but this function is used to flush information from the server back    to the client.  */
end_comment

begin_function
name|void
name|cvs_flusherr
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
comment|/* Flush what we can to the network, but don't block.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* Send a special count to tell the parent to flush.  */
name|buf_send_special_count
argument_list|(
name|protocol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make it possible for the user to see what has been written to    stdout (it is up to the implementation to decide exactly how far it    should go to ensure this).  */
end_comment

begin_function
name|void
name|cvs_flushout
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
comment|/* Flush what we can to the network, but don't block.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* Just do nothing.  This is because the code which 	   cvs_flushout replaces, setting stdout to line buffering in 	   main.c, didn't get called in the server child process.  But 	   in the future it is quite plausible that we'll want to make 	   this case work analogously to cvs_flusherr.  */
block|}
else|else
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

