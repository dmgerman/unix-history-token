begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, Cyclic Software, Bloomington, IN, USA  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with CVS.  *   * Allow user to log in for an authenticating server.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* This covers the rest of the file. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPASSPHRASE
end_ifdef

begin_define
define|#
directive|define
name|GETPASS
value|getpassphrase
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETPASS
value|getpass
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* There seems to be very little agreement on which system header    getpass is declared in.  With a lot of fancy autoconfiscation,    we could perhaps detect this, but for now we'll just rely on    _CRAY, since Cray is perhaps the only system on which our own    declaration won't work (some Crays declare the 2#$@% thing as    varadic, believe it or not).  On Cray, getpass will be declared    in either stdlib.h or unistd.h.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CRAY
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|GETPASS
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVS_PASSWORD_FILE
end_ifndef

begin_define
define|#
directive|define
name|CVS_PASSWORD_FILE
value|".cvspass"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-NULL, get_cvs_password() will just return this. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cvs_password
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|construct_cvspass_filename
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The return value will need to be freed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|construct_cvspass_filename
parameter_list|()
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
name|char
modifier|*
name|passfile
decl_stmt|;
comment|/* Environment should override file. */
if|if
condition|(
operator|(
name|passfile
operator|=
name|getenv
argument_list|(
literal|"CVS_PASSFILE"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|passfile
argument_list|)
return|;
comment|/* Construct absolute pathname to user's password file. */
comment|/* todo: does this work under OS/2 ? */
name|homedir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
block|{
comment|/* FIXME?  This message confuses a lot of users, at least 	   on Win95 (which doesn't set HOMEDRIVE and HOMEPATH like 	   NT does).  I suppose the answer for Win95 is to store the 	   passwords in the registry or something (??).  And .cvsrc 	   and such too?  Wonder what WinCVS does (about .cvsrc, the 	   right thing for a GUI is to just store the password in 	   memory only)...  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not find out home directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|passfile
operator|=
name|strcat_filename_onto_homedir
argument_list|(
name|homedir
argument_list|,
name|CVS_PASSWORD_FILE
argument_list|)
expr_stmt|;
comment|/* Safety first and last, Scouts. */
if|if
condition|(
name|isfile
argument_list|(
name|passfile
argument_list|)
condition|)
comment|/* xchmod() is too polite. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
return|return
name|passfile
return|;
block|}
end_function

begin_comment
comment|/*  * static char *  * password_entry_parseline (  *			      const char *cvsroot_canonical,  *			      const unsigned char warn,  *			      const int linenumber,  *			      char *linebuf  *			     );  *  * Internal function used by password_entry_operation.  Parse a single line  * from a ~/.cvsroot password file and return a pointer to the password if the  * line refers to the same cvsroot as cvsroot_canonical  *  * INPUTS  *	cvsroot_canonical	the root we are looking for  *	warn			Boolean: print warnings for invalid lines?  *	linenumber		the line number for error messages  *	linebuf			the current line  *  * RETURNS  * 	NULL			if the line doesn't match  * 	char *password		as a pointer into linebuf  *  * NOTES  *	This function temporarily alters linebuf, so it isn't thread safe when  *	called on the same linebuf  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|password_entry_parseline
parameter_list|(
name|cvsroot_canonical
parameter_list|,
name|warn
parameter_list|,
name|linenumber
parameter_list|,
name|linebuf
parameter_list|)
specifier|const
name|char
modifier|*
name|cvsroot_canonical
decl_stmt|;
specifier|const
name|unsigned
name|char
name|warn
decl_stmt|;
specifier|const
name|int
name|linenumber
decl_stmt|;
name|char
modifier|*
name|linebuf
decl_stmt|;
block|{
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* look for '^/' */
if|if
condition|(
operator|*
name|linebuf
operator|==
literal|'/'
condition|)
block|{
comment|/* Yes: slurp '^/\d+\D' and parse the rest of the line according to version number */
name|char
modifier|*
name|q
decl_stmt|;
name|unsigned
name|long
name|int
name|entry_version
decl_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|linebuf
operator|+
literal|1
operator|)
argument_list|)
condition|)
comment|/* special case since strtoul ignores leading white space */
name|q
operator|=
name|linebuf
operator|+
literal|1
expr_stmt|;
else|else
name|entry_version
operator|=
name|strtoul
argument_list|(
name|linebuf
operator|+
literal|1
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|linebuf
operator|+
literal|1
condition|)
comment|/* no valid digits found by strtoul */
name|entry_version
operator|=
literal|0
expr_stmt|;
else|else
comment|/* assume a delimiting seperator */
name|q
operator|++
expr_stmt|;
switch|switch
condition|(
name|entry_version
condition|)
block|{
case|case
literal|1
case|:
comment|/* this means the same normalize_cvsroot we are using was 		 * used to create this entry.  strcmp is good enough for 		 * us. 		 */
name|p
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipping invalid entry in password file at line %d"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cvsroot_canonical
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
name|password
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|ULONG_MAX
case|:
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: unable to convert version number in password file at line %d"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"skipping entry"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipping entry with invalid version string in password file at line %d"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipping entry with unknown version (%lu) in password file at line %d"
argument_list|,
name|entry_version
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* No: assume: 	 * 	 *	^cvsroot Aencoded_password$ 	 * 	 * as header comment specifies and parse accordingly 	 */
name|cvsroot_t
modifier|*
name|tmp_root
decl_stmt|;
name|char
modifier|*
name|tmp_root_canonical
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|linebuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipping invalid entry in password file at line %d"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
empty_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_root
operator|=
name|parse_cvsroot
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: skipping invalid entry in password file at line %d"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|tmp_root_canonical
operator|=
name|normalize_cvsroot
argument_list|(
name|tmp_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cvsroot_canonical
argument_list|,
name|tmp_root_canonical
argument_list|)
operator|==
literal|0
condition|)
name|password
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|tmp_root_canonical
argument_list|)
expr_stmt|;
name|free_cvsroot_t
argument_list|(
name|tmp_root
argument_list|)
expr_stmt|;
block|}
return|return
name|password
return|;
block|}
end_function

begin_comment
comment|/*  * static char *  * password_entry_operation (  * 			     password_entry_operation_t operation,  * 			     cvsroot_t *root,  * 			     char *newpassword  * 			    );  *  * Search the password file and depending on the value of operation:  *  *	Mode				Action  *	password_entry_lookup		Return the password  *	password_entry_delete		Delete the entry from the file, if it exists  *	password_entry_add		Replace the line with the new one, else append it  *  * Because the user might be accessing multiple repositories, with  * different passwords for each one, the format of ~/.cvspass is:  *  * [user@]host:[port]/path Aencoded_password  * [user@]host:[port]/path Aencoded_password  * ...  *  * New entries are always of the form:  *  * /1 user@host:port/path Aencoded_password  *  * but the old format is supported for backwards compatibility.  * The entry version string wasn't strictly necessary, but it avoids the  * overhead of parsing some entries since we know it is already in canonical  * form and allows room for expansion later, say, if we want to allow spaces  * and/or other characters to be escaped in the string.  Also, the new entries  * would have been ignored by old versions of CVS anyhow since those versions  * didn't know how to parse a port number.  *  * The "A" before "encoded_password" is a literal capital A.  It's a  * version number indicating which form of scrambling we're doing on  * the password -- someday we might provide something more secure than  * the trivial encoding we do now, and when that day comes, it would  * be nice to remain backward-compatible.  *  * Like .netrc, the file's permissions are the only thing preventing  * it from being read by others.  Unlike .netrc, we will not be  * fascist about it, at most issuing a warning, and never refusing to  * work.  *  * INPUTS  * 	operation	operation to perform  * 	root		cvsroot_t to look up  * 	newpassword	prescrambled new password, for password_entry_add_mode  *  * RETURNS  * 	-1	if password_entry_lookup_mode not specified  * 	NULL	on failed lookup  * 	pointer to a copy of the password string otherwise, which the caller is  * 		responsible for disposing of  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|password_entry_operation_e
block|{
name|password_entry_lookup
block|,
name|password_entry_delete
block|,
name|password_entry_add
block|}
name|password_entry_operation_t
typedef|;
end_typedef

begin_function
specifier|static
name|char
modifier|*
name|password_entry_operation
parameter_list|(
name|operation
parameter_list|,
name|root
parameter_list|,
name|newpassword
parameter_list|)
name|password_entry_operation_t
name|operation
decl_stmt|;
name|cvsroot_t
modifier|*
name|root
decl_stmt|;
name|char
modifier|*
name|newpassword
decl_stmt|;
block|{
name|char
modifier|*
name|passfile
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cvsroot_canonical
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|long
name|line
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|save_errno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|root
operator|->
name|method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: can only call password_entry_operation with pserver method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|root
operator|->
name|original
argument_list|)
expr_stmt|;
block|}
name|cvsroot_canonical
operator|=
name|normalize_cvsroot
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* Yes, the method below reads the user's password file twice when we have      * to delete an entry.  It's inefficient, but we're not talking about a gig of      * data here.      */
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: failed to open %s for reading"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
comment|/* Check each line to see if we have this entry already. */
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|password
operator|=
name|password_entry_parseline
argument_list|(
name|cvsroot_canonical
argument_list|,
literal|1
argument_list|,
name|line
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|!=
name|NULL
condition|)
comment|/* this is it!  break out and deal with linebuf */
break|break;
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
comment|/* not fatal, unless it cascades */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
comment|/* Utter, total, raving paranoia, I know. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
comment|/* a copy to return or keep around so we can reuse linebuf */
if|if
condition|(
name|password
operator|!=
name|NULL
condition|)
block|{
comment|/* chomp the EOL */
name|p
operator|=
name|strchr
argument_list|(
name|password
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|password
operator|=
name|xstrdup
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
name|process
label|:
comment|/* might as well return now */
if|if
condition|(
name|operation
operator|==
name|password_entry_lookup
condition|)
goto|goto
name|out
goto|;
comment|/* same here */
if|if
condition|(
name|operation
operator|==
name|password_entry_delete
operator|&&
name|password
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Entry not found."
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* okay, file errors can simply be fatal from now on since we don't do      * anything else if we're in lookup mode      */
comment|/* copy the file with the entry deleted unless we're in add      * mode and the line we found contains the same password we're supposed to      * add      */
if|if
condition|(
operator|!
name|noexec
operator|&&
name|password
operator|!=
name|NULL
operator|&&
operator|(
name|operation
operator|==
name|password_entry_delete
operator|||
operator|(
name|operation
operator|==
name|password_entry_add
operator|&&
name|strcmp
argument_list|(
name|password
argument_list|,
name|newpassword
argument_list|)
operator|)
operator|)
condition|)
block|{
name|long
name|found_at
init|=
name|line
decl_stmt|;
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|FILE
modifier|*
name|tmp_fp
decl_stmt|;
comment|/* open the original file again */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"failed to open %s for reading"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
comment|/* create and open a temp file */
if|if
condition|(
operator|(
name|tmp_fp
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|tmp_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open temp file %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|<
name|found_at
operator|||
operator|(
name|line
operator|!=
name|found_at
operator|&&
operator|!
name|password_entry_parseline
argument_list|(
name|cvsroot_canonical
argument_list|,
literal|0
argument_list|,
name|line
argument_list|,
name|linebuf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
operator|==
name|EOF
condition|)
block|{
comment|/* try and clean up anyhow */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"fatal error: cannot write %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* call CVS_UNLINK instead of unlink_file since the file 		     * got created in noexec mode 		     */
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* but quit so we don't remove all the entries from a 		     * user's password file accidentally 		     */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"exiting"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
comment|/* not fatal, unless it cascades */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
operator|<
literal|0
condition|)
comment|/* not fatal, unless it cascades */
comment|/* FIXME - does copy_file return correct results if the file wasn't 	     * closed? should this be fatal? 	     */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* FIXME: rename_file would make more sense (e.g. almost 	 * always faster). 	 * 	 * I don't think so, unless we change the way rename_file works to 	 * attempt a cp/rm sequence when rename fails since rename doesn't 	 * work across file systems and it isn't uncommon to have /tmp 	 * on its own partition. 	 * 	 * For that matter, it's probably not uncommon to have a home 	 * directory on an NFS mount. 	 */
name|copy_file
argument_list|(
name|tmp_name
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
comment|/* in add mode, if we didn't find an entry or found an entry with a      * different password, append the new line      */
if|if
condition|(
operator|!
name|noexec
operator|&&
name|operation
operator|==
name|password_entry_add
operator|&&
operator|(
name|password
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|password
argument_list|,
name|newpassword
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open %s for writing"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/1 %s %s\n"
argument_list|,
name|cvsroot_canonical
argument_list|,
name|newpassword
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
block|}
comment|/* Utter, total, raving paranoia, I know. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
condition|)
block|{
name|free
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|password
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|cvsroot_canonical
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
return|return
name|password
return|;
name|error_exit
label|:
comment|/* just exit when we're not in lookup mode */
if|if
condition|(
name|operation
operator|!=
name|password_entry_lookup
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"fatal error: exiting"
argument_list|)
expr_stmt|;
comment|/* clean up and exit in lookup mode so we can try a login with a NULL      * password anyhow in case that's what we would have found      */
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* Utter, total, raving paranoia, I know. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvsroot_canonical
condition|)
name|free
argument_list|(
name|cvsroot_canonical
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Prompt for a password, and store it in the file "CVS/.cvspass".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|login_usage
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|login
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|typed_password
decl_stmt|;
name|char
modifier|*
name|cvsroot_canonical
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|usage
argument_list|(
name|login_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_parsed_root
operator|->
name|method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only use `login' command with the 'pserver' method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|current_parsed_root
operator|->
name|original
argument_list|)
expr_stmt|;
block|}
name|cvsroot_canonical
operator|=
name|normalize_cvsroot
argument_list|(
name|current_parsed_root
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Logging in to %s\n"
argument_list|,
name|cvsroot_canonical
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_parsed_root
operator|->
name|password
condition|)
block|{
name|typed_password
operator|=
name|scramble
argument_list|(
name|current_parsed_root
operator|->
name|password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|GETPASS
argument_list|(
literal|"CVS password: "
argument_list|)
expr_stmt|;
comment|/* Must deal with a NULL return value here.  I haven't managed to 	 * disconnect the CVS process from the tty and force a NULL return 	 * in sanity.sh, but the Linux version of getpass is documented 	 * to return NULL when it can't open /dev/tty... 	 */
if|if
condition|(
operator|!
name|tmp
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"login: Failed to read password."
argument_list|)
expr_stmt|;
name|typed_password
operator|=
name|scramble
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Force get_cvs_password() to use this one (when the client      * confirms the new password with the server), instead of      * consulting the file.  We make a new copy because cvs_password      * will get zeroed by connect_to_server().  */
name|cvs_password
operator|=
name|xstrdup
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
name|connect_to_pserver
argument_list|(
name|current_parsed_root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|password_entry_operation
argument_list|(
name|password_entry_add
argument_list|,
name|current_parsed_root
argument_list|,
name|typed_password
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|typed_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|typed_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvs_password
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_canonical
argument_list|)
expr_stmt|;
name|cvs_password
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the _scrambled_ password.  The server must descramble    before hashing and comparing.  If password file not found, or    password not found in the file, just return NULL. */
end_comment

begin_function
name|char
modifier|*
name|get_cvs_password
parameter_list|()
block|{
if|if
condition|(
name|current_parsed_root
operator|->
name|password
condition|)
return|return
operator|(
name|scramble
argument_list|(
name|current_parsed_root
operator|->
name|password
argument_list|)
operator|)
return|;
comment|/* If someone (i.e., login()) is calling connect_to_pserver() out of        context, then assume they have supplied the correct, scrambled        password. */
if|if
condition|(
name|cvs_password
condition|)
return|return
name|cvs_password
return|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CVS_PASSWORD"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* In previous versions of CVS one could specify a password in 	 * CVS_PASSWORD.  This is a bad idea, because in BSD variants 	 * of unix anyone can see the environment variable with 'ps'. 	 * But for users who were using that feature we want to at 	 * least let them know what is going on.  After printing this 	 * warning, we should fall through to the regular error where 	 * we tell them to run "cvs login" (unless they already ran 	 * it, of course). 	 */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS_PASSWORD is no longer supported; ignored"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_parsed_root
operator|->
name|method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only call get_cvs_password with pserver method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|current_parsed_root
operator|->
name|original
argument_list|)
expr_stmt|;
block|}
return|return
name|password_entry_operation
argument_list|(
name|password_entry_lookup
argument_list|,
name|current_parsed_root
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|logout_usage
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove any entry for the CVSRoot repository found in .cvspass. */
end_comment

begin_function
name|int
name|logout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|cvsroot_canonical
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|usage
argument_list|(
name|logout_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_parsed_root
operator|->
name|method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only use pserver method with `logout' command"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|current_parsed_root
operator|->
name|original
argument_list|)
expr_stmt|;
block|}
comment|/* Hmm.  Do we want a variant of this command which deletes _all_        the entries from the current .cvspass?  Might be easier to        remember than "rm ~/.cvspass" but then again if people are        mucking with HOME (common in Win95 as the system doesn't set        it), then this variant of "cvs logout" might give a false sense        of security, in that it wouldn't delete entries from any        .cvspass files but the current one.  */
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|cvsroot_canonical
operator|=
name|normalize_cvsroot
argument_list|(
name|current_parsed_root
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Logging out of %s\n"
argument_list|,
name|cvsroot_canonical
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_canonical
argument_list|)
expr_stmt|;
block|}
name|password_entry_operation
argument_list|(
name|password_entry_delete
argument_list|,
name|current_parsed_root
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT from beginning of file. */
end_comment

end_unit

