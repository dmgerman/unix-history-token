begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, Cyclic Software, Bloomington, IN, USA  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with CVS.  *   * Allow user to log in for an authenticating server.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* This covers the rest of the file. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpass
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CVS_PASSWORD_FILE
end_ifndef

begin_define
define|#
directive|define
name|CVS_PASSWORD_FILE
value|".cvspass"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-NULL, get_cvs_password() will just return this. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cvs_password
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The return value will need to be freed. */
end_comment

begin_function
name|char
modifier|*
name|construct_cvspass_filename
parameter_list|()
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
name|char
modifier|*
name|passfile
decl_stmt|;
comment|/* Environment should override file. */
if|if
condition|(
operator|(
name|passfile
operator|=
name|getenv
argument_list|(
literal|"CVS_PASSFILE"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|passfile
argument_list|)
return|;
comment|/* Construct absolute pathname to user's password file. */
comment|/* todo: does this work under OS/2 ? */
name|homedir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not find out home directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|passfile
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVS_PASSWORD_FILE
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|passfile
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|passfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|passfile
argument_list|,
name|CVS_PASSWORD_FILE
argument_list|)
expr_stmt|;
comment|/* Safety first and last, Scouts. */
if|if
condition|(
name|isfile
argument_list|(
name|passfile
argument_list|)
condition|)
comment|/* xchmod() is too polite. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
return|return
name|passfile
return|;
block|}
end_function

begin_comment
comment|/* Prompt for a password, and store it in the file "CVS/.cvspass".  *  * Because the user might be accessing multiple repositories, with  * different passwords for each one, the format of ~/.cvspass is:  *  * user@host:/path Acleartext_password  * user@host:/path Acleartext_password  * ...  *  * Of course, the "user@" might be left off -- it's just based on the  * value of CVSroot.  *  * The "A" before "cleartext_password" is a literal capital A.  It's a  * version number indicating which form of scrambling we're doing on  * the password -- someday we might provide something more secure than  * the trivial encoding we do now, and when that day comes, it would  * be nice to remain backward-compatible.  *  * Like .netrc, the file's permissions are the only thing preventing  * it from being read by others.  Unlike .netrc, we will not be  * fascist about it, at most issuing a warning, and never refusing to  * work.  */
end_comment

begin_function
name|int
name|login
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|passfile
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|typed_password
decl_stmt|,
modifier|*
name|found_password
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|int
name|root_len
decl_stmt|,
name|already_entered
init|=
literal|0
decl_stmt|;
comment|/* Make this a "fully-qualified" CVSroot if necessary. */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|CVSroot
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* We need to prepend "user@host:". */
name|char
modifier|*
name|tmp
decl_stmt|;
name|printf
argument_list|(
literal|"Repository \"%s\" not fully-qualified.\n"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please enter \"user@host:/path\": "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Give it some permanent storage. */
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|tmp
index|[
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|CVSroot
operator|=
name|tmp
expr_stmt|;
comment|/* Reset. */
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|CVSroot
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
block|{
comment|/* Then we need to prepend ":pserver:". */
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|":pserver:"
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|":pserver:"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|CVSroot
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Check to make sure it's fully-qualified before going on.     * Fully qualified in this context means it has both a user and a    * host:repos portion.    */
block|{
name|char
modifier|*
name|r
decl_stmt|;
comment|/* After confirming that CVSroot is non-NULL, we skip past the        initial ":pserver:" to test the rest of it. */
if|if
condition|(
operator|!
name|CVSroot
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSroot is NULL"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|(
name|r
operator|=
operator|(
name|CVSroot
operator|+
name|strlen
argument_list|(
literal|":pserver:"
argument_list|)
operator|)
operator|)
argument_list|,
literal|'@'
argument_list|)
condition|)
goto|goto
name|not_fqrn
goto|;
elseif|else
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|r
argument_list|,
literal|':'
argument_list|)
condition|)
goto|goto
name|not_fqrn
goto|;
if|if
condition|(
literal|0
condition|)
comment|/* Lovely. */
block|{
name|not_fqrn
label|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSroot not fully-qualified: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"should be format user@host:/path/to/repository"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* CVSroot is now fully qualified and has ":pserver:" prepended.      We'll print out most of it so user knows exactly what is being      dealt with here. */
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|CVSroot
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"NULL CVSroot"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Logging in to %s)\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
name|typed_password
operator|=
name|getpass
argument_list|(
literal|"CVS password: "
argument_list|)
expr_stmt|;
name|typed_password
operator|=
name|scramble
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
comment|/* Force get_cvs_password() to use this one (when the client    * confirms the new password with the server), instead of consulting    * the file.  We make a new copy because cvs_password will get    * zeroed by connect_to_server().    */
name|cvs_password
operator|=
name|xstrdup
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect_to_pserver
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The password is wrong, according to the server. */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"incorrect password"
argument_list|)
expr_stmt|;
block|}
comment|/* IF we have a password for this "[user@]host:/path" already    *  THEN    *    IF it's the same as the password we read from the prompt    *     THEN     *       do nothing    *     ELSE    *       replace the old password with the new one    *  ELSE    *    append new entry to the end of the file.    */
name|root_len
operator|=
name|strlen
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
comment|/* Yes, the method below reads the user's password file twice.  It's      inefficient, but we're not talking about a gig of data here. */
name|fp
operator|=
name|fopen
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* FIXME: should be printing a message if fp == NULL and not      existence_error (errno).  */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* Check each line to see if we have this entry already. */
while|while
condition|(
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|already_entered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|already_entered
condition|)
block|{
comment|/* This user/host has a password in the file already. */
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|found_password
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|found_password
argument_list|,
name|typed_password
argument_list|)
condition|)
block|{
comment|/* typed_password and found_password don't match, so we'll            * have to update passfile.  We replace the old password            * with the new one by writing a tmp file whose contents are            * exactly the same as passfile except that this one entry            * gets typed_password instead of found_password.  Then we            * rename the tmp file on top of passfile.            */
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|FILE
modifier|*
name|tmp_fp
decl_stmt|;
name|tmp_name
operator|=
name|tmpnam
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_fp
operator|=
name|fopen
argument_list|(
name|tmp_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open temp file %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|chmod
argument_list|(
name|tmp_name
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* I'm not paranoid, they really ARE out to get me: */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
condition|)
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|CVSroot
argument_list|,
name|typed_password
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|tmp_name
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|passfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|CVSroot
argument_list|,
name|typed_password
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Utter, total, raving paranoia, I know. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|typed_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|typed_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvs_password
argument_list|)
expr_stmt|;
name|cvs_password
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* todo: "cvs logout" could erase an entry from the file.  * But to what purpose?  */
end_comment

begin_comment
comment|/* Returns the _scrambled_ password.  The server must descramble    before hashing and comparing. */
end_comment

begin_function
name|char
modifier|*
name|get_cvs_password
parameter_list|()
block|{
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|int
name|root_len
decl_stmt|;
name|char
modifier|*
name|password
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|passfile
decl_stmt|;
comment|/* If someone (i.e., login()) is calling connect_to_pserver() out of      context, then assume they have supplied the correct, scrambled      password. */
if|if
condition|(
name|cvs_password
condition|)
return|return
name|cvs_password
return|;
comment|/* Environment should override file. */
if|if
condition|(
operator|(
name|password
operator|=
name|getenv
argument_list|(
literal|"CVS_PASSWORD"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|xstrdup
argument_list|(
name|password
argument_list|)
expr_stmt|;
comment|/* If we got it from the environment, then it wasn't properly          scrambled.  Since unscrambling is done on the server side, we          need to transmit it scrambled. */
name|p
operator|=
name|scramble
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Else get it from the file. */
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"could not open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"use \"cvs login\" to log in first"
argument_list|)
expr_stmt|;
block|}
name|root_len
operator|=
name|strlen
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
comment|/* Check each line to see if we have this entry already. */
while|while
condition|(
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is it!  So break out and deal with linebuf. */
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|linebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_it
condition|)
block|{
comment|/* linebuf now contains the line with the password. */
name|char
modifier|*
name|tmp
decl_stmt|;
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|password
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Give it permanent storage. */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|password
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|password
argument_list|)
expr_stmt|;
name|tmp
index|[
name|strlen
argument_list|(
name|password
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find password"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"use \"cvs login\" to log in first"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"or set the CVS_PASSWORD environment variable"
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT from beginning of file. */
end_comment

end_unit

