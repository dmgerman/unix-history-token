begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, Cyclic Software, Bloomington, IN, USA  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with CVS.  *   * Allow user to log in for an authenticating server.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* This covers the rest of the file. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETPASSPHRASE
end_ifdef

begin_define
define|#
directive|define
name|GETPASS
value|getpassphrase
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETPASS
value|getpass
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* There seems to be very little agreement on which system header    getpass is declared in.  With a lot of fancy autoconfiscation,    we could perhaps detect this, but for now we'll just rely on    _CRAY, since Cray is perhaps the only system on which our own    declaration won't work (some Crays declare the 2#$@% thing as    varadic, believe it or not).  On Cray, getpass will be declared    in either stdlib.h or unistd.h.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CRAY
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|GETPASS
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVS_PASSWORD_FILE
end_ifndef

begin_define
define|#
directive|define
name|CVS_PASSWORD_FILE
value|".cvspass"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-NULL, get_cvs_password() will just return this. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cvs_password
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|construct_cvspass_filename
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The return value will need to be freed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|construct_cvspass_filename
parameter_list|()
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
name|char
modifier|*
name|passfile
decl_stmt|;
comment|/* Environment should override file. */
if|if
condition|(
operator|(
name|passfile
operator|=
name|getenv
argument_list|(
literal|"CVS_PASSFILE"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|passfile
argument_list|)
return|;
comment|/* Construct absolute pathname to user's password file. */
comment|/* todo: does this work under OS/2 ? */
name|homedir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
block|{
comment|/* FIXME?  This message confuses a lot of users, at least 	   on Win95 (which doesn't set HOMEDRIVE and HOMEPATH like 	   NT does).  I suppose the answer for Win95 is to store the 	   passwords in the registry or something (??).  And .cvsrc 	   and such too?  Wonder what WinCVS does (about .cvsrc, the 	   right thing for a GUI is to just store the password in 	   memory only)...  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not find out home directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
name|passfile
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVS_PASSWORD_FILE
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|passfile
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_SLASH_AFTER_HOME
comment|/* NO_SLASH_AFTER_HOME is defined for VMS, where foo:[bar]/.cvspass is not        a legal filename but foo:[bar].cvspass is.  A more clean solution would        be something more along the lines of a "join a directory to a filename"        kind of thing....  */
name|strcat
argument_list|(
name|passfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|passfile
argument_list|,
name|CVS_PASSWORD_FILE
argument_list|)
expr_stmt|;
comment|/* Safety first and last, Scouts. */
if|if
condition|(
name|isfile
argument_list|(
name|passfile
argument_list|)
condition|)
comment|/* xchmod() is too polite. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
return|return
name|passfile
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|login_usage
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prompt for a password, and store it in the file "CVS/.cvspass".  *  * Because the user might be accessing multiple repositories, with  * different passwords for each one, the format of ~/.cvspass is:  *  * user@host:/path Acleartext_password  * user@host:/path Acleartext_password  * ...  *  * Of course, the "user@" might be left off -- it's just based on the  * value of CVSroot.  *  * The "A" before "cleartext_password" is a literal capital A.  It's a  * version number indicating which form of scrambling we're doing on  * the password -- someday we might provide something more secure than  * the trivial encoding we do now, and when that day comes, it would  * be nice to remain backward-compatible.  *  * Like .netrc, the file's permissions are the only thing preventing  * it from being read by others.  Unlike .netrc, we will not be  * fascist about it, at most issuing a warning, and never refusing to  * work.  */
end_comment

begin_function
name|int
name|login
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|passfile
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|typed_password
decl_stmt|,
modifier|*
name|found_password
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|int
name|root_len
decl_stmt|,
name|already_entered
init|=
literal|0
decl_stmt|;
name|int
name|line_length
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|usage
argument_list|(
name|login_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot_method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only use pserver method with `login' command"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CVSroot_username
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\" is not fully-qualified."
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Please make sure to specify \"user@host\"!"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"(Logging in to %s@%s)\n"
argument_list|,
name|CVSroot_username
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
name|typed_password
operator|=
name|GETPASS
argument_list|(
literal|"CVS password: "
argument_list|)
expr_stmt|;
name|typed_password
operator|=
name|scramble
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
comment|/* Force get_cvs_password() to use this one (when the client      * confirms the new password with the server), instead of      * consulting the file.  We make a new copy because cvs_password      * will get zeroed by connect_to_server().  */
name|cvs_password
operator|=
name|xstrdup
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
name|connect_to_pserver
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* IF we have a password for this "[user@]host:/path" already      *  THEN      *    IF it's the same as the password we read from the prompt      *     THEN       *       do nothing      *     ELSE      *       replace the old password with the new one      *  ELSE      *    append new entry to the end of the file.      */
name|root_len
operator|=
name|strlen
argument_list|(
name|CVSroot_original
argument_list|)
expr_stmt|;
comment|/* Yes, the method below reads the user's password file twice.  It's        inefficient, but we're not talking about a gig of data here. */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* FIXME: should be printing a message if fp == NULL and not        existence_error (errno).  */
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* Check each line to see if we have this entry already. */
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_original
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|already_entered
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|already_entered
condition|)
block|{
comment|/* This user/host has a password in the file already. */
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|found_password
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|found_password
argument_list|,
name|typed_password
argument_list|)
condition|)
block|{
comment|/* typed_password and found_password don't match, so we'll 	     * have to update passfile.  We replace the old password 	     * with the new one by writing a tmp file whose contents are 	     * exactly the same as passfile except that this one entry 	     * gets typed_password instead of found_password.  Then we 	     * rename the tmp file on top of passfile. 	     */
name|char
modifier|*
name|tmp_name
decl_stmt|;
name|FILE
modifier|*
name|tmp_fp
decl_stmt|;
name|tmp_name
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_fp
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open temp file %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|chmod
argument_list|(
name|tmp_name
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* I'm not paranoid, they really ARE out to get me: */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_original
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|CVSroot_original
argument_list|,
name|typed_password
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
comment|/* FIXME: rename_file would make more sense (e.g. almost 	       always faster).  */
name|copy_file
argument_list|(
name|tmp_name
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s\n"
argument_list|,
name|CVSroot_original
argument_list|,
name|typed_password
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
block|}
comment|/* Utter, total, raving paranoia, I know. */
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|typed_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|typed_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|typed_password
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvs_password
argument_list|)
expr_stmt|;
name|cvs_password
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the _scrambled_ password.  The server must descramble    before hashing and comparing.  If password file not found, or    password not found in the file, just return NULL. */
end_comment

begin_function
name|char
modifier|*
name|get_cvs_password
parameter_list|()
block|{
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|int
name|root_len
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|passfile
decl_stmt|;
name|int
name|line_length
decl_stmt|;
comment|/* If someone (i.e., login()) is calling connect_to_pserver() out of        context, then assume they have supplied the correct, scrambled        password. */
if|if
condition|(
name|cvs_password
condition|)
return|return
name|cvs_password
return|;
if|if
condition|(
name|getenv
argument_list|(
literal|"CVS_PASSWORD"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* In previous versions of CVS one could specify a password in 	   CVS_PASSWORD.  This is a bad idea, because in BSD variants 	   of unix anyone can see the environment variable with 'ps'. 	   But for users who were using that feature we want to at 	   least let them know what is going on.  After printing this 	   warning, we should fall through to the regular error where 	   we tell them to run "cvs login" (unless they already ran 	   it, of course).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS_PASSWORD is no longer supported; ignored"
argument_list|)
expr_stmt|;
block|}
comment|/* Else get it from the file.  First make sure that the CVSROOT        variable has the appropriate fields filled in. */
if|if
condition|(
name|CVSroot_method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only call GET_CVS_PASSWORD  with pserver method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CVSroot_username
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\" is not fully-qualified."
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Please make sure to specify \"user@host\"!"
argument_list|)
expr_stmt|;
block|}
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|root_len
operator|=
name|strlen
argument_list|(
name|CVSroot_original
argument_list|)
expr_stmt|;
comment|/* Check each line to see if we have this entry already. */
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_original
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is it!  So break out and deal with linebuf. */
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_it
condition|)
block|{
comment|/* linebuf now contains the line with the password. */
name|char
modifier|*
name|tmp
decl_stmt|;
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entry in %s for %s"
argument_list|,
name|passfile
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
comment|/* Give it permanent storage. */
name|password
operator|=
name|xstrdup
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passfile
argument_list|)
expr_stmt|;
return|return
name|password
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|logout_usage
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove any entry for the CVSRoot repository found in .cvspass. */
end_comment

begin_function
name|int
name|logout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|passfile
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|tmp_name
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|tmp_fp
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|int
name|root_len
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|int
name|line_length
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|usage
argument_list|(
name|logout_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot_method
operator|!=
name|pserver_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can only use pserver method with `logout' command"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT: %s"
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CVSroot_username
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\" is not fully-qualified."
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Please make sure to specify \"user@host\"!"
argument_list|)
expr_stmt|;
block|}
comment|/* Hmm.  Do we want a variant of this command which deletes _all_        the entries from the current .cvspass?  Might be easier to        remember than "rm ~/.cvspass" but then again if people are        mucking with HOME (common in Win95 as the system doesn't set        it), then this variant of "cvs logout" might give a false sense        of security, in that it wouldn't delete entries from any        .cvspass files but the current one.  */
name|printf
argument_list|(
literal|"(Logging out of %s@%s)\n"
argument_list|,
name|CVSroot_username
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* IF we have a password for this "[user@]host:/path" already      *  THEN      *    drop the entry      *  ELSE      *    do nothing      */
name|passfile
operator|=
name|construct_cvspass_filename
argument_list|()
expr_stmt|;
comment|/* FIXME: This should not be in /tmp; that is almost surely a security        hole.  Probably should just keep it in memory.  */
name|tmp_name
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_fp
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"unable to open temp file %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|chmod
argument_list|(
name|tmp_name
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|root_len
operator|=
name|strlen
argument_list|(
name|CVSroot_original
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|passfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Error opening %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
comment|/* Check each line to see if we have this entry. */
comment|/* Copy only those lines that do not match this entry */
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_original
argument_list|,
name|linebuf
argument_list|,
name|root_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|tmp_fp
argument_list|,
literal|"%s"
argument_list|,
name|linebuf
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|tmp_fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|printf
argument_list|(
literal|"Entry not found for %s\n"
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: rename_file would make more sense (e.g. almost 	   always faster).  */
name|copy_file
argument_list|(
name|tmp_name
argument_list|,
name|passfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|passfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp_name
condition|)
name|free
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT from beginning of file. */
end_comment

end_unit

