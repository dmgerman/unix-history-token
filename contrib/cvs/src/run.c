begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* run.c --- routines for executing subprocesses.        This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args, lastarg)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|va_alist
value|a1, a2, a3, a4, a5, a6, a7, a8
end_define

begin_define
define|#
directive|define
name|va_dcl
value|char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|run_add_arg
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|vasprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * To exec a program under CVS, first call run_setup() to setup any initial  * arguments.  The options to run_setup are essentially like printf(). The  * arguments will be parsed into whitespace separated words and added to the  * global run_argv list.  *   * Then, optionally call run_arg() for each additional argument that you'd like  * to pass to the executed program.  *   * Finally, call run_exec() to execute the program with the specified arguments.  * The execvp() syscall will be used, so that the PATH is searched correctly.  * File redirections can be performed in the call to run_exec().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|run_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
end_if

begin_function
name|void
name|run_setup
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|void  run_setup
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|run_prog
decl_stmt|;
comment|/* clean out any malloc'ed values from run_argv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|run_argv
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|run_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|run_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|run_argc
operator|=
literal|0
expr_stmt|;
comment|/* process the varargs into run_prog */
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
name|VA_START
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vasprintf
argument_list|(
operator|&
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|you
name|lose
endif|#
directive|endif
if|if
condition|(
name|run_prog
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* put each word into run_argv, allocating it as we go */
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|run_prog
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
name|run_add_arg
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|run_prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|run_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|run_add_arg
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
end_if

begin_function
name|void
name|run_args
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|void  run_args
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
name|va_list
name|args
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|run_prog
decl_stmt|;
comment|/* process the varargs into run_prog */
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
name|VA_START
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vasprintf
argument_list|(
operator|&
name|run_prog
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|you
name|lose
endif|#
directive|endif
if|if
condition|(
name|run_prog
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* and add the (single) argument to the run_argv list */
name|run_add_arg
argument_list|(
name|run_prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|run_prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_add_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* allocate more argv entries if we've run out */
if|if
condition|(
name|run_argc
operator|>=
name|run_argc_allocated
condition|)
block|{
name|run_argc_allocated
operator|+=
literal|50
expr_stmt|;
name|run_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|run_argv
argument_list|,
name|run_argc_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|run_argv
index|[
name|run_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|run_argv
index|[
name|run_argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* not post-incremented on purpose! */
block|}
end_function

begin_function
name|int
name|run_exec
parameter_list|(
name|stin
parameter_list|,
name|stout
parameter_list|,
name|sterr
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|stin
decl_stmt|;
name|char
modifier|*
name|stout
decl_stmt|;
name|char
modifier|*
name|sterr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|shin
decl_stmt|,
name|shout
decl_stmt|,
name|sherr
decl_stmt|;
name|int
name|mode_out
decl_stmt|,
name|mode_err
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rerrno
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|w
decl_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|sigset_t
name|sigset_mask
decl_stmt|,
name|sigset_omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|,
name|iact
decl_stmt|,
name|qact
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
name|int
name|mask
decl_stmt|;
name|struct
name|sigvec
name|vec
decl_stmt|,
name|ivec
decl_stmt|,
name|qvec
decl_stmt|;
else|#
directive|else
name|RETSIGTYPE
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|cvs_outerr
argument_list|(
name|server_active
condition|?
literal|"S"
else|:
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvs_outerr
argument_list|(
literal|"-> system("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|")\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noexec
operator|&&
operator|(
name|flags
operator|&
name|RUN_REALLY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make sure that we are null terminated, since we didn't calloc */
name|run_add_arg
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* setup default file descriptor numbers */
name|shin
operator|=
literal|0
expr_stmt|;
name|shout
operator|=
literal|1
expr_stmt|;
name|sherr
operator|=
literal|2
expr_stmt|;
comment|/* set the file modes for stdout and stderr */
name|mode_out
operator|=
name|mode_err
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
name|mode_out
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDOUT_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
name|mode_err
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDERR_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
if|if
condition|(
name|stin
operator|&&
operator|(
name|shin
operator|=
name|open
argument_list|(
name|stin
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading (prog %s)"
argument_list|,
name|stin
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out0
goto|;
block|}
if|if
condition|(
name|stout
operator|&&
operator|(
name|shout
operator|=
name|open
argument_list|(
name|stout
argument_list|,
name|mode_out
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|stout
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|sterr
operator|&&
operator|(
name|flags
operator|&
name|RUN_COMBINED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sherr
operator|=
name|open
argument_list|(
name|sterr
argument_list|,
name|mode_err
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|sterr
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
comment|/* Make sure we don't flush this twice, once in the subprocess.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* The output files, if any, are now created.  Do the fork and dups.         We use vfork not so much for the sake of unices without        copy-on-write (such systems are rare these days), but for the        sake of systems without an MMU, which therefore can't do        copy-on-write (e.g. Amiga).  The other solution is spawn (see        windows-NT/run.c).  */
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shin
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shout
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RUN_COMBINED
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sherr
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sherr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
block|}
comment|/* dup'ing is done.  try to run it now */
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|run_argv
index|[
literal|0
index|]
argument_list|,
name|run_argv
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot exec %s"
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* the parent.  Ignore some signals for now */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|iact
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|qact
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sigset_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_mask
argument_list|,
operator|&
name|sigset_omask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vec
argument_list|)
argument_list|)
expr_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|ivec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|qvec
argument_list|)
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* wait for our process to die and munge return status */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
while|while
condition|(
operator|(
name|w
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|w
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|rerrno
operator|=
name|errno
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMS
comment|/* status is return status */
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|rc
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGPIPE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"broken pipe"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|rc
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|rc
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* restore the signals */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|iact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_omask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|ivec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qvec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* cleanup the open file descriptors */
name|out
label|:
if|if
condition|(
name|sterr
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
name|out2
label|:
if|if
condition|(
name|stout
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
name|out1
label|:
if|if
condition|(
name|stin
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
name|out0
label|:
if|if
condition|(
name|rerrno
condition|)
name|errno
operator|=
name|rerrno
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|run_print
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|void
argument_list|(
argument|*outfn
argument_list|)
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|stderr
condition|)
name|outfn
operator|=
name|cvs_outerr
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|==
name|stdout
condition|)
name|outfn
operator|=
name|cvs_output
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: bad argument to run_print"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outfn
call|)
argument_list|(
name|run_argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|run_argc
operator|-
literal|1
condition|)
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|FILE
modifier|*
name|run_popen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> run_popen(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> run_popen(%s,%s)\n"
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|evecvp
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|piped_child
parameter_list|(
name|command
parameter_list|,
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|char
modifier|*
modifier|*
name|command
decl_stmt|;
name|int
modifier|*
name|tofdp
decl_stmt|;
name|int
modifier|*
name|fromfdp
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|to_child_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|from_child_pipe
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|to_child_pipe
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|from_child_pipe
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|to_child_pipe
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|to_child_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|from_child_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|from_child_pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup2"
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|command
index|[
literal|0
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot exec"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|to_child_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|from_child_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
operator|*
name|tofdp
operator|=
name|to_child_pipe
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|from_child_pipe
index|[
literal|0
index|]
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_function
name|void
name|close_on_exec
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|FD_CLOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set close-on-exec flag on %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * dir = 0 : main proc writes to new proc, which writes to oldfd  * dir = 1 : main proc reads from new proc, which reads from oldfd  *  * Returns: a file descriptor.  On failure (i.e., the exec fails),  * then filter_stream_through_program() complains and dies.  */
end_comment

begin_function
name|int
name|filter_stream_through_program
parameter_list|(
name|oldfd
parameter_list|,
name|dir
parameter_list|,
name|prog
parameter_list|,
name|pidp
parameter_list|)
name|int
name|oldfd
decl_stmt|,
name|dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|prog
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|newfd
decl_stmt|;
name|pid_t
name|newpid
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|newpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|newpid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pidp
condition|)
operator|*
name|pidp
operator|=
name|newpid
expr_stmt|;
switch|switch
condition|(
name|newpid
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* child */
if|if
condition|(
name|dir
condition|)
block|{
comment|/* write to new pipe */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|oldfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read from new pipe */
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|oldfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Should I be blocking some signals here?  */
name|execvp
argument_list|(
name|prog
index|[
literal|0
index|]
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"couldn't exec %s"
argument_list|,
name|prog
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
default|default:
comment|/* parent */
name|close
argument_list|(
name|oldfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
comment|/* read from new pipe */
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* write to new pipe */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
block|}
name|close_on_exec
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
block|}
end_function

end_unit

