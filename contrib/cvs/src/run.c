begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* run.c --- routines for executing subprocesses.        This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_UNISTD_H
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|execvp
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|run_add_arg
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * To exec a program under CVS, first call run_setup() to setup initial  * arguments.  The argument to run_setup will be parsed into whitespace   * separated words and added to the global run_argv list.  *   * Then, optionally call run_arg() for each additional argument that you'd like  * to pass to the executed program.  *   * Finally, call run_exec() to execute the program with the specified arguments.  * The execvp() syscall will be used, so that the PATH is searched correctly.  * File redirections can be performed in the call to run_exec().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|run_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_argc_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|run_setup
parameter_list|(
name|prog
parameter_list|)
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|run_prog
decl_stmt|;
comment|/* clean out any malloc'ed values from run_argv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|run_argv
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|run_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|run_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|run_argc
operator|=
literal|0
expr_stmt|;
name|run_prog
operator|=
name|xstrdup
argument_list|(
name|prog
argument_list|)
expr_stmt|;
comment|/* put each word into run_argv, allocating it as we go */
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|run_prog
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
name|run_add_arg
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|run_prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|run_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|run_add_arg
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_add_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* allocate more argv entries if we've run out */
if|if
condition|(
name|run_argc
operator|>=
name|run_argc_allocated
condition|)
block|{
name|run_argc_allocated
operator|+=
literal|50
expr_stmt|;
name|run_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|run_argv
argument_list|,
name|run_argc_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|run_argv
index|[
name|run_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|run_argv
index|[
name|run_argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* not post-incremented on purpose! */
block|}
end_function

begin_function
name|int
name|run_exec
parameter_list|(
name|stin
parameter_list|,
name|stout
parameter_list|,
name|sterr
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|stin
decl_stmt|;
specifier|const
name|char
modifier|*
name|stout
decl_stmt|;
specifier|const
name|char
modifier|*
name|sterr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|shin
decl_stmt|,
name|shout
decl_stmt|,
name|sherr
decl_stmt|;
name|int
name|mode_out
decl_stmt|,
name|mode_err
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|rc
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rerrno
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|w
decl_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|sigset_t
name|sigset_mask
decl_stmt|,
name|sigset_omask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|,
name|iact
decl_stmt|,
name|qact
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
name|int
name|mask
decl_stmt|;
name|struct
name|sigvec
name|vec
decl_stmt|,
name|ivec
decl_stmt|,
name|qvec
decl_stmt|;
else|#
directive|else
name|RETSIGTYPE
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|cvs_outerr
argument_list|(
name|server_active
condition|?
literal|"S"
else|:
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvs_outerr
argument_list|(
literal|"-> system("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|")\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noexec
operator|&&
operator|(
name|flags
operator|&
name|RUN_REALLY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make sure that we are null terminated, since we didn't calloc */
name|run_add_arg
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* setup default file descriptor numbers */
name|shin
operator|=
literal|0
expr_stmt|;
name|shout
operator|=
literal|1
expr_stmt|;
name|sherr
operator|=
literal|2
expr_stmt|;
comment|/* set the file modes for stdout and stderr */
name|mode_out
operator|=
name|mode_err
operator|=
name|O_WRONLY
operator||
name|O_CREAT
expr_stmt|;
name|mode_out
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDOUT_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
name|mode_err
operator||=
operator|(
operator|(
name|flags
operator|&
name|RUN_STDERR_APPEND
operator|)
condition|?
name|O_APPEND
else|:
name|O_TRUNC
operator|)
expr_stmt|;
if|if
condition|(
name|stin
operator|&&
operator|(
name|shin
operator|=
name|open
argument_list|(
name|stin
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading (prog %s)"
argument_list|,
name|stin
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out0
goto|;
block|}
if|if
condition|(
name|stout
operator|&&
operator|(
name|shout
operator|=
name|open
argument_list|(
name|stout
argument_list|,
name|mode_out
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|stout
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|sterr
operator|&&
operator|(
name|flags
operator|&
name|RUN_COMBINED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sherr
operator|=
name|open
argument_list|(
name|sterr
argument_list|,
name|mode_err
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing (prog %s)"
argument_list|,
name|sterr
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
comment|/* Make sure we don't flush this twice, once in the subprocess.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* The output files, if any, are now created.  Do the fork and dups.         We use vfork not so much for the sake of unices without        copy-on-write (such systems are rare these days), but for the        sake of systems without an MMU, which therefore can't do        copy-on-write (e.g. Amiga).  The other solution is spawn (see        windows-NT/run.c).  */
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shin
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shout
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|shout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RUN_COMBINED
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sherr
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sherr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
block|}
comment|/* dup'ing is done.  try to run it now */
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|run_argv
index|[
literal|0
index|]
argument_list|,
name|run_argv
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot exec %s"
argument_list|,
name|run_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|rerrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* the parent.  Ignore some signals for now */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|iact
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|qact
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sigset_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sigset_mask
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_mask
argument_list|,
operator|&
name|sigset_omask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|vec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vec
argument_list|)
argument_list|)
expr_stmt|;
name|vec
operator|.
name|sv_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|ivec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|vec
argument_list|,
operator|&
name|qvec
argument_list|)
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* wait for our process to die and munge return status */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
while|while
condition|(
operator|(
name|w
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|w
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
block|{
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|rerrno
operator|=
name|errno
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMS
comment|/* status is return status */
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|rc
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|==
name|SIGPIPE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"broken pipe"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|rc
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|rc
operator|=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* restore the signals */
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|iact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset_omask
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD_SIGNALS
if|if
condition|(
name|flags
operator|&
name|RUN_SIGIGNORE
condition|)
block|{
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|ivec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGQUIT
argument_list|,
operator|&
name|qvec
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* cleanup the open file descriptors */
name|out
label|:
if|if
condition|(
name|sterr
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sherr
argument_list|)
expr_stmt|;
name|out2
label|:
if|if
condition|(
name|stout
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shout
argument_list|)
expr_stmt|;
name|out1
label|:
if|if
condition|(
name|stin
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|shin
argument_list|)
expr_stmt|;
name|out0
label|:
if|if
condition|(
name|rerrno
condition|)
name|errno
operator|=
name|rerrno
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|run_print
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|void
argument_list|(
argument|*outfn
argument_list|)
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|stderr
condition|)
name|outfn
operator|=
name|cvs_outerr
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|==
name|stdout
condition|)
name|outfn
operator|=
name|cvs_output
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: bad argument to run_print"
argument_list|)
expr_stmt|;
comment|/* Solely to placate gcc -Wall. 	   FIXME: it'd be better to use a function named `fatal' that 	   is known never to return.  Then kludges wouldn't be necessary.  */
name|outfn
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_argc
condition|;
name|i
operator|++
control|)
block|{
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outfn
call|)
argument_list|(
name|run_argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|run_argc
operator|-
literal|1
condition|)
call|(
modifier|*
name|outfn
call|)
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return value is NULL for error, or if noexec was set.  If there was an    error, return NULL and I'm not sure whether errno was set (the Red Hat    Linux 4.1 popen manpage was kind of vague but discouraging; and the noexec    case complicates this even aside from popen behavior).  */
end_comment

begin_function
name|FILE
modifier|*
name|run_popen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> run_popen(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> run_popen(%s,%s)\n"
argument_list|,
name|cmd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|piped_child
parameter_list|(
name|command
parameter_list|,
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|char
modifier|*
modifier|*
name|command
decl_stmt|;
name|int
modifier|*
name|tofdp
decl_stmt|;
name|int
modifier|*
name|fromfdp
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|to_child_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|from_child_pipe
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|to_child_pipe
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|from_child_pipe
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SETMODE_BINARY
name|setmode
argument_list|(
name|to_child_pipe
index|[
literal|0
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|to_child_pipe
index|[
literal|1
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|from_child_pipe
index|[
literal|0
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|from_child_pipe
index|[
literal|1
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|to_child_pipe
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|to_child_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|from_child_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|from_child_pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup2"
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|command
index|[
literal|0
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot exec"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|to_child_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|from_child_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close"
argument_list|)
expr_stmt|;
operator|*
name|tofdp
operator|=
name|to_child_pipe
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|from_child_pipe
index|[
literal|0
index|]
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_function
name|void
name|close_on_exec
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|FD_CLOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set close-on-exec flag on %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * dir = 0 : main proc writes to new proc, which writes to oldfd  * dir = 1 : main proc reads from new proc, which reads from oldfd  *  * Returns: a file descriptor.  On failure (i.e., the exec fails),  * then filter_stream_through_program() complains and dies.  */
end_comment

begin_function
name|int
name|filter_stream_through_program
parameter_list|(
name|oldfd
parameter_list|,
name|dir
parameter_list|,
name|prog
parameter_list|,
name|pidp
parameter_list|)
name|int
name|oldfd
decl_stmt|,
name|dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|prog
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|newfd
decl_stmt|;
name|pid_t
name|newpid
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create pipe"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SETMODE_BINARY
name|setmode
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_VFORK
name|newpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
else|#
directive|else
name|newpid
operator|=
name|fork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pidp
condition|)
operator|*
name|pidp
operator|=
name|newpid
expr_stmt|;
switch|switch
condition|(
name|newpid
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* child */
if|if
condition|(
name|dir
condition|)
block|{
comment|/* write to new pipe */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|oldfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read from new pipe */
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|oldfd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Should I be blocking some signals here?  */
name|execvp
argument_list|(
name|prog
index|[
literal|0
index|]
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"couldn't exec %s"
argument_list|,
name|prog
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
default|default:
comment|/* parent */
name|close
argument_list|(
name|oldfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
block|{
comment|/* read from new pipe */
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* write to new pipe */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
block|}
name|close_on_exec
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
block|}
end_function

end_unit

