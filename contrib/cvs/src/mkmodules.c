begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS kit.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DBLKSIZ
end_ifndef

begin_define
define|#
directive|define
name|DBLKSIZ
value|4096
end_define

begin_comment
comment|/* since GNU ndbm doesn't define it */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|checkout_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|temp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|make_tempfile
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rename_rcsfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|temp
operator|,
name|char
operator|*
name|real
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MY_NDBM
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|rename_dbmfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|temp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_dbmfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|temp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MY_NDBM */
end_comment

begin_comment
comment|/* Structure which describes an administrative file.  */
end_comment

begin_struct
struct|struct
name|admin_file
block|{
comment|/* Name of the file, within the CVSROOT directory.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* This is a one line description of what the file is for.  It is not       currently used, although one wonders whether it should be, somehow.       If NULL, then don't process this file in mkmodules (FIXME?: a bit of       a kludge; probably should replace this with a flags field).  */
name|char
modifier|*
name|errormsg
decl_stmt|;
comment|/* Contents which the file should have in a new repository.  To avoid       problems with brain-dead compilers which choke on long string constants,       this is a pointer to an array of char * terminated by NULL--each of       the strings is concatenated.        If this field is NULL, the file is not created in a new       repository, but it can be added with "cvs add" (just as if one       had created the repository with a version of CVS which didn't       know about the file) and the checked-out copy will be updated       without having to add it to checkoutlist.  */
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|contents
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|loginfo_contents
index|[]
init|=
block|{
literal|"# The \"loginfo\" file controls where \"cvs commit\" log information\n"
block|,
literal|"# is sent.  The first entry on a line is a regular expression which must match\n"
block|,
literal|"# the directory that the change is being made to, relative to the\n"
block|,
literal|"# $CVSROOT.  If a match is found, then the remainder of the line is a filter\n"
block|,
literal|"# program that should expect log information on its standard input.\n"
block|,
literal|"#\n"
block|,
literal|"# If the repository name does not match any of the regular expressions in this\n"
block|,
literal|"# file, the \"DEFAULT\" line is used, if it is specified.\n"
block|,
literal|"#\n"
block|,
literal|"# If the name ALL appears as a regular expression it is always used\n"
block|,
literal|"# in addition to the first matching regex or DEFAULT.\n"
block|,
literal|"#\n"
block|,
literal|"# You may specify a format string as part of the\n"
block|,
literal|"# filter.  The string is composed of a `%' followed\n"
block|,
literal|"# by a single format character, or followed by a set of format\n"
block|,
literal|"# characters surrounded by `{' and `}' as separators.  The format\n"
block|,
literal|"# characters are:\n"
block|,
literal|"#\n"
block|,
literal|"#   s = file name\n"
block|,
literal|"#   V = old version number (pre-checkin)\n"
block|,
literal|"#   v = new version number (post-checkin)\n"
block|,
literal|"#\n"
block|,
literal|"# For example:\n"
block|,
literal|"#DEFAULT (echo \"\"; id; echo %s; date; cat)>> $CVSROOT/CVSROOT/commitlog\n"
block|,
literal|"# or\n"
block|,
literal|"#DEFAULT (echo \"\"; id; echo %{sVv}; date; cat)>> $CVSROOT/CVSROOT/commitlog\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rcsinfo_contents
index|[]
init|=
block|{
literal|"# The \"rcsinfo\" file is used to control templates with which the editor\n"
block|,
literal|"# is invoked on commit and import.\n"
block|,
literal|"#\n"
block|,
literal|"# The first entry on a line is a regular expression which is tested\n"
block|,
literal|"# against the directory that the change is being made to, relative to the\n"
block|,
literal|"# $CVSROOT.  For the first match that is found, then the remainder of the\n"
block|,
literal|"# line is the name of the file that contains the template.\n"
block|,
literal|"#\n"
block|,
literal|"# If the repository name does not match any of the regular expressions in this\n"
block|,
literal|"# file, the \"DEFAULT\" line is used, if it is specified.\n"
block|,
literal|"#\n"
block|,
literal|"# If the name \"ALL\" appears as a regular expression it is always used\n"
block|,
literal|"# in addition to the first matching regex or \"DEFAULT\".\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|editinfo_contents
index|[]
init|=
block|{
literal|"# The \"editinfo\" file is used to allow verification of logging\n"
block|,
literal|"# information.  It works best when a template (as specified in the\n"
block|,
literal|"# rcsinfo file) is provided for the logging procedure.  Given a\n"
block|,
literal|"# template with locations for, a bug-id number, a list of people who\n"
block|,
literal|"# reviewed the code before it can be checked in, and an external\n"
block|,
literal|"# process to catalog the differences that were code reviewed, the\n"
block|,
literal|"# following test can be applied to the code:\n"
block|,
literal|"#\n"
block|,
literal|"#   Making sure that the entered bug-id number is correct.\n"
block|,
literal|"#   Validating that the code that was reviewed is indeed the code being\n"
block|,
literal|"#       checked in (using the bug-id number or a seperate review\n"
block|,
literal|"#       number to identify this particular code set.).\n"
block|,
literal|"#\n"
block|,
literal|"# If any of the above test failed, then the commit would be aborted.\n"
block|,
literal|"#\n"
block|,
literal|"# Actions such as mailing a copy of the report to each reviewer are\n"
block|,
literal|"# better handled by an entry in the loginfo file.\n"
block|,
literal|"#\n"
block|,
literal|"# One thing that should be noted is the the ALL keyword is not\n"
block|,
literal|"# supported.  There can be only one entry that matches a given\n"
block|,
literal|"# repository.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|verifymsg_contents
index|[]
init|=
block|{
literal|"# The \"verifymsg\" file is used to allow verification of logging\n"
block|,
literal|"# information.  It works best when a template (as specified in the\n"
block|,
literal|"# rcsinfo file) is provided for the logging procedure.  Given a\n"
block|,
literal|"# template with locations for, a bug-id number, a list of people who\n"
block|,
literal|"# reviewed the code before it can be checked in, and an external\n"
block|,
literal|"# process to catalog the differences that were code reviewed, the\n"
block|,
literal|"# following test can be applied to the code:\n"
block|,
literal|"#\n"
block|,
literal|"#   Making sure that the entered bug-id number is correct.\n"
block|,
literal|"#   Validating that the code that was reviewed is indeed the code being\n"
block|,
literal|"#       checked in (using the bug-id number or a seperate review\n"
block|,
literal|"#       number to identify this particular code set.).\n"
block|,
literal|"#\n"
block|,
literal|"# If any of the above test failed, then the commit would be aborted.\n"
block|,
literal|"#\n"
block|,
literal|"# Actions such as mailing a copy of the report to each reviewer are\n"
block|,
literal|"# better handled by an entry in the loginfo file.\n"
block|,
literal|"#\n"
block|,
literal|"# One thing that should be noted is the the ALL keyword is not\n"
block|,
literal|"# supported.  There can be only one entry that matches a given\n"
block|,
literal|"# repository.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|commitinfo_contents
index|[]
init|=
block|{
literal|"# The \"commitinfo\" file is used to control pre-commit checks.\n"
block|,
literal|"# The filter on the right is invoked with the repository and a list \n"
block|,
literal|"# of files to check.  A non-zero exit of the filter program will \n"
block|,
literal|"# cause the commit to be aborted.\n"
block|,
literal|"#\n"
block|,
literal|"# The first entry on a line is a regular expression which is tested\n"
block|,
literal|"# against the directory that the change is being committed to, relative\n"
block|,
literal|"# to the $CVSROOT.  For the first match that is found, then the remainder\n"
block|,
literal|"# of the line is the name of the filter to run.\n"
block|,
literal|"#\n"
block|,
literal|"# If the repository name does not match any of the regular expressions in this\n"
block|,
literal|"# file, the \"DEFAULT\" line is used, if it is specified.\n"
block|,
literal|"#\n"
block|,
literal|"# If the name \"ALL\" appears as a regular expression it is always used\n"
block|,
literal|"# in addition to the first matching regex or \"DEFAULT\".\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|taginfo_contents
index|[]
init|=
block|{
literal|"# The \"taginfo\" file is used to control pre-tag checks.\n"
block|,
literal|"# The filter on the right is invoked with the following arguments:\n"
block|,
literal|"#\n"
block|,
literal|"# $1 -- tagname\n"
block|,
literal|"# $2 -- operation \"add\" for tag, \"mov\" for tag -F, and \"del\" for tag -d\n"
block|,
literal|"# $3 -- repository\n"
block|,
literal|"# $4->  file revision [file revision ...]\n"
block|,
literal|"#\n"
block|,
literal|"# A non-zero exit of the filter program will cause the tag to be aborted.\n"
block|,
literal|"#\n"
block|,
literal|"# The first entry on a line is a regular expression which is tested\n"
block|,
literal|"# against the directory that the change is being committed to, relative\n"
block|,
literal|"# to the $CVSROOT.  For the first match that is found, then the remainder\n"
block|,
literal|"# of the line is the name of the filter to run.\n"
block|,
literal|"#\n"
block|,
literal|"# If the repository name does not match any of the regular expressions in this\n"
block|,
literal|"# file, the \"DEFAULT\" line is used, if it is specified.\n"
block|,
literal|"#\n"
block|,
literal|"# If the name \"ALL\" appears as a regular expression it is always used\n"
block|,
literal|"# in addition to the first matching regex or \"DEFAULT\".\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|checkoutlist_contents
index|[]
init|=
block|{
literal|"# The \"checkoutlist\" file is used to support additional version controlled\n"
block|,
literal|"# administrative files in $CVSROOT/CVSROOT, such as template files.\n"
block|,
literal|"#\n"
block|,
literal|"# The first entry on a line is a filename which will be checked out from\n"
block|,
literal|"# the corresponding RCS file in the $CVSROOT/CVSROOT directory.\n"
block|,
literal|"# The remainder of the line is an error message to use if the file cannot\n"
block|,
literal|"# be checked out.\n"
block|,
literal|"#\n"
block|,
literal|"# File format:\n"
block|,
literal|"#\n"
block|,
literal|"#	[<whitespace>]<filename><whitespace><error message><end-of-line>\n"
block|,
literal|"#\n"
block|,
literal|"# comment lines begin with '#'\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cvswrappers_contents
index|[]
init|=
block|{
literal|"# This file affects handling of files based on their names.\n"
block|,
literal|"#\n"
block|,
literal|"# The -t/-f options allow one to treat directories of files\n"
block|,
literal|"# as a single file, or to transform a file in other ways on\n"
block|,
literal|"# its way in and out of CVS.\n"
block|,
literal|"#\n"
block|,
literal|"# The -m option specifies whether CVS attempts to merge files.\n"
block|,
literal|"#\n"
block|,
literal|"# The -k option specifies keyword expansion (e.g. -kb for binary).\n"
block|,
literal|"#\n"
block|,
literal|"# Format of wrapper file ($CVSROOT/CVSROOT/cvswrappers or .cvswrappers)\n"
block|,
literal|"#\n"
block|,
literal|"#  wildcard	[option value][option value]...\n"
block|,
literal|"#\n"
block|,
literal|"#  where option is one of\n"
block|,
literal|"#  -f		from cvs filter		value: path to filter\n"
block|,
literal|"#  -t		to cvs filter		value: path to filter\n"
block|,
literal|"#  -m		update methodology	value: MERGE or COPY\n"
block|,
literal|"#  -k		expansion mode		value: b, o, kkv,&c\n"
block|,
literal|"#\n"
block|,
literal|"#  and value is a single-quote delimited value.\n"
block|,
literal|"# For example:\n"
block|,
literal|"#*.gif -k 'b'\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|notify_contents
index|[]
init|=
block|{
literal|"# The \"notify\" file controls where notifications from watches set by\n"
block|,
literal|"# \"cvs watch add\" or \"cvs edit\" are sent.  The first entry on a line is\n"
block|,
literal|"# a regular expression which is tested against the directory that the\n"
block|,
literal|"# change is being made to, relative to the $CVSROOT.  If it matches,\n"
block|,
literal|"# then the remainder of the line is a filter program that should contain\n"
block|,
literal|"# one occurrence of %s for the user to notify, and information on its\n"
block|,
literal|"# standard input.\n"
block|,
literal|"#\n"
block|,
literal|"# \"ALL\" or \"DEFAULT\" can be used in place of the regular expression.\n"
block|,
literal|"#\n"
block|,
literal|"# For example:\n"
block|,
literal|"#ALL mail %s -s \"CVS notification\"\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|modules_contents
index|[]
init|=
block|{
literal|"# Three different line formats are valid:\n"
block|,
literal|"#	key	-a    aliases...\n"
block|,
literal|"#	key [options] directory\n"
block|,
literal|"#	key [options] directory files...\n"
block|,
literal|"#\n"
block|,
literal|"# Where \"options\" are composed of:\n"
block|,
literal|"#	-i prog		Run \"prog\" on \"cvs commit\" from top-level of module.\n"
block|,
literal|"#	-o prog		Run \"prog\" on \"cvs checkout\" of module.\n"
block|,
literal|"#	-e prog		Run \"prog\" on \"cvs export\" of module.\n"
block|,
literal|"#	-t prog		Run \"prog\" on \"cvs rtag\" of module.\n"
block|,
literal|"#	-u prog		Run \"prog\" on \"cvs update\" of module.\n"
block|,
literal|"#	-d dir		Place module in directory \"dir\" instead of module name.\n"
block|,
literal|"#	-l		Top-level directory only -- do not recurse.\n"
block|,
literal|"#\n"
block|,
literal|"# NOTE:  If you change any of the \"Run\" options above, you'll have to\n"
block|,
literal|"# release and re-checkout any working directories of these modules.\n"
block|,
literal|"#\n"
block|,
literal|"# And \"directory\" is a path to a directory relative to $CVSROOT.\n"
block|,
literal|"#\n"
block|,
literal|"# The \"-a\" option specifies an alias.  An alias is interpreted as if\n"
block|,
literal|"# everything on the right of the \"-a\" had been typed on the command line.\n"
block|,
literal|"#\n"
block|,
literal|"# You can encode a module within a module by using the special '&'\n"
block|,
literal|"# character to interpose another module into the current module.  This\n"
block|,
literal|"# can be useful for creating a module that consists of many directories\n"
block|,
literal|"# spread out over the entire source repository.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|config_contents
index|[]
init|=
block|{
literal|"# Set this to \"no\" if pserver shouldn't check system users/passwords\n"
block|,
literal|"#SystemAuth=no\n"
block|,
literal|"\n"
block|,
literal|"# Put CVS lock files in this directory rather than directly in the repository.\n"
block|,
literal|"#LockDir=/var/lock/cvs\n"
block|,
literal|"\n"
block|,
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
literal|"# Set `PreservePermissions' to `yes' to save file status information\n"
block|,
literal|"# in the repository.\n"
block|,
literal|"#PreservePermissions=no\n"
block|,
literal|"\n"
block|,
endif|#
directive|endif
literal|"# Set `TopLevelAdmin' to `yes' to create a CVS directory at the top\n"
block|,
literal|"# level of the new working directory when using the `cvs checkout'\n"
block|,
literal|"# command.\n"
block|,
literal|"#TopLevelAdmin=no\n"
block|,
literal|"\n"
block|,
literal|"# Set `LogHistory' to `all' or `TOFEWGCMAR' to log all transactions to the\n"
block|,
literal|"# history file, or a subset as needed (ie `TMAR' logs all write operations)\n"
block|,
literal|"#LogHistory=TOFEWGCMAR\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|admin_file
name|filelist
index|[]
init|=
block|{
block|{
name|CVSROOTADM_LOGINFO
block|,
literal|"no logging of 'cvs commit' messages is done without a %s file"
block|,
operator|&
name|loginfo_contents
index|[
literal|0
index|]
block|}
block|,
block|{
name|CVSROOTADM_RCSINFO
block|,
literal|"a %s file can be used to configure 'cvs commit' templates"
block|,
name|rcsinfo_contents
block|}
block|,
block|{
name|CVSROOTADM_EDITINFO
block|,
literal|"a %s file can be used to validate log messages"
block|,
name|editinfo_contents
block|}
block|,
block|{
name|CVSROOTADM_VERIFYMSG
block|,
literal|"a %s file can be used to validate log messages"
block|,
name|verifymsg_contents
block|}
block|,
block|{
name|CVSROOTADM_COMMITINFO
block|,
literal|"a %s file can be used to configure 'cvs commit' checking"
block|,
name|commitinfo_contents
block|}
block|,
block|{
name|CVSROOTADM_TAGINFO
block|,
literal|"a %s file can be used to configure 'cvs tag' checking"
block|,
name|taginfo_contents
block|}
block|,
block|{
name|CVSROOTADM_IGNORE
block|,
literal|"a %s file can be used to specify files to ignore"
block|,
name|NULL
block|}
block|,
block|{
name|CVSROOTADM_CHECKOUTLIST
block|,
literal|"a %s file can specify extra CVSROOT files to auto-checkout"
block|,
name|checkoutlist_contents
block|}
block|,
block|{
name|CVSROOTADM_WRAPPER
block|,
literal|"a %s file can be used to specify files to treat as wrappers"
block|,
name|cvswrappers_contents
block|}
block|,
block|{
name|CVSROOTADM_NOTIFY
block|,
literal|"a %s file can be used to specify where notifications go"
block|,
name|notify_contents
block|}
block|,
block|{
name|CVSROOTADM_MODULES
block|,
comment|/* modules is special-cased in mkmodules.  */
name|NULL
block|,
name|modules_contents
block|}
block|,
block|{
name|CVSROOTADM_READERS
block|,
literal|"a %s file specifies read-only users"
block|,
name|NULL
block|}
block|,
block|{
name|CVSROOTADM_WRITERS
block|,
literal|"a %s file specifies read/write users"
block|,
name|NULL
block|}
block|,
comment|/* Some have suggested listing CVSROOTADM_PASSWD here too.  This        would mean that CVS commands which operate on the        CVSROOTADM_PASSWD file would transmit hashed passwords over the        net.  This might seem to be no big deal, as pserver normally        transmits cleartext passwords, but the difference is that        CVSROOTADM_PASSWD contains *all* passwords, not just the ones        currently being used.  For example, it could be too easy to        accidentally give someone readonly access to CVSROOTADM_PASSWD        (e.g. via anonymous CVS or cvsweb), and then if there are any        guessable passwords for read/write access (usually there will be)        they get read/write access.         Another worry is the implications of storing old passwords--if        someone used a password in the past they might be using it        elsewhere, using a similar password, etc, and so saving old        passwords, even hashed, is probably not a good idea.  */
block|{
name|CVSROOTADM_CONFIG
block|,
literal|"a %s file configures various behaviors"
block|,
name|config_contents
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rebuild the checked out administrative files in directory DIR.  */
end_comment

begin_function
name|int
name|mkmodules
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
ifdef|#
directive|ifdef
name|MY_NDBM
name|DBM
modifier|*
name|db
decl_stmt|;
endif|#
directive|endif
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|admin_file
modifier|*
name|fileptr
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/*      * First, do the work necessary to update the "modules" database.      */
name|temp
operator|=
name|make_tempfile
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|checkout_file
argument_list|(
name|CVSROOTADM_MODULES
argument_list|,
name|temp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* everything ok */
ifdef|#
directive|ifdef
name|MY_NDBM
comment|/* open it, to generate any duplicate errors */
if|if
condition|(
operator|(
name|db
operator|=
name|dbm_open
argument_list|(
name|temp
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
else|#
directive|else
name|write_dbmfile
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|rename_dbmfile
argument_list|(
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rename_rcsfile
argument_list|(
name|temp
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"'cvs checkout' is less functional without a %s file"
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on checkout_file() */
if|if
condition|(
name|unlink_file
argument_list|(
name|temp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Checkout the files that need it in CVSROOT dir */
for|for
control|(
name|fileptr
operator|=
name|filelist
init|;
name|fileptr
operator|&&
name|fileptr
operator|->
name|filename
condition|;
name|fileptr
operator|++
control|)
block|{
if|if
condition|(
name|fileptr
operator|->
name|errormsg
operator|==
name|NULL
condition|)
continue|continue;
name|temp
operator|=
name|make_tempfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkout_file
argument_list|(
name|fileptr
operator|->
name|filename
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
name|rename_rcsfile
argument_list|(
name|temp
argument_list|,
name|fileptr
operator|->
name|filename
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * If there was some problem other than the file not existing, 	 * checkout_file already printed a real error message.  If the 	 * file does not exist, it is harmless--it probably just means 	 * that the repository was created with an old version of CVS 	 * which didn't have so many files in CVSROOT. 	 */
block|else if (fileptr->errormsg) 	    error (0, 0, fileptr->errormsg, fileptr->filename);
endif|#
directive|endif
if|if
condition|(
name|unlink_file
argument_list|(
name|temp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSROOTADM_CHECKOUTLIST
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
comment|/* 	 * File format: 	 *  [<whitespace>]<filename><whitespace><error message><end-of-line> 	 * 	 * comment lines begin with '#' 	 */
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* skip lines starting with # */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|last
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|last
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the newline */
comment|/* Skip leading white space. */
for|for
control|(
name|fname
operator|=
name|line
init|;
operator|*
name|fname
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fname
argument_list|)
condition|;
name|fname
operator|++
control|)
empty_stmt|;
comment|/* Find end of filename. */
for|for
control|(
name|cp
operator|=
name|fname
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|make_tempfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkout_file
argument_list|(
name|fname
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rename_rcsfile
argument_list|(
name|temp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cp
operator|++
init|;
name|cp
operator|<
name|last
operator|&&
operator|*
name|last
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|last
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|cp
operator|<
name|last
operator|&&
operator|*
name|cp
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|cp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlink_file
argument_list|(
name|temp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSROOTADM_CHECKOUTLIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSROOTADM_CHECKOUTLIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Error from CVS_FOPEN.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|CVSROOTADM_CHECKOUTLIST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Yeah, I know, there are NFS race conditions here.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_tempfile
parameter_list|()
block|{
specifier|static
name|int
name|seed
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
name|seed
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s%d"
argument_list|,
name|BAKPREFIX
argument_list|,
name|seed
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|temp
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close temporary file %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Get a file.  If the file does not exist, return 1 silently.  If    there is an error, print a message and return 1 (FIXME: probably    not a very clean convention).  On success, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|checkout_file
parameter_list|(
name|file
parameter_list|,
name|temp
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
block|{
name|char
modifier|*
name|rcs
decl_stmt|;
name|RCSNode
modifier|*
name|rcsnode
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
literal|0
return|;
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcs
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcs
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rcsnode
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcsnode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|temp
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
comment|/* Probably not necessary (?); RCS_checkout already printed a 	   message.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"failed to check out %s file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|freercsnode
argument_list|(
operator|&
name|rcsnode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|retcode
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MY_NDBM
end_ifndef

begin_function
specifier|static
name|void
name|write_dbmfile
parameter_list|(
name|temp
parameter_list|)
name|char
modifier|*
name|temp
decl_stmt|;
block|{
name|char
name|line
index|[
name|DBLKSIZ
index|]
decl_stmt|,
name|value
index|[
name|DBLKSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cont
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dbm_open
argument_list|(
name|temp
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open dbm file %s for creation"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|cont
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the newline */
comment|/* 	 * Add the line to the value, at the end if this is a continuation 	 * line; otherwise at the beginning, but only after any trailing 	 * backslash is removed. 	 */
name|vp
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|cont
condition|)
name|vp
operator|+=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * See if the line we read is a continuation line, and strip the 	 * backslash if so. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|cp
operator|=
operator|&
name|line
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
condition|)
block|{
name|cont
operator|=
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|cont
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vp
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* comment line */
name|vp
operator|=
name|value
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* empty line */
comment|/* 	 * If this was not a continuation line, add the entry to the database 	 */
if|if
condition|(
operator|!
name|cont
condition|)
block|{
name|key
operator|.
name|dptr
operator|=
name|vp
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|vp
operator|-
name|key
operator|.
name|dptr
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* NULL terminate the key */
while|while
condition|(
operator|*
name|vp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
comment|/* skip whitespace to value */
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: NULL value for key `%s'"
argument_list|,
name|key
operator|.
name|dptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|val
operator|.
name|dptr
operator|=
name|vp
expr_stmt|;
name|val
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbm_store
argument_list|(
name|db
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|DBM_INSERT
argument_list|)
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate key found for `%s'"
argument_list|,
name|key
operator|.
name|dptr
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
block|}
block|}
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* I think that the size of the buffer needed here is 	   just determined by sizeof (CVSROOTADM_MODULES), the 	   filenames created by make_tempfile, and other things that won't 	   overflow.  */
name|char
name|dotdir
index|[
literal|50
index|]
decl_stmt|,
name|dotpag
index|[
literal|50
index|]
decl_stmt|,
name|dotdb
index|[
literal|50
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotdir
argument_list|,
literal|"%s.dir"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotpag
argument_list|,
literal|"%s.pag"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotdb
argument_list|,
literal|"%s.db"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|dotdir
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|dotdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|dotpag
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|dotpag
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|dotdb
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|dotdb
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DBM creation failed; correct above errors"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rename_dbmfile
parameter_list|(
name|temp
parameter_list|)
name|char
modifier|*
name|temp
decl_stmt|;
block|{
comment|/* I think that the size of the buffer needed here is        just determined by sizeof (CVSROOTADM_MODULES), the        filenames created by make_tempfile, and other things that won't        overflow.  */
name|char
name|newdir
index|[
literal|50
index|]
decl_stmt|,
name|newpag
index|[
literal|50
index|]
decl_stmt|,
name|newdb
index|[
literal|50
index|]
decl_stmt|;
name|char
name|dotdir
index|[
literal|50
index|]
decl_stmt|,
name|dotpag
index|[
literal|50
index|]
decl_stmt|,
name|dotdb
index|[
literal|50
index|]
decl_stmt|;
name|char
name|bakdir
index|[
literal|50
index|]
decl_stmt|,
name|bakpag
index|[
literal|50
index|]
decl_stmt|,
name|bakdb
index|[
literal|50
index|]
decl_stmt|;
name|int
name|dir1_errno
init|=
literal|0
decl_stmt|,
name|pag1_errno
init|=
literal|0
decl_stmt|,
name|db1_errno
init|=
literal|0
decl_stmt|;
name|int
name|dir2_errno
init|=
literal|0
decl_stmt|,
name|pag2_errno
init|=
literal|0
decl_stmt|,
name|db2_errno
init|=
literal|0
decl_stmt|;
name|int
name|dir3_errno
init|=
literal|0
decl_stmt|,
name|pag3_errno
init|=
literal|0
decl_stmt|,
name|db3_errno
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotdir
argument_list|,
literal|"%s.dir"
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotpag
argument_list|,
literal|"%s.pag"
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dotdb
argument_list|,
literal|"%s.db"
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bakdir
argument_list|,
literal|"%s%s.dir"
argument_list|,
name|BAKPREFIX
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bakpag
argument_list|,
literal|"%s%s.pag"
argument_list|,
name|BAKPREFIX
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bakdb
argument_list|,
literal|"%s%s.db"
argument_list|,
name|BAKPREFIX
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newdir
argument_list|,
literal|"%s.dir"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newpag
argument_list|,
literal|"%s.pag"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newdb
argument_list|,
literal|"%s.db"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|newdir
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|newpag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|newdb
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
comment|/* don't mess with me */
name|SIG_beginCrSect
argument_list|()
expr_stmt|;
comment|/* rm .#modules.dir .#modules.pag */
if|if
condition|(
name|unlink_file
argument_list|(
name|bakdir
argument_list|)
operator|<
literal|0
condition|)
name|dir1_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|bakpag
argument_list|)
operator|<
literal|0
condition|)
name|pag1_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|bakdb
argument_list|)
operator|<
literal|0
condition|)
name|db1_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv modules.dir .#modules.dir */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|dotdir
argument_list|,
name|bakdir
argument_list|)
operator|<
literal|0
condition|)
name|dir2_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv modules.pag .#modules.pag */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|dotpag
argument_list|,
name|bakpag
argument_list|)
operator|<
literal|0
condition|)
name|pag2_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv modules.db .#modules.db */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|dotdb
argument_list|,
name|bakdb
argument_list|)
operator|<
literal|0
condition|)
name|db2_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv "temp".dir modules.dir */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|newdir
argument_list|,
name|dotdir
argument_list|)
operator|<
literal|0
condition|)
name|dir3_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv "temp".pag modules.pag */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|newpag
argument_list|,
name|dotpag
argument_list|)
operator|<
literal|0
condition|)
name|pag3_errno
operator|=
name|errno
expr_stmt|;
comment|/* mv "temp".db modules.db */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|newdb
argument_list|,
name|dotdb
argument_list|)
operator|<
literal|0
condition|)
name|db3_errno
operator|=
name|errno
expr_stmt|;
comment|/* OK -- make my day */
name|SIG_endCrSect
argument_list|()
expr_stmt|;
comment|/* I didn't want to call error() when we had signals blocked        (unnecessary?), but do it now.  */
if|if
condition|(
name|dir1_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|dir1_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|dir1_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|pag1_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|pag1_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|pag1_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakpag
argument_list|)
expr_stmt|;
if|if
condition|(
name|db1_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|db1_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|db1_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir2_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|dir2_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|dir2_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|pag2_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|pag2_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|pag2_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakpag
argument_list|)
expr_stmt|;
if|if
condition|(
name|db2_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|db2_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|db2_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir3_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|dir3_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|dir3_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|pag3_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|pag3_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|pag3_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakpag
argument_list|)
expr_stmt|;
if|if
condition|(
name|db3_errno
operator|&&
operator|!
name|existence_error
argument_list|(
name|db3_errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|db3_errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bakdb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MY_NDBM */
end_comment

begin_function
specifier|static
name|void
name|rename_rcsfile
parameter_list|(
name|temp
parameter_list|,
name|real
parameter_list|)
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|real
decl_stmt|;
block|{
name|char
modifier|*
name|bak
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
comment|/* Set "x" bits if set in original. */
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|real
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s%s"
argument_list|,
name|real
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|statbuf
operator|.
name|st_mode
operator|=
literal|0
expr_stmt|;
comment|/* in case rcs file doesn't exist, but it should... */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|rcs
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|temp
argument_list|,
literal|0444
operator||
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|0111
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot chmod %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|bak
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|real
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bak
argument_list|,
literal|"%s%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|real
argument_list|)
expr_stmt|;
comment|/* rm .#loginfo */
if|if
condition|(
name|unlink_file
argument_list|(
name|bak
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|bak
argument_list|)
expr_stmt|;
comment|/* mv loginfo .#loginfo */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|real
argument_list|,
name|bak
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot rename %s to %s"
argument_list|,
name|real
argument_list|,
name|bak
argument_list|)
expr_stmt|;
comment|/* mv "temp" loginfo */
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|temp
argument_list|,
name|real
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot rename %s to %s"
argument_list|,
name|temp
argument_list|,
name|real
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bak
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|init_usage
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
comment|/* Name of CVSROOT directory.  */
name|char
modifier|*
name|adm
decl_stmt|;
comment|/* Name of this administrative file.  */
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Name of ,v file for this administrative file.  */
name|char
modifier|*
name|info_v
decl_stmt|;
comment|/* Exit status.  */
name|int
name|err
decl_stmt|;
specifier|const
name|struct
name|admin_file
modifier|*
name|fileptr
decl_stmt|;
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
operator|||
name|argc
operator|>
literal|1
condition|)
name|usage
argument_list|(
name|init_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|send_init_command
argument_list|()
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
comment|/* Note: we do *not* create parent directories as needed like the        old cvsinit.sh script did.  Few utilities do that, and a        non-existent parent directory is as likely to be a typo as something        which needs to be created.  */
name|mkdir_if_needed
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|adm
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|adm
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|adm
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|adm
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
name|mkdir_if_needed
argument_list|(
name|adm
argument_list|)
expr_stmt|;
comment|/* This is needed because we pass "fileptr->filename" not "info"        to add_rcs_file below.  I think this would be easy to change,        thus nuking the need for CVS_CHDIR here, but I haven't looked        closely (e.g. see wrappers calls within add_rcs_file).  */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|adm
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change to directory %s"
argument_list|,
name|adm
argument_list|)
expr_stmt|;
comment|/* Make Emptydir so it's there if we need it */
name|mkdir_if_needed
argument_list|(
name|CVSNULLREPOS
argument_list|)
expr_stmt|;
comment|/* 80 is long enough for all the administrative file names, plus        "/" and so on.  */
name|info
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|adm
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|info_v
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|adm
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
for|for
control|(
name|fileptr
operator|=
name|filelist
init|;
name|fileptr
operator|&&
name|fileptr
operator|->
name|filename
condition|;
operator|++
name|fileptr
control|)
block|{
if|if
condition|(
name|fileptr
operator|->
name|contents
operator|==
name|NULL
condition|)
continue|continue;
name|strcpy
argument_list|(
name|info
argument_list|,
name|adm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
name|fileptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|info_v
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info_v
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|info_v
argument_list|)
condition|)
comment|/* We will check out this file in the mkmodules step. 	       Nothing else is required.  */
empty_stmt|;
else|else
block|{
name|int
name|retcode
decl_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|info
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fileptr
operator|->
name|contents
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|fputs
argument_list|(
operator|*
name|p
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* The message used to say " of " and fileptr->filename after 	       "initial checkin" but I fail to see the point as we know what 	       file it is from the name.  */
name|retcode
operator|=
name|add_rcs_file
argument_list|(
literal|"initial checkin"
argument_list|,
name|info_v
argument_list|,
name|fileptr
operator|->
name|filename
argument_list|,
literal|"1.1"
argument_list|,
name|NULL
argument_list|,
comment|/* No vendor branch.  */
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
comment|/* add_rcs_file already printed an error message.  */
name|err
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Turn on history logging by default.  The user can remove the file        to disable it.  */
name|strcpy
argument_list|(
name|info
argument_list|,
name|adm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|info
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Make the new history file world-writeable, since every CVS            user will need to be able to write to it.  We use chmod()            because xchmod() is too shy. */
name|chmod
argument_list|(
name|info
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
comment|/* Make an empty val-tags file to prevent problems creating it later.  */
name|strcpy
argument_list|(
name|info
argument_list|,
name|adm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|info
argument_list|,
name|CVSROOTADM_VALTAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|info
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Make the new val-tags file world-writeable, since every CVS            user will need to be able to write to it.  We use chmod()            because xchmod() is too shy. */
name|chmod
argument_list|(
name|info
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info_v
argument_list|)
expr_stmt|;
name|mkmodules
argument_list|(
name|adm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

