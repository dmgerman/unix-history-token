begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Trivially encode strings to protect them from innocent eyes (i.e.,  * inadvertent password compromises, like a network administrator  * who's watching packets for legitimate reasons and accidentally sees  * the password protocol go by).  *   * This is NOT secure encryption.  *  * It would be tempting to encode the password according to username  * and repository, so that the same password would encode to a  * different string when used with different usernames and/or  * repositories.  However, then users would not be able to cut and  * paste passwords around.  They're not supposed to anyway, but we all  * know they will, and there's no reason to make it harder for them if  * we're not trying to provide real security anyway.  */
end_comment

begin_comment
comment|/* Set this to test as a standalone program. */
end_comment

begin_comment
comment|/* #define DIAGNOSTIC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIAGNOSTIC
end_ifndef

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! DIAGNOSTIC */
end_comment

begin_comment
comment|/* cvs.h won't define this for us */
end_comment

begin_define
define|#
directive|define
name|AUTH_CLIENT_SUPPORT
end_define

begin_define
define|#
directive|define
name|xmalloc
value|malloc
end_define

begin_comment
comment|/* Use "gcc -fwritable-strings". */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! DIAGNOSTIC */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* Map characters to each other randomly and symmetrically, A<--> B.  *  * We divide the ASCII character set into 3 domains: control chars (0  * thru 31), printing chars (32 through 126), and "meta"-chars (127  * through 255).  The control chars map _to_ themselves, the printing  * chars map _among_ themselves, and the meta chars map _among_  * themselves.  Why is this thus?  *  * No character in any of these domains maps to a character in another  * domain, because I'm not sure what characters are legal in  * passwords, or what tools people are likely to use to cut and paste  * them.  It seems prudent not to introduce control or meta chars,  * unless the user introduced them first.  And having the control  * chars all map to themselves insures that newline and  * carriage-return are safely handled.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|shifts
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|114
block|,
literal|120
block|,
literal|53
block|,
literal|79
block|,
literal|96
block|,
literal|109
block|,
literal|72
block|,
literal|108
block|,
literal|70
block|,
literal|64
block|,
literal|76
block|,
literal|67
block|,
literal|116
block|,
literal|74
block|,
literal|68
block|,
literal|87
block|,
literal|111
block|,
literal|52
block|,
literal|75
block|,
literal|119
block|,
literal|49
block|,
literal|34
block|,
literal|82
block|,
literal|81
block|,
literal|95
block|,
literal|65
block|,
literal|112
block|,
literal|86
block|,
literal|118
block|,
literal|110
block|,
literal|122
block|,
literal|105
block|,
literal|41
block|,
literal|57
block|,
literal|83
block|,
literal|43
block|,
literal|46
block|,
literal|102
block|,
literal|40
block|,
literal|89
block|,
literal|38
block|,
literal|103
block|,
literal|45
block|,
literal|50
block|,
literal|42
block|,
literal|123
block|,
literal|91
block|,
literal|35
block|,
literal|125
block|,
literal|55
block|,
literal|54
block|,
literal|66
block|,
literal|124
block|,
literal|126
block|,
literal|59
block|,
literal|47
block|,
literal|92
block|,
literal|71
block|,
literal|115
block|,
literal|78
block|,
literal|88
block|,
literal|107
block|,
literal|106
block|,
literal|56
block|,
literal|36
block|,
literal|121
block|,
literal|117
block|,
literal|104
block|,
literal|101
block|,
literal|100
block|,
literal|69
block|,
literal|73
block|,
literal|99
block|,
literal|63
block|,
literal|94
block|,
literal|93
block|,
literal|39
block|,
literal|37
block|,
literal|61
block|,
literal|48
block|,
literal|58
block|,
literal|113
block|,
literal|32
block|,
literal|90
block|,
literal|44
block|,
literal|98
block|,
literal|60
block|,
literal|51
block|,
literal|33
block|,
literal|97
block|,
literal|62
block|,
literal|77
block|,
literal|84
block|,
literal|80
block|,
literal|85
block|,
literal|223
block|,
literal|225
block|,
literal|216
block|,
literal|187
block|,
literal|166
block|,
literal|229
block|,
literal|189
block|,
literal|222
block|,
literal|188
block|,
literal|141
block|,
literal|249
block|,
literal|148
block|,
literal|200
block|,
literal|184
block|,
literal|136
block|,
literal|248
block|,
literal|190
block|,
literal|199
block|,
literal|170
block|,
literal|181
block|,
literal|204
block|,
literal|138
block|,
literal|232
block|,
literal|218
block|,
literal|183
block|,
literal|255
block|,
literal|234
block|,
literal|220
block|,
literal|247
block|,
literal|213
block|,
literal|203
block|,
literal|226
block|,
literal|193
block|,
literal|174
block|,
literal|172
block|,
literal|228
block|,
literal|252
block|,
literal|217
block|,
literal|201
block|,
literal|131
block|,
literal|230
block|,
literal|197
block|,
literal|211
block|,
literal|145
block|,
literal|238
block|,
literal|161
block|,
literal|179
block|,
literal|160
block|,
literal|212
block|,
literal|207
block|,
literal|221
block|,
literal|254
block|,
literal|173
block|,
literal|202
block|,
literal|146
block|,
literal|224
block|,
literal|151
block|,
literal|140
block|,
literal|196
block|,
literal|205
block|,
literal|130
block|,
literal|135
block|,
literal|133
block|,
literal|143
block|,
literal|246
block|,
literal|192
block|,
literal|159
block|,
literal|244
block|,
literal|239
block|,
literal|185
block|,
literal|168
block|,
literal|215
block|,
literal|144
block|,
literal|139
block|,
literal|165
block|,
literal|180
block|,
literal|157
block|,
literal|147
block|,
literal|186
block|,
literal|214
block|,
literal|176
block|,
literal|227
block|,
literal|231
block|,
literal|219
block|,
literal|169
block|,
literal|175
block|,
literal|156
block|,
literal|206
block|,
literal|198
block|,
literal|129
block|,
literal|164
block|,
literal|150
block|,
literal|210
block|,
literal|154
block|,
literal|177
block|,
literal|134
block|,
literal|127
block|,
literal|182
block|,
literal|128
block|,
literal|158
block|,
literal|208
block|,
literal|162
block|,
literal|132
block|,
literal|167
block|,
literal|209
block|,
literal|149
block|,
literal|241
block|,
literal|153
block|,
literal|251
block|,
literal|237
block|,
literal|236
block|,
literal|171
block|,
literal|195
block|,
literal|243
block|,
literal|233
block|,
literal|253
block|,
literal|240
block|,
literal|194
block|,
literal|250
block|,
literal|191
block|,
literal|155
block|,
literal|142
block|,
literal|137
block|,
literal|245
block|,
literal|235
block|,
literal|163
block|,
literal|242
block|,
literal|178
block|,
literal|152
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCRAMBLE and DESCRAMBLE work like this:  *  * scramble(STR) returns SCRM, a scrambled copy of STR.  SCRM[0] is a  * single letter indicating the scrambling method.  As of this  * writing, the only legal method is 'A', but check the code for more  * up-to-date information.  The copy will have been allocated with  * malloc().   *  * descramble(SCRM) returns STR, again in its own malloc'd space.  * descramble() uses SCRM[0] to determine which method of unscrambling  * to use.  If it does not recognize the method, it dies with error.  */
end_comment

begin_comment
comment|/* Return a malloc'd, scrambled version of STR. */
end_comment

begin_function
name|char
modifier|*
name|scramble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
comment|/* +2 to hold the 'A' prefix that indicates which version of        scrambling this is (the first, obviously, since we only do one        kind of scrambling so far), and then the '\0' of course.  */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Scramble (TM) version prefix. */
name|s
index|[
literal|0
index|]
operator|=
literal|'A'
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
name|shifts
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Decode the string in place. */
end_comment

begin_function
name|char
modifier|*
name|descramble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* For now we can only handle one kind of scrambling.  In the future        there may be other kinds, and this `if' will become a `switch'.  */
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'A'
condition|)
ifndef|#
directive|ifndef
name|DIAGNOSTIC
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"descramble: unknown scrambling method"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DIAGNOSTIC */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"descramble: unknown scrambling method\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
comment|/* Method `A' is symmetrical, so scramble again to decrypt. */
name|s
operator|=
name|scramble
argument_list|(
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Shift the whole string one char to the left, pushing the unwanted        'A' off the left end.  Safe, because s is null-terminated. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (AUTH_CLIENT_SUPPORT || AUTH_SERVER_SUPPORT) from top of file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function
name|int
name|main
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|m
decl_stmt|,
name|biggie
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|cleartexts
index|[
literal|5
index|]
decl_stmt|;
name|cleartexts
index|[
literal|0
index|]
operator|=
literal|"first"
expr_stmt|;
name|cleartexts
index|[
literal|1
index|]
operator|=
literal|"the second"
expr_stmt|;
name|cleartexts
index|[
literal|2
index|]
operator|=
literal|"this is the third"
expr_stmt|;
name|cleartexts
index|[
literal|3
index|]
operator|=
literal|"$#% !!\\3"
expr_stmt|;
name|cleartexts
index|[
literal|4
index|]
operator|=
name|biggie
expr_stmt|;
comment|/* Set up the most important test string: */
comment|/* Can't have a real ASCII zero in the string, because we want to        use printf, so we substitute the character zero. */
name|biggie
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
comment|/* The rest of the string gets straight ascending ASCII. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|biggie
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Test all the strings. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"clear%d: %s\n"
argument_list|,
name|i
argument_list|,
name|cleartexts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|e
operator|=
name|scramble
argument_list|(
name|cleartexts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scram%d: %s\n"
argument_list|,
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|m
operator|=
name|descramble
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clear%d: %s\n\n"
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DIAGNOSTIC */
end_comment

begin_comment
comment|/*  * ;;; The Emacs Lisp that did the dirty work ;;;  * (progn  *   *   ;; Helper func.  *   (defun random-elt (lst)  *     (let* ((len (length lst))  *            (rnd (random len)))  *       (nth rnd lst)))  *   *   ;; A list of all characters under 127, each appearing once.  *   (setq non-meta-chars  *         (let ((i 0)  *               (l nil))  *           (while (< i 127)  *             (setq l (cons i l)   *                   i (1+ i)))  *           l))  *   *   ;; A list of all characters 127 and above, each appearing once.  *   (setq meta-chars  *         (let ((i 127)  *               (l nil))  *           (while (< i 256)  *             (setq l (cons i l)   *                   i (1+ i)))  *           l))  *   *   ;; A vector that will hold the chars in a random order.  *   (setq scrambled-chars (make-vector 256 0))  *   *   ;; These characters should map to themselves.  *   (let ((i 0))  *     (while (< i 32)  *       (aset scrambled-chars i i)  *       (setq non-meta-chars (delete i non-meta-chars)   *             i (1+ i))))  *     *   ;; Assign random (but unique) values, within the non-meta chars.   *   (let ((i 32))  *     (while (< i 127)  *       (let ((ch (random-elt non-meta-chars)))  *         (if (= 0 (aref scrambled-chars i))  *             (progn  *               (aset scrambled-chars i ch)  *               (aset scrambled-chars ch i)  *               (setq non-meta-chars (delete ch non-meta-chars)  *                     non-meta-chars (delete i non-meta-chars))))  *         (setq i (1+ i)))))  *   *   ;; Assign random (but unique) values, within the non-meta chars.   *   (let ((i 127))  *     (while (< i 256)  *       (let ((ch (random-elt meta-chars)))  *         (if (= 0 (aref scrambled-chars i))  *             (progn  *               (aset scrambled-chars i ch)  *               (aset scrambled-chars ch i)  *               (setq meta-chars (delete ch meta-chars)  *                     meta-chars (delete i meta-chars))))  *         (setq i (1+ i)))))  *   *   ;; Now use the `scrambled-chars' vector to get your C array.  *   )  */
end_comment

end_unit

