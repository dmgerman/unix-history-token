begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *    Copyright (c) 1992, Brian Berliner and Jeff Polk  *    Copyright (c) 1989-1992, Brian Berliner  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS source distribution.  *  * Modules  *  *	Functions for accessing the modules file.  *  *	The modules file supports basically three formats of lines:  *		key [options] directory files... [ -x directory [files] ] ...  *		key [options] directory [ -x directory [files] ] ...  *		key -a aliases...  *  *	The -a option allows an aliasing step in the parsing of the modules  *	file.  The "aliases" listed on a line following the -a are  *	processed one-by-one, as if they were specified as arguments on the  *	command line.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Defines related to the syntax of the modules file.  */
end_comment

begin_comment
comment|/* Options in modules file.  Note that it is OK to use GNU getopt features;    we already are arranging to make sure we are using the getopt distributed    with CVS.  */
end_comment

begin_define
define|#
directive|define
name|CVSMODULE_OPTS
value|"+ad:i:lo:e:s:t:u:"
end_define

begin_comment
comment|/* Special delimiter.  */
end_comment

begin_define
define|#
directive|define
name|CVSMODULE_SPEC
value|'&'
end_define

begin_escape
end_escape

begin_struct
struct|struct
name|sortrec
block|{
comment|/* Name of the module, malloc'd.  */
name|char
modifier|*
name|modname
decl_stmt|;
comment|/* If Status variable is set, this is either def_status or the malloc'd        name of the status.  If Status is not set, the field is left        uninitialized.  */
name|char
modifier|*
name|status
decl_stmt|;
comment|/* Pointer to a malloc'd array which contains (1) the raw contents        of the options and arguments, excluding comments, (2) a '\0',        and (3) the storage for the "comment" field.  */
name|char
modifier|*
name|rest
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|sort_order
name|PROTO
argument_list|(
operator|(
specifier|const
name|PTR
name|l
operator|,
specifier|const
name|PTR
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_d
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|k
operator|,
name|int
name|ks
operator|,
name|char
operator|*
name|d
operator|,
name|int
name|ds
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open the modules file, and die if the CVSROOT environment variable  * was not set.  If the modules file does not exist, that's fine, and  * a warning message is displayed and a NULL is returned.  */
end_comment

begin_function
name|DBM
modifier|*
name|open_module
parameter_list|()
block|{
name|char
modifier|*
name|mfile
decl_stmt|;
name|DBM
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|current_parsed_root
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"must set the CVSROOT environment variable"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"or specify the '-d' global option"
argument_list|)
expr_stmt|;
block|}
name|mfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_MODULES
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mfile
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_MODULES
argument_list|)
expr_stmt|;
name|retval
operator|=
name|dbm_open
argument_list|(
name|mfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mfile
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Close the modules file, if the open succeeded, that is  */
end_comment

begin_function
name|void
name|close_module
parameter_list|(
name|db
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
block|{
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the recursive function that processes a module name.  * It calls back the passed routine for each directory of a module  * It runs the post checkout or post tag proc from the modules file  */
end_comment

begin_function
name|int
name|do_module
parameter_list|(
name|db
parameter_list|,
name|mname
parameter_list|,
name|m_type
parameter_list|,
name|msg
parameter_list|,
name|callback_proc
parameter_list|,
name|where
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|run_module_prog
parameter_list|,
name|build_dirs
parameter_list|,
name|extra_arg
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
name|enum
name|mtype
name|m_type
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|CALLBACKPROC
name|callback_proc
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|int
name|run_module_prog
decl_stmt|;
name|int
name|build_dirs
decl_stmt|;
name|char
modifier|*
name|extra_arg
decl_stmt|;
block|{
name|char
modifier|*
name|checkin_prog
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|checkout_prog
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|export_prog
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tag_prog
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|update_prog
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|int
name|cwd_saved
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|modargc
decl_stmt|;
name|int
name|xmodargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|modargv
decl_stmt|;
name|char
modifier|*
modifier|*
name|xmodargv
init|=
name|NULL
decl_stmt|;
comment|/* Found entry from modules file, including options and such.  */
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mwhere
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|spec_opt
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|xvalue
init|=
name|NULL
decl_stmt|;
name|int
name|alias
init|=
literal|0
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|val
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nonalias_opt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|int
name|restore_server_dir
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|server_dir_to_restore
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* We use cvs_outerr, rather than fprintf to stderr, because 	   this may be called by server code with error_use_protocol 	   set.  */
name|buf
operator|=
name|xmalloc
argument_list|(
literal|100
operator|+
name|strlen
argument_list|(
name|mname
argument_list|)
operator|+
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
operator|(
name|where
condition|?
name|strlen
argument_list|(
name|where
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|extra_arg
condition|?
name|strlen
argument_list|(
name|extra_arg
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s-> do_module (%s, %s, %s, %s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|mname
argument_list|,
name|msg
argument_list|,
name|where
condition|?
name|where
else|:
literal|""
argument_list|,
name|extra_arg
condition|?
name|extra_arg
else|:
literal|""
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if this is a directory to ignore, add it to that list */
if|if
condition|(
name|mname
index|[
literal|0
index|]
operator|==
literal|'!'
operator|&&
name|mname
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ign_dir_add
argument_list|(
name|mname
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
comment|/* strip extra stuff from the module name */
name|strip_trailing_slashes
argument_list|(
name|mname
argument_list|)
expr_stmt|;
comment|/*      * Look up the module using the following scheme:      *	1) look for mname as a module name      *	2) look for mname as a directory      *	3) look for mname as a file      *  4) take mname up to the first slash and look it up as a module name      *	   (this is for checking out only part of a module)      */
comment|/* look it up as a module name */
name|key
operator|.
name|dptr
operator|=
name|mname
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|key
operator|.
name|dptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|val
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|val
operator|.
name|dptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|!=
name|NULL
condition|)
block|{
comment|/* copy and null terminate the value */
name|value
operator|=
name|xmalloc
argument_list|(
name|val
operator|.
name|dsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|value
argument_list|,
name|val
operator|.
name|dptr
argument_list|,
name|val
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|value
index|[
name|val
operator|.
name|dsize
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the line ends in a comment, strip it off */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|cp
operator|=
name|value
operator|+
name|val
operator|.
name|dsize
expr_stmt|;
comment|/* Always strip trailing spaces */
while|while
condition|(
name|cp
operator|>
name|value
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|mwhere
operator|=
name|xstrdup
argument_list|(
name|mname
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|attic_file
decl_stmt|;
name|char
modifier|*
name|acp
decl_stmt|;
name|int
name|is_found
init|=
literal|0
decl_stmt|;
comment|/* check to see if mname is a directory or file */
name|file
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|mname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|attic_file
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|mname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acp
operator|=
name|strrchr
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|acp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|attic_file
argument_list|,
literal|"%s/%s/%s/%s%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|mname
argument_list|,
name|CVSATTIC
argument_list|,
name|acp
operator|+
literal|1
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
operator|*
name|acp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|attic_file
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSATTIC
argument_list|,
name|mname
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|modargv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|modargv
argument_list|)
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
name|mname
argument_list|)
expr_stmt|;
name|modargc
operator|=
literal|1
expr_stmt|;
name|is_found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
operator|||
name|isfile
argument_list|(
name|attic_file
argument_list|)
condition|)
block|{
comment|/* if mname was a file, we have to split it into "dir file" */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|cp
operator|!=
name|mname
condition|)
block|{
name|modargv
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|modargv
argument_list|)
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|mname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|modargv
index|[
literal|0
index|]
argument_list|,
name|mname
argument_list|,
name|cp
operator|-
name|mname
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|0
index|]
index|[
name|cp
operator|-
name|mname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|modargv
index|[
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|modargc
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * the only '/' at the beginning or no '/' at all 		     * means the file we are interested in is in CVSROOT 		     * itself so the directory should be '.' 		     */
if|if
condition|(
name|cp
operator|==
name|mname
condition|)
block|{
comment|/* drop the leading / if specified */
name|modargv
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|modargv
argument_list|)
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|mname
operator|+
literal|1
argument_list|)
expr_stmt|;
name|modargc
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise just copy it */
name|modargv
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|modargv
argument_list|)
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|modargv
index|[
literal|1
index|]
operator|=
name|xstrdup
argument_list|(
name|mname
argument_list|)
expr_stmt|;
name|modargc
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|is_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|attic_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_found
condition|)
block|{
name|assert
argument_list|(
name|value
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* OK, we have now set up modargv with the actual 	       file/directory we want to work on.  We duplicate a 	       small amount of code here because the vast majority of 	       the code after the "found" label does not pertain to 	       the case where we found a file/directory rather than 	       finding an entry in the modules file.  */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|cwd_saved
operator|=
literal|1
expr_stmt|;
name|err
operator|+=
name|callback_proc
argument_list|(
name|modargc
argument_list|,
name|modargv
argument_list|,
name|where
argument_list|,
name|mwhere
argument_list|,
name|mfile
argument_list|,
name|shorten
argument_list|,
name|local_specified
argument_list|,
name|mname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|free_names
argument_list|(
operator|&
name|modargc
argument_list|,
name|modargv
argument_list|)
expr_stmt|;
comment|/* cd back to where we started.  */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|cwd_saved
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
block|}
comment|/* look up everything to the first / as a module */
if|if
condition|(
name|mname
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|mname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Make the slash the new end of the string temporarily */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|key
operator|.
name|dptr
operator|=
name|mname
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|key
operator|.
name|dptr
argument_list|)
expr_stmt|;
comment|/* do the lookup */
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|val
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|val
operator|.
name|dptr
operator|=
name|NULL
expr_stmt|;
comment|/* if we found it, clean up the value and life is good */
if|if
condition|(
name|val
operator|.
name|dptr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* copy and null terminate the value */
name|value
operator|=
name|xmalloc
argument_list|(
name|val
operator|.
name|dsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|value
argument_list|,
name|val
operator|.
name|dptr
argument_list|,
name|val
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|value
index|[
name|val
operator|.
name|dsize
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If the line ends in a comment, strip it off */
if|if
condition|(
operator|(
name|cp2
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
else|else
name|cp2
operator|=
name|value
operator|+
name|val
operator|.
name|dsize
expr_stmt|;
comment|/* Always strip trailing spaces */
while|while
condition|(
name|cp2
operator|>
name|value
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|cp2
argument_list|)
condition|)
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
comment|/* mwhere gets just the module name */
name|mwhere
operator|=
name|xstrdup
argument_list|(
name|mname
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* put the / back in mname */
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* put the / back in mname */
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* if we got here, we couldn't find it using our search, so give up */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find module `%s' - ignored"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
goto|goto
name|do_module_return
goto|;
comment|/*      * At this point, we found what we were looking for in one      * of the many different forms.      */
name|found
label|:
comment|/* remember where we start */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|cwd_saved
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|value
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* search the value for the special delimiter and save for later */
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
name|CVSMODULE_SPEC
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* null out the special char */
name|spec_opt
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* save the options for later */
comment|/* strip whitespace if necessary */
while|while
condition|(
name|cp
operator|>
name|value
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* don't do special options only part of a module was specified */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
name|spec_opt
operator|=
name|NULL
expr_stmt|;
comment|/*      * value now contains one of the following:      *    1) dir      *	  2) dir file      *    3) the value from modules without any special args      *		    [ args ] dir [file] [file] ...      *	     or     -a module [ module ] ...      */
comment|/* Put the value on a line with XXX prepended for getopt to eat */
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"XXX "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|line
operator|+
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* turn the line into an argv[] array */
name|line2argv
argument_list|(
operator|&
name|xmodargc
argument_list|,
operator|&
name|xmodargv
argument_list|,
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|modargc
operator|=
name|xmodargc
expr_stmt|;
name|modargv
operator|=
name|xmodargv
expr_stmt|;
comment|/* parse the args */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|modargc
argument_list|,
name|modargv
argument_list|,
name|CVSMODULE_OPTS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|alias
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|mwhere
condition|)
name|free
argument_list|(
name|mwhere
argument_list|)
expr_stmt|;
name|mwhere
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|checkin_prog
condition|)
name|free
argument_list|(
name|checkin_prog
argument_list|)
expr_stmt|;
name|checkin_prog
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local_specified
operator|=
literal|1
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|checkout_prog
condition|)
name|free
argument_list|(
name|checkout_prog
argument_list|)
expr_stmt|;
name|checkout_prog
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|export_prog
condition|)
name|free
argument_list|(
name|export_prog
argument_list|)
expr_stmt|;
name|export_prog
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|tag_prog
condition|)
name|free
argument_list|(
name|tag_prog
argument_list|)
expr_stmt|;
name|tag_prog
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|update_prog
condition|)
name|free
argument_list|(
name|update_prog
argument_list|)
expr_stmt|;
name|update_prog
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|nonalias_opt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"modules file has invalid option for key %s value %s"
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
block|}
name|modargc
operator|-=
name|optind
expr_stmt|;
name|modargv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|modargc
operator|==
literal|0
operator|&&
name|spec_opt
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"modules file missing directory for module %s"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
if|if
condition|(
name|alias
operator|&&
name|nonalias_opt
condition|)
block|{
comment|/* The documentation has never said it is legal to specify 	   -a along with another option.  And I believe that in the past 	   CVS has ignored the options other than -a, more or less, in this 	   situation.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ -a cannot be specified in the modules file along with other options"
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
comment|/* if this was an alias, call ourselves recursively for each module */
if|if
condition|(
name|alias
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|mname
argument_list|,
name|modargv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"module `%s' in modules file contains infinite loop"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
else|else
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|modargv
index|[
name|i
index|]
argument_list|,
name|m_type
argument_list|,
name|msg
argument_list|,
name|callback_proc
argument_list|,
name|where
argument_list|,
name|shorten
argument_list|,
name|local_specified
argument_list|,
name|run_module_prog
argument_list|,
name|build_dirs
argument_list|,
name|extra_arg
argument_list|)
expr_stmt|;
block|}
goto|goto
name|do_module_return
goto|;
block|}
if|if
condition|(
name|mfile
operator|!=
name|NULL
operator|&&
name|modargc
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ module `%s' is a request for a file in a module which is not a directory"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
goto|goto
name|do_module_return
goto|;
block|}
comment|/* otherwise, process this module */
if|if
condition|(
name|modargc
operator|>
literal|0
condition|)
block|{
name|err
operator|+=
name|callback_proc
argument_list|(
name|modargc
argument_list|,
name|modargv
argument_list|,
name|where
argument_list|,
name|mwhere
argument_list|,
name|mfile
argument_list|,
name|shorten
argument_list|,
name|local_specified
argument_list|,
name|mname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * we had nothing but special options, so we must 	 * make the appropriate directory and cd to it 	 */
name|char
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|build_dirs
condition|)
goto|goto
name|do_special
goto|;
name|dir
operator|=
name|where
condition|?
name|where
else|:
operator|(
name|mwhere
condition|?
name|mwhere
else|:
name|mname
operator|)
expr_stmt|;
comment|/* XXX - think about making null repositories at each dir here 		 instead of just at the bottom */
name|make_directories
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|spec_opt
operator|=
name|NULL
expr_stmt|;
name|err
operator|++
expr_stmt|;
goto|goto
name|do_special
goto|;
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
name|char
modifier|*
name|nullrepos
decl_stmt|;
name|nullrepos
operator|=
name|emptydir_name
argument_list|()
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|dir
argument_list|,
name|nullrepos
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_entstat
argument_list|(
name|dir
argument_list|,
name|nullrepos
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|nullrepos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if there were special include args, process them now */
name|do_special
label|:
name|free_names
argument_list|(
operator|&
name|xmodargc
argument_list|,
name|xmodargv
argument_list|)
expr_stmt|;
name|xmodargv
operator|=
name|NULL
expr_stmt|;
comment|/* blow off special options if -l was specified */
if|if
condition|(
name|local_specified
condition|)
name|spec_opt
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* We want to check out into the directory named by the module.        So we set a global variable which tells the server to glom that        directory name onto the front.  A cleaner approach would be some        way of passing it down to the recursive call, through the        callback_proc, to start_recursion, and then into the update_dir in        the struct file_info.  That way the "Updating foo" message could        print the actual directory we are checking out into.         For local CVS, this is handled by the chdir call above        (directly or via the callback_proc).  */
if|if
condition|(
name|server_active
operator|&&
name|spec_opt
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|change_to
decl_stmt|;
name|change_to
operator|=
name|where
condition|?
name|where
else|:
operator|(
name|mwhere
condition|?
name|mwhere
else|:
name|mname
operator|)
expr_stmt|;
name|server_dir_to_restore
operator|=
name|server_dir
expr_stmt|;
name|restore_server_dir
operator|=
literal|1
expr_stmt|;
name|server_dir
operator|=
name|xmalloc
argument_list|(
operator|(
name|server_dir_to_restore
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|server_dir_to_restore
argument_list|)
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|change_to
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|server_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|server_dir_to_restore
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|server_dir
argument_list|,
name|server_dir_to_restore
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|server_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|server_dir
argument_list|,
name|change_to
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|spec_opt
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|next_opt
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|spec_opt
argument_list|,
name|CVSMODULE_SPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* save the beginning of the next arg */
name|next_opt
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* strip whitespace off the end */
do|do
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
do|while
condition|(
name|cp
operator|>
name|spec_opt
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|cp
argument_list|)
condition|)
do|;
block|}
else|else
name|next_opt
operator|=
name|NULL
expr_stmt|;
comment|/* strip whitespace from front */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|spec_opt
argument_list|)
condition|)
name|spec_opt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|spec_opt
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Mal-formed %c option for module %s - ignored"
argument_list|,
name|CVSMODULE_SPEC
argument_list|,
name|mname
argument_list|)
expr_stmt|;
else|else
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|spec_opt
argument_list|,
name|m_type
argument_list|,
name|msg
argument_list|,
name|callback_proc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|local_specified
argument_list|,
name|run_module_prog
argument_list|,
name|build_dirs
argument_list|,
name|extra_arg
argument_list|)
expr_stmt|;
name|spec_opt
operator|=
name|next_opt
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|restore_server_dir
condition|)
block|{
name|free
argument_list|(
name|server_dir
argument_list|)
expr_stmt|;
name|server_dir
operator|=
name|server_dir_to_restore
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* write out the checkin/update prog files if necessary */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|noexec
operator|&&
name|m_type
operator|==
name|CHECKOUT
operator|&&
name|server_expanding
condition|)
block|{
if|if
condition|(
name|checkin_prog
operator|!=
name|NULL
condition|)
name|server_prog
argument_list|(
name|where
condition|?
name|where
else|:
name|mname
argument_list|,
name|checkin_prog
argument_list|,
name|PROG_CHECKIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prog
operator|!=
name|NULL
condition|)
name|server_prog
argument_list|(
name|where
condition|?
name|where
else|:
name|mname
argument_list|,
name|update_prog
argument_list|,
name|PROG_UPDATE
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|noexec
operator|&&
name|m_type
operator|==
name|CHECKOUT
operator|&&
name|run_module_prog
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|checkin_prog
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|checkin_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_prog
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|update_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cd back to where we started */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|cwd_saved
operator|=
literal|0
expr_stmt|;
comment|/* run checkout or tag prog if appropriate */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|run_module_prog
condition|)
block|{
if|if
condition|(
operator|(
name|m_type
operator|==
name|TAG
operator|&&
name|tag_prog
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|m_type
operator|==
name|CHECKOUT
operator|&&
name|checkout_prog
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|m_type
operator|==
name|EXPORT
operator|&&
name|export_prog
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 	     * If a relative pathname is specified as the checkout, tag 	     * or export proc, try to tack on the current "where" value. 	     * if we can't find a matching program, just punt and use 	     * whatever is specified in the modules file. 	     */
name|char
modifier|*
name|real_prog
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|prog
init|=
operator|(
name|m_type
operator|==
name|TAG
condition|?
name|tag_prog
else|:
operator|(
name|m_type
operator|==
name|CHECKOUT
condition|?
name|checkout_prog
else|:
name|export_prog
operator|)
operator|)
decl_stmt|;
name|char
modifier|*
name|real_where
init|=
operator|(
name|where
operator|!=
name|NULL
condition|?
name|where
else|:
name|mwhere
operator|)
decl_stmt|;
name|char
modifier|*
name|expanded_path
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|prog
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|prog
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|real_prog
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|real_where
argument_list|)
operator|+
name|strlen
argument_list|(
name|prog
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|real_prog
argument_list|,
literal|"%s/%s"
argument_list|,
name|real_where
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|real_prog
argument_list|)
condition|)
name|prog
operator|=
name|real_prog
expr_stmt|;
block|}
comment|/* XXX can we determine the line number for this entry??? */
name|expanded_path
operator|=
name|expand_path
argument_list|(
name|prog
argument_list|,
literal|"modules"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_path
operator|!=
name|NULL
condition|)
block|{
name|run_setup
argument_list|(
name|expanded_path
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|real_where
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_arg
condition|)
name|run_arg
argument_list|(
name|extra_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Executing '"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_flushout
argument_list|()
expr_stmt|;
block|}
name|err
operator|+=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|real_prog
argument_list|)
expr_stmt|;
block|}
block|}
name|do_module_return
label|:
comment|/* clean up */
if|if
condition|(
name|xmodargv
operator|!=
name|NULL
condition|)
name|free_names
argument_list|(
operator|&
name|xmodargc
argument_list|,
name|xmodargv
argument_list|)
expr_stmt|;
if|if
condition|(
name|mwhere
condition|)
name|free
argument_list|(
name|mwhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkin_prog
condition|)
name|free
argument_list|(
name|checkin_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkout_prog
condition|)
name|free
argument_list|(
name|checkout_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|export_prog
condition|)
name|free
argument_list|(
name|export_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_prog
condition|)
name|free
argument_list|(
name|tag_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prog
condition|)
name|free
argument_list|(
name|update_prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd_saved
condition|)
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|xvalue
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xvalue
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* - Read all the records from the modules database into an array.    - Sort the array depending on what format is desired.    - Print the array in the format desired.     Currently, there are only two "desires":     1. Sort by module name and format the whole entry including switches,       files and the comment field: (Including aliases)        modulename	-s switches, one per line, even if 			-i it has many switches. 			Directories and files involved, formatted 			to cover multiple lines if necessary. 			# Comment, also formatted to cover multiple 			# lines if necessary.     2. Sort by status field string and print:  (*not* including aliases)        modulename    STATUS	Directories and files involved, formatted 				to cover multiple lines if necessary. 				# Comment, also formatted to cover multiple 				# lines if necessary. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sortrec
modifier|*
name|s_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements used */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the user is 					   interested in status 					   information as well as 					   module name */
end_comment

begin_decl_stmt
specifier|static
name|char
name|def_status
index|[]
init|=
literal|"NONE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sort routine for qsort:    - If we want the "Status" field to be sorted, check it first.    - Then compare the "module name" fields.  Since they are unique, we don't      have to look further. */
end_comment

begin_function
specifier|static
name|int
name|sort_order
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
specifier|const
name|PTR
name|l
decl_stmt|;
specifier|const
name|PTR
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|sortrec
modifier|*
name|left
init|=
operator|(
specifier|const
expr|struct
name|sortrec
operator|*
operator|)
name|l
decl_stmt|;
specifier|const
name|struct
name|sortrec
modifier|*
name|right
init|=
operator|(
specifier|const
expr|struct
name|sortrec
operator|*
operator|)
name|r
decl_stmt|;
if|if
condition|(
name|Status
condition|)
block|{
comment|/* If Sort by status field, compare them. */
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|status
argument_list|,
name|right
operator|->
name|status
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
name|strcmp
argument_list|(
name|left
operator|->
name|modname
argument_list|,
name|right
operator|->
name|modname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_d
parameter_list|(
name|k
parameter_list|,
name|ks
parameter_list|,
name|d
parameter_list|,
name|ds
parameter_list|)
name|char
modifier|*
name|k
decl_stmt|;
name|int
name|ks
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|ds
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|struct
name|sortrec
modifier|*
name|s_rec
decl_stmt|;
if|if
condition|(
name|Status
operator|&&
operator|*
name|d
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|d
operator|+
literal|1
operator|)
operator|==
literal|'a'
condition|)
return|return;
comment|/* We want "cvs co -s" and it is an alias! */
if|if
condition|(
name|s_count
operator|==
name|s_max
condition|)
block|{
name|s_max
operator|+=
literal|64
expr_stmt|;
name|s_head
operator|=
operator|(
expr|struct
name|sortrec
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s_head
argument_list|,
name|s_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|s_head
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s_rec
operator|=
operator|&
name|s_head
index|[
name|s_count
index|]
expr_stmt|;
name|s_rec
operator|->
name|modname
operator|=
name|cp
operator|=
name|xmalloc
argument_list|(
name|ks
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|cp
argument_list|,
name|k
argument_list|,
name|ks
argument_list|)
expr_stmt|;
operator|*
operator|(
name|cp
operator|+
name|ks
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|s_rec
operator|->
name|rest
operator|=
name|cp2
operator|=
name|xmalloc
argument_list|(
name|ds
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|d
expr_stmt|;
operator|*
operator|(
name|cp
operator|+
name|ds
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assumes an extra byte at end of static dbm buffer */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Turn<spaces> into one ' ' -- makes the rest of this routine simpler */
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp2
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for the "-s statusvalue" text */
if|if
condition|(
name|Status
condition|)
block|{
name|s_rec
operator|->
name|status
operator|=
name|def_status
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s_rec
operator|->
name|rest
init|;
operator|(
name|cp2
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|cp
operator|=
operator|++
name|cp2
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp2
operator|+
literal|1
operator|)
operator|==
literal|'s'
operator|&&
operator|*
operator|(
name|cp2
operator|+
literal|2
operator|)
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|status_start
decl_stmt|;
name|cp2
operator|+=
literal|3
expr_stmt|;
name|status_start
operator|=
name|cp2
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|!=
literal|' '
operator|&&
operator|*
name|cp2
operator|!=
literal|'\0'
condition|)
name|cp2
operator|++
expr_stmt|;
name|s_rec
operator|->
name|status
operator|=
name|xmalloc
argument_list|(
name|cp2
operator|-
name|status_start
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|s_rec
operator|->
name|status
argument_list|,
name|status_start
argument_list|,
name|cp2
operator|-
name|status_start
argument_list|)
expr_stmt|;
name|s_rec
operator|->
name|status
index|[
name|cp2
operator|-
name|status_start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|cp2
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|cp
operator|=
name|s_rec
operator|->
name|rest
expr_stmt|;
comment|/* Find comment field, clean up on all three sides& compress blanks */
if|if
condition|(
operator|(
name|cp2
operator|=
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|cp2
operator|==
literal|' '
condition|)
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
name|s_rec
operator|->
name|comment
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|s_rec
operator|->
name|comment
operator|=
literal|""
expr_stmt|;
name|s_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the module database as we know it.  If STATUS is    non-zero, print out status information for each module. */
end_comment

begin_function
name|void
name|cat_module
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|wid
decl_stmt|,
name|argc
decl_stmt|,
name|cols
init|=
literal|80
decl_stmt|,
name|indent
decl_stmt|,
name|fill
decl_stmt|;
name|int
name|moduleargc
decl_stmt|;
name|struct
name|sortrec
modifier|*
name|s_h
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|moduleargv
decl_stmt|;
name|Status
operator|=
name|status
expr_stmt|;
comment|/* Read the whole modules file into allocated records */
if|if
condition|(
operator|!
operator|(
name|db
operator|=
name|open_module
argument_list|()
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"failed to open the modules file"
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|db
argument_list|)
init|;
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|;
name|key
operator|=
name|dbm_nextkey
argument_list|(
name|db
argument_list|)
control|)
block|{
name|val
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|!=
name|NULL
condition|)
name|save_d
argument_list|(
name|key
operator|.
name|dptr
argument_list|,
name|key
operator|.
name|dsize
argument_list|,
name|val
operator|.
name|dptr
argument_list|,
name|val
operator|.
name|dsize
argument_list|)
expr_stmt|;
block|}
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Sort the list as requested */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|s_head
argument_list|,
name|s_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sortrec
argument_list|)
argument_list|,
name|sort_order
argument_list|)
expr_stmt|;
comment|/*      * Run through the sorted array and format the entries      * indent = space for modulename + space for status field      */
name|indent
operator|=
literal|12
operator|+
operator|(
name|status
operator|*
literal|12
operator|)
expr_stmt|;
name|fill
operator|=
name|cols
operator|-
operator|(
name|indent
operator|+
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|s_h
operator|=
name|s_head
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s_count
condition|;
name|i
operator|++
operator|,
name|s_h
operator|++
control|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Print module name (and status, if wanted) */
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s_h
operator|->
name|modname
argument_list|)
operator|+
literal|15
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%-12s"
argument_list|,
name|s_h
operator|->
name|modname
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s_h
operator|->
name|status
argument_list|)
operator|+
literal|15
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" %-11s"
argument_list|,
name|s_h
operator|->
name|status
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s_h
operator|->
name|modname
argument_list|)
operator|+
name|strlen
argument_list|(
name|s_h
operator|->
name|rest
argument_list|)
operator|+
literal|15
argument_list|)
expr_stmt|;
comment|/* Parse module file entry as command line and print options */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s %s"
argument_list|,
name|s_h
operator|->
name|modname
argument_list|,
name|s_h
operator|->
name|rest
argument_list|)
expr_stmt|;
name|line2argv
argument_list|(
operator|&
name|moduleargc
argument_list|,
operator|&
name|moduleargv
argument_list|,
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|argc
operator|=
name|moduleargc
expr_stmt|;
name|argv
operator|=
name|moduleargv
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
name|wid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|CVSMODULE_OPTS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|status
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'a'
operator|||
name|c
operator|==
literal|'l'
condition|)
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" -%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wid
operator|+=
literal|3
expr_stmt|;
comment|/* Could just set it to 3 */
block|}
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|4
operator|+
name|wid
operator|>
operator|(
name|unsigned
operator|)
name|fill
condition|)
block|{
name|int
name|j
decl_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
operator|++
name|j
control|)
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wid
operator|=
literal|0
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" -%c "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wid
operator|+=
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* Format and Print all the files and directories */
for|for
control|(
init|;
name|argc
operator|--
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
name|wid
operator|>
operator|(
name|unsigned
operator|)
name|fill
condition|)
block|{
name|int
name|j
decl_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
operator|++
name|j
control|)
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wid
operator|=
literal|0
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wid
operator|+=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Format the comment field -- save_d (), compressed spaces */
for|for
control|(
name|cp2
operator|=
name|cp
operator|=
name|s_h
operator|->
name|comment
init|;
operator|*
name|cp
condition|;
name|cp2
operator|=
name|cp
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|indent
condition|;
operator|++
name|j
control|)
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" # "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp2
argument_list|)
operator|<
call|(
name|unsigned
call|)
argument_list|(
name|fill
operator|-
literal|2
argument_list|)
condition|)
block|{
name|cvs_output
argument_list|(
name|cp2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|fill
operator|-
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
name|cp
operator|>
name|cp2
condition|)
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|cp2
condition|)
block|{
name|cvs_output
argument_list|(
name|cp2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cvs_output
argument_list|(
name|cp2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free_names
argument_list|(
operator|&
name|moduleargc
argument_list|,
name|moduleargv
argument_list|)
expr_stmt|;
comment|/* FIXME-leak: here is where we would free s_h->modname, s_h->rest, 	   and if applicable, s_h->status.  Not exactly a memory leak, 	   in the sense that we are about to exit(), but may be worth 	   noting if we ever do a multithreaded server or something of 	   the sort.  */
block|}
comment|/* FIXME-leak: as above, here is where we would free s_head.  */
block|}
end_function

end_unit

