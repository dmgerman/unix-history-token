begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CVS client-related stuff.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
operator|||
name|HAVE_KERBEROS
operator|||
name|defined
argument_list|(
name|SOCK_ERRNO
argument_list|)
operator|||
name|defined
argument_list|(
name|SOCK_STRERROR
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No winsock.h */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No winsock.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If SOCK_ERRNO is defined, then send()/recv() and other socket calls    do not set errno, but that this macro should be used to obtain an    error code.  This probably doesn't make sense unless    NO_SOCKET_TO_FD is also defined. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOCK_ERRNO
end_ifndef

begin_define
define|#
directive|define
name|SOCK_ERRNO
value|errno
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If SOCK_STRERROR is defined, then the error codes returned by    socket operations are not known to strerror, and this macro must be    used instead to convert those error codes to strings. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOCK_STRERROR
end_ifndef

begin_define
define|#
directive|define
name|SOCK_STRERROR
value|strerror
end_define

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strerror
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! SOCK_STRERROR */
end_comment

begin_if
if|#
directive|if
name|HAVE_KERBEROS
end_if

begin_define
define|#
directive|define
name|CVS_PORT
value|1999
end_define

begin_if
if|#
directive|if
name|HAVE_KERBEROS
end_if

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|krb_realmofhost
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KRB_GET_ERR_TEXT
end_ifndef

begin_define
define|#
directive|define
name|krb_get_err_text
parameter_list|(
name|status
parameter_list|)
value|krb_err_txt[status]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KRB_GET_ERR_TEXT */
end_comment

begin_comment
comment|/* Information we need if we are going to use Kerberos encryption.  */
end_comment

begin_decl_stmt
specifier|static
name|C_Block
name|kblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Key_schedule
name|sched
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_include
include|#
directive|include
file|<gssapi/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<gssapi/gssapi_generic.h>
end_include

begin_comment
comment|/* This is needed for GSSAPI encryption.  */
end_comment

begin_decl_stmt
specifier|static
name|gss_ctx_id_t
name|gcontext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|connect_to_gserver
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|hostent
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|add_prune_candidate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the commands.  */
end_comment

begin_decl_stmt
name|int
name|add
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|admin
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkout
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|commit
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|diff
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|import
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvslog
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patch
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|release
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvsremove
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|update
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the response handling functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|handle_ok
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_error
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_valid_requests
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_checked_in
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_new_entry
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_checksum
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_copy_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_updated
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_merged
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_patched
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_rcs_diff
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_removed
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_remove_entry
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_static_directory
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_clear_static_directory
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_sticky
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_clear_sticky
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_checkin_prog
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_update_prog
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_module_expansion
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_wrapper_rcs_option
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_m
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_e
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_f
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_notified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|try_read_from_server
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* Shared with server.  */
end_comment

begin_comment
comment|/*  * Return a malloc'd, '\0'-terminated string  * corresponding to the mode in SB.  */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|mode_to_string
parameter_list|(
name|mode_t
name|mode
parameter_list|)
else|#
directive|else
comment|/* ! __STDC__ */
function|mode_to_string
parameter_list|(
name|mode
parameter_list|)
name|mode_t
name|mode
decl_stmt|;
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|char
name|buf
index|[
literal|18
index|]
decl_stmt|,
name|u
index|[
literal|4
index|]
decl_stmt|,
name|g
index|[
literal|4
index|]
decl_stmt|,
name|o
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|u
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|o
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"u=%s,g=%s,o=%s"
argument_list|,
name|u
argument_list|,
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change mode of FILENAME to MODE_STRING.  * Returns 0 for success or errno code.  * If RESPECT_UMASK is set, then honor the umask.  */
end_comment

begin_function
name|int
name|change_mode
parameter_list|(
name|filename
parameter_list|,
name|mode_string
parameter_list|,
name|respect_umask
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
name|int
name|respect_umask
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CHMOD_BROKEN
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|writeable
init|=
literal|0
decl_stmt|;
comment|/* We can only distinguish between          1) readable          2) writeable          3) Picasso's "Blue Period"        We handle the first two. */
name|p
operator|=
name|mode_string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'w'
condition|)
name|writeable
operator|=
literal|1
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
block|}
comment|/* Skip to the next field.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|++
name|p
expr_stmt|;
block|}
comment|/* xchmod honors the umask for us.  In the !respect_umask case, we        don't try to cope with it (probably to handle that well, the server        needs to deal with modes in data structures, rather than via the        modes in temporary files).  */
name|xchmod
argument_list|(
name|filename
argument_list|,
name|writeable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* ! CHMOD_BROKEN */
name|char
modifier|*
name|p
decl_stmt|;
name|mode_t
name|mode
init|=
literal|0
decl_stmt|;
name|mode_t
name|oumask
decl_stmt|;
name|p
operator|=
name|mode_string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|int
name|can_read
init|=
literal|0
decl_stmt|,
name|can_write
init|=
literal|0
decl_stmt|,
name|can_execute
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'r'
condition|)
name|can_read
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'w'
condition|)
name|can_write
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'x'
condition|)
name|can_execute
operator|=
literal|1
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
comment|/* Skip to the next field.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|respect_umask
condition|)
block|{
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
name|mode
operator|&=
operator|~
name|oumask
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* ! CHMOD_BROKEN */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_decl_stmt
name|int
name|client_prune_dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to write to the server.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|to_server
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stream underlying to_server, if we are using a stream.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|to_server_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer used to read from the server.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|from_server
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stream underlying from_server, if we are using a stream.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|from_server_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process ID of rsh subprocess.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rsh_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* We want to be able to log data sent between us and the server.  We    do it using log buffers.  Each log buffer has another buffer which    handles the actual I/O, and a file to log information to.     This structure is the closure field of a log buffer.  */
end_comment

begin_struct
struct|struct
name|log_buffer
block|{
comment|/* The underlying buffer.  */
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
comment|/* The file to log information to.  */
name|FILE
modifier|*
name|log
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|log_buffer_initialize
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_buffer_shutdown
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a log buffer.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|buffer
modifier|*
name|log_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|fp
parameter_list|,
name|input
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|input
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|log_buffer
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|n
operator|->
name|log
operator|=
name|fp
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|log_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|log_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|log_buffer_flush
argument_list|,
name|log_buffer_block
argument_list|,
name|log_buffer_shutdown
argument_list|,
name|memory
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The input function for a log buffer.  */
end_comment

begin_function
specifier|static
name|int
name|log_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|log_buffer
modifier|*
name|lb
init|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|n_to_write
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|buf
operator|->
name|input
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|lb
operator|->
name|buf
operator|->
name|input
call|)
argument_list|(
name|lb
operator|->
name|buf
operator|->
name|closure
argument_list|,
name|data
argument_list|,
name|need
argument_list|,
name|size
argument_list|,
name|got
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|*
name|got
operator|>
literal|0
condition|)
block|{
name|n_to_write
operator|=
operator|*
name|got
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|n_to_write
argument_list|,
name|lb
operator|->
name|log
argument_list|)
operator|!=
name|n_to_write
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"writing to log file"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The output function for a log buffer.  */
end_comment

begin_function
specifier|static
name|int
name|log_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|log_buffer
modifier|*
name|lb
init|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|status
decl_stmt|;
name|size_t
name|n_to_write
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|buf
operator|->
name|output
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|lb
operator|->
name|buf
operator|->
name|output
call|)
argument_list|(
name|lb
operator|->
name|buf
operator|->
name|closure
argument_list|,
name|data
argument_list|,
name|have
argument_list|,
name|wrote
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
if|if
condition|(
operator|*
name|wrote
operator|>
literal|0
condition|)
block|{
name|n_to_write
operator|=
operator|*
name|wrote
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|n_to_write
argument_list|,
name|lb
operator|->
name|log
argument_list|)
operator|!=
name|n_to_write
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"writing to log file"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The flush function for a log buffer.  */
end_comment

begin_function
specifier|static
name|int
name|log_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|log_buffer
modifier|*
name|lb
init|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|lb
operator|->
name|buf
operator|->
name|flush
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We don't really have to flush the log file here, but doing it        will let tail -f on the log file show what is sent to the        network as it is sent.  */
if|if
condition|(
name|fflush
argument_list|(
name|lb
operator|->
name|log
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"flushing log file"
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|lb
operator|->
name|buf
operator|->
name|flush
call|)
argument_list|(
name|lb
operator|->
name|buf
operator|->
name|closure
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The block function for a log buffer.  */
end_comment

begin_function
specifier|static
name|int
name|log_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|log_buffer
modifier|*
name|lb
init|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|set_block
argument_list|(
name|lb
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
name|set_nonblock
argument_list|(
name|lb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The shutdown function for a log buffer.  */
end_comment

begin_function
specifier|static
name|int
name|log_buffer_shutdown
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|log_buffer
modifier|*
name|lb
init|=
operator|(
expr|struct
name|log_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|buf_shutdown
argument_list|(
name|lb
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|lb
operator|->
name|log
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing log file"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
end_ifdef

begin_comment
comment|/* Under certain circumstances, we must communicate with the server    via a socket using send() and recv().  This is because under some    operating systems (OS/2 and Windows 95 come to mind), a socket    cannot be converted to a file descriptor -- it must be treated as a    socket and nothing else.        We may also need to deal with socket routine error codes differently    in these cases.  This is handled through the SOCK_ERRNO and    SOCK_STRERROR macros. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_socket_style
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|server_sock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These routines implement a buffer structure which uses send and    recv.  The buffer is always in blocking mode so we don't implement    the block routine.  */
end_comment

begin_comment
comment|/* Note that it is important that these routines always handle errors    internally and never return a positive errno code, since it would in    general be impossible for the caller to know in general whether any    error code came from a socket routine (to decide whether to use    SOCK_STRERROR or simply strerror to print an error message). */
end_comment

begin_comment
comment|/* We use an instance of this structure as the closure field.  */
end_comment

begin_struct
struct|struct
name|socket_buffer
block|{
comment|/* The socket number.  */
name|int
name|socket
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|socket_buffer_initialize
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|socket_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|socket_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|socket_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a buffer based on a socket.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|buffer
modifier|*
name|socket_buffer_initialize
parameter_list|(
name|socket
parameter_list|,
name|input
parameter_list|,
name|memory
parameter_list|)
name|int
name|socket
decl_stmt|;
name|int
name|input
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|socket_buffer
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|socket_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|socket
operator|=
name|socket
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|socket_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|socket_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|socket_buffer_flush
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|memory
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The buffer input function for a buffer built on a socket.  */
end_comment

begin_function
specifier|static
name|int
name|socket_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|socket_buffer
modifier|*
name|sb
init|=
operator|(
expr|struct
name|socket_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* I believe that the recv function gives us exactly the semantics        we want.  If there is a message, it returns immediately with        whatever it could get.  If there is no message, it waits until        one comes in.  In other words, it is not like read, which in        blocking mode normally waits until all the requested data is        available.  */
operator|*
name|got
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Note that for certain (broken?) networking stacks, like 	   VMS's UCX (not sure what version, problem reported with 	   recv() in 1997), and (according to windows-NT/config.h) 	   Windows NT 3.51, we must call recv or send with a 	   moderately sized buffer (say, less than 200K or something), 	   or else there may be network errors (somewhat hard to 	   produce, e.g. WAN not LAN or some such).  buf_read_data 	   makes sure that we only recv() BUFFER_DATA_SIZE bytes at 	   a time.  */
name|nbytes
operator|=
name|recv
argument_list|(
name|sb
operator|->
name|socket
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"reading from server: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* End of file (for example, the server has closed 	       the connection).  If we've already read something, we 	       just tell the caller about the data, not about the end of 	       file.  If we've read nothing, we return end of file.  */
if|if
condition|(
operator|*
name|got
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
name|need
operator|-=
name|nbytes
expr_stmt|;
name|size
operator|-=
name|nbytes
expr_stmt|;
name|data
operator|+=
name|nbytes
expr_stmt|;
operator|*
name|got
operator|+=
name|nbytes
expr_stmt|;
block|}
do|while
condition|(
name|need
operator|>
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer output function for a buffer built on a socket.  */
end_comment

begin_function
specifier|static
name|int
name|socket_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|socket_buffer
modifier|*
name|sb
init|=
operator|(
expr|struct
name|socket_buffer
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|wrote
operator|=
name|have
expr_stmt|;
comment|/* See comment in socket_buffer_input regarding buffer size we pass        to send and recv.  */
ifdef|#
directive|ifdef
name|SEND_NEVER_PARTIAL
comment|/* If send() never will produce a partial write, then just do it.  This        is needed for systems where its return value is something other than        the number of bytes written.  */
if|if
condition|(
name|send
argument_list|(
name|sb
operator|->
name|socket
argument_list|,
name|data
argument_list|,
name|have
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"writing to server socket: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|have
operator|>
literal|0
condition|)
block|{
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|send
argument_list|(
name|sb
operator|->
name|socket
argument_list|,
name|data
argument_list|,
name|have
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"writing to server socket: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
name|have
operator|-=
name|nbytes
expr_stmt|;
name|data
operator|+=
name|nbytes
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer flush function for a buffer built on a socket.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|socket_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
comment|/* Nothing to do.  Sockets are always flushed.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_SOCKET_TO_FD */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Read a line from the server.  Result does not include the terminating \n.  *  * Space for the result is malloc'd and should be freed by the caller.  *  * Returns number of bytes read.  */
end_comment

begin_function
specifier|static
name|int
name|read_line
parameter_list|(
name|resultp
parameter_list|)
name|char
modifier|*
modifier|*
name|resultp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|status
operator|=
name|buf_flush
argument_list|(
name|to_server
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|status
argument_list|,
literal|"writing to server"
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|from_server
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of file from server (consult above messages if any)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|status
argument_list|,
literal|"reading from server"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resultp
operator|!=
name|NULL
condition|)
operator|*
name|resultp
operator|=
name|result
expr_stmt|;
else|else
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * Zero if compression isn't supported or requested; non-zero to indicate  * a compression level to request from gzip.  */
end_comment

begin_decl_stmt
name|int
name|gzip_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Level of compression to use when running gzip on a single file.  */
end_comment

begin_decl_stmt
name|int
name|file_gzip_level
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|filter_through_gzip
parameter_list|(
name|fd
parameter_list|,
name|dir
parameter_list|,
name|level
parameter_list|,
name|pidp
parameter_list|)
name|int
name|fd
decl_stmt|,
name|dir
decl_stmt|,
name|level
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|5
index|]
init|=
literal|"-"
decl_stmt|;
specifier|static
name|char
modifier|*
name|gzip_argv
index|[
literal|3
index|]
init|=
block|{
literal|"gzip"
block|,
name|buf
block|}
decl_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|filter_stream_through_program
argument_list|(
name|fd
argument_list|,
name|dir
argument_list|,
operator|&
name|gzip_argv
index|[
literal|0
index|]
argument_list|,
name|pidp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|filter_through_gunzip
parameter_list|(
name|fd
parameter_list|,
name|dir
parameter_list|,
name|pidp
parameter_list|)
name|int
name|fd
decl_stmt|,
name|dir
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|gunzip_argv
index|[
literal|3
index|]
init|=
block|{
literal|"gzip"
block|,
literal|"-d"
block|}
decl_stmt|;
return|return
name|filter_stream_through_program
argument_list|(
name|fd
argument_list|,
name|dir
argument_list|,
operator|&
name|gunzip_argv
index|[
literal|0
index|]
argument_list|,
name|pidp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/*  * The Repository for the top level of this command (not necessarily  * the CVSROOT, just the current directory at the time we do it).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|toplevel_repos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Working directory when we first started.  Note: we could speed things    up on some systems by using savecwd.h here instead of just always    storing a name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|toplevel_wd
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handle_ok
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_error
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|something_printed
decl_stmt|;
comment|/*      * First there is a symbolic error code followed by a space, which      * we ignore.      */
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid data from cvs server"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|p
expr_stmt|;
name|len
operator|-=
name|p
operator|-
name|args
expr_stmt|;
name|something_printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|something_printed
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|something_printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_valid_requests
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rq
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rq
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* 	     * It is a request we have never heard of (and thus never 	     * will want to use).  So don't worry about it. 	     */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_enableme
condition|)
block|{
comment|/* 		 * Server wants to know if we have this, to enable the 		 * feature. 		 */
name|send_to_server
argument_list|(
name|rq
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|rq
operator|->
name|status
operator|=
name|rq_supported
expr_stmt|;
block|}
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
block|{
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_essential
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"request `%s' not supported by server"
argument_list|,
name|rq
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_optional
condition|)
name|rq
operator|->
name|status
operator|=
name|rq_not_supported
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This variable holds the result of Entries_Open, so that we can    close Entries_Close on it when we move on to a new directory, or    when we finish.  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|last_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Do all the processing for PATHNAME, where pathname consists of the  * repository and the filename.  The parameters we pass to FUNC are:  * DATA is just the DATA parameter which was passed to  * call_in_directory; ENT_LIST is a pointer to an entries list (which  * we manage the storage for); SHORT_PATHNAME is the pathname of the  * file relative to the (overall) directory in which the command is  * taking place; and FILENAME is the filename portion only of  * SHORT_PATHNAME.  When we call FUNC, the curent directory points to  * the directory portion of SHORT_PATHNAME.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_dir_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|call_in_directory
parameter_list|(
name|pathname
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|data
operator|,
name|List
operator|*
name|ent_list
operator|,
name|char
operator|*
name|short_pathname
operator|,
name|char
operator|*
name|filename
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dir_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* This is what we get when we hook up the directory (working directory        name) from PATHNAME with the filename from REPOSNAME.  For example:        pathname: ccvs/src/        reposname: /u/src/master/ccvs/foo/ChangeLog        short_pathname: ccvs/src/ChangeLog        */
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * Do the whole descent in parallel for the repositories, so we      * know what to put in CVS/Repository files.  I'm not sure the      * full hair is necessary since the server does a similar      * computation; I suspect that we only end up creating one      * directory at a time anyway.      *      * Also note that we must *only* worry about this stuff when we      * are creating directories; `cvs co foo/bar; cd foo/bar; cvs co      * CVSROOT; cvs update' is legitimate, but in this case      * foo/bar/CVSROOT/CVS/Repository is not a subdirectory of      * foo/bar/CVS/Repository.      */
name|char
modifier|*
name|reposname
decl_stmt|;
name|char
modifier|*
name|short_repos
decl_stmt|;
name|char
modifier|*
name|reposdirname
decl_stmt|;
name|char
modifier|*
name|rdirp
decl_stmt|;
name|int
name|reposdirname_absolute
decl_stmt|;
name|reposname
operator|=
name|NULL
expr_stmt|;
name|read_line
argument_list|(
operator|&
name|reposname
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reposname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|reposdirname_absolute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|reposname
argument_list|,
name|toplevel_repos
argument_list|,
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reposdirname_absolute
operator|=
literal|1
expr_stmt|;
name|short_repos
operator|=
name|reposname
expr_stmt|;
block|}
else|else
block|{
name|short_repos
operator|=
name|reposname
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|short_repos
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|reposdirname_absolute
operator|=
literal|1
expr_stmt|;
name|short_repos
operator|=
name|reposname
expr_stmt|;
block|}
block|}
name|reposdirname
operator|=
name|xstrdup
argument_list|(
name|short_repos
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|reposdirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|reposdirname
operator|=
name|xrealloc
argument_list|(
name|reposdirname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|reposdirname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|reposdirname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|dir_name
operator|=
name|xstrdup
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|dir_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|dir_name
operator|=
name|xrealloc
argument_list|(
name|dir_name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dir_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|client_prune_dirs
condition|)
name|add_prune_candidate
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|short_repos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|short_repos
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
name|short_pathname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|short_pathname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|short_pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_dir_name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last_dir_name
argument_list|,
name|dir_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|newdir
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|last_entries
condition|)
name|Entries_Close
argument_list|(
name|last_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_dir_name
condition|)
name|free
argument_list|(
name|last_dir_name
argument_list|)
expr_stmt|;
name|last_dir_name
operator|=
name|dir_name
expr_stmt|;
if|if
condition|(
name|toplevel_wd
operator|==
name|NULL
condition|)
block|{
name|toplevel_wd
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplevel_wd
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get working directory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
name|newdir
operator|=
literal|0
expr_stmt|;
comment|/* Create the CVS directory at the top level if needed. 	   The isdir seems like an unneeded system call, but it *does* 	   need to be called both if the CVS_CHDIR below succeeds (e.g. 	   "cvs co .") or if it fails (e.g. basicb-1a in testsuite).  */
if|if
condition|(
comment|/* I think the reposdirname_absolute case has to do with 	       things like "cvs update /foo/bar".  In any event, the 	       code below which tries to put toplevel_repos into 	       CVS/Repository is almost surely unsuited to 	       the reposdirname_absolute case.  */
operator|!
name|reposdirname_absolute
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
name|char
modifier|*
name|repo
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|newdir
operator|=
literal|1
expr_stmt|;
name|repo
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|repo
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
name|r
operator|=
name|repo
operator|+
name|strlen
argument_list|(
name|repo
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|r
index|[
operator|-
literal|2
index|]
operator|!=
literal|'/'
condition|)
name|strcpy
argument_list|(
name|r
argument_list|,
literal|"/."
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
literal|"."
argument_list|,
name|repo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|dirp
decl_stmt|;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
comment|/* Directory does not exist, we need to create it.  */
name|newdir
operator|=
literal|1
expr_stmt|;
comment|/* Provided we are willing to assume that directories get 	       created one at a time, we could simplify this a lot. 	       Do note that one aspect still would need to walk the 	       dir_name path: the checking for "fncmp (dir, CVSADM)".  */
name|dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|dir_name
expr_stmt|;
name|rdirp
operator|=
name|reposdirname
expr_stmt|;
comment|/* This algorithm makes nested directories one at a time                and create CVS administration files in them.  For                example, we're checking out foo/bar/baz from the                repository:  	       1) create foo, point CVS/Repository to<root>/foo 	       2)     .. foo/bar                   ..<root>/foo/bar 	       3)     .. foo/bar/baz               ..<root>/foo/bar/baz 	        	       As you can see, we're just stepping along DIR_NAME (with 	       DIRP) and REPOSDIRNAME (with RDIRP) respectively.  	       We need to be careful when we are checking out a 	       module, however, since DIR_NAME and REPOSDIRNAME are not 	       going to be the same.  Since modules will not have any 	       slashes in their names, we should watch the output of 	       STRCHR to decide whether or not we should use STRCHR on 	       the RDIRP.  That is, if we're down to a module name, 	       don't keep picking apart the repository directory name.  */
do|do
block|{
name|dirp
operator|=
name|strchr
argument_list|(
name|dirp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
condition|)
block|{
name|strncpy
argument_list|(
name|dir
argument_list|,
name|dir_name
argument_list|,
name|dirp
operator|-
name|dir_name
argument_list|)
expr_stmt|;
name|dir
index|[
name|dirp
operator|-
name|dir_name
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip the slash.  */
operator|++
name|dirp
expr_stmt|;
if|if
condition|(
name|rdirp
operator|==
name|NULL
condition|)
comment|/* This just means that the repository string has 			   fewer components than the dir_name string.  But 			   that is OK (e.g. see modules3-8 in testsuite).  */
empty_stmt|;
else|else
name|rdirp
operator|=
name|strchr
argument_list|(
name|rdirp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If there are no more slashes in the dir name,                        we're down to the most nested directory -OR- to                        the name of a module.  In the first case, we                        should be down to a DIRP that has no slashes,                        so it won't help/hurt to do another STRCHR call                        on DIRP.  It will definitely hurt, however, if                        we're down to a module name, since a module                        name can point to a nested directory (that is,                        DIRP will still have slashes in it.  Therefore,                        we should set it to NULL so the routine below                        copies the contents of REMOTEDIRNAME onto the                        root repository directory (does this if rdirp                        is set to NULL, because we used to do an extra                        STRCHR call here). */
name|rdirp
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fncmp
argument_list|(
name|dir
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot create a directory named %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"because CVS uses \"%s\" for its own uses"
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"rename the directory and try again"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir_if_needed
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* It already existed, fine.  Just keep going.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
comment|/* Don't create CVSADM directories if this is export.  */
empty_stmt|;
else|else
block|{
comment|/* 		     * Put repository in CVS/Repository.  For historical 		     * (pre-CVS/Root) reasons, this is an absolute pathname, 		     * but what really matters is the part of it which is 		     * relative to cvsroot. 		     */
name|char
modifier|*
name|repo
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|repo
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|reposdirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|reposdirname_absolute
condition|)
name|r
operator|=
name|repo
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|repo
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|repo
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|r
operator|=
name|repo
operator|+
name|strlen
argument_list|(
name|repo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdirp
condition|)
block|{
comment|/* See comment near start of function; the only 			   way that the server can put the right thing 			   in each CVS/Repository file is to create the 			   directories one at a time.  I think that the 			   CVS server has been doing this all along.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: server is not creating directories one at a time"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|r
argument_list|,
name|reposdirname
argument_list|,
name|rdirp
operator|-
name|reposdirname
argument_list|)
expr_stmt|;
name|r
index|[
name|rdirp
operator|-
name|reposdirname
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|r
argument_list|,
name|reposdirname
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|dir
argument_list|,
name|repo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repo
argument_list|)
expr_stmt|;
name|b
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|b
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rdirp
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip the slash.  */
operator|++
name|rdirp
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dirp
operator|!=
name|NULL
condition|)
do|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* Now it better work.  */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|last_entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
comment|/* If this is a newly created directory, we will record 	       all subdirectory information, so call Subdirs_Known in 	       case there are no subdirectories.  If this is not a 	       newly created directory, it may be an old working 	       directory from before we recorded subdirectory 	       information in the Entries file.  We force a search for 	       all subdirectories now, to make sure our subdirectory 	       information is up to date.  If the Entries file does 	       record subdirectory information, then this call only 	       does list manipulation.  */
if|if
condition|(
name|newdir
condition|)
name|Subdirs_Known
argument_list|(
name|last_entries
argument_list|)
expr_stmt|;
else|else
block|{
name|List
modifier|*
name|dirlist
decl_stmt|;
name|dirlist
operator|=
name|Find_Directories
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|,
name|last_entries
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|free
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposdirname
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|data
argument_list|,
name|last_entries
argument_list|,
name|short_pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposname
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copy_a_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|newname
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|read_line
argument_list|(
operator|&
name|newname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
comment|/* Mogrify the filename so VMS is happy with it. */
for|for
control|(
name|p
operator|=
name|newname
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'#'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
name|copy_file
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_copy_file
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|copy_a_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|read_counted_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read from the server the count for the length of a file, then read    the contents of that file and write them to FILENAME.  FULLNAME is    the name of the file for use in error messages.  FIXME-someday:    extend this to deal with compressed files and make update_entries    use it.  On error, gives a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|read_counted_file
parameter_list|(
name|filename
parameter_list|,
name|fullname
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
block|{
name|char
modifier|*
name|size_string
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Pointers in buf to the place to put data which will be read,        and the data which needs to be written, respectively.  */
name|char
modifier|*
name|pread
decl_stmt|;
name|char
modifier|*
name|pwrite
decl_stmt|;
comment|/* Number of bytes left to read and number of bytes in buf waiting to        be written, respectively.  */
name|size_t
name|nread
decl_stmt|;
name|size_t
name|nwrite
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|size_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_string
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ protocol error: compressed files not supported for that operation"
argument_list|)
expr_stmt|;
comment|/* FIXME: should be doing more error checking, probably.  Like using        strtoul and making sure we used up the whole line.  */
name|size
operator|=
name|atoi
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
comment|/* A more sophisticated implementation would use only a limited amount        of buffer space (8K perhaps), and read that much at a time.  We allocate        a buffer for the whole file only to make it easy to keep track what        needs to be read and written.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* FIXME-someday: caller should pass in a flag saying whether it        is binary or not.  I haven't carefully looked into whether        CVS/Template files should use local text file conventions or        not.  */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|nread
operator|=
name|size
expr_stmt|;
name|nwrite
operator|=
literal|0
expr_stmt|;
name|pread
operator|=
name|buf
expr_stmt|;
name|pwrite
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|nread
operator|>
literal|0
operator|||
name|nwrite
operator|>
literal|0
condition|)
block|{
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|try_read_from_server
argument_list|(
name|pread
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|nread
operator|-=
name|n
expr_stmt|;
name|pread
operator|+=
name|n
expr_stmt|;
name|nwrite
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|nwrite
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|fwrite
argument_list|(
name|pwrite
argument_list|,
literal|1
argument_list|,
name|nwrite
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|nwrite
operator|-=
name|n
expr_stmt|;
name|pwrite
operator|+=
name|n
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* OK, we want to swallow the "U foo.c" response and then output it only    if we can update the file.  In the future we probably want some more    systematic approach to parsing tagged text, but for now we keep it    ad hoc.  "Why," I hear you cry, "do we not just look at the    Update-existing and Created responses?"  That is an excellent question,    and the answer is roughly conservatism/laziness--I haven't read through    update.c enough to figure out the exact correspondence or lack thereof    between those responses and a "U foo.c" line (note that Merged, from    join_file, can be either "C foo" or "U foo" depending on the context).  */
end_comment

begin_comment
comment|/* Nonzero if we have seen +updated and not -updated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|updated_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename from an "fname" tagged response within +updated/-updated.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|updated_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should arrange to return with a failure exit status.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|failure_exit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The time stamp of the last file we registered.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The Checksum response gives the checksum for the file transferred  * over by the next Updated, Merged or Patch response.  We just store  * it here, and then check it in update_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stored_checksum_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|stored_checksum
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_checksum
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stored_checksum_valid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Checksum received before last one was used"
argument_list|)
expr_stmt|;
name|s
operator|=
name|args
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|bufend
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|stored_checksum
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|strtol
argument_list|(
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufend
operator|!=
name|buf
operator|+
literal|2
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|16
operator|||
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid Checksum response: `%s'"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|stored_mode_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stored_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_mode
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mode
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|stored_mode_valid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"protocol error: duplicate Mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stored_mode
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stored_mode
argument_list|)
expr_stmt|;
name|stored_mode
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stored_mode_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if time was specified in Mod-time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stored_modtime_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time specified in Mod-time.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|stored_modtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_mod_time
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mod_time
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|stored_modtime_valid
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: duplicate Mod-time"
argument_list|)
expr_stmt|;
name|stored_modtime
operator|=
name|get_date
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stored_modtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: cannot parse date %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|stored_modtime_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * If we receive a patch, but the patch program fails to apply it, we  * want to request the original file.  We keep a list of files whose  * patches have failed.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|failed_patches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|failed_patches_count
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|update_entries_data
block|{
enum|enum
block|{
comment|/*        * We are just getting an Entries line; the local file is        * correct.        */
name|UPDATE_ENTRIES_CHECKIN
block|,
comment|/* We are getting the file contents as well.  */
name|UPDATE_ENTRIES_UPDATE
block|,
comment|/*        * We are getting a patch against the existing local file, not        * an entire new file.        */
name|UPDATE_ENTRIES_PATCH
block|,
comment|/*        * We are getting an RCS change text (diff -n output) against        * the existing local file, not an entire new file.        */
name|UPDATE_ENTRIES_RCS_DIFF
block|}
name|contents
enum|;
enum|enum
block|{
comment|/* We are replacing an existing file.  */
name|UPDATE_ENTRIES_EXISTING
block|,
comment|/* We are creating a new file.  */
name|UPDATE_ENTRIES_NEW
block|,
comment|/* We don't know whether it is existing or new.  */
name|UPDATE_ENTRIES_EXISTING_OR_NEW
block|}
name|existp
enum|;
comment|/*      * String to put in the timestamp field or NULL to use the timestamp      * of the file.      */
name|char
modifier|*
name|timestamp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Update the Entries line for this file.  */
end_comment

begin_function
specifier|static
name|void
name|update_entries
parameter_list|(
name|data_arg
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data_arg
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|entries_line
decl_stmt|;
name|struct
name|update_entries_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|update_entries_data
operator|*
operator|)
name|data_arg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|vn
decl_stmt|;
comment|/* Timestamp field.  Always empty according to the protocol.  */
name|char
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tag_or_date
decl_stmt|;
name|char
modifier|*
name|scratch_entries
init|=
name|NULL
decl_stmt|;
name|int
name|bin
decl_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
name|int
name|change_it_back
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|read_line
argument_list|(
operator|&
name|entries_line
argument_list|)
expr_stmt|;
comment|/*      * Parse the entries line.      */
name|scratch_entries
operator|=
name|xstrdup
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_entries
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
name|user
operator|=
name|scratch_entries
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vn
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|vn
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|options
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tag_or_date
operator|=
name|cp
expr_stmt|;
comment|/* If a slash ends the tag_or_date, ignore everything after it.  */
name|cp
operator|=
name|strchr
argument_list|(
name|tag_or_date
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'T'
condition|)
name|tag
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'D'
condition|)
name|date
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
comment|/* Done parsing the entries line. */
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_UPDATE
operator|||
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_PATCH
operator|||
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_RCS_DIFF
condition|)
block|{
name|char
modifier|*
name|size_string
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|temp_filename
decl_stmt|;
name|int
name|use_gzip
decl_stmt|;
name|int
name|patch_failed
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|mode_string
argument_list|)
expr_stmt|;
name|read_line
argument_list|(
operator|&
name|size_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_string
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|use_gzip
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_string
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|use_gzip
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
comment|/* Note that checking this separately from writing the file is 	   a race condition: if the existing or lack thereof of the 	   file changes between now and the actually calls which 	   operate on it, we lose.  However (a) there are so many 	   cases, I'm reluctant to try to fix them all, (b) in some 	   cases the system might not even have a system call which 	   does the right thing, and (c) it isn't clear this needs to 	   work.  */
if|if
condition|(
name|data
operator|->
name|existp
operator|==
name|UPDATE_ENTRIES_EXISTING
operator|&&
operator|!
name|isfile
argument_list|(
name|filename
argument_list|)
condition|)
comment|/* Emit a warning and update the file anyway.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: %s unexpectedly disappeared"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|existp
operator|==
name|UPDATE_ENTRIES_NEW
operator|&&
name|isfile
argument_list|(
name|filename
argument_list|)
condition|)
block|{
comment|/* Emit a warning and refuse to update the file; we don't want 	       to clobber a user's file.  */
name|size_t
name|nread
decl_stmt|;
name|size_t
name|toread
decl_stmt|;
comment|/* size should be unsigned, but until we get around to fixing 	       that, work around it.  */
name|size_t
name|usize
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* This error might be confusing; it isn't really clear to 	       the user what to do about it.  Keep in mind that it has 	       several causes: (1) something/someone creates the file 	       during the time that CVS is running, (2) the repository 	       has two files whose names clash for the client because 	       of case-insensitivity or similar causes, (3) a special 	       case of this is that a file gets renamed for example 	       from a.c to A.C.  A "cvs update" on a case-insensitive 	       client will get this error.  Repeating the update takes 	       care of the problem, but is it clear to the user what 	       is going on and what to do about it?, (4) the client 	       has a file which the server doesn't know about (e.g. "? 	       foo" file), and that name clashes with a file the 	       server does know about, (5) classify.c will print the same 	       message for other reasons.  	       I hope the above paragraph makes it clear that making this 	       clearer is not a one-line fix.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"move away %s; it is in the way"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|updated_fname
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"C "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|updated_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|failure_exit
operator|=
literal|1
expr_stmt|;
name|discard_file_and_return
label|:
comment|/* Now read and discard the file contents.  */
name|usize
operator|=
name|size
expr_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nread
operator|<
name|usize
condition|)
block|{
name|toread
operator|=
name|usize
operator|-
name|nread
expr_stmt|;
if|if
condition|(
name|toread
operator|>
sizeof|sizeof
name|buf
condition|)
name|toread
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|nread
operator|+=
name|try_read_from_server
argument_list|(
name|buf
argument_list|,
name|toread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
name|usize
condition|)
break|break;
block|}
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
comment|/* The Mode, Mod-time, and Checksum responses should not carry 	       over to a subsequent Created (or whatever) response, even 	       in the error case.  */
name|stored_mode_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stored_mode
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stored_mode
argument_list|)
expr_stmt|;
name|stored_modtime_valid
operator|=
literal|0
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|updated_fname
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|updated_fname
argument_list|)
expr_stmt|;
name|updated_fname
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
comment|/* A VMS rename of "blah.dat" to "foo" to implies a            destination of "foo.dat" which is unfortinate for CVS */
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|"%s_new_"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_POSIX_NO_TRUNC
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|".new.%.9s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _POSIX_NO_TRUNC */
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|".new.%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_NO_TRUNC */
endif|#
directive|endif
comment|/* USE_VMS_FILENAMES */
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Some systems, like OS/2 and Windows NT, end lines with CRLF            instead of just LF.  Format translation is done in the C            library I/O funtions.  Here we tell them whether or not to            convert -- if this file is marked "binary" with the RCS -kb            flag, then we don't want to convert, else we do (because            CVS assumes text files by default). */
if|if
condition|(
name|options
condition|)
name|bin
operator|=
operator|!
operator|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|)
expr_stmt|;
else|else
name|bin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_RCS_DIFF
condition|)
block|{
comment|/* This is an RCS change text.  We just hold the change 	       text in memory.  */
if|if
condition|(
name|use_gzip
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server error: gzip invalid with RCS change text"
argument_list|)
expr_stmt|;
name|read_from_server
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|temp_filename
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
operator|(
name|bin
condition|?
name|OPEN_BINARY
else|:
literal|0
operator|)
operator|)
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* I can see a case for making this a fatal error; for 		   a condition like disk full or network unreachable 		   (for a file server), carrying on and giving an 		   error on each file seems unnecessary.  But if it is 		   a permission problem, or some such, then it is 		   entirely possible that future files will not have 		   the same problem.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
goto|goto
name|discard_file_and_return
goto|;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|read_from_server
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gzip
condition|)
name|gunzip_and_write
argument_list|(
name|fd
argument_list|,
name|short_pathname
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
comment|/* This is after we have read the file from the net (a change 	   from previous versions, where the server would send us 	   "M U foo.c" before Update-existing or whatever), but before 	   we finish writing the file (arguably a bug).  The timing 	   affects a user who wants status info about how far we have 	   gotten, and also affects whether "U foo.c" appears in addition 	   to various error messages.  */
if|if
condition|(
name|updated_fname
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"U "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|updated_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|updated_fname
argument_list|)
expr_stmt|;
name|updated_fname
operator|=
literal|0
expr_stmt|;
block|}
name|patch_failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_UPDATE
condition|)
block|{
name|rename_file
argument_list|(
name|temp_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_PATCH
condition|)
block|{
ifdef|#
directive|ifdef
name|DONT_USE_PATCH
comment|/* Hmm.  We support only Rcs-diff, and the server supports 	       only Patched (or else it would have sent Rcs-diff instead). 	       Fall back to transmitting entire files.  */
name|patch_failed
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* Use patch.  */
name|int
name|retcode
decl_stmt|;
name|char
modifier|*
name|backup
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|backup
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|backup
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|filename
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"patch original file %s does not exist"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|temp_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't stat patch file %s"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|st_size
operator|==
literal|0
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* This behavior (in which -b takes an argument) is 		   supported by GNU patch 2.1.  Apparently POSIX.2 		   specifies a -b option without an argument.  GNU 		   patch 2.1.5 implements this and therefore won't 		   work here.  GNU patch versions after 2.1.5 are said 		   to have a kludge which checks if the last 4 args 		   are `-b SUFFIX ORIGFILE PATCHFILE' and if so emit a 		   warning (I think -s suppresses it), and then behave 		   as CVS expects.  		   Of course this is yet one more reason why in the long 		   run we want Rcs-diff to replace Patched.  */
name|run_setup
argument_list|(
name|PATCH_PROGRAM
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
literal|"-s"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
literal|"~"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|run_exec
argument_list|(
name|DEVNULL
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
name|char
modifier|*
name|path_tmp
decl_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Get rid of the patch reject file.  */
name|path_tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path_tmp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path_tmp
argument_list|,
literal|".rej"
argument_list|)
expr_stmt|;
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|path_tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_tmp
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not patch %s%s"
argument_list|,
name|filename
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
literal|"; will refetch"
argument_list|)
expr_stmt|;
name|patch_failed
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Use patch.  */
block|}
else|else
block|{
name|char
modifier|*
name|filebuf
decl_stmt|;
name|size_t
name|filebufsize
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
name|char
modifier|*
name|patchedbuf
decl_stmt|;
name|size_t
name|patchedlen
decl_stmt|;
comment|/* Handle UPDATE_ENTRIES_RCS_DIFF.  */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|filename
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"patch original file %s does not exist"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|filebuf
operator|=
name|NULL
expr_stmt|;
name|filebufsize
operator|=
literal|0
expr_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
name|get_file
argument_list|(
name|filename
argument_list|,
name|short_pathname
argument_list|,
name|bin
condition|?
name|FOPEN_BINARY_READ
else|:
literal|"r"
argument_list|,
operator|&
name|filebuf
argument_list|,
operator|&
name|filebufsize
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
comment|/* At this point the contents of the existing file are in                FILEBUF, and the length of the contents is in NREAD.                The contents of the patch from the network are in BUF,                and the length of the patch is in SIZE.  */
if|if
condition|(
operator|!
name|rcs_change_text
argument_list|(
name|short_pathname
argument_list|,
name|filebuf
argument_list|,
name|nread
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
operator|&
name|patchedbuf
argument_list|,
operator|&
name|patchedlen
argument_list|)
condition|)
name|patch_failed
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stored_checksum_valid
condition|)
block|{
name|struct
name|MD5Context
name|context
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
comment|/* We have a checksum.  Check it before writing 		       the file out, so that we don't have to read it 		       back in again.  */
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|patchedbuf
argument_list|,
name|patchedlen
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|checksum
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum
argument_list|,
name|stored_checksum
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"checksum failure after patch to %s; will refetch"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|patch_failed
operator|=
literal|1
expr_stmt|;
block|}
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|patch_failed
condition|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|open_file
argument_list|(
name|temp_filename
argument_list|,
name|bin
condition|?
name|FOPEN_BINARY_WRITE
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|patchedbuf
argument_list|,
literal|1
argument_list|,
name|patchedlen
argument_list|,
name|e
argument_list|)
operator|!=
name|patchedlen
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|temp_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|patchedbuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stored_checksum_valid
operator|&&
operator|!
name|patch_failed
condition|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|MD5Context
name|context
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	     * Compute the MD5 checksum.  This will normally only be 	     * used when receiving a patch, so we always compute it 	     * here on the final file, rather than on the received 	     * data. 	     * 	     * Note that if the file is a text file, we should read it 	     * here using text mode, so its lines will be terminated the same 	     * way they were transmitted. 	     */
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not read %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|checksum
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum
argument_list|,
name|stored_checksum
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|contents
operator|!=
name|UPDATE_ENTRIES_PATCH
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"checksum failure on %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"checksum failure after patch to %s; will refetch"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|patch_failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|patch_failed
condition|)
block|{
comment|/* Save this file to retrieve later.  */
name|failed_patches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|failed_patches
argument_list|,
operator|(
operator|(
name|failed_patches_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failed_patches
index|[
name|failed_patches_count
index|]
operator|=
name|xstrdup
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
operator|++
name|failed_patches_count
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|int
name|status
init|=
name|change_mode
argument_list|(
name|filename
argument_list|,
name|mode_string
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot change mode of %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stored_mode_valid
condition|)
name|change_mode
argument_list|(
name|filename
argument_list|,
name|stored_mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stored_mode_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stored_modtime_valid
condition|)
block|{
name|struct
name|utimbuf
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There is probably little point in trying to preserved the 	   actime (or is there? What about Checked-in?).  */
name|t
operator|.
name|modtime
operator|=
name|t
operator|.
name|actime
operator|=
name|stored_modtime
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
if|if
condition|(
operator|!
name|iswritable
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|xchmod
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|change_it_back
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UTIME_EXPECTS_WRITABLE  */
if|if
condition|(
name|utime
argument_list|(
name|filename
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot set time on %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
if|if
condition|(
name|change_it_back
operator|==
literal|1
condition|)
block|{
name|xchmod
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_it_back
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  UTIME_EXPECTS_WRITABLE  */
name|stored_modtime_valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Process the entries line.  Do this after we've written the file,      * since we need the timestamp.      */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|local_timestamp
decl_stmt|;
name|char
modifier|*
name|file_timestamp
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|local_timestamp
operator|=
name|data
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|local_timestamp
operator|==
name|NULL
operator|||
name|ts
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|file_timestamp
operator|=
name|time_stamp
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|file_timestamp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * These special version numbers signify that it is not up to 	 * date.  Create a dummy timestamp which will never compare 	 * equal to the timestamp of the file. 	 */
if|if
condition|(
name|vn
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|vn
index|[
literal|0
index|]
operator|==
literal|'0'
operator|||
name|vn
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|local_timestamp
operator|=
literal|"dummy timestamp"
expr_stmt|;
elseif|else
if|if
condition|(
name|local_timestamp
operator|==
name|NULL
condition|)
block|{
name|local_timestamp
operator|=
name|file_timestamp
expr_stmt|;
name|mark_up_to_date
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|,
name|vn
argument_list|,
name|local_timestamp
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
name|file_timestamp
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_timestamp
condition|)
name|free
argument_list|(
name|file_timestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratch_entries
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_checked_in
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_CHECKIN
expr_stmt|;
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_new_entry
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_CHECKIN
expr_stmt|;
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
literal|"dummy timestamp from new-entry"
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_updated
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_created
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_created
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_update_existing
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_update_existing
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_merged
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
comment|/* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
literal|"Result of merge"
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_patched
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_PATCH
expr_stmt|;
comment|/* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_rcs_diff
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_RCS_DIFF
expr_stmt|;
comment|/* Think this could be UPDATE_ENTRIES_EXISTING, but just in case...  */
name|dat
operator|.
name|existp
operator|=
name|UPDATE_ENTRIES_EXISTING_OR_NEW
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_entry
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Scratch_Entry
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_remove_entry
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|remove_entry
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_entry_and_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Scratch_Entry
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Note that we don't ignore existence_error's here.  The server        should be sending Remove-entry rather than Removed in cases        where the file does not exist.  And if the user removes the        file halfway through a cvs command, we should be printing an        error.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|filename
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"unable to remove %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_removed
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|remove_entry_and_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Is this the top level (directory containing CVSROOT)?  */
end_comment

begin_function
specifier|static
name|int
name|is_cvsroot_level
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|toplevel_repos
argument_list|,
name|CVSroot_directory
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_static
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_static_directory
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|set_static
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_static
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_clear_static_directory
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|clear_static
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_sticky
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|tagspec
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|tagspec
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|tagspec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tagspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_sticky
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Swallow the tag line.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Swallow the tag line.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|set_sticky
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_sticky
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_TAG
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_clear_sticky
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|clear_sticky
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|List
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|template
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
comment|/* FIXME: should be computing second argument from CVSADM_TEMPLATE        and short_pathname.  */
name|read_counted_file
argument_list|(
name|CVSADM_TEMPLATE
argument_list|,
literal|"<CVS/Template file>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_template
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|template
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|save_prog
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|save_prog
modifier|*
name|checkin_progs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|save_prog
modifier|*
name|update_progs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unlike some responses this doesn't include the repository.  So we can't  * just call call_in_directory and have the right thing happen; we save up  * the requests and do them at the end.  */
end_comment

begin_function
specifier|static
name|void
name|handle_set_checkin_prog
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|prog
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|prog
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|save_prog
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_prog
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|checkin_progs
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|prog
expr_stmt|;
name|checkin_progs
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_update_prog
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|prog
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|prog
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|save_prog
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_prog
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|update_progs
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|prog
expr_stmt|;
name|update_progs
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|do_deferred_progs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|do_deferred_progs
parameter_list|()
block|{
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|toplevel_wd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|checkin_progs
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|dir
argument_list|)
operator|+
sizeof|sizeof
name|CVSADM_CIPROG
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
operator|->
name|dir
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|checkin_progs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|update_progs
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|dir
argument_list|)
operator|+
sizeof|sizeof
name|CVSADM_UPROG
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
operator|->
name|dir
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|update_progs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|save_dir
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|save_dir
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|save_dir
modifier|*
name|prune_candidates
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_prune_candidate
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|save_dir
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|prune_candidates
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dir
argument_list|,
name|prune_candidates
operator|->
name|dir
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|save_dir
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_dir
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|prune_candidates
expr_stmt|;
name|prune_candidates
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|process_prune_candidates
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|process_prune_candidates
parameter_list|()
block|{
name|struct
name|save_dir
modifier|*
name|p
decl_stmt|;
name|struct
name|save_dir
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|toplevel_wd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|prune_candidates
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|isemptydir
argument_list|(
name|p
operator|->
name|dir
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|p
operator|->
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|b
operator|=
name|strrchr
argument_list|(
name|p
operator|->
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|Subdir_Deregister
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
name|Subdir_Deregister
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
name|p
operator|->
name|dir
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|prune_candidates
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a Repository line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_repos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_update_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_repository
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_repository
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
modifier|*
name|adm_name
decl_stmt|;
comment|/* FIXME: this is probably not the best place to check; I wish I      * knew where in here's callers to really trap this bug.  To      * reproduce the bug, just do this:      *       *       mkdir junk      *       cd junk      *       cvs -d some_repos update foo      *      * Poof, CVS seg faults and dies!  It's because it's trying to      * send a NULL string to the server but dies in send_to_server.      * That string was supposed to be the repository, but it doesn't      * get set because there's no CVSADM dir, and somehow it's not      * getting set from the -d argument either... ?      */
if|if
condition|(
name|repos
operator|==
name|NULL
condition|)
block|{
comment|/* Lame error.  I want a real fix but can't stay up to track            this down right now. */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no repository"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_dir
operator|==
name|NULL
operator|||
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|update_dir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|repos
argument_list|,
name|last_repos
argument_list|)
operator|==
literal|0
operator|&&
name|last_update_dir
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|update_dir
argument_list|,
name|last_update_dir
argument_list|)
operator|==
literal|0
condition|)
comment|/* We've already sent it.  */
return|return;
if|if
condition|(
name|client_prune_dirs
condition|)
name|add_prune_candidate
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
comment|/* 80 is large enough for any of CVSADM_*.  */
name|adm_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Directory "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
comment|/* Send the directory name.  I know that this 	   sort of duplicates code elsewhere, but each 	   case seems slightly different...  */
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|update_dir
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|assert
argument_list|(
operator|*
name|p
operator|!=
literal|'\012'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIRSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|repos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|supported_request
argument_list|(
literal|"Static-directory"
argument_list|)
condition|)
block|{
name|adm_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|adm_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|adm_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|adm_name
argument_list|)
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Static-directory\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Sticky"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
init|=
name|NULL
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Sticky "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Checkin-prog"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
init|=
name|NULL
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Checkin-prog "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Update-prog"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
init|=
name|NULL
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Update-prog "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|adm_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|xstrdup
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a Repository line and set toplevel_repos.  */
end_comment

begin_function
name|void
name|send_a_repository
parameter_list|(
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
operator|&&
name|repository
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|update_dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	     * Get the repository from a CVS/Repository file if update_dir 	     * is absolute.  This is not correct in general, because 	     * the CVS/Repository file might not be the top-level one. 	     * This is for cases like "cvs update /foo/bar" (I'm not 	     * sure it matters what toplevel_repos we get, but it does 	     * matter that we don't hit the "internal error" code below). 	     */
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|toplevel_repos
operator|=
name|Name_Repository
argument_list|(
name|update_dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Guess the repository of that directory by looking at a 		 * subdirectory and removing as many pathname components 		 * as are in update_dir.  I think that will always (or at 		 * least almost always) be 1. 		 * 		 * So this deals with directories which have been 		 * renamed, though it doesn't necessarily deal with 		 * directories which have been put inside other 		 * directories (and cvs invoked on the containing 		 * directory).  I'm not sure the latter case needs to 		 * work. 		 */
comment|/* 		 * This gets toplevel_repos wrong for "cvs update ../foo" 		 * but I'm not sure toplevel_repos matters in that case. 		 */
name|int
name|slashes_in_update_dir
decl_stmt|;
name|int
name|slashes_skipped
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 		 * Strip trailing slashes from the name of the update directory. 		 * Otherwise, running `cvs update dir/' provokes the failure 		 * `protocol error: illegal directory syntax in dir/' when 		 * running in client/server mode. 		 */
name|strip_trailing_slashes
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|slashes_in_update_dir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|update_dir
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|slashes_in_update_dir
expr_stmt|;
name|slashes_skipped
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|repository
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|repository
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: not enough slashes in %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|slashes_skipped
expr_stmt|;
if|if
condition|(
name|slashes_skipped
operator|<
name|slashes_in_update_dir
operator|+
literal|1
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|toplevel_repos
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|repository
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we don't copy the trailing '/'.  */
name|strncpy
argument_list|(
name|toplevel_repos
argument_list|,
name|repository
argument_list|,
name|p
operator|-
name|repository
argument_list|)
expr_stmt|;
name|toplevel_repos
index|[
name|p
operator|-
name|repository
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|send_repository
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The "expanded" modules.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|modules_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modules_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|modules_vector
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_module_expansion
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|modules_vector
operator|==
name|NULL
condition|)
block|{
name|modules_allocated
operator|=
literal|1
expr_stmt|;
comment|/* Small for testing */
name|modules_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|modules_allocated
operator|*
sizeof|sizeof
argument_list|(
name|modules_vector
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modules_count
operator|>=
name|modules_allocated
condition|)
block|{
name|modules_allocated
operator|*=
literal|2
expr_stmt|;
name|modules_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modules_vector
argument_list|,
name|modules_allocated
operator|*
sizeof|sizeof
argument_list|(
name|modules_vector
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modules_vector
index|[
name|modules_count
index|]
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|modules_vector
index|[
name|modules_count
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|++
name|modules_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Original, not "expanded" modules.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|module_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|module_argv
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|client_expand_modules
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|int
name|errs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|module_argc
operator|=
name|argc
expr_stmt|;
name|module_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|module_argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|module_argv
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|module_argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|CVSroot_directory
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"expand-modules\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errs
operator|=
name|get_server_responses
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|errs
condition|)
name|error
argument_list|(
name|errs
argument_list|,
literal|0
argument_list|,
literal|"cannot expand modules"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_send_expansions
parameter_list|(
name|local
parameter_list|,
name|where
parameter_list|,
name|build_dirs
parameter_list|)
name|int
name|local
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|int
name|build_dirs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|1
index|]
decl_stmt|;
comment|/* Send the original module names.  The "expanded" module name might        not be suitable as an argument to a co request (e.g. it might be        the result of a -d argument in the modules file).  It might be        cleaner if we genuinely expanded module names, all the way to a        local directory and repository, but that isn't the way it works        now.  */
name|send_file_names
argument_list|(
name|module_argc
argument_list|,
name|module_argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modules_count
condition|;
operator|++
name|i
control|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
name|where
condition|?
name|where
else|:
name|modules_vector
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
name|send_files
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|build_dirs
condition|?
name|SEND_BUILD_DIRS
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|CVSroot_directory
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_nonexpanded_setup
parameter_list|()
block|{
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|CVSroot_directory
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Receive a cvswrappers line from the server; it must be a line    containing an RCS option (e.g., "*.exe   -k 'b'").     Note that this doesn't try to handle -t/-f options (which are a    whole separate issue which noone has thought much about, as far    as I know).     We need to know the keyword expansion mode so we know whether to    read the file in text or binary mode.  */
end_comment

begin_function
specifier|static
name|void
name|handle_wrapper_rcs_option
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Enforce the notes in cvsclient.texi about how the response is not        as free-form as it looks.  */
name|p
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'-'
operator|||
operator|*
operator|++
name|p
operator|!=
literal|'k'
operator|||
operator|*
operator|++
name|p
operator|!=
literal|' '
operator|||
operator|*
operator|++
name|p
operator|!=
literal|'\''
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\''
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* Add server-side cvswrappers line to our wrapper list. */
name|wrap_add
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"protocol error: ignoring invalid wrappers %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handle_m
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* In the case where stdout and stderr point to the same place,        fflushing stderr will make output happen in the correct order.        Often stderr will be line-buffered and this won't be needed,        but not always (is that true?  I think the comment is probably        based on being confused between default buffering between        stdout and stderr.  But I'm not sure).  */
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|args
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_mbinary
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mbinary
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|size_string
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|totalread
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
name|size_t
name|toread
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
comment|/* See comment at handle_m about (non)flush of stderr.  */
comment|/* Get the size.  */
name|read_line
argument_list|(
operator|&
name|size_string
argument_list|)
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
comment|/* OK, now get all the data.  The algorithm here is that we read        as much as the network wants to give us in        try_read_from_server, and then we output it all, and then        repeat, until we get all the data.  */
name|totalread
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|totalread
operator|<
name|size
condition|)
block|{
name|toread
operator|=
name|size
operator|-
name|totalread
expr_stmt|;
if|if
condition|(
name|toread
operator|>
sizeof|sizeof
name|buf
condition|)
name|toread
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|nread
operator|=
name|try_read_from_server
argument_list|(
name|buf
argument_list|,
name|toread
argument_list|)
expr_stmt|;
name|cvs_output_binary
argument_list|(
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|totalread
operator|+=
name|nread
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|handle_e
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/* In the case where stdout and stderr point to the same place,        fflushing stdout will make output happen in the correct order.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|args
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|handle_f
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_mt
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mt
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
comment|/* See comment at handle_m for more details.  */
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|text
operator|=
name|NULL
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|text
operator|=
name|p
expr_stmt|;
block|}
switch|switch
condition|(
name|tag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"+updated"
argument_list|)
operator|==
literal|0
condition|)
name|updated_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"-updated"
argument_list|)
operator|==
literal|0
condition|)
name|updated_seen
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|updated_seen
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"fname"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|updated_fname
operator|!=
name|NULL
condition|)
block|{
comment|/* Output the previous message now.  This can happen 			   if there was no Update-existing or other such 			   response, due to the -n global option.  */
name|cvs_output
argument_list|(
literal|"U "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|updated_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|updated_fname
argument_list|)
expr_stmt|;
block|}
name|updated_fname
operator|=
name|xstrdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/* Swallow all other tags.  Either they are extraneous 		   or they reflect future extensions that we can 		   safely ignore.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"newline"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* This table must be writeable if the server code is included.  */
end_comment

begin_decl_stmt
name|struct
name|response
name|responses
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
define|#
directive|define
name|RSP_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|)
value|{n, f, t, s}
else|#
directive|else
comment|/* ! CLIENT_SUPPORT */
define|#
directive|define
name|RSP_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|)
value|{n, s}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|RSP_LINE
argument_list|(
literal|"ok"
argument_list|,
name|handle_ok
argument_list|,
name|response_type_ok
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"error"
argument_list|,
name|handle_error
argument_list|,
name|response_type_error
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Valid-requests"
argument_list|,
name|handle_valid_requests
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Checked-in"
argument_list|,
name|handle_checked_in
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"New-entry"
argument_list|,
name|handle_new_entry
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Checksum"
argument_list|,
name|handle_checksum
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Copy-file"
argument_list|,
name|handle_copy_file
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Updated"
argument_list|,
name|handle_updated
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Created"
argument_list|,
name|handle_created
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Update-existing"
argument_list|,
name|handle_update_existing
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Merged"
argument_list|,
name|handle_merged
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Patched"
argument_list|,
name|handle_patched
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Rcs-diff"
argument_list|,
name|handle_rcs_diff
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Mode"
argument_list|,
name|handle_mode
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Mod-time"
argument_list|,
name|handle_mod_time
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Removed"
argument_list|,
name|handle_removed
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Remove-entry"
argument_list|,
name|handle_remove_entry
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-static-directory"
argument_list|,
name|handle_set_static_directory
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Clear-static-directory"
argument_list|,
name|handle_clear_static_directory
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-sticky"
argument_list|,
name|handle_set_sticky
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Clear-sticky"
argument_list|,
name|handle_clear_sticky
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Template"
argument_list|,
name|handle_template
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-checkin-prog"
argument_list|,
name|handle_set_checkin_prog
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-update-prog"
argument_list|,
name|handle_set_update_prog
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Notified"
argument_list|,
name|handle_notified
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Module-expansion"
argument_list|,
name|handle_module_expansion
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Wrapper-rcsOption"
argument_list|,
name|handle_wrapper_rcs_option
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"M"
argument_list|,
name|handle_m
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Mbinary"
argument_list|,
name|handle_mbinary
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"E"
argument_list|,
name|handle_e
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"F"
argument_list|,
name|handle_f
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"MT"
argument_list|,
name|handle_mt
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
comment|/* Possibly should be response_type_error.  */
name|RSP_LINE
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|response_type_normal
argument_list|,
argument|rs_essential
argument_list|)
undef|#
directive|undef
name|RSP_LINE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/*   * If LEN is 0, then send_to_server() computes string's length itself.  *  * Therefore, pass the real length when transmitting data that might  * contain 0's.  */
end_comment

begin_function
name|void
name|send_to_server
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
specifier|static
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|to_server
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* There is no reason not to send data to the server, so do it        whenever we've accumulated enough information in the buffer to        make it worth sending.  */
name|nbytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>=
literal|2
operator|*
name|BUFFER_DATA_SIZE
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_send_output
argument_list|(
name|to_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|status
argument_list|,
literal|"error writing to server"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read up to LEN bytes from the server.  Returns actual number of    bytes read, which will always be at least one; blocks if there is    no data available at all.  Gives a fatal error on EOF or error.  */
end_comment

begin_function
specifier|static
name|size_t
name|try_read_from_server
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|from_server
argument_list|,
name|len
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of file from server (consult above messages if any)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|status
argument_list|,
literal|"reading from server"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|nread
argument_list|)
expr_stmt|;
return|return
name|nread
return|;
block|}
end_function

begin_comment
comment|/*  * Read LEN bytes from the server or die trying.  */
end_comment

begin_function
name|void
name|read_from_server
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|red
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|red
operator|<
name|len
condition|)
block|{
name|red
operator|+=
name|try_read_from_server
argument_list|(
name|buf
operator|+
name|red
argument_list|,
name|len
operator|-
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|len
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Get some server responses and process them.  Returns nonzero for  * error, 0 for success.  */
end_comment

begin_function
name|int
name|get_server_responses
parameter_list|()
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read_line
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
name|rs
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|rs
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|cmdlen
init|=
name|strlen
argument_list|(
name|rs
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
index|[
name|cmdlen
index|]
operator|==
literal|'\0'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|cmdlen
index|]
operator|==
literal|' '
condition|)
operator|++
name|cmdlen
expr_stmt|;
else|else
comment|/* 		     * The first len characters match, but it's a different 		     * response.  e.g. the response is "oklahoma" but we 		     * matched "ok". 		     */
continue|continue;
call|(
modifier|*
name|rs
operator|->
name|func
call|)
argument_list|(
name|cmd
operator|+
name|cmdlen
argument_list|,
name|len
operator|-
name|cmdlen
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* It's OK to print just to the first '\0'.  */
comment|/* We might want to handle control characters and the like 	       in some other way other than just sending them to stdout. 	       One common reason for this error is if people use :ext: 	       with a version of rsh which is doing CRLF translation or 	       something, and so the client gets "ok^M" instead of "ok". 	       Right now that will tend to print part of this error 	       message over the other part of it.  It seems like we could 	       do better (either in general, by quoting or omitting all 	       control characters, and/or specifically, by detecting the CRLF 	       case and printing a specific error message).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: unrecognized response `%s' from cvs server"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rs
operator|->
name|type
operator|==
name|response_type_normal
condition|)
do|;
if|if
condition|(
name|updated_fname
operator|!=
name|NULL
condition|)
block|{
comment|/* Output the previous message now.  This can happen 	   if there was no Update-existing or other such 	   response, due to the -n global option.  */
name|cvs_output
argument_list|(
literal|"U "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|updated_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|updated_fname
argument_list|)
expr_stmt|;
name|updated_fname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|->
name|type
operator|==
name|response_type_error
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|failure_exit
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the responses and then close the connection.  */
end_comment

begin_decl_stmt
name|int
name|server_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag var; we'll set it in start_server() and not one of its  * callees, such as start_rsh_server().  This means that there might  * be a small window between the starting of the server and the  * setting of this var, but all the code in that window shouldn't care  * because it's busy checking return values to see if the server got  * started successfully anyway.  */
end_comment

begin_decl_stmt
name|int
name|server_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|get_responses_and_close
parameter_list|()
block|{
name|int
name|errs
init|=
name|get_server_responses
argument_list|()
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|last_entries
operator|!=
name|NULL
condition|)
block|{
name|Entries_Close
argument_list|(
name|last_entries
argument_list|)
expr_stmt|;
name|last_entries
operator|=
name|NULL
expr_stmt|;
block|}
name|do_deferred_progs
argument_list|()
expr_stmt|;
if|if
condition|(
name|client_prune_dirs
condition|)
name|process_prune_candidates
argument_list|()
expr_stmt|;
comment|/* The calls to buf_shutdown are currently only meaningful when we        are using compression.  First we shut down TO_SERVER.  That        tells the server that its input is finished.  It then shuts        down the buffer it is sending to us, at which point our shut        down of FROM_SERVER will complete.  */
name|status
operator|=
name|buf_shutdown
argument_list|(
name|to_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"shutting down buffer to server"
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_shutdown
argument_list|(
name|from_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"shutting down buffer from server"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|server_sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"shutting down server socket: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|||
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
if|if
condition|(
name|server_fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|server_fd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"shutting down connection to %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/*              * This test will always be true because we dup the descriptor              */
if|if
condition|(
name|fileno
argument_list|(
name|from_server_fp
argument_list|)
operator|!=
name|fileno
argument_list|(
name|to_server_fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|to_server_fp
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing down connection to %s"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHUTDOWN_SERVER
name|SHUTDOWN_SERVER
argument_list|(
name|fileno
argument_list|(
name|to_server_fp
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! SHUTDOWN_SERVER */
block|{
ifdef|#
directive|ifdef
name|START_RSH_WITH_POPEN_RW
if|if
condition|(
name|pclose
argument_list|(
name|to_server_fp
argument_list|)
operator|==
name|EOF
condition|)
else|#
directive|else
comment|/* ! START_RSH_WITH_POPEN_RW */
if|if
condition|(
name|fclose
argument_list|(
name|to_server_fp
argument_list|)
operator|==
name|EOF
condition|)
endif|#
directive|endif
comment|/* START_RSH_WITH_POPEN_RW */
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing connection to %s"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|from_server
argument_list|)
operator|||
name|getc
argument_list|(
name|from_server_fp
argument_list|)
operator|!=
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dying gasps from %s unexpected"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|from_server_fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"reading from %s"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|from_server_fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHUTDOWN_SERVER */
block|}
if|if
condition|(
name|rsh_pid
operator|!=
operator|-
literal|1
operator|&&
name|waitpid
argument_list|(
name|rsh_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for process %d"
argument_list|,
name|rsh_pid
argument_list|)
expr_stmt|;
name|server_started
operator|=
literal|0
expr_stmt|;
comment|/* see if we need to sleep before returning */
if|if
condition|(
name|last_register_time
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|last_register_time
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* to avoid time-stamp races */
block|}
return|return
name|errs
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXT_METHOD
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|start_rsh_server
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|supported_request
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
condition|;
name|rq
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rq
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|rq
operator|->
name|status
operator|==
name|rq_supported
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: testing support for unknown option?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|hostent
modifier|*
name|init_sockaddr
name|PROTO
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|init_sockaddr
parameter_list|(
name|name
parameter_list|,
name|hostname
parameter_list|,
name|port
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|unsigned
name|int
name|port
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hostinfo
decl_stmt|;
name|unsigned
name|short
name|shortport
init|=
name|port
decl_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|name
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|shortport
argument_list|)
expr_stmt|;
name|hostinfo
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostinfo
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown host %s.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
name|name
operator|->
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hostinfo
operator|->
name|h_addr
expr_stmt|;
return|return
name|hostinfo
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (AUTH_CLIENT_SUPPORT) || defined (HAVE_KERBEROS) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|auth_server_port_number
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|auth_server_port_number
parameter_list|()
block|{
name|struct
name|servent
modifier|*
name|s
init|=
name|getservbyname
argument_list|(
literal|"cvspserver"
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|ntohs
argument_list|(
name|s
operator|->
name|s_port
argument_list|)
return|;
else|else
return|return
name|CVS_AUTH_PORT
return|;
block|}
end_function

begin_comment
comment|/* Read a line from socket SOCK.  Result does not include the    terminating linefeed.  This is only used by the authentication    protocol, which we call before we set up all the buffering stuff.    It is possible it should use the buffers too, which would be faster    (unlike the server, there isn't really a security issue in terms of    separating authentication from the rest of the code).     Space for the result is malloc'd and should be freed by the caller.     Returns number of bytes read.  */
end_comment

begin_function
specifier|static
name|int
name|recv_line
parameter_list|(
name|sock
parameter_list|,
name|resultp
parameter_list|)
name|int
name|sock
decl_stmt|;
name|char
modifier|*
modifier|*
name|resultp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|input_index
init|=
literal|0
decl_stmt|;
name|size_t
name|result_size
init|=
literal|80
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|recv
argument_list|(
name|sock
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"recv() from server %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* It's end of file.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of file from server"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\012'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|+
literal|1
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resultp
condition|)
operator|*
name|resultp
operator|=
name|result
expr_stmt|;
comment|/* Terminate it just for kicks, but we *can* deal with embedded NULs.  */
name|result
index|[
name|input_index
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|resultp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|input_index
return|;
block|}
end_function

begin_comment
comment|/* Connect to the authenticating server.     If VERIFY_ONLY is non-zero, then just verify that the password is    correct and then shutdown the connection.     If VERIFY_ONLY is 0, then really connect to the server.     If DO_GSSAPI is non-zero, then we use GSSAPI authentication rather    than the pserver password authentication.     If we fail to connect or if access is denied, then die with fatal    error.  */
end_comment

begin_function
name|void
name|connect_to_pserver
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|,
name|verify_only
parameter_list|,
name|do_gssapi
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|verify_only
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_gssapi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sock
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SOCKET_TO_FD
name|int
name|tofd
decl_stmt|,
name|fromfd
decl_stmt|;
endif|#
directive|endif
name|int
name|port_number
decl_stmt|;
name|struct
name|sockaddr_in
name|client_sai
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hostinfo
decl_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create socket: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|port_number
operator|=
name|auth_server_port_number
argument_list|()
expr_stmt|;
name|hostinfo
operator|=
name|init_sockaddr
argument_list|(
operator|&
name|client_sai
argument_list|,
name|CVSroot_hostname
argument_list|,
name|port_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_sai
argument_list|,
sizeof|sizeof
argument_list|(
name|client_sai
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"connect to %s:%d failed: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|port_number
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the authorization mini-protocol before anything else. */
if|if
condition|(
name|do_gssapi
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
if|if
condition|(
operator|!
name|connect_to_gserver
argument_list|(
name|sock
argument_list|,
name|hostinfo
argument_list|)
condition|)
goto|goto
name|rejected
goto|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This client does not support GSSAPI authentication"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|char
modifier|*
name|begin
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|repository
init|=
name|CVSroot_directory
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|CVSroot_username
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|verify_only
condition|)
block|{
name|begin
operator|=
literal|"BEGIN VERIFICATION REQUEST\012"
expr_stmt|;
name|end
operator|=
literal|"END VERIFICATION REQUEST\012"
expr_stmt|;
block|}
else|else
block|{
name|begin
operator|=
literal|"BEGIN AUTH REQUEST\012"
expr_stmt|;
name|end
operator|=
literal|"END AUTH REQUEST\012"
expr_stmt|;
block|}
comment|/* Get the password, probably from ~/.cvspass. */
name|password
operator|=
name|get_cvs_password
argument_list|()
expr_stmt|;
comment|/* Announce that we're starting the authorization protocol. */
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|begin
argument_list|,
name|strlen
argument_list|(
name|begin
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send the data the server needs. */
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|repository
argument_list|,
name|strlen
argument_list|(
name|repository
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
literal|"\012"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|username
argument_list|,
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
literal|"\012"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|password
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
literal|"\012"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Announce that we're ending the authorization protocol. */
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|end
argument_list|,
name|strlen
argument_list|(
name|end
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoia. */
name|memset
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|read_buf
decl_stmt|;
comment|/* Loop, getting responses from the server.  */
while|while
condition|(
literal|1
condition|)
block|{
name|recv_line
argument_list|(
name|sock
argument_list|,
operator|&
name|read_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|read_buf
argument_list|,
literal|"I HATE YOU"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Authorization not granted. */
goto|goto
name|rejected
goto|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|read_buf
argument_list|,
literal|"E "
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|read_buf
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Continue with the authentication protocol.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|read_buf
argument_list|,
literal|"error "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First skip the code.  */
name|p
operator|=
name|read_buf
operator|+
literal|6
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Skip the space that follows the code.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Now output the text.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|rejected
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|read_buf
argument_list|,
literal|"I LOVE YOU"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|read_buf
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Unrecognized response from server. */
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unrecognized auth response from %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"shutdown() failed, server %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized auth response from %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|read_buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verify_only
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"shutdown() failed, server %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
name|use_socket_style
operator|=
literal|1
expr_stmt|;
name|server_sock
operator|=
name|sock
expr_stmt|;
comment|/* Try to break mistaken callers: */
operator|*
name|tofdp
operator|=
literal|0
expr_stmt|;
operator|*
name|fromfdp
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! NO_SOCKET_TO_FD */
name|server_fd
operator|=
name|sock
expr_stmt|;
name|close_on_exec
argument_list|(
name|server_fd
argument_list|)
expr_stmt|;
name|tofd
operator|=
name|fromfd
operator|=
name|sock
expr_stmt|;
comment|/* Hand them back to the caller. */
operator|*
name|tofdp
operator|=
name|tofd
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|fromfd
expr_stmt|;
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|}
return|return;
name|rejected
label|:
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"authorization failed: server %s rejected access"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"shutdown() failed (server %s): %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"authorization failed: server %s rejected access"
argument_list|,
name|CVSroot_hostname
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_KERBEROS
end_if

begin_comment
comment|/* This function has not been changed to deal with NO_SOCKET_TO_FD    (i.e., systems on which sockets cannot be converted to file    descriptors).  The first person to try building a kerberos client    on such a system (OS/2, Windows 95, and maybe others) will have to    make take care of this.  */
end_comment

begin_function
name|void
name|start_tcp_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|portenv
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create socket: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get CVS_CLIENT_PORT or look up cvs/tcp with CVS_PORT as default */
name|portenv
operator|=
name|getenv
argument_list|(
literal|"CVS_CLIENT_PORT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|portenv
operator|!=
name|NULL
condition|)
block|{
name|port
operator|=
name|atoi
argument_list|(
name|portenv
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS_CLIENT_PORT must be a positive number!  If you"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"are trying to force a connection via rsh, please"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"put \":server:\" at the beginning of your CVSROOT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"variable."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using TCP port %d to contact server.\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"cvs"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|port
operator|=
name|CVS_PORT
expr_stmt|;
else|else
name|port
operator|=
name|ntohs
argument_list|(
name|sp
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
name|init_sockaddr
argument_list|(
operator|&
name|sin
argument_list|,
name|CVSroot_hostname
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|hname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"connect to %s:%d failed: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|port
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
block|{
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
name|int
name|laddrlen
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|MSG_DAT
name|msg_data
decl_stmt|;
name|CREDENTIALS
name|cred
decl_stmt|;
name|int
name|status
decl_stmt|;
name|realm
operator|=
name|krb_realmofhost
argument_list|(
name|hname
argument_list|)
expr_stmt|;
name|laddrlen
operator|=
sizeof|sizeof
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|laddr
argument_list|,
operator|&
name|laddrlen
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"getsockname failed: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't care about the checksum, and pass it as zero.  */
name|status
operator|=
name|krb_sendauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|s
argument_list|,
operator|&
name|ticket
argument_list|,
literal|"rcmd"
argument_list|,
name|hname
argument_list|,
name|realm
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|,
operator|&
name|msg_data
argument_list|,
operator|&
name|cred
argument_list|,
name|sched
argument_list|,
operator|&
name|laddr
argument_list|,
operator|&
name|sin
argument_list|,
literal|"KCVSV1.0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"kerberos authentication failed: %s"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kblock
argument_list|,
name|cred
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
name|server_fd
operator|=
name|s
expr_stmt|;
name|close_on_exec
argument_list|(
name|server_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hname
argument_list|)
expr_stmt|;
comment|/* Give caller the values it wants. */
operator|*
name|tofdp
operator|=
name|s
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_comment
comment|/* Receive a given number of bytes.  */
end_comment

begin_function
specifier|static
name|void
name|recv_bytes
parameter_list|(
name|sock
parameter_list|,
name|buf
parameter_list|,
name|need
parameter_list|)
name|int
name|sock
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|need
decl_stmt|;
block|{
while|while
condition|(
name|need
operator|>
literal|0
condition|)
block|{
name|int
name|got
decl_stmt|;
name|got
operator|=
name|recv
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
name|need
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"recv() from server %s: %s"
argument_list|,
name|CVSroot_hostname
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|got
expr_stmt|;
name|need
operator|-=
name|got
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Connect to the server using GSSAPI authentication.  */
end_comment

begin_function
specifier|static
name|int
name|connect_to_gserver
parameter_list|(
name|sock
parameter_list|,
name|hostinfo
parameter_list|)
name|int
name|sock
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hostinfo
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|gss_buffer_desc
modifier|*
name|tok_in_ptr
decl_stmt|,
name|tok_in
decl_stmt|,
name|tok_out
decl_stmt|;
name|OM_uint32
name|stat_min
decl_stmt|,
name|stat_maj
decl_stmt|;
name|gss_name_t
name|server_name
decl_stmt|;
name|str
operator|=
literal|"BEGIN GSSAPI REQUEST\012"
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cvs@%s"
argument_list|,
name|hostinfo
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|tok_in
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tok_in
operator|.
name|value
operator|=
name|buf
expr_stmt|;
name|gss_import_name
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|tok_in
argument_list|,
name|gss_nt_service_name
argument_list|,
operator|&
name|server_name
argument_list|)
expr_stmt|;
name|tok_in_ptr
operator|=
name|GSS_C_NO_BUFFER
expr_stmt|;
name|gcontext
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
do|do
block|{
name|stat_maj
operator|=
name|gss_init_sec_context
argument_list|(
operator|&
name|stat_min
argument_list|,
name|GSS_C_NO_CREDENTIAL
argument_list|,
operator|&
name|gcontext
argument_list|,
name|server_name
argument_list|,
name|GSS_C_NULL_OID
argument_list|,
operator|(
name|GSS_C_MUTUAL_FLAG
operator||
name|GSS_C_REPLAY_FLAG
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|tok_in_ptr
argument_list|,
name|NULL
argument_list|,
operator|&
name|tok_out
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_maj
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|stat_maj
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|OM_uint32
name|message_context
decl_stmt|;
name|message_context
operator|=
literal|0
expr_stmt|;
name|gss_display_status
argument_list|(
operator|&
name|stat_min
argument_list|,
name|stat_maj
argument_list|,
name|GSS_C_GSS_CODE
argument_list|,
name|GSS_C_NULL_OID
argument_list|,
operator|&
name|message_context
argument_list|,
operator|&
name|tok_out
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"GSSAPI authentication failed: %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tok_out
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tok_out
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|tok_in
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|need
decl_stmt|;
name|cbuf
index|[
literal|0
index|]
operator|=
operator|(
name|tok_out
operator|.
name|length
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cbuf
index|[
literal|1
index|]
operator|=
name|tok_out
operator|.
name|length
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|cbuf
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sock
argument_list|,
name|tok_out
operator|.
name|value
argument_list|,
name|tok_out
operator|.
name|length
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot send: %s"
argument_list|,
name|SOCK_STRERROR
argument_list|(
name|SOCK_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
name|recv_bytes
argument_list|(
name|sock
argument_list|,
name|cbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|need
operator|=
operator|(
operator|(
name|cbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|cbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need
operator|<=
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|recv_bytes
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|tok_in
operator|.
name|length
operator|=
name|need
expr_stmt|;
block|}
name|tok_in
operator|.
name|value
operator|=
name|buf
expr_stmt|;
name|tok_in_ptr
operator|=
operator|&
name|tok_in
expr_stmt|;
block|}
do|while
condition|(
name|stat_maj
operator|==
name|GSS_S_CONTINUE_NEEDED
condition|)
do|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|send_variable_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send_variable_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|send_to_server
argument_list|(
literal|"Set "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"="
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|node
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Contact the server.  */
end_comment

begin_function
name|void
name|start_server
parameter_list|()
block|{
name|int
name|tofd
decl_stmt|,
name|fromfd
decl_stmt|;
name|char
modifier|*
name|log
init|=
name|getenv
argument_list|(
literal|"CVS_CLIENT_LOG"
argument_list|)
decl_stmt|;
comment|/* Note that generally speaking we do *not* fall back to a different        way of connecting if the first one does not work.  This is slow        (*really* slow on a 14.4kbps link); the clean way to have a CVS        which supports several ways of connecting is with access methods.  */
switch|switch
condition|(
name|CVSroot_method
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
case|case
name|pserver_method
case|:
comment|/* Toss the return value.  It will die with error if anything 	       goes wrong anyway. */
name|connect_to_pserver
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|HAVE_KERBEROS
case|case
name|kserver_method
case|:
name|start_tcp_server
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|HAVE_GSSAPI
case|case
name|gserver_method
case|:
comment|/* GSSAPI authentication is handled by the pserver.  */
name|connect_to_pserver
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ext_method
case|:
if|#
directive|if
name|defined
argument_list|(
name|NO_EXT_METHOD
argument_list|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|":ext: method not supported by this port of CVS"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"try :server: instead"
argument_list|)
expr_stmt|;
else|#
directive|else
name|start_rsh_server
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|server_method
case|:
if|#
directive|if
name|defined
argument_list|(
name|START_SERVER
argument_list|)
name|START_SERVER
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|CVSroot_username
argument_list|,
name|CVSroot_hostname
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|START_SERVER_RETURNS_SOCKET
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_SOCKET_TO_FD
argument_list|)
comment|/* This is a system on which we can only write to a socket 	       using send/recv.  Therefore its START_SERVER needs to 	       return a socket.  */
name|use_socket_style
operator|=
literal|1
expr_stmt|;
name|server_sock
operator|=
name|tofd
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* FIXME: It should be possible to implement this portably, 	       like pserver, which would get rid of the duplicated code 	       in {vms,windows-NT,...}/startserver.c.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ the :server: access method is not supported by this port of CVS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ (start_server internal error): unknown access method"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* "Hi, I'm Darlene and I'll be your server tonight..." */
name|server_started
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
name|to_server
operator|=
name|socket_buffer_initialize
argument_list|(
name|server_sock
argument_list|,
literal|0
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|socket_buffer_initialize
argument_list|(
name|server_sock
argument_list|,
literal|1
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
comment|/* todo: some OS's don't need these calls... */
name|close_on_exec
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|close_on_exec
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
comment|/* SCO 3 and AIX have a nasty bug in the I/O libraries which precludes 	   fdopening the same file descriptor twice, so dup it if it is the 	   same.  */
if|if
condition|(
name|tofd
operator|==
name|fromfd
condition|)
block|{
name|fromfd
operator|=
name|dup
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromfd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup net connection"
argument_list|)
expr_stmt|;
block|}
comment|/* These will use binary mode on systems which have it.  */
name|to_server_fp
operator|=
name|fdopen
argument_list|(
name|tofd
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_server_fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fdopen %d for write"
argument_list|,
name|tofd
argument_list|)
expr_stmt|;
name|to_server
operator|=
name|stdio_buffer_initialize
argument_list|(
name|to_server_fp
argument_list|,
literal|0
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|from_server_fp
operator|=
name|fdopen
argument_list|(
name|fromfd
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_server_fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fdopen %d for read"
argument_list|,
name|fromfd
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|stdio_buffer_initialize
argument_list|(
name|from_server_fp
argument_list|,
literal|1
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up logfiles, if any. */
if|if
condition|(
name|log
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|log
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|len
expr_stmt|;
comment|/* Open logfiles in binary mode so that they reflect 	   exactly what was transmitted and received (that is 	   more important than that they be maximally 	   convenient to view).  */
comment|/* Note that if we create several connections in a single CVS client 	   (currently used by update.c), then the last set of logfiles will 	   overwrite the others.  There is currently no way around this.  */
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".in"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|buf
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"opening to-server logfile %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|to_server
operator|=
name|log_buffer_initialize
argument_list|(
name|to_server
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".out"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|buf
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"opening from-server logfile %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|from_server
operator|=
name|log_buffer_initialize
argument_list|(
name|from_server
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Clear static variables.  */
if|if
condition|(
name|toplevel_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|toplevel_repos
argument_list|)
expr_stmt|;
name|toplevel_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_dir_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_dir_name
argument_list|)
expr_stmt|;
name|last_dir_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|NULL
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
name|stored_mode_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Root "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|CVSroot_directory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Valid-responses"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
name|send_to_server
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|rs
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"valid-requests\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_server_responses
argument_list|()
condition|)
name|error_exit
argument_list|()
expr_stmt|;
comment|/*      * Now handle global options.      *      * -H, -f, -d, -e should be handled OK locally.      *      * -b we ignore (treating it as a server installation issue).      * FIXME: should be an error message.      *      * -v we print local version info; FIXME: Add a protocol request to get      * the version from the server so we can print that too.      *      * -l -t -r -w -q -n and -Q need to go to the server.      */
block|{
name|int
name|have_global
init|=
name|supported_request
argument_list|(
literal|"Global_option"
argument_list|)
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -n\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -n option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quiet
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -q\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -q option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_quiet
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -Q\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -Q option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cvswrite
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -r\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -r option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -t\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -t option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logoff
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -l\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -l option."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find out about server-side cvswrappers.  An extra network        turnaround for cvs import seems to be unavoidable, unless we        want to add some kind of client-side place to configure which        filenames imply binary.  For cvs add, we could avoid the        problem by keeping a copy of the wrappers in CVSADM (the main        reason to bother would be so we could make add work without        contacting the server, I suspect).  */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"import"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"wrapper-sendme-rcsOptions"
argument_list|)
condition|)
block|{
name|int
name|err
decl_stmt|;
name|send_to_server
argument_list|(
literal|"wrapper-sendme-rcsOptions\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_server_responses
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|err
argument_list|,
literal|0
argument_list|,
literal|"error reading from server"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cvsencrypt
condition|)
block|{
ifdef|#
directive|ifdef
name|ENCRYPTION
comment|/* Turn on encryption before turning on compression.  We do            not want to try to compress the encrypted stream.  Instead,            we want to encrypt the compressed stream.  If we can't turn            on encryption, bomb out; don't let the user think the data            is being encrypted when it is not.  */
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
if|if
condition|(
name|CVSroot_method
operator|==
name|kserver_method
condition|)
block|{
if|if
condition|(
operator|!
name|supported_request
argument_list|(
literal|"Kerberos-encrypt"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support encryption"
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Kerberos-encrypt\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to_server
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|to_server
argument_list|,
literal|0
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|from_server
argument_list|,
literal|1
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
if|if
condition|(
name|CVSroot_method
operator|==
name|gserver_method
condition|)
block|{
if|if
condition|(
operator|!
name|supported_request
argument_list|(
literal|"Gssapi-encrypt"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support encryption"
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Gssapi-encrypt\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to_server
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|to_server
argument_list|,
literal|0
argument_list|,
name|gcontext
argument_list|,
operator|(
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|from_server
argument_list|,
literal|1
argument_list|,
name|gcontext
argument_list|,
operator|(
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|cvs_gssapi_encrypt
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_GSSAPI */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Encryption is only supported when using GSSAPI or Kerberos"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! ENCRYPTION */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This client does not support encryption"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! ENCRYPTION */
block|}
if|if
condition|(
name|gzip_level
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"Gzip-stream"
argument_list|)
condition|)
block|{
name|char
name|gzip_level_buf
index|[
literal|5
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Gzip-stream "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|gzip_level_buf
argument_list|,
literal|"%d"
argument_list|,
name|gzip_level
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|gzip_level_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All further communication with the server will be                compressed.  */
name|to_server
operator|=
name|compress_buffer_initialize
argument_list|(
name|to_server
argument_list|,
literal|0
argument_list|,
name|gzip_level
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|compress_buffer_initialize
argument_list|(
name|from_server
argument_list|,
literal|1
argument_list|,
name|gzip_level
argument_list|,
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CLIENT_GZIP_PROCESS
elseif|else
if|if
condition|(
name|supported_request
argument_list|(
literal|"gzip-file-contents"
argument_list|)
condition|)
block|{
name|char
name|gzip_level_buf
index|[
literal|5
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"gzip-file-contents "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|gzip_level_buf
argument_list|,
literal|"%d"
argument_list|,
name|gzip_level
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|gzip_level_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|file_gzip_level
operator|=
name|gzip_level
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server doesn't support gzip-file-contents\n"
argument_list|)
expr_stmt|;
comment|/* Setting gzip_level to 0 prevents us from giving the                error twice if update has to contact the server again                to fetch unpatchable files.  */
name|gzip_level
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cvsauthenticate
operator|&&
operator|!
name|cvsencrypt
condition|)
block|{
comment|/* Turn on authentication after turning on compression, so 	   that we can compress the authentication information.  We 	   assume that encrypted data is always authenticated--the 	   ability to decrypt the data stream is itself a form of 	   authentication.  */
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
if|if
condition|(
name|CVSroot_method
operator|==
name|gserver_method
condition|)
block|{
if|if
condition|(
operator|!
name|supported_request
argument_list|(
literal|"Gssapi-authenticate"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support stream authentication"
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Gssapi-authenticate\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|to_server
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|to_server
argument_list|,
literal|0
argument_list|,
name|gcontext
argument_list|,
operator|(
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|from_server
argument_list|,
literal|1
argument_list|,
name|gcontext
argument_list|,
operator|(
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Stream authentication is only supported when using GSSAPI"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_GSSAPI */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This client does not support stream authentication"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_GSSAPI */
block|}
ifdef|#
directive|ifdef
name|FILENAMES_CASE_INSENSITIVE
if|if
condition|(
name|supported_request
argument_list|(
literal|"Case"
argument_list|)
condition|)
name|send_to_server
argument_list|(
literal|"Case\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If "Set" is not supported, just silently fail to send the variables.        Users with an old server should get a useful error message when it        fails to recognize the ${=foo} syntax.  This way if someone uses        several servers, some of which are new and some old, they can still        set user variables in their .cvsrc without trouble.  */
if|if
condition|(
name|supported_request
argument_list|(
literal|"Set"
argument_list|)
condition|)
name|walklist
argument_list|(
name|variable_list
argument_list|,
name|send_variable_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXT_METHOD
end_ifndef

begin_comment
comment|/* Contact the server by starting it with rsh.  */
end_comment

begin_comment
comment|/* Right now, we have two different definitions for this function,    depending on whether we start the rsh server using popenRW or not.    This isn't ideal, and the best thing would probably be to change    the OS/2 port to be more like the regular Unix client (i.e., by    implementing piped_child)... but I'm doing something else at the    moment, and wish to make only one change at a time.  -Karl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|START_RSH_WITH_POPEN_RW
end_ifdef

begin_comment
comment|/* This is actually a crock -- it's OS/2-specific, for no one else    uses it.  If I get time, I want to make piped_child and all the    other stuff in os2/run.c work right.  In the meantime, this gets us    up and running, and that's most important. */
end_comment

begin_function
specifier|static
name|void
name|start_rsh_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
comment|/* If you're working through firewalls, you can set the        CVS_RSH environment variable to a script which uses rsh to        invoke another rsh on a proxy machine.  */
name|char
modifier|*
name|cvs_rsh
init|=
name|getenv
argument_list|(
literal|"CVS_RSH"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cvs_server
init|=
name|getenv
argument_list|(
literal|"CVS_SERVER"
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* This needs to fit "rsh", "-b", "-l", "USER", "host",        "cmd (w/ args)", and NULL.  We leave some room to grow. */
name|char
modifier|*
name|rsh_argv
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cvs_rsh
condition|)
comment|/* People sometimes suggest or assume that this should default 	   to "remsh" on systems like HPUX in which that is the 	   system-supplied name for the rsh program.  However, that 	   causes various problems (keep in mind that systems such as 	   HPUX might have non-system-supplied versions of "rsh", like 	   a Kerberized one, which one might want to use).  If we 	   based the name on what is found in the PATH of the person 	   who runs configure, that would make it harder to 	   consistently produce the same result in the face of 	   different people producing binary distributions.  If we 	   based it on "remsh" always being the default for HPUX 	   (e.g. based on uname), that might be slightly better but 	   would require us to keep track of what the defaults are for 	   each system type, and probably would cope poorly if the 	   existence of remsh or rsh varies from OS version to OS 	   version.  Therefore, it seems best to have the default 	   remain "rsh", and tell HPUX users to specify remsh, for 	   example in CVS_RSH or other such mechanisms to be devised, 	   if that is what they want (the manual already tells them 	   that).  */
name|cvs_rsh
operator|=
literal|"rsh"
expr_stmt|;
if|if
condition|(
operator|!
name|cvs_server
condition|)
name|cvs_server
operator|=
literal|"cvs"
expr_stmt|;
comment|/* The command line starts out with rsh. */
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|cvs_rsh
expr_stmt|;
ifdef|#
directive|ifdef
name|RSH_NEEDS_BINARY_FLAG
comment|/* "-b" for binary, under OS/2. */
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-b"
expr_stmt|;
endif|#
directive|endif
comment|/* RSH_NEEDS_BINARY_FLAG */
comment|/* Then we strcat more things on the end one by one. */
if|if
condition|(
name|CVSroot_username
operator|!=
name|NULL
condition|)
block|{
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|CVSroot_username
expr_stmt|;
block|}
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|CVSroot_hostname
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|cvs_server
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"server"
expr_stmt|;
comment|/* Mark the end of the arg list. */
name|rsh_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> Starting server: "
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Do the deed. */
name|rsh_pid
operator|=
name|popenRW
argument_list|(
name|rsh_argv
argument_list|,
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsh_pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot start server via rsh"
argument_list|)
expr_stmt|;
comment|/* Give caller the file descriptors. */
operator|*
name|tofdp
operator|=
name|pipes
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|pipes
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! START_RSH_WITH_POPEN_RW */
end_comment

begin_function
specifier|static
name|void
name|start_rsh_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|;
name|int
modifier|*
name|fromfdp
decl_stmt|;
block|{
comment|/* If you're working through firewalls, you can set the        CVS_RSH environment variable to a script which uses rsh to        invoke another rsh on a proxy machine.  */
name|char
modifier|*
name|cvs_rsh
init|=
name|getenv
argument_list|(
literal|"CVS_RSH"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cvs_server
init|=
name|getenv
argument_list|(
literal|"CVS_SERVER"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
if|if
condition|(
operator|!
name|cvs_rsh
condition|)
name|cvs_rsh
operator|=
literal|"rsh"
expr_stmt|;
if|if
condition|(
operator|!
name|cvs_server
condition|)
name|cvs_server
operator|=
literal|"cvs"
expr_stmt|;
comment|/* Pass the command to rsh as a single string.  This shouldn't        affect most rsh servers at all, and will pacify some buggy        versions of rsh that grab switches out of the middle of the        command (they're calling the GNU getopt routines incorrectly).  */
name|command
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cvs_server
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
comment|/* If you are running a very old (Nov 3, 1994, before 1.5)      * version of the server, you need to make sure that your .bashrc      * on the server machine does not set CVSROOT to something      * containing a colon (or better yet, upgrade the server).  */
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s server"
argument_list|,
name|cvs_server
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|argv
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|argv
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|cvs_rsh
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|CVSroot_hostname
expr_stmt|;
comment|/* If the login names differ between client and server 	 * pass it on to rsh. 	 */
if|if
condition|(
name|CVSroot_username
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|"-l"
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|CVSroot_username
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|command
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> Starting server: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|rsh_pid
operator|=
name|piped_child
argument_list|(
name|argv
argument_list|,
name|tofdp
argument_list|,
name|fromfdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsh_pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot start server via rsh"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* START_RSH_WITH_POPEN_RW */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_EXT_METHOD */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Send an argument STRING.  */
end_comment

begin_function
name|void
name|send_arg
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|send_to_server
argument_list|(
literal|"\012Argumentx "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|send_modified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Vers_TS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VERS->OPTIONS specifies whether the file is binary or not.  NOTE: BEFORE    using any other fields of the struct vers, we would need to fix    client_process_import_file to set them up.  */
end_comment

begin_function
specifier|static
name|void
name|send_modified
parameter_list|(
name|file
parameter_list|,
name|short_pathname
parameter_list|,
name|vers
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
comment|/* File was modified, send it.  */
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|bin
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> Sending file `%s' to server\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Don't think we can assume fstat exists.  */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* Beware: on systems using CRLF line termination conventions,        the read and write functions will convert CRLF to LF, so the        number of characters read is not the same as sb.st_size.  Text        files should always be transmitted using the LF convention, so        we don't want to disable this conversion.  */
name|bufsize
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Is the file marked as containing binary data by the "-kb" flag?        If so, make sure to open it in binary mode: */
if|if
condition|(
name|vers
operator|&&
name|vers
operator|->
name|options
condition|)
name|bin
operator|=
operator|!
operator|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|)
expr_stmt|;
else|else
name|bin
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_READWRITE_CONVERSION
if|if
condition|(
operator|!
name|bin
condition|)
block|{
comment|/* If only stdio, not open/write/etc., do text/binary 	   conversion, use convert_file which can compensate 	   (FIXME: we could just use stdio instead which would 	   avoid the whole problem).  */
name|char
name|tfile
index|[
literal|1024
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tfile
argument_list|,
literal|".CVSBFCTMP"
argument_list|)
expr_stmt|;
name|convert_file
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|,
name|tfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|OPEN_BINARY
argument_list|)
expr_stmt|;
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|tfile
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
expr_stmt|;
else|#
directive|else
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
operator|(
name|bin
condition|?
name|OPEN_BINARY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_gzip_level
operator|&&
name|sb
operator|.
name|st_size
operator|>
literal|100
condition|)
block|{
name|size_t
name|newsize
init|=
literal|0
decl_stmt|;
name|read_and_gzip
argument_list|(
name|fd
argument_list|,
name|short_pathname
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|newsize
argument_list|,
name|file_gzip_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't close %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Modified "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|mode_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012z"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newsize
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|newsize
decl_stmt|;
block|{
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* FIXME: This is gross.  It assumes that we might read 	       less than st_size bytes (true on NT), but not more. 	       Instead of this we should just be reading a block of 	       data (e.g. 8192 bytes), writing it to the network, and 	       so on until EOF.  */
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bufp
argument_list|,
operator|(
name|buf
operator|+
name|sb
operator|.
name|st_size
operator|)
operator|-
name|bufp
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|bufp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|bufp
operator|-
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't close %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Modified "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|mode_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu\012"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newsize
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BROKEN_READWRITE_CONVERSION
if|if
condition|(
operator|!
name|bin
condition|)
block|{
name|char
name|tfile
index|[
literal|1024
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tfile
argument_list|,
literal|".CVSBFCTMP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't remove temp file %s"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Note that this only ends with a newline if the file ended with 	 * one. 	 */
if|if
condition|(
name|newsize
operator|>
literal|0
condition|)
name|send_to_server
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The address of an instance of this structure is passed to    send_fileproc, send_filesdoneproc, and send_direntproc, as the    callerdat parameter.  */
end_comment

begin_struct
struct|struct
name|send_data
block|{
comment|/* Each of the following flags are zero for clear or nonzero for set.  */
name|int
name|build_dirs
decl_stmt|;
name|int
name|force
decl_stmt|;
name|int
name|no_contents
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|send_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Deal with one file.  */
end_comment

begin_function
specifier|static
name|int
name|send_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|struct
name|send_data
modifier|*
name|args
init|=
operator|(
expr|struct
name|send_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|file_info
name|xfinfo
decl_stmt|;
comment|/* File name to actually use.  Might differ in case from        finfo->file.  */
name|char
modifier|*
name|filename
decl_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|xfinfo
operator|=
operator|*
name|finfo
expr_stmt|;
name|xfinfo
operator|.
name|repository
operator|=
name|NULL
expr_stmt|;
name|xfinfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|xfinfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
condition|)
name|filename
operator|=
name|vers
operator|->
name|entdata
operator|->
name|user
expr_stmt|;
else|else
name|filename
operator|=
name|finfo
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
block|{
comment|/* The Entries request.  */
name|send_to_server
argument_list|(
literal|"Entry /"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_conflict
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|vers
operator|->
name|ts_user
argument_list|)
operator|==
literal|0
condition|)
name|send_to_server
argument_list|(
literal|"+="
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|send_to_server
argument_list|(
literal|"+modified"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
condition|?
name|vers
operator|->
name|entdata
operator|->
name|options
else|:
name|vers
operator|->
name|options
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|entdata
operator|->
name|tag
condition|)
block|{
name|send_to_server
argument_list|(
literal|"T"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|entdata
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|entdata
operator|->
name|date
condition|)
block|{
name|send_to_server
argument_list|(
literal|"D"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|entdata
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It seems a little silly to re-read this on each file, but 	   send_dirent_proc doesn't get called if filenames are specified 	   explicitly on the command line.  */
name|wrap_add_file
argument_list|(
name|CVSDOTWRAPPER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_name_has
argument_list|(
name|filename
argument_list|,
name|WRAP_RCSOPTION
argument_list|)
condition|)
block|{
comment|/* No "Entry", but the wrappers did give us a kopt so we better 	       send it with "Kopt".  As far as I know this only happens 	       for "cvs add".  Question: is there any reason why checking 	       for options from wrappers isn't done in Version_TS?  	       Note: it might have been better to just remember all the 	       kopts on the client side, rather than send them to the server, 	       and have it send us back the same kopts.  But that seemed like 	       a bigger change than I had in mind making now.  */
if|if
condition|(
name|supported_request
argument_list|(
literal|"Kopt"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|opt
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Kopt "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opt
operator|=
name|wrap_rcsoption
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|opt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|opt
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: ignoring -k options due to server limitations"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Do we want to print "file was lost" like normal CVS? 	 * Would it always be appropriate? 	 */
comment|/* File no longer exists.  Don't do anything, missing files 	   just happen.  */
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_rcs
operator|==
name|NULL
operator|||
name|args
operator|->
name|force
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|no_contents
operator|&&
name|supported_request
argument_list|(
literal|"Is-modified"
argument_list|)
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Is-modified "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|send_modified
argument_list|(
name|filename
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_to_server
argument_list|(
literal|"Unchanged "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|send_ignproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_ignproc
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
if|if
condition|(
name|ign_inhibit_server
operator|||
operator|!
name|supported_request
argument_list|(
literal|"Questionable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"? %s/%s\n"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"? %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_to_server
argument_list|(
literal|"Questionable "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|send_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|,
name|send_ignproc
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Dtype
name|send_dirent_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * send_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  * A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  *  */
end_comment

begin_function
specifier|static
name|Dtype
name|send_dirent_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|struct
name|send_data
modifier|*
name|args
init|=
operator|(
expr|struct
name|send_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|int
name|dir_exists
decl_stmt|;
name|char
modifier|*
name|cvsadm_name
decl_stmt|;
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
comment|/*      * If the directory does not exist yet (e.g. "cvs update -d foo"),      * no need to send any files from it.  If the directory does not      * have a CVS directory, then we pretend that it does not exist.      * Otherwise, we will fail when trying to open the Entries file.      * This case will happen when checking out a module defined as      * ``-a .''.      */
name|cvsadm_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cvsadm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|dir_exists
operator|=
name|isdir
argument_list|(
name|cvsadm_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsadm_name
argument_list|)
expr_stmt|;
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * If there is an empty directory (e.g. we are doing `cvs add' on a      * newly-created directory), the server still needs to know about it.      */
if|if
condition|(
name|dir_exists
condition|)
block|{
comment|/* 	 * Get the repository from a CVS/Repository file whenever possible. 	 * The repository variable is wrong if the names in the local 	 * directory don't match the names in the repository. 	 */
name|char
modifier|*
name|repos
init|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
name|send_a_repository
argument_list|(
name|dir
argument_list|,
name|repos
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It doesn't make sense to send a non-existent directory, 	   because there is no way to get the correct value for 	   the repository (I suppose maybe via the expand-modules 	   request).  In the case where the "obvious" choice for 	   repository is correct, the server can figure out whether 	   to recreate the directory; in the case where it is wrong 	   (that is, does not match what modules give us), we might as 	   well just fail to recreate it.  	   Checking for noexec is a kludge for "cvs -n add dir".  */
comment|/* Don't send a non-existent directory unless we are building            new directories (build_dirs is true).  Otherwise, CVS may            see a D line in an Entries file, and recreate a directory            which the user removed by hand.  */
if|if
condition|(
name|args
operator|->
name|build_dirs
operator|&&
name|noexec
condition|)
name|send_a_repository
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dir_exists
condition|?
name|R_PROCESS
else|:
name|R_SKIP_ALL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send each option in a string to the server, one by one.  * This assumes that the options are separated by spaces, for example  * STRING might be "--foo -C5 -y".  */
end_comment

begin_function
name|void
name|send_option_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|copy
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|p
operator|=
name|copy
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|l
decl_stmt|;
for|for
control|(
name|s
operator|=
name|p
init|;
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|l
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|p
condition|)
name|send_arg
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send the names of all the argument files to the server.  */
end_comment

begin_function
name|void
name|send_file_names
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|max_level
decl_stmt|;
comment|/* The fact that we do this here as well as start_recursion is a bit         of a performance hit.  Perhaps worth cleaning up someday.  */
if|if
condition|(
name|flags
operator|&
name|SEND_EXPAND_WILD
condition|)
name|expand_wild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Send Max-dotdot if needed.  */
name|max_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|level
operator|=
name|pathname_levels
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
name|max_level
condition|)
name|max_level
operator|=
name|level
expr_stmt|;
block|}
if|if
condition|(
name|max_level
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"Max-dotdot"
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|max_level
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Max-dotdot "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 	     * "leading .." is not strictly correct, as this also includes 	     * cases like "foo/../..".  But trying to explain that in the 	     * error message would probably just confuse users. 	     */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"leading .. not supported by old (pre-Max-dotdot) servers"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|FILENAMES_CASE_INSENSITIVE
comment|/* We want to send the file name as it appears 	   in CVS/Entries.  We put this inside an ifdef 	   to avoid doing all these system calls in 	   cases where fncmp is just strcmp anyway.  */
comment|/* For now just do this for files in the local 	   directory.  Would be nice to handle the 	   non-local case too, though.  */
comment|/* The isdir check could more gracefully be replaced 	   with a way of having Entries_Open report back the 	   error to us and letting us ignore existence_error. 	   Or some such.  */
if|if
condition|(
name|p
operator|==
name|last_component
argument_list|(
name|p
argument_list|)
operator|&&
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
comment|/* If we were doing non-local directory, 	       we would save_cwd, CVS_CHDIR 	       like in update.c:isemptydir.  */
comment|/* Note that if we are adding a directory, 	       the following will read the entry 	       that we just wrote there, that is, we 	       will get the case specified on the 	       command line, not the case of the 	       directory in the filesystem.  This 	       is correct behavior.  */
name|entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|findnode_fn
argument_list|(
name|entries
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|line
operator|=
name|xstrdup
argument_list|(
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FILENAMES_CASE_INSENSITIVE */
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|send_to_server
argument_list|(
literal|"\012Argumentx "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIRSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SEND_EXPAND_WILD
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send Repository, Modified and Entry.  argc and argv contain only   the files to operate on (or empty for everything), not options.   local is nonzero if we should not recurse (-l option).  flags&   SEND_BUILD_DIRS is nonzero if nonexistent directories should be   sent.  flags& SEND_FORCE is nonzero if we should send unmodified   files to the server as though they were modified.  flags&   SEND_NO_CONTENTS means that this command only needs to know   _whether_ a file is modified, not the contents.  Also sends Argument   lines for argc and argv, so should be called after options are sent.  */
end_comment

begin_function
name|void
name|send_files
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|,
name|flags
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|send_data
name|args
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/*      * aflag controls whether the tag/date is copied into the vers_ts.      * But we don't actually use it, so I don't think it matters what we pass      * for aflag here.      */
name|args
operator|.
name|build_dirs
operator|=
name|flags
operator|&
name|SEND_BUILD_DIRS
expr_stmt|;
name|args
operator|.
name|force
operator|=
name|flags
operator|&
name|SEND_FORCE
expr_stmt|;
name|args
operator|.
name|no_contents
operator|=
name|flags
operator|&
name|SEND_NO_CONTENTS
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|send_fileproc
argument_list|,
name|send_filesdoneproc
argument_list|,
name|send_dirent_proc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* 	 * This happens if we are not processing any files, 	 * or for checkouts in directories without any existing stuff 	 * checked out.  The following assignment is correct for the 	 * latter case; I don't think toplevel_repos matters for the 	 * former. 	 */
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|send_repository
argument_list|(
literal|""
argument_list|,
name|toplevel_repos
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|client_import_setup
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* should always be true */
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the argument import file.  */
end_comment

begin_function
name|int
name|client_process_import_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|repository
parameter_list|,
name|all_files_binary
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|all_files_binary
decl_stmt|;
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
name|Vers_TS
name|vers
decl_stmt|;
name|assert
argument_list|(
name|toplevel_repos
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|repository
argument_list|,
name|toplevel_repos
argument_list|,
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: pathname `%s' doesn't specify file in `%s'"
argument_list|,
name|repository
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|repository
argument_list|,
name|toplevel_repos
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
operator|=
literal|""
expr_stmt|;
name|fullname
operator|=
name|xstrdup
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_dir
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fullname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|vfile
argument_list|)
operator|+
name|strlen
argument_list|(
name|update_dir
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
block|}
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_files_binary
condition|)
block|{
name|vers
operator|.
name|options
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* strlen("-kb") + 1 */
name|strcpy
argument_list|(
name|vers
operator|.
name|options
argument_list|,
literal|"-kb"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vers
operator|.
name|options
operator|=
name|wrap_rcsoption
argument_list|(
name|vfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|.
name|options
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"Kopt"
argument_list|)
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Kopt "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|.
name|options
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: ignoring -k options due to server limitations"
argument_list|)
expr_stmt|;
block|}
name|send_modified
argument_list|(
name|vfile
argument_list|,
name|fullname
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|.
name|options
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers
operator|.
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|client_import_done
parameter_list|()
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* 	 * This happens if we are not processing any files, 	 * or for checkouts in directories without any existing stuff 	 * checked out.  The following assignment is correct for the 	 * latter case; I don't think toplevel_repos matters for the 	 * former. 	 */
comment|/* FIXME: "can't happen" now that we call client_import_setup 	   at the beginning.  */
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|send_repository
argument_list|(
literal|""
argument_list|,
name|toplevel_repos
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|notified_a_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FILE
modifier|*
name|newf
decl_stmt|;
name|size_t
name|line_len
init|=
literal|8192
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|xmalloc
argument_list|(
name|line_len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|int
name|nwritten
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot read %s: end of file"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"malformed %s file"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|line
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: notified %s, expected %s"
argument_list|,
name|filename
argument_list|,
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|CVSADM_NOTIFY
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|newf
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFYTMP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|line
argument_list|,
name|newf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
while|while
condition|(
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|line_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|nwritten
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|newf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|nread
operator|-=
name|nwritten
expr_stmt|;
name|p
operator|+=
name|nwritten
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|newf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|newf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
comment|/* In this case, we want rename_file() to ignore noexec. */
name|int
name|saved_noexec
init|=
name|noexec
decl_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
name|rename_file
argument_list|(
name|CVSADM_NOTIFYTMP
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|saved_noexec
expr_stmt|;
block|}
return|return;
name|error2
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|newf
argument_list|)
expr_stmt|;
name|error_exit
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_notified
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|notified_a_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_notify
parameter_list|(
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|filename
parameter_list|,
name|notif_type
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|notif_type
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Notify "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|notif_type
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Send an option with an argument, dealing correctly with newlines in  * the argument.  If ARG is NULL, forget the whole thing.  */
end_comment

begin_function
name|void
name|option_with_arg
parameter_list|(
name|option
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a date to the server.  This will passed a string which is the  * result of Make_Date, and looks like YY.MM.DD.HH.MM.SS, where all  * the letters are single digits.  The time will be GMT.  getdate on  * the server can't parse that, so we turn it back into something  * which it can parse.  */
end_comment

begin_function
name|void
name|client_senddate
parameter_list|(
name|date
parameter_list|)
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"diff_client_senddate: sscanf failed on date"
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d/%d/%d %d:%d:%d GMT"
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-D"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|send_init_command
parameter_list|()
block|{
comment|/* This is here because we need the CVSroot_directory variable.  */
name|send_to_server
argument_list|(
literal|"init "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|CVSroot_directory
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

end_unit

