begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CVS client-related stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
operator|||
name|HAVE_KERBEROS
operator|||
name|USE_DIRECT_TCP
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No winsock.h */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No winsock.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(AUTH_CLIENT_SUPPORT) || HAVE_KERBEROS || USE_DIRECT_TCP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|get_cvs_password
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|,
name|char
operator|*
name|host
operator|,
name|char
operator|*
name|cvsrooot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|HAVE_KERBEROS
operator|||
name|USE_DIRECT_TCP
end_if

begin_define
define|#
directive|define
name|CVS_PORT
value|1999
end_define

begin_if
if|#
directive|if
name|HAVE_KERBEROS
end_if

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|krb_realmofhost
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KRB_GET_ERR_TEXT
end_ifndef

begin_define
define|#
directive|define
name|krb_get_err_text
parameter_list|(
name|status
parameter_list|)
value|krb_err_txt[status]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KRB_GET_ERR_TEXT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS || USE_DIRECT_TCP */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|add_prune_candidate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the commands.  */
end_comment

begin_decl_stmt
name|int
name|add
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|admin
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkout
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|commit
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|diff
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|import
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvslog
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patch
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|release
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvsremove
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|update
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the response handling functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|handle_ok
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_error
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_valid_requests
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_checked_in
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_new_entry
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_checksum
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_copy_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_updated
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_merged
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_patched
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_removed
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_remove_entry
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_static_directory
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_clear_static_directory
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_sticky
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_clear_sticky
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_checkin_prog
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_set_update_prog
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_module_expansion
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_m
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_e
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_notified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|try_read_from_server
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* Shared with server.  */
end_comment

begin_comment
comment|/*  * Return a malloc'd, '\0'-terminated string  * corresponding to the mode in SB.  */
end_comment

begin_function
name|char
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|mode_to_string
parameter_list|(
name|mode_t
name|mode
parameter_list|)
else|#
directive|else
comment|/* ! __STDC__ */
function|mode_to_string
parameter_list|(
name|mode
parameter_list|)
name|mode_t
name|mode
decl_stmt|;
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|char
name|buf
index|[
literal|18
index|]
decl_stmt|,
name|u
index|[
literal|4
index|]
decl_stmt|,
name|g
index|[
literal|4
index|]
decl_stmt|,
name|o
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|u
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|u
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|g
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|o
index|[
name|i
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|o
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"u=%s,g=%s,o=%s"
argument_list|,
name|u
argument_list|,
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change mode of FILENAME to MODE_STRING.  * Returns 0 for success or errno code.  */
end_comment

begin_function
name|int
name|change_mode
parameter_list|(
name|filename
parameter_list|,
name|mode_string
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CHMOD_BROKEN
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|writeable
init|=
literal|0
decl_stmt|;
comment|/* We can only distinguish between          1) readable          2) writeable          3) Picasso's "Blue Period"        We handle the first two. */
name|p
operator|=
name|mode_string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'w'
condition|)
name|writeable
operator|=
literal|1
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
block|}
comment|/* Skip to the next field.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|++
name|p
expr_stmt|;
block|}
name|xchmod
argument_list|(
name|filename
argument_list|,
name|writeable
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* ! CHMOD_BROKEN */
name|char
modifier|*
name|p
decl_stmt|;
name|mode_t
name|mode
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|mode_string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|int
name|can_read
init|=
literal|0
decl_stmt|,
name|can_write
init|=
literal|0
decl_stmt|,
name|can_execute
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|p
operator|+
literal|2
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'r'
condition|)
name|can_read
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'w'
condition|)
name|can_write
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'x'
condition|)
name|can_execute
operator|=
literal|1
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|can_read
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|can_write
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|can_execute
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
comment|/* Skip to the next field.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* ! CHMOD_BROKEN */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* The host part of CVSROOT.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user part of CVSROOT */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_user
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The repository part of CVSROOT.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_cvsroot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|client_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|client_prune_dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cvsroot_parsed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set server_host and server_cvsroot.  */
end_comment

begin_function
specifier|static
name|void
name|parse_cvsroot
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
specifier|static
name|char
modifier|*
name|access_method
decl_stmt|;
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
comment|/* Don't go through the trouble twice. */
if|if
condition|(
name|cvsroot_parsed
condition|)
return|return;
name|server_host
operator|=
name|xstrdup
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
if|if
condition|(
operator|(
name|server_host
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* Access method specified, as in        * "cvs -d :pserver:user@host:/path".        * We need to get past that part of CVSroot before parsing the        * rest of it.        */
name|access_method
operator|=
name|p
operator|=
operator|&
operator|(
name|server_host
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|access_method
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad CVSroot: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|access_method
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad CVSroot: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|server_host
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|server_host
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad CVSroot: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|access_method
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
name|use_authenticating_server
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unknown access method: %s"
argument_list|,
name|access_method
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
comment|/* First get just the pathname. */
name|server_cvsroot
operator|=
name|strchr
argument_list|(
name|server_host
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|server_cvsroot
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|server_cvsroot
expr_stmt|;
comment|/* Then deal with host and possible user. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|server_host
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|server_user
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|server_user
operator|=
name|server_host
expr_stmt|;
name|server_host
operator|=
name|p
expr_stmt|;
operator|++
name|server_host
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|client_active
operator|=
literal|1
expr_stmt|;
name|cvsroot_parsed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
end_ifdef

begin_comment
comment|/* Under certain circumstances, we must communicate with the server    via a socket using send() and recv().  This is because under some    operating systems (OS/2 and Windows 95 come to mind), a socket    cannot be converted to a file descriptor -- it must be treated as a    socket and nothing else. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_socket_style
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|server_sock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_SOCKET_TO_FD */
end_comment

begin_comment
comment|/* Stream to write to the server.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|to_server
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stream to read from the server.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|from_server
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We might want to log client/server traffic. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|from_server_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|to_server_logfile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|RSH_NOT_TRANSPARENT
end_if

begin_comment
comment|/* Process ID of rsh subprocess.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rsh_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RSH_NOT_TRANSPARENT */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Read a line from the server.  Result does not include the terminating \n.  *  * Space for the result is malloc'd and should be freed by the caller.  *  * Returns number of bytes read.  If EOF_OK, then return 0 on end of file,  * else end of file is an error.  */
end_comment

begin_function
specifier|static
name|int
name|read_line
parameter_list|(
name|resultp
parameter_list|,
name|eof_ok
parameter_list|)
name|char
modifier|*
modifier|*
name|resultp
decl_stmt|;
name|int
name|eof_ok
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|input_index
init|=
literal|0
decl_stmt|;
name|size_t
name|result_size
init|=
literal|80
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
operator|!
name|use_socket_style
condition|)
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
name|fflush
argument_list|(
name|to_server
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
name|char
name|ch
decl_stmt|;
comment|/* Yes, this sucks performance-wise.  Short of implementing              our own buffering, I'm not sure how to effect a big              improvement.  We could at least avoid calling              read_from_server() for each character if we were willing              to duplicate a lot of its code, but I'm not sure that's              worth it. */
name|read_from_server
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
name|c
operator|=
name|getc
argument_list|(
name|from_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
operator|!
name|use_socket_style
condition|)
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
if|if
condition|(
name|ferror
argument_list|(
name|from_server
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading from server"
argument_list|)
expr_stmt|;
comment|/* It's end of file.  */
if|if
condition|(
name|eof_ok
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of file from server (consult above messages if any)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|+
literal|1
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resultp
condition|)
operator|*
name|resultp
operator|=
name|result
expr_stmt|;
comment|/* Terminate it just for kicks, but we *can* deal with embedded NULs.  */
name|result
index|[
name|input_index
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
operator|!
name|use_socket_style
condition|)
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
comment|/* 	 * If we're using socket style, then everything has already 	 * been logged because read_from_server() was used to get the 	 * individual chars, and read_from_server() logs already. 	 */
if|if
condition|(
name|from_server_logfile
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|result
argument_list|,
literal|1
argument_list|,
name|input_index
argument_list|,
name|from_server_logfile
argument_list|)
operator|<
name|input_index
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"writing to from-server logfile"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|from_server_logfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resultp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|input_index
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * Zero if compression isn't supported or requested; non-zero to indicate  * a compression level to request from gzip.  */
end_comment

begin_decl_stmt
name|int
name|gzip_level
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|filter_through_gzip
parameter_list|(
name|fd
parameter_list|,
name|dir
parameter_list|,
name|level
parameter_list|,
name|pidp
parameter_list|)
name|int
name|fd
decl_stmt|,
name|dir
decl_stmt|,
name|level
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|5
index|]
init|=
literal|"-"
decl_stmt|;
specifier|static
name|char
modifier|*
name|gzip_argv
index|[
literal|3
index|]
init|=
block|{
literal|"gzip"
block|,
name|buf
block|}
decl_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|filter_stream_through_program
argument_list|(
name|fd
argument_list|,
name|dir
argument_list|,
operator|&
name|gzip_argv
index|[
literal|0
index|]
argument_list|,
name|pidp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|filter_through_gunzip
parameter_list|(
name|fd
parameter_list|,
name|dir
parameter_list|,
name|pidp
parameter_list|)
name|int
name|fd
decl_stmt|,
name|dir
decl_stmt|;
name|pid_t
modifier|*
name|pidp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|gunzip_argv
index|[
literal|3
index|]
init|=
block|{
literal|"gunzip"
block|,
literal|"-d"
block|}
decl_stmt|;
return|return
name|filter_stream_through_program
argument_list|(
name|fd
argument_list|,
name|dir
argument_list|,
operator|&
name|gunzip_argv
index|[
literal|0
index|]
argument_list|,
name|pidp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/*  * The Repository for the top level of this command (not necessarily  * the CVSROOT, just the current directory at the time we do it).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|toplevel_repos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Working directory when we first started.  */
end_comment

begin_decl_stmt
name|char
name|toplevel_wd
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handle_ok
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_error
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|something_printed
decl_stmt|;
comment|/*      * First there is a symbolic error code followed by a space, which      * we ignore.      */
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid data from cvs server"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|p
expr_stmt|;
name|len
operator|-=
name|p
operator|-
name|args
expr_stmt|;
name|something_printed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|something_printed
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|something_printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_valid_requests
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rq
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rq
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* 	     * It is a request we have never heard of (and thus never 	     * will want to use).  So don't worry about it. 	     */
empty_stmt|;
else|else
block|{
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_enableme
condition|)
block|{
comment|/* 		 * Server wants to know if we have this, to enable the 		 * feature. 		 */
name|send_to_server
argument_list|(
name|rq
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"UseUnchanged"
argument_list|,
name|rq
operator|->
name|name
argument_list|)
condition|)
name|use_unchanged
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rq
operator|->
name|status
operator|=
name|rq_supported
expr_stmt|;
block|}
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
block|{
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_essential
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"request `%s' not supported by server"
argument_list|,
name|rq
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rq
operator|->
name|status
operator|==
name|rq_optional
condition|)
name|rq
operator|->
name|status
operator|=
name|rq_not_supported
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|use_directory
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_short_pathname
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_short_pathname
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|use_directory
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|name
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|toplevel_repos
argument_list|,
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server bug: name `%s' doesn't specify file in `%s'"
argument_list|,
name|name
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
name|retval
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|retval
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server bug: name `%s' doesn't specify file in `%s'"
argument_list|,
name|name
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the processing for PATHNAME, where pathname consists of the  * repository and the filename.  The parameters we pass to FUNC are:  * DATA is just the DATA parameter which was passed to  * call_in_directory; ENT_LIST is a pointer to an entries list (which  * we manage the storage for); SHORT_PATHNAME is the pathname of the  * file relative to the (overall) directory in which the command is  * taking place; and FILENAME is the filename portion only of  * SHORT_PATHNAME.  When we call FUNC, the curent directory points to  * the directory portion of SHORT_PATHNAME.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_dir_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|call_in_directory
parameter_list|(
name|pathname
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|data
operator|,
name|List
operator|*
name|ent_list
operator|,
name|char
operator|*
name|short_pathname
operator|,
name|char
operator|*
name|filename
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|List
modifier|*
name|last_entries
decl_stmt|;
name|char
modifier|*
name|dir_name
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Just the part of pathname relative to toplevel_repos.  */
name|char
modifier|*
name|short_pathname
init|=
name|get_short_pathname
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*      * Do the whole descent in parallel for the repositories, so we      * know what to put in CVS/Repository files.  I'm not sure the      * full hair is necessary since the server does a similar      * computation; I suspect that we only end up creating one      * directory at a time anyway.      *      * Also note that we must *only* worry about this stuff when we      * are creating directories; `cvs co foo/bar; cd foo/bar; cvs co      * CVSROOT; cvs update' is legitimate, but in this case      * foo/bar/CVSROOT/CVS/Repository is not a subdirectory of      * foo/bar/CVS/Repository.      */
name|char
modifier|*
name|reposname
decl_stmt|;
name|char
modifier|*
name|short_repos
decl_stmt|;
name|char
modifier|*
name|reposdirname
decl_stmt|;
name|char
modifier|*
name|rdirp
decl_stmt|;
name|int
name|reposdirname_absolute
decl_stmt|;
name|reposname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|use_directory
condition|)
name|read_line
argument_list|(
operator|&
name|reposname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reposdirname_absolute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reposname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|reposname
argument_list|,
name|toplevel_repos
argument_list|,
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reposdirname_absolute
operator|=
literal|1
expr_stmt|;
name|short_repos
operator|=
name|reposname
expr_stmt|;
block|}
else|else
block|{
name|short_repos
operator|=
name|reposname
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|short_repos
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|reposdirname_absolute
operator|=
literal|1
expr_stmt|;
name|short_repos
operator|=
name|reposname
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|short_repos
operator|=
name|short_pathname
expr_stmt|;
block|}
name|reposdirname
operator|=
name|xstrdup
argument_list|(
name|short_repos
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|reposdirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|reposdirname
operator|=
name|xrealloc
argument_list|(
name|reposdirname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|reposdirname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|reposdirname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|dir_name
operator|=
name|xstrdup
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|dir_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|dir_name
operator|=
name|xrealloc
argument_list|(
name|dir_name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dir_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|client_prune_dirs
condition|)
name|add_prune_candidate
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|short_repos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|short_repos
expr_stmt|;
else|else
operator|++
name|filename
expr_stmt|;
if|if
condition|(
name|reposname
operator|!=
name|NULL
condition|)
block|{
comment|/* This is the use_directory case.  */
name|short_pathname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|short_pathname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|short_pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_dir_name
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|last_dir_name
argument_list|,
name|dir_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|last_dir_name
condition|)
name|free
argument_list|(
name|last_dir_name
argument_list|)
expr_stmt|;
name|last_dir_name
operator|=
name|dir_name
expr_stmt|;
if|if
condition|(
name|toplevel_wd
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|getwd
argument_list|(
name|toplevel_wd
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not get working directory: %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|dirp
decl_stmt|;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
comment|/* Directory does not exist, we need to create it.  */
name|dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|dir_name
expr_stmt|;
name|rdirp
operator|=
name|reposdirname
expr_stmt|;
comment|/* This algorithm makes nested directories one at a time                and create CVS administration files in them.  For                example, we're checking out foo/bar/baz from the                repository:  	       1) create foo, point CVS/Repository to<root>/foo 	       2)     .. foo/bar                   ..<root>/foo/bar 	       3)     .. foo/bar/baz               ..<root>/foo/bar/baz 	        	       As you can see, we're just stepping along DIR_NAME (with 	       DIRP) and REPOSDIRNAME (with RDIRP) respectively.  	       We need to be careful when we are checking out a 	       module, however, since DIR_NAME and REPOSDIRNAME are not 	       going to be the same.  Since modules will not have any 	       slashes in their names, we should watch the output of 	       STRCHR to decide whether or not we should use STRCHR on 	       the RDIRP.  That is, if we're down to a module name, 	       don't keep picking apart the repository directory name.  */
do|do
block|{
name|dirp
operator|=
name|strchr
argument_list|(
name|dirp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
condition|)
block|{
name|strncpy
argument_list|(
name|dir
argument_list|,
name|dir_name
argument_list|,
name|dirp
operator|-
name|dir_name
argument_list|)
expr_stmt|;
name|dir
index|[
name|dirp
operator|-
name|dir_name
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip the slash.  */
operator|++
name|dirp
expr_stmt|;
if|if
condition|(
name|rdirp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: repository string too short."
argument_list|)
expr_stmt|;
else|else
name|rdirp
operator|=
name|strchr
argument_list|(
name|rdirp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If there are no more slashes in the dir name,                        we're down to the most nested directory -OR- to                        the name of a module.  In the first case, we                        should be down to a DIRP that has no slashes,                        so it won't help/hurt to do another STRCHR call                        on DIRP.  It will definitely hurt, however, if                        we're down to a module name, since a module                        name can point to a nested directory (that is,                        DIRP will still have slashes in it.  Therefore,                        we should set it to NULL so the routine below                        copies the contents of REMOTEDIRNAME onto the                        root repository directory (does this if rdirp                        is set to NULL, because we used to do an extra                        STRCHR call here). */
name|rdirp
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Now, let me get this straight.  In IBM C/C++                    * under OS/2, the error string for EEXIST is:                    *                    *     "The file already exists",                    *                    * and the error string for EACCESS is:                    *                    *     "The file or directory specified is read-only".                    *                    * Nonetheless, mkdir() will set EACCESS if the                    * directory *exists*, according both to the                    * documentation and its actual behavior.                    *                    * I'm sure that this made sense, to someone,                    * somewhere, sometime.  Just not me, here, now.                    */
ifdef|#
directive|ifdef
name|EACCESS
if|if
condition|(
operator|(
name|errno
operator|!=
name|EACCESS
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! defined(EACCESS) */
if|if
condition|(
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(EACCESS) */
comment|/* It already existed, fine.  Just keep going.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
comment|/* Don't create CVSADM directories if this is export.  */
empty_stmt|;
else|else
block|{
comment|/* 		     * Put repository in CVS/Repository.  For historical 		     * (pre-CVS/Root) reasons, this is an absolute pathname, 		     * but what really matters is the part of it which is 		     * relative to cvsroot. 		     */
name|char
modifier|*
name|repo
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|repo
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|reposdirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|reposdirname_absolute
condition|)
name|r
operator|=
name|repo
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|repo
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|repo
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|r
operator|=
name|repo
operator|+
name|strlen
argument_list|(
name|repo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdirp
condition|)
block|{
name|strncpy
argument_list|(
name|r
argument_list|,
name|reposdirname
argument_list|,
name|rdirp
operator|-
name|reposdirname
argument_list|)
expr_stmt|;
name|r
index|[
name|rdirp
operator|-
name|reposdirname
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|r
argument_list|,
name|reposdirname
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|dir
argument_list|,
name|repo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdirp
operator|!=
name|NULL
condition|)
block|{
comment|/* Skip the slash.  */
operator|++
name|rdirp
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dirp
operator|!=
name|NULL
condition|)
do|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* Now it better work.  */
if|if
condition|(
name|chdir
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|last_entries
condition|)
name|Entries_Close
argument_list|(
name|last_entries
argument_list|)
expr_stmt|;
name|last_entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|free
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposdirname
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|data
argument_list|,
name|last_entries
argument_list|,
name|short_pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|reposname
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|void
name|copy_a_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|newname
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|read_line
argument_list|(
operator|&
name|newname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
comment|/* Mogrify the filename so VMS is happy with it. */
for|for
control|(
name|p
operator|=
name|newname
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'#'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
endif|#
directive|endif
name|copy_file
argument_list|(
name|filename
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_copy_file
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|copy_a_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|read_counted_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read from the server the count for the length of a file, then read    the contents of that file and write them to FILENAME.  FULLNAME is    the name of the file for use in error messages.  FIXME-someday:    extend this to deal with compressed files and make update_entries    use it.  On error, gives a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|read_counted_file
parameter_list|(
name|filename
parameter_list|,
name|fullname
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
block|{
name|char
modifier|*
name|size_string
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Pointers in buf to the place to put data which will be read,        and the data which needs to be written, respectively.  */
name|char
modifier|*
name|pread
decl_stmt|;
name|char
modifier|*
name|pwrite
decl_stmt|;
comment|/* Number of bytes left to read and number of bytes in buf waiting to        be written, respectively.  */
name|size_t
name|nread
decl_stmt|;
name|size_t
name|nwrite
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|size_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_string
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ protocol error: compressed files not supported for that operation"
argument_list|)
expr_stmt|;
comment|/* FIXME: should be doing more error checking, probably.  Like using        strtoul and making sure we used up the whole line.  */
name|size
operator|=
name|atoi
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
comment|/* A more sophisticated implementation would use only a limited amount        of buffer space (8K perhaps), and read that much at a time.  We allocate        a buffer for the whole file only to make it easy to keep track what        needs to be read and written.  */
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* FIXME-someday: caller should pass in a flag saying whether it        is binary or not.  I haven't carefully looked into whether        CVS/Template files should use local text file conventions or        not.  */
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|nread
operator|=
name|size
expr_stmt|;
name|nwrite
operator|=
literal|0
expr_stmt|;
name|pread
operator|=
name|buf
expr_stmt|;
name|pwrite
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|nread
operator|>
literal|0
operator|||
name|nwrite
operator|>
literal|0
condition|)
block|{
name|size_t
name|n
decl_stmt|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|try_read_from_server
argument_list|(
name|pread
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|nread
operator|-=
name|n
expr_stmt|;
name|pread
operator|+=
name|n
expr_stmt|;
name|nwrite
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|nwrite
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|fwrite
argument_list|(
name|pwrite
argument_list|,
literal|1
argument_list|,
name|nwrite
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|nwrite
operator|-=
name|n
expr_stmt|;
name|pwrite
operator|+=
name|n
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The Checksum response gives the checksum for the file transferred  * over by the next Updated, Merged or Patch response.  We just store  * it here, and then check it in update_entries.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stored_checksum_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|stored_checksum
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_checksum
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stored_checksum_valid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Checksum received before last one was used"
argument_list|)
expr_stmt|;
name|s
operator|=
name|args
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|bufend
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|stored_checksum
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|strtol
argument_list|(
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufend
operator|!=
name|buf
operator|+
literal|2
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|16
operator|||
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Invalid Checksum response: `%s'"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|stored_mode_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stored_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_mode
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mode
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|stored_mode_valid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"protocol error: duplicate Mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stored_mode
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stored_mode
argument_list|)
expr_stmt|;
name|stored_mode
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stored_mode_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If we receive a patch, but the patch program fails to apply it, we  * want to request the original file.  We keep a list of files whose  * patches have failed.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|failed_patches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|failed_patches_count
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|update_entries_data
block|{
enum|enum
block|{
comment|/*        * We are just getting an Entries line; the local file is        * correct.        */
name|UPDATE_ENTRIES_CHECKIN
block|,
comment|/* We are getting the file contents as well.  */
name|UPDATE_ENTRIES_UPDATE
block|,
comment|/*        * We are getting a patch against the existing local file, not        * an entire new file.        */
name|UPDATE_ENTRIES_PATCH
block|}
name|contents
enum|;
comment|/*      * String to put in the timestamp field or NULL to use the timestamp      * of the file.      */
name|char
modifier|*
name|timestamp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Update the Entries line for this file.  */
end_comment

begin_function
specifier|static
name|void
name|update_entries
parameter_list|(
name|data_arg
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data_arg
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|entries_line
decl_stmt|;
name|struct
name|update_entries_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|update_entries_data
operator|*
operator|)
name|data_arg
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|vn
decl_stmt|;
comment|/* Timestamp field.  Always empty according to the protocol.  */
name|char
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|tag_or_date
decl_stmt|;
name|char
modifier|*
name|scratch_entries
decl_stmt|;
name|int
name|bin
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|entries_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Parse the entries line.      */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|scratch_entries
operator|=
name|xstrdup
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_entries
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
name|user
operator|=
name|scratch_entries
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vn
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|vn
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|options
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad entries line `%s' from server"
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tag_or_date
operator|=
name|cp
expr_stmt|;
comment|/* If a slash ends the tag_or_date, ignore everything after it.  */
name|cp
operator|=
name|strchr
argument_list|(
name|tag_or_date
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|date
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'T'
condition|)
name|tag
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'D'
condition|)
name|date
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* For cvs export, assume it is a text file.  FIXME: This is 	   broken behavior--we should be having the server tell us 	   whether it is text or binary and dealing accordingly.  I 	   think maybe we can parse the entries line, get the options, 	   and then ignore the entries line otherwise, but I haven't 	   checked to see whether the server sends the entries line 	   correctly in this case.  */
name|options
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_UPDATE
operator|||
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_PATCH
condition|)
block|{
name|char
modifier|*
name|size_string
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|temp_filename
decl_stmt|;
name|int
name|use_gzip
decl_stmt|,
name|gzip_status
decl_stmt|;
name|pid_t
name|gzip_pid
init|=
literal|0
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|mode_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_line
argument_list|(
operator|&
name|size_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_string
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|use_gzip
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_string
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|use_gzip
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|size_string
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_VMS_FILENAMES
comment|/* A VMS rename of "blah.dat" to "foo" to implies a            destination of "foo.dat" which is unfortinate for CVS */
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|"%s_new_"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_POSIX_NO_TRUNC
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|".new.%.9s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _POSIX_NO_TRUNC */
name|sprintf
argument_list|(
name|temp_filename
argument_list|,
literal|".new.%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _POSIX_NO_TRUNC */
endif|#
directive|endif
comment|/* USE_VMS_FILENAMES */
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Some systems, like OS/2 and Windows NT, end lines with CRLF            instead of just LF.  Format translation is done in the C            library I/O funtions.  Here we tell them whether or not to            convert -- if this file is marked "binary" with the RCS -kb            flag, then we don't want to convert, else we do (because            CVS assumes text files by default). */
if|if
condition|(
name|options
condition|)
name|bin
operator|=
operator|!
operator|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|)
expr_stmt|;
else|else
name|bin
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|temp_filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
operator|(
name|bin
condition|?
name|OPEN_BINARY
else|:
literal|0
operator|)
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gzip
condition|)
name|fd
operator|=
name|filter_through_gunzip
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|read_from_server
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzip_pid
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gzip process %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip process exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
block|}
name|gzip_pid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Since gunzip writes files without converting LF to CRLF 	   (a reasonable behavior), we now have a patch file in LF 	   format.  Leave the file as is if we're just going to feed 	   it to patch; patch can handle it.  However, if it's the 	   final source file, convert it.  */
if|if
condition|(
name|data
operator|->
name|contents
operator|==
name|UPDATE_ENTRIES_UPDATE
condition|)
block|{
ifdef|#
directive|ifdef
name|LINES_CRLF_TERMINATED
comment|/* `bin' is non-zero iff `options' contains "-kb", meaning                 treat this file as binary. */
if|if
condition|(
name|use_gzip
operator|&&
operator|(
operator|!
name|bin
operator|)
condition|)
block|{
name|convert_file
argument_list|(
name|temp_filename
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|,
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|temp_filename
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: couldn't delete %s"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
block|}
else|else
name|rename_file
argument_list|(
name|temp_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! LINES_CRLF_TERMINATED */
name|rename_file
argument_list|(
name|temp_filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LINES_CRLF_TERMINATED */
block|}
else|else
block|{
name|int
name|retcode
decl_stmt|;
name|char
name|backup
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s~"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|filename
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"patch original file %s does not exist"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|temp_filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|"can't stat patch file %s"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|st_size
operator|==
literal|0
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|run_setup
argument_list|(
literal|"%s -f -s -b ~ %s %s"
argument_list|,
name|PATCH_PROGRAM
argument_list|,
name|filename
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|run_exec
argument_list|(
name|DEVNULL
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
name|char
modifier|*
name|path_tmp
decl_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Get rid of the patch reject file.  */
name|path_tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path_tmp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path_tmp
argument_list|,
literal|".rej"
argument_list|)
expr_stmt|;
comment|/* FIXME: should we really be silently ignoring errors?  */
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|path_tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_tmp
argument_list|)
expr_stmt|;
comment|/* Save this file to retrieve later.  */
name|failed_patches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|failed_patches
argument_list|,
operator|(
operator|(
name|failed_patches_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failed_patches
index|[
name|failed_patches_count
index|]
operator|=
name|xstrdup
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
operator|++
name|failed_patches_count
expr_stmt|;
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not patch %s%s"
argument_list|,
name|filename
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
literal|"; will refetch"
argument_list|)
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|stored_checksum_valid
condition|)
block|{
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|MD5Context
name|context
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	     * Compute the MD5 checksum.  This will normally only be 	     * used when receiving a patch, so we always compute it 	     * here on the final file, rather than on the received 	     * data. 	     * 	     * Note that if the file is a text file, we should read it 	     * here using text mode, so its lines will be terminated the same 	     * way they were transmitted. 	     */
name|e
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|MD5Update
argument_list|(
operator|&
name|context
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not read %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|checksum
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|checksum
argument_list|,
name|stored_checksum
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|contents
operator|!=
name|UPDATE_ENTRIES_PATCH
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"checksum failure on %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"checksum failure after patch to %s; will refetch"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
comment|/* Save this file to retrieve later.  */
name|failed_patches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|failed_patches
argument_list|,
operator|(
operator|(
name|failed_patches_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|failed_patches
index|[
name|failed_patches_count
index|]
operator|=
name|xstrdup
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
operator|++
name|failed_patches_count
expr_stmt|;
return|return;
block|}
block|}
block|{
comment|/* FIXME: we should be respecting the umask.  */
name|int
name|status
init|=
name|change_mode
argument_list|(
name|filename
argument_list|,
name|mode_string
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot change mode of %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stored_mode_valid
condition|)
name|change_mode
argument_list|(
name|filename
argument_list|,
name|stored_mode
argument_list|)
expr_stmt|;
name|stored_mode_valid
operator|=
literal|0
expr_stmt|;
comment|/*      * Process the entries line.  Do this after we've written the file,      * since we need the timestamp.      */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|local_timestamp
decl_stmt|;
name|char
modifier|*
name|file_timestamp
decl_stmt|;
name|local_timestamp
operator|=
name|data
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|local_timestamp
operator|==
name|NULL
operator|||
name|ts
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
name|file_timestamp
operator|=
name|time_stamp
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|file_timestamp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * These special version numbers signify that it is not up to 	 * date.  Create a dummy timestamp which will never compare 	 * equal to the timestamp of the file. 	 */
if|if
condition|(
name|vn
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|vn
index|[
literal|0
index|]
operator|==
literal|'0'
operator|||
name|vn
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|local_timestamp
operator|=
literal|"dummy timestamp"
expr_stmt|;
elseif|else
if|if
condition|(
name|local_timestamp
operator|==
name|NULL
condition|)
block|{
name|local_timestamp
operator|=
name|file_timestamp
expr_stmt|;
name|mark_up_to_date
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|,
name|vn
argument_list|,
name|local_timestamp
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts
index|[
literal|0
index|]
operator|==
literal|'+'
condition|?
name|file_timestamp
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_timestamp
condition|)
name|free
argument_list|(
name|file_timestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratch_entries
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_checked_in
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_CHECKIN
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_new_entry
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_CHECKIN
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
literal|"dummy timestamp from new-entry"
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_updated
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_merged
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_UPDATE
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
literal|"Result of merge"
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_patched
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|update_entries_data
name|dat
decl_stmt|;
name|dat
operator|.
name|contents
operator|=
name|UPDATE_ENTRIES_PATCH
expr_stmt|;
name|dat
operator|.
name|timestamp
operator|=
name|NULL
expr_stmt|;
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|update_entries
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_entry
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Scratch_Entry
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_remove_entry
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|remove_entry
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_entry_and_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Scratch_Entry
argument_list|(
name|ent_list
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|filename
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"unable to remove %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_removed
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|remove_entry_and_file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Is this the top level (directory containing CVSROOT)?  */
end_comment

begin_function
specifier|static
name|int
name|is_cvsroot_level
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|short_pathname
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|toplevel_repos
argument_list|,
name|server_cvsroot
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|use_directory
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pathname
argument_list|,
name|server_cvsroot
argument_list|,
name|strlen
argument_list|(
name|server_cvsroot
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server bug: pathname `%s' doesn't specify file in `%s'"
argument_list|,
name|pathname
argument_list|,
name|server_cvsroot
argument_list|)
expr_stmt|;
name|short_pathname
operator|=
name|pathname
operator|+
name|strlen
argument_list|(
name|server_cvsroot
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|short_pathname
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server bug: pathname `%s' doesn't specify file in `%s'"
argument_list|,
name|pathname
argument_list|,
name|server_cvsroot
argument_list|)
expr_stmt|;
return|return
name|strchr
argument_list|(
name|short_pathname
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
return|;
block|}
else|else
block|{
return|return
name|strchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_static
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_static_directory
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|set_static
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_static
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_clear_static_directory
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|clear_static
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_sticky
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|tagspec
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|tagspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|tagspec
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tagspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_sticky
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Swallow the tag line.  */
operator|(
name|void
operator|)
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Swallow the tag line.  */
operator|(
name|void
operator|)
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|set_sticky
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_sticky
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_TAG
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_clear_sticky
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Swallow the repository.  */
name|read_line
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_cvsroot_level
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
comment|/* 	 * Top level (directory containing CVSROOT).  This seems to normally 	 * lack a CVS directory, so don't try to create files in it. 	 */
return|return;
block|}
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|clear_sticky
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|List
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|template
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
comment|/* FIXME: should be computing second argument from CVSADM_TEMPLATE        and short_pathname.  */
name|read_counted_file
argument_list|(
name|CVSADM_TEMPLATE
argument_list|,
literal|"<CVS/Template file>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|handle_template
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_template
parameter_list|(
name|pathname
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|pathname
argument_list|,
name|template
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|save_prog
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|save_prog
modifier|*
name|checkin_progs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|save_prog
modifier|*
name|update_progs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unlike some responses this doesn't include the repository.  So we can't  * just call call_in_directory and have the right thing happen; we save up  * the requests and do them at the end.  */
end_comment

begin_function
specifier|static
name|void
name|handle_set_checkin_prog
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|prog
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|prog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|save_prog
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_prog
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|checkin_progs
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|prog
expr_stmt|;
name|checkin_progs
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_set_update_prog
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|prog
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|read_line
argument_list|(
operator|&
name|prog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|save_prog
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_prog
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|update_progs
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|prog
expr_stmt|;
name|update_progs
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|do_deferred_progs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|do_deferred_progs
parameter_list|()
block|{
name|struct
name|save_prog
modifier|*
name|p
decl_stmt|;
name|struct
name|save_prog
modifier|*
name|q
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|toplevel_wd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|checkin_progs
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
operator|->
name|dir
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|checkin_progs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|update_progs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
operator|->
name|dir
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|update_progs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|client_isemptydir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Returns 1 if the argument directory exists and is completely empty,  * other than the existence of the CVS directory entry.  Zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|client_isemptydir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s for empty check"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|save_dir
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|save_dir
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|save_dir
modifier|*
name|prune_candidates
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_prune_candidate
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|save_dir
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|save_dir
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|save_dir
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|prune_candidates
expr_stmt|;
name|prune_candidates
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|process_prune_candidates
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|process_prune_candidates
parameter_list|()
block|{
name|struct
name|save_dir
modifier|*
name|p
decl_stmt|;
name|struct
name|save_dir
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|toplevel_wd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|prune_candidates
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|client_isemptydir
argument_list|(
name|p
operator|->
name|dir
argument_list|)
condition|)
block|{
name|unlink_file_dir
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a Repository line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_repos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_update_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_repository
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_repository
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
modifier|*
name|adm_name
decl_stmt|;
comment|/* FIXME: this is probably not the best place to check; I wish I      * knew where in here's callers to really trap this bug.  To      * reproduce the bug, just do this:      *       *       mkdir junk      *       cd junk      *       cvs -d some_repos update foo      *      * Poof, CVS seg faults and dies!  It's because it's trying to      * send a NULL string to the server but dies in send_to_server.      * That string was supposed to be the repository, but it doesn't      * get set because there's no CVSADM dir, and somehow it's not      * getting set from the -d argument either... ?      */
if|if
condition|(
name|repos
operator|==
name|NULL
condition|)
block|{
comment|/* Lame error.  I want a real fix but can't stay up to track            this down right now. */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no repository"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_dir
operator|==
name|NULL
operator|||
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|update_dir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|repos
argument_list|,
name|last_repos
argument_list|)
operator|==
literal|0
operator|&&
name|last_update_dir
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|update_dir
argument_list|,
name|last_update_dir
argument_list|)
operator|==
literal|0
condition|)
comment|/* We've already sent it.  */
return|return;
if|if
condition|(
name|client_prune_dirs
condition|)
name|add_prune_candidate
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
comment|/* 80 is large enough for any of CVSADM_*.  */
name|adm_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_directory
operator|==
operator|-
literal|1
condition|)
name|use_directory
operator|=
name|supported_request
argument_list|(
literal|"Directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_directory
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Directory "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|repos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_to_server
argument_list|(
literal|"Repository "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|repos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Static-directory"
argument_list|)
condition|)
block|{
name|adm_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|adm_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|adm_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|adm_name
argument_list|)
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Static-directory\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Sticky"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Sticky "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Checkin-prog"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Checkin-prog "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|supported_request
argument_list|(
literal|"Update-prog"
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|adm_name
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|adm_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|adm_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Update-prog "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|nl
operator|==
name|NULL
condition|)
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing %s"
argument_list|,
name|adm_name
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|adm_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|xstrdup
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a Repository line and set toplevel_repos.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|send_a_repository
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_a_repository
parameter_list|(
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
operator|&&
name|repository
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|update_dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 	     * Get the repository from a CVS/Repository file if update_dir 	     * is absolute.  This is not correct in general, because 	     * the CVS/Repository file might not be the top-level one. 	     * This is for cases like "cvs update /foo/bar" (I'm not 	     * sure it matters what toplevel_repos we get, but it does 	     * matter that we don't hit the "internal error" code below). 	     */
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|toplevel_repos
operator|=
name|Name_Repository
argument_list|(
name|update_dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Guess the repository of that directory by looking at a 		 * subdirectory and removing as many pathname components 		 * as are in update_dir.  I think that will always (or at 		 * least almost always) be 1. 		 * 		 * So this deals with directories which have been 		 * renamed, though it doesn't necessarily deal with 		 * directories which have been put inside other 		 * directories (and cvs invoked on the containing 		 * directory).  I'm not sure the latter case needs to 		 * work. 		 */
comment|/* 		 * This gets toplevel_repos wrong for "cvs update ../foo" 		 * but I'm not sure toplevel_repos matters in that case. 		 */
name|int
name|slashes_in_update_dir
decl_stmt|;
name|int
name|slashes_skipped
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|slashes_in_update_dir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|update_dir
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|slashes_in_update_dir
expr_stmt|;
name|slashes_skipped
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|repository
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|repository
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: not enough slashes in %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|slashes_skipped
expr_stmt|;
if|if
condition|(
name|slashes_skipped
operator|<
name|slashes_in_update_dir
operator|+
literal|1
condition|)
operator|--
name|p
expr_stmt|;
else|else
break|break;
block|}
name|toplevel_repos
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|repository
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Note that we don't copy the trailing '/'.  */
name|strncpy
argument_list|(
name|toplevel_repos
argument_list|,
name|repository
argument_list|,
name|p
operator|-
name|repository
argument_list|)
expr_stmt|;
name|toplevel_repos
index|[
name|p
operator|-
name|repository
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|send_repository
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The "expanded" modules.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|modules_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|modules_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|modules_vector
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_module_expansion
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|modules_vector
operator|==
name|NULL
condition|)
block|{
name|modules_allocated
operator|=
literal|1
expr_stmt|;
comment|/* Small for testing */
name|modules_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|modules_allocated
operator|*
sizeof|sizeof
argument_list|(
name|modules_vector
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modules_count
operator|>=
name|modules_allocated
condition|)
block|{
name|modules_allocated
operator|*=
literal|2
expr_stmt|;
name|modules_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modules_vector
argument_list|,
name|modules_allocated
operator|*
sizeof|sizeof
argument_list|(
name|modules_vector
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|modules_vector
index|[
name|modules_count
index|]
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|modules_vector
index|[
name|modules_count
index|]
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|++
name|modules_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Original, not "expanded" modules.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|module_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|module_argv
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|client_expand_modules
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|int
name|errs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|module_argc
operator|=
name|argc
expr_stmt|;
name|module_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|module_argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|module_argv
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|module_argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|server_cvsroot
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"expand-modules\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errs
operator|=
name|get_server_responses
argument_list|()
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|errs
condition|)
name|error
argument_list|(
name|errs
argument_list|,
literal|0
argument_list|,
literal|"cannot expand modules"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_send_expansions
parameter_list|(
name|local
parameter_list|)
name|int
name|local
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|1
index|]
decl_stmt|;
comment|/* Send the original module names.  The "expanded" module name might        not be suitable as an argument to a co request (e.g. it might be        the result of a -d argument in the modules file).  It might be        cleaner if we genuinely expanded module names, all the way to a        local directory and repository, but that isn't the way it works        now.  */
name|send_file_names
argument_list|(
name|module_argc
argument_list|,
name|module_argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modules_count
condition|;
operator|++
name|i
control|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
name|modules_vector
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
name|send_files
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|server_cvsroot
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_nonexpanded_setup
parameter_list|()
block|{
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|server_cvsroot
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handle_m
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|args
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_e
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|args
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* This table must be writeable if the server code is included.  */
end_comment

begin_decl_stmt
name|struct
name|response
name|responses
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
define|#
directive|define
name|RSP_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|)
value|{n, f, t, s}
else|#
directive|else
comment|/* ! CLIENT_SUPPORT */
define|#
directive|define
name|RSP_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|)
value|{n, s}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|RSP_LINE
argument_list|(
literal|"ok"
argument_list|,
name|handle_ok
argument_list|,
name|response_type_ok
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"error"
argument_list|,
name|handle_error
argument_list|,
name|response_type_error
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Valid-requests"
argument_list|,
name|handle_valid_requests
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Checked-in"
argument_list|,
name|handle_checked_in
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"New-entry"
argument_list|,
name|handle_new_entry
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Checksum"
argument_list|,
name|handle_checksum
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Copy-file"
argument_list|,
name|handle_copy_file
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Updated"
argument_list|,
name|handle_updated
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Merged"
argument_list|,
name|handle_merged
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Patched"
argument_list|,
name|handle_patched
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Mode"
argument_list|,
name|handle_mode
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Removed"
argument_list|,
name|handle_removed
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Remove-entry"
argument_list|,
name|handle_remove_entry
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-static-directory"
argument_list|,
name|handle_set_static_directory
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Clear-static-directory"
argument_list|,
name|handle_clear_static_directory
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-sticky"
argument_list|,
name|handle_set_sticky
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Clear-sticky"
argument_list|,
name|handle_clear_sticky
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Template"
argument_list|,
name|handle_template
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-checkin-prog"
argument_list|,
name|handle_set_checkin_prog
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Set-update-prog"
argument_list|,
name|handle_set_update_prog
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Notified"
argument_list|,
name|handle_notified
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"Module-expansion"
argument_list|,
name|handle_module_expansion
argument_list|,
name|response_type_normal
argument_list|,
name|rs_optional
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"M"
argument_list|,
name|handle_m
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
name|RSP_LINE
argument_list|(
literal|"E"
argument_list|,
name|handle_e
argument_list|,
name|response_type_normal
argument_list|,
name|rs_essential
argument_list|)
block|,
comment|/* Possibly should be response_type_error.  */
name|RSP_LINE
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|response_type_normal
argument_list|,
argument|rs_essential
argument_list|)
undef|#
directive|undef
name|RSP_LINE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT or SERVER_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/*   * If LEN is 0, then send_to_server() computes string's length itself.  *  * Therefore, pass the real length when transmitting data that might  * contain 0's.  */
end_comment

begin_function
name|void
name|send_to_server
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
name|int
name|just_wrtn
init|=
literal|0
decl_stmt|;
name|size_t
name|wrtn
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* send() blocks under VMS */
if|if
condition|(
name|send
argument_list|(
name|server_sock
argument_list|,
name|str
operator|+
name|wrtn
argument_list|,
name|len
operator|-
name|wrtn
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing to server socket"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
while|while
condition|(
name|wrtn
operator|<
name|len
condition|)
block|{
name|just_wrtn
operator|=
name|send
argument_list|(
name|server_sock
argument_list|,
name|str
operator|+
name|wrtn
argument_list|,
name|len
operator|-
name|wrtn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|just_wrtn
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing to server socket"
argument_list|)
expr_stmt|;
name|wrtn
operator|+=
name|just_wrtn
expr_stmt|;
if|if
condition|(
name|wrtn
operator|==
name|len
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* VMS */
block|}
else|else
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
name|size_t
name|wrtn
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|wrtn
operator|<
name|len
condition|)
block|{
name|wrtn
operator|+=
name|fwrite
argument_list|(
name|str
operator|+
name|wrtn
argument_list|,
literal|1
argument_list|,
name|len
operator|-
name|wrtn
argument_list|,
name|to_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrtn
operator|==
name|len
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|to_server
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing to server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|to_server
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"premature end-of-file on server"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_server_logfile
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|to_server_logfile
argument_list|)
operator|<
name|len
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"writing to to-server logfile"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read up to LEN bytes from the server.  Returns actual number of bytes    read.  Gives a fatal error on EOF or error.  */
end_comment

begin_function
specifier|static
name|size_t
name|try_read_from_server
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|nread
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
name|nread
operator|=
name|recv
argument_list|(
name|server_sock
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading from server"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|nread
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|from_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|from_server
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading from server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|from_server
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of file from server (consult above messages if any)"
argument_list|)
expr_stmt|;
block|}
comment|/* Log, if that's what we're doing. */
if|if
condition|(
name|from_server_logfile
operator|!=
name|NULL
operator|&&
name|nread
operator|>
literal|0
condition|)
block|{
name|size_t
name|towrite
init|=
name|nread
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|towrite
argument_list|,
name|from_server_logfile
argument_list|)
operator|<
name|towrite
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"writing to from-server logfile"
argument_list|)
expr_stmt|;
block|}
return|return
name|nread
return|;
block|}
end_function

begin_comment
comment|/*  * Read LEN bytes from the server or die trying.  */
end_comment

begin_function
name|void
name|read_from_server
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|red
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|red
operator|<
name|len
condition|)
block|{
name|red
operator|+=
name|try_read_from_server
argument_list|(
name|buf
operator|+
name|red
argument_list|,
name|len
operator|-
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|==
name|len
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Get some server responses and process them.  Returns nonzero for  * error, 0 for success.  */
end_comment

begin_function
name|int
name|get_server_responses
parameter_list|()
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
do|do
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|read_line
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
name|rs
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|rs
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|cmdlen
init|=
name|strlen
argument_list|(
name|rs
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
index|[
name|cmdlen
index|]
operator|==
literal|'\0'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|cmdlen
index|]
operator|==
literal|' '
condition|)
operator|++
name|cmdlen
expr_stmt|;
else|else
comment|/* 		     * The first len characters match, but it's a different 		     * response.  e.g. the response is "oklahoma" but we 		     * matched "ok". 		     */
continue|continue;
call|(
modifier|*
name|rs
operator|->
name|func
call|)
argument_list|(
name|cmd
operator|+
name|cmdlen
argument_list|,
name|len
operator|-
name|cmdlen
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* It's OK to print just to the first '\0'.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: unrecognized response `%s' from cvs server"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rs
operator|->
name|type
operator|==
name|response_type_normal
condition|)
do|;
return|return
name|rs
operator|->
name|type
operator|==
name|response_type_error
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the responses and then close the connection.  */
end_comment

begin_decl_stmt
name|int
name|server_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag var; we'll set it in start_server() and not one of its  * callees, such as start_rsh_server().  This means that there might  * be a small window between the starting of the server and the  * setting of this var, but all the code in that window shouldn't care  * because it's busy checking return values to see if the server got  * started successfully anyway.  */
end_comment

begin_decl_stmt
name|int
name|server_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|get_responses_and_close
parameter_list|()
block|{
name|int
name|errs
init|=
name|get_server_responses
argument_list|()
decl_stmt|;
name|do_deferred_progs
argument_list|()
expr_stmt|;
if|if
condition|(
name|client_prune_dirs
condition|)
name|process_prune_candidates
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
name|use_socket_style
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|server_sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"shutting down server socket"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DIRECT_TCP
argument_list|)
operator|||
name|defined
argument_list|(
name|AUTH_CLIENT_SUPPORT
argument_list|)
if|if
condition|(
name|server_fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|server_fd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"shutting down connection to %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
comment|/*              * This test will always be true because we dup the descriptor              */
if|if
condition|(
name|fileno
argument_list|(
name|from_server
argument_list|)
operator|!=
name|fileno
argument_list|(
name|to_server
argument_list|)
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|to_server
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing down connection to %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_KERBEROS || USE_DIRECT_TCP || AUTH_CLIENT_SUPPORT */
ifdef|#
directive|ifdef
name|SHUTDOWN_SERVER
name|SHUTDOWN_SERVER
argument_list|(
name|fileno
argument_list|(
name|to_server
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! SHUTDOWN_SERVER */
block|{
ifdef|#
directive|ifdef
name|START_RSH_WITH_POPEN_RW
if|if
condition|(
name|pclose
argument_list|(
name|to_server
argument_list|)
operator|==
name|EOF
condition|)
else|#
directive|else
comment|/* ! START_RSH_WITH_POPEN_RW */
if|if
condition|(
name|fclose
argument_list|(
name|to_server
argument_list|)
operator|==
name|EOF
condition|)
endif|#
directive|endif
comment|/* START_RSH_WITH_POPEN_RW */
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"closing connection to %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getc
argument_list|(
name|from_server
argument_list|)
operator|!=
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dying gasps from %s unexpected"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|from_server
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"reading from %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|from_server
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHUTDOWN_SERVER */
block|}
if|#
directive|if
operator|!
name|RSH_NOT_TRANSPARENT
if|if
condition|(
name|rsh_pid
operator|!=
operator|-
literal|1
operator|&&
name|waitpid
argument_list|(
name|rsh_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for process %d"
argument_list|,
name|rsh_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! RSH_NOT_TRANSPARENT */
name|server_started
operator|=
literal|0
expr_stmt|;
return|return
name|errs
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RSH_NOT_TRANSPARENT
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|start_rsh_server
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RSH_NOT_TRANSPARENT */
end_comment

begin_function
name|int
name|supported_request
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
condition|;
name|rq
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rq
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|rq
operator|->
name|status
operator|==
name|rq_supported
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: testing support for unknown option?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_function
name|void
name|init_sockaddr
parameter_list|(
name|name
parameter_list|,
name|hostname
parameter_list|,
name|port
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
name|unsigned
name|short
name|int
name|port
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hostinfo
decl_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|name
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|hostinfo
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostinfo
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown host %s.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|name
operator|->
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hostinfo
operator|->
name|h_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|auth_server_port_number
parameter_list|()
block|{
return|return
name|CVS_AUTH_PORT
return|;
block|}
end_function

begin_comment
comment|/*  * Connect to the authenticating server.  *  * If VERIFY_ONLY is non-zero, then just verify that the password is  * correct and then shutdown the connection.  In this case, the return  * values is 1 if the password was correct, 0 if not.  *  * If VERIFY_ONLY is 0, then really connect to the server.  In this  * case the return value is 1 on succees, but is probably ignored.  If  * fail to connect, then die with error.  */
end_comment

begin_function
name|int
name|connect_to_pserver
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|,
name|verify_only
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|verify_only
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sock
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SOCKET_TO_FD
name|int
name|tofd
decl_stmt|,
name|fromfd
decl_stmt|;
endif|#
directive|endif
name|int
name|port_number
decl_stmt|;
name|struct
name|sockaddr_in
name|client_sai
decl_stmt|;
comment|/* Does nothing if already called before now. */
name|parse_cvsroot
argument_list|()
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"socket() failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|port_number
operator|=
name|auth_server_port_number
argument_list|()
expr_stmt|;
name|init_sockaddr
argument_list|(
operator|&
name|client_sai
argument_list|,
name|server_host
argument_list|,
name|port_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_sai
argument_list|,
sizeof|sizeof
argument_list|(
name|client_sai
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"connect to %s:%d failed"
argument_list|,
name|server_host
argument_list|,
name|CVS_AUTH_PORT
argument_list|)
expr_stmt|;
comment|/* Run the authorization mini-protocol before anything else. */
block|{
name|int
name|i
decl_stmt|;
name|char
name|ch
decl_stmt|,
name|read_buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|begin
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|repository
init|=
name|server_cvsroot
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|server_user
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|verify_only
condition|)
block|{
name|begin
operator|=
literal|"BEGIN VERIFICATION REQUEST\n"
expr_stmt|;
name|end
operator|=
literal|"END VERIFICATION REQUEST\n"
expr_stmt|;
block|}
else|else
block|{
name|begin
operator|=
literal|"BEGIN AUTH REQUEST\n"
expr_stmt|;
name|end
operator|=
literal|"END AUTH REQUEST\n"
expr_stmt|;
block|}
comment|/* Get the password, probably from ~/.cvspass. */
name|password
operator|=
name|get_cvs_password
argument_list|(
name|server_user
argument_list|,
name|server_host
argument_list|,
name|server_cvsroot
argument_list|)
expr_stmt|;
comment|/* Announce that we're starting the authorization protocol. */
name|send
argument_list|(
name|sock
argument_list|,
name|begin
argument_list|,
name|strlen
argument_list|(
name|begin
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send the data the server needs. */
name|send
argument_list|(
name|sock
argument_list|,
name|repository
argument_list|,
name|strlen
argument_list|(
name|repository
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|sock
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|sock
argument_list|,
name|username
argument_list|,
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|sock
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|sock
argument_list|,
name|password
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|sock
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Announce that we're ending the authorization protocol. */
name|send
argument_list|(
name|sock
argument_list|,
name|end
argument_list|,
name|strlen
argument_list|(
name|end
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Paranoia. */
name|memset
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|password
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get ACK or NACK from the server.  	 *  	 * We could avoid this careful read-char loop by having the ACK 	 * and NACK cookies be of the same length, so we'd simply read 	 * that length and see what we got.  But then there'd be Yet 	 * Another Protocol Requirement floating around, and someday 	 * someone would make a change that breaks it and spend a hellish 	 * day tracking it down.  Therefore, we use "\n" to mark off the 	 * end of both ACK and NACK, and we loop, reading until "\n". 	 */
name|ch
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|read_buf
argument_list|,
literal|0
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|PATH_MAX
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|recv
argument_list|(
name|sock
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"recv() from server %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
name|read_buf
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|read_buf
argument_list|,
literal|"I HATE YOU\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Authorization not granted. */
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"authorization failed: server %s rejected access"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"shutdown() failed (server %s)"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verify_only
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"authorization failed: server %s rejected access"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|read_buf
argument_list|,
literal|"I LOVE YOU\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Unrecognized response from server. */
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unrecognized auth response from %s: %s"
argument_list|,
name|server_host
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"shutdown() failed, server %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized auth response from %s: %s"
argument_list|,
name|server_host
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verify_only
condition|)
block|{
if|if
condition|(
name|shutdown
argument_list|(
name|sock
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"shutdown() failed, server %s"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
name|use_socket_style
operator|=
literal|1
expr_stmt|;
name|server_sock
operator|=
name|sock
expr_stmt|;
comment|/* Try to break mistaken callers: */
operator|*
name|tofdp
operator|=
literal|0
expr_stmt|;
operator|*
name|fromfdp
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* ! NO_SOCKET_TO_FD */
name|server_fd
operator|=
name|sock
expr_stmt|;
name|close_on_exec
argument_list|(
name|server_fd
argument_list|)
expr_stmt|;
name|tofd
operator|=
name|fromfd
operator|=
name|sock
expr_stmt|;
comment|/* Hand them back to the caller. */
operator|*
name|tofdp
operator|=
name|tofd
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|fromfd
expr_stmt|;
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|}
return|return
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|HAVE_KERBEROS
operator|||
name|USE_DIRECT_TCP
end_if

begin_comment
comment|/*  * FIXME: this function has not been changed to deal with  * NO_SOCKET_TO_FD (i.e., systems on which sockets cannot be converted  * to file descriptors.  The first person to try building a kerberos  * client on such a system (OS/2, Windows 95, and maybe others) will  * have to make take care of this.  */
end_comment

begin_function
name|void
name|start_tcp_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|tofd
decl_stmt|,
name|fromfd
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|hname
decl_stmt|;
specifier|const
name|char
modifier|*
name|portenv
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|HAVE_KERBEROS
name|KTEXT_ST
name|ticket
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
name|int
name|status
decl_stmt|;
comment|/*    * We look up the host to give a better error message if it    * does not exist.  However, we then pass server_host to    * krb_sendauth, rather than the canonical name, because    * krb_sendauth is going to do its own canonicalization anyhow    * and that lets us not worry about the static storage used by    * gethostbyname.    */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|server_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: unknown host"
argument_list|,
name|server_host
argument_list|)
expr_stmt|;
name|hname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_KERBEROS
name|realm
operator|=
name|krb_realmofhost
argument_list|(
name|hname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
comment|/* Get CVS_CLIENT_PORT or look up cvs/tcp with CVS_PORT as default */
name|portenv
operator|=
name|getenv
argument_list|(
literal|"CVS_CLIENT_PORT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|portenv
operator|!=
name|NULL
condition|)
block|{
name|port
operator|=
name|atoi
argument_list|(
name|portenv
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
goto|goto
name|try_rsh_no_message
goto|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using TCP port %d to contact server.\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"cvs"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|port
operator|=
name|htons
argument_list|(
name|CVS_PORT
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|tofd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
name|int
name|laddrlen
decl_stmt|;
name|MSG_DAT
name|msg_data
decl_stmt|;
name|CREDENTIALS
name|cred
decl_stmt|;
name|Key_schedule
name|sched
decl_stmt|;
name|laddrlen
operator|=
sizeof|sizeof
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|laddr
argument_list|,
operator|&
name|laddrlen
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
comment|/* We don't care about the checksum, and pass it as zero.  */
name|status
operator|=
name|krb_sendauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|s
argument_list|,
operator|&
name|ticket
argument_list|,
literal|"rcmd"
argument_list|,
name|hname
argument_list|,
name|realm
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|,
operator|&
name|msg_data
argument_list|,
operator|&
name|cred
argument_list|,
name|sched
argument_list|,
operator|&
name|laddr
argument_list|,
operator|&
name|sin
argument_list|,
literal|"KCVSV1.0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"kerberos: %s"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
name|server_fd
operator|=
name|s
expr_stmt|;
name|close_on_exec
argument_list|(
name|server_fd
argument_list|)
expr_stmt|;
name|tofd
operator|=
name|fromfd
operator|=
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
block|}
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
block|}
if|if
condition|(
name|tofd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* FIXME: Falling back like this is slow and we should probably 	 just make it a fatal error (so that people use the right 	 environment variables or, when we get around to implementing 	 the right ones, access methods).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"trying to start server using rsh"
argument_list|)
expr_stmt|;
name|try_rsh_no_message
label|:
name|server_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|RSH_NOT_TRANSPARENT
name|start_rsh_server
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* RSH_NOT_TRANSPARENT */
if|#
directive|if
name|defined
argument_list|(
name|START_SERVER
argument_list|)
name|START_SERVER
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|server_user
argument_list|,
name|server_host
argument_list|,
name|server_cvsroot
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined (START_SERVER) */
endif|#
directive|endif
comment|/* ! RSH_NOT_TRANSPARENT */
block|}
name|free
argument_list|(
name|hname
argument_list|)
expr_stmt|;
comment|/* Give caller the values it wants. */
operator|*
name|tofdp
operator|=
name|tofd
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|fromfd
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS || USE_DIRECT_TCP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|send_variable_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send_variable_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|send_to_server
argument_list|(
literal|"Set "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"="
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|node
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Contact the server.  */
end_comment

begin_function
name|void
name|start_server
parameter_list|()
block|{
name|int
name|tofd
decl_stmt|,
name|fromfd
decl_stmt|;
name|char
modifier|*
name|log
init|=
name|getenv
argument_list|(
literal|"CVS_CLIENT_LOG"
argument_list|)
decl_stmt|;
comment|/* Note that generally speaking we do *not* fall back to a different      way of connecting if the first one does not work.  This is slow      (*really* slow on a 14.4kbps link); the clean way to have a CVS      which supports several ways of connecting is with access methods.  */
comment|/* Init these to NULL.  They will be set later if logging is on. */
name|from_server_logfile
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
name|to_server_logfile
operator|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
if|if
condition|(
name|use_authenticating_server
condition|)
block|{
comment|/* Toss the return value.  It will die with error if anything            goes wrong anyway. */
name|connect_to_pserver
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
block|{
if|#
directive|if
name|HAVE_KERBEROS
operator|||
name|USE_DIRECT_TCP
name|start_tcp_server
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|RSH_NOT_TRANSPARENT
name|start_rsh_server
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|START_SERVER
argument_list|)
name|START_SERVER
argument_list|(
operator|&
name|tofd
argument_list|,
operator|&
name|fromfd
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|server_user
argument_list|,
name|server_host
argument_list|,
name|server_cvsroot
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|NO_SOCKET_TO_FD
argument_list|)
comment|/* Avoid mixing sockets with stdio */
name|use_socket_style
operator|=
literal|1
expr_stmt|;
name|server_sock
operator|=
name|tofd
expr_stmt|;
endif|#
directive|endif
comment|/* VMS&& NO_SOCKET_TO_FD */
comment|/* "Hi, I'm Darlene and I'll be your server tonight..." */
name|server_started
operator|=
literal|1
expr_stmt|;
comment|/* Set up logfiles, if any. */
if|if
condition|(
name|log
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|log
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|len
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".in"
argument_list|)
expr_stmt|;
name|to_server_logfile
operator|=
name|open_file
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_server_logfile
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"opening to-server logfile %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|".out"
argument_list|)
expr_stmt|;
name|from_server_logfile
operator|=
name|open_file
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_server_logfile
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"opening from-server logfile %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_SOCKET_TO_FD
if|if
condition|(
operator|!
name|use_socket_style
condition|)
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
block|{
comment|/* todo: some OS's don't need these calls... */
name|close_on_exec
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|close_on_exec
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
comment|/* SCO 3 and AIX have a nasty bug in the I/O libraries which precludes 	   fdopening the same file descriptor twice, so dup it if it is the 	   same.  */
if|if
condition|(
name|tofd
operator|==
name|fromfd
condition|)
block|{
name|fromfd
operator|=
name|dup
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromfd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot dup net connection"
argument_list|)
expr_stmt|;
block|}
comment|/* These will use binary mode on systems which have it.  */
name|to_server
operator|=
name|fdopen
argument_list|(
name|tofd
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_server
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fdopen %d for write"
argument_list|,
name|tofd
argument_list|)
expr_stmt|;
name|from_server
operator|=
name|fdopen
argument_list|(
name|fromfd
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_server
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fdopen %d for read"
argument_list|,
name|fromfd
argument_list|)
expr_stmt|;
block|}
comment|/* Clear static variables.  */
if|if
condition|(
name|toplevel_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|toplevel_repos
argument_list|)
expr_stmt|;
name|toplevel_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_dir_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_dir_name
argument_list|)
expr_stmt|;
name|last_dir_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_repos
argument_list|)
expr_stmt|;
name|last_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_update_dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_update_dir
argument_list|)
expr_stmt|;
name|last_update_dir
operator|=
name|NULL
expr_stmt|;
name|stored_checksum_valid
operator|=
literal|0
expr_stmt|;
name|stored_mode_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Root "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|server_cvsroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Valid-responses"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
name|send_to_server
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|rs
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"valid-requests\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_server_responses
argument_list|()
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/*      * Now handle global options.      *      * -H, -f, -d, -e should be handled OK locally.      *      * -b we ignore (treating it as a server installation issue).      * FIXME: should be an error message.      *      * -v we print local version info; FIXME: Add a protocol request to get      * the version from the server so we can print that too.      *      * -l -t -r -w -q -n and -Q need to go to the server.      */
block|{
name|int
name|have_global
init|=
name|supported_request
argument_list|(
literal|"Global_option"
argument_list|)
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -n\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -n option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quiet
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -q\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -q option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_quiet
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -Q\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -Q option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cvswrite
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -r\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -r option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -t\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -t option."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logoff
condition|)
block|{
if|if
condition|(
name|have_global
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Global_option -l\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"This server does not support the global -l option."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gzip_level
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"gzip-file-contents"
argument_list|)
condition|)
block|{
name|char
name|gzip_level_buf
index|[
literal|5
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"gzip-file-contents "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|gzip_level_buf
argument_list|,
literal|"%d"
argument_list|,
name|gzip_level
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|gzip_level_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server doesn't support gzip-file-contents\n"
argument_list|)
expr_stmt|;
name|gzip_level
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FILENAMES_CASE_INSENSITIVE
if|if
condition|(
name|supported_request
argument_list|(
literal|"Case"
argument_list|)
condition|)
name|send_to_server
argument_list|(
literal|"Case\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If "Set" is not supported, just silently fail to send the variables.        Users with an old server should get a useful error message when it        fails to recognize the ${=foo} syntax.  This way if someone uses        several servers, some of which are new and some old, they can still        set user variables in their .cvsrc without trouble.  */
if|if
condition|(
name|supported_request
argument_list|(
literal|"Set"
argument_list|)
condition|)
name|walklist
argument_list|(
name|variable_list
argument_list|,
name|send_variable_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RSH_NOT_TRANSPARENT
end_ifndef

begin_comment
comment|/* Contact the server by starting it with rsh.  */
end_comment

begin_comment
comment|/* Right now, we have two different definitions for this function,    depending on whether we start the rsh server using popenRW or not.    This isn't ideal, and the best thing would probably be to change    the OS/2 port to be more like the regular Unix client (i.e., by    implementing piped_child)... but I'm doing something else at the    moment, and wish to make only one change at a time.  -Karl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|START_RSH_WITH_POPEN_RW
end_ifdef

begin_comment
comment|/* This is actually a crock -- it's OS/2-specific, for no one else    uses it.  If I get time, I want to make piped_child and all the    other stuff in os2/run.c work right.  In the meantime, this gets us    up and running, and that's most important. */
end_comment

begin_function
specifier|static
name|void
name|start_rsh_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|,
decl|*
name|fromfdp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
comment|/* If you're working through firewalls, you can set the      CVS_RSH environment variable to a script which uses rsh to      invoke another rsh on a proxy machine.  */
name|char
modifier|*
name|cvs_rsh
init|=
name|getenv
argument_list|(
literal|"CVS_RSH"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cvs_server
init|=
name|getenv
argument_list|(
literal|"CVS_SERVER"
argument_list|)
decl_stmt|;
name|char
name|command
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* This needs to fit "rsh", "-b", "-l", "USER", "host", 	 "cmd (w/ args)", and NULL.  We leave some room to grow. */
name|char
modifier|*
name|rsh_argv
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cvs_rsh
condition|)
name|cvs_rsh
operator|=
literal|"rsh"
expr_stmt|;
if|if
condition|(
operator|!
name|cvs_server
condition|)
name|cvs_server
operator|=
literal|"cvs"
expr_stmt|;
comment|/* If you are running a very old (Nov 3, 1994, before 1.5)    * version of the server, you need to make sure that your .bashrc    * on the server machine does not set CVSROOT to something    * containing a colon (or better yet, upgrade the server).  */
comment|/* The command line starts out with rsh. */
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|cvs_rsh
expr_stmt|;
ifdef|#
directive|ifdef
name|RSH_NEEDS_BINARY_FLAG
comment|/* "-b" for binary, under OS/2. */
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-b"
expr_stmt|;
endif|#
directive|endif
comment|/* RSH_NEEDS_BINARY_FLAG */
comment|/* Then we strcat more things on the end one by one. */
if|if
condition|(
name|server_user
operator|!=
name|NULL
condition|)
block|{
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|server_user
expr_stmt|;
block|}
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|server_host
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
name|cvs_server
expr_stmt|;
name|rsh_argv
index|[
name|i
operator|++
index|]
operator|=
literal|"server"
expr_stmt|;
comment|/* Mark the end of the arg list. */
name|rsh_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> Starting server: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Do the deed. */
name|rsh_pid
operator|=
name|popenRW
argument_list|(
name|rsh_argv
argument_list|,
name|pipes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsh_pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot start server via rsh"
argument_list|)
expr_stmt|;
comment|/* Give caller the file descriptors. */
operator|*
name|tofdp
operator|=
name|pipes
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|fromfdp
operator|=
name|pipes
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! START_RSH_WITH_POPEN_RW */
end_comment

begin_function
specifier|static
name|void
name|start_rsh_server
parameter_list|(
name|tofdp
parameter_list|,
name|fromfdp
parameter_list|)
name|int
modifier|*
name|tofdp
decl_stmt|;
name|int
modifier|*
name|fromfdp
decl_stmt|;
block|{
comment|/* If you're working through firewalls, you can set the        CVS_RSH environment variable to a script which uses rsh to        invoke another rsh on a proxy machine.  */
name|char
modifier|*
name|cvs_rsh
init|=
name|getenv
argument_list|(
literal|"CVS_RSH"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cvs_server
init|=
name|getenv
argument_list|(
literal|"CVS_SERVER"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
if|if
condition|(
operator|!
name|cvs_rsh
condition|)
name|cvs_rsh
operator|=
literal|"rsh"
expr_stmt|;
if|if
condition|(
operator|!
name|cvs_server
condition|)
name|cvs_server
operator|=
literal|"cvs"
expr_stmt|;
comment|/* Pass the command to rsh as a single string.  This shouldn't        affect most rsh servers at all, and will pacify some buggy        versions of rsh that grab switches out of the middle of the        command (they're calling the GNU getopt routines incorrectly).  */
name|command
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cvs_server
argument_list|)
operator|+
name|strlen
argument_list|(
name|server_cvsroot
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
comment|/* If you are running a very old (Nov 3, 1994, before 1.5)      * version of the server, you need to make sure that your .bashrc      * on the server machine does not set CVSROOT to something      * containing a colon (or better yet, upgrade the server).  */
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s server"
argument_list|,
name|cvs_server
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|argv
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|argv
decl_stmt|;
operator|*
name|p
operator|++
operator|=
name|cvs_rsh
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|server_host
expr_stmt|;
comment|/* If the login names differ between client and server 	 * pass it on to rsh. 	 */
if|if
condition|(
name|server_user
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|"-l"
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|server_user
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|command
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> Starting server: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|rsh_pid
operator|=
name|piped_child
argument_list|(
name|argv
argument_list|,
name|tofdp
argument_list|,
name|fromfdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsh_pid
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot start server via rsh"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* START_RSH_WITH_POPEN_RW */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! RSH_NOT_TRANSPARENT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Send an argument STRING.  */
end_comment

begin_function
name|void
name|send_arg
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|send_to_server
argument_list|(
literal|"\012Argumentx "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|send_modified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Vers_TS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_modified
parameter_list|(
name|file
parameter_list|,
name|short_pathname
parameter_list|,
name|vers
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
comment|/* File was modified, send it.  */
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|bin
decl_stmt|;
comment|/* Don't think we can assume fstat exists.  */
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* Beware: on systems using CRLF line termination conventions,        the read and write functions will convert CRLF to LF, so the        number of characters read is not the same as sb.st_size.  Text        files should always be transmitted using the LF convention, so        we don't want to disable this conversion.  */
name|bufsize
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Is the file marked as containing binary data by the "-kb" flag?        If so, make sure to open it in binary mode: */
if|if
condition|(
name|vers
operator|&&
name|vers
operator|->
name|options
condition|)
name|bin
operator|=
operator|!
operator|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|)
expr_stmt|;
else|else
name|bin
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
operator|(
name|bin
condition|?
name|OPEN_BINARY
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzip_level
operator|&&
name|sb
operator|.
name|st_size
operator|>
literal|100
condition|)
block|{
name|int
name|nread
decl_stmt|,
name|newsize
init|=
literal|0
decl_stmt|,
name|gzip_status
decl_stmt|;
name|pid_t
name|gzip_pid
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|int
name|readsize
init|=
literal|8192
decl_stmt|;
ifdef|#
directive|ifdef
name|LINES_CRLF_TERMINATED
name|char
name|tempfile
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|int
name|converting
decl_stmt|;
endif|#
directive|endif
comment|/* LINES_CRLF_TERMINATED */
ifdef|#
directive|ifdef
name|LINES_CRLF_TERMINATED
comment|/* Assume everything in a "cvs import" is text.  */
if|if
condition|(
name|vers
operator|==
name|NULL
condition|)
name|converting
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Otherwise, we convert things unless they're binary. */
name|converting
operator|=
operator|(
operator|!
name|bin
operator|)
expr_stmt|;
if|if
condition|(
name|converting
condition|)
block|{
comment|/* gzip reads and writes files without munging CRLF 	       sequences, as it should, but files should be 	       transmitted in LF form.  Convert CRLF to LF before 	       gzipping, on systems where this is necessary.  	       If Windows NT supported fork, we could do this by 	       pushing another filter on in front of gzip.  But it 	       doesn't.  I'd have to write a trivial little program to 	       do the conversion and have CVS spawn it off.  But 	       little executables like that always get lost.  	       Alternatively, this cruft could go away if we switched 	       to a gzip library instead of a subprocess; then we 	       could tell gzip to open the file with CRLF translation 	       enabled.  */
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't close %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|tmpnam
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|convert_file
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|,
name|tempfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|OPEN_BINARY
argument_list|)
expr_stmt|;
comment|/* This OPEN_BINARY doesn't make any difference, I think, because 	       gzip will deal with the inherited handle as it pleases.  But I 	       do remember something obscure in the manuals about propagating 	       the translation mode to created processes via environment 	       variables, ick.  */
name|fd
operator|=
name|open
argument_list|(
name|tempfile
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LINES_CRLF_TERMINATED */
name|fd
operator|=
name|filter_through_gzip
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
name|gzip_level
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
comment|/* FIXME: is there any reason to go through all this realloc'ing 	   when we could just be writing the data to the network as we read 	   it from gzip?  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|bufp
operator|-
name|buf
operator|)
operator|+
name|readsize
operator|>=
name|bufsize
condition|)
block|{
comment|/* 		 * We need to expand the buffer if gzip ends up expanding 		 * the file. 		 */
name|newsize
operator|=
name|bufp
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|newsize
operator|+
name|readsize
operator|>=
name|bufsize
condition|)
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
operator|+
name|newsize
expr_stmt|;
block|}
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bufp
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading from gzip pipe"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
comment|/* eof */
break|break;
name|bufp
operator|+=
name|nread
expr_stmt|;
block|}
name|newsize
operator|=
name|bufp
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't close %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|!=
name|gzip_pid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gzip proc %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"gzip exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
if|#
directive|if
name|LINES_CRLF_TERMINATED
if|if
condition|(
name|converting
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|tempfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't remove temp file %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LINES_CRLF_TERMINATED */
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Modified "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|mode_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012z"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newsize
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|newsize
decl_stmt|;
block|{
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* FIXME: This is gross.  It assumes that we might read 	       less than st_size bytes (true on NT), but not more. 	       Instead of this we should just be reading a block of 	       data (e.g. 8192 bytes), writing it to the network, and 	       so on until EOF.  */
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bufp
argument_list|,
operator|(
name|buf
operator|+
name|sb
operator|.
name|st_size
operator|)
operator|-
name|bufp
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|bufp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|bufp
operator|-
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: can't close %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Modified "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|mode_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu\012"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|newsize
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that this only ends with a newline if the file ended with 	 * one. 	 */
if|if
condition|(
name|newsize
operator|>
literal|0
condition|)
name|send_to_server
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|send_fileproc
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Deal with one file.  */
end_comment

begin_function
specifier|static
name|int
name|send_fileproc
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|options
argument_list|)
operator|+
literal|200
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"Entry /%s/%s/%s%s/%s/"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|ts_conflict
operator|==
name|NULL
condition|?
literal|""
else|:
literal|"+"
argument_list|,
operator|(
name|vers
operator|->
name|ts_conflict
operator|==
name|NULL
condition|?
literal|""
else|:
operator|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|vers
operator|->
name|ts_user
argument_list|)
operator|==
literal|0
condition|?
literal|"="
else|:
literal|"modified"
operator|)
operator|)
argument_list|,
name|vers
operator|->
name|options
argument_list|)
expr_stmt|;
comment|/* The Entries request.  */
comment|/* Not sure about whether this deals with -k and stuff right.  */
name|send_to_server
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|entdata
operator|->
name|tag
condition|)
block|{
name|send_to_server
argument_list|(
literal|"T"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|entdata
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|entdata
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|entdata
operator|->
name|date
condition|)
block|{
name|send_to_server
argument_list|(
literal|"D"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|vers
operator|->
name|entdata
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Do we want to print "file was lost" like normal CVS? 	 * Would it always be appropriate? 	 */
comment|/* File no longer exists.  */
if|if
condition|(
operator|!
name|use_unchanged
condition|)
block|{
comment|/* if the server is old, use the old request... */
name|send_to_server
argument_list|(
literal|"Lost "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	     * Otherwise, don't do anything for missing files, 	     * they just happen. 	     */
block|}
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_rcs
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|send_modified
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only use this request if the server supports it... */
if|if
condition|(
name|use_unchanged
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Unchanged "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|send_ignproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_ignproc
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
if|if
condition|(
name|ign_inhibit_server
operator|||
operator|!
name|supported_request
argument_list|(
literal|"Questionable"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"? %s/%s\n"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"? %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_to_server
argument_list|(
literal|"Questionable "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|send_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|update_dir
argument_list|,
name|send_ignproc
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Dtype
name|send_dirent_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * send_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  * A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  *  */
end_comment

begin_function
specifier|static
name|Dtype
name|send_dirent_proc
parameter_list|(
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|int
name|dir_exists
decl_stmt|;
name|char
modifier|*
name|cvsadm_repos_name
decl_stmt|;
comment|/*      * If the directory does not exist yet (e.g. "cvs update -d      * foo"), no need to send any files from it.      */
name|dir_exists
operator|=
name|isdir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * If there is an empty directory (e.g. we are doing `cvs add' on a      * newly-created directory), the server still needs to know about it.      */
name|cvsadm_repos_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_REP
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cvsadm_repos_name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_exists
operator|&&
name|isreadable
argument_list|(
name|cvsadm_repos_name
argument_list|)
condition|)
block|{
comment|/* 	 * Get the repository from a CVS/Repository file whenever possible. 	 * The repository variable is wrong if the names in the local 	 * directory don't match the names in the repository. 	 */
name|char
modifier|*
name|repos
init|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
name|send_a_repository
argument_list|(
name|dir
argument_list|,
name|repos
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
else|else
name|send_a_repository
argument_list|(
name|dir
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsadm_repos_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|dir_exists
condition|?
name|R_PROCESS
else|:
name|R_SKIP_ALL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send each option in a string to the server, one by one.  * This assumes that the options are single characters.  For  * more complex parsing, do it yourself.  */
end_comment

begin_function
name|void
name|send_option_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|it
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
name|p
index|[
literal|0
index|]
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
continue|continue;
name|it
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|it
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|it
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|send_arg
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Send the names of all the argument files to the server.  */
end_comment

begin_function
name|void
name|send_file_names
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|flags
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|max_level
decl_stmt|;
comment|/* The fact that we do this here as well as start_recursion is a bit         of a performance hit.  Perhaps worth cleaning up someday.  */
if|if
condition|(
name|flags
operator|&
name|SEND_EXPAND_WILD
condition|)
name|expand_wild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Send Max-dotdot if needed.  */
name|max_level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
operator|-
name|level
operator|>
name|max_level
condition|)
name|max_level
operator|=
operator|-
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
empty_stmt|;
else|else
operator|++
name|level
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
block|}
if|if
condition|(
name|max_level
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|supported_request
argument_list|(
literal|"Max-dotdot"
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|max_level
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Max-dotdot "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 	     * "leading .." is not strictly correct, as this also includes 	     * cases like "foo/../..".  But trying to explain that in the 	     * error message would probably just confuse users. 	     */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"leading .. not supported by old (pre-Max-dotdot) servers"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|send_to_server
argument_list|(
literal|"\012Argumentx "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIRSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SEND_EXPAND_WILD
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send Repository, Modified and Entry.  argc and argv contain only  * the files to operate on (or empty for everything), not options.  * local is nonzero if we should not recurse (-l option).  Also sends  * Argument lines for argc and argv, so should be called after options  * are sent.  */
end_comment

begin_function
name|void
name|send_files
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/*      * aflag controls whether the tag/date is copied into the vers_ts.      * But we don't actually use it, so I don't think it matters what we pass      * for aflag here.      */
name|err
operator|=
name|start_recursion
argument_list|(
name|send_fileproc
argument_list|,
name|send_filesdoneproc
argument_list|,
name|send_dirent_proc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* 	 * This happens if we are not processing any files, 	 * or for checkouts in directories without any existing stuff 	 * checked out.  The following assignment is correct for the 	 * latter case; I don't think toplevel_repos matters for the 	 * former. 	 */
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|server_cvsroot
argument_list|)
expr_stmt|;
name|send_repository
argument_list|(
literal|""
argument_list|,
name|toplevel_repos
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|client_import_setup
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* should always be true */
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the argument import file.  */
end_comment

begin_function
name|int
name|client_process_import_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|int
name|first_time
decl_stmt|;
comment|/* FIXME: I think this is always false now that we call        client_import_setup at the start.  */
name|first_time
operator|=
name|toplevel_repos
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
name|first_time
condition|)
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|repository
argument_list|,
name|toplevel_repos
argument_list|,
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: pathname `%s' doesn't specify file in `%s'"
argument_list|,
name|repository
argument_list|,
name|toplevel_repos
argument_list|)
expr_stmt|;
name|short_pathname
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|toplevel_repos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|first_time
condition|)
block|{
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
name|send_modified
argument_list|(
name|vfile
argument_list|,
name|short_pathname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|client_import_done
parameter_list|()
block|{
if|if
condition|(
name|toplevel_repos
operator|==
name|NULL
condition|)
comment|/* 	 * This happens if we are not processing any files, 	 * or for checkouts in directories without any existing stuff 	 * checked out.  The following assignment is correct for the 	 * latter case; I don't think toplevel_repos matters for the 	 * former. 	 */
comment|/* FIXME: "can't happen" now that we call client_import_setup 	   at the beginning.  */
name|toplevel_repos
operator|=
name|xstrdup
argument_list|(
name|server_cvsroot
argument_list|)
expr_stmt|;
name|send_repository
argument_list|(
literal|""
argument_list|,
name|toplevel_repos
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|notified_a_file
parameter_list|(
name|data
parameter_list|,
name|ent_list
parameter_list|,
name|short_pathname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|List
modifier|*
name|ent_list
decl_stmt|;
name|char
modifier|*
name|short_pathname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FILE
modifier|*
name|newf
decl_stmt|;
name|size_t
name|line_len
init|=
literal|8192
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|xmalloc
argument_list|(
name|line_len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|int
name|nwritten
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"malformed %s file"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|line
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: notified %s, expected %s"
argument_list|,
name|filename
argument_list|,
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|CVSADM_NOTIFY
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
name|newf
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFYTMP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|line
argument_list|,
name|newf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
while|while
condition|(
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|line_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|nwritten
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|nread
argument_list|,
name|newf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|nread
operator|-=
name|nwritten
expr_stmt|;
name|p
operator|+=
name|nwritten
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|newf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|newf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFYTMP
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
comment|/* In this case, we want rename_file() to ignore noexec. */
name|int
name|saved_noexec
init|=
name|noexec
decl_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
name|rename_file
argument_list|(
name|CVSADM_NOTIFYTMP
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|saved_noexec
expr_stmt|;
block|}
return|return;
name|error2
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|newf
argument_list|)
expr_stmt|;
name|error_exit
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_notified
parameter_list|(
name|args
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|call_in_directory
argument_list|(
name|args
argument_list|,
name|notified_a_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|client_notify
parameter_list|(
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|filename
parameter_list|,
name|notif_type
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|notif_type
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Notify "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|notif_type
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|send_to_server
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Send an option with an argument, dealing correctly with newlines in  * the argument.  If ARG is NULL, forget the whole thing.  */
end_comment

begin_function
name|void
name|option_with_arg
parameter_list|(
name|option
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a date to the server.  This will passed a string which is the  * result of Make_Date, and looks like YY.MM.DD.HH.MM.SS, where all  * the letters are single digits.  The time will be GMT.  getdate on  * the server can't parse that, so we turn it back into something  * which it can parse.  */
end_comment

begin_function
name|void
name|client_senddate
parameter_list|(
name|date
parameter_list|)
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"diff_client_senddate: sscanf failed on date"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|HAVE_RCS5
comment|/* We need to fix the timezone in this case; see Make_Date.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_RCS5 */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d/%d/%d %d:%d:%d GMT"
argument_list|,
name|month
argument_list|,
name|day
argument_list|,
name|year
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-D"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|client_commit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|commit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|client_update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|update
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|client_checkout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|checkout
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|client_diff
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|diff
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_status
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|status
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|client_log
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|cvslog
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_add
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|add
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_remove
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|cvsremove
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_rdiff
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|patch
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_tag
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|tag
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_rtag
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|rtag
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_import
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|import
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_admin
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|admin
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_export
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|checkout
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_history
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|history
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_release
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|release
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_watch
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|watch
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_watchers
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|watchers
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_editors
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|editors
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_edit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|edit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_unedit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|unedit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|void
name|send_init_command
parameter_list|()
block|{
comment|/* This is here because we need the server_cvsroot variable.  */
name|send_to_server
argument_list|(
literal|"init "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|server_cvsroot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|client_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_function
name|int
name|client_annotate
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|parse_cvsroot
argument_list|()
expr_stmt|;
return|return
name|annotate
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
comment|/* Call real code */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

end_unit

