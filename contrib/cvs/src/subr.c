begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * Various useful functions for the CVS support code.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * malloc some data and die if it fails  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Parts of CVS try to xmalloc zero bytes and then free it.  Some        systems have a malloc which returns NULL for zero byte        allocations but a free which can't handle NULL, so compensate. */
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
name|bytes
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can not allocate %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * realloc data and die if it fails [I've always wanted to have "realloc" do  * a "malloc" if the argument is NULL, but you can't depend on it.  Here, I  * can *force* it.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|bytes
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can not reallocate %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Two constants which tune expand_string.  Having MIN_INCR as large    as 1024 might waste a bit of memory, but it shouldn't be too bad    (CVS used to allocate arrays of, say, 3000, PATH_MAX (8192, often),    or other such sizes).  Probably anything which is going to allocate    memory which is likely to get as big as MAX_INCR shouldn't be doing    it in one block which must be contiguous, but since getrcskey does    so, we might as well limit the wasted memory to MAX_INCR or so    bytes.  */
end_comment

begin_define
define|#
directive|define
name|MIN_INCR
value|1024
end_define

begin_define
define|#
directive|define
name|MAX_INCR
value|(2*1024*1024)
end_define

begin_comment
comment|/* *STRPTR is a pointer returned from malloc (or NULL), pointing to *N    characters of space.  Reallocate it so that points to at least    NEWSIZE bytes of space.  Gives a fatal error if out of memory;    if it returns it was successful.  */
end_comment

begin_function
name|void
name|expand_string
parameter_list|(
name|strptr
parameter_list|,
name|n
parameter_list|,
name|newsize
parameter_list|)
name|char
modifier|*
modifier|*
name|strptr
decl_stmt|;
name|size_t
modifier|*
name|n
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|n
operator|<
name|newsize
condition|)
block|{
while|while
condition|(
operator|*
name|n
operator|<
name|newsize
condition|)
block|{
if|if
condition|(
operator|*
name|n
operator|<
name|MIN_INCR
condition|)
operator|*
name|n
operator|+=
name|MIN_INCR
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|n
operator|>
name|MAX_INCR
condition|)
operator|*
name|n
operator|+=
name|MAX_INCR
expr_stmt|;
else|else
operator|*
name|n
operator|*=
literal|2
expr_stmt|;
block|}
operator|*
name|strptr
operator|=
name|xrealloc
argument_list|(
operator|*
name|strptr
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Duplicate a string, calling xmalloc to allocate some dynamic space  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|s
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove trailing newlines from STRING, destructively. */
end_comment

begin_function
name|void
name|strip_trailing_newlines
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|str
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
name|str
index|[
name|len
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of levels that path ascends above where it starts.    For example:    "../../foo" -> 2    "foo/../../bar" -> 1    */
end_comment

begin_comment
comment|/* FIXME: Should be using ISDIRSEP, last_component, or some other    mechanism which is more general than just looking at slashes,    particularly for the client.c caller.  The server.c caller might    want something different, so be careful.  */
end_comment

begin_function
name|int
name|pathname_levels
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|max_level
decl_stmt|;
name|max_level
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
operator|-
name|level
operator|>
name|max_level
condition|)
name|max_level
operator|=
operator|-
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
empty_stmt|;
else|else
operator|++
name|level
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
return|return
name|max_level
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free a vector, where (*ARGV)[0], (*ARGV)[1], ... (*ARGV)[*PARGC - 1]    are malloc'd and so is *ARGV itself.  Such a vector is allocated by    line2argv or expand_wild, for example.  */
end_comment

begin_function
name|void
name|free_names
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
name|i
operator|++
control|)
block|{
comment|/* only do through *pargc */
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
comment|/* and set it to zero when done */
block|}
end_function

begin_comment
comment|/* Convert LINE into arguments separated by space and tab.  Set *ARGC    to the number of arguments found, and (*ARGV)[0] to the first argument,    (*ARGV)[1] to the second, etc.  *ARGV is malloc'd and so are each of    (*ARGV)[0], (*ARGV)[1], ...  Use free_names() to return the memory    allocated here back to the free pool.  */
end_comment

begin_function
name|void
name|line2argv
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|line
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Could make a case for size_t or some other unsigned type, but        we'll stick with int to avoid signed/unsigned warnings when        comparing with *pargc.  */
name|int
name|argv_allocated
decl_stmt|;
comment|/* Small for testing.  */
comment|/* argv_allocated must be at least 3 because at some places        (e.g. checkout_proc) cvs alters argv[2].  */
name|argv_allocated
operator|=
literal|4
expr_stmt|;
operator|*
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argv_allocated
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|pargc
operator|==
name|argv_allocated
condition|)
block|{
name|argv_allocated
operator|*=
literal|2
expr_stmt|;
operator|*
name|argv
operator|=
name|xrealloc
argument_list|(
operator|*
name|argv
argument_list|,
name|argv_allocated
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|argv
operator|)
index|[
operator|*
name|pargc
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pargc
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the number of dots ('.') found in an RCS revision number  */
end_comment

begin_function
name|int
name|numdots
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|dots
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|dots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|dots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the caller's login from his uid. If the real uid is "root" try LOGNAME  * USER or getlogin(). If getlogin() and getpwuid() both fail, return  * the uid as a string.  */
end_comment

begin_function
name|char
modifier|*
name|getcaller
parameter_list|()
block|{
specifier|static
name|char
name|uidname
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
comment|/* super-user; try getlogin() to distinguish */
if|if
condition|(
operator|(
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
operator|||
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|||
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|)
operator|&&
operator|*
name|name
condition|)
return|return
operator|(
name|name
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uidname
argument_list|,
literal|"uid%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|uidname
operator|)
return|;
block|}
return|return
operator|(
name|pw
operator|->
name|pw_name
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|time_t
name|get_date
parameter_list|(
name|date
parameter_list|,
name|now
parameter_list|)
name|char
modifier|*
name|date
decl_stmt|;
name|struct
name|timeb
modifier|*
name|now
decl_stmt|;
block|{
name|time_t
name|foo
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|foo
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given two revisions, find their greatest common ancestor.  If the    two input revisions exist, then rcs guarantees that the gca will    exist.  */
end_comment

begin_function
name|char
modifier|*
name|gca
parameter_list|(
name|rev1
parameter_list|,
name|rev2
parameter_list|)
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|gca
decl_stmt|;
name|char
modifier|*
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|j
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|rev2
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sanity failure in gca"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The greatest common ancestor will have no more dots, and numbers        of digits for each component no greater than the arguments.  Therefore        this string will be big enough.  */
name|gca
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev1
argument_list|)
operator|+
name|strlen
argument_list|(
name|rev2
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
comment|/* walk the strings, reading the common parts. */
name|gca
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|rev1
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|rev2
expr_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|s
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
comment|/* swap out the dot */
name|s
index|[
name|i
index|]
operator|=
name|strchr
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|c
index|[
name|i
index|]
operator|=
operator|*
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* read an int */
name|j
index|[
name|i
index|]
operator|=
name|atoi
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* swap back the dot... */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
operator|*
name|s
index|[
name|i
index|]
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* or mark us at the end */
name|p
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* use the lowest. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gca
operator|+
name|strlen
argument_list|(
name|gca
argument_list|)
argument_list|,
literal|"%d."
argument_list|,
name|j
index|[
literal|0
index|]
operator|<
name|j
index|[
literal|1
index|]
condition|?
name|j
index|[
literal|0
index|]
else|:
name|j
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|j
index|[
literal|0
index|]
operator|==
name|j
index|[
literal|1
index|]
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
do|;
comment|/* back up over that last dot. */
name|gca
index|[
name|strlen
argument_list|(
name|gca
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* numbers differ, or we ran out of strings.  we're done with the        common parts.  */
name|dots
operator|=
name|numdots
argument_list|(
name|gca
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|==
literal|0
condition|)
block|{
comment|/* revisions differ in trunk major number.  */
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|j
index|[
literal|0
index|]
operator|<
name|j
index|[
literal|1
index|]
operator|)
condition|?
name|p
index|[
literal|0
index|]
else|:
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* we only got one number.  this is strange.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad revisions %s or %s"
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a minor number.  use it.  */
name|q
operator|=
name|gca
operator|+
name|strlen
argument_list|(
name|gca
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* if we have an even number of dots, then we have a branch. 	   remove the last number in order to make it a revision.  */
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strrchr
argument_list|(
name|gca
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|retval
operator|=
name|xstrdup
argument_list|(
name|gca
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gca
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  *  Sanity checks and any required fix-up on message passed to RCS via '-m'.  *  RCS 5.7 requires that a non-total-whitespace, non-null message be provided  *  with '-m'.  Returns the original argument or a pointer to readonly  *  static storage.  */
end_comment

begin_function
name|char
modifier|*
name|make_message_rcslegal
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|message
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|message
operator|==
literal|'\0'
operator|)
operator|||
name|isspace
argument_list|(
operator|*
name|message
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|message
condition|)
for|for
control|(
name|t
operator|=
name|message
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return
name|message
return|;
return|return
literal|"*** empty log message ***\n"
return|;
block|}
return|return
name|message
return|;
block|}
end_function

begin_comment
comment|/* Does the file FINFO contain conflict markers?  The whole concept    of looking at the contents of the file to figure out whether there are    unresolved conflicts is kind of bogus (people do want to manage files    which contain those patterns not as conflict markers), but for now it    is what we do.  */
end_comment

begin_function
name|int
name|file_has_markers
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|RCS_MERGE_PAT
argument_list|,
sizeof|sizeof
name|RCS_MERGE_PAT
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

