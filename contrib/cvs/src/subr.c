begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Various useful functions for the CVS support code.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * malloc some data and die if it fails  */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Parts of CVS try to xmalloc zero bytes and then free it.  Some        systems have a malloc which returns NULL for zero byte        allocations but a free which can't handle NULL, so compensate. */
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
name|bytes
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory; can not allocate %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * realloc data and die if it fails [I've always wanted to have "realloc" do  * a "malloc" if the argument is NULL, but you can't depend on it.  Here, I  * can *force* it.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|bytes
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can not reallocate %lu bytes"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Two constants which tune expand_string.  Having MIN_INCR as large    as 1024 might waste a bit of memory, but it shouldn't be too bad    (CVS used to allocate arrays of, say, 3000, PATH_MAX (8192, often),    or other such sizes).  Probably anything which is going to allocate    memory which is likely to get as big as MAX_INCR shouldn't be doing    it in one block which must be contiguous, but since getrcskey does    so, we might as well limit the wasted memory to MAX_INCR or so    bytes.  */
end_comment

begin_define
define|#
directive|define
name|MIN_INCR
value|1024
end_define

begin_define
define|#
directive|define
name|MAX_INCR
value|(2*1024*1024)
end_define

begin_comment
comment|/* *STRPTR is a pointer returned from malloc (or NULL), pointing to *N    characters of space.  Reallocate it so that points to at least    NEWSIZE bytes of space.  Gives a fatal error if out of memory;    if it returns it was successful.  */
end_comment

begin_function
name|void
name|expand_string
parameter_list|(
name|strptr
parameter_list|,
name|n
parameter_list|,
name|newsize
parameter_list|)
name|char
modifier|*
modifier|*
name|strptr
decl_stmt|;
name|size_t
modifier|*
name|n
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|n
operator|<
name|newsize
condition|)
block|{
while|while
condition|(
operator|*
name|n
operator|<
name|newsize
condition|)
block|{
if|if
condition|(
operator|*
name|n
operator|<
name|MIN_INCR
condition|)
operator|*
name|n
operator|+=
name|MIN_INCR
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|n
operator|>
name|MAX_INCR
condition|)
operator|*
name|n
operator|+=
name|MAX_INCR
expr_stmt|;
else|else
operator|*
name|n
operator|*=
literal|2
expr_stmt|;
block|}
operator|*
name|strptr
operator|=
name|xrealloc
argument_list|(
operator|*
name|strptr
argument_list|,
operator|*
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Duplicate a string, calling xmalloc to allocate some dynamic space  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|s
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove trailing newlines from STRING, destructively. */
end_comment

begin_function
name|void
name|strip_trailing_newlines
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|str
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
name|str
index|[
name|len
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of levels that path ascends above where it starts.    For example:    "../../foo" -> 2    "foo/../../bar" -> 1    */
end_comment

begin_comment
comment|/* FIXME: Should be using ISDIRSEP, last_component, or some other    mechanism which is more general than just looking at slashes,    particularly for the client.c caller.  The server.c caller might    want something different, so be careful.  */
end_comment

begin_function
name|int
name|pathname_levels
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|max_level
decl_stmt|;
name|max_level
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
operator|-
name|level
operator|>
name|max_level
condition|)
name|max_level
operator|=
operator|-
name|level
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
empty_stmt|;
else|else
operator|++
name|level
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|NULL
condition|)
do|;
return|return
name|max_level
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free a vector, where (*ARGV)[0], (*ARGV)[1], ... (*ARGV)[*PARGC - 1]    are malloc'd and so is *ARGV itself.  Such a vector is allocated by    line2argv or expand_wild, for example.  */
end_comment

begin_function
name|void
name|free_names
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
name|i
operator|++
control|)
block|{
comment|/* only do through *pargc */
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
comment|/* and set it to zero when done */
block|}
end_function

begin_comment
comment|/* Convert LINE into arguments separated by SEPCHARS.  Set *ARGC    to the number of arguments found, and (*ARGV)[0] to the first argument,    (*ARGV)[1] to the second, etc.  *ARGV is malloc'd and so are each of    (*ARGV)[0], (*ARGV)[1], ...  Use free_names() to return the memory    allocated here back to the free pool.  */
end_comment

begin_function
name|void
name|line2argv
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|line
parameter_list|,
name|sepchars
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|sepchars
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Could make a case for size_t or some other unsigned type, but        we'll stick with int to avoid signed/unsigned warnings when        comparing with *pargc.  */
name|int
name|argv_allocated
decl_stmt|;
comment|/* Small for testing.  */
comment|/* argv_allocated must be at least 3 because at some places        (e.g. checkout_proc) cvs alters argv[2].  */
name|argv_allocated
operator|=
literal|4
expr_stmt|;
operator|*
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argv_allocated
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pargc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
name|sepchars
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|sepchars
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|pargc
operator|==
name|argv_allocated
condition|)
block|{
name|argv_allocated
operator|*=
literal|2
expr_stmt|;
operator|*
name|argv
operator|=
name|xrealloc
argument_list|(
operator|*
name|argv
argument_list|,
name|argv_allocated
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|argv
operator|)
index|[
operator|*
name|pargc
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pargc
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns the number of dots ('.') found in an RCS revision number  */
end_comment

begin_function
name|int
name|numdots
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|dots
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|dots
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|dots
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compare revision numbers REV1 and REV2 by consecutive fields.    Return negative, zero, or positive in the manner of strcmp.  The    two revision numbers must have the same number of fields, or else    compare_revnums will return an inaccurate result. */
end_comment

begin_function
name|int
name|compare_revnums
parameter_list|(
name|rev1
parameter_list|,
name|rev2
parameter_list|)
specifier|const
name|char
modifier|*
name|rev1
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|snext
decl_stmt|,
modifier|*
name|tnext
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|sp
operator|=
name|s
operator|=
name|rev1
expr_stmt|;
name|tp
operator|=
name|t
operator|=
name|rev2
expr_stmt|;
while|while
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|strtoul
argument_list|(
name|sp
argument_list|,
operator|&
name|snext
argument_list|,
literal|10
argument_list|)
operator|-
name|strtoul
argument_list|(
name|tp
argument_list|,
operator|&
name|tnext
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|snext
operator|==
literal|'\0'
operator|||
operator|*
name|tnext
operator|==
literal|'\0'
condition|)
break|break;
name|sp
operator|=
name|snext
operator|+
literal|1
expr_stmt|;
name|tp
operator|=
name|tnext
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|increment_revnum
parameter_list|(
name|rev
parameter_list|)
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
modifier|*
name|newrev
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|lastfield
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|rev
argument_list|)
decl_stmt|;
name|newrev
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newrev
argument_list|,
name|rev
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|newrev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lastfield
operator|=
name|atoi
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|lastfield
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|newrev
return|;
block|}
end_function

begin_comment
comment|/* Return the username by which the caller should be identified in    CVS, in contexts such as the author field of RCS files, various    logs, etc.     Returns a pointer to storage that we manage; it is good until the    next call to getcaller () (provided that the caller doesn't call    getlogin () or some such themself).  */
end_comment

begin_function
name|char
modifier|*
name|getcaller
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|SYSTEM_GETCALLER
specifier|static
name|char
name|uidname
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
endif|#
directive|endif
comment|/* If there is a CVS username, return it.  */
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
if|if
condition|(
name|CVS_Username
operator|!=
name|NULL
condition|)
return|return
name|CVS_Username
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSTEM_GETCALLER
return|return
name|SYSTEM_GETCALLER
argument_list|()
return|;
else|#
directive|else
comment|/* Get the caller's login from his uid.  If the real uid is "root"        try LOGNAME USER or getlogin(). If getlogin() and getpwuid()        both fail, return the uid as a string.  */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
comment|/* super-user; try getlogin() to distinguish */
if|if
condition|(
operator|(
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
operator|||
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|||
operator|(
name|name
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|)
operator|&&
operator|*
name|name
condition|)
return|return
operator|(
name|name
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uidname
argument_list|,
literal|"uid%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|uidname
operator|)
return|;
block|}
return|return
operator|(
name|pw
operator|->
name|pw_name
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|time_t
name|get_date
parameter_list|(
name|date
parameter_list|,
name|now
parameter_list|)
name|char
modifier|*
name|date
decl_stmt|;
name|struct
name|timeb
modifier|*
name|now
decl_stmt|;
block|{
name|time_t
name|foo
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|foo
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given two revisions, find their greatest common ancestor.  If the    two input revisions exist, then rcs guarantees that the gca will    exist.  */
end_comment

begin_function
name|char
modifier|*
name|gca
parameter_list|(
name|rev1
parameter_list|,
name|rev2
parameter_list|)
specifier|const
name|char
modifier|*
name|rev1
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|gca
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|j
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|rev2
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sanity failure in gca"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The greatest common ancestor will have no more dots, and numbers        of digits for each component no greater than the arguments.  Therefore        this string will be big enough.  */
name|gca
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev1
argument_list|)
operator|+
name|strlen
argument_list|(
name|rev2
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
comment|/* walk the strings, reading the common parts. */
name|gca
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|rev1
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|rev2
expr_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|s
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
comment|/* swap out the dot */
name|s
index|[
name|i
index|]
operator|=
name|strchr
argument_list|(
name|p
index|[
name|i
index|]
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|c
index|[
name|i
index|]
operator|=
operator|*
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* read an int */
name|j
index|[
name|i
index|]
operator|=
name|atoi
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* swap back the dot... */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
operator|*
name|s
index|[
name|i
index|]
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* or mark us at the end */
name|p
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* use the lowest. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gca
operator|+
name|strlen
argument_list|(
name|gca
argument_list|)
argument_list|,
literal|"%d."
argument_list|,
name|j
index|[
literal|0
index|]
operator|<
name|j
index|[
literal|1
index|]
condition|?
name|j
index|[
literal|0
index|]
else|:
name|j
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|j
index|[
literal|0
index|]
operator|==
name|j
index|[
literal|1
index|]
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
do|;
comment|/* back up over that last dot. */
name|gca
index|[
name|strlen
argument_list|(
name|gca
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* numbers differ, or we ran out of strings.  we're done with the        common parts.  */
name|dots
operator|=
name|numdots
argument_list|(
name|gca
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|==
literal|0
condition|)
block|{
comment|/* revisions differ in trunk major number.  */
name|char
modifier|*
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|j
index|[
literal|0
index|]
operator|<
name|j
index|[
literal|1
index|]
operator|)
condition|?
name|p
index|[
literal|0
index|]
else|:
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* we only got one number.  this is strange.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad revisions %s or %s"
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a minor number.  use it.  */
name|q
operator|=
name|gca
operator|+
name|strlen
argument_list|(
name|gca
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'.'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* if we have an even number of dots, then we have a branch. 	   remove the last number in order to make it a revision.  */
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strrchr
argument_list|(
name|gca
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|retval
operator|=
name|xstrdup
argument_list|(
name|gca
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gca
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Give fatal error if REV is numeric and ARGC,ARGV imply we are    planning to operate on more than one file.  The current directory    should be the working directory.  Note that callers assume that we    will only be checking the first character of REV; it need not have    '\0' at the end of the tag name and other niceties.  Right now this    is only called from admin.c, but if people like the concept it probably    should also be called from diff -r, update -r, get -r, and log -r.  */
end_comment

begin_function
name|void
name|check_numeric
parameter_list|(
name|rev
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return;
comment|/* Note that the check for whether we are processing more than one        file is (basically) syntactic; that is, we don't behave differently        depending on whether a directory happens to contain only a single        file or whether it contains more than one.  I strongly suspect this        is the least confusing behavior.  */
if|if
condition|(
name|argc
operator|!=
literal|1
operator|||
operator|(
operator|!
name|wrap_name_has
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"while processing more than one file:"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"attempt to specify a numeric revision"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Sanity checks and any required fix-up on message passed to RCS via '-m'.  *  RCS 5.7 requires that a non-total-whitespace, non-null message be provided  *  with '-m'.  Returns a newly allocated, non-empty buffer with whitespace  *  stripped from end of lines and end of buffer.  *  *  TODO: We no longer use RCS to manage repository files, so maybe this  *  nonsense about non-empty log fields can be dropped.  */
end_comment

begin_function
name|char
modifier|*
name|make_message_rcslegal
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|message
operator|==
name|NULL
condition|)
name|message
operator|=
literal|""
expr_stmt|;
comment|/* Strip whitespace from end of lines and end of string. */
name|dp
operator|=
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|message
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|message
init|;
operator|*
name|mp
operator|!=
literal|'\0'
condition|;
operator|++
name|mp
control|)
block|{
if|if
condition|(
operator|*
name|mp
operator|==
literal|'\n'
condition|)
block|{
comment|/* At end-of-line; backtrack to last non-space. */
while|while
condition|(
name|dp
operator|>
name|dst
operator|&&
operator|(
name|dp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|dp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|dp
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
operator|*
name|mp
expr_stmt|;
block|}
comment|/* Backtrack to last non-space at end of string, and truncate. */
while|while
condition|(
name|dp
operator|>
name|dst
operator|&&
name|isspace
argument_list|(
name|dp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|dp
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
comment|/* After all that, if there was no non-space in the string,        substitute a non-empty message. */
if|if
condition|(
operator|*
name|dst
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|=
name|xstrdup
argument_list|(
literal|"*** empty log message ***"
argument_list|)
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* Does the file FINFO contain conflict markers?  The whole concept    of looking at the contents of the file to figure out whether there are    unresolved conflicts is kind of bogus (people do want to manage files    which contain those patterns not as conflict markers), but for now it    is what we do.  */
end_comment

begin_function
name|int
name|file_has_markers
parameter_list|(
name|finfo
parameter_list|)
specifier|const
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|RCS_MERGE_PAT
argument_list|,
sizeof|sizeof
name|RCS_MERGE_PAT
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Read the entire contents of the file NAME into *BUF.    If NAME is NULL, read from stdin.  *BUF    is a pointer returned from malloc (or NULL), pointing to *BUFSIZE    bytes of space.  The actual size is returned in *LEN.  On error,    give a fatal error.  The name of the file to use in error messages    (typically will include a directory if we have changed directory)    is FULLNAME.  MODE is "r" for text or "rb" for binary.  */
end_comment

begin_function
name|void
name|get_file
parameter_list|(
name|name
parameter_list|,
name|fullname
parameter_list|,
name|mode
parameter_list|,
name|buf
parameter_list|,
name|bufsize
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|fullname
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|size_t
modifier|*
name|bufsize
decl_stmt|;
name|size_t
modifier|*
name|len
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
name|char
modifier|*
name|tobuf
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|size_t
name|filesize
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|e
operator|=
name|stdin
expr_stmt|;
name|filesize
operator|=
literal|100
expr_stmt|;
comment|/* force allocation of minimum buffer */
block|}
else|else
block|{
if|if
condition|(
name|CVS_STAT
argument_list|(
name|name
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't stat %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* Convert from signed to unsigned.  */
name|filesize
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|e
operator|=
name|open_file
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bufsize
operator|<
name|filesize
condition|)
block|{
operator|*
name|bufsize
operator|=
name|filesize
expr_stmt|;
operator|*
name|buf
operator|=
name|xrealloc
argument_list|(
operator|*
name|buf
argument_list|,
operator|*
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|tobuf
operator|=
operator|*
name|buf
expr_stmt|;
name|nread
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|got
decl_stmt|;
name|got
operator|=
name|fread
argument_list|(
name|tobuf
argument_list|,
literal|1
argument_list|,
operator|*
name|bufsize
operator|-
operator|(
name|tobuf
operator|-
operator|*
name|buf
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|e
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't read %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|nread
operator|+=
name|got
expr_stmt|;
name|tobuf
operator|+=
name|got
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|e
argument_list|)
condition|)
break|break;
comment|/* It's probably paranoid to think S.ST_SIZE might be 	   too small to hold the entire file contents, but we 	   handle it just in case.  */
if|if
condition|(
name|tobuf
operator|==
operator|*
name|buf
operator|+
operator|*
name|bufsize
condition|)
block|{
name|int
name|c
decl_stmt|;
name|long
name|off
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|off
operator|=
name|tobuf
operator|-
operator|*
name|buf
expr_stmt|;
name|expand_string
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
operator|*
name|bufsize
operator|+
literal|100
argument_list|)
expr_stmt|;
name|tobuf
operator|=
operator|*
name|buf
operator|+
name|off
expr_stmt|;
operator|*
name|tobuf
operator|++
operator|=
name|c
expr_stmt|;
operator|++
name|nread
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|!=
name|stdin
operator|&&
name|fclose
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|nread
expr_stmt|;
comment|/* Force *BUF to be large enough to hold a null terminator. */
if|if
condition|(
operator|*
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nread
operator|==
operator|*
name|bufsize
condition|)
name|expand_string
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
operator|*
name|bufsize
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
name|nread
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

end_unit

