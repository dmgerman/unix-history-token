begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation for "cvs edit", "cvs watch on", and related commands     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|watch_onoff
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setting_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|turning_on
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setting_tedit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setting_tunedit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setting_tcommit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|onoff_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|onoff_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|fileattr_set
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|,
name|turning_on
condition|?
literal|""
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|onoff_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|onoff_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|setting_default
condition|)
name|fileattr_set
argument_list|(
name|NULL
argument_list|,
literal|"_watched"
argument_list|,
name|turning_on
condition|?
literal|""
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|watch_onoff
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|watch_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|turning_on
condition|?
literal|"watch-on\012"
else|:
literal|"watch-off\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|setting_default
operator|=
operator|(
name|argc
operator|<=
literal|0
operator|)
expr_stmt|;
name|lock_tree_for_write
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|onoff_fileproc
argument_list|,
name|onoff_filesdoneproc
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|watch_on
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|turning_on
operator|=
literal|1
expr_stmt|;
return|return
name|watch_onoff
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|watch_off
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|turning_on
operator|=
literal|0
expr_stmt|;
return|return
name|watch_onoff
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|dummy_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dummy_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
comment|/* This is a pretty hideous hack, but the gist of it is that recurse.c        won't call notify_check unless there is a fileproc, so we can't just        pass NULL for fileproc.  */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ncheck_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Check for and process notifications.  Local only.  I think that doing    this as a fileproc is the only way to catch all the    cases (e.g. foo/bar.c), even though that means checking over and over    for the same CVSADM_NOTIFY file which we removed the first time we    processed the directory.  */
end_comment

begin_function
specifier|static
name|int
name|ncheck_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|int
name|notif_type
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|watches
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_len
init|=
literal|0
decl_stmt|;
comment|/* We send notifications even if noexec.  I'm not sure which behavior        is most sensible.  */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|notif_type
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|notif_type
operator|==
literal|'\0'
condition|)
continue|continue;
name|filename
operator|=
name|line
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|val
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|watches
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|notify_do
argument_list|(
name|notif_type
argument_list|,
name|filename
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|val
argument_list|,
name|watches
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|CVSADM_NOTIFY
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|send_notifications
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look through the CVSADM_NOTIFY file and process each item there    accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|send_notifications
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* OK, we've done everything which needs to happen on the client side.        Now we can try to contact the server; if we fail, then the        notifications stay in CVSADM_NOTIFY to be sent next time.  */
if|if
condition|(
name|client_active
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"release"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
block|}
name|err
operator|+=
name|start_recursion
argument_list|(
name|dummy_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"noop\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"release"
argument_list|)
operator|==
literal|0
condition|)
name|err
operator|+=
name|get_server_responses
argument_list|()
expr_stmt|;
else|else
name|err
operator|+=
name|get_responses_and_close
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Local.  */
name|lock_tree_for_write
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|start_recursion
argument_list|(
name|ncheck_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|edit_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|edit_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|ascnow
decl_stmt|;
name|char
modifier|*
name|basefilename
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
literal|0
return|;
comment|/* This is a somewhat screwy way to check for this, because it        doesn't help errors other than the nonexistence of the file        (e.g. permissions problems).  It might be better to rearrange        the code so that CVSADM_NOTIFY gets written only after the        various actions succeed (but what if only some of them        succeed).  */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"no such file %s; ignored"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ascnow
operator|=
name|asctime
argument_list|(
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|ascnow
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"E%s\t%s GMT\t%s\t%s\t"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|ascnow
argument_list|,
name|hostname
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|setting_tedit
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"E"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setting_tunedit
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"U"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setting_tcommit
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s/%s"
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
block|}
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now stash the file away in CVSADM so that unedit can revert even if        it can't communicate with the server.  We stash away a writable        copy so that if the user removes the working file, then restores it        with "cvs update" (which clears _editors but does not update        CVSADM_BASE), then a future "cvs edit" can still win.  */
comment|/* Could save a system call by only calling mkdir_if_needed if        trying to create the output file fails.  But copy_file isn't        set up to facilitate that.  */
name|mkdir_if_needed
argument_list|(
name|CVSADM_BASE
argument_list|)
expr_stmt|;
name|basefilename
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
sizeof|sizeof
name|CVSADM_BASE
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|basefilename
argument_list|,
name|CVSADM_BASE
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|basefilename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|basefilename
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|basefilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basefilename
argument_list|)
expr_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|findnode_fn
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|base_register
argument_list|(
name|finfo
argument_list|,
operator|(
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
operator|)
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|edit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lR] [files...]\n"
block|,
literal|"-l: Local directory only, not recursive\n"
block|,
literal|"-R: Process directories recursively\n"
block|,
literal|"-a: Specify what actions for temporary watch, one of\n"
block|,
literal|"    edit,unedit,commit,all,none\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|edit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|a_omitted
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|edit_usage
argument_list|)
expr_stmt|;
name|a_omitted
operator|=
literal|1
expr_stmt|;
name|setting_tedit
operator|=
literal|0
expr_stmt|;
name|setting_tunedit
operator|=
literal|0
expr_stmt|;
name|setting_tcommit
operator|=
literal|0
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lRa:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|a_omitted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"edit"
argument_list|)
operator|==
literal|0
condition|)
name|setting_tedit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"unedit"
argument_list|)
operator|==
literal|0
condition|)
name|setting_tunedit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"commit"
argument_list|)
operator|==
literal|0
condition|)
name|setting_tcommit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|setting_tedit
operator|=
literal|1
expr_stmt|;
name|setting_tunedit
operator|=
literal|1
expr_stmt|;
name|setting_tcommit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|setting_tedit
operator|=
literal|0
expr_stmt|;
name|setting_tunedit
operator|=
literal|0
expr_stmt|;
name|setting_tcommit
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
name|edit_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|edit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|a_omitted
condition|)
block|{
name|setting_tedit
operator|=
literal|1
expr_stmt|;
name|setting_tunedit
operator|=
literal|1
expr_stmt|;
name|setting_tcommit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strpbrk
argument_list|(
name|hostname
argument_list|,
literal|"+,>;=\t\n"
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"host name (%s) contains an invalid character (+,>;=\\t\\n)"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strpbrk
argument_list|(
name|CurDir
argument_list|,
literal|"+,>;=\t\n"
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"current directory (%s) contains an invalid character (+,>;=\\t\\n)"
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
comment|/* No need to readlock since we aren't doing anything to the        repository.  */
name|err
operator|=
name|start_recursion
argument_list|(
name|edit_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|send_notifications
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|unedit_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|unedit_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|ascnow
decl_stmt|;
name|char
modifier|*
name|basefilename
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
literal|0
return|;
name|basefilename
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
sizeof|sizeof
name|CVSADM_BASE
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|basefilename
argument_list|,
name|CVSADM_BASE
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|basefilename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|basefilename
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|basefilename
argument_list|)
condition|)
block|{
comment|/* This file apparently was never cvs edit'd (e.g. we are uneditting 	   a directory where only some of the files were cvs edit'd.  */
name|free
argument_list|(
name|basefilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|xcmp
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|basefilename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s has been modified; revert changes? "
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yesno
argument_list|()
condition|)
block|{
comment|/* "no".  */
name|free
argument_list|(
name|basefilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|rename_file
argument_list|(
name|basefilename
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basefilename
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ascnow
operator|=
name|asctime
argument_list|(
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|ascnow
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"U%s\t%s GMT\t%s\t%s\t\n"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|ascnow
argument_list|,
name|hostname
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s/%s"
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
block|}
comment|/* Now update the revision number in CVS/Entries from CVS/Baserev.        The basic idea here is that we are reverting to the revision        that the user edited.  If we wanted "cvs update" to update        CVS/Base as we go along (so that an unedit could revert to the        current repository revision), we would need:         update (or all send_files?) (client) needs to send revision in        new Entry-base request.  update (server/local) needs to check        revision against repository and send new Update-base response        (like Update-existing in that the file already exists.  While        we are at it, might try to clean up the syntax by having the        mode only in a "Mode" response, not in the Update-base itself).  */
block|{
name|char
modifier|*
name|baserev
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
name|baserev
operator|=
name|base_get
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
name|node
operator|=
name|findnode_fn
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* The case where node is NULL probably should be an error or 	   something, but I don't want to think about it too hard right 	   now.  */
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|baserev
operator|==
name|NULL
condition|)
block|{
comment|/* This can only happen if the CVS/Baserev file got 		   corrupted.  We suspect it might be possible if the 		   user interrupts CVS, although I haven't verified 		   that.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s not mentioned in %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|CVSADM_BASEREV
argument_list|)
expr_stmt|;
comment|/* Since we don't know what revision the file derives from, 		   keeping it around would be asking for trouble.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* This is cheesy, in a sense; why shouldn't we do the 		   update for the user?  However, doing that would require 		   contacting the server, so maybe this is OK.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"run update to complete the unedit"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|baserev
argument_list|,
name|entdata
operator|->
name|timestamp
argument_list|,
name|entdata
operator|->
name|options
argument_list|,
name|entdata
operator|->
name|tag
argument_list|,
name|entdata
operator|->
name|date
argument_list|,
name|entdata
operator|->
name|conflict
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|baserev
argument_list|)
expr_stmt|;
name|base_deregister
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
block|}
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|unedit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lR] [files...]\n"
block|,
literal|"-l: Local directory only, not recursive\n"
block|,
literal|"-R: Process directories recursively\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|unedit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|unedit_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|unedit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* No need to readlock since we aren't doing anything to the        repository.  */
name|err
operator|=
name|start_recursion
argument_list|(
name|unedit_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|send_notifications
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mark_up_to_date
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|base
decl_stmt|;
comment|/* The file is up to date, so we better get rid of an out of        date file in CVSADM_BASE.  */
name|base
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|base
argument_list|,
name|CVSADM_BASE
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|base
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|base
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|base
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|editor_set
parameter_list|(
name|filename
parameter_list|,
name|editor
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|editor
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|edlist
decl_stmt|;
name|char
modifier|*
name|newlist
decl_stmt|;
name|edlist
operator|=
name|fileattr_get0
argument_list|(
name|filename
argument_list|,
literal|"_editors"
argument_list|)
expr_stmt|;
name|newlist
operator|=
name|fileattr_modify
argument_list|(
name|edlist
argument_list|,
name|editor
argument_list|,
name|val
argument_list|,
literal|'>'
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* If the attributes is unchanged, don't rewrite the attribute file.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|edlist
operator|==
name|NULL
operator|&&
name|newlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|edlist
operator|!=
name|NULL
operator|&&
name|newlist
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|edlist
argument_list|,
name|newlist
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|fileattr_set
argument_list|(
name|filename
argument_list|,
literal|"_editors"
argument_list|,
name|newlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|edlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|edlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|newlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|notify_proc_args
block|{
comment|/* What kind of notification, "edit", "tedit", etc.  */
name|char
modifier|*
name|type
decl_stmt|;
comment|/* User who is running the command which causes notification.  */
name|char
modifier|*
name|who
decl_stmt|;
comment|/* User to be notified.  */
name|char
modifier|*
name|notifyee
decl_stmt|;
comment|/* File.  */
name|char
modifier|*
name|file
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pass as a static until we get around to fixing Parse_Info to pass along    a void * where we can stash it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|notify_proc_args
modifier|*
name|notify_args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|notify_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|notify_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
name|FILE
modifier|*
name|pipefp
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|expanded_prog
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|srepos
decl_stmt|;
name|struct
name|notify_proc_args
modifier|*
name|args
init|=
name|notify_args
decl_stmt|;
name|srepos
operator|=
name|Short_Repository
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|prog
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filter
argument_list|)
operator|+
name|strlen
argument_list|(
name|args
operator|->
name|notifyee
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Copy FILTER to PROG, replacing the first occurrence of %s with        the notifyee.  We only allocated enough memory for one %s, and I doubt        there is a need for more.  */
for|for
control|(
name|p
operator|=
name|filter
operator|,
name|q
operator|=
name|prog
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|strcpy
argument_list|(
name|q
argument_list|,
name|args
operator|->
name|notifyee
argument_list|)
expr_stmt|;
name|q
operator|+=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|q
operator|+=
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
continue|continue;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* FIXME: why are we calling expand_proc?  Didn't we already        expand it in Parse_Info, before passing it to notify_proc?  */
name|expanded_prog
operator|=
name|expand_path
argument_list|(
name|prog
argument_list|,
literal|"notify"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expanded_prog
condition|)
block|{
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|pipefp
operator|=
name|run_popen
argument_list|(
name|expanded_prog
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipefp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write entry to notify filter: %s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_prog
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"%s %s\n---\n"
argument_list|,
name|srepos
argument_list|,
name|args
operator|->
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"Triggered %s watch on %s\n"
argument_list|,
name|args
operator|->
name|type
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"By %s\n"
argument_list|,
name|args
operator|->
name|who
argument_list|)
expr_stmt|;
comment|/* Lots more potentially useful information we could add here; see        logfile_write for inspiration.  */
name|free
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|pclose
argument_list|(
name|pipefp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FIXME: this function should have a way to report whether there was    an error so that server.c can know whether to report Notified back    to the client.  */
end_comment

begin_function
name|void
name|notify_do
parameter_list|(
name|type
parameter_list|,
name|filename
parameter_list|,
name|who
parameter_list|,
name|val
parameter_list|,
name|watches
parameter_list|,
name|repository
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|watches
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|struct
name|addremove_args
name|blank
decl_stmt|;
name|struct
name|addremove_args
name|args
decl_stmt|;
name|char
modifier|*
name|watchers
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nextp
decl_stmt|;
comment|/* Initialize fields to 0, NULL, or 0.0.  */
name|args
operator|=
name|blank
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'E'
case|:
if|if
condition|(
name|strpbrk
argument_list|(
name|val
argument_list|,
literal|",>;=\n"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid character in editor value"
argument_list|)
expr_stmt|;
return|return;
block|}
name|editor_set
argument_list|(
name|filename
argument_list|,
name|who
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
case|case
literal|'C'
case|:
name|editor_set
argument_list|(
name|filename
argument_list|,
name|who
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|watchers
operator|=
name|fileattr_get0
argument_list|(
name|filename
argument_list|,
literal|"_watchers"
argument_list|)
expr_stmt|;
name|p
operator|=
name|watchers
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|endq
decl_stmt|;
name|char
modifier|*
name|nextq
decl_stmt|;
name|char
modifier|*
name|notif
decl_stmt|;
name|endp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|NULL
condition|)
break|break;
name|nextp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|endp
operator|-
name|p
argument_list|)
operator|==
name|strlen
argument_list|(
name|who
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|who
argument_list|,
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't notify user of their own changes.  Would perhaps 	       be better to check whether it is the same working 	       directory, not the same user, but that is hairy.  */
name|p
operator|=
name|nextp
operator|==
name|NULL
condition|?
name|nextp
else|:
name|nextp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Now we point q at a string which looks like 	   "edit+unedit+commit,"... and walk down it.  */
name|q
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
name|notif
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|endq
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endq
operator|==
name|NULL
operator|||
operator|(
name|nextp
operator|!=
name|NULL
operator|&&
name|endq
operator|>
name|nextp
operator|)
condition|)
block|{
if|if
condition|(
name|nextp
operator|==
name|NULL
condition|)
name|endq
operator|=
name|q
operator|+
name|strlen
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|endq
operator|=
name|nextp
expr_stmt|;
name|nextq
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|nextq
operator|=
name|endq
operator|+
literal|1
expr_stmt|;
comment|/* If there is a temporary and a regular watch, send a single 	       notification, for the regular watch.  */
if|if
condition|(
name|type
operator|==
literal|'E'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|4
operator|&&
name|strncmp
argument_list|(
literal|"edit"
argument_list|,
name|q
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notif
operator|=
literal|"edit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'U'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|6
operator|&&
name|strncmp
argument_list|(
literal|"unedit"
argument_list|,
name|q
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notif
operator|=
literal|"unedit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'C'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|6
operator|&&
name|strncmp
argument_list|(
literal|"commit"
argument_list|,
name|q
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notif
operator|=
literal|"commit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'E'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|5
operator|&&
name|strncmp
argument_list|(
literal|"tedit"
argument_list|,
name|q
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|notif
operator|==
name|NULL
condition|)
name|notif
operator|=
literal|"temporary edit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'U'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|7
operator|&&
name|strncmp
argument_list|(
literal|"tunedit"
argument_list|,
name|q
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|notif
operator|==
name|NULL
condition|)
name|notif
operator|=
literal|"temporary unedit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
literal|'C'
operator|&&
name|endq
operator|-
name|q
operator|==
literal|7
operator|&&
name|strncmp
argument_list|(
literal|"tcommit"
argument_list|,
name|q
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|notif
operator|==
name|NULL
condition|)
name|notif
operator|=
literal|"temporary commit"
expr_stmt|;
block|}
name|q
operator|=
name|nextq
expr_stmt|;
block|}
if|if
condition|(
name|nextp
operator|!=
name|NULL
condition|)
operator|++
name|nextp
expr_stmt|;
if|if
condition|(
name|notif
operator|!=
name|NULL
condition|)
block|{
name|struct
name|notify_proc_args
name|args
decl_stmt|;
name|size_t
name|len
init|=
name|endp
operator|-
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|usersname
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_len
init|=
literal|0
decl_stmt|;
name|args
operator|.
name|notifyee
operator|=
name|NULL
expr_stmt|;
name|usersname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
name|CVSROOTADM
operator|+
sizeof|sizeof
name|CVSROOTADM_USERS
operator|+
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|usersname
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|usersname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|usersname
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|usersname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|usersname
argument_list|,
name|CVSROOTADM_USERS
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|usersname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|usersname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|line
index|[
name|len
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|args
operator|.
name|notifyee
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* There may or may not be more                            colon-separated fields added to this in the                            future; in any case, we ignore them right                            now, and if there are none we make sure to                            chop off the final newline, if any. */
name|cp
operator|=
name|strpbrk
argument_list|(
name|args
operator|.
name|notifyee
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|usersname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|usersname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|usersname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|notifyee
operator|==
name|NULL
condition|)
block|{
name|args
operator|.
name|notifyee
operator|=
name|xmalloc
argument_list|(
name|endp
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|args
operator|.
name|notifyee
argument_list|,
name|p
argument_list|,
name|endp
operator|-
name|p
argument_list|)
expr_stmt|;
name|args
operator|.
name|notifyee
index|[
name|endp
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|notify_args
operator|=
operator|&
name|args
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|notif
expr_stmt|;
name|args
operator|.
name|who
operator|=
name|who
expr_stmt|;
name|args
operator|.
name|file
operator|=
name|filename
expr_stmt|;
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_NOTIFY
argument_list|,
name|repository
argument_list|,
name|notify_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
operator|.
name|notifyee
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|nextp
expr_stmt|;
block|}
if|if
condition|(
name|watchers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|watchers
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'E'
case|:
if|if
condition|(
operator|*
name|watches
operator|==
literal|'E'
condition|)
block|{
name|args
operator|.
name|add_tedit
operator|=
literal|1
expr_stmt|;
operator|++
name|watches
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|watches
operator|==
literal|'U'
condition|)
block|{
name|args
operator|.
name|add_tunedit
operator|=
literal|1
expr_stmt|;
operator|++
name|watches
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|watches
operator|==
literal|'C'
condition|)
block|{
name|args
operator|.
name|add_tcommit
operator|=
literal|1
expr_stmt|;
block|}
name|watch_modify_watchers
argument_list|(
name|filename
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
case|case
literal|'C'
case|:
name|args
operator|.
name|remove_temp
operator|=
literal|1
expr_stmt|;
name|watch_modify_watchers
argument_list|(
name|filename
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* Check and send notifications.  This is only for the client.  */
end_comment

begin_function
name|void
name|notify_check
parameter_list|(
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|server_started
condition|)
comment|/* We are in the midst of a command which is not to talk to 	   the server (e.g. the first phase of a cvs edit).  Just chill 	   out, we'll catch the notifications on the flip side.  */
return|return;
comment|/* We send notifications even if noexec.  I'm not sure which behavior        is most sensible.  */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_NOTIFY
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|notif_type
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|notif_type
operator|=
name|line
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|notif_type
operator|==
literal|'\0'
condition|)
continue|continue;
name|filename
operator|=
name|line
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|filename
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|cp
expr_stmt|;
name|client_notify
argument_list|(
name|repository
argument_list|,
name|update_dir
argument_list|,
name|filename
argument_list|,
name|notif_type
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_NOTIFY
argument_list|)
expr_stmt|;
comment|/* Leave the CVSADM_NOTIFY file there, until the server tells us it        has dealt with it.  */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|editors_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lR] [files...]\n"
block|,
literal|"\t-l\tProcess this directory only (not recursive).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|editors_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|editors_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|them
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|them
operator|=
name|fileattr_get0
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_editors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|them
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|them
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'>'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|cvs_output
argument_list|(
name|p
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* Only happens if attribute is misformed.  */
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'+'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|cvs_output
argument_list|(
name|p
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
operator|++
name|p
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|out
label|:
empty_stmt|;
name|free
argument_list|(
name|them
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|editors
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|editors_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|editors_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"editors\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
return|return
name|start_recursion
argument_list|(
name|editors_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

