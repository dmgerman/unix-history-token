begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * The routines contained in this file do all the rcs file parsing and  * manipulation  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"hardlink.h"
end_include

begin_decl_stmt
name|int
name|preserve_perms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The RCS -k options, and a set of enums that must match the array.    These come first so that we can use enum kflag in function    prototypes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|kflags
index|[]
init|=
block|{
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
literal|"b"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|kflag
block|{
name|KFLAG_KV
init|=
literal|0
block|,
name|KFLAG_KVL
block|,
name|KFLAG_K
block|,
name|KFLAG_V
block|,
name|KFLAG_O
block|,
name|KFLAG_B
block|}
enum|;
end_enum

begin_comment
comment|/* A structure we use to buffer the contents of an RCS file.  The    various fields are only referenced directly by the rcsbuf_*    functions.  We declare the struct here so that we can allocate it    on the stack, rather than in memory.  */
end_comment

begin_struct
struct|struct
name|rcsbuffer
block|{
comment|/* Points to the current position in the buffer.  */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* Points just after the last valid character in the buffer.  */
name|char
modifier|*
name|ptrend
decl_stmt|;
comment|/* The file.  */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* The name of the file, used for error messages.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The starting file position of the data in the buffer.  */
name|unsigned
name|long
name|pos
decl_stmt|;
comment|/* The length of the value.  */
name|size_t
name|vlen
decl_stmt|;
comment|/* Whether the value contains an '@' string.  If so, we can not        compress whitespace characters.  */
name|int
name|at_string
decl_stmt|;
comment|/* The number of embedded '@' characters in an '@' string.  If        this is non-zero, we must search the string for pairs of '@'        and convert them to a single '@'.  */
name|int
name|embedded_at
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
specifier|const
name|char
operator|*
name|rcsfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|date
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_open
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|FILE
operator|*
name|fp
operator|,
specifier|const
name|char
operator|*
name|filename
operator|,
name|unsigned
name|long
name|pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_close
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcsbuf_getkey
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
operator|*
name|keyp
operator|,
name|char
operator|*
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcsbuf_getrevnum
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
operator|*
name|revp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsbuf_fill
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
name|ptr
operator|,
name|char
operator|*
operator|*
name|keyp
operator|,
name|char
operator|*
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcsbuf_valcmp
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsbuf_valcopy
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
name|val
operator|,
name|int
name|polish
operator|,
name|size_t
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_valpolish
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
name|val
operator|,
name|int
name|polish
operator|,
name|size_t
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_valpolish_internal
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
name|to
operator|,
specifier|const
name|char
operator|*
name|from
operator|,
name|size_t
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|rcsbuf_ftell
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_get_buffered
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
operator|*
name|datap
operator|,
name|size_t
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_cache
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_cache_close
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsbuf_cache_open
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|long
operator|,
name|FILE
operator|*
operator|*
operator|,
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkmagic_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branches
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_symbols
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_locks
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_rcsnode_contents
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_rcsvers_contents
name|PROTO
argument_list|(
operator|(
name|RCSVers
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsvers_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|translate_symtag
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCS_addbranch
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|truncate_revnum_in_place
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|truncate_revnum
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printable_date
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|escape_keyword_value
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_keywords
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|RCSVers
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
expr|enum
name|kflag
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cmp_file_buffer
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|rcs_delta_op
block|{
name|RCS_ANNOTATE
block|,
name|RCS_FETCH
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|RCS_deltas
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|rcs_delta_op
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routines for reading, parsing and writing RCS files. */
end_comment

begin_decl_stmt
specifier|static
name|RCSVers
modifier|*
name|getdelta
name|PROTO
argument_list|(
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Deltatext
modifier|*
name|RCS_getdeltatext
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|struct
name|rcsbuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freedeltatext
name|PROTO
argument_list|(
operator|(
name|Deltatext
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RCS_putadmin
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RCS_putdtree
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RCS_putdesc
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putdelta
name|PROTO
argument_list|(
operator|(
name|RCSVers
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|putrcsfield_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|putsymbol_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RCS_copydeltas
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|struct
name|rcsbuffer
operator|*
operator|,
name|FILE
operator|*
operator|,
name|Deltatext
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_delta_actions
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putdeltatext
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Deltatext
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|rcs_internal_lockfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcs_internal_unlockfile
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcs_lockfilename
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The RCS file reading functions are called a lot, and they do some    string comparisons.  This macro speeds things up a bit by skipping    the function call when the first characters are different.  It    evaluates its arguments multiple times.  */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)[0] == (b)[0]&& strcmp ((a), (b)) == 0)
end_define

begin_comment
comment|/*  * We don't want to use isspace() from the C library because:  *  * 1. The definition of "whitespace" in RCS files includes ASCII  *    backspace, but the C locale doesn't.  * 2. isspace is an very expensive function call in some implementations  *    due to the addition of wide character support.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|spacetab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 - 0x0f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x10 - 0x1f */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x20 - 0x2f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x30 - 0x3f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x40 - 0x4f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x50 - 0x5f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x60 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x70 - 0x7f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x80 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x90 - 0x9f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xa0 - 0xaf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xb0 - 0xbf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xc0 - 0xcf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xd0 - 0xdf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xe0 - 0xef */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 0xf0 - 0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(spacetab[(unsigned char)c] != 0)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcs_lockfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcs_lockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A few generic thoughts on error handling, in particular the    printing of unexpected characters that we find in the RCS file    (that is, why we use '\x%x' rather than %c or some such).     * Avoiding %c means we don't have to worry about what is printable    and other such stuff.  In error handling, often better to keep it    simple.     * Hex rather than decimal or octal because character set standards    tend to use hex.     * Saying "character 0x%x" might make it sound like we are printing    a file offset.  So we use '\x%x'.     * Would be nice to print the offset within the file, but I can    imagine various portability hassles (in particular, whether    unsigned long is always big enough to hold file offsets).  */
end_comment

begin_comment
comment|/* Parse an rcsfile given a user file name and a repository.  If there is    an error, we print an error message and return NULL.  If the file    does not exist, we return NULL without printing anything (I'm not    sure this allows the caller to do anything reasonable, but it is    the current behavior).  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parse
parameter_list|(
name|file
parameter_list|,
name|repos
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCSNode
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
comment|/* We're creating a new RCSNode, so there is no hope of finding it        in the cache.  */
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
name|rcsfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FILENAMES_CASE_INSENSITIVE
argument_list|)
elseif|else
if|if
condition|(
name|ign_case
condition|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|found_path
decl_stmt|;
comment|/* The client might be asking for a file which we do have 	   (which the client doesn't know about), but for which the 	   filename case differs.  We only consider this case if the 	   regular CVS_FOPENs fail, because fopen_case is such an 	   expensive call.  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|status
operator|=
name|fopen_case
argument_list|(
name|rcsfile
argument_list|,
literal|"rb"
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|found_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|path
operator|=
name|found_path
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|status
operator|=
name|fopen_case
argument_list|(
name|rcsfile
argument_list|,
literal|"rb"
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|found_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
name|free
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|path
operator|=
name|found_path
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
name|retval
operator|=
name|NULL
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a specific rcsfile.  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parsercsfile
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
comment|/* We're creating a new RCSNode, so there is no hope of finding it        in the cache.  */
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
comment|/* open the rcsfile */
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcs file `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
parameter_list|(
name|fp
parameter_list|,
name|rcsfile
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
comment|/* make a node */
name|rdata
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* Process HEAD, BRANCH, and EXPAND keywords from the RCS header.         Most cvs operations on the main branch don't need any more        information.  Those that do call RCS_reparsercsfile to parse        the rest of the header and the deltas.  */
name|rcsbuf_open
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|fp
argument_list|,
name|rcsfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|STREQ
argument_list|(
name|RCSHEAD
argument_list|,
name|key
argument_list|)
operator|&&
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|head
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|STREQ
argument_list|(
name|RCSBRANCH
argument_list|,
name|key
argument_list|)
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|rdata
operator|->
name|branch
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|rdata
operator|->
name|branch
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* turn it into a branch if it's a revision */
name|cp
operator|=
name|strrchr
argument_list|(
name|rdata
operator|->
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* Look ahead for expand, stopping when we see desc or a revision        number.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|RCSEXPAND
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|rdata
operator|->
name|expand
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|STREQ
argument_list|(
name|RCSDESC
argument_list|,
name|key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
break|break;
block|}
name|rdata
operator|->
name|flags
operator||=
name|PARTIAL
expr_stmt|;
name|rcsbuf_cache
argument_list|(
name|rdata
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
return|return
name|rdata
return|;
name|l_error
label|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|rcsbuf_close
argument_list|(
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the real work of parsing an RCS file.     On error, die with a fatal error; if it returns at all it was successful.     If PFP is NULL, close the file when done.  Otherwise, leave it open    and store the FILE * in *PFP.  */
end_comment

begin_function
name|void
name|RCS_reparsercsfile
parameter_list|(
name|rdata
parameter_list|,
name|pfp
parameter_list|,
name|rcsbufp
parameter_list|)
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pfp
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbufp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbuf
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|,
modifier|*
name|kv
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|int
name|gotkey
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|assert
argument_list|(
name|rdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rcsfile
operator|=
name|rdata
operator|->
name|path
expr_stmt|;
name|rcsbuf_cache_open
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
comment|/* make a node */
comment|/* This probably shouldn't be done until later: if a file has an        empty revision tree (which is permissible), rdata->versions        should be NULL. -twp */
name|rdata
operator|->
name|versions
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * process all the special header information, break out when we get to      * the first revision delta      */
name|gotkey
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get the next key/value pair */
if|if
condition|(
operator|!
name|gotkey
condition|)
block|{
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
block|}
name|gotkey
operator|=
literal|0
expr_stmt|;
comment|/* Skip head, branch and expand tags; we already have them. */
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSHEAD
argument_list|)
operator|||
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSBRANCH
argument_list|)
operator|||
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSEXPAND
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"access"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
comment|/* We pass the POLISH parameter as 1 because                    RCS_addaccess expects nothing but spaces.  FIXME:                    It would be easy and more efficient to change                    RCS_addaccess.  */
name|rdata
operator|->
name|access
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* We always save lock information, so that we can handle            -kkvl correctly when checking out a file. */
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"locks"
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|locks_data
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"premature end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"strict"
argument_list|)
operator|&&
name|value
operator|==
name|NULL
condition|)
block|{
name|rdata
operator|->
name|strict_locks
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|gotkey
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|RCSSYMBOLS
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|symbols_data
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * check key for '.''s and digits (probably a rev) if it is a 	 * revision or `desc', we are done with the headers and are down to the 	 * revision deltas, so we break out of the loop 	 */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
comment|/* Note that when comparing with RCSDATE, we are not massaging            VALUE from the string found in the RCS file.  This is OK            since we know exactly what to expect.  */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
operator|(
sizeof|sizeof
name|RCSDATE
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
break|break;
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"comment"
argument_list|)
condition|)
block|{
name|rdata
operator|->
name|comment
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rdata
operator|->
name|other
operator|==
name|NULL
condition|)
name|rdata
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|rcsbuf_valcmp
argument_list|(
operator|&
name|rcsbuf
argument_list|)
condition|?
name|RCSCMPFLD
else|:
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
name|kv
operator|->
name|type
operator|==
name|RCSFIELD
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: duplicate key `%s' in RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
comment|/* if we haven't grabbed it yet, we didn't want it */
block|}
comment|/* We got out of the loop, so we have the first part of the first        revision delta in KEY (the revision) and VALUE (the date key        and its value).  This is what getdelta expects to receive.  */
while|while
condition|(
operator|(
name|vnode
operator|=
name|getdelta
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|rcsfile
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* get the node */
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|q
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|q
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|vnode
expr_stmt|;
name|q
operator|->
name|key
operator|=
name|vnode
operator|->
name|version
expr_stmt|;
comment|/* add the nodes to the list */
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|versions
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|purify_printf("WARNING: Adding duplicate version: %s (%s)\n", 			 q->key, rcsfile); 		freenode (q);
endif|#
directive|endif
block|}
block|}
comment|/* Here KEY and VALUE are whatever caused getdelta to return NULL.  */
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdata
operator|->
name|desc
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: duplicate key `%s' in RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rdata
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
name|rdata
operator|->
name|desc
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rdata
operator|->
name|delta_pos
operator|=
name|rcsbuf_ftell
argument_list|(
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|rcsbuf_cache
argument_list|(
name|rdata
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pfp
operator|=
name|fp
expr_stmt|;
operator|*
name|rcsbufp
operator|=
name|rcsbuf
expr_stmt|;
block|}
name|rdata
operator|->
name|flags
operator|&=
operator|~
name|PARTIAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move RCS into or out of the Attic, depending on TOATTIC.  If the    file is already in the desired place, return without doing    anything.  At some point may want to think about how this relates    to RCS_rewrite but that is a bit hairy (if one wants renames to be    atomic, or that kind of thing).  If there is an error, print a message    and return 1.  On success, return 0.  */
end_comment

begin_function
name|int
name|RCS_setattic
parameter_list|(
name|rcs
parameter_list|,
name|toattic
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|int
name|toattic
decl_stmt|;
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Some systems aren't going to let us rename an open file.  */
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
comment|/* Could make the pathname computations in this file, and probably        in other parts of rcs.c too, easier if the REPOS and FILE        arguments to RCS_parse got stashed in the RCSNode.  */
if|if
condition|(
name|toattic
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|INATTIC
condition|)
return|return
literal|0
return|;
comment|/* Example: rcs->path is "/foo/bar/baz,v".  */
name|newpath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
operator|+
sizeof|sizeof
name|CVSATTIC
operator|+
literal|5
argument_list|)
expr_stmt|;
name|p
operator|=
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newpath
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|p
operator|-
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newpath
operator|+
operator|(
name|p
operator|-
name|rcs
operator|->
name|path
operator|)
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
comment|/* Create the Attic directory if it doesn't exist.  */
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|newpath
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newpath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newpath
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|newpath
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* The checks for isreadable look awfully fishy, but 	       I'm going to leave them here for now until I 	       can think harder about whether they take care of 	       some cases which should be handled somehow.  */
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
operator|||
operator|!
name|isreadable
argument_list|(
name|newpath
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|save_errno
argument_list|,
literal|"cannot rename %s to %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|rcs
operator|->
name|flags
operator|&
name|INATTIC
operator|)
condition|)
return|return
literal|0
return|;
name|newpath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Example: rcs->path is "/foo/bar/Attic/baz,v".  */
name|p
operator|=
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newpath
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|p
operator|-
name|rcs
operator|->
name|path
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newpath
index|[
name|p
operator|-
name|rcs
operator|->
name|path
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|newpath
operator|+
operator|(
name|p
operator|-
name|rcs
operator|->
name|path
operator|-
literal|1
operator|)
operator|-
operator|(
sizeof|sizeof
name|CVSATTIC
operator|-
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
name|strncmp
argument_list|(
name|q
argument_list|,
name|CVSATTIC
argument_list|,
sizeof|sizeof
name|CVSATTIC
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|newpath
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to move `%s' out of the attic"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|free
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|path
operator|=
name|newpath
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fully parse the RCS file.  Store all keyword/value pairs, fetch the  * log messages for each revision, and fetch add and delete counts for  * each revision (we could fetch the entire text for each revision,  * but the only caller, log_fileproc, doesn't need that information,  * so we don't waste the memory required to store it).  The add and  * delete counts are stored on the OTHER field of the RCSVERSNODE  * structure, under the names ";add" and ";delete", so that we don't  * waste the memory space of extra fields in RCSVERSNODE for code  * which doesn't need this information.  */
end_comment

begin_function
name|void
name|RCS_fully_parse
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbuf
decl_stmt|;
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|Node
modifier|*
name|vers
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
comment|/* Rather than try to keep track of how much information we            have read, just read to the end of the file.  */
if|if
condition|(
operator|!
name|rcsbuf_getrevnum
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|)
condition|)
break|break;
name|vers
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|vers
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
condition|)
block|{
name|Node
modifier|*
name|kv
decl_stmt|;
if|if
condition|(
name|vnode
operator|->
name|other
operator|==
name|NULL
condition|)
name|vnode
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|rcsbuf_valcmp
argument_list|(
operator|&
name|rcsbuf
argument_list|)
condition|?
name|RCSCMPFLD
else|:
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
name|kv
operator|->
name|type
operator|==
name|RCSFIELD
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|add
decl_stmt|,
name|del
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|Node
modifier|*
name|kv
decl_stmt|;
comment|/* This is a change text.  Store the add and delete                    counts.  */
name|add
operator|=
literal|0
expr_stmt|;
name|del
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|vallen
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|rcsbuf_valpolish
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|&
name|vallen
argument_list|)
expr_stmt|;
name|cp
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|value
operator|+
name|vallen
condition|)
block|{
name|char
name|op
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
name|op
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|'a'
operator|&&
name|op
operator|!=
literal|'d'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unrecognized operation '\\x%x' in %s"
argument_list|,
name|op
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|' '
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"space expected in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|count
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\012'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed expected in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'d'
condition|)
name|del
operator|+=
name|count
expr_stmt|;
else|else
block|{
name|add
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\012'
condition|)
operator|--
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
name|value
operator|+
name|vallen
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ invalid rcs file %s: premature end of value"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
operator|++
name|cp
expr_stmt|;
block|}
block|}
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|";add"
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|del
argument_list|)
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|";delete"
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We have found the "text" key which ends the data for                this revision.  Break out of the loop and go on to the                next revision.  */
break|break;
block|}
block|}
name|rcsbuf_cache
argument_list|(
name|rcs
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freercsnode - free up the info for an RCSNode  */
end_comment

begin_function
name|void
name|freercsnode
parameter_list|(
name|rnodep
parameter_list|)
name|RCSNode
modifier|*
modifier|*
name|rnodep
decl_stmt|;
block|{
if|if
condition|(
name|rnodep
operator|==
name|NULL
operator|||
operator|*
name|rnodep
operator|==
name|NULL
condition|)
return|return;
operator|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
argument_list|)
expr_stmt|;
name|free_rcsnode_contents
argument_list|(
operator|*
name|rnodep
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|rnodep
argument_list|)
expr_stmt|;
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free_rcsnode_contents - free up the contents of an RCSNode without  * freeing the node itself, or the file name, or the head, or the  * path.  This returns the RCSNode to the state it is in immediately  * after a call to RCS_parse.  */
end_comment

begin_function
specifier|static
name|void
name|free_rcsnode_contents
parameter_list|(
name|rnode
parameter_list|)
name|RCSNode
modifier|*
name|rnode
decl_stmt|;
block|{
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|versions
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|symbols
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|symbols_data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|expand
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|expand
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|other
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|access
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|locks_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|locks_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|locks
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|locks
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|desc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* free_rcsvers_contents -- free up the contents of an RCSVers node,    but also free the pointer to the node itself. */
end_comment

begin_comment
comment|/* Note: The `hardlinks' list is *not* freed, since it is merely a    pointer into the `hardlist' structure (defined in hardlink.c), and    that structure is freed elsewhere in the program. */
end_comment

begin_function
specifier|static
name|void
name|free_rcsvers_contents
parameter_list|(
name|rnode
parameter_list|)
name|RCSVers
modifier|*
name|rnode
decl_stmt|;
block|{
if|if
condition|(
name|rnode
operator|->
name|branches
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|branches
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|date
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|next
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|author
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|state
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|other
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|other_delta
operator|!=
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|other_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|text
operator|!=
name|NULL
condition|)
name|freedeltatext
argument_list|(
name|rnode
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcsvers_delproc - free up an RCSVers type node  */
end_comment

begin_function
specifier|static
name|void
name|rcsvers_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|free_rcsvers_contents
argument_list|(
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These functions retrieve keys and values from an RCS file using a    buffer.  We use this somewhat complex approach because it turns out    that for many common operations, CVS spends most of its time    reading keys, so it's worth doing some fairly hairy optimization.  */
end_comment

begin_comment
comment|/* The number of bytes we try to read each time we need more data.  */
end_comment

begin_define
define|#
directive|define
name|RCSBUF_BUFSIZE
value|(8192)
end_define

begin_comment
comment|/* The buffer we use to store data.  This grows as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsbuf_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|rcsbuf_buffer_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether rcsbuf_buffer is in use.  This is used as a sanity check.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rcsbuf_inuse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up to start gathering keys and values from an RCS file.  This    initializes RCSBUF.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_open
parameter_list|(
name|rcsbuf
parameter_list|,
name|fp
parameter_list|,
name|filename
parameter_list|,
name|pos
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|long
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|rcsbuf_inuse
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"rcsbuf_open: internal error"
argument_list|)
expr_stmt|;
name|rcsbuf_inuse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rcsbuf_buffer_size
operator|<
name|RCSBUF_BUFSIZE
condition|)
name|expand_string
argument_list|(
operator|&
name|rcsbuf_buffer
argument_list|,
operator|&
name|rcsbuf_buffer_size
argument_list|,
name|RCSBUF_BUFSIZE
argument_list|)
expr_stmt|;
name|rcsbuf
operator|->
name|ptr
operator|=
name|rcsbuf_buffer
expr_stmt|;
name|rcsbuf
operator|->
name|ptrend
operator|=
name|rcsbuf_buffer
expr_stmt|;
name|rcsbuf
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|rcsbuf
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|rcsbuf
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
literal|0
expr_stmt|;
name|rcsbuf
operator|->
name|at_string
operator|=
literal|0
expr_stmt|;
name|rcsbuf
operator|->
name|embedded_at
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop gathering keys from an RCS file.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_close
parameter_list|(
name|rcsbuf
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|rcsbuf_inuse
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"rcsbuf_close: internal error"
argument_list|)
expr_stmt|;
name|rcsbuf_inuse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a key/value pair from an RCS file.  This sets *KEYP to point    to the key, and *VALUEP to point to the value.  A missing or empty    value is indicated by setting *VALUEP to NULL.     This function returns 1 on success, or 0 on EOF.  If there is an    error reading the file, or an EOF in an unexpected location, it    gives a fatal error.     This sets *KEYP and *VALUEP to point to storage managed by    rcsbuf_getkey.  Moreover, *VALUEP has not been massaged from the    RCS format: it may contain embedded whitespace and embedded '@'    characters.  Call rcsbuf_valcopy or rcsbuf_valpolish to do    appropriate massaging.  */
end_comment

begin_comment
comment|/* Note that the extreme hair in rcsbuf_getkey is because profiling    statistics show that it was worth it. */
end_comment

begin_function
specifier|static
name|int
name|rcsbuf_getkey
parameter_list|(
name|rcsbuf
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
specifier|const
name|my_spacetab
init|=
name|spacetab
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|char
name|c
decl_stmt|;
define|#
directive|define
name|my_whitespace
parameter_list|(
name|c
parameter_list|)
value|(my_spacetab[(unsigned char)c] != 0)
name|rcsbuf
operator|->
name|vlen
operator|=
literal|0
expr_stmt|;
name|rcsbuf
operator|->
name|at_string
operator|=
literal|0
expr_stmt|;
name|rcsbuf
operator|->
name|embedded_at
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|rcsbuf
operator|->
name|ptr
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|ptr
operator|<
name|rcsbuf_buffer
operator|||
name|ptr
operator|>
name|rcsbuf_buffer
operator|+
name|rcsbuf_buffer_size
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the pointer is more than RCSBUF_BUFSIZE bytes into the        buffer, move back to the start of the buffer.  This keeps the        buffer from growing indefinitely.  */
if|if
condition|(
name|ptr
operator|-
name|rcsbuf_buffer
operator|>=
name|RCSBUF_BUFSIZE
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|ptrend
operator|-
name|ptr
expr_stmt|;
comment|/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes            at a time, so we can't have more bytes than that past PTR.  */
if|if
condition|(
name|len
operator|>
name|RCSBUF_BUFSIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Update the POS field, which holds the file offset of the            first byte in the RCSBUF_BUFFER buffer.  */
name|rcsbuf
operator|->
name|pos
operator|+=
name|ptr
operator|-
name|rcsbuf_buffer
expr_stmt|;
name|memcpy
argument_list|(
name|rcsbuf_buffer
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|rcsbuf_buffer
expr_stmt|;
name|ptrend
operator|=
name|ptr
operator|+
name|len
expr_stmt|;
name|rcsbuf
operator|->
name|ptrend
operator|=
name|ptrend
expr_stmt|;
block|}
comment|/* Skip leading whitespace.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|my_whitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* We've found the start of the key.  */
operator|*
name|keyp
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|';'
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
name|keyp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF in key in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|my_whitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Here *KEYP points to the key in the buffer, C is the character        we found at the of the key, and PTR points to the location in        the buffer where we found C.  We must set *PTR to \0 in order        to terminate the key.  If the key ended with ';', then there is        no value.  */
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* C must be whitespace.  Skip whitespace between the key and the        value.  If we find ';' now, there is no value.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
name|keyp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF while looking for value in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|ptr
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|my_whitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* Now PTR points to the start of the value, and C is the first        character of the value.  */
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
operator|*
name|valp
operator|=
name|ptr
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|pat
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
comment|/* Optimize the common case of a value composed of a single 	   '@' string.  */
name|rcsbuf
operator|->
name|at_string
operator|=
literal|1
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
operator|*
name|valp
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|pat
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
literal|'@'
argument_list|,
name|ptrend
operator|-
name|ptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Note that we pass PTREND as the PTR value to                    rcsbuf_fill, so that we will wind up setting PTR to                    the location corresponding to the old PTREND, so                    that we don't search the same bytes again.  */
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptrend
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF while looking for end of string in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
comment|/* Handle the special case of an '@' right at the end of                the known bytes.  */
if|if
condition|(
name|pat
operator|+
literal|1
operator|>=
name|ptrend
condition|)
block|{
comment|/* Note that we pass PAT, not PTR, here.  */
name|pat
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|pat
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|==
name|NULL
condition|)
block|{
comment|/* EOF here is OK; it just means that the last 		       character of the file was an '@' terminating a 		       value for a key type which does not require a 		       trailing ';'.  */
name|pat
operator|=
name|rcsbuf
operator|->
name|ptrend
operator|-
literal|1
expr_stmt|;
block|}
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
comment|/* Note that the value of PTR is bogus here.  This is 		   OK, because we don't use it.  */
block|}
if|if
condition|(
name|pat
operator|+
literal|1
operator|>=
name|ptrend
operator|||
name|pat
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
break|break;
comment|/* We found an '@' pair in the string.  Keep looking.  */
operator|++
name|rcsbuf
operator|->
name|embedded_at
expr_stmt|;
name|ptr
operator|=
name|pat
operator|+
literal|2
expr_stmt|;
block|}
comment|/* Here PAT points to the final '@' in the string.  */
operator|*
name|pat
operator|=
literal|'\0'
expr_stmt|;
name|vlen
operator|=
name|pat
operator|-
operator|*
name|valp
expr_stmt|;
if|if
condition|(
name|vlen
operator|==
literal|0
condition|)
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
name|vlen
expr_stmt|;
name|ptr
operator|=
name|pat
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Certain keywords only have a '@' string.  If there is no '@'        string, then the old getrcskey function assumed that they had        no value, and we do the same.  */
block|{
name|char
modifier|*
name|k
decl_stmt|;
name|k
operator|=
operator|*
name|keyp
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|k
argument_list|,
name|RCSDESC
argument_list|)
operator|||
name|STREQ
argument_list|(
name|k
argument_list|,
literal|"text"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|k
argument_list|,
literal|"log"
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If we've already gathered a '@' string, try to skip whitespace        and find a ';'.  */
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|n
decl_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF in value in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|n
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|';'
condition|)
block|{
comment|/* We're done.  We already set everything up for this                    case above.  */
name|rcsbuf
operator|->
name|ptr
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|my_whitespace
argument_list|(
name|n
argument_list|)
condition|)
break|break;
operator|++
name|ptr
expr_stmt|;
block|}
comment|/* The value extends past the '@' string.  We need to undo the            '@' stripping done in the default case above.  This            case never happens in a plain RCS file, but it can happen            if user defined phrases are used.  */
operator|(
operator|(
operator|*
name|valp
operator|)
operator|--
operator|)
index|[
name|rcsbuf
operator|->
name|vlen
operator|++
index|]
operator|=
literal|'@'
expr_stmt|;
block|}
comment|/* Here we have a value which is not a simple '@' string.  We need        to gather up everything until the next ';', including any '@'        strings.  *VALP points to the start of the value.  If        RCSBUF->VLEN is not zero, then we have already read an '@'        string, and PTR points to the data following the '@' string.        Otherwise, PTR points to the start of the value.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|psemi
decl_stmt|,
modifier|*
name|pat
decl_stmt|;
comment|/* Find the ';' which must end the value.  */
name|start
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|psemi
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
literal|';'
argument_list|,
name|ptrend
operator|-
name|ptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|slen
decl_stmt|;
comment|/* Note that we pass PTREND as the PTR value to 	       rcsbuf_fill, so that we will wind up setting PTR to the 	       location corresponding to the old PTREND, so that we 	       don't search the same bytes again.  */
name|slen
operator|=
name|start
operator|-
operator|*
name|valp
expr_stmt|;
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptrend
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF in value in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|valp
operator|+
name|slen
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
comment|/* See if there are any '@' strings in the value.  */
name|pat
operator|=
name|memchr
argument_list|(
name|start
argument_list|,
literal|'@'
argument_list|,
name|psemi
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|==
name|NULL
condition|)
block|{
name|size_t
name|vlen
decl_stmt|;
comment|/* We're done with the value.  Trim any trailing                whitespace.  */
name|rcsbuf
operator|->
name|ptr
operator|=
name|psemi
operator|+
literal|1
expr_stmt|;
name|start
operator|=
operator|*
name|valp
expr_stmt|;
while|while
condition|(
name|psemi
operator|>
name|start
operator|&&
name|my_whitespace
argument_list|(
name|psemi
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|psemi
expr_stmt|;
operator|*
name|psemi
operator|=
literal|'\0'
expr_stmt|;
name|vlen
operator|=
name|psemi
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|vlen
operator|==
literal|0
condition|)
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
name|vlen
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We found an '@' string in the value.  We set RCSBUF->AT_STRING 	   and RCSBUF->EMBEDDED_AT to indicate that we won't be able to 	   compress whitespace correctly for this type of value. 	   Since this type of value never arises in a normal RCS file, 	   this should not be a big deal.  It means that if anybody 	   adds a phrase which can have both an '@' string and regular 	   text, they will have to handle whitespace compression 	   themselves.  */
name|rcsbuf
operator|->
name|at_string
operator|=
literal|1
expr_stmt|;
name|rcsbuf
operator|->
name|embedded_at
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|pat
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|pat
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
literal|'@'
argument_list|,
name|ptrend
operator|-
name|ptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Note that we pass PTREND as the PTR value to                    rcsbuff_fill, so that we will wind up setting PTR                    to the location corresponding to the old PTREND, so                    that we don't search the same bytes again.  */
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptrend
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF while looking for end of string in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
comment|/* Handle the special case of an '@' right at the end of                the known bytes.  */
if|if
condition|(
name|pat
operator|+
literal|1
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
name|keyp
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"EOF in value in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
if|if
condition|(
name|pat
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
break|break;
comment|/* We found an '@' pair in the string.  Keep looking.  */
name|ptr
operator|=
name|pat
operator|+
literal|2
expr_stmt|;
block|}
comment|/* Here PAT points to the final '@' in the string.  */
name|ptr
operator|=
name|pat
operator|+
literal|1
expr_stmt|;
block|}
undef|#
directive|undef
name|my_whitespace
block|}
end_function

begin_comment
comment|/* Read an RCS revision number from an RCS file.  This sets *REVP to    point to the revision number; it will point to space that is    managed by the rcsbuf functions, and is only good until the next    call to rcsbuf_getkey or rcsbuf_getrevnum.     This function returns 1 on success, or 0 on EOF.  If there is an    error reading the file, or an EOF in an unexpected location, it    gives a fatal error.  */
end_comment

begin_function
specifier|static
name|int
name|rcsbuf_getrevnum
parameter_list|(
name|rcsbuf
parameter_list|,
name|revp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
modifier|*
name|revp
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ptr
operator|=
name|rcsbuf
operator|->
name|ptr
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
operator|*
name|revp
operator|=
name|NULL
expr_stmt|;
comment|/* Skip leading whitespace.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|++
name|ptr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unexpected '\\x%x' reading revision number in RCS file %s"
argument_list|,
name|c
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|revp
operator|=
name|ptr
expr_stmt|;
do|do
block|{
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
block|{
name|ptr
operator|=
name|rcsbuf_fill
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
name|revp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected EOF reading revision number in RCS file %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ptrend
operator|=
name|rcsbuf
operator|->
name|ptrend
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|)
do|;
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unexpected '\\x%x' reading revision number in RCS file %s"
argument_list|,
name|c
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|rcsbuf
operator|->
name|ptr
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill RCSBUF_BUFFER with bytes from the file associated with RCSBUF,    updating PTR and the PTREND field.  If KEYP and *KEYP are not NULL,    then *KEYP points into the buffer, and must be adjusted if the    buffer is changed.  Likewise for VALP.  Returns the new value of    PTR, or NULL on error.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rcsbuf_fill
parameter_list|(
name|rcsbuf
parameter_list|,
name|ptr
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
name|int
name|got
decl_stmt|;
if|if
condition|(
name|rcsbuf
operator|->
name|ptrend
operator|-
name|rcsbuf_buffer
operator|+
name|RCSBUF_BUFSIZE
operator|>
name|rcsbuf_buffer_size
condition|)
block|{
name|int
name|poff
decl_stmt|,
name|peoff
decl_stmt|,
name|koff
decl_stmt|,
name|voff
decl_stmt|;
name|poff
operator|=
name|ptr
operator|-
name|rcsbuf_buffer
expr_stmt|;
name|peoff
operator|=
name|rcsbuf
operator|->
name|ptrend
operator|-
name|rcsbuf_buffer
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
operator|&&
operator|*
name|keyp
operator|!=
name|NULL
condition|)
name|koff
operator|=
operator|*
name|keyp
operator|-
name|rcsbuf_buffer
expr_stmt|;
if|if
condition|(
name|valp
operator|!=
name|NULL
operator|&&
operator|*
name|valp
operator|!=
name|NULL
condition|)
name|voff
operator|=
operator|*
name|valp
operator|-
name|rcsbuf_buffer
expr_stmt|;
name|koff
operator|=
name|keyp
operator|==
name|NULL
condition|?
literal|0
else|:
operator|*
name|keyp
operator|-
name|rcsbuf_buffer
expr_stmt|;
name|voff
operator|=
name|valp
operator|==
name|NULL
condition|?
literal|0
else|:
operator|*
name|valp
operator|-
name|rcsbuf_buffer
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|rcsbuf_buffer
argument_list|,
operator|&
name|rcsbuf_buffer_size
argument_list|,
name|rcsbuf_buffer_size
operator|+
name|RCSBUF_BUFSIZE
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|rcsbuf_buffer
operator|+
name|poff
expr_stmt|;
name|rcsbuf
operator|->
name|ptrend
operator|=
name|rcsbuf_buffer
operator|+
name|peoff
expr_stmt|;
if|if
condition|(
name|keyp
operator|!=
name|NULL
operator|&&
operator|*
name|keyp
operator|!=
name|NULL
condition|)
operator|*
name|keyp
operator|=
name|rcsbuf_buffer
operator|+
name|koff
expr_stmt|;
if|if
condition|(
name|valp
operator|!=
name|NULL
operator|&&
operator|*
name|valp
operator|!=
name|NULL
condition|)
operator|*
name|valp
operator|=
name|rcsbuf_buffer
operator|+
name|voff
expr_stmt|;
block|}
name|got
operator|=
name|fread
argument_list|(
name|rcsbuf
operator|->
name|ptrend
argument_list|,
literal|1
argument_list|,
name|RCSBUF_BUFSIZE
argument_list|,
name|rcsbuf
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|rcsbuf
operator|->
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rcsbuf
operator|->
name|ptrend
operator|+=
name|got
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Test whether the last value returned by rcsbuf_getkey is a composite    value or not. */
end_comment

begin_function
specifier|static
name|int
name|rcsbuf_valcmp
parameter_list|(
name|rcsbuf
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
block|{
return|return
name|rcsbuf
operator|->
name|at_string
operator|&&
name|rcsbuf
operator|->
name|embedded_at
operator|<
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy the value VAL returned by rcsbuf_getkey into a memory buffer,    returning the memory buffer.  Polish the value like    rcsbuf_valpolish, q.v.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rcsbuf_valcopy
parameter_list|(
name|rcsbuf
parameter_list|,
name|val
parameter_list|,
name|polish
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|polish
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
name|size_t
name|vlen
decl_stmt|;
name|int
name|embedded_at
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vlen
operator|=
name|rcsbuf
operator|->
name|vlen
expr_stmt|;
name|embedded_at
operator|=
name|rcsbuf
operator|->
name|embedded_at
operator|<
literal|0
condition|?
literal|0
else|:
name|rcsbuf
operator|->
name|embedded_at
expr_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|vlen
operator|-
name|embedded_at
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsbuf
operator|->
name|at_string
condition|?
name|embedded_at
operator|==
literal|0
else|:
operator|!
name|polish
condition|)
block|{
comment|/* No special action to take.  */
name|memcpy
argument_list|(
name|ret
argument_list|,
name|val
argument_list|,
name|vlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|vlen
expr_stmt|;
return|return
name|ret
return|;
block|}
name|rcsbuf_valpolish_internal
argument_list|(
name|rcsbuf
argument_list|,
name|ret
argument_list|,
name|val
argument_list|,
name|lenp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Polish the value VAL returned by rcsbuf_getkey.  The POLISH    parameter is non-zero if multiple embedded whitespace characters    should be compressed into a single whitespace character.  Note that    leading and trailing whitespace was already removed by    rcsbuf_getkey.  Within an '@' string, pairs of '@' characters are    compressed into a single '@' character regardless of the value of    POLISH.  If LENP is not NULL, set *LENP to the length of the value.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_valpolish
parameter_list|(
name|rcsbuf
parameter_list|,
name|val
parameter_list|,
name|polish
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|polish
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rcsbuf
operator|->
name|at_string
condition|?
name|rcsbuf
operator|->
name|embedded_at
operator|==
literal|0
else|:
operator|!
name|polish
condition|)
block|{
comment|/* No special action to take.  */
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|rcsbuf
operator|->
name|vlen
expr_stmt|;
return|return;
block|}
name|rcsbuf_valpolish_internal
argument_list|(
name|rcsbuf
argument_list|,
name|val
argument_list|,
name|val
argument_list|,
name|lenp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Internal polishing routine, called from rcsbuf_valcopy and    rcsbuf_valpolish.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_valpolish_internal
parameter_list|(
name|rcsbuf
parameter_list|,
name|to
parameter_list|,
name|from
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|rcsbuf
operator|->
name|vlen
expr_stmt|;
if|if
condition|(
operator|!
name|rcsbuf
operator|->
name|at_string
condition|)
block|{
name|char
modifier|*
name|orig_to
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|orig_to
operator|=
name|to
expr_stmt|;
for|for
control|(
name|clen
operator|=
name|len
init|;
name|clen
operator|>
literal|0
condition|;
operator|++
name|from
operator|,
operator|--
name|clen
control|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Note that we know that clen can not drop to zero                    while we have whitespace, because we know there is                    no trailing whitespace.  */
while|while
condition|(
name|whitespace
argument_list|(
name|from
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|from
expr_stmt|;
operator|--
name|clen
expr_stmt|;
block|}
name|c
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|to
operator|-
name|orig_to
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|orig_from
decl_stmt|;
name|char
modifier|*
name|orig_to
decl_stmt|;
name|int
name|embedded_at
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|orig_from
operator|=
name|from
expr_stmt|;
name|orig_to
operator|=
name|to
expr_stmt|;
name|embedded_at
operator|=
name|rcsbuf
operator|->
name|embedded_at
expr_stmt|;
name|assert
argument_list|(
name|embedded_at
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|len
operator|-
name|embedded_at
expr_stmt|;
for|for
control|(
name|clen
operator|=
name|len
init|;
name|clen
operator|>
literal|0
condition|;
operator|++
name|from
operator|,
operator|--
name|clen
control|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|from
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
operator|++
name|from
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
operator|*
name|from
operator|!=
literal|'@'
operator|||
name|clen
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|--
name|clen
expr_stmt|;
operator|--
name|embedded_at
expr_stmt|;
if|if
condition|(
name|embedded_at
operator|==
literal|0
condition|)
block|{
comment|/* We've found all the embedded '@' characters.                        We can just memcpy the rest of the buffer after                        this '@' character.  */
if|if
condition|(
name|orig_to
operator|!=
name|orig_from
condition|)
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
operator|+
literal|1
argument_list|,
name|clen
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|to
argument_list|,
name|from
operator|+
literal|1
argument_list|,
name|clen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|from
operator|+=
name|clen
expr_stmt|;
name|to
operator|+=
name|clen
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Sanity check.  */
if|if
condition|(
name|from
operator|!=
name|orig_from
operator|+
name|len
operator|||
name|to
operator|!=
name|orig_to
operator|+
operator|(
name|len
operator|-
name|rcsbuf
operator|->
name|embedded_at
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
end_ifdef

begin_comment
comment|/* Copy the next word from the value VALP returned by rcsbuf_getkey into a    memory buffer, updating VALP and returning the memory buffer.  Return    NULL when there are no more words. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rcsbuf_valword
parameter_list|(
name|rcsbuf
parameter_list|,
name|valp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
specifier|const
name|my_spacetab
init|=
name|spacetab
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|pat
decl_stmt|;
name|char
name|c
decl_stmt|;
define|#
directive|define
name|my_whitespace
parameter_list|(
name|c
parameter_list|)
value|(my_spacetab[(unsigned char)c] != 0)
if|if
condition|(
operator|*
name|valp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|ptr
operator|=
operator|*
name|valp
init|;
name|my_whitespace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|;
operator|++
name|ptr
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
condition|)
block|{
name|assert
argument_list|(
name|ptr
operator|-
operator|*
name|valp
operator|==
name|rcsbuf
operator|->
name|vlen
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* PTR now points to the start of a value.  Find out whether it is        a num, an id, a string or a colon. */
name|c
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|rcsbuf
operator|->
name|vlen
operator|-=
operator|++
name|ptr
operator|-
operator|*
name|valp
expr_stmt|;
operator|*
name|valp
operator|=
name|ptr
expr_stmt|;
return|return
name|xstrdup
argument_list|(
literal|":"
argument_list|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
name|int
name|embedded_at
init|=
literal|0
decl_stmt|;
name|size_t
name|vlen
decl_stmt|;
name|pat
operator|=
operator|++
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|pat
operator|=
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pat
index|[
literal|1
index|]
operator|!=
literal|'@'
condition|)
break|break;
operator|++
name|embedded_at
expr_stmt|;
name|pat
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Here PAT points to the final '@' in the string.  */
operator|*
name|pat
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|rcsbuf
operator|->
name|at_string
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|rcsbuf
operator|->
name|vlen
operator|-
operator|(
name|pat
operator|-
operator|*
name|valp
operator|)
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
name|pat
operator|-
name|ptr
operator|-
literal|1
expr_stmt|;
name|rcsbuf
operator|->
name|embedded_at
operator|=
name|embedded_at
expr_stmt|;
name|ptr
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|pat
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|=
name|vlen
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|pat
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|rcsbuf
operator|->
name|at_string
operator|=
literal|0
expr_stmt|;
else|else
name|rcsbuf
operator|->
name|embedded_at
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ptr
return|;
block|}
comment|/* *PTR is neither `:', `;' nor `@', so it should be the start of a num        or an id.  Make sure it is not another special character. */
if|if
condition|(
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal special character in RCS field in %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Legitimate ID characters are digits, dots and any `graphic            printing character that is not a special.' This test ought 	   to do the trick. */
name|c
operator|=
operator|*
operator|++
name|pat
expr_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|||
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'@'
operator|||
name|c
operator|==
literal|':'
condition|)
break|break;
block|}
comment|/* PAT points to the last non-id character in this word, and C is        the character in its memory cell.  Check to make sure that it        is a legitimate word delimiter -- whitespace or end. */
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
operator|!
name|my_whitespace
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal special character in RCS field in %s"
argument_list|,
name|rcsbuf
operator|->
name|filename
argument_list|)
expr_stmt|;
operator|*
name|pat
operator|=
literal|'\0'
expr_stmt|;
name|rcsbuf
operator|->
name|vlen
operator|-=
name|pat
operator|-
operator|*
name|valp
expr_stmt|;
operator|*
name|valp
operator|=
name|pat
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|ptr
argument_list|)
return|;
undef|#
directive|undef
name|my_whitespace
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the current position of an rcsbuf.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rcsbuf_ftell
parameter_list|(
name|rcsbuf
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
block|{
return|return
name|rcsbuf
operator|->
name|pos
operator|+
operator|(
name|rcsbuf
operator|->
name|ptr
operator|-
name|rcsbuf_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to any data buffered for RCSBUF, along with the    length.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_get_buffered
parameter_list|(
name|rcsbuf
parameter_list|,
name|datap
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
modifier|*
name|datap
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
operator|*
name|datap
operator|=
name|rcsbuf
operator|->
name|ptr
expr_stmt|;
operator|*
name|lenp
operator|=
name|rcsbuf
operator|->
name|ptrend
operator|-
name|rcsbuf
operator|->
name|ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CVS optimizes by quickly reading some header information from a    file.  If it decides it needs to do more with the file, it reopens    it.  We speed that up here by maintaining a cache of a single open    file, to save the time it takes to reopen the file in the common    case.  */
end_comment

begin_decl_stmt
specifier|static
name|RCSNode
modifier|*
name|cached_rcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rcsbuffer
name|cached_rcsbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache RCS and RCSBUF.  This takes responsibility for closing    RCSBUF->FP.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_cache
parameter_list|(
name|rcs
parameter_list|,
name|rcsbuf
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
block|{
if|if
condition|(
name|cached_rcs
operator|!=
name|NULL
condition|)
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
name|cached_rcs
operator|=
name|rcs
expr_stmt|;
operator|++
name|rcs
operator|->
name|refcount
expr_stmt|;
name|cached_rcsbuf
operator|=
operator|*
name|rcsbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there is anything in the cache, close it.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_cache_close
parameter_list|()
block|{
if|if
condition|(
name|cached_rcs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|cached_rcsbuf
operator|.
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|cached_rcsbuf
operator|.
name|filename
argument_list|)
expr_stmt|;
name|rcsbuf_close
argument_list|(
operator|&
name|cached_rcsbuf
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|cached_rcs
argument_list|)
expr_stmt|;
name|cached_rcs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Open an rcsbuffer for RCS, getting it from the cache if possible.    Set *FPP to the file, and *RCSBUFP to the rcsbuf.  The file should    be put at position POS.  */
end_comment

begin_function
specifier|static
name|void
name|rcsbuf_cache_open
parameter_list|(
name|rcs
parameter_list|,
name|pos
parameter_list|,
name|pfp
parameter_list|,
name|prcsbuf
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pfp
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|prcsbuf
decl_stmt|;
block|{
if|if
condition|(
name|cached_rcs
operator|==
name|rcs
condition|)
block|{
if|if
condition|(
name|rcsbuf_ftell
argument_list|(
operator|&
name|cached_rcsbuf
argument_list|)
operator|!=
name|pos
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|cached_rcsbuf
operator|.
name|fp
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot fseek RCS file %s"
argument_list|,
name|cached_rcsbuf
operator|.
name|filename
argument_list|)
expr_stmt|;
name|cached_rcsbuf
operator|.
name|ptr
operator|=
name|rcsbuf_buffer
expr_stmt|;
name|cached_rcsbuf
operator|.
name|ptrend
operator|=
name|rcsbuf_buffer
expr_stmt|;
name|cached_rcsbuf
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
operator|*
name|pfp
operator|=
name|cached_rcsbuf
operator|.
name|fp
expr_stmt|;
comment|/* When RCS_parse opens a file using fopen_case, it frees the            filename which we cached in CACHED_RCSBUF and stores a new            file name in RCS->PATH.  We avoid problems here by always            copying the filename over.  FIXME: This is hackish.  */
name|cached_rcsbuf
operator|.
name|filename
operator|=
name|rcs
operator|->
name|path
expr_stmt|;
operator|*
name|prcsbuf
operator|=
name|cached_rcsbuf
expr_stmt|;
name|cached_rcs
operator|=
name|NULL
expr_stmt|;
comment|/* Removing RCS from the cache removes a reference to it.  */
operator|--
name|rcs
operator|->
name|refcount
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|refcount
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"rcsbuf_cache_open: internal error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cached_rcs
operator|!=
name|NULL
condition|)
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
operator|*
name|pfp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pfp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unable to reopen `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
operator|*
name|pfp
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot fseek RCS file %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|rcsbuf_open
argument_list|(
name|prcsbuf
argument_list|,
operator|*
name|pfp
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * process the symbols list of the rcs file  */
end_comment

begin_function
specifier|static
name|void
name|do_symbols
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* split it up into tag and rev */
name|tag
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the locks list of the rcs file  * Like do_symbols, but hash entries are keyed backwards: i.e.  * an entry like `user:rev' is keyed on REV rather than on USER.  */
end_comment

begin_function
specifier|static
name|void
name|do_locks
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* split it up into user and rev */
name|user
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the branches list of a revision delta  */
end_comment

begin_function
specifier|static
name|void
name|do_branches
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* find the end of this branch */
name|branch
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Version Number  *   * Returns the requested version number of the RCS file, satisfying tags and/or  * dates, and walking branches, if necessary.  *   * The result is returned; null-string if error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getversion
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|,
name|simple_tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
modifier|*
name|simple_tag
decl_stmt|;
block|{
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|date
condition|)
block|{
name|char
modifier|*
name|branch
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
if|if
condition|(
operator|!
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* We can't get a particular date if the tag is not a                branch.  */
return|return
name|NULL
return|;
block|}
comment|/* Work out the branch.  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|branch
operator|=
name|RCS_whatbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|branch
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* Fetch the revision of branch as of date.  */
name|rev
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
name|rev
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tag
condition|)
return|return
operator|(
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|,
name|simple_tag
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|date
condition|)
return|return
operator|(
name|RCS_getdate
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get existing revision number corresponding to tag or revision.  * Similar to RCS_gettag but less interpretation imposed.  * For example:  * -- If tag designates a magic branch, RCS_tag2rev  *    returns the magic branch number.  * -- If tag is a branch tag, returns the branch number, not  *    the revision of the head of the branch.  * If tag or revision is not valid or does not exist in file,  * exit with error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_tag2rev
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|rev
decl_stmt|,
modifier|*
name|pa
decl_stmt|,
modifier|*
name|pb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If a valid revision, try to look it up */
if|if
condition|(
name|RCS_valid_rev
argument_list|(
name|tag
argument_list|)
condition|)
block|{
comment|/* Make a copy so we can scribble on it */
name|rev
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* If revision exists, return the copy */
if|if
condition|(
name|RCS_exist_rev
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
condition|)
return|return
name|rev
return|;
comment|/* Nope, none such. If tag is not a branch we're done. */
name|i
operator|=
name|numdots
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
name|pa
operator|=
name|strrchr
argument_list|(
name|rev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
operator|*
operator|(
name|pa
operator|-
literal|1
operator|)
operator|!=
name|RCS_MAGIC_BRANCH
operator|||
operator|*
operator|(
name|pa
operator|-
literal|2
operator|)
operator|!=
literal|'.'
condition|)
block|{
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"revision `%s' does not exist"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try for a real (that is, exists in the RCS deltas) branch 	   (RCS_exist_rev just checks for real revisions and revisions 	   which have tags pointing to them).  */
name|pa
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pa
argument_list|)
expr_stmt|;
return|return
name|rev
return|;
block|}
comment|/* Tag is branch, but does not exist, try corresponding  	* magic branch tag. 	* 	* FIXME: assumes all magic branches are of        	* form "n.n.n ... .0.n".  I'll fix if somebody can 	* send me a method to get a magic branch tag with 	* the 0 in some other position --<dan@gasboy.com> 	*/
name|pa
operator|=
name|strrchr
argument_list|(
name|rev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|pb
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|pa
operator|++
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"%s.%d.%s"
argument_list|,
name|rev
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|rev
operator|=
name|pb
expr_stmt|;
if|if
condition|(
name|RCS_exist_rev
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
condition|)
return|return
name|rev
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"revision `%s' does not exist"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|RCS_check_tag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* exit if not a valid tag */
comment|/* If tag is "HEAD", special case to get head RCS revision */
if|if
condition|(
name|tag
operator|&&
name|STREQ
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
condition|)
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
comment|/* If valid tag let translate_symtag say yea or nay. */
name|rev
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
condition|)
return|return
name|rev
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' does not exist"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* NOT REACHED -- error (1 ... ) does not return here */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the revision for a specific tag.  * If force_tag_match is set, return NULL if an exact match is not  * possible otherwise return RCS_head ().  We are careful to look for  * and handle "magic" revisions specially.  *   * If the matched tag is a branch tag, find the head of the branch.  *   * Returns pointer to newly malloc'd string, or NULL.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_gettag
parameter_list|(
name|rcs
parameter_list|,
name|symtag
parameter_list|,
name|force_tag_match
parameter_list|,
name|simple_tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|symtag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
modifier|*
name|simple_tag
decl_stmt|;
block|{
name|char
modifier|*
name|tag
init|=
name|symtag
decl_stmt|;
name|int
name|tag_allocated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX this is probably not necessary, --jtc */
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If tag is "HEAD", special case to get head RCS revision */
if|if
condition|(
name|tag
operator|&&
operator|(
name|STREQ
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
operator|||
operator|*
name|tag
operator|==
literal|'\0'
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* This #if 0 is only in the Cygnus code.  Why?  Death support?  */
then|if (force_tag_match&& (rcs->flags& VALID)&& (rcs->flags& INATTIC)) 	    return ((char *) NULL);
comment|/* head request for removed file */
then|else
endif|#
directive|endif
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|version
decl_stmt|;
comment|/* If we got a symbolic tag, resolve it to a numeric */
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|magic
decl_stmt|,
modifier|*
name|branch
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|tag
operator|=
name|version
expr_stmt|;
name|tag_allocated
operator|=
literal|1
expr_stmt|;
comment|/* 	     * If this is a magic revision, we turn it into either its 	     * physical branch equivalent (if one exists) or into 	     * its base revision, which we assume exists. 	     */
name|dots
operator|=
name|numdots
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|>
literal|2
operator|&&
operator|(
name|dots
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|branch
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|branch
operator|++
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's magic.  See if the branch exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|tag
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|branch
operator|)
return|;
block|}
return|return
operator|(
name|tag
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The tag wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*      * numeric tag processing:      *		1) revision number - just return it      *		2) branch number   - find head of branch      */
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|branch
decl_stmt|;
comment|/* we have a branch tag, so we need to walk the branch */
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_allocated
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
name|branch
return|;
block|}
else|else
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* we have a revision tag, so make sure it exists */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* We have found a numeric revision for the revision tag. 	       To support expanding the RCS keyword Name, if 	       SIMPLE_TAG is not NULL, tell the the caller that this 	       is a simple tag which co will recognize.  FIXME: Are 	       there other cases in which we should set this?  In 	       particular, what if we expand RCS keywords internally 	       without calling co?  */
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tag_allocated
condition|)
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
else|else
block|{
comment|/* The revision wasn't there, so return the head or NULL */
if|if
condition|(
name|tag_allocated
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return a "magic" revision as a virtual branch off of REV for the RCS file.  * A "magic" revision is one which is unique in the RCS file.  By unique, I  * mean we return a revision which:  *	- has a branch of 0 (see rcs.h RCS_MAGIC_BRANCH)  *	- has a revision component which is not an existing branch off REV  *	- has a revision component which is not an existing magic revision  *	- is an even-numbered revision, to avoid conflicts with vendor branches  * The first point is what makes it "magic".  *  * As an example, if we pass in 1.37 as REV, we will look for an existing  * branch called 1.37.2.  If it did not exist, we would look for an  * existing symbolic tag with a numeric part equal to 1.37.0.2.  If that  * didn't exist, then we know that the 1.37.2 branch can be reserved by  * creating a symbolic tag with 1.37.0.2 as the numeric part.  *  * This allows us to fork development with very little overhead -- just a  * symbolic tag is used in the RCS file.  When a commit is done, a physical  * branch is dynamically created to hold the new revision.  *  * Note: We assume that REV is an RCS revision and not a branch number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_rev
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|RCS_magicrev
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|rev_num
decl_stmt|;
name|char
modifier|*
name|xrev
decl_stmt|,
modifier|*
name|test_branch
decl_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* enough for .0.number */
name|check_rev
operator|=
name|xrev
expr_stmt|;
comment|/* only look at even numbered branches */
for|for
control|(
name|rev_num
operator|=
literal|2
init|;
condition|;
name|rev_num
operator|+=
literal|2
control|)
block|{
comment|/* see if the physical branch exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d"
argument_list|,
name|rev
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
name|test_branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|xrev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_branch
operator|!=
name|NULL
condition|)
comment|/* it did, so keep looking */
block|{
name|free
argument_list|(
name|test_branch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now, create a "magic" revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|rev
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
comment|/* walk the symbols list to see if a magic one already exists */
if|if
condition|(
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|checkmagic_proc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we found a free magic branch.  Claim it as ours */
return|return
operator|(
name|xrev
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc to look for a match in the symbols list.  * Returns 0 if the symbol does not match, 1 if it does.  */
end_comment

begin_function
specifier|static
name|int
name|checkmagic_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|check_rev
argument_list|,
name|p
operator|->
name|data
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number   * or symbolic tag resolves to a "branch" within the rcs file.  *  * FIXME: this is the same as RCS_nodeisbranch except for the special   *        case for handling a null rcsnode.  */
end_comment

begin_function
name|int
name|RCS_isbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
comment|/* assume a revision if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* now, look for a match in the symbols list */
return|return
operator|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number  * or symbolic tag resolves to a "branch" within the rcs file.  We do  * take into account any magic branches as well.  */
end_comment

begin_function
name|int
name|RCS_nodeisbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|version
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to malloc'ed memory which contains the branch  * for the specified *symbolic* tag.  Magic branches are handled correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_whatbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|dots
decl_stmt|;
comment|/* assume no branch if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* now, look for a match in the symbols list */
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|version
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|version
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|++
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* yep.  it's magic.  now, construct the real branch */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|version
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
name|magic
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the specified branch.  If the branch does not exist,  * return NULL or RCS_head depending on force_tag_match.  * Returns NULL or a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getbranch
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|RCSVers
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|nextvers
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* find out if the tag contains a dot, or is on the trunk */
name|cp
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* trunk processing is the special case */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for an extra . */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|rcs
operator|->
name|head
init|;
name|cp
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|xtag
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xstrdup
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
comment|/* if it had a `.', terminate the string so we have the base revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* look up the revision this branch is based on */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* put the . back so we have the branch again */
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* if the base revision didn't exist, return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* find the first element of the branch we are looking for */
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 for the extra '.' */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|head
operator|=
name|vn
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xtag
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|head
condition|)
block|{
comment|/* we didn't find a match so return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* now walk the next pointers of the branch */
name|nextvers
operator|=
name|p
operator|->
name|key
expr_stmt|;
do|do
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nextvers
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* a link in the chain is missing - return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|nextvers
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|nextvers
operator|!=
name|NULL
condition|)
do|;
comment|/* we have the version in our hand, so go for it */
return|return
operator|(
name|xstrdup
argument_list|(
name|vn
operator|->
name|version
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the head of the branch which REV is on.  REV can be a    branch tag or non-branch tag; symbolic or numeric.     Returns a newly malloc'd string.  Returns NULL if a symbolic name    isn't found.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_branch_head
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
modifier|*
name|num
decl_stmt|;
name|char
modifier|*
name|br
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
condition|)
return|return
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|rev
argument_list|)
condition|)
name|num
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
else|else
block|{
name|num
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|br
operator|=
name|truncate_revnum
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|retval
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|br
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|br
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|num
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Get the branch point for a particular branch, that is the first    revision on that branch.  For example, RCS_getbranchpoint (rcs,    "1.3.2") will normally return "1.3.2.1".  TARGET may be either a    branch number or a revision number; if a revnum, find the    branchpoint of the branch to which TARGET belongs.     Return RCS_head if TARGET is on the trunk or if the root node could    not be found (this is sort of backwards from our behavior on a branch;    the rationale is that the return value is a revision from which you    can start walking the next fields and end up at TARGET).    Return NULL on error.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getbranchpoint
parameter_list|(
name|rcs
parameter_list|,
name|target
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|char
modifier|*
name|branch
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|Node
modifier|*
name|vp
decl_stmt|;
name|RCSVers
modifier|*
name|rev
decl_stmt|;
name|int
name|dots
decl_stmt|,
name|isrevnum
decl_stmt|,
name|brlen
decl_stmt|;
name|dots
operator|=
name|numdots
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|isrevnum
operator|=
name|dots
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|dots
operator|==
literal|1
condition|)
comment|/* TARGET is a trunk revision; return rcs->head. */
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
comment|/* Get the revision number of the node at which TARGET's branch is        rooted.  If TARGET is a branch number, lop off the last field;        if it's a revision number, lop off the last *two* fields. */
name|branch
operator|=
name|xstrdup
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|bp
operator|=
name|strrchr
argument_list|(
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: confused revision number %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrevnum
condition|)
while|while
condition|(
operator|*
operator|--
name|bp
operator|!=
literal|'.'
condition|)
empty_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't find branch point %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rev
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|vp
operator|->
name|data
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'.'
condition|)
operator|++
name|bp
expr_stmt|;
name|brlen
operator|=
name|bp
operator|-
name|branch
expr_stmt|;
name|vp
operator|=
name|rev
operator|->
name|branches
operator|->
name|list
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|vp
operator|!=
name|rev
operator|->
name|branches
operator|->
name|list
condition|)
block|{
comment|/* BRANCH may be a genuine branch number, e.g. `1.1.3', or 	   maybe a full revision number, e.g. `1.1.3.6'.  We have 	   found our branch point if the first BRANCHLEN characters 	   of the revision number match, *and* if the following 	   character is a dot. */
if|if
condition|(
name|strncmp
argument_list|(
name|vp
operator|->
name|key
argument_list|,
name|branch
argument_list|,
name|brlen
argument_list|)
operator|==
literal|0
operator|&&
name|vp
operator|->
name|key
index|[
name|brlen
index|]
operator|==
literal|'.'
condition|)
break|break;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|rev
operator|->
name|branches
operator|->
name|list
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't find branch point %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|vp
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the RCS file.  If branch is set, this is the head of the  * branch, otherwise the real head.  * Returns NULL or a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_head
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * NOTE: we call getbranch with force_tag_match set to avoid any      * possibility of recursion      */
if|if
condition|(
name|rcs
operator|->
name|branch
condition|)
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|branch
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the most recent revision, based on the supplied date, but use some  * funky stuff and follow the vendor branch maybe  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getdate
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
init|=
name|NULL
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* if the head is on a branch, try the branch first */
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
comment|/* if we found a match, we are done */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* otherwise if we have a trunk, try it */
if|if
condition|(
name|rcs
operator|->
name|head
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* if the date of this one is before date, take it */
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
break|break;
block|}
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * at this point, either we have the revision we want, or we have the      * first revision on the trunk (1.1?) in our hands      */
comment|/* if we found what we're looking for, and it's not 1.1 return it */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|cur_rev
argument_list|,
literal|"1.1"
argument_list|)
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
comment|/* This is 1.1;  if the date of 1.1 is not the same as that for the 	   1.1.1.1 version, then return 1.1.  This happens when the first 	   version of a file is created by a regular cvs add and commit, 	   and there is a subsequent cvs import of the same file.  */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
literal|"1.1.1.1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
literal|"1.1"
argument_list|)
return|;
block|}
block|}
comment|/* look on the vendor branch */
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
comment|/*      * if we found a match, return it; otherwise, we return the first      * revision on the trunk or NULL depending on force_tag_match and the      * date of the first rev      */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
operator|!
name|force_tag_match
operator|||
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|vers
operator|->
name|version
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the last element on a branch that was put in before the specified  * date (return the rev or NULL)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|xbranch
decl_stmt|,
modifier|*
name|xrev
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* look up the first revision on the branch */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|xrev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* Tentatively use this revision, if it is early enough.  */
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
comment|/* If no branches list, return now.  This is what happens if the branch        is a (magic) branch with no revisions yet.  */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
return|;
comment|/* walk the branches list looking for the branch number */
name|xbranch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for the extra dot */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xbranch
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xbranch
argument_list|,
name|strlen
argument_list|(
name|xbranch
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
block|{
comment|/* This is what happens if the branch is a (magic) branch with 	   no revisions yet.  Similar to the case where vers->branches == 	   NULL, except here there was a another branch off the same 	   branchpoint.  */
return|return
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
return|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* walk the next pointers until you find the end, or the date is too late */
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
else|else
break|break;
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Return whatever we found, which may be NULL.  */
return|return
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two dates in RCS format. Beware the change in format on January 1,  * 2000, when years go from 2-digit to full format.  */
end_comment

begin_function
name|int
name|RCS_datecmp
parameter_list|(
name|date1
parameter_list|,
name|date2
parameter_list|)
name|char
modifier|*
name|date1
decl_stmt|,
decl|*
name|date2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|date1
argument_list|)
operator|-
name|strlen
argument_list|(
name|date2
argument_list|)
decl_stmt|;
return|return
operator|(
name|length_diff
condition|?
name|length_diff
else|:
name|strcmp
argument_list|(
name|date1
argument_list|,
name|date2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Look up revision REV in RCS and return the date specified for the    revision minus FUDGE seconds (FUDGE will generally be one, so that the    logically previous revision will be found later, or zero, if we want    the exact date).     The return value is the date being returned as a time_t, or (time_t)-1    on error (previously was documented as zero on error; I haven't checked    the callers to make sure that they really check for (time_t)-1, but    the latter is what this function really returns).  If DATE is non-NULL,    then it must point to MAXDATELEN characters, and we store the same    return value there in DATEFORM format.  */
end_comment

begin_function
name|time_t
name|RCS_getrevtime
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|date
parameter_list|,
name|fudge
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|fudge
decl_stmt|;
block|{
name|char
name|tdate
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|struct
name|tm
name|xtm
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|revdate
init|=
literal|0
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* look up the revision */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* split up the date */
name|ftm
operator|=
operator|&
name|xtm
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|ftm
operator|->
name|tm_year
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mon
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mday
argument_list|,
operator|&
name|ftm
operator|->
name|tm_hour
argument_list|,
operator|&
name|ftm
operator|->
name|tm_min
argument_list|,
operator|&
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
comment|/* If the year is from 1900 to 1999, RCS files contain only two        digits, and sscanf gives us a year from 0-99.  If the year is        2000+, RCS files contain all four digits and we subtract 1900,        because the tm_year field should contain years since 1900.  */
if|if
condition|(
name|ftm
operator|->
name|tm_year
operator|>
literal|1900
condition|)
name|ftm
operator|->
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* put the date in a form getdate can grok */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d GMT %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
comment|/* turn it into seconds since the epoch */
name|revdate
operator|=
name|get_date
argument_list|(
name|tdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|revdate
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|revdate
operator|-=
name|fudge
expr_stmt|;
comment|/* remove "fudge" seconds */
if|if
condition|(
name|date
condition|)
block|{
comment|/* put an appropriate string into ``date'' if we were given one */
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revdate
operator|)
return|;
block|}
end_function

begin_function
name|List
modifier|*
name|RCS_getlocks
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|locks_data
condition|)
block|{
name|rcs
operator|->
name|locks
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_locks
argument_list|(
name|rcs
operator|->
name|locks
argument_list|,
name|rcs
operator|->
name|locks_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|locks_data
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|locks_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rcs
operator|->
name|locks
return|;
block|}
end_function

begin_function
name|List
modifier|*
name|RCS_symbols
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|symbols_data
condition|)
block|{
name|rcs
operator|->
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_symbols
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|symbols_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rcs
operator|->
name|symbols
return|;
block|}
end_function

begin_comment
comment|/*  * Return the version associated with a particular symbolic tag.  * Returns NULL or a newly malloc'd string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|translate_symtag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|symbols
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* The symbols have already been converted into a list.  */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|xstrdup
argument_list|(
name|p
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|rcs
operator|->
name|symbols_data
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Look through the RCS symbols information.  This is like            do_symbols, but we don't add the information to a list.  In            most cases, we will only be called once for this file, so            generating the list is unnecessary overhead.  */
name|len
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rcs
operator|->
name|symbols_data
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
name|tag
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|==
name|rcs
operator|->
name|symbols_data
operator|||
name|whitespace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
index|[
name|len
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* We found the tag.  Return the version number.  */
name|cp
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|v
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|++
name|cp
expr_stmt|;
name|r
operator|=
name|xmalloc
argument_list|(
name|cp
operator|-
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|r
argument_list|,
name|v
argument_list|,
name|cp
operator|-
name|v
argument_list|)
expr_stmt|;
name|r
index|[
name|cp
operator|-
name|v
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|++
name|cp
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * The argument ARG is the getopt remainder of the -k option specified on the  * command line.  This function returns malloc'ed space that can be used  * directly in calls to RCS V5, with the -k flag munged correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_check_kflag
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|keyword_usage
index|[]
init|=
block|{
literal|"%s %s: invalid RCS keyword expansion mode\n"
block|,
literal|"Valid expansion modes include:\n"
block|,
literal|"   -kkv\tGenerate keywords using the default form.\n"
block|,
literal|"   -kkvl\tLike -kkv, except locker's name inserted.\n"
block|,
literal|"   -kk\tGenerate only keyword names in keyword strings.\n"
block|,
literal|"   -kv\tGenerate only keyword values in keyword strings.\n"
block|,
literal|"   -ko\tGenerate the old keyword string (no changes from checked in file).\n"
block|,
literal|"   -kb\tGenerate binary file unmodified (merges not allowed) (RCS 5.7).\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|,     }
decl_stmt|;
comment|/* Big enough to hold any of the strings from kflags.  */
name|char
name|karg
index|[
literal|10
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|cpp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|arg
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|cpp
operator|==
name|NULL
condition|)
block|{
name|usage
argument_list|(
name|keyword_usage
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|karg
argument_list|,
literal|"-k%s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xstrdup
argument_list|(
name|karg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do some consistency checks on the symbolic tag... These should equate  * pretty close to what RCS checks, though I don't know for certain.  */
end_comment

begin_function
name|void
name|RCS_check_tag
parameter_list|(
name|tag
parameter_list|)
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|invalid
init|=
literal|"$,.:;@"
decl_stmt|;
comment|/* invalid RCS tag characters */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/*      * The first character must be an alphabetic letter. The remaining      * characters cannot be non-visible graphic characters, and must not be      * in the set of "invalid" RCS identifier characters.      */
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|tag
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|tag
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' has non-visible graphic characters"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|invalid
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must not contain the characters `%s'"
argument_list|,
name|tag
argument_list|,
name|invalid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must start with a letter"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TRUE if argument has valid syntax for an RCS revision or   * branch number.  All characters must be digits or dots, first   * and last characters must be digits, and no two consecutive   * characters may be dots.  *  * Intended for classifying things, so this function doesn't   * call error.  */
end_comment

begin_function
name|int
name|RCS_valid_rev
parameter_list|(
name|rev
parameter_list|)
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
name|last
decl_stmt|,
name|c
decl_stmt|;
name|last
operator|=
operator|*
name|rev
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|last
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|rev
operator|++
operator|)
condition|)
comment|/* Extra parens placate -Wall gcc option */
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|'.'
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
name|last
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|last
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if RCS revision with TAG is a dead revision.  */
end_comment

begin_function
name|int
name|RCS_isdead
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|version
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
return|return
operator|(
name|version
operator|->
name|dead
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the RCS keyword expansion mode.  For example "b" for binary.    Returns a pointer into storage which is allocated and freed along with    the rest of the RCS information; the caller should not modify this    storage.  Returns NULL if the RCS file does not specify a keyword    expansion mode; for all other errors, die with a fatal error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getexpand
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
comment|/* Since RCS_parsercsfile_i now reads expand, don't need to worry        about RCS_reparsercsfile.  */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rcs
operator|->
name|expand
return|;
block|}
end_function

begin_comment
comment|/* Set keyword expansion mode to EXPAND.  For example "b" for binary.  */
end_comment

begin_function
name|void
name|RCS_setexpand
parameter_list|(
name|rcs
parameter_list|,
name|expand
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|expand
decl_stmt|;
block|{
comment|/* Since RCS_parsercsfile_i now reads expand, don't need to worry        about RCS_reparsercsfile.  */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|expand
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcs
operator|->
name|expand
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|expand
operator|=
name|xstrdup
argument_list|(
name|expand
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* RCS keywords, and a matching enum.  */
end_comment

begin_struct
struct|struct
name|rcs_keyword
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEYWORD_INIT
parameter_list|(
name|s
parameter_list|)
value|(s), sizeof (s) - 1
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|rcs_keyword
name|keywords
index|[]
init|=
block|{
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Author"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Date"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Header"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Id"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Locker"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Log"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Name"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"RCSfile"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Revision"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Source"
argument_list|)
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"State"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|keyword
block|{
name|KEYWORD_AUTHOR
init|=
literal|0
block|,
name|KEYWORD_DATE
block|,
name|KEYWORD_HEADER
block|,
name|KEYWORD_ID
block|,
name|KEYWORD_LOCKER
block|,
name|KEYWORD_LOG
block|,
name|KEYWORD_NAME
block|,
name|KEYWORD_RCSFILE
block|,
name|KEYWORD_REVISION
block|,
name|KEYWORD_SOURCE
block|,
name|KEYWORD_STATE
block|}
enum|;
end_enum

begin_comment
comment|/* Convert an RCS date string into a readable string.  This is like    the RCS date2str function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_date
parameter_list|(
name|rcs_date
parameter_list|)
specifier|const
name|char
modifier|*
name|rcs_date
decl_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|mon
decl_stmt|,
name|mday
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|rcs_date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|mon
argument_list|,
operator|&
name|mday
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|<
literal|1900
condition|)
name|year
operator|+=
literal|1900
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%04d/%02d/%02d %02d:%02d:%02d"
argument_list|,
name|year
argument_list|,
name|mon
argument_list|,
name|mday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Escape the characters in a string so that it can be included in an    RCS value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|escape_keyword_value
parameter_list|(
name|value
parameter_list|,
name|free_value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
modifier|*
name|free_value
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|value
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|free_value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|value
return|;
block|}
name|ret
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|free_value
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|value
operator|,
name|t
operator|=
name|ret
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
operator|,
name|t
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
operator|*
name|t
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'4'
expr_stmt|;
operator|*
name|t
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'4'
expr_stmt|;
operator|*
name|t
operator|=
literal|'4'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand RCS keywords in the memory buffer BUF of length LEN.  This    applies to file RCS and version VERS.  If NAME is not NULL, and is    not a numeric revision, then it is the symbolic tag used for the    checkout.  EXPAND indicates how to expand the keywords.  This    function sets *RETBUF and *RETLEN to the new buffer and length.    This function may modify the buffer BUF.  If BUF != *RETBUF, then    RETBUF is a newly allocated buffer.  */
end_comment

begin_function
specifier|static
name|void
name|expand_keywords
parameter_list|(
name|rcs
parameter_list|,
name|ver
parameter_list|,
name|name
parameter_list|,
name|log
parameter_list|,
name|loglen
parameter_list|,
name|expand
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|retbuf
parameter_list|,
name|retlen
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|RCSVers
modifier|*
name|ver
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|log
decl_stmt|;
name|size_t
name|loglen
decl_stmt|;
name|enum
name|kflag
name|expand
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|retbuf
decl_stmt|;
name|size_t
modifier|*
name|retlen
decl_stmt|;
block|{
struct|struct
name|expand_buffer
block|{
name|struct
name|expand_buffer
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|free_data
decl_stmt|;
block|}
modifier|*
name|ebufs
init|=
name|NULL
struct|;
name|struct
name|expand_buffer
modifier|*
name|ebuf_last
init|=
name|NULL
decl_stmt|;
name|size_t
name|ebuf_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|locker
decl_stmt|;
name|char
modifier|*
name|srch
decl_stmt|,
modifier|*
name|srch_next
decl_stmt|;
name|size_t
name|srch_len
decl_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_O
operator|||
name|expand
operator|==
name|KFLAG_B
condition|)
block|{
operator|*
name|retbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
return|return;
block|}
comment|/* If we are using -kkvl, dig out the locker information if any.  */
name|locker
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_KVL
condition|)
block|{
name|Node
modifier|*
name|lock
decl_stmt|;
name|lock
operator|=
name|findnode
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|ver
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|locker
operator|=
name|xstrdup
argument_list|(
name|lock
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* RCS keywords look like $STRING$ or $STRING: VALUE$.  */
name|srch
operator|=
name|buf
expr_stmt|;
name|srch_len
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|srch_next
operator|=
name|memchr
argument_list|(
name|srch
argument_list|,
literal|'$'
argument_list|,
name|srch_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|send
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
specifier|const
name|struct
name|rcs_keyword
modifier|*
name|keyword
decl_stmt|;
name|enum
name|keyword
name|kw
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|free_value
decl_stmt|;
name|char
modifier|*
name|sub
decl_stmt|;
name|size_t
name|sublen
decl_stmt|;
name|srch_len
operator|-=
operator|(
name|srch_next
operator|+
literal|1
operator|)
operator|-
name|srch
expr_stmt|;
name|srch
operator|=
name|srch_next
operator|+
literal|1
expr_stmt|;
comment|/* Look for the first non alphabetic character after the '$'.  */
name|send
operator|=
name|srch
operator|+
name|srch_len
expr_stmt|;
for|for
control|(
name|s
operator|=
name|srch
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
break|break;
comment|/* If the first non alphabetic character is not '$' or ':',            then this is not an RCS keyword.  */
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'$'
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|)
condition|)
continue|continue;
comment|/* See if this is one of the keywords.  */
name|slen
operator|=
name|s
operator|-
name|srch
expr_stmt|;
for|for
control|(
name|keyword
operator|=
name|keywords
init|;
name|keyword
operator|->
name|string
operator|!=
name|NULL
condition|;
name|keyword
operator|++
control|)
block|{
if|if
condition|(
name|keyword
operator|->
name|len
operator|==
name|slen
operator|&&
name|strncmp
argument_list|(
name|keyword
operator|->
name|string
argument_list|,
name|srch
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|keyword
operator|->
name|string
operator|==
name|NULL
condition|)
continue|continue;
name|kw
operator|=
operator|(
expr|enum
name|keyword
operator|)
operator|(
name|keyword
operator|-
name|keywords
operator|)
expr_stmt|;
comment|/* If the keyword ends with a ':', then the old value consists            of the characters up to the next '$'.  If there is no '$'            before the end of the line, though, then this wasn't an RCS            keyword after all.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|*
name|s
operator|!=
literal|'$'
condition|)
continue|continue;
block|}
comment|/* At this point we must replace the string from SRCH to S            with the expansion of the keyword KW.  */
comment|/* Get the value to use.  */
name|free_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_K
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|kw
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|KEYWORD_AUTHOR
case|:
name|value
operator|=
name|ver
operator|->
name|author
expr_stmt|;
break|break;
case|case
name|KEYWORD_DATE
case|:
name|value
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEYWORD_HEADER
case|:
case|case
name|KEYWORD_ID
case|:
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|free_path
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
if|if
condition|(
name|kw
operator|==
name|KEYWORD_HEADER
condition|)
name|path
operator|=
name|rcs
operator|->
name|path
expr_stmt|;
else|else
name|path
operator|=
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|escape_keyword_value
argument_list|(
name|path
argument_list|,
operator|&
name|free_path
argument_list|)
expr_stmt|;
name|date
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|author
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|state
argument_list|)
operator|+
operator|(
name|locker
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|locker
argument_list|)
operator|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%s %s %s %s %s%s%s"
argument_list|,
name|path
argument_list|,
name|ver
operator|->
name|version
argument_list|,
name|date
argument_list|,
name|ver
operator|->
name|author
argument_list|,
name|ver
operator|->
name|state
argument_list|,
name|locker
operator|!=
name|NULL
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|locker
operator|!=
name|NULL
condition|?
name|locker
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|KEYWORD_LOCKER
case|:
name|value
operator|=
name|locker
expr_stmt|;
break|break;
case|case
name|KEYWORD_LOG
case|:
case|case
name|KEYWORD_RCSFILE
case|:
name|value
operator|=
name|escape_keyword_value
argument_list|(
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
argument_list|,
operator|&
name|free_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORD_NAME
case|:
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
argument_list|)
condition|)
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
else|else
name|value
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KEYWORD_REVISION
case|:
name|value
operator|=
name|ver
operator|->
name|version
expr_stmt|;
break|break;
case|case
name|KEYWORD_SOURCE
case|:
name|value
operator|=
name|escape_keyword_value
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
operator|&
name|free_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORD_STATE
case|:
name|value
operator|=
name|ver
operator|->
name|state
expr_stmt|;
break|break;
block|}
block|}
name|sub
operator|=
name|xmalloc
argument_list|(
name|keyword
operator|->
name|len
operator|+
operator|(
name|value
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|value
argument_list|)
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_V
condition|)
block|{
comment|/* Decrement SRCH and increment S to remove the $                characters.  */
operator|--
name|srch
expr_stmt|;
operator|++
name|srch_len
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|sub
argument_list|,
name|keyword
operator|->
name|string
argument_list|)
expr_stmt|;
name|sublen
operator|=
name|strlen
argument_list|(
name|keyword
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_K
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|':'
expr_stmt|;
name|sub
index|[
name|sublen
operator|+
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|sublen
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
operator|&&
name|expand
operator|!=
name|KFLAG_K
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|' '
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* The Log keyword requires special handling.  This behaviour            is taken from RCS 5.7.  The special log message is what RCS            uses for ci -k.  */
if|if
condition|(
name|kw
operator|==
name|KEYWORD_LOG
operator|&&
operator|(
sizeof|sizeof
expr|"checked in with -k by "
operator|<=
name|loglen
operator|||
name|log
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|log
argument_list|,
literal|"checked in with -k by "
argument_list|,
sizeof|sizeof
expr|"checked in with -k by "
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|leader
decl_stmt|;
name|size_t
name|leader_len
decl_stmt|,
name|leader_sp_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|logend
decl_stmt|;
specifier|const
name|char
modifier|*
name|snl
decl_stmt|;
name|int
name|cnl
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|sl
decl_stmt|;
comment|/* We are going to insert the trailing $ ourselves, before                the log message, so we must remove it from S, if we                haven't done so already.  */
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
operator|++
name|s
expr_stmt|;
comment|/* CVS never has empty log messages, but old RCS files might.  */
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
name|log
operator|=
literal|""
expr_stmt|;
comment|/* Find the start of the line.  */
name|start
operator|=
name|srch
expr_stmt|;
while|while
condition|(
name|start
operator|>
name|buf
operator|&&
name|start
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|start
expr_stmt|;
comment|/* Copy the start of the line to use as a comment leader.  */
name|leader_len
operator|=
name|srch
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
operator|--
name|leader_len
expr_stmt|;
name|leader
operator|=
name|xmalloc
argument_list|(
name|leader_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|leader
argument_list|,
name|start
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|leader_sp_len
operator|=
name|leader_len
expr_stmt|;
while|while
condition|(
name|leader_sp_len
operator|>
literal|0
operator|&&
name|leader
index|[
name|leader_sp_len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|leader_sp_len
expr_stmt|;
comment|/* RCS does some checking for an old style of Log here, 	       but we don't bother.  RCS issues a warning if it 	       changes anything.  */
comment|/* Count the number of newlines in the log message so that 	       we know how many copies of the leader we will need.  */
name|cnl
operator|=
literal|0
expr_stmt|;
name|logend
operator|=
name|log
operator|+
name|loglen
expr_stmt|;
for|for
control|(
name|snl
operator|=
name|log
init|;
name|snl
operator|<
name|logend
condition|;
name|snl
operator|++
control|)
if|if
condition|(
operator|*
name|snl
operator|==
literal|'\n'
condition|)
operator|++
name|cnl
expr_stmt|;
name|date
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|sub
operator|=
name|xrealloc
argument_list|(
name|sub
argument_list|,
operator|(
name|sublen
operator|+
sizeof|sizeof
expr|"Revision"
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|author
argument_list|)
operator|+
name|loglen
operator|+
operator|(
name|cnl
operator|+
literal|2
operator|)
operator|*
name|leader_len
operator|+
literal|20
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|'$'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
block|}
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_len
expr_stmt|;
name|sprintf
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
literal|"Revision %s  %s  %s\n"
argument_list|,
name|ver
operator|->
name|version
argument_list|,
name|date
argument_list|,
name|ver
operator|->
name|author
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|strlen
argument_list|(
name|sub
operator|+
name|sublen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|sl
operator|=
name|log
expr_stmt|;
while|while
condition|(
name|sl
operator|<
name|logend
condition|)
block|{
if|if
condition|(
operator|*
name|sl
operator|==
literal|'\n'
condition|)
block|{
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_sp_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_sp_len
expr_stmt|;
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
operator|++
name|sl
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|slnl
decl_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_len
expr_stmt|;
for|for
control|(
name|slnl
operator|=
name|sl
init|;
name|slnl
operator|<
name|logend
operator|&&
operator|*
name|slnl
operator|!=
literal|'\n'
condition|;
operator|++
name|slnl
control|)
empty_stmt|;
if|if
condition|(
name|slnl
operator|<
name|logend
condition|)
operator|++
name|slnl
expr_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|sl
argument_list|,
name|slnl
operator|-
name|sl
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|slnl
operator|-
name|sl
expr_stmt|;
name|sl
operator|=
name|slnl
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_sp_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_sp_len
expr_stmt|;
name|free
argument_list|(
name|leader
argument_list|)
expr_stmt|;
block|}
comment|/* Now SUB contains a string which is to replace the string 	   from SRCH to S.  SUBLEN is the length of SUB.  */
if|if
condition|(
name|srch
operator|+
name|sublen
operator|==
name|s
condition|)
block|{
name|memcpy
argument_list|(
name|srch
argument_list|,
name|sub
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|expand_buffer
modifier|*
name|ebuf
decl_stmt|;
comment|/* We need to change the size of the buffer.  We build a                list of expand_buffer structures.  Each expand_buffer                structure represents a portion of the final output.  We                concatenate them back into a single buffer when we are                done.  This minimizes the number of potentially large                buffer copies we must do.  */
if|if
condition|(
name|ebufs
operator|==
name|NULL
condition|)
block|{
name|ebufs
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebufs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebufs
operator|->
name|data
operator|=
name|buf
expr_stmt|;
name|ebufs
operator|->
name|free_data
operator|=
literal|0
expr_stmt|;
name|ebuf_len
operator|=
name|srch
operator|-
name|buf
expr_stmt|;
name|ebufs
operator|->
name|len
operator|=
name|ebuf_len
expr_stmt|;
name|ebuf_last
operator|=
name|ebufs
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|srch
operator|>=
name|ebuf_last
operator|->
name|data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|srch
operator|<=
name|ebuf_last
operator|->
name|data
operator|+
name|ebuf_last
operator|->
name|len
argument_list|)
expr_stmt|;
name|ebuf_len
operator|-=
name|ebuf_last
operator|->
name|len
operator|-
operator|(
name|srch
operator|-
name|ebuf_last
operator|->
name|data
operator|)
expr_stmt|;
name|ebuf_last
operator|->
name|len
operator|=
name|srch
operator|-
name|ebuf_last
operator|->
name|data
expr_stmt|;
block|}
name|ebuf
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebuf
operator|->
name|data
operator|=
name|sub
expr_stmt|;
name|ebuf
operator|->
name|len
operator|=
name|sublen
expr_stmt|;
name|ebuf
operator|->
name|free_data
operator|=
literal|1
expr_stmt|;
name|ebuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebuf_last
operator|->
name|next
operator|=
name|ebuf
expr_stmt|;
name|ebuf_last
operator|=
name|ebuf
expr_stmt|;
name|ebuf_len
operator|+=
name|sublen
expr_stmt|;
name|ebuf
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebuf
operator|->
name|data
operator|=
name|s
expr_stmt|;
name|ebuf
operator|->
name|len
operator|=
name|srch_len
operator|-
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
name|ebuf
operator|->
name|free_data
operator|=
literal|0
expr_stmt|;
name|ebuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebuf_last
operator|->
name|next
operator|=
name|ebuf
expr_stmt|;
name|ebuf_last
operator|=
name|ebuf
expr_stmt|;
name|ebuf_len
operator|+=
name|srch_len
operator|-
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
block|}
name|srch_len
operator|-=
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
name|srch
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|locker
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|locker
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebufs
operator|==
name|NULL
condition|)
block|{
operator|*
name|retbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|ebuf_len
argument_list|)
expr_stmt|;
operator|*
name|retbuf
operator|=
name|ret
expr_stmt|;
operator|*
name|retlen
operator|=
name|ebuf_len
expr_stmt|;
while|while
condition|(
name|ebufs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|expand_buffer
modifier|*
name|next
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ebufs
operator|->
name|data
argument_list|,
name|ebufs
operator|->
name|len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|ebufs
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|ebufs
operator|->
name|free_data
condition|)
name|free
argument_list|(
name|ebufs
operator|->
name|data
argument_list|)
expr_stmt|;
name|next
operator|=
name|ebufs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ebufs
argument_list|)
expr_stmt|;
name|ebufs
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check out a revision from an RCS file.     If PFN is not NULL, then ignore WORKFILE and SOUT.  Call PFN zero    or more times with the contents of the file.  CALLERDAT is passed,    uninterpreted, to PFN.  (The current code will always call PFN    exactly once for a non empty file; however, the current code    assumes that it can hold the entire file contents in memory, which    is not a good assumption, and might change in the future).     Otherwise, if WORKFILE is not NULL, check out the revision to    WORKFILE.  However, if WORKFILE is not NULL, and noexec is set,    then don't do anything.     Otherwise, if WORKFILE is NULL, check out the revision to SOUT.  If    SOUT is RUN_TTY, then write the contents of the revision to    standard output.  When using SOUT, the output is generally a    temporary file; don't bother to get the file modes correct.     REV is the numeric revision to check out.  It may be NULL, which    means to check out the head of the default branch.     If NAMETAG is not NULL, and is not a numeric revision, then it is    the tag that should be used when expanding the RCS Name keyword.     OPTIONS is a string such as "-kb" or "-kv" for keyword expansion    options.  It may be NULL to use the default expansion mode of the    file, typically "-kkv".     On an error which prevented checking out the file, either print a    nonfatal error and return 1, or give a fatal error.  On success,    return 0.  */
end_comment

begin_comment
comment|/* This function mimics the behavior of `rcs co' almost exactly.  The    chief difference is in its support for preserving file ownership,    permissions, and special files across checkin and checkout -- see    comments in RCS_checkin for some issues about this. -twp */
end_comment

begin_function
name|int
name|RCS_checkout
parameter_list|(
name|rcs
parameter_list|,
name|workfile
parameter_list|,
name|rev
parameter_list|,
name|nametag
parameter_list|,
name|options
parameter_list|,
name|sout
parameter_list|,
name|pfn
parameter_list|,
name|callerdat
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|nametag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|sout
decl_stmt|;
name|RCSCHECKOUTPROC
name|pfn
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
block|{
name|int
name|free_rev
init|=
literal|0
decl_stmt|;
name|enum
name|kflag
name|expand
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|ofp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|free_value
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|log
init|=
name|NULL
decl_stmt|;
name|size_t
name|loglen
decl_stmt|;
name|Node
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
name|uid_t
name|rcs_owner
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|gid_t
name|rcs_group
init|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|mode_t
name|rcs_mode
decl_stmt|;
name|int
name|change_rcs_owner_or_group
init|=
literal|0
decl_stmt|;
name|int
name|change_rcs_mode
init|=
literal|0
decl_stmt|;
name|int
name|special_file
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|devnum_long
decl_stmt|;
name|dev_t
name|devnum
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> checkout (%s, %s, %s, %s)\n"
argument_list|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|server_active
condition|?
literal|"S"
else|:
literal|" "
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
name|rcs
operator|->
name|path
argument_list|,
name|rev
operator|!=
name|NULL
condition|?
name|rev
else|:
literal|""
argument_list|,
name|options
operator|!=
name|NULL
condition|?
name|options
else|:
literal|""
argument_list|,
operator|(
name|pfn
operator|!=
name|NULL
condition|?
literal|"(function)"
else|:
operator|(
name|workfile
operator|!=
name|NULL
condition|?
name|workfile
else|:
operator|(
name|sout
operator|!=
name|RUN_TTY
condition|?
name|sout
else|:
literal|"(stdout)"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|rev
operator|==
name|NULL
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
operator|&&
name|workfile
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|sout
operator|==
name|RUN_TTY
operator|||
name|workfile
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pfn
operator|==
name|NULL
operator|||
operator|(
name|sout
operator|==
name|RUN_TTY
operator|&&
name|workfile
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
comment|/* Some callers, such as Checkin or remove_file, will pass us a        branch.  */
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|rev
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: bad branch tag in checkout"
argument_list|)
expr_stmt|;
name|free_rev
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
name|STREQ
argument_list|(
name|rev
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
condition|)
block|{
name|int
name|gothead
decl_stmt|;
comment|/* We want the head revision.  Try to read it directly.  */
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
else|else
name|rcsbuf_cache_open
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|delta_pos
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
name|gothead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rcsbuf_getrevnum
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected EOF reading %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|rcsbuf_getkey
argument_list|(
operator|&
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
condition|)
name|log
operator|=
name|rcsbuf_valcopy
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|&
name|loglen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
condition|)
block|{
name|gothead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|gothead
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: cannot find head text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rcsbuf_valpolish
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcsbuf_cache
argument_list|(
name|rcs
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|rcsbuffer
modifier|*
name|rcsbufp
decl_stmt|;
comment|/* It isn't the head revision of the trunk.  We'll need to 	   walk through the deltas.  */
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* If RCS_deltas didn't close the file, we could use fstat 	       here too.  Probably should change it thusly....  */
if|if
condition|(
name|stat
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcsbufp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcsbufp
operator|=
operator|&
name|rcsbuf
expr_stmt|;
block|}
name|RCS_deltas
argument_list|(
name|rcs
argument_list|,
name|fp
argument_list|,
name|rcsbufp
argument_list|,
name|rev
argument_list|,
name|RCS_FETCH
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|log
argument_list|,
operator|&
name|loglen
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If OPTIONS is NULL or the empty string, then the old code would        invoke the RCS co program with no -k option, which means that        co would use the string we have stored in rcs->expand.  */
if|if
condition|(
operator|(
name|options
operator|==
name|NULL
operator|||
name|options
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|rcs
operator|->
name|expand
operator|==
name|NULL
condition|)
name|expand
operator|=
name|KFLAG_KV
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|ouroptions
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cpp
decl_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|assert
argument_list|(
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
argument_list|)
expr_stmt|;
name|ouroptions
operator|=
name|options
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|ouroptions
operator|=
name|rcs
operator|->
name|expand
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|cpp
argument_list|,
name|ouroptions
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cpp
operator|!=
name|NULL
condition|)
name|expand
operator|=
operator|(
expr|enum
name|kflag
operator|)
operator|(
name|cpp
operator|-
name|kflags
operator|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: unsupported substitution string -k%s"
argument_list|,
name|ouroptions
argument_list|)
expr_stmt|;
name|expand
operator|=
name|KFLAG_KV
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* Handle special files and permissions, if that is desired. */
if|if
condition|(
name|preserve_perms
condition|)
block|{
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|Node
modifier|*
name|info
decl_stmt|;
name|vp
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no revision information for %s"
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|vp
operator|->
name|data
expr_stmt|;
comment|/* First we look for symlinks, which are simplest to handle. */
name|info
operator|=
name|findnode
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
literal|"symlink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|pfn
operator|!=
name|NULL
operator|||
operator|(
name|workfile
operator|==
name|NULL
operator|&&
name|sout
operator|==
name|RUN_TTY
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"symbolic link %s:%s cannot be piped"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|vers
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
name|dest
operator|=
name|sout
expr_stmt|;
else|else
name|dest
operator|=
name|workfile
expr_stmt|;
comment|/* Remove `dest', just in case.  It's okay to get ENOENT here, 	       since we just want the file not to be there.  (TODO: decide 	       whether it should be considered an error for `dest' to exist 	       at this point.  If so, the unlink call should be removed and 	       `symlink' should signal the error. -twp) */
if|if
condition|(
name|unlink
argument_list|(
name|dest
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|info
operator|->
name|data
argument_list|,
name|dest
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create symbolic link from %s to %s"
argument_list|,
name|dest
argument_list|,
name|info
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Next, we look at this file's hardlinks field, and see whether 	   it is linked to any other file that has been checked out. 	   If so, we don't do anything else -- just link it to that file.  	   If we are checking out a file to a pipe or temporary storage, 	   none of this should matter.  Hence the `workfile != NULL' 	   wrapper around the whole thing. -twp */
if|if
condition|(
name|workfile
operator|!=
name|NULL
condition|)
block|{
name|List
modifier|*
name|links
init|=
name|vers
operator|->
name|hardlinks
decl_stmt|;
if|if
condition|(
name|links
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|uptodate_link
decl_stmt|;
comment|/* For each file in the hardlinks field, check to see 		   if it exists, and if so, if it has been checked out 		   this iteration.  When walklist returns, uptodate_link 		   should point to a hardlist node representing a file 		   in `links' which has recently been checked out, or 		   NULL if no file in `links' has yet been checked out. */
name|uptodate_link
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|links
argument_list|,
name|find_checkedout_proc
argument_list|,
operator|&
name|uptodate_link
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|links
argument_list|)
expr_stmt|;
comment|/* If we've found a file that `workfile' is supposed to be 		   linked to, and it has been checked out since CVS was 		   invoked, then simply link workfile to that file and return.  		   If one of these conditions is not met, then 		   workfile is the first one in its hardlink group to 		   be checked out, and we must continue with a full 		   checkout. */
if|if
condition|(
name|uptodate_link
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hardlink_info
modifier|*
name|hlinfo
init|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|uptodate_link
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|link
argument_list|(
name|uptodate_link
operator|->
name|key
argument_list|,
name|workfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot link %s to %s"
argument_list|,
name|workfile
argument_list|,
name|uptodate_link
operator|->
name|key
argument_list|)
expr_stmt|;
name|hlinfo
operator|->
name|checked_out
operator|=
literal|1
expr_stmt|;
comment|/* probably unnecessary */
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
name|info
operator|=
name|findnode
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
literal|"owner"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|change_rcs_owner_or_group
operator|=
literal|1
expr_stmt|;
name|rcs_owner
operator|=
operator|(
name|uid_t
operator|)
name|strtoul
argument_list|(
name|info
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|info
operator|=
name|findnode
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|change_rcs_owner_or_group
operator|=
literal|1
expr_stmt|;
name|rcs_group
operator|=
operator|(
name|gid_t
operator|)
name|strtoul
argument_list|(
name|info
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|info
operator|=
name|findnode
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
literal|"permissions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|change_rcs_mode
operator|=
literal|1
expr_stmt|;
name|rcs_mode
operator|=
operator|(
name|mode_t
operator|)
name|strtoul
argument_list|(
name|info
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|info
operator|=
name|findnode
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
literal|"special"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
comment|/* If the size of `devtype' changes, fix the sscanf call also */
name|char
name|devtype
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|info
operator|->
name|data
argument_list|,
literal|"%16s %lu"
argument_list|,
name|devtype
argument_list|,
operator|&
name|devnum_long
argument_list|)
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s:%s has bad `special' newphrase %s"
argument_list|,
name|workfile
argument_list|,
name|vers
operator|->
name|version
argument_list|,
name|info
operator|->
name|data
argument_list|)
expr_stmt|;
name|devnum
operator|=
name|devnum_long
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|devtype
argument_list|,
literal|"character"
argument_list|)
condition|)
name|special_file
operator|=
name|S_IFCHR
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|devtype
argument_list|,
literal|"block"
argument_list|)
condition|)
name|special_file
operator|=
name|S_IFBLK
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is a special file of unsupported type `%s'"
argument_list|,
name|workfile
argument_list|,
name|info
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|expand
operator|!=
name|KFLAG_O
operator|&&
name|expand
operator|!=
name|KFLAG_B
condition|)
block|{
name|char
modifier|*
name|newvalue
decl_stmt|;
comment|/* Don't fetch the delta node again if we already have it. */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|vp
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no revision information for %s"
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
block|}
name|expand_keywords
argument_list|(
name|rcs
argument_list|,
operator|(
name|RCSVers
operator|*
operator|)
name|vp
operator|->
name|data
argument_list|,
name|nametag
argument_list|,
name|log
argument_list|,
name|loglen
argument_list|,
name|expand
argument_list|,
name|value
argument_list|,
name|len
argument_list|,
operator|&
name|newvalue
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvalue
operator|!=
name|value
condition|)
block|{
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|newvalue
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pfn
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|special_file
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"special file %s cannot be piped to anything"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The PFN interface is very simple to implement right now, as            we always have the entire file in memory.  */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|pfn
argument_list|(
name|callerdat
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
elseif|else
if|if
condition|(
name|special_file
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MKNOD
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* Can send either to WORKFILE or to SOUT, as long as SOUT is 	   not RUN_TTY. */
name|dest
operator|=
name|workfile
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sout
operator|==
name|RUN_TTY
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"special file %s cannot be written to stdout"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|dest
operator|=
name|sout
expr_stmt|;
block|}
comment|/* Unlink `dest', just in case.  It's okay if this provokes a 	   ENOENT error. */
if|if
condition|(
name|unlink
argument_list|(
name|dest
argument_list|)
operator|<
literal|0
operator|&&
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|mknod
argument_list|(
name|dest
argument_list|,
name|special_file
argument_list|,
name|devnum
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not create special file %s"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create %s: unable to create special files on this system"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
else|else
block|{
comment|/* Not a special file: write to WORKFILE or SOUT. */
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sout
operator|==
name|RUN_TTY
condition|)
name|ofp
operator|=
name|stdout
expr_stmt|;
else|else
block|{
comment|/* Symbolic links should be removed before replacement, so that 		   `fopen' doesn't follow the link and open the wrong file. */
if|if
condition|(
name|islink
argument_list|(
name|sout
argument_list|)
condition|)
if|if
condition|(
name|unlink_file
argument_list|(
name|sout
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|sout
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|CVS_FOPEN
argument_list|(
name|sout
argument_list|,
name|expand
operator|==
name|KFLAG_B
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Output is supposed to go to WORKFILE, so we should open that 	       file.  Symbolic links should be removed first (see above). */
if|if
condition|(
name|islink
argument_list|(
name|workfile
argument_list|)
condition|)
if|if
condition|(
name|unlink_file
argument_list|(
name|workfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|CVS_FOPEN
argument_list|(
name|workfile
argument_list|,
name|expand
operator|==
name|KFLAG_B
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
comment|/* If the open failed because the existing workfile was not 	       writable, try to chmod the file and retry the open.  */
if|if
condition|(
name|ofp
operator|==
name|NULL
operator|&&
name|errno
operator|==
name|EACCES
operator|&&
name|isfile
argument_list|(
name|workfile
argument_list|)
operator|&&
operator|!
name|iswritable
argument_list|(
name|workfile
argument_list|)
condition|)
block|{
name|xchmod
argument_list|(
name|workfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|CVS_FOPEN
argument_list|(
name|workfile
argument_list|,
name|expand
operator|==
name|KFLAG_B
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|workfile
operator|==
name|NULL
operator|&&
name|sout
operator|==
name|RUN_TTY
condition|)
block|{
if|if
condition|(
name|expand
operator|==
name|KFLAG_B
condition|)
name|cvs_output_binary
argument_list|(
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* cvs_output requires the caller to check for zero 		   length.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|cvs_output
argument_list|(
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NT 4.0 is said to have trouble writing 2099999 bytes 	       (for example) in a single fwrite.  So break it down 	       (there is no need to be writing that much at once 	       anyway; it is possible that LARGEST_FWRITE should be 	       somewhat larger for good performance, but for testing I 	       want to start with a small value until/unless a bigger 	       one proves useful).  */
define|#
directive|define
name|LARGEST_FWRITE
value|8192
name|size_t
name|nleft
init|=
name|len
decl_stmt|;
name|size_t
name|nstep
init|=
operator|(
name|len
operator|<
name|LARGEST_FWRITE
condition|?
name|len
else|:
name|LARGEST_FWRITE
operator|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|value
decl_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|nstep
argument_list|,
name|ofp
argument_list|)
operator|!=
name|nstep
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
operator|(
name|workfile
operator|!=
name|NULL
condition|?
name|workfile
else|:
operator|(
name|sout
operator|!=
name|RUN_TTY
condition|?
name|sout
else|:
literal|"stdout"
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|+=
name|nstep
expr_stmt|;
name|nleft
operator|-=
name|nstep
expr_stmt|;
if|if
condition|(
name|nleft
operator|<
name|nstep
condition|)
name|nstep
operator|=
name|nleft
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
operator|!
name|special_file
operator|&&
name|fclose
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|change_rcs_owner_or_group
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|workfile
argument_list|,
name|rcs_owner
argument_list|,
name|rcs_group
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"could not change owner or group of %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|chmod
argument_list|(
name|workfile
argument_list|,
name|change_rcs_mode
condition|?
name|rcs_mode
else|:
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fclose
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ret
operator|=
name|chmod
argument_list|(
name|workfile
argument_list|,
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sout
operator|!=
name|RUN_TTY
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
operator|!
name|special_file
operator|&&
endif|#
directive|endif
name|fclose
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|sout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* If we are in the business of preserving hardlinks, then        mark this file as having been checked out. */
if|if
condition|(
name|preserve_perms
operator|&&
name|workfile
operator|!=
name|NULL
condition|)
name|update_hardlink_info
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|RCSVers
modifier|*
name|RCS_findlock_or_tip
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the delta currently locked by the user.  From the `ci' man page:  	"If rev is omitted, ci tries to  derive  the  new  revision 	 number  from  the  caller's  last lock.  If the caller has 	 locked the tip revision of a branch, the new  revision  is 	 appended  to  that  branch.   The  new  revision number is 	 obtained by incrementing the tip revision number.  If  the 	 caller  locked a non-tip revision, a new branch is started 	 at that revision by incrementing the highest branch number 	 at  that  revision.   The default initial branch and level 	 numbers are 1.  	 If rev is omitted and the caller has no lock, but owns the 	 file  and  locking is not set to strict, then the revision 	 is appended to the default branch (normally the trunk; see 	 the -b option of rcs(1))."     RCS_findlock_or_tip finds the unique revision locked by the caller    and returns its delta node.  If the caller has not locked any    revisions (and is permitted to commit to an unlocked delta, as    described above), return the tip of the default branch. */
end_comment

begin_function
specifier|static
name|RCSVers
modifier|*
name|RCS_findlock_or_tip
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|char
modifier|*
name|user
init|=
name|getcaller
argument_list|()
decl_stmt|;
name|Node
modifier|*
name|lock
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|locklist
decl_stmt|;
comment|/* Find unique delta locked by caller. This code is very similar        to the code in RCS_unlock -- perhaps it could be abstracted        into a RCS_findlock function. */
name|locklist
operator|=
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|locklist
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|locklist
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|data
argument_list|,
name|user
argument_list|)
condition|)
block|{
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ %s: multiple revisions locked by %s; please specify one"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
block|{
comment|/* Found an old lock, but check that the revision still exists. */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|lock
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't unlock nonexistent revision %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|lock
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
return|;
block|}
comment|/* No existing lock.  The RCS rule is that this is an error unless        locking is nonstrict AND the file is owned by the current        user.  Trying to determine the latter is a portability nightmare        in the face of NT, VMS, AFS, and other systems with non-unix-like        ideas of users and owners.  In the case of CVS, we should never get        here (as long as the traditional behavior of making sure to call        RCS_lock persists).  Anyway, we skip the RCS error checks        and just return the default branch or head.  The reasoning is that        those error checks are to make users lock before a checkin, and we do        that in other ways if at all anyway (e.g. rcslock.pl).  */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|branch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Revision number string, R, must contain a `.'.    Return a newly-malloc'd copy of the prefix of R up    to but not including the final `.'.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|truncate_revnum
parameter_list|(
name|r
parameter_list|)
specifier|const
name|char
modifier|*
name|r
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|new_r
decl_stmt|;
name|char
modifier|*
name|dot
init|=
name|strrchr
argument_list|(
name|r
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|len
operator|=
name|dot
operator|-
name|r
expr_stmt|;
name|new_r
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_r
argument_list|,
name|r
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|new_r
operator|+
name|len
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new_r
return|;
block|}
end_function

begin_comment
comment|/* Revision number string, R, must contain a `.'.    R must be writable.  Replace the rightmost `.' in R with    the NUL byte and return a pointer to that NUL byte.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|truncate_revnum_in_place
parameter_list|(
name|r
parameter_list|)
name|char
modifier|*
name|r
decl_stmt|;
block|{
name|char
modifier|*
name|dot
init|=
name|strrchr
argument_list|(
name|r
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|dot
argument_list|)
expr_stmt|;
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dot
return|;
block|}
end_function

begin_comment
comment|/* Revision number strings, R and S, must each contain a `.'.    R and S must be writable and must have the same number of dots.    Truncate R and S for the comparison, then restored them to their    original state.    Return the result (see compare_revnums) of comparing R and S    ignoring differences in any component after the rightmost `.'.  */
end_comment

begin_function
specifier|static
name|int
name|compare_truncated_revnums
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|r_dot
init|=
name|truncate_revnum_in_place
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s_dot
init|=
name|truncate_revnum_in_place
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|assert
argument_list|(
name|numdots
argument_list|(
name|r
argument_list|)
operator|==
name|numdots
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|compare_revnums
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|r_dot
operator|=
literal|'.'
expr_stmt|;
operator|*
name|s_dot
operator|=
literal|'.'
expr_stmt|;
return|return
name|cmp
return|;
block|}
end_function

begin_comment
comment|/* Return a malloc'd copy of the string representing the highest branch    number on BRANCHNODE.  If there are no branches on BRANCHNODE, return NULL.    FIXME: isn't the max rev always the last one?    If so, we don't even need a loop.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|max_rev
name|PROTO
argument_list|(
operator|(
specifier|const
name|RCSVers
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|max_rev
parameter_list|(
name|branchnode
parameter_list|)
specifier|const
name|RCSVers
modifier|*
name|branchnode
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|;
name|Node
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|max
decl_stmt|;
if|if
condition|(
name|branchnode
operator|->
name|branches
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|max
operator|=
name|NULL
expr_stmt|;
name|head
operator|=
name|branchnode
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|head
operator|->
name|next
init|;
name|bp
operator|!=
name|head
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|max
operator|==
name|NULL
operator|||
name|compare_truncated_revnums
argument_list|(
name|max
argument_list|,
name|bp
operator|->
name|key
argument_list|)
operator|<
literal|0
condition|)
block|{
name|max
operator|=
name|bp
operator|->
name|key
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|max
argument_list|)
expr_stmt|;
return|return
name|truncate_revnum
argument_list|(
name|max
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create BRANCH in RCS's delta tree.  BRANCH may be either a branch    number or a revision number.  In the former case, create the branch    with the specified number; in the latter case, create a new branch    rooted at node BRANCH with a higher branch number than any others.    Return the number of the tip node on the new branch. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_addbranch
parameter_list|(
name|rcs
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
modifier|*
name|branchpoint
decl_stmt|,
modifier|*
name|newrevnum
decl_stmt|;
name|Node
modifier|*
name|nodep
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|Node
modifier|*
name|marker
decl_stmt|;
name|RCSVers
modifier|*
name|branchnode
decl_stmt|;
comment|/* Append to end by default.  */
name|marker
operator|=
name|NULL
expr_stmt|;
name|branchpoint
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|branchpoint
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|truncate_revnum_in_place
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
block|}
comment|/* Find the branch rooted at BRANCHPOINT. */
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|branchpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodep
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't find branch point %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|branchpoint
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|free
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
name|branchnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
comment|/* If BRANCH was a full branch number, make sure it is higher than MAX. */
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|branch
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|branchnode
operator|->
name|branches
operator|==
name|NULL
condition|)
block|{
comment|/* We have to create the first branch on this node, which means 	       appending ".2" to the revision number. */
name|newrevnum
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newrevnum
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newrevnum
argument_list|,
literal|".2"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|max
init|=
name|max_rev
argument_list|(
name|branchnode
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|newrevnum
operator|=
name|increment_revnum
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newrevnum
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchnode
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|head
decl_stmt|;
name|Node
modifier|*
name|bp
decl_stmt|;
comment|/* Find the position of this new branch in the sorted list 	       of branches.  */
name|head
operator|=
name|branchnode
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|head
operator|->
name|next
init|;
name|bp
operator|!=
name|head
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
name|int
name|found_pos
decl_stmt|;
comment|/* The existing list must be sorted on increasing revnum.  */
name|assert
argument_list|(
name|bp
operator|->
name|next
operator|==
name|head
operator|||
name|compare_truncated_revnums
argument_list|(
name|bp
operator|->
name|key
argument_list|,
name|bp
operator|->
name|next
operator|->
name|key
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|dot
operator|=
name|truncate_revnum_in_place
argument_list|(
name|bp
operator|->
name|key
argument_list|)
expr_stmt|;
name|found_pos
operator|=
operator|(
name|compare_revnums
argument_list|(
name|branch
argument_list|,
name|bp
operator|->
name|key
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
operator|*
name|dot
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|found_pos
condition|)
block|{
break|break;
block|}
block|}
name|marker
operator|=
name|bp
expr_stmt|;
block|}
block|}
name|newrevnum
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|newrevnum
argument_list|,
name|strlen
argument_list|(
name|newrevnum
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newrevnum
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
comment|/* Add this new revision number to BRANCHPOINT's branches list. */
if|if
condition|(
name|branchnode
operator|->
name|branches
operator|==
name|NULL
condition|)
name|branchnode
operator|->
name|branches
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|bp
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|bp
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|newrevnum
argument_list|)
expr_stmt|;
comment|/* Append to the end of the list by default, that is, just before        the header node, `list'.  */
if|if
condition|(
name|marker
operator|==
name|NULL
condition|)
name|marker
operator|=
name|branchnode
operator|->
name|branches
operator|->
name|list
expr_stmt|;
block|{
name|int
name|fail
decl_stmt|;
name|fail
operator|=
name|insert_before
argument_list|(
name|branchnode
operator|->
name|branches
argument_list|,
name|marker
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|fail
argument_list|)
expr_stmt|;
block|}
return|return
name|newrevnum
return|;
block|}
end_function

begin_comment
comment|/* Check in to RCSFILE with revision REV (which must be greater than    the largest revision) and message MESSAGE (which is checked for    legality).  If FLAGS& RCS_FLAGS_DEAD, check in a dead revision.    If FLAGS& RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS&    RCS_FLAGS_MODTIME, use the working file's modification time for the    checkin time.  WORKFILE is the working file to check in from, or    NULL to use the usual RCS rules for deriving it from the RCSFILE.    If FLAGS& RCS_FLAGS_KEEPFILE, don't unlink the working file;    unlinking the working file is standard RCS behavior, but is rarely    appropriate for CVS.     This function should almost exactly mimic the behavior of `rcs ci'.  The    principal point of difference is the support here for preserving file    ownership and permissions in the delta nodes.  This is not a clean    solution -- precisely because it diverges from RCS's behavior -- but    it doesn't seem feasible to do this anywhere else in the code. [-twp]        Return value is -1 for error (and errno is set to indicate the    error), positive for error (and an error message has been printed),    or zero for success.  */
end_comment

begin_function
name|int
name|RCS_checkin
parameter_list|(
name|rcs
parameter_list|,
name|workfile
parameter_list|,
name|message
parameter_list|,
name|rev
parameter_list|,
name|flags
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|delta
decl_stmt|,
modifier|*
name|commitpt
decl_stmt|;
name|Deltatext
modifier|*
name|dtext
decl_stmt|;
name|Node
modifier|*
name|nodep
decl_stmt|;
name|char
modifier|*
name|tmpfile
decl_stmt|,
modifier|*
name|changefile
decl_stmt|,
modifier|*
name|chtext
decl_stmt|;
name|char
modifier|*
name|diffopts
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|chtextlen
decl_stmt|;
name|int
name|status
decl_stmt|,
name|checkin_quiet
decl_stmt|,
name|allocated_workfile
decl_stmt|;
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
name|int
name|adding_branch
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
name|struct
name|stat
name|sb
decl_stmt|;
endif|#
directive|endif
name|commitpt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get basename of working file.  Is there a library function to        do this?  I couldn't find one. -twp */
name|allocated_workfile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|extlen
init|=
name|strlen
argument_list|(
name|RCSEXT
argument_list|)
decl_stmt|;
name|workfile
operator|=
name|xstrdup
argument_list|(
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|workfile
operator|+
operator|(
name|strlen
argument_list|(
name|workfile
argument_list|)
operator|-
name|extlen
operator|)
expr_stmt|;
name|assert
argument_list|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|RCSEXT
argument_list|,
name|extlen
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|allocated_workfile
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the filename is a symbolic link, follow it and replace it        with the destination of the link.  We need to do this before        calling rcs_internal_lockfile, or else we won't put the lock in        the right place. */
name|resolve_symlink
argument_list|(
operator|&
operator|(
name|rcs
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|checkin_quiet
operator|=
name|flags
operator|&
name|RCS_FLAGS_QUIET
expr_stmt|;
if|if
condition|(
operator|!
name|checkin_quiet
condition|)
block|{
name|cvs_output
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"<--  "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|workfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Create new delta node. */
name|delta
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|delta
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|->
name|author
operator|=
name|xstrdup
argument_list|(
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RCS_FLAGS_MODTIME
condition|)
block|{
name|struct
name|stat
name|ws
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|workfile
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
name|modtime
operator|=
name|ws
operator|.
name|st_mtime
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|modtime
argument_list|)
expr_stmt|;
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|modtime
argument_list|)
expr_stmt|;
name|delta
operator|->
name|date
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAXDATELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|delta
operator|->
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RCS_FLAGS_DEAD
condition|)
block|{
name|delta
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
name|RCSDEAD
argument_list|)
expr_stmt|;
name|delta
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|delta
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
literal|"Exp"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* If permissions should be preserved on this project, then        save the permission info. */
if|if
condition|(
name|preserve_perms
condition|)
block|{
name|Node
modifier|*
name|np
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* static buffer should be safe: see usage. -twp */
name|delta
operator|->
name|other_delta
operator|=
name|getlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|workfile
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|"cannot lstat %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|np
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|np
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"symlink"
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
operator|=
name|xreadlink
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|delta
operator|->
name|other_delta
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%u"
argument_list|,
name|sb
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|np
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|np
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"owner"
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|delta
operator|->
name|other_delta
argument_list|,
name|np
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%u"
argument_list|,
name|sb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|np
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|np
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"group"
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|delta
operator|->
name|other_delta
argument_list|,
name|np
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%o"
argument_list|,
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|np
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|np
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"permissions"
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|delta
operator|->
name|other_delta
argument_list|,
name|np
argument_list|)
expr_stmt|;
comment|/* Save device number. */
switch|switch
condition|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
ifdef|#
directive|ifdef
name|HAVE_ST_RDEV
name|np
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|np
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"special"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %lu"
argument_list|,
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|?
literal|"character"
else|:
literal|"block"
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|np
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|delta
operator|->
name|other_delta
argument_list|,
name|np
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't preserve %s: unable to save device files on this system"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"special file %s has unknown type"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
comment|/* Save hardlinks. */
name|delta
operator|->
name|hardlinks
operator|=
name|list_linked_files_on_disk
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Create a new deltatext node. */
name|dtext
operator|=
operator|(
name|Deltatext
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dtext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|dtext
operator|->
name|log
operator|=
name|make_message_rcslegal
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* If the delta tree is empty, then there's nothing to link the        new delta into.  So make a new delta tree, snarf the working        file contents, and just write the new RCS file. */
if|if
condition|(
name|rcs
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|newrev
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
comment|/* Figure out what the first revision number should be. */
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|*
name|rev
operator|==
literal|'\0'
condition|)
name|newrev
operator|=
name|xstrdup
argument_list|(
literal|"1.1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newrev
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newrev
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newrev
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
block|}
else|else
name|newrev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
comment|/* Don't need to xstrdup NEWREV because it's already dynamic, and 	   not used for anything else.  (Don't need to free it, either.) */
name|rcs
operator|->
name|head
operator|=
name|newrev
expr_stmt|;
name|delta
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|nodep
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|nodep
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|nodep
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|nodep
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|delta
expr_stmt|;
name|nodep
operator|->
name|key
operator|=
name|delta
operator|->
name|version
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
name|dtext
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|preserve_perms
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* Pretend file is empty.  */
name|bufsize
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
name|get_file
argument_list|(
name|workfile
argument_list|,
name|workfile
argument_list|,
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|,
operator|&
name|dtext
operator|->
name|text
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|dtext
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkin_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"initial revision: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcs
operator|->
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We are probably about to invalidate any cached file.  */
name|rcsbuf_cache_close
argument_list|()
expr_stmt|;
name|fout
operator|=
name|rcs_internal_lockfile
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|RCS_putadmin
argument_list|(
name|rcs
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|RCS_putdtree
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|head
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|RCS_putdesc
argument_list|(
name|rcs
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|delta_pos
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|delta_pos
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot ftell for %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|putdeltatext
argument_list|(
name|fout
argument_list|,
name|dtext
argument_list|)
expr_stmt|;
name|rcs_internal_unlockfile
argument_list|(
name|fout
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|RCS_FLAGS_KEEPFILE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|workfile
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checkin_quiet
condition|)
name|cvs_output
argument_list|(
literal|"done\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
comment|/* Derive a new revision number.  From the `ci' man page:  	 "If rev  is  a revision number, it must be higher than the 	 latest one on the branch to which  rev  belongs,  or  must 	 start a new branch.  	 If  rev is a branch rather than a revision number, the new 	 revision is appended to that branch.  The level number  is 	 obtained  by  incrementing the tip revision number of that 	 branch.  If rev  indicates  a  non-existing  branch,  that 	 branch  is  created  with  the  initial  revision numbered 	 rev.1."         RCS_findlock_or_tip handles the case where REV is omitted.        RCS 5.7 also permits REV to be "$" or to begin with a dot, but        we do not address those cases -- every routine that calls        RCS_checkin passes it a numeric revision. */
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|*
name|rev
operator|==
literal|'\0'
condition|)
block|{
comment|/* Figure out where the commit point is by looking for locks. 	   If the commit point is at the tip of a branch (or is the 	   head of the delta tree), then increment its revision number 	   to obtain the new revnum.  Otherwise, start a new 	   branch. */
name|commitpt
operator|=
name|RCS_findlock_or_tip
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitpt
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
elseif|else
if|if
condition|(
name|commitpt
operator|->
name|next
operator|==
name|NULL
operator|||
name|STREQ
argument_list|(
name|commitpt
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
condition|)
name|delta
operator|->
name|version
operator|=
name|increment_revnum
argument_list|(
name|commitpt
operator|->
name|version
argument_list|)
expr_stmt|;
else|else
name|delta
operator|->
name|version
operator|=
name|RCS_addbranch
argument_list|(
name|rcs
argument_list|,
name|commitpt
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* REV is either a revision number or a branch number.  Find the 	   tip of the target branch. */
name|char
modifier|*
name|branch
decl_stmt|,
modifier|*
name|tip
decl_stmt|,
modifier|*
name|newrev
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|dots
decl_stmt|,
name|isrevnum
decl_stmt|;
name|assert
argument_list|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|newrev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|dots
operator|=
name|numdots
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|isrevnum
operator|=
name|dots
operator|&
literal|1
expr_stmt|;
name|branch
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrevnum
condition|)
block|{
name|p
operator|=
name|strrchr
argument_list|(
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Find the tip of the target branch.  If we got a one- or two-digit 	   revision number, this will be the head of the tree.  Exception: 	   if rev is a single-field revision equal to the branch number of 	   the trunk (usually "1") then we want to treat it like an ordinary 	   branch revision. */
if|if
condition|(
name|dots
operator|==
literal|0
condition|)
block|{
name|tip
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|tip
argument_list|)
operator|!=
name|atoi
argument_list|(
name|branch
argument_list|)
condition|)
block|{
name|newrev
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|newrev
argument_list|,
name|strlen
argument_list|(
name|newrev
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newrev
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|dots
operator|=
name|isrevnum
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dots
operator|==
literal|1
condition|)
name|tip
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
else|else
name|tip
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the branch does not exist, and we were supplied an exact 	   revision number, signal an error.  Otherwise, if we were 	   given only a branch number, create it and set COMMITPT to 	   the branch point. */
if|if
condition|(
name|tip
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isrevnum
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't find branch point %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
name|delta
operator|->
name|version
operator|=
name|RCS_addbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
operator|->
name|version
condition|)
block|{
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
name|adding_branch
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tip
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isrevnum
condition|)
block|{
comment|/* NEWREV must be higher than TIP. */
if|if
condition|(
name|compare_revnums
argument_list|(
name|tip
argument_list|,
name|newrev
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: revision %s too low; must be higher than %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|newrev
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
name|delta
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Just increment the tip number to get the new revision. */
name|delta
operator|->
name|version
operator|=
name|increment_revnum
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|commitpt
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|delta
operator|->
name|version
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If COMMITPT is locked by us, break the lock.  If it's locked        by someone else, signal an error. */
name|nodep
operator|=
name|findnode
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|commitpt
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|nodep
operator|->
name|data
argument_list|,
name|delta
operator|->
name|author
argument_list|)
condition|)
block|{
comment|/* If we are adding a branch, then leave the old lock around. 	       That is sensible in the sense that when adding a branch, 	       we don't need to use the lock to tell us where to check 	       in.  It is fishy in the sense that if it is our own lock, 	       we break it.  However, this is the RCS 5.7 behavior (at 	       the end of addbranch in ci.c in RCS 5.7, it calls 	       removelock only if it is our own lock, not someone 	       else's).  */
if|if
condition|(
operator|!
name|adding_branch
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: revision %s locked by %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|nodep
operator|->
name|key
argument_list|,
name|nodep
operator|->
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|checkin_done
goto|;
block|}
block|}
else|else
name|delnode
argument_list|(
name|nodep
argument_list|)
expr_stmt|;
block|}
name|dtext
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|delta
operator|->
name|version
argument_list|)
expr_stmt|;
comment|/* Obtain the change text for the new delta.  If DELTA is to be the        new head of the tree, then its change text should be the contents        of the working file, and LEAFNODE's change text should be a diff.        Else, DELTA's change text should be a diff between LEAFNODE and        the working file. */
name|tmpfile
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|commitpt
operator|->
name|version
argument_list|,
name|NULL
argument_list|,
operator|(
operator|(
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
operator|)
condition|?
literal|"-kb"
else|:
literal|"-ko"
operator|)
argument_list|,
name|tmpfile
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not check out revision %s of `%s'"
argument_list|,
name|commitpt
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|bufsize
operator|=
name|buflen
operator|=
literal|0
expr_stmt|;
name|chtext
operator|=
name|NULL
expr_stmt|;
name|chtextlen
operator|=
literal|0
expr_stmt|;
name|changefile
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
comment|/* Diff options should include --binary if the RCS file has -kb set        in its `expand' field. */
name|diffopts
operator|=
operator|(
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|?
literal|"-a -n --binary"
else|:
literal|"-a -n"
operator|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|commitpt
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
operator|&&
name|numdots
argument_list|(
name|delta
operator|->
name|version
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* If this revision is being inserted on the trunk, the change text 	   for the new delta should be the contents of the working file ... */
name|bufsize
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|preserve_perms
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* Pretend file is empty.  */
empty_stmt|;
else|else
endif|#
directive|endif
name|get_file
argument_list|(
name|workfile
argument_list|,
name|workfile
argument_list|,
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|,
operator|&
name|dtext
operator|->
name|text
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|dtext
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* ... and the change text for the old delta should be a diff. */
name|commitpt
operator|->
name|text
operator|=
operator|(
name|Deltatext
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|commitpt
operator|->
name|text
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|diff_exec
argument_list|(
name|workfile
argument_list|,
name|tmpfile
argument_list|,
name|diffopts
argument_list|,
name|changefile
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
case|case
operator|-
literal|1
case|:
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error diffing %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error diffing %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* OK, the text file case here is really dumb.  Logically 	   speaking we want diff to read the files in text mode, 	   convert them to the canonical form found in RCS files 	   (which, we hope at least, is independent of OS--always 	   bare linefeeds), and then work with change texts in that 	   format.  However, diff_exec both generates change 	   texts and produces output for user purposes (e.g. patch.c), 	   and there is no way to distinguish between the two cases. 	   So we actually implement the text file case by writing the 	   change text as a text file, then reading it as a text file. 	   This should cause no harm, but doesn't strike me as 	   immensely clean.  */
name|get_file
argument_list|(
name|changefile
argument_list|,
name|changefile
argument_list|,
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|,
operator|&
name|commitpt
operator|->
name|text
operator|->
name|text
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|commitpt
operator|->
name|text
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* If COMMITPT->TEXT->TEXT is NULL, it means that CHANGEFILE 	   was empty and that there are no differences between revisions. 	   In that event, we want to force RCS_rewrite to write an empty 	   string for COMMITPT's change text.  Leaving the change text 	   field set NULL won't work, since that means "preserve the original 	   change text for this delta." */
if|if
condition|(
name|commitpt
operator|->
name|text
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|commitpt
operator|->
name|text
operator|->
name|text
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|commitpt
operator|->
name|text
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This file is not being inserted at the head, but on a side 	   branch somewhere.  Make a diff from the previous revision 	   to the working file. */
switch|switch
condition|(
name|diff_exec
argument_list|(
name|tmpfile
argument_list|,
name|workfile
argument_list|,
name|diffopts
argument_list|,
name|changefile
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
case|case
operator|-
literal|1
case|:
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error diffing %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error diffing %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* See the comment above, at the other get_file invocation, 	   regarding binary vs. text.  */
name|get_file
argument_list|(
name|changefile
argument_list|,
name|changefile
argument_list|,
name|rcs
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|?
literal|"rb"
else|:
literal|"r"
argument_list|,
operator|&
name|dtext
operator|->
name|text
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|dtext
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtext
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|dtext
operator|->
name|text
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dtext
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Update DELTA linkage.  It is important not to do this before        the very end of RCS_checkin; if an error arises that forces        us to abort checking in, we must not have malformed deltas        partially linked into the tree.         If DELTA and COMMITPT are on different branches, do nothing --        DELTA is linked to the tree through COMMITPT->BRANCHES, and we        don't want to change `next' pointers.         Otherwise, if the nodes are both on the trunk, link DELTA to        COMMITPT; otherwise, link COMMITPT to DELTA. */
if|if
condition|(
name|numdots
argument_list|(
name|commitpt
operator|->
name|version
argument_list|)
operator|==
name|numdots
argument_list|(
name|delta
operator|->
name|version
argument_list|)
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|commitpt
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
condition|)
block|{
name|delta
operator|->
name|next
operator|=
name|rcs
operator|->
name|head
expr_stmt|;
name|rcs
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|delta
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
else|else
name|commitpt
operator|->
name|next
operator|=
name|xstrdup
argument_list|(
name|delta
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
comment|/* Add DELTA to RCS->VERSIONS. */
if|if
condition|(
name|rcs
operator|->
name|versions
operator|==
name|NULL
condition|)
name|rcs
operator|->
name|versions
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|nodep
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|nodep
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|nodep
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|nodep
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|delta
expr_stmt|;
name|nodep
operator|->
name|key
operator|=
name|delta
operator|->
name|version
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
comment|/* Write the new RCS file, inserting the new delta at COMMITPT. */
if|if
condition|(
operator|!
name|checkin_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"new revision: "
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|delta
operator|->
name|version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"; previous revision: "
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|commitpt
operator|->
name|version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|dtext
argument_list|,
name|commitpt
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|RCS_FLAGS_KEEPFILE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|workfile
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME-update-dir: message does not include update_dir.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|changefile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|changefile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|changefile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkin_quiet
condition|)
name|cvs_output
argument_list|(
literal|"done\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|checkin_done
label|:
if|if
condition|(
name|allocated_workfile
condition|)
name|free
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|commitpt
operator|!=
name|NULL
operator|&&
name|commitpt
operator|->
name|text
operator|!=
name|NULL
condition|)
block|{
name|freedeltatext
argument_list|(
name|commitpt
operator|->
name|text
argument_list|)
expr_stmt|;
name|commitpt
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
block|}
name|freedeltatext
argument_list|(
name|dtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|free_rcsvers_contents
argument_list|(
name|delta
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* This structure is passed between RCS_cmp_file and cmp_file_buffer.  */
end_comment

begin_struct
struct|struct
name|cmp_file_data
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|different
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare the contents of revision REV of RCS file RCS with the    contents of the file FILENAME.  OPTIONS is a string for the keyword    expansion options.  Return 0 if the contents of the revision are    the same as the contents of the file, 1 if they are different.  */
end_comment

begin_function
name|int
name|RCS_cmp_file
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|options
parameter_list|,
name|filename
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|binary
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|cmp_file_data
name|data
decl_stmt|;
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|binary
operator|=
name|STREQ
argument_list|(
name|options
argument_list|,
literal|"-kb"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|expand
decl_stmt|;
name|expand
operator|=
name|RCS_getexpand
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|)
name|binary
operator|=
literal|1
expr_stmt|;
else|else
name|binary
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* If CVS is to deal properly with special files (when        PreservePermissions is on), the best way is to check out the        revision to a temporary file and call `xcmp' on the two disk        files.  xcmp needs to handle non-regular files properly anyway,        so calling it simplifies RCS_cmp_file.  We *could* just yank        the delta node out of the version tree and look for device        numbers, but writing to disk and calling xcmp is a better        abstraction (therefore probably more robust). -twp */
if|if
condition|(
name|preserve_perms
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|retcode
operator|=
name|xcmp
argument_list|(
name|tmp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
name|binary
condition|?
name|FOPEN_BINARY_READ
else|:
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
comment|/* FIXME-update-dir: should include update_dir in message.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|data
operator|.
name|different
operator|=
literal|0
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|rev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|cmp_file_buffer
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* If we have not yet found a difference, make sure that we are at            the end of the file.  */
if|if
condition|(
operator|!
name|data
operator|.
name|different
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
name|data
operator|.
name|different
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|data
operator|.
name|different
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is a subroutine of RCS_cmp_file.  It is passed to    RCS_checkout.  */
end_comment

begin_define
define|#
directive|define
name|CMP_BUF_SIZE
value|(8 * 1024)
end_define

begin_function
specifier|static
name|void
name|cmp_file_buffer
parameter_list|(
name|callerdat
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|cmp_file_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|cmp_file_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|;
comment|/* If we've already found a difference, we don't need to check        further.  */
if|if
condition|(
name|data
operator|->
name|different
condition|)
return|return;
name|filebuf
operator|=
name|xmalloc
argument_list|(
name|len
operator|>
name|CMP_BUF_SIZE
condition|?
name|CMP_BUF_SIZE
else|:
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|checklen
decl_stmt|;
name|checklen
operator|=
name|len
operator|>
name|CMP_BUF_SIZE
condition|?
name|CMP_BUF_SIZE
else|:
name|len
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|filebuf
argument_list|,
literal|1
argument_list|,
name|checklen
argument_list|,
name|data
operator|->
name|fp
argument_list|)
operator|!=
name|checklen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|data
operator|->
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|data
operator|->
name|filename
argument_list|)
expr_stmt|;
name|data
operator|->
name|different
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|filebuf
argument_list|,
name|buffer
argument_list|,
name|checklen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|data
operator|->
name|different
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer
operator|+=
name|checklen
expr_stmt|;
name|len
operator|-=
name|checklen
expr_stmt|;
block|}
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For RCS file RCS, make symbolic tag TAG point to revision REV.    This validates that TAG is OK for a user to use.  Return value is    -1 for error (and errno is set to indicate the error), positive for    error (and an error message has been printed), or zero for success.  */
end_comment

begin_function
name|int
name|RCS_settag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|List
modifier|*
name|symbols
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: This check should be moved to RCS_check_tag.  There is no        reason for it to be here.  */
if|if
condition|(
name|STREQ
argument_list|(
name|tag
argument_list|,
name|TAG_BASE
argument_list|)
operator|||
name|STREQ
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
condition|)
block|{
comment|/* Print the name of the tag might be considered redundant 	   with the caller, which also prints it.  Perhaps this helps 	   clarify why the tag name is considered reserved, I don't 	   know.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Attempt to add reserved tag name %s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* A revision number of NULL means use the head or default branch.        If rev is not NULL, it may be a symbolic tag or branch number;        expand it to the correct numeric revision or branch head. */
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
name|rev
operator|=
name|rcs
operator|->
name|branch
condition|?
name|rcs
operator|->
name|branch
else|:
name|rcs
operator|->
name|head
expr_stmt|;
comment|/* At this point rcs->symbol_data may not have been parsed.        Calling RCS_symbols will force it to be parsed into a list        which we can easily manipulate.  */
name|symbols
operator|=
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
block|{
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|rcs
operator|->
name|symbols
operator|=
name|symbols
expr_stmt|;
block|}
name|node
operator|=
name|findnode
argument_list|(
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode_at_front
argument_list|(
name|symbols
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete the symbolic tag TAG from the RCS file RCS.  Return 0 if    the tag was found (and removed), or 1 if it was not present.  (In    either case, the tag will no longer be in RCS->SYMBOLS.) */
end_comment

begin_function
name|int
name|RCS_deltag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|List
modifier|*
name|symbols
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|node
operator|=
name|findnode
argument_list|(
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the default branch of RCS to REV.  */
end_comment

begin_function
name|int
name|RCS_setbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|&&
operator|!
operator|*
name|rev
condition|)
name|rev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
operator|&&
name|rcs
operator|->
name|branch
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
name|rcs
operator|->
name|branch
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|rev
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|branch
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lock revision REV.  LOCK_QUIET is 1 to suppress output.  FIXME:    Most of the callers only call us because RCS_checkin still tends to    like a lock (a relic of old behavior inherited from the RCS ci    program).  If we clean this up, only "cvs admin -l" will still need    to call RCS_lock.  */
end_comment

begin_comment
comment|/* FIXME-twp: if a lock owned by someone else is broken, should this    send mail to the lock owner?  Prompt user?  It seems like such an    obscure situation for CVS as almost not worth worrying much    about. */
end_comment

begin_function
name|int
name|RCS_lock
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|lock_quiet
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|lock_quiet
decl_stmt|;
block|{
name|List
modifier|*
name|locks
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|xrev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|locks
operator|=
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|locks
operator|==
name|NULL
condition|)
name|locks
operator|=
name|rcs
operator|->
name|locks
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|user
operator|=
name|getcaller
argument_list|()
expr_stmt|;
comment|/* A revision number of NULL means lock the head or default branch. */
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
name|xrev
operator|=
name|RCS_head
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
comment|/* If rev is a branch number, lock the latest revision on that        branch. I think that if the branch doesn't exist, it's        okay to return 0 -- that just means that the branch is new,        so we don't need to lock it anyway. -twp */
elseif|else
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|xrev
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lock_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: branch %s absent"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|xrev
operator|==
name|NULL
condition|)
name|xrev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
comment|/* Make sure that the desired revision exists.  Technically,        we can update the locks list without even checking this,        but RCS 5.7 did this.  And it can't hurt. */
if|if
condition|(
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|xrev
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lock_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: revision %s absent"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Is this rev already locked? */
name|p
operator|=
name|findnode
argument_list|(
name|locks
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|data
argument_list|,
name|user
argument_list|)
condition|)
block|{
comment|/* We already own the lock on this revision, so do nothing. */
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* Well, first of all, "rev" below should be "xrev" to avoid 	   core dumps.  But more importantly, should we really be 	   breaking the lock unconditionally?  What CVS 1.9 does (via 	   RCS) is to prompt "Revision 1.1 is already locked by fred. 	   Do you want to break the lock? [ny](n): ".  Well, we don't 	   want to interact with the user (certainly not at the 	   server/protocol level, and probably not in the command-line 	   client), but isn't it more sensible to give an error and 	   let the user run "cvs admin -u" if they want to break the 	   lock?  */
comment|/* Break the lock. */
block|if (!lock_quiet) 	{ 	    cvs_output (rev, 0); 	    cvs_output (" unlocked\n", 0); 	} 	delnode (p);
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Revision %s is already locked by %s"
argument_list|,
name|xrev
argument_list|,
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Create a new lock. */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xrev
expr_stmt|;
comment|/* already xstrdupped */
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode_at_front
argument_list|(
name|locks
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock_quiet
condition|)
block|{
name|cvs_output
argument_list|(
name|xrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" locked\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unlock revision REV.  UNLOCK_QUIET is 1 to suppress output.  FIXME:    Like RCS_lock, this can become a no-op if we do the checkin    ourselves.     If REV is not null and is locked by someone else, break their    lock and notify them.  It is an open issue whether RCS_unlock    queries the user about whether or not to break the lock. */
end_comment

begin_function
name|int
name|RCS_unlock
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|unlock_quiet
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|unlock_quiet
decl_stmt|;
block|{
name|Node
modifier|*
name|lock
decl_stmt|;
name|List
modifier|*
name|locks
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|xrev
init|=
name|NULL
decl_stmt|;
name|user
operator|=
name|getcaller
argument_list|()
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If rev is NULL, unlock the latest revision (first in        rcs->locks) held by the caller. */
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* No-ops: attempts to unlock an empty tree or an unlocked file. */
if|if
condition|(
name|rcs
operator|->
name|head
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|unlock_quiet
condition|)
name|cvs_outerr
argument_list|(
literal|"can't unlock an empty tree\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|locks
operator|=
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|locks
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|unlock_quiet
condition|)
name|cvs_outerr
argument_list|(
literal|"No locks are set.\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|locks
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|locks
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|unlock_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ %s: multiple revisions locked by %s; please specify one"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lock
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* no lock found, ergo nothing to do */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|lock
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
comment|/* If rev is a branch number, unlock the latest revision on that 	   branch. */
name|xrev
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: branch %s absent"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
comment|/* REV is an exact revision number. */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|lock
operator|=
name|findnode
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
block|{
comment|/* This revision isn't locked. */
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|lock
operator|->
name|data
argument_list|,
name|user
argument_list|)
condition|)
block|{
comment|/* If the revision is locked by someone else, notify 	   them.  Note that this shouldn't ever happen if RCS_unlock 	   is called with a NULL revision, since that means "whatever 	   revision is currently locked by the caller." */
name|char
modifier|*
name|repos
decl_stmt|,
modifier|*
name|workfile
decl_stmt|;
name|repos
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|workfile
operator|=
name|strrchr
argument_list|(
name|repos
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|workfile
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|notify_do
argument_list|(
literal|'C'
argument_list|,
name|workfile
argument_list|,
name|user
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
name|delnode
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unlock_quiet
condition|)
block|{
name|cvs_output
argument_list|(
name|xrev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" unlocked\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add USER to the access list of RCS.  Do nothing if already present.    FIXME-twp: check syntax of USER to make sure it's a valid id. */
end_comment

begin_function
name|void
name|RCS_addaccess
parameter_list|(
name|rcs
parameter_list|,
name|user
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
modifier|*
name|access
decl_stmt|,
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|access
operator|==
name|NULL
condition|)
name|rcs
operator|->
name|access
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
else|else
block|{
name|access
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|access
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|strtok
argument_list|(
name|access
argument_list|,
literal|" "
argument_list|)
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" "
argument_list|)
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|a
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|access
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|access
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|rcs
operator|->
name|access
argument_list|,
name|strlen
argument_list|(
name|rcs
operator|->
name|access
argument_list|)
operator|+
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcs
operator|->
name|access
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rcs
operator|->
name|access
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove USER from the access list of RCS. */
end_comment

begin_function
name|void
name|RCS_delaccess
parameter_list|(
name|rcs
parameter_list|,
name|user
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|ulen
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|access
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rcs
operator|->
name|access
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|access
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|rcs
operator|->
name|access
expr_stmt|;
name|ulen
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|user
argument_list|,
name|ulen
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
name|ulen
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|ulen
index|]
operator|==
literal|' '
operator|)
condition|)
break|break;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|s
operator|=
name|p
operator|+
name|ulen
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|RCS_getaccess
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rcs
operator|->
name|access
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|findtag
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a nonzero value if the revision specified by ARG is found.  */
end_comment

begin_function
specifier|static
name|int
name|findtag
parameter_list|(
name|node
parameter_list|,
name|arg
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|rev
init|=
operator|(
name|char
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|rev
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete revisions between REV1 and REV2.  The changes between the two    revisions must be collapsed, and the result stored in the revision    immediately preceding the lower one.  Return 0 for successful completion,    1 otherwise.     Solution: check out the revision preceding REV1 and the revision    following REV2.  Use call_diff to find aggregate diffs between    these two revisions, and replace the delta text for the latter one    with the new aggregate diff.  Alternatively, we could write a    function that takes two change texts and combines them to produce a    new change text, without checking out any revs or calling diff.  It    would be hairy, but so, so cool.     If INCLUSIVE is set, then TAG1 and TAG2, if non-NULL, tell us to    delete that revision as well (cvs admin -o tag1:tag2).  If clear,    delete up to but not including that revision (cvs admin -o tag1::tag2).    This does not affect TAG1 or TAG2 being NULL; the meaning of the start    point in ::tag2 and :tag2 is the same and likewise for end points.  */
end_comment

begin_function
name|int
name|RCS_delete_revs
parameter_list|(
name|rcs
parameter_list|,
name|tag1
parameter_list|,
name|tag2
parameter_list|,
name|inclusive
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag1
decl_stmt|;
name|char
modifier|*
name|tag2
decl_stmt|;
name|int
name|inclusive
decl_stmt|;
block|{
name|char
modifier|*
name|next
decl_stmt|;
name|Node
modifier|*
name|nodep
decl_stmt|;
name|RCSVers
modifier|*
name|revp
init|=
name|NULL
decl_stmt|;
name|RCSVers
modifier|*
name|beforep
decl_stmt|;
name|int
name|status
decl_stmt|,
name|found
decl_stmt|;
name|int
name|save_noexec
decl_stmt|;
name|char
modifier|*
name|branchpoint
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rev1
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rev2
init|=
name|NULL
decl_stmt|;
name|int
name|rev1_inclusive
init|=
name|inclusive
decl_stmt|;
name|int
name|rev2_inclusive
init|=
name|inclusive
decl_stmt|;
name|char
modifier|*
name|before
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|after
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|beforefile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|afterfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tag1
operator|==
name|NULL
operator|&&
name|tag2
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Assume error status until everything is finished. */
name|status
operator|=
literal|1
expr_stmt|;
comment|/* Make sure both revisions exist. */
if|if
condition|(
name|tag1
operator|!=
name|NULL
condition|)
block|{
name|rev1
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
operator|(
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: Revision %s doesn't exist."
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|tag1
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
block|}
if|if
condition|(
name|tag2
operator|!=
name|NULL
condition|)
block|{
name|rev2
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag2
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
operator|==
name|NULL
operator|||
operator|(
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: Revision %s doesn't exist."
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|tag2
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
block|}
comment|/* If rev1 is on the trunk and rev2 is NULL, rev2 should be        RCS->HEAD.  (*Not* RCS_head(rcs), which may return rcs->branch        instead.)  We need to check this special case early, in order        to make sure that rev1 and rev2 get ordered correctly. */
if|if
condition|(
name|rev2
operator|==
name|NULL
operator|&&
name|numdots
argument_list|(
name|rev1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rev2
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
name|rev2_inclusive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
name|rev2_inclusive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev1
operator|!=
name|NULL
operator|&&
name|rev2
operator|!=
name|NULL
condition|)
block|{
comment|/* A range consisting of a branch number means the latest revision 	   on that branch. */
if|if
condition|(
name|RCS_isbranch
argument_list|(
name|rcs
argument_list|,
name|rev1
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
condition|)
name|rev1
operator|=
name|rev2
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rev1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Make sure REV1 and REV2 are ordered correctly (in the 	       same order as the next field).  For revisions on the 	       trunk, REV1 should be higher than REV2; for branches, 	       REV1 should be lower.  */
comment|/* Shouldn't we just be giving an error in the case where 	       the user specifies the revisions in the wrong order 	       (that is, always swap on the trunk, never swap on a 	       branch, in the non-error cases)?  It is not at all 	       clear to me that users who specify -o 1.4:1.2 really 	       meant to type -o 1.2:1.4, and the out of order usage 	       has never been documented, either by cvs.texinfo or 	       rcs(1).  */
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|temp_inclusive
decl_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|rev1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|compare_revnums
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|temp
operator|=
name|rev2
expr_stmt|;
name|rev2
operator|=
name|rev1
expr_stmt|;
name|rev1
operator|=
name|temp
expr_stmt|;
name|temp_inclusive
operator|=
name|rev2_inclusive
expr_stmt|;
name|rev2_inclusive
operator|=
name|rev1_inclusive
expr_stmt|;
name|rev1_inclusive
operator|=
name|temp_inclusive
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|compare_revnums
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|rev2
expr_stmt|;
name|rev2
operator|=
name|rev1
expr_stmt|;
name|rev1
operator|=
name|temp
expr_stmt|;
name|temp_inclusive
operator|=
name|rev2_inclusive
expr_stmt|;
name|rev2_inclusive
operator|=
name|rev1_inclusive
expr_stmt|;
name|rev1_inclusive
operator|=
name|temp_inclusive
expr_stmt|;
block|}
block|}
block|}
comment|/* Basically the same thing; make sure that the ordering is what we        need.  */
if|if
condition|(
name|rev1
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|rev2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|rev2
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Swap rev1 and rev2.  */
name|int
name|temp_inclusive
decl_stmt|;
name|rev1
operator|=
name|rev2
expr_stmt|;
name|rev2
operator|=
name|NULL
expr_stmt|;
name|temp_inclusive
operator|=
name|rev2_inclusive
expr_stmt|;
name|rev2_inclusive
operator|=
name|rev1_inclusive
expr_stmt|;
name|rev1_inclusive
operator|=
name|temp_inclusive
expr_stmt|;
block|}
block|}
comment|/* Put the revision number preceding the first one to delete into        BEFORE (where "preceding" means according to the next field).        If the first revision to delete is the first revision on its        branch (e.g. 1.3.2.1), BEFORE should be the node on the trunk        at which the branch is rooted.  If the first revision to delete        is the head revision of the trunk, set BEFORE to NULL.         Note that because BEFORE may not be on the same branch as REV1,        it is not very handy for navigating the revision tree.  It's        most useful just for checking out the revision preceding REV1. */
name|before
operator|=
name|NULL
expr_stmt|;
name|branchpoint
operator|=
name|RCS_getbranchpoint
argument_list|(
name|rcs
argument_list|,
name|rev1
operator|!=
name|NULL
condition|?
name|rev1
else|:
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|==
name|NULL
condition|)
block|{
name|rev1
operator|=
name|xstrdup
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|branchpoint
argument_list|)
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|strrchr
argument_list|(
name|branchpoint
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|bp
operator|!=
literal|'.'
condition|)
empty_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Note that this is exclusive, always, because the inclusive 	       flag doesn't affect the meaning when rev1 == NULL.  */
name|before
operator|=
name|xstrdup
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|rev1
argument_list|,
name|branchpoint
argument_list|)
condition|)
block|{
comment|/* Walk deltas from BRANCHPOINT on, looking for REV1. */
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|branchpoint
argument_list|)
expr_stmt|;
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|revp
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|STREQ
argument_list|(
name|revp
operator|->
name|next
argument_list|,
name|rev1
argument_list|)
condition|)
block|{
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|revp
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: Revision %s doesn't exist."
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|rev1
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
if|if
condition|(
name|rev1_inclusive
condition|)
name|before
operator|=
name|xstrdup
argument_list|(
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
else|else
block|{
name|before
operator|=
name|rev1
expr_stmt|;
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|rev1
operator|=
name|xstrdup
argument_list|(
operator|(
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
operator|)
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|rev1_inclusive
condition|)
block|{
name|before
operator|=
name|rev1
expr_stmt|;
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|rev1
operator|=
name|xstrdup
argument_list|(
operator|(
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
operator|)
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numdots
argument_list|(
name|branchpoint
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* Example: rev1 is "1.3.2.1", branchpoint is "1.3.2.1". 	   Set before to "1.3".  */
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|strrchr
argument_list|(
name|branchpoint
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|bp
operator|!=
literal|'.'
condition|)
empty_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|before
operator|=
name|xstrdup
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* If any revision between REV1 and REV2 is locked or is a branch point,        we can't delete that revision and must abort. */
name|after
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|rev1
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|found
operator|&&
name|next
operator|!=
name|NULL
condition|)
block|{
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|rev2
operator|!=
name|NULL
condition|)
name|found
operator|=
name|STREQ
argument_list|(
name|revp
operator|->
name|version
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|next
operator|=
name|revp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|found
operator|&&
name|next
operator|!=
name|NULL
operator|)
operator|||
name|rev2_inclusive
operator|||
name|rev2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|findnode
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|revp
operator|->
name|version
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't remove locked revision %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
if|if
condition|(
name|revp
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't remove branch point %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
comment|/* Doing this only for the :: syntax is for compatibility. 	       See cvs.texinfo for somewhat more discussion.  */
if|if
condition|(
operator|!
name|inclusive
operator|&&
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|findtag
argument_list|,
name|revp
operator|->
name|version
argument_list|)
condition|)
block|{
comment|/* We don't print which file this happens to on the theory 		   that the caller will print the name of the file in a 		   more useful fashion (fullname not rcs->path).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove revision %s because it has tags"
argument_list|,
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
comment|/* It's misleading to print the `deleting revision' output 	       here, since we may not actually delete these revisions. 	       But that's how RCS does it.  Bleah.  Someday this should be 	       moved to the point where the revs are actually marked for 	       deletion. -twp */
name|cvs_output
argument_list|(
literal|"deleting revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|revp
operator|->
name|version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|rev2_inclusive
condition|)
name|after
operator|=
name|xstrdup
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
name|after
operator|=
name|xstrdup
argument_list|(
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|inclusive
condition|)
block|{
comment|/* In the case of an empty range, for example 1.2::1.2 or 	   1.2::1.3, we want to just do nothing.  */
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
else|else
block|{
comment|/* This looks fishy in the cases where tag1 == NULL or tag2 == NULL. 	   Are those cases really impossible?  */
name|assert
argument_list|(
name|tag1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tag2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: invalid revision range %s:%s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|tag1
argument_list|,
name|tag2
argument_list|)
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
if|if
condition|(
name|after
operator|==
name|NULL
operator|&&
name|before
operator|==
name|NULL
condition|)
block|{
comment|/* The user is trying to delete all revisions.  While an 	   RCS file without revisions makes sense to RCS (e.g. the 	   state after "rcs -i"), CVS has never been able to cope with 	   it.  So at least for now we just make this an error.  	   We don't include rcs->path in the message since "cvs admin" 	   already printed "RCS file:" and the name.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"attempt to delete all revisions"
argument_list|)
expr_stmt|;
block|}
comment|/* The conditionals at this point get really hairy.  Here is the        general idea:         IF before != NULL and after == NULL          THEN don't check out any revisions, just delete them        IF before == NULL and after != NULL          THEN only check out after's revision, and use it for the new deltatext        ELSE          check out both revisions and diff -n them.  This could use 	 RCS_exec_rcsdiff with some changes, like being able 	 to suppress diagnostic messages and to direct output. */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|,
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* FIXME: This is an awful kludge, but at least until I have 	   time to work on it a little more and test it, I'd rather 	   give a fatal error than corrupt the file.  I think that we 	   need to use "-kb" and "--binary" and "rb" to get_file 	   (probably can do it always, not just for binary files, if 	   we are consistent between the RCS_checkout and the diff).  */
block|{
name|char
modifier|*
name|expand
init|=
name|RCS_getexpand
argument_list|(
name|rcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|expand
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|expand
argument_list|,
literal|"b"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"admin -o not implemented yet for binary on this system"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|afterfile
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|after
argument_list|,
name|NULL
argument_list|,
literal|"-ko"
argument_list|,
name|afterfile
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
goto|goto
name|delrev_done
goto|;
if|if
condition|(
name|before
operator|==
name|NULL
condition|)
block|{
comment|/* We are deleting revisions from the head of the tree, 	       so must create a new head. */
name|diffbuf
operator|=
name|NULL
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
name|get_file
argument_list|(
name|afterfile
argument_list|,
name|afterfile
argument_list|,
literal|"r"
argument_list|,
operator|&
name|diffbuf
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|afterfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|afterfile
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|free
argument_list|(
name|afterfile
argument_list|)
expr_stmt|;
name|afterfile
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beforefile
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|before
argument_list|,
name|NULL
argument_list|,
literal|"-ko"
argument_list|,
name|beforefile
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
goto|goto
name|delrev_done
goto|;
name|outfile
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|status
operator|=
name|diff_exec
argument_list|(
name|beforefile
argument_list|,
name|afterfile
argument_list|,
literal|"-an"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|2
condition|)
block|{
comment|/* Not sure we need this message; will diff_exec already 		   have printed an error?  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: could not diff"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|delrev_done
goto|;
block|}
name|diffbuf
operator|=
name|NULL
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
name|get_file
argument_list|(
name|outfile
argument_list|,
name|outfile
argument_list|,
literal|"r"
argument_list|,
operator|&
name|diffbuf
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Save the new change text in after's delta node. */
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|assert
argument_list|(
name|revp
operator|->
name|text
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|revp
operator|->
name|text
operator|=
operator|(
name|Deltatext
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|Deltatext
operator|*
operator|)
name|revp
operator|->
name|text
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|revp
operator|->
name|text
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|revp
operator|->
name|version
argument_list|)
expr_stmt|;
name|revp
operator|->
name|text
operator|->
name|text
operator|=
name|diffbuf
expr_stmt|;
name|revp
operator|->
name|text
operator|->
name|len
operator|=
name|len
expr_stmt|;
comment|/* If DIFFBUF is NULL, it means that OUTFILE is empty and that 	   there are no differences between the two revisions.  In that 	   case, we want to force RCS_copydeltas to write an empty string 	   for the new change text (leaving the text field set NULL 	   means "preserve the original change text for this delta," so 	   we don't want that). */
if|if
condition|(
name|revp
operator|->
name|text
operator|->
name|text
operator|==
name|NULL
condition|)
name|revp
operator|->
name|text
operator|->
name|text
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Walk through the revisions (again) to mark each one as        outdated.  (FIXME: would it be safe to use the `dead' field for        this?  Doubtful.) */
for|for
control|(
name|next
operator|=
name|rev1
init|;
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|after
operator|==
name|NULL
operator|||
operator|!
name|STREQ
argument_list|(
name|next
argument_list|,
name|after
argument_list|)
operator|)
condition|;
name|next
operator|=
name|revp
operator|->
name|next
control|)
block|{
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|revp
operator|->
name|outdated
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Update delta links.  If BEFORE == NULL, we're changing the        head of the tree and don't need to update any `next' links. */
if|if
condition|(
name|before
operator|!=
name|NULL
condition|)
block|{
comment|/* If REV1 is the first node on its branch, then BEFORE is its 	   root node (on the trunk) and we have to update its branches 	   list.  Otherwise, BEFORE is on the same branch as AFTER, and 	   we can just change BEFORE's `next' field to point to AFTER. 	   (This should be safe: since findnode manages its lists via 	   the `hashnext' and `hashprev' fields, rather than `next' and 	   `prev', mucking with `next' and `prev' should not corrupt the 	   delta tree's internal structure.  Much. -twp) */
if|if
condition|(
name|rev1
operator|==
name|NULL
condition|)
comment|/* beforep's ->next field already should be equal to after, 	       which I think is always NULL in this case.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|rev1
argument_list|,
name|branchpoint
argument_list|)
condition|)
block|{
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|revp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|nodep
operator|=
name|revp
operator|->
name|branches
operator|->
name|list
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|nodep
operator|!=
name|revp
operator|->
name|branches
operator|->
name|list
operator|&&
operator|!
name|STREQ
argument_list|(
name|nodep
operator|->
name|key
argument_list|,
name|rev1
argument_list|)
condition|)
name|nodep
operator|=
name|nodep
operator|->
name|next
expr_stmt|;
name|assert
argument_list|(
name|nodep
operator|!=
name|revp
operator|->
name|branches
operator|->
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|NULL
condition|)
name|delnode
argument_list|(
name|nodep
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|nodep
operator|->
name|key
argument_list|)
expr_stmt|;
name|nodep
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nodep
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|before
argument_list|)
expr_stmt|;
name|beforep
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nodep
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|beforep
operator|->
name|next
argument_list|)
expr_stmt|;
name|beforep
operator|->
name|next
operator|=
name|xstrdup
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|=
literal|0
expr_stmt|;
name|delrev_done
label|:
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchpoint
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|branchpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|beforefile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|beforefile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|beforefile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|beforefile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|afterfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|afterfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|afterfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|afterfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|outfile
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
name|noexec
operator|=
name|save_noexec
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * TRUE if there exists a symbolic tag "tag" in file.  */
end_comment

begin_function
name|int
name|RCS_exist_tag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|findnode
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|tag
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * TRUE if RCS revision number "rev" exists.  * This includes magic branch revisions, not found in rcs->versions,   * but only in rcs->symbols, requiring a list walk to find them.  * Take advantage of list walk callback function already used by   * RCS_delete_revs, above.  */
end_comment

begin_function
name|int
name|RCS_exist_rev
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|rcsbuffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|findtag
argument_list|,
name|rev
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */
end_comment

begin_struct
struct|struct
name|line
block|{
comment|/* Text of this line.  Part of the same malloc'd block as the struct        line itself (we probably should use the "struct hack" (char text[1])        and save ourselves sizeof (char *) bytes).  Does not include \n;        instead has_newline indicates the presence or absence of \n.  */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Length of this line, not counting \n if has_newline is true.  */
name|size_t
name|len
decl_stmt|;
comment|/* Version in which it was introduced.  */
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* Nonzero if this line ends with \n.  This will always be true        except possibly for the last line.  */
name|int
name|has_newline
decl_stmt|;
comment|/* Number of pointers to this struct line.  */
name|int
name|refcount
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linevector
block|{
comment|/* How many lines in use for this linevector?  */
name|unsigned
name|int
name|nlines
decl_stmt|;
comment|/* How many lines allocated for this linevector?  */
name|unsigned
name|int
name|lines_alloced
decl_stmt|;
comment|/* Pointer to array containing a pointer to each line.  */
name|struct
name|line
modifier|*
modifier|*
name|vector
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|linevector_init
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize *VEC to be a linevector with no lines.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_init
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
name|vec
operator|->
name|lines_alloced
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|linevector_add
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
name|vec
operator|,
specifier|const
name|char
operator|*
name|text
operator|,
name|size_t
name|len
operator|,
name|RCSVers
operator|*
name|vers
operator|,
name|unsigned
name|int
name|pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given some text TEXT, add each of its lines to VEC before line POS    (where line 0 is the first line).  The last line in TEXT may or may    not be \n terminated.    Set the version for each of the new lines to VERS.  This    function returns non-zero for success.  It returns zero if the line    number is out of range.     Each of the lines in TEXT are copied to space which is managed with    the linevector (and freed by linevector_free).  So the caller doesn't    need to keep TEXT around after the call to this function.  */
end_comment

begin_function
specifier|static
name|int
name|linevector_add
parameter_list|(
name|vec
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|,
name|vers
parameter_list|,
name|pos
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|textend
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nnew
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|nextline_text
decl_stmt|;
name|size_t
name|nextline_len
decl_stmt|;
name|int
name|nextline_newline
decl_stmt|;
name|struct
name|line
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|textend
operator|=
name|text
operator|+
name|len
expr_stmt|;
comment|/* Count the number of lines we will need to add.  */
name|nnew
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
name|p
operator|<
name|textend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|p
operator|+
literal|1
operator|<
name|textend
condition|)
operator|++
name|nnew
expr_stmt|;
comment|/* Expand VEC->VECTOR if needed.  */
if|if
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
block|{
if|if
condition|(
name|vec
operator|->
name|lines_alloced
operator|==
literal|0
condition|)
name|vec
operator|->
name|lines_alloced
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
name|vec
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
name|xrealloc
argument_list|(
name|vec
operator|->
name|vector
argument_list|,
name|vec
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for the new lines in VEC->VECTOR.  */
for|for
control|(
name|i
operator|=
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|-
literal|1
init|;
name|i
operator|>=
name|pos
operator|+
name|nnew
condition|;
operator|--
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|-
name|nnew
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|vec
operator|->
name|nlines
condition|)
return|return
literal|0
return|;
comment|/* Actually add the lines, to VEC->VECTOR.  */
name|i
operator|=
name|pos
expr_stmt|;
name|nextline_text
operator|=
name|text
expr_stmt|;
name|nextline_newline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
name|p
operator|<
name|textend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|nextline_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|==
name|textend
condition|)
comment|/* If there are no characters beyond the last newline, we 		   don't consider it another line.  */
break|break;
name|nextline_len
operator|=
name|p
operator|-
name|nextline_text
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|+
name|nextline_len
argument_list|)
expr_stmt|;
name|q
operator|->
name|vers
operator|=
name|vers
expr_stmt|;
name|q
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|q
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
expr_stmt|;
name|q
operator|->
name|len
operator|=
name|nextline_len
expr_stmt|;
name|q
operator|->
name|has_newline
operator|=
name|nextline_newline
expr_stmt|;
name|q
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|text
argument_list|,
name|nextline_text
argument_list|,
name|nextline_len
argument_list|)
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|nextline_text
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
expr_stmt|;
name|nextline_newline
operator|=
literal|0
expr_stmt|;
block|}
name|nextline_len
operator|=
name|p
operator|-
name|nextline_text
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
operator|+
name|nextline_len
argument_list|)
expr_stmt|;
name|q
operator|->
name|vers
operator|=
name|vers
expr_stmt|;
name|q
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|q
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
expr_stmt|;
name|q
operator|->
name|len
operator|=
name|nextline_len
expr_stmt|;
name|q
operator|->
name|has_newline
operator|=
name|nextline_newline
expr_stmt|;
name|q
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|q
operator|->
name|text
argument_list|,
name|nextline_text
argument_list|,
name|nextline_len
argument_list|)
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
name|vec
operator|->
name|nlines
operator|+=
name|nnew
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_delete
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove NLINES lines from VEC at position POS (where line 0 is the    first line).  */
end_comment

begin_function
specifier|static
name|void
name|linevector_delete
parameter_list|(
name|vec
parameter_list|,
name|pos
parameter_list|,
name|nlines
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|unsigned
name|int
name|nlines
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|last
operator|=
name|vec
operator|->
name|nlines
operator|-
name|nlines
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pos
init|;
name|i
operator|<
name|pos
operator|+
name|nlines
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|--
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|->
name|refcount
operator|==
literal|0
condition|)
name|free
argument_list|(
name|vec
operator|->
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|pos
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|+
name|nlines
index|]
expr_stmt|;
name|vec
operator|->
name|nlines
operator|-=
name|nlines
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_copy
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy FROM to TO, copying the vectors but not the lines pointed to.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_copy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|linevector
modifier|*
name|to
decl_stmt|;
name|struct
name|linevector
modifier|*
name|from
decl_stmt|;
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|to
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
if|if
condition|(
operator|--
name|to
operator|->
name|vector
index|[
name|ln
index|]
operator|->
name|refcount
operator|==
literal|0
condition|)
name|free
argument_list|(
name|to
operator|->
name|vector
index|[
name|ln
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
block|{
if|if
condition|(
name|to
operator|->
name|lines_alloced
operator|==
literal|0
condition|)
name|to
operator|->
name|lines_alloced
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
name|to
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|to
operator|->
name|vector
operator|=
operator|(
expr|struct
name|line
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|to
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|from
operator|->
name|vector
argument_list|,
name|from
operator|->
name|nlines
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|nlines
operator|=
name|from
operator|->
name|nlines
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|to
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
operator|++
name|to
operator|->
name|vector
index|[
name|ln
index|]
operator|->
name|refcount
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_free
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free storage associated with linevector.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_free
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
if|if
condition|(
name|vec
operator|->
name|vector
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|vec
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
if|if
condition|(
operator|--
name|vec
operator|->
name|vector
index|[
name|ln
index|]
operator|->
name|refcount
operator|==
literal|0
condition|)
name|free
argument_list|(
name|vec
operator|->
name|vector
index|[
name|ln
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vec
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|month_printname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a textual string giving the month (1-12), terminated with any    character not recognized by atoi, return the 3 character name to    print it with.  I do not think it is a good idea to change these    strings based on the locale; they are standard abbreviations (for    example in rfc822 mail messages) which should be widely understood.    Returns a pointer into static readonly storage.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|month_printname
parameter_list|(
name|month
parameter_list|)
name|char
modifier|*
name|month
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|int
name|mnum
decl_stmt|;
name|mnum
operator|=
name|atoi
argument_list|(
name|month
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnum
operator|<
literal|1
operator|||
name|mnum
operator|>
literal|12
condition|)
return|return
literal|"???"
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|months
index|[
name|mnum
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|apply_rcs_changes
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
specifier|const
name|char
operator|*
operator|,
name|RCSVers
operator|*
operator|,
name|RCSVers
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Apply changes to the line vector LINES.  DIFFBUF is a buffer of    length DIFFLEN holding the change text from an RCS file (the output    of diff -n).  NAME is used in error messages.  The VERS field of    any line added is set to ADDVERS.  The VERS field of any line    deleted is set to DELVERS, unless DELVERS is NULL, in which case    the VERS field of deleted lines is unchanged.  The function returns    non-zero if the change text is applied successfully.  It returns    zero if the change text does not appear to apply to LINES (e.g., a    line number is invalid).  If the change text is improperly    formatted (e.g., it is not the output of diff -n), the function    calls error with a status of 1, causing the program to exit.  */
end_comment

begin_function
specifier|static
name|int
name|apply_rcs_changes
parameter_list|(
name|lines
parameter_list|,
name|diffbuf
parameter_list|,
name|difflen
parameter_list|,
name|name
parameter_list|,
name|addvers
parameter_list|,
name|delvers
parameter_list|)
name|struct
name|linevector
modifier|*
name|lines
decl_stmt|;
specifier|const
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|size_t
name|difflen
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|RCSVers
modifier|*
name|addvers
decl_stmt|;
name|RCSVers
modifier|*
name|delvers
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|op
decl_stmt|;
comment|/* The RCS format throws us for a loop in that the deltafrags (if        we define a deltafrag as an add or a delete) need to be applied        in reverse order.  So we stick them into a linked list.  */
struct|struct
name|deltafrag
block|{
enum|enum
block|{
name|FRAG_ADD
block|,
name|FRAG_DELETE
block|}
name|type
enum|;
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|nlines
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_lines
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|deltafrag
modifier|*
name|dfhead
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|df
decl_stmt|;
name|dfhead
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|diffbuf
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|<
name|diffbuf
operator|+
name|difflen
condition|;
control|)
block|{
name|op
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|'a'
operator|&&
name|op
operator|!=
literal|'d'
condition|)
comment|/* Can't just skip over the deltafrag, because the value 	       of op determines the syntax.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized operation '\\x%x' in %s"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|df
operator|=
operator|(
expr|struct
name|deltafrag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deltafrag
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|next
operator|=
name|dfhead
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
name|df
operator|->
name|pos
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"space expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|df
operator|->
name|nlines
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\012'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'a'
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|df
operator|->
name|type
operator|=
name|FRAG_ADD
expr_stmt|;
name|i
operator|=
name|df
operator|->
name|nlines
expr_stmt|;
comment|/* The text we want is the number of lines specified, or 	       until the end of the value, whichever comes first (it 	       will be the former except in the case where we are 	       adding a line which does not end in newline).  */
for|for
control|(
name|q
operator|=
name|p
init|;
name|i
operator|!=
literal|0
condition|;
operator|++
name|q
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'\n'
condition|)
operator|--
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|==
name|diffbuf
operator|+
name|difflen
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"premature end of change in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Stash away a pointer to the text we are adding.  */
name|df
operator|->
name|new_lines
operator|=
name|p
expr_stmt|;
name|df
operator|->
name|len
operator|=
name|q
operator|-
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
comment|/* Correct for the fact that line numbers in RCS files 	       start with 1.  */
operator|--
name|df
operator|->
name|pos
expr_stmt|;
name|assert
argument_list|(
name|op
operator|==
literal|'d'
argument_list|)
expr_stmt|;
name|df
operator|->
name|type
operator|=
name|FRAG_DELETE
expr_stmt|;
block|}
block|}
for|for
control|(
name|df
operator|=
name|dfhead
init|;
name|df
operator|!=
name|NULL
condition|;
control|)
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
switch|switch
condition|(
name|df
operator|->
name|type
condition|)
block|{
case|case
name|FRAG_ADD
case|:
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
name|lines
argument_list|,
name|df
operator|->
name|new_lines
argument_list|,
name|df
operator|->
name|len
argument_list|,
name|addvers
argument_list|,
name|df
operator|->
name|pos
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|FRAG_DELETE
case|:
if|if
condition|(
name|df
operator|->
name|pos
operator|>
name|lines
operator|->
name|nlines
operator|||
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
operator|>
name|lines
operator|->
name|nlines
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|delvers
operator|!=
name|NULL
condition|)
for|for
control|(
name|ln
operator|=
name|df
operator|->
name|pos
init|;
name|ln
operator|<
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
name|lines
operator|->
name|vector
index|[
name|ln
index|]
operator|->
name|vers
operator|=
name|delvers
expr_stmt|;
name|linevector_delete
argument_list|(
name|lines
argument_list|,
name|df
operator|->
name|pos
argument_list|,
name|df
operator|->
name|nlines
argument_list|)
expr_stmt|;
break|break;
block|}
name|df
operator|=
name|df
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dfhead
argument_list|)
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Apply an RCS change text to a buffer.  The function name starts    with rcs rather than RCS because this does not take an RCSNode    argument.  NAME is used in error messages.  TEXTBUF is the text    buffer to change, and TEXTLEN is the size.  DIFFBUF and DIFFLEN are    the change buffer and size.  The new buffer is returned in *RETBUF    and *RETLEN.  The new buffer is allocated by xmalloc.     Return 1 for success.  On failure, call error and return 0.  */
end_comment

begin_function
name|int
name|rcs_change_text
parameter_list|(
name|name
parameter_list|,
name|textbuf
parameter_list|,
name|textlen
parameter_list|,
name|diffbuf
parameter_list|,
name|difflen
parameter_list|,
name|retbuf
parameter_list|,
name|retlen
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|textbuf
decl_stmt|;
name|size_t
name|textlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|size_t
name|difflen
decl_stmt|;
name|char
modifier|*
modifier|*
name|retbuf
decl_stmt|;
name|size_t
modifier|*
name|retlen
decl_stmt|;
block|{
name|struct
name|linevector
name|lines
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|retbuf
operator|=
name|NULL
expr_stmt|;
operator|*
name|retlen
operator|=
literal|0
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
operator|&
name|lines
argument_list|,
name|textbuf
argument_list|,
name|textlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot initialize line vector"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_rcs_changes
argument_list|(
operator|&
name|lines
argument_list|,
name|diffbuf
argument_list|,
name|difflen
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid change text in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|unsigned
name|int
name|ln
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|lines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
comment|/* 1 for \n */
name|n
operator|+=
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|retbuf
operator|=
name|p
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|lines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|has_newline
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|retlen
operator|=
name|p
operator|-
operator|*
name|retbuf
expr_stmt|;
name|assert
argument_list|(
operator|*
name|retlen
operator|<=
name|n
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|linevector_free
argument_list|(
operator|&
name|lines
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Walk the deltas in RCS to get to revision VERSION.     If OP is RCS_ANNOTATE, then write annotations using cvs_output.     If OP is RCS_FETCH, then put the contents of VERSION into a    newly-malloc'd array and put a pointer to it in *TEXT.  Each line    is \n terminated; the caller is responsible for converting text    files if desired.  The total length is put in *LEN.     If FP is non-NULL, it should be a file descriptor open to the file    RCS with file position pointing to the deltas.  We close the file    when we are done.     If LOG is non-NULL, then *LOG is set to the log message of VERSION,    and *LOGLEN is set to the length of the log message.     On error, give a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|RCS_deltas
parameter_list|(
name|rcs
parameter_list|,
name|fp
parameter_list|,
name|rcsbuf
parameter_list|,
name|version
parameter_list|,
name|op
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|,
name|log
parameter_list|,
name|loglen
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|enum
name|rcs_delta_op
name|op
decl_stmt|;
name|char
modifier|*
modifier|*
name|text
decl_stmt|;
name|size_t
modifier|*
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|log
decl_stmt|;
name|size_t
modifier|*
name|loglen
decl_stmt|;
block|{
name|struct
name|rcsbuffer
name|rcsbuf_local
decl_stmt|;
name|char
modifier|*
name|branchversion
decl_stmt|;
name|char
modifier|*
name|cpversion
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|vallen
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|RCSVers
modifier|*
name|prev_vers
decl_stmt|;
name|RCSVers
modifier|*
name|trunk_vers
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|ishead
decl_stmt|,
name|isnext
decl_stmt|,
name|isversion
decl_stmt|,
name|onbranch
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|struct
name|linevector
name|headlines
decl_stmt|;
name|struct
name|linevector
name|curlines
decl_stmt|;
name|struct
name|linevector
name|trunklines
decl_stmt|;
name|int
name|foundhead
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|rcsbuf_cache_open
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|delta_pos
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf_local
argument_list|)
expr_stmt|;
name|rcsbuf
operator|=
operator|&
name|rcsbuf_local
expr_stmt|;
block|}
name|ishead
operator|=
literal|1
expr_stmt|;
name|vers
operator|=
name|NULL
expr_stmt|;
name|prev_vers
operator|=
name|NULL
expr_stmt|;
name|trunk_vers
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|onbranch
operator|=
literal|0
expr_stmt|;
name|foundhead
operator|=
literal|0
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|trunklines
argument_list|)
expr_stmt|;
comment|/* We set BRANCHVERSION to the version we are currently looking        for.  Initially, this is the version on the trunk from which        VERSION branches off.  If VERSION is not a branch, then        BRANCHVERSION is just VERSION.  */
name|branchversion
operator|=
name|xstrdup
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|branchversion
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
operator|*
name|cpversion
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|rcsbuf_getrevnum
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected EOF reading RCS file %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
operator|!
name|STREQ
argument_list|(
name|next
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* This is not the next version we need.  It is a branch                version which we want to ignore.  */
name|isnext
operator|=
literal|0
expr_stmt|;
name|isversion
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|isnext
operator|=
literal|1
expr_stmt|;
comment|/* look up the revision */
name|node
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Stash the previous version.  */
name|prev_vers
operator|=
name|vers
expr_stmt|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|vers
operator|->
name|next
expr_stmt|;
comment|/* Compare key and trunkversion now, because key points to 	       storage controlled by rcsbuf_getkey.  */
if|if
condition|(
name|STREQ
argument_list|(
name|branchversion
argument_list|,
name|key
argument_list|)
condition|)
name|isversion
operator|=
literal|1
expr_stmt|;
else|else
name|isversion
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s does not appear to be a valid rcs file"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|!=
name|NULL
operator|&&
name|isversion
operator|&&
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|branchversion
argument_list|,
name|version
argument_list|)
condition|)
block|{
operator|*
name|log
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|loglen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
condition|)
block|{
name|rcsbuf_valpolish
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|&
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishead
condition|)
block|{
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
operator|&
name|curlines
argument_list|,
name|value
argument_list|,
name|vallen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid rcs file %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|ishead
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isnext
condition|)
block|{
if|if
condition|(
operator|!
name|apply_rcs_changes
argument_list|(
operator|&
name|curlines
argument_list|,
name|value
argument_list|,
name|vallen
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|onbranch
condition|?
name|vers
else|:
name|NULL
argument_list|,
name|onbranch
condition|?
name|NULL
else|:
name|prev_vers
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid change text in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|isversion
condition|)
block|{
comment|/* This is either the version we want, or it is the                branchpoint to the version we want.  */
if|if
condition|(
name|STREQ
argument_list|(
name|branchversion
argument_list|,
name|version
argument_list|)
condition|)
block|{
comment|/* This is the version we want.  */
name|linevector_copy
argument_list|(
operator|&
name|headlines
argument_list|,
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|foundhead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|onbranch
condition|)
block|{
comment|/* We have found this version by tracking up a                        branch.  Restore back to the lines we saved                        when we left the trunk, and continue tracking                        down the trunk.  */
name|onbranch
operator|=
literal|0
expr_stmt|;
name|vers
operator|=
name|trunk_vers
expr_stmt|;
name|next
operator|=
name|vers
operator|->
name|next
expr_stmt|;
name|linevector_copy
argument_list|(
operator|&
name|curlines
argument_list|,
operator|&
name|trunklines
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* We need to look up the branch.  */
name|onbranch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|branchversion
argument_list|)
operator|<
literal|2
condition|)
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
comment|/* We are leaving the trunk; save the current                        lines so that we can restore them when we                        continue tracking down the trunk.  */
name|trunk_vers
operator|=
name|vers
expr_stmt|;
name|linevector_copy
argument_list|(
operator|&
name|trunklines
argument_list|,
operator|&
name|curlines
argument_list|)
expr_stmt|;
comment|/* Reset the version information we have                        accumulated so far.  It only applies to the                        changes from the head to this version.  */
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|curlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
name|curlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The next version we want is the entry on                    VERS->branches which matches this branch.  For                    example, suppose VERSION is 1.21.4.3 and                    BRANCHVERSION was 1.21.  Then we look for an entry                    starting with "1.21.4" and we'll put it (probably                    1.21.4.1) in NEXT.  We'll advance BRANCHVERSION by                    two dots (in this example, to 1.21.4.3).  */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing expected branches in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|cpversion
operator|=
literal|'.'
expr_stmt|;
operator|++
name|cpversion
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"version number confusion in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|branchversion
argument_list|,
name|cpversion
operator|-
name|branchversion
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing expected branch in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
operator|*
name|cpversion
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|RCS_FETCH
operator|&&
name|foundhead
condition|)
break|break;
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
name|free
argument_list|(
name|branchversion
argument_list|)
expr_stmt|;
name|rcsbuf_cache
argument_list|(
name|rcs
argument_list|,
name|rcsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundhead
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not find desired version %s in %s"
argument_list|,
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Now print out or return the data we have just computed.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RCS_ANNOTATE
case|:
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* Period which separates year from month in date.  */
name|char
modifier|*
name|ym
decl_stmt|;
comment|/* Period which separates month from day in date.  */
name|char
modifier|*
name|md
decl_stmt|;
name|RCSVers
modifier|*
name|prvers
decl_stmt|;
name|prvers
operator|=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
expr_stmt|;
if|if
condition|(
name|prvers
operator|==
name|NULL
condition|)
name|prvers
operator|=
name|vers
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-12s (%-8.8s "
argument_list|,
name|prvers
operator|->
name|version
argument_list|,
name|prvers
operator|->
name|author
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now output the date.  */
name|ym
operator|=
name|strchr
argument_list|(
name|prvers
operator|->
name|date
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ym
operator|==
name|NULL
condition|)
block|{
comment|/* ??- is an ANSI trigraph.  The ANSI way to 			   avoid it is \? but some pre ANSI compilers 			   complain about the unrecognized escape 			   sequence.  Of course string concatenation 			   ("??" "-???") is also an ANSI-ism.  Testing 			   __STDC__ seems to be a can of worms, since 			   compilers do all kinds of things with it.  */
name|cvs_output
argument_list|(
literal|"??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-???"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md
operator|=
name|strchr
argument_list|(
name|ym
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cvs_output
argument_list|(
name|md
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|month_printname
argument_list|(
name|ym
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Only output the last two digits of the year.  Our output 			   lines are long enough as it is without printing the 			   century.  */
name|cvs_output
argument_list|(
name|ym
operator|-
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"): "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
operator|!=
literal|0
condition|)
name|cvs_output
argument_list|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RCS_FETCH
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|unsigned
name|int
name|ln
decl_stmt|;
name|assert
argument_list|(
name|text
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
comment|/* 1 for \n */
name|n
operator|+=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|text
operator|=
name|p
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|has_newline
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|p
operator|-
operator|*
name|text
expr_stmt|;
name|assert
argument_list|(
operator|*
name|len
operator|<=
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|linevector_free
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_free
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|linevector_free
argument_list|(
operator|&
name|trunklines
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read the information for a single delta from the RCS buffer RCSBUF,    whose name is RCSFILE.  *KEYP and *VALP are either NULL, or the    first key/value pair to read, as set by rcsbuf_getkey. Return NULL    if there are no more deltas.  Store the key/value pair which    terminated the read in *KEYP and *VALP.  */
end_comment

begin_function
specifier|static
name|RCSVers
modifier|*
name|getdelta
parameter_list|(
name|rcsbuf
parameter_list|,
name|rcsfile
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|)
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|Node
modifier|*
name|kv
decl_stmt|;
comment|/* Get revision number if it wasn't passed in. This uses        rcsbuf_getkey because it doesn't croak when encountering        unexpected input.  As a result, we have to play unholy games        with `key' and `value'. */
if|if
condition|(
operator|*
name|keyp
operator|!=
name|NULL
condition|)
block|{
name|key
operator|=
operator|*
name|keyp
expr_stmt|;
name|value
operator|=
operator|*
name|valp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: unexpected EOF"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that it is a revision number and not a cabbage         or something. */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
comment|/* Note that when comparing with RCSDATE, we are not massaging        VALUE from the string found in the RCS file.  This is OK since        we know exactly what to expect.  */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
operator|(
sizeof|sizeof
name|RCSDATE
operator|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
name|value
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vnode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Grab the value of the date from value.  Note that we are not        massaging VALUE from the string found in the RCS file.  */
name|cp
operator|=
name|value
operator|+
operator|(
sizeof|sizeof
name|RCSDATE
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* skip the "date" keyword */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
comment|/* take space off front of value */
name|cp
operator|++
expr_stmt|;
name|vnode
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Get author field.  */
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"author"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse %s; `author' not in the expected place"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|author
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get state field.  */
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"state"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse %s; `state' not in the expected place"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|state
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* The value is optional, according to rcsfile(5).  */
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|value
argument_list|,
literal|"dead"
argument_list|)
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Note that "branches" and "next" are in fact mandatory, according        to doc/RCSFILES.  */
comment|/* fill in the branch list (if any branches exist) */
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
name|value
expr_stmt|;
comment|/* Probably could/should be a fatal error.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: 'branches' keyword missing from %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|vnode
return|;
block|}
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|vnode
operator|->
name|branches
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* Note that we are not massaging VALUE from the string found            in the RCS file.  */
name|do_branches
argument_list|(
name|vnode
operator|->
name|branches
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the next field if there is a next revision */
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
name|value
expr_stmt|;
comment|/* Probably could/should be a fatal error.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: 'next' keyword missing from %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|vnode
return|;
block|}
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|vnode
operator|->
name|next
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * XXX - this is where we put the symbolic link stuff???      * (into newphrases in the deltas).      */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* The `desc' keyword is the end of the deltas. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* The `hardlinks' value is a group of words, which must 	   be parsed separately and added as a list to vnode->hardlinks. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hardlinks"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|word
decl_stmt|;
name|vnode
operator|->
name|hardlinks
operator|=
name|getlist
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|word
operator|=
name|rcsbuf_valword
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|getnode
argument_list|()
decl_stmt|;
name|n
operator|->
name|key
operator|=
name|word
expr_stmt|;
name|addnode
argument_list|(
name|vnode
operator|->
name|hardlinks
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* Enable use of repositories created by certain obsolete 	   versions of CVS.  This code should remain indefinately; 	   there is no procedure for converting old repositories, and 	   checking for it is harmless.  */
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
name|RCSDEAD
argument_list|)
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|state
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vnode
operator|->
name|state
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
literal|"dead"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if we have a new revision number, we're done with this delta */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
comment|/* Note that when comparing with RCSDATE, we are not massaging 	   VALUE from the string found in the RCS file.  This is OK 	   since we know exactly what to expect.  */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* At this point, key and value represent a user-defined field 	   in the delta node. */
if|if
condition|(
name|vnode
operator|->
name|other_delta
operator|==
name|NULL
condition|)
name|vnode
operator|->
name|other_delta
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|rcsbuf_valcmp
argument_list|(
name|rcsbuf
argument_list|)
condition|?
name|RCSCMPFLD
else|:
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
name|kv
operator|->
name|type
operator|==
name|RCSFIELD
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other_delta
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Complaining about duplicate keys in newphrases seems 	       questionable, in that we don't know what they mean and 	       doc/RCSFILES has no prohibition on several newphrases 	       with the same key.  But we can't store more than one as 	       long as we store them in a List *.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: duplicate key `%s' in RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the key which caused us to fail back to the caller.  */
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
name|value
expr_stmt|;
return|return
name|vnode
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freedeltatext
parameter_list|(
name|d
parameter_list|)
name|Deltatext
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|version
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|log
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|other
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|d
operator|->
name|other
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Deltatext
modifier|*
name|RCS_getdeltatext
parameter_list|(
name|rcs
parameter_list|,
name|fp
parameter_list|,
name|rcsbuf
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbuf
decl_stmt|;
block|{
name|char
modifier|*
name|num
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|Deltatext
modifier|*
name|d
decl_stmt|;
comment|/* Get the revision number. */
if|if
condition|(
operator|!
name|rcsbuf_getrevnum
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|num
argument_list|)
condition|)
block|{
comment|/* If num == NULL, it means we reached EOF naturally.  That's 	   fine. */
if|if
condition|(
name|num
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s: unexpected EOF"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|Deltatext
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* Get the log message. */
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s, delta %s: unexpected EOF"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s, delta %s: expected `log', got `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|num
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|d
operator|->
name|log
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get random newphrases. */
name|d
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|rcsbuf_getkey
argument_list|(
name|rcsbuf
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s, delta %s: unexpected EOF"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
condition|)
break|break;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|rcsbuf_valcmp
argument_list|(
name|rcsbuf
argument_list|)
condition|?
name|RCSCMPFLD
else|:
name|RCSFIELD
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
name|p
operator|->
name|type
operator|==
name|RCSFIELD
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|d
operator|->
name|other
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: %s, delta %s: duplicate field `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|num
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the change text. We already know that this key is `text'. */
name|d
operator|->
name|text
operator|=
name|rcsbuf_valcopy
argument_list|(
name|rcsbuf
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
operator|&
name|d
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* RCS output functions, for writing RCS format files from RCSNode    structures.     For most of this work, RCS 5.7 uses an `aprintf' function which aborts    program upon error.  Instead, these functions check the output status    of the stream right before closing it, and aborts if an error condition    is found.  The RCS solution is probably the better one: it produces    more overhead, but will produce a clearer diagnostic in the case of    catastrophic error.  In either case, however, the repository will probably    not get corrupted. */
end_comment

begin_function
specifier|static
name|int
name|putsymbol_proc
parameter_list|(
name|symnode
parameter_list|,
name|fparg
parameter_list|)
name|Node
modifier|*
name|symnode
decl_stmt|;
name|void
modifier|*
name|fparg
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|fparg
decl_stmt|;
comment|/* A fiddly optimization: this code used to just call fprintf, but        in an old repository with hundreds of tags this can get called        hundreds of thousands of times when doing a cvs tag.  Since        tagging is a relatively common operation, and using putc and        fputs is just as comprehensible, the change is worthwhile.  */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|symnode
operator|->
name|key
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|symnode
operator|->
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|putlock_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* putlock_proc is like putsymbol_proc, but key and data are reversed. */
end_comment

begin_function
specifier|static
name|int
name|putlock_proc
parameter_list|(
name|symnode
parameter_list|,
name|fp
parameter_list|)
name|Node
modifier|*
name|symnode
decl_stmt|;
name|void
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|fp
argument_list|,
literal|"\n\t%s:%s"
argument_list|,
name|symnode
operator|->
name|data
argument_list|,
name|symnode
operator|->
name|key
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|putrcsfield_proc
parameter_list|(
name|node
parameter_list|,
name|vfp
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|vfp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfp
decl_stmt|;
comment|/* Some magic keys used internally by CVS start with `;'. Skip them. */
if|if
condition|(
name|node
operator|->
name|key
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s\t"
argument_list|,
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
comment|/* If the field's value contains evil characters, 	   it must be stringified. */
comment|/* FIXME: This does not quite get it right.  "7jk8f" is not a legal 	   value for a value in a newpharse, according to doc/RCSFILES, 	   because digits are not valid in an "id".  We might do OK by 	   always writing strings (enclosed in @@).  Would be nice to 	   explicitly mention this one way or another in doc/RCSFILES. 	   A case where we are wrong in a much more clear-cut way is that 	   we let through non-graphic characters such as whitespace and 	   control characters.  */
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|RCSCMPFLD
operator|||
name|strpbrk
argument_list|(
name|node
operator|->
name|data
argument_list|,
literal|"$,.:;@"
argument_list|)
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|expand_at_signs
argument_list|(
name|node
operator|->
name|data
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|node
operator|->
name|data
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* desc, log and text fields should not be terminated with semicolon;        all other fields should be. */
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|"desc"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|"log"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|"text"
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
end_ifdef

begin_comment
comment|/* Save a filename in a `hardlinks' RCS field.  NODE->KEY will contain    a full pathname, but currently only basenames are stored in the RCS    node.  Assume that the filename includes nasty characters and    @-escape it. */
end_comment

begin_function
specifier|static
name|int
name|puthardlink_proc
parameter_list|(
name|node
parameter_list|,
name|vfp
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|vfp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|vfp
decl_stmt|;
name|char
modifier|*
name|basename
init|=
name|strrchr
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
name|basename
operator|=
name|node
operator|->
name|key
expr_stmt|;
else|else
operator|++
name|basename
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|expand_at_signs
argument_list|(
name|basename
argument_list|,
name|strlen
argument_list|(
name|basename
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output the admin node for RCS into stream FP. */
end_comment

begin_function
specifier|static
name|void
name|RCS_putadmin
parameter_list|(
name|rcs
parameter_list|,
name|fp
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t%s;\n"
argument_list|,
name|RCSHEAD
argument_list|,
name|rcs
operator|->
name|head
condition|?
name|rcs
operator|->
name|head
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|branch
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t%s;\n"
argument_list|,
name|RCSBRANCH
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"access"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|access
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|access
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|s
argument_list|,
literal|" \n\t"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \n\t"
argument_list|)
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|";\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|RCSSYMBOLS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* If we haven't had to convert the symbols to a list yet, don't        force a conversion now; just write out the string.  */
if|if
condition|(
name|rcs
operator|->
name|symbols
operator|==
name|NULL
operator|&&
name|rcs
operator|->
name|symbols_data
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"\n\t"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|rcs
operator|->
name|symbols_data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|putsymbol_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"locks"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|locks_data
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s"
argument_list|,
name|rcs
operator|->
name|locks_data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rcs
operator|->
name|locks
condition|)
name|walklist
argument_list|(
name|rcs
operator|->
name|locks
argument_list|,
name|putlock_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|strict_locks
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"; strict"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|comment
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"comment\t@"
argument_list|)
expr_stmt|;
name|expand_at_signs
argument_list|(
name|rcs
operator|->
name|comment
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|rcs
operator|->
name|comment
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@;\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcs
operator|->
name|expand
operator|&&
operator|!
name|STREQ
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
literal|"kv"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t@%s@;\n"
argument_list|,
name|RCSEXPAND
argument_list|,
name|rcs
operator|->
name|expand
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|rcs
operator|->
name|other
argument_list|,
name|putrcsfield_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putdelta
parameter_list|(
name|vers
parameter_list|,
name|fp
parameter_list|)
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|Node
modifier|*
name|bp
decl_stmt|,
modifier|*
name|start
decl_stmt|;
comment|/* Skip if no revision was supplied, or if it is outdated (cvs admin -o) */
if|if
condition|(
name|vers
operator|==
name|NULL
operator|||
name|vers
operator|->
name|outdated
condition|)
return|return;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s\n%s\t%s;\t%s %s;\t%s %s;\nbranches"
argument_list|,
name|vers
operator|->
name|version
argument_list|,
name|RCSDATE
argument_list|,
name|vers
operator|->
name|date
argument_list|,
literal|"author"
argument_list|,
name|vers
operator|->
name|author
argument_list|,
literal|"state"
argument_list|,
name|vers
operator|->
name|state
condition|?
name|vers
operator|->
name|state
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|start
operator|->
name|next
init|;
name|bp
operator|!=
name|start
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t%s"
argument_list|,
name|bp
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";\nnext\t%s;"
argument_list|,
name|vers
operator|->
name|next
condition|?
name|vers
operator|->
name|next
else|:
literal|""
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|vers
operator|->
name|other_delta
argument_list|,
name|putrcsfield_proc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|vers
operator|->
name|hardlinks
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\nhardlinks"
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|vers
operator|->
name|hardlinks
argument_list|,
name|puthardlink_proc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|RCS_putdtree
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|fp
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|versp
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|branch
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
return|return;
comment|/* Find the delta node for this revision. */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error parsing repository file %s, file may be corrupt."
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|versp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* Print the delta node and recurse on its `next' node.  This prints        the trunk.  If there are any branches printed on this revision,        print those trunks as well. */
name|putdelta
argument_list|(
name|versp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|RCS_putdtree
argument_list|(
name|rcs
argument_list|,
name|versp
operator|->
name|next
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|versp
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|branch
operator|=
name|versp
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|branch
operator|->
name|next
init|;
name|p
operator|!=
name|branch
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|RCS_putdtree
argument_list|(
name|rcs
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|RCS_putdesc
parameter_list|(
name|rcs
parameter_list|,
name|fp
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\n%s\n@"
argument_list|,
name|RCSDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|desc
operator|!=
name|NULL
condition|)
block|{
name|off_t
name|len
init|=
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|rcs
operator|->
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|expand_at_signs
argument_list|(
name|rcs
operator|->
name|desc
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|desc
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"@\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putdeltatext
parameter_list|(
name|fp
parameter_list|,
name|d
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Deltatext
modifier|*
name|d
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\n%s\nlog\n@"
argument_list|,
name|d
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|log
operator|!=
name|NULL
condition|)
block|{
name|int
name|loglen
init|=
name|strlen
argument_list|(
name|d
operator|->
name|log
argument_list|)
decl_stmt|;
name|expand_at_signs
argument_list|(
name|d
operator|->
name|log
argument_list|,
operator|(
name|off_t
operator|)
name|loglen
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|log
index|[
name|loglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|d
operator|->
name|other
argument_list|,
name|putrcsfield_proc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ntext\n@"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|!=
name|NULL
condition|)
name|expand_at_signs
argument_list|(
name|d
operator|->
name|text
argument_list|,
operator|(
name|off_t
operator|)
name|d
operator|->
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: the whole mechanism for updating deltas is kludgey... more    sensible would be to supply all the necessary info in a `newdeltatext'    field for RCSVers nodes. -twp */
end_comment

begin_comment
comment|/* Copy delta text nodes from FIN to FOUT.  If NEWDTEXT is non-NULL, it    is a new delta text node, and should be added to the tree at the    node whose revision number is INSERTPT.  (Note that trunk nodes are    written in decreasing order, and branch nodes are written in    increasing order.) */
end_comment

begin_function
specifier|static
name|void
name|RCS_copydeltas
parameter_list|(
name|rcs
parameter_list|,
name|fin
parameter_list|,
name|rcsbufin
parameter_list|,
name|fout
parameter_list|,
name|newdtext
parameter_list|,
name|insertpt
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fin
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbufin
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
name|Deltatext
modifier|*
name|newdtext
decl_stmt|;
name|char
modifier|*
name|insertpt
decl_stmt|;
block|{
name|int
name|actions
decl_stmt|;
name|RCSVers
modifier|*
name|dadmin
decl_stmt|;
name|Node
modifier|*
name|np
decl_stmt|;
name|int
name|insertbefore
decl_stmt|,
name|found
decl_stmt|;
name|char
modifier|*
name|bufrest
decl_stmt|;
name|int
name|nls
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|got
decl_stmt|;
comment|/* Count the number of versions for which we have to do some        special operation.  */
name|actions
operator|=
name|walklist
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|count_delta_actions
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make a note of whether NEWDTEXT should be inserted        before or after its INSERTPT. */
name|insertbefore
operator|=
operator|(
name|newdtext
operator|!=
name|NULL
operator|&&
name|numdots
argument_list|(
name|newdtext
operator|->
name|version
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|actions
operator|!=
literal|0
operator|||
name|newdtext
operator|!=
name|NULL
condition|)
block|{
name|Deltatext
modifier|*
name|dtext
decl_stmt|;
name|dtext
operator|=
name|RCS_getdeltatext
argument_list|(
name|rcs
argument_list|,
name|fin
argument_list|,
name|rcsbufin
argument_list|)
expr_stmt|;
comment|/* We shouldn't hit EOF here, because that would imply that            some action was not taken, or that we could not insert            NEWDTEXT.  */
if|if
condition|(
name|dtext
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: EOF too early in RCS_copydeltas"
argument_list|)
expr_stmt|;
name|found
operator|=
operator|(
name|insertpt
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|dtext
operator|->
name|version
argument_list|,
name|insertpt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|insertbefore
condition|)
block|{
name|putdeltatext
argument_list|(
name|fout
argument_list|,
name|newdtext
argument_list|)
expr_stmt|;
name|newdtext
operator|=
name|NULL
expr_stmt|;
name|insertpt
operator|=
name|NULL
expr_stmt|;
block|}
name|np
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|dtext
operator|->
name|version
argument_list|)
expr_stmt|;
name|dadmin
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|np
operator|->
name|data
expr_stmt|;
comment|/* If this revision has been outdated, just skip it. */
if|if
condition|(
name|dadmin
operator|->
name|outdated
condition|)
block|{
name|freedeltatext
argument_list|(
name|dtext
argument_list|)
expr_stmt|;
operator|--
name|actions
expr_stmt|;
continue|continue;
block|}
comment|/* Update the change text for this delta.  New change text 	   data may come from cvs admin -m, cvs admin -o, or cvs ci. */
if|if
condition|(
name|dadmin
operator|->
name|text
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dadmin
operator|->
name|text
operator|->
name|log
operator|!=
name|NULL
operator|||
name|dadmin
operator|->
name|text
operator|->
name|text
operator|!=
name|NULL
condition|)
operator|--
name|actions
expr_stmt|;
if|if
condition|(
name|dadmin
operator|->
name|text
operator|->
name|log
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dtext
operator|->
name|log
argument_list|)
expr_stmt|;
name|dtext
operator|->
name|log
operator|=
name|dadmin
operator|->
name|text
operator|->
name|log
expr_stmt|;
name|dadmin
operator|->
name|text
operator|->
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dadmin
operator|->
name|text
operator|->
name|text
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dtext
operator|->
name|text
argument_list|)
expr_stmt|;
name|dtext
operator|->
name|text
operator|=
name|dadmin
operator|->
name|text
operator|->
name|text
expr_stmt|;
name|dtext
operator|->
name|len
operator|=
name|dadmin
operator|->
name|text
operator|->
name|len
expr_stmt|;
name|dadmin
operator|->
name|text
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|putdeltatext
argument_list|(
name|fout
argument_list|,
name|dtext
argument_list|)
expr_stmt|;
name|freedeltatext
argument_list|(
name|dtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
operator|!
name|insertbefore
condition|)
block|{
name|putdeltatext
argument_list|(
name|fout
argument_list|,
name|newdtext
argument_list|)
expr_stmt|;
name|newdtext
operator|=
name|NULL
expr_stmt|;
name|insertpt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Copy the rest of the file directly, without bothering to        interpret it.  The caller will handle error checking by calling        ferror.         We just wrote a newline to the file, either in putdeltatext or        in the caller.  However, we may not have read the corresponding        newline from the file, because rcsbuf_getkey returns as soon as        it finds the end of the '@' string for the desc or text key.        Therefore, we may read three newlines when we should really        only write two, and we check for that case here.  This is not        an semantically important issue; we only do it to make our RCS        files look traditional.  */
name|nls
operator|=
literal|3
expr_stmt|;
name|rcsbuf_get_buffered
argument_list|(
name|rcsbufin
argument_list|,
operator|&
name|bufrest
argument_list|,
operator|&
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bufrest
index|[
literal|0
index|]
operator|!=
literal|'\n'
operator|||
name|strncmp
argument_list|(
name|bufrest
argument_list|,
literal|"\n\n\n"
argument_list|,
name|buflen
operator|<
literal|3
condition|?
name|buflen
else|:
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nls
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buflen
operator|<
literal|3
condition|)
name|nls
operator|-=
name|buflen
expr_stmt|;
else|else
block|{
operator|++
name|bufrest
expr_stmt|;
operator|--
name|buflen
expr_stmt|;
name|nls
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fwrite
argument_list|(
name|bufrest
argument_list|,
literal|1
argument_list|,
name|buflen
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|got
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fin
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nls
operator|>
literal|0
operator|&&
name|got
operator|>=
name|nls
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"\n\n\n"
argument_list|,
name|nls
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|got
operator|-
literal|1
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|got
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|nls
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A helper procedure for RCS_copydeltas.  This is called via walklist    to count the number of RCS revisions for which some special action    is required.  */
end_comment

begin_function
specifier|static
name|int
name|count_delta_actions
parameter_list|(
name|np
parameter_list|,
name|ignore
parameter_list|)
name|Node
modifier|*
name|np
decl_stmt|;
name|void
modifier|*
name|ignore
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|dadmin
decl_stmt|;
name|dadmin
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|np
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|dadmin
operator|->
name|outdated
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dadmin
operator|->
name|text
operator|!=
name|NULL
operator|&&
operator|(
name|dadmin
operator|->
name|text
operator|->
name|log
operator|!=
name|NULL
operator|||
name|dadmin
operator|->
name|text
operator|->
name|text
operator|!=
name|NULL
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up temporary files  */
end_comment

begin_function
name|RETSIGTYPE
name|rcs_cleanup
parameter_list|()
block|{
comment|/* Note that the checks for existence_error are because we are        called from a signal handler, so we don't know whether the        files got created.  */
comment|/* FIXME: Do not perform buffered I/O from an interrupt handler like        this (via error).  However, I'm leaving the error-calling code there        in the hope that on the rare occasion the error call is actually made        (e.g., a fluky I/O error or permissions problem prevents the deletion        of a just-created file) reentrancy won't be an issue.  */
if|if
condition|(
name|rcs_lockfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|rcs_lockfile
decl_stmt|;
name|rcs_lockfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rcs_lockfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|rcs_lockfd
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing lock file %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|rcs_lockfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* RCS_internal_lockfile and RCS_internal_unlockfile perform RCS-style    locking on the specified RCSFILE: for a file called `foo,v', open    for writing a file called `,foo,'.     Note that we what do here is quite different from what RCS does.    RCS creates the ,foo, file before it reads the RCS file (if it    knows that it will be writing later), so that it actually serves as    a lock.  We don't; instead we rely on CVS writelocks.  This means    that if someone is running RCS on the file at the same time they    are running CVS on it, they might lose (we read the file,    then RCS writes it, then we write it, clobbering the    changes made by RCS).  I believe the current sentiment about this    is "well, don't do that".     A concern has been expressed about whether adopting the RCS    strategy would slow us down.  I don't think so, since we need to    write the ,foo, file anyway (unless perhaps if O_EXCL is slower or    something).     These do not perform quite the same function as the RCS -l option    for locking files: they are intended to prevent competing RCS    processes from stomping all over each other's laundry.  Hence,    they are `internal' locking functions.     If there is an error, give a fatal error; if we return we always    return a non-NULL value.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|rcs_internal_lockfile
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|struct
name|stat
name|rstat
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|int
name|first_call
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first_call
condition|)
block|{
name|first_call
operator|=
literal|0
expr_stmt|;
comment|/* clean up if we get a signal */
ifdef|#
directive|ifdef
name|SIGABRT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGABRT
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|rcs_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Get the lock file name: `,file,' for RCS file `file,v'. */
name|assert
argument_list|(
name|rcs_lockfile
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rcs_lockfd
operator|<
literal|0
argument_list|)
expr_stmt|;
name|rcs_lockfile
operator|=
name|rcs_lockfilename
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* Use the existing RCS file mode, or read-only if this is a new        file.  (Really, this is a lie -- if this is a new file,        RCS_checkin uses the permissions from the working copy.  For        actually creating the file, we use 0444 as a safe default mode.) */
if|if
condition|(
name|stat
argument_list|(
name|rcsfile
argument_list|,
operator|&
name|rstat
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|rstat
operator|.
name|st_mode
operator|=
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
comment|/* Try to open exclusively.  POSIX.1 guarantees that O_EXCL|O_CREAT        guarantees an exclusive open.  According to the RCS source, with        NFS v2 we must also throw in O_TRUNC and use an open mask that makes        the file unwriteable.  For extensive justification, see the comments for        rcswriteopen() in rcsedit.c, in RCS 5.7.  This is kind of pointless        in the CVS case; see comment at the start of this file concerning        general ,foo, file strategy.         There is some sentiment that with NFSv3 and such, that one can        rely on O_EXCL these days.  This might be true for unix (I        don't really know), but I am still pretty skeptical in the case        of the non-unix systems.  */
name|rcs_lockfd
operator|=
name|open
argument_list|(
name|rcs_lockfile
argument_list|,
name|OPEN_BINARY
operator||
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_TRUNC
argument_list|,
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs_lockfd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open lock file `%s'"
argument_list|,
name|rcs_lockfile
argument_list|)
expr_stmt|;
block|}
comment|/* Force the file permissions, and return a stream object. */
comment|/* Because we change the modes later, we don't worry about        this in the non-HAVE_FCHMOD case.  */
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
if|if
condition|(
name|fchmod
argument_list|(
name|rcs_lockfd
argument_list|,
name|rstat
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode for %s"
argument_list|,
name|rcs_lockfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|fdopen
argument_list|(
name|rcs_lockfd
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fdopen %s"
argument_list|,
name|rcs_lockfile
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rcs_internal_unlockfile
parameter_list|(
name|fp
parameter_list|,
name|rcsfile
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs_lockfile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rcs_lockfd
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Abort if we could not write everything successfully to LOCKFILE.        This is not a great error-handling mechanism, but should prevent        corrupting the repository. */
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
comment|/* The only case in which using errno here would be meaningful 	   is if we happen to have left errno unmolested since the call 	   which produced the error (e.g. fprintf).  That is pretty 	   fragile even if it happens to sometimes be true.  The real 	   solution is to check each call to fprintf rather than waiting 	   until the end like this.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error writing to lock file %s"
argument_list|,
name|rcs_lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing lock file %s"
argument_list|,
name|rcs_lockfile
argument_list|)
expr_stmt|;
name|rcs_lockfd
operator|=
operator|-
literal|1
expr_stmt|;
name|rename_file
argument_list|(
name|rcs_lockfile
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|{
comment|/* Use a temporary to make sure there's no interval 	   (after rcs_lockfile has been freed but before it's set to NULL) 	   during which the signal handler's use of rcs_lockfile would 	   reference freed memory.  */
name|char
modifier|*
name|tmp
init|=
name|rcs_lockfile
decl_stmt|;
name|rcs_lockfile
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|rcs_lockfilename
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|char
modifier|*
name|lockfile
decl_stmt|,
modifier|*
name|lockp
decl_stmt|;
name|char
modifier|*
name|rcsbase
decl_stmt|,
modifier|*
name|rcsp
decl_stmt|,
modifier|*
name|rcsend
decl_stmt|;
name|int
name|rcslen
decl_stmt|;
comment|/* Create the lockfile name. */
name|rcslen
operator|=
name|strlen
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
name|lockfile
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|rcslen
operator|+
literal|10
argument_list|)
expr_stmt|;
name|rcsbase
operator|=
name|last_component
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
name|rcsend
operator|=
name|rcsfile
operator|+
name|rcslen
operator|-
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
expr_stmt|;
for|for
control|(
name|lockp
operator|=
name|lockfile
operator|,
name|rcsp
operator|=
name|rcsfile
init|;
name|rcsp
operator|<
name|rcsbase
condition|;
operator|++
name|rcsp
control|)
operator|*
name|lockp
operator|++
operator|=
operator|*
name|rcsp
expr_stmt|;
operator|*
name|lockp
operator|++
operator|=
literal|','
expr_stmt|;
while|while
condition|(
name|rcsp
operator|<=
name|rcsend
condition|)
operator|*
name|lockp
operator|++
operator|=
operator|*
name|rcsp
operator|++
expr_stmt|;
operator|*
name|lockp
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|lockp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|lockfile
return|;
block|}
end_function

begin_comment
comment|/* Rewrite an RCS file.  The basic idea here is that the caller should    first call RCS_reparsercsfile, then munge the data structures as    desired (via RCS_delete_revs, RCS_settag,&c), then call RCS_rewrite.  */
end_comment

begin_function
name|void
name|RCS_rewrite
parameter_list|(
name|rcs
parameter_list|,
name|newdtext
parameter_list|,
name|insertpt
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|Deltatext
modifier|*
name|newdtext
decl_stmt|;
name|char
modifier|*
name|insertpt
decl_stmt|;
block|{
name|FILE
modifier|*
name|fin
decl_stmt|,
modifier|*
name|fout
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbufin
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
comment|/* Make sure we're operating on an actual file and not a symlink.  */
name|resolve_symlink
argument_list|(
operator|&
operator|(
name|rcs
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|fout
operator|=
name|rcs_internal_lockfile
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|RCS_putadmin
argument_list|(
name|rcs
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|RCS_putdtree
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|head
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|RCS_putdesc
argument_list|(
name|rcs
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/* Open the original RCS file and seek to the first delta text. */
name|rcsbuf_cache_open
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|delta_pos
argument_list|,
operator|&
name|fin
argument_list|,
operator|&
name|rcsbufin
argument_list|)
expr_stmt|;
comment|/* Update delta_pos to the current position in the output file.        Do NOT move these statements: they must be done after fin has        been positioned at the old delta_pos, but before any delta        texts have been written to fout. */
name|rcs
operator|->
name|delta_pos
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|delta_pos
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot ftell in RCS file %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|RCS_copydeltas
argument_list|(
name|rcs
argument_list|,
name|fin
argument_list|,
operator|&
name|rcsbufin
argument_list|,
name|fout
argument_list|,
name|newdtext
argument_list|,
name|insertpt
argument_list|)
expr_stmt|;
comment|/* We don't want to call rcsbuf_cache here, since we're about to        delete the file.  */
name|rcsbuf_close
argument_list|(
operator|&
name|rcsbufin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fin
argument_list|)
condition|)
comment|/* The only case in which using errno here would be meaningful 	   is if we happen to have left errno unmolested since the call 	   which produced the error (e.g. fread).  That is pretty 	   fragile even if it happens to sometimes be true.  The real 	   solution is to make sure that all the code which reads 	   from fin checks for errors itself (some does, some doesn't).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: when closing RCS file `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: closing RCS file `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs_internal_unlockfile
argument_list|(
name|fout
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Abandon changes to an RCS file. */
end_comment

begin_function
name|void
name|RCS_abandon
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|free_rcsnode_contents
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|symbols_data
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|expand
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|access
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|locks_data
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|comment
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|desc
operator|=
name|NULL
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|PARTIAL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Annotate command.  In rcs.c for historical reasons (from back when    what is now RCS_deltas was part of annotate_fileproc).  */
end_comment

begin_comment
comment|/* Options from the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|annotate_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|annotate_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|rcsbuffer
modifier|*
name|rcsbufp
init|=
name|NULL
decl_stmt|;
name|struct
name|rcsbuffer
name|rcsbuf
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
block|{
name|RCS_reparsercsfile
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|rcsbuf
argument_list|)
expr_stmt|;
name|rcsbufp
operator|=
operator|&
name|rcsbuf
expr_stmt|;
block|}
name|version
operator|=
name|RCS_getversion
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Distinguish output for various files if we are processing        several files.  */
name|cvs_outerr
argument_list|(
literal|"Annotations for "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n***************\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RCS_deltas
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|fp
argument_list|,
name|rcsbufp
argument_list|,
name|version
argument_list|,
name|RCS_ANNOTATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|annotate_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lRf] [-r rev|-D date] [files...]\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-f\tUse head revision if tag/date not found.\n"
block|,
literal|"\t-r rev\tAnnotate file as of specified revision/tag.\n"
block|,
literal|"\t-D date\tAnnotate file as of specified date.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command to show the revision, date, and author where each line of a    file was modified.  */
end_comment

begin_function
name|int
name|annotate
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lr:D:fR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"annotate\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|start_recursion
argument_list|(
name|annotate_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * For a given file with full pathname PATH and revision number REV,  * produce a file label suitable for passing to diff.  The default  * file label as used by RCS 5.7 looks like this:  *  *	FILENAME<tab> YYYY/MM/DD<sp> HH:MM:SS<tab> REVNUM  *  * The date and time used are the revision's last checkin date and time.  * If REV is NULL, use the working copy's mtime instead.  */
end_comment

begin_function
name|char
modifier|*
name|make_file_label
parameter_list|(
name|path
parameter_list|,
name|rev
parameter_list|,
name|rcs
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|char
name|datebuf
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|last_component
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
operator|(
name|rev
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|rev
argument_list|)
operator|)
operator|+
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
condition|)
block|{
name|char
modifier|*
name|date
decl_stmt|;
name|RCS_getrevtime
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
name|datebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|date
operator|=
name|printable_date
argument_list|(
name|datebuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"-L%s\t%s\t%s"
argument_list|,
name|path
argument_list|,
name|date
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|tm
modifier|*
name|wm
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|"could not get info for `%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|wm
operator|=
name|gmtime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|datebuf
argument_list|,
literal|"%04d/%02d/%02d %02d:%02d:%02d"
argument_list|,
name|wm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|wm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|wm
operator|->
name|tm_mday
argument_list|,
name|wm
operator|->
name|tm_hour
argument_list|,
name|wm
operator|->
name|tm_min
argument_list|,
name|wm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|label
argument_list|,
literal|"-L%s\t%s"
argument_list|,
name|path
argument_list|,
name|datebuf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|label
return|;
block|}
end_function

end_unit

