begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * The routines contained in this file do all the rcs file parsing and  * manipulation  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
specifier|const
name|char
operator|*
name|rcsfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|date
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getrcskey
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
name|char
operator|*
operator|*
name|keyp
operator|,
name|char
operator|*
operator|*
name|valp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkmagic_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branches
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_symbols
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsvers_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We don't want to use isspace() from the C library because:  *  * 1. The definition of "whitespace" in RCS files includes ASCII  *    backspace, but the C locale doesn't.  * 2. isspace is an very expensive function call in some implementations  *    due to the addition of wide character support.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|spacetab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 - 0x0f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x10 - 0x1f */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x20 - 0x2f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x30 - 0x3f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x40 - 0x4f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x50 - 0x5f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x60 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x70 - 0x7f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x80 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x90 - 0x9f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xa0 - 0xaf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xb0 - 0xbf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xc0 - 0xcf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xd0 - 0xdf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xe0 - 0xef */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 0xf0 - 0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(spacetab[(unsigned char)c] != 0)
end_define

begin_comment
comment|/*  * Parse an rcsfile given a user file name and a repository  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parse
parameter_list|(
name|file
parameter_list|,
name|repos
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|rcsfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a specific rcsfile.  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parsercsfile
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
comment|/* open the rcsfile */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcs file `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
parameter_list|(
name|fp
parameter_list|,
name|rcsfile
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
comment|/* make a node */
name|rdata
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* Process HEAD and BRANCH keywords from the RCS header.        *      * Most cvs operatations on the main branch don't need any more      * information.  Those that do call XXX to completely parse the      * RCS file.  */
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|RCSHEAD
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|RCSBRANCH
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|rdata
operator|->
name|branch
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|rdata
operator|->
name|branch
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* turn it into a branch if it's a revision */
name|cp
operator|=
name|strrchr
argument_list|(
name|rdata
operator|->
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|rdata
operator|->
name|flags
operator||=
name|PARTIAL
expr_stmt|;
return|return
name|rdata
return|;
name|l_error
label|:
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
block|}
name|freercsnode
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the real work of parsing an RCS file.     On error, die with a fatal error; if it returns at all it was successful.     If PFP is NULL, close the file when done.  Otherwise, leave it open    and store the FILE * in *PFP.  */
end_comment

begin_function
specifier|static
name|void
name|RCS_reparsercsfile
parameter_list|(
name|rdata
parameter_list|,
name|pfp
parameter_list|)
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pfp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|assert
argument_list|(
name|rdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rcsfile
operator|=
name|rdata
operator|->
name|path
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unable to reopen `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* make a node */
name|rdata
operator|->
name|versions
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * process all the special header information, break out when we get to      * the first revision delta      */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get the next key/value pair */
comment|/* if key is NULL here, then the file is missing some headers 	   or we had trouble reading the file. */
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSSYMBOLS
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|rdata
operator|->
name|symbols_data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSEXPAND
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rdata
operator|->
name|expand
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * check key for '.''s and digits (probably a rev) if it is a 	 * revision, we are done with the headers and are down to the 	 * revision deltas, so we break out of the loop 	 */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* if we haven't grabbed it yet, we didn't want it */
block|}
comment|/*      * we got out of the loop, so we have the first part of the first      * revision delta in our hand key=the revision and value=the date key and      * its value      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|valp
decl_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vnode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the version before we forget it */
name|vnode
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* grab the value of the date from value */
name|valp
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
expr_stmt|;
comment|/* skip the "date" keyword */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|valp
argument_list|)
condition|)
comment|/* take space off front of value */
name|valp
operator|++
expr_stmt|;
name|vnode
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|valp
argument_list|)
expr_stmt|;
comment|/* Get author field.  */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: should be using errno in case of ferror.  */
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"author"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse rcs file; `author' not in the expected place"
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|author
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Get state field.  */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: should be using errno in case of ferror.  */
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"state"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse rcs file; `state' not in the expected place"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"dead"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
block|}
comment|/* fill in the branch list (if any branches exist) */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: should be handling various error conditions better.  */
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|vnode
operator|->
name|branches
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_branches
argument_list|(
name|vnode
operator|->
name|branches
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the next field if there is a next revision */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: should be handling various error conditions better.  */
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|vnode
operator|->
name|next
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * at this point, we skip any user defined fields XXX - this is where 	 * we put the symbolic link stuff??? 	 */
comment|/* FIXME: Does not correctly handle errors, e.g. from stdio.  */
while|while
condition|(
operator|(
name|n
operator|=
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Enable use of repositories created by certain obsolete 	       versions of CVS.  This code should remain indefinately; 	       there is no procedure for converting old repositories, and 	       checking for it is harmless.  */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDEAD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* if we have a revision, break and do it */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* get the node */
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|q
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|q
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|vnode
expr_stmt|;
name|q
operator|->
name|key
operator|=
name|vnode
operator|->
name|version
expr_stmt|;
comment|/* add the nodes to the list */
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|versions
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|purify_printf("WARNING: Adding duplicate version: %s (%s)\n", 			 q->key, rcsfile); 		freenode (q);
endif|#
directive|endif
block|}
comment|/* 	 * if we left the loop because there were no more keys, we break out 	 * of the revision processing loop 	 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pfp
operator|=
name|fp
expr_stmt|;
block|}
name|rdata
operator|->
name|flags
operator|&=
operator|~
name|PARTIAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freercsnode - free up the info for an RCSNode  */
end_comment

begin_function
name|void
name|freercsnode
parameter_list|(
name|rnodep
parameter_list|)
name|RCSNode
modifier|*
modifier|*
name|rnodep
decl_stmt|;
block|{
if|if
condition|(
name|rnodep
operator|==
name|NULL
operator|||
operator|*
name|rnodep
operator|==
name|NULL
condition|)
return|return;
operator|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|path
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|versions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols_data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|expand
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|expand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|rnodep
argument_list|)
expr_stmt|;
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcsvers_delproc - free up an RCSVers type node  */
end_comment

begin_function
specifier|static
name|void
name|rcsvers_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|rnode
decl_stmt|;
name|rnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|branches
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|branches
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|date
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|next
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getrcskey - fill in the key and value from the rcs file the algorithm is  *             as follows   *  *    o skip whitespace o fill in key with everything up to next white   *      space or semicolon   *    o if key == "desc" then key and data are NULL and return -1   *    o if key wasn't terminated by a semicolon, skip white space and fill   *      in value with everything up to a semicolon   *    o compress all whitespace down to a single space   *    o if a word starts with @, do funky rcs processing  *    o strip whitespace off end of value or set value to NULL if it empty   *    o return 0 since we found something besides "desc"  *  * Sets *KEYP and *VALUEP to point to storage managed by the getrcskey  * function; the contents are only valid until the next call to getrcskey  * or getrcsrev.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|keysize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|valsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALLOCINCR
value|1024
end_define

begin_function
specifier|static
name|int
name|getrcskey
parameter_list|(
name|fp
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
block|{
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|max
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* skip leading whitespace */
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* fill in key */
name|cur
operator|=
name|key
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|key
operator|=
name|xrealloc
argument_list|(
name|key
argument_list|,
name|keysize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
name|keysize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|key
operator|=
name|xrealloc
argument_list|(
name|key
argument_list|,
name|keysize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
name|keysize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip whitespace between key and val */
while|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* if we ended key with a semicolon, there is no value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* otherwise, there might be a value, so fill it in */
name|cur
operator|=
name|value
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
comment|/* process the value */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* handle RCS "strings" */
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* The syntax for some key-value pairs is different; they 	   don't end with a semicolon.  */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* compress whitespace down to a single space */
if|if
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* if we got a semi-colon we are done with the entire value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
break|break;
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* terminate the string */
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|value
operator|=
name|xrealloc
argument_list|(
name|value
argument_list|,
name|valsize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|valsize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* if the string is empty, make it null */
if|if
condition|(
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'\0'
condition|)
operator|*
name|valp
operator|=
name|value
expr_stmt|;
else|else
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|getrcsrev
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
name|char
operator|*
operator|*
name|revp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read an RCS revision number from FP.  Put a pointer to it in *REVP;    it points to space managed by getrcsrev which is only good until    the next call to getrcskey or getrcsrev.  */
end_comment

begin_function
specifier|static
name|void
name|getrcsrev
parameter_list|(
name|fp
parameter_list|,
name|revp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|revp
decl_stmt|;
block|{
name|char
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|max
decl_stmt|;
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
comment|/* FIXME: should be including filename in error message.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcs file"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
comment|/* FIXME: should be including filename in error message.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading rcs file; revision number expected"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|key
operator|=
name|xrealloc
argument_list|(
name|key
argument_list|,
name|keysize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
name|keysize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* FIXME: should be including filename in error message.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcs file"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|key
operator|=
name|xrealloc
argument_list|(
name|key
argument_list|,
name|keysize
operator|+
name|ALLOCINCR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
name|keysize
operator|+=
name|ALLOCINCR
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|revp
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process the symbols list of the rcs file  */
end_comment

begin_function
specifier|static
name|void
name|do_symbols
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* split it up into tag and rev */
name|tag
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the branches list of a revision delta  */
end_comment

begin_function
specifier|static
name|void
name|do_branches
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* find the end of this branch */
name|branch
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Version Number  *   * Returns the requested version number of the RCS file, satisfying tags and/or  * dates, and walking branches, if necessary.  *   * The result is returned; null-string if error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getversion
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|,
name|return_both
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
name|return_both
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|date
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|tagrev
decl_stmt|;
comment|/* 	 * first lookup the tag; if that works, turn the revision into 	 * a branch and lookup the date. 	 */
name|tagrev
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tagrev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|tagrev
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|tagrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tagrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rev
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tag
condition|)
return|return
operator|(
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|,
name|return_both
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|date
condition|)
return|return
operator|(
name|RCS_getdate
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the revision for a specific tag.  * If force_tag_match is set, return NULL if an exact match is not  * possible otherwise return RCS_head ().  We are careful to look for  * and handle "magic" revisions specially.  *   * If the matched tag is a branch tag, find the head of the branch.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_gettag
parameter_list|(
name|rcs
parameter_list|,
name|symtag
parameter_list|,
name|force_tag_match
parameter_list|,
name|return_both
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|symtag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
name|return_both
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|tag
init|=
name|symtag
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX this is probably not necessary, --jtc */
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If tag is "HEAD", special case to get head RCS revision */
if|if
condition|(
name|tag
operator|&&
operator|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
operator|||
operator|*
name|tag
operator|==
literal|'\0'
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* This #if 0 is only in the Cygnus code.  Why?  Death support?  */
then|if (force_tag_match&& (rcs->flags& VALID)&& (rcs->flags& INATTIC)) 	    return ((char *) NULL);
comment|/* head request for removed file */
then|else
endif|#
directive|endif
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* If we got a symbolic tag, resolve it to a numeric */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|p
operator|=
name|findnode
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|magic
decl_stmt|,
modifier|*
name|branch
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|tag
operator|=
name|p
operator|->
name|data
expr_stmt|;
comment|/* 	     * If this is a magic revision, we turn it into either its 	     * physical branch equivalent (if one exists) or into 	     * its base revision, which we assume exists. 	     */
name|dots
operator|=
name|numdots
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|>
literal|2
operator|&&
operator|(
name|dots
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|branch
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|branch
operator|++
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|xtag
decl_stmt|;
comment|/* it's magic.  See if the branch exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
comment|/* and back again */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|xtag
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|branch
operator|)
return|;
block|}
return|return
operator|(
name|xtag
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The tag wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*      * numeric tag processing:      *		1) revision number - just return it      *		2) branch number   - find head of branch      */
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* we have a branch tag, so we need to walk the branch */
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* we have a revision tag, so make sure it exists */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * we have found a numeric revision for the revision tag. 	     * To support expanding the RCS keyword Name, return both 	     * the numeric tag and the supplied tag (which might be 	     * symbolic).  They are separated with a ':' which is not 	     * a valid tag char.  The variable return_both is only set 	     * if this function is called through Version_TS -> 	     * RCS_getversion. 	     */
if|if
condition|(
name|return_both
condition|)
block|{
name|char
modifier|*
name|both
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|symtag
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|both
argument_list|,
literal|"%s:%s"
argument_list|,
name|tag
argument_list|,
name|symtag
argument_list|)
expr_stmt|;
return|return
name|both
return|;
block|}
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|tag
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* The revision wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return a "magic" revision as a virtual branch off of REV for the RCS file.  * A "magic" revision is one which is unique in the RCS file.  By unique, I  * mean we return a revision which:  *	- has a branch of 0 (see rcs.h RCS_MAGIC_BRANCH)  *	- has a revision component which is not an existing branch off REV  *	- has a revision component which is not an existing magic revision  *	- is an even-numbered revision, to avoid conflicts with vendor branches  * The first point is what makes it "magic".  *  * As an example, if we pass in 1.37 as REV, we will look for an existing  * branch called 1.37.2.  If it did not exist, we would look for an  * existing symbolic tag with a numeric part equal to 1.37.0.2.  If that  * didn't exist, then we know that the 1.37.2 branch can be reserved by  * creating a symbolic tag with 1.37.0.2 as the numeric part.  *  * This allows us to fork development with very little overhead -- just a  * symbolic tag is used in the RCS file.  When a commit is done, a physical  * branch is dynamically created to hold the new revision.  *  * Note: We assume that REV is an RCS revision and not a branch number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_rev
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|RCS_magicrev
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|rev_num
decl_stmt|;
name|char
modifier|*
name|xrev
decl_stmt|,
modifier|*
name|test_branch
decl_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* enough for .0.number */
name|check_rev
operator|=
name|xrev
expr_stmt|;
comment|/* only look at even numbered branches */
for|for
control|(
name|rev_num
operator|=
literal|2
init|;
condition|;
name|rev_num
operator|+=
literal|2
control|)
block|{
comment|/* see if the physical branch exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d"
argument_list|,
name|rev
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
name|test_branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|xrev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_branch
operator|!=
name|NULL
condition|)
comment|/* it did, so keep looking */
block|{
name|free
argument_list|(
name|test_branch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now, create a "magic" revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|rev
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
comment|/* walk the symbols list to see if a magic one already exists */
if|if
condition|(
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|checkmagic_proc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we found a free magic branch.  Claim it as ours */
return|return
operator|(
name|xrev
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc to look for a match in the symbols list.  * Returns 0 if the symbol does not match, 1 if it does.  */
end_comment

begin_function
specifier|static
name|int
name|checkmagic_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|check_rev
argument_list|,
name|p
operator|->
name|data
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number   * or symbolic tag resolves to a "branch" within the rcs file.  *  * FIXME: this is the same as RCS_nodeisbranch except for the special   *        case for handling a null rcsnode.  */
end_comment

begin_function
name|int
name|RCS_isbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
comment|/* assume a revision if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* now, look for a match in the symbols list */
return|return
operator|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number  * or symbolic tag resolves to a "branch" within the rcs file.  We do  * take into account any magic branches as well.  */
end_comment

begin_function
name|int
name|RCS_nodeisbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
name|p
operator|=
name|findnode
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to malloc'ed memory which contains the branch  * for the specified *symbolic* tag.  Magic branches are handled correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_whatbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|dots
decl_stmt|;
comment|/* assume no branch if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* now, look for a match in the symbols list */
name|p
operator|=
name|findnode
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|++
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* yep.  it's magic.  now, construct the real branch */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|p
operator|->
name|data
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
comment|/* and turn it back */
return|return
operator|(
name|magic
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the specified branch.  If the branch does not exist,  * return NULL or RCS_head depending on force_tag_match  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getbranch
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|RCSVers
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|nextvers
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* find out if the tag contains a dot, or is on the trunk */
name|cp
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* trunk processing is the special case */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for an extra . */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|rcs
operator|->
name|head
init|;
name|cp
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|xtag
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xstrdup
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
comment|/* if it had a `.', terminate the string so we have the base revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* look up the revision this branch is based on */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* put the . back so we have the branch again */
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* if the base revision didn't exist, return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* find the first element of the branch we are looking for */
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 for the extra '.' */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|head
operator|=
name|vn
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xtag
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|head
condition|)
block|{
comment|/* we didn't find a match so return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* now walk the next pointers of the branch */
name|nextvers
operator|=
name|p
operator|->
name|key
expr_stmt|;
do|do
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nextvers
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* a link in the chain is missing - return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|nextvers
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|nextvers
operator|!=
name|NULL
condition|)
do|;
comment|/* we have the version in our hand, so go for it */
return|return
operator|(
name|xstrdup
argument_list|(
name|vn
operator|->
name|version
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the RCS file.  If branch is set, this is the head of the  * branch, otherwise the real head  */
end_comment

begin_function
name|char
modifier|*
name|RCS_head
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * NOTE: we call getbranch with force_tag_match set to avoid any      * possibility of recursion      */
if|if
condition|(
name|rcs
operator|->
name|branch
condition|)
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|branch
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the most recent revision, based on the supplied date, but use some  * funky stuff and follow the vendor branch maybe  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getdate
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
init|=
name|NULL
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if the head is on a branch, try the branch first */
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
comment|/* if we found a match, we are done */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* otherwise if we have a trunk, try it */
if|if
condition|(
name|rcs
operator|->
name|head
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* if the date of this one is before date, take it */
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
break|break;
block|}
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * at this point, either we have the revision we want, or we have the      * first revision on the trunk (1.1?) in our hands      */
comment|/* if we found what we're looking for, and it's not 1.1 return it */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cur_rev
argument_list|,
literal|"1.1"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
comment|/* look on the vendor branch */
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
comment|/*      * if we found a match, return it; otherwise, we return the first      * revision on the trunk or NULL depending on force_tag_match and the      * date of the first rev      */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
operator|!
name|force_tag_match
operator|||
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|vers
operator|->
name|version
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the last element on a branch that was put in before the specified  * date (return the rev or NULL)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|xbranch
decl_stmt|,
modifier|*
name|xrev
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* look up the first revision on the branch */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|xrev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* if no branches list, return NULL */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* walk the branches list looking for the branch number */
name|xbranch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for the extra dot */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xbranch
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xbranch
argument_list|,
name|strlen
argument_list|(
name|xbranch
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* walk the next pointers until you find the end, or the date is too late */
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
else|else
break|break;
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* if we found something acceptable, return it - otherwise NULL */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two dates in RCS format. Beware the change in format on January 1,  * 2000, when years go from 2-digit to full format.  */
end_comment

begin_function
name|int
name|RCS_datecmp
parameter_list|(
name|date1
parameter_list|,
name|date2
parameter_list|)
name|char
modifier|*
name|date1
decl_stmt|,
decl|*
name|date2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|date1
argument_list|)
operator|-
name|strlen
argument_list|(
name|date2
argument_list|)
decl_stmt|;
return|return
operator|(
name|length_diff
condition|?
name|length_diff
else|:
name|strcmp
argument_list|(
name|date1
argument_list|,
name|date2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Lookup the specified revision in the ,v file and return, in the date  * argument, the date specified for the revision *minus one second*, so that  * the logically previous revision will be found later.  *   * Returns zero on failure, RCS revision time as a Unix "time_t" on success.  */
end_comment

begin_function
name|time_t
name|RCS_getrevtime
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|date
parameter_list|,
name|fudge
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|fudge
decl_stmt|;
block|{
name|char
name|tdate
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|struct
name|tm
name|xtm
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|revdate
init|=
literal|0
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* look up the revision */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* split up the date */
name|ftm
operator|=
operator|&
name|xtm
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|ftm
operator|->
name|tm_year
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mon
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mday
argument_list|,
operator|&
name|ftm
operator|->
name|tm_hour
argument_list|,
operator|&
name|ftm
operator|->
name|tm_min
argument_list|,
operator|&
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
comment|/* If the year is from 1900 to 1999, RCS files contain only two        digits, and sscanf gives us a year from 0-99.  If the year is        2000+, RCS files contain all four digits and we subtract 1900,        because the tm_year field should contain years since 1900.  */
if|if
condition|(
name|ftm
operator|->
name|tm_year
operator|>
literal|1900
condition|)
name|ftm
operator|->
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* put the date in a form getdate can grok */
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d GMT %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* turn it into seconds since the epoch */
name|revdate
operator|=
name|get_date
argument_list|(
name|tdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|revdate
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|revdate
operator|-=
name|fudge
expr_stmt|;
comment|/* remove "fudge" seconds */
if|if
condition|(
name|date
condition|)
block|{
comment|/* put an appropriate string into ``date'' if we were given one */
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revdate
operator|)
return|;
block|}
end_function

begin_function
name|List
modifier|*
name|RCS_symbols
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|symbols_data
condition|)
block|{
name|rcs
operator|->
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_symbols
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|symbols_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rcs
operator|->
name|symbols
return|;
block|}
end_function

begin_comment
comment|/*  * The argument ARG is the getopt remainder of the -k option specified on the  * command line.  This function returns malloc'ed space that can be used  * directly in calls to RCS V5, with the -k flag munged correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_check_kflag
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|kflags
index|[]
init|=
block|{
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
literal|"b"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|keyword_usage
index|[]
init|=
block|{
literal|"%s %s: invalid RCS keyword expansion mode\n"
block|,
literal|"Valid expansion modes include:\n"
block|,
literal|"   -kkv\tGenerate keywords using the default form.\n"
block|,
literal|"   -kkvl\tLike -kkv, except locker's name inserted.\n"
block|,
literal|"   -kk\tGenerate only keyword names in keyword strings.\n"
block|,
literal|"   -kv\tGenerate only keyword values in keyword strings.\n"
block|,
literal|"   -ko\tGenerate the old keyword string (no changes from checked in file).\n"
block|,
literal|"   -kb\tGenerate binary file unmodified (merges not allowed) (RCS 5.7).\n"
block|,
name|NULL
block|,     }
decl_stmt|;
name|char
name|karg
index|[
literal|10
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|cpp
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s %s: your version of RCS does not support the -k option"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arg
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
operator|*
name|cpp
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|cpp
operator|==
name|NULL
condition|)
block|{
name|usage
argument_list|(
name|keyword_usage
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|karg
argument_list|,
literal|"-k%s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xstrdup
argument_list|(
name|karg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do some consistency checks on the symbolic tag... These should equate  * pretty close to what RCS checks, though I don't know for certain.  */
end_comment

begin_function
name|void
name|RCS_check_tag
parameter_list|(
name|tag
parameter_list|)
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|invalid
init|=
literal|"$,.:;@"
decl_stmt|;
comment|/* invalid RCS tag characters */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/*      * The first character must be an alphabetic letter. The remaining      * characters cannot be non-visible graphic characters, and must not be      * in the set of "invalid" RCS identifier characters.      */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|tag
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' has non-visible graphic characters"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|invalid
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must not contain the characters `%s'"
argument_list|,
name|tag
argument_list|,
name|invalid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must start with a letter"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if RCS revision with TAG is a dead revision.  */
end_comment

begin_function
name|int
name|RCS_isdead
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|version
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
return|return
operator|(
name|version
operator|->
name|dead
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the RCS keyword expansion mode.  For example "b" for binary.    Returns a pointer into storage which is allocated and freed along with    the rest of the RCS information; the caller should not modify this    storage.  Returns NULL if the RCS file does not specify a keyword    expansion mode; for all other errors, die with a fatal error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getexpand
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rcs
operator|->
name|expand
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff related to annotate command.  This should perhaps be split    into the stuff which knows about the guts of RCS files, and the    command parsing type stuff.  */
end_comment

begin_comment
comment|/* Linked list of allocated blocks.  Seems kind of silly to    reinvent the obstack wheel, and this isn't as nice as obstacks    in some ways, but obstacks are pretty baroque.  */
end_comment

begin_struct
struct|struct
name|allocblock
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|struct
name|allocblock
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|allocblock
modifier|*
name|blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|block_alloc
name|PROTO
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|block_alloc
parameter_list|(
name|n
parameter_list|)
name|size_t
name|n
decl_stmt|;
block|{
name|struct
name|allocblock
modifier|*
name|blk
decl_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|allocblock
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|allocblock
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|->
name|text
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|=
name|blk
expr_stmt|;
return|return
name|blk
operator|->
name|text
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|block_free
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|block_free
parameter_list|()
block|{
name|struct
name|allocblock
modifier|*
name|p
decl_stmt|;
name|struct
name|allocblock
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|blocks
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|line
block|{
comment|/* Text of this line, terminated by \n or \0.  */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Version in which it was introduced.  */
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* Nonzero if this line ends with \n.  This will always be true        except possibly for the last line.  */
name|int
name|has_newline
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linevector
block|{
comment|/* How many lines in use for this linevector?  */
name|unsigned
name|int
name|nlines
decl_stmt|;
comment|/* How many lines allocated for this linevector?  */
name|unsigned
name|int
name|lines_alloced
decl_stmt|;
comment|/* Pointer to array containing a pointer to each line.  */
name|struct
name|line
modifier|*
modifier|*
name|vector
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|linevector_init
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize *VEC to be a linevector with no lines.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_init
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
name|vec
operator|->
name|lines_alloced
operator|=
literal|10
expr_stmt|;
name|vec
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
operator|(
expr|struct
name|line
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|vec
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_add
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
name|vec
operator|,
name|char
operator|*
name|text
operator|,
name|RCSVers
operator|*
name|vers
operator|,
name|unsigned
name|int
name|pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given some text TEXT, add each of its lines to VEC before line POS    (where line 0 is the first line).  The last line in TEXT may or may    not be \n terminated.  All \n in TEXT are changed to \0.  Set the    version for each of the new lines to VERS.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_add
parameter_list|(
name|vec
parameter_list|,
name|text
parameter_list|,
name|vers
parameter_list|,
name|pos
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nnew
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|line
modifier|*
name|lines
decl_stmt|;
name|assert
argument_list|(
name|vec
operator|->
name|lines_alloced
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Count the number of lines we will need to add.  */
name|nnew
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|nnew
expr_stmt|;
comment|/* Allocate the struct line's.  */
name|lines
operator|=
name|block_alloc
argument_list|(
name|nnew
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand VEC->VECTOR if needed.  */
if|if
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
block|{
while|while
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
name|vec
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
name|xrealloc
argument_list|(
name|vec
operator|->
name|vector
argument_list|,
name|vec
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for the new lines in VEC->VECTOR.  */
for|for
control|(
name|i
operator|=
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|-
literal|1
init|;
name|i
operator|>=
name|pos
operator|+
name|nnew
condition|;
operator|--
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|-
name|nnew
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|vec
operator|->
name|nlines
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid rcs file: line to add out of range"
argument_list|)
expr_stmt|;
comment|/* Actually add the lines, to LINES and VEC->VECTOR.  */
name|i
operator|=
name|pos
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|has_newline
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
operator|++
index|]
operator|=
operator|&
name|lines
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|has_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* If there are no characters beyond the last newline, we 		   don't consider it another line.  */
break|break;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|text
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|has_newline
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
operator|&
name|lines
index|[
name|i
operator|-
name|pos
index|]
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|vec
operator|->
name|nlines
operator|+=
name|nnew
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_delete
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove NLINES lines from VEC at position POS (where line 0 is the    first line).  */
end_comment

begin_function
specifier|static
name|void
name|linevector_delete
parameter_list|(
name|vec
parameter_list|,
name|pos
parameter_list|,
name|nlines
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|unsigned
name|int
name|nlines
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|last
operator|=
name|vec
operator|->
name|nlines
operator|-
name|nlines
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pos
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|+
name|nlines
index|]
expr_stmt|;
name|vec
operator|->
name|nlines
operator|-=
name|nlines
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_copy
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy FROM to TO, copying the vectors but not the lines pointed to.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_copy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|linevector
modifier|*
name|to
decl_stmt|;
name|struct
name|linevector
modifier|*
name|from
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
block|{
while|while
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
name|to
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|to
operator|->
name|vector
operator|=
operator|(
expr|struct
name|line
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|to
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|from
operator|->
name|vector
argument_list|,
name|from
operator|->
name|nlines
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|nlines
operator|=
name|from
operator|->
name|nlines
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_free
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free storage associated with linevector (that is, the vector but    not the lines pointed to).  */
end_comment

begin_function
specifier|static
name|void
name|linevector_free
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
name|free
argument_list|(
name|vec
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|month_printname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a textual string giving the month (1-12), terminated with any    character not recognized by atoi, return the 3 character name to    print it with.  I do not think it is a good idea to change these    strings based on the locale; they are standard abbreviations (for    example in rfc822 mail messages) which should be widely understood.    Returns a pointer into static readonly storage.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|month_printname
parameter_list|(
name|month
parameter_list|)
name|char
modifier|*
name|month
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|int
name|mnum
decl_stmt|;
name|mnum
operator|=
name|atoi
argument_list|(
name|month
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnum
operator|<
literal|1
operator|||
name|mnum
operator|>
literal|12
condition|)
return|return
literal|"???"
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|months
index|[
name|mnum
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|annotate_fileproc
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|annotate_fileproc
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|RCSVers
modifier|*
name|prev_vers
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|ishead
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|struct
name|linevector
name|headlines
decl_stmt|;
name|struct
name|linevector
name|curlines
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Distinguish output for various files if we are processing        several files.  */
name|cvs_outerr
argument_list|(
literal|"Annotations for "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n***************\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|finfo
operator|->
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
operator|)
condition|)
comment|/* We are leaking memory by calling RCS_reparsefile again.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal warning: non-partial rcs in annotate_fileproc"
argument_list|)
expr_stmt|;
name|RCS_reparsercsfile
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
name|ishead
operator|=
literal|1
expr_stmt|;
name|vers
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|getrcsrev
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* Stash the previous version.  */
name|prev_vers
operator|=
name|vers
expr_stmt|;
comment|/* look up the revision */
name|node
operator|=
name|findnode
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|versions
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ishead
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|block_alloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_add
argument_list|(
operator|&
name|headlines
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|linevector_copy
argument_list|(
operator|&
name|curlines
argument_list|,
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|ishead
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|op
decl_stmt|;
comment|/* The RCS format throws us for a loop in that the 		       deltafrags (if we define a deltafrag as an 		       add or a delete) need to be applied in reverse 		       order.  So we stick them into a linked list.  */
struct|struct
name|deltafrag
block|{
enum|enum
block|{
name|ADD
block|,
name|DELETE
block|}
name|type
enum|;
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|nlines
decl_stmt|;
name|char
modifier|*
name|new_lines
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|deltafrag
modifier|*
name|dfhead
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|df
decl_stmt|;
name|dfhead
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|value
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|op
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|'a'
operator|&&
name|op
operator|!=
literal|'d'
condition|)
comment|/* Can't just skip over the deltafrag, because 			       the value of op determines the syntax.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized operation '%c' in %s"
argument_list|,
name|op
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|df
operator|=
operator|(
expr|struct
name|deltafrag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deltafrag
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|next
operator|=
name|dfhead
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
name|df
operator|->
name|pos
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"space expected in %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|df
operator|->
name|nlines
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\012'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed expected in %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'a'
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|df
operator|->
name|type
operator|=
name|ADD
expr_stmt|;
name|i
operator|=
name|df
operator|->
name|nlines
expr_stmt|;
comment|/* The text we want is the number of lines 			       specified, or until the end of the value, 			       whichever comes first (it will be the former 			       except in the case where we are adding a line 			       which does not end in newline).  */
for|for
control|(
name|q
operator|=
name|p
init|;
name|i
operator|!=
literal|0
condition|;
operator|++
name|q
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'\n'
condition|)
operator|--
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ invalid rcs file %s: premature end of value"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Copy the text we are adding into allocated 			       space.  */
name|df
operator|->
name|new_lines
operator|=
name|block_alloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|df
operator|->
name|new_lines
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|df
operator|->
name|new_lines
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
comment|/* Correct for the fact that line numbers in RCS 			       files start with 1.  */
operator|--
name|df
operator|->
name|pos
expr_stmt|;
name|assert
argument_list|(
name|op
operator|==
literal|'d'
argument_list|)
expr_stmt|;
name|df
operator|->
name|type
operator|=
name|DELETE
expr_stmt|;
block|}
block|}
for|for
control|(
name|df
operator|=
name|dfhead
init|;
name|df
operator|!=
name|NULL
condition|;
control|)
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
switch|switch
condition|(
name|df
operator|->
name|type
condition|)
block|{
case|case
name|ADD
case|:
name|linevector_add
argument_list|(
operator|&
name|curlines
argument_list|,
name|df
operator|->
name|new_lines
argument_list|,
name|NULL
argument_list|,
name|df
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
if|if
condition|(
name|df
operator|->
name|pos
operator|>
name|curlines
operator|.
name|nlines
operator|||
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
operator|>
name|curlines
operator|.
name|nlines
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ invalid rcs file %s (`d' operand out of range)"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|ln
operator|=
name|df
operator|->
name|pos
init|;
name|ln
operator|<
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
name|curlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
operator|=
name|prev_vers
expr_stmt|;
name|linevector_delete
argument_list|(
operator|&
name|curlines
argument_list|,
name|df
operator|->
name|pos
argument_list|,
name|df
operator|->
name|nlines
argument_list|)
expr_stmt|;
break|break;
block|}
name|df
operator|=
name|df
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dfhead
argument_list|)
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|l_error
goto|;
block|}
do|while
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Now print out the data we have just computed.  */
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* Period which separates year from month in date.  */
name|char
modifier|*
name|ym
decl_stmt|;
comment|/* Period which separates month from day in date.  */
name|char
modifier|*
name|md
decl_stmt|;
name|RCSVers
modifier|*
name|prvers
decl_stmt|;
name|prvers
operator|=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
expr_stmt|;
if|if
condition|(
name|prvers
operator|==
name|NULL
condition|)
name|prvers
operator|=
name|vers
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-12s (%-8.8s "
argument_list|,
name|prvers
operator|->
name|version
argument_list|,
name|prvers
operator|->
name|author
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now output the date.  */
name|ym
operator|=
name|strchr
argument_list|(
name|prvers
operator|->
name|date
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ym
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"??-???-??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|md
operator|=
name|strchr
argument_list|(
name|ym
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cvs_output
argument_list|(
name|md
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|month_printname
argument_list|(
name|ym
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Only output the last two digits of the year.  Our output 		   lines are long enough as it is without printing the 		   century.  */
name|cvs_output
argument_list|(
name|ym
operator|-
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"): "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ishead
condition|)
block|{
name|linevector_free
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_free
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
block|}
name|block_free
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
name|l_error
label|:
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s does not appear to be a valid rcs file"
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Shut up gcc -Wall.  */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|annotate_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-l] [files...]\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command to show the revision, date, and author where each line of a    file was modified.  Currently it will only show the trunk, all the    way to the head, but it would be useful to enhance it to (a) allow    one to specify a revision, and display only as far as that (easy;    just have annotate_fileproc set all the ->vers fields to NULL when    you hit that revision), and (b) handle branches (not as easy, but    doable).  The user interface for both (a) and (b) could be a -r    option.  */
end_comment

begin_function
name|int
name|annotate
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+l"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
comment|/* FIXME:  We shouldn't have to send current files, but I'm not sure 	   whether it works.  So send the files -- 	   it's slower but it works.  */
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"annotate\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
return|return
name|start_recursion
argument_list|(
name|annotate_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

