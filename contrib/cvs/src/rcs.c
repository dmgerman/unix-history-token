begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * The routines contained in this file do all the rcs file parsing and  * manipulation  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_comment
comment|/* The RCS -k options, and a set of enums that must match the array.    These come first so that we can use enum kflag in function    prototypes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|kflags
index|[]
init|=
block|{
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
literal|"b"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|kflag
block|{
name|KFLAG_KV
init|=
literal|0
block|,
name|KFLAG_KVL
block|,
name|KFLAG_K
block|,
name|KFLAG_V
block|,
name|KFLAG_O
block|,
name|KFLAG_B
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
specifier|const
name|char
operator|*
name|rcsfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|RCS_reparsercsfile
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|date
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getrcskey
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
name|char
operator|*
operator|*
name|keyp
operator|,
name|char
operator|*
operator|*
name|valp
operator|,
name|size_t
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getrcsrev
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
name|char
operator|*
operator|*
name|revp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkmagic_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_branches
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_symbols
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|char
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_rcsnode_contents
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcsvers_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|translate_symtag
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printable_date
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|escape_keyword_value
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_keywords
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|RCSVers
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
expr|enum
name|kflag
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cmp_file_buffer
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|rcs_delta_op
block|{
name|RCS_ANNOTATE
block|,
name|RCS_FETCH
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|RCS_deltas
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|rcs_delta_op
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getfullCVSname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We don't want to use isspace() from the C library because:  *  * 1. The definition of "whitespace" in RCS files includes ASCII  *    backspace, but the C locale doesn't.  * 2. isspace is an very expensive function call in some implementations  *    due to the addition of wide character support.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|spacetab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 - 0x0f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x10 - 0x1f */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x20 - 0x2f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x30 - 0x3f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x40 - 0x4f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x50 - 0x5f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x60 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x70 - 0x7f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x80 - 0x8f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x90 - 0x9f */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xa0 - 0xaf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xb0 - 0xbf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xc0 - 0xcf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xd0 - 0xdf */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0xe0 - 0xef */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* 0xf0 - 0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(spacetab[(unsigned char)c] != 0)
end_define

begin_comment
comment|/* Parse an rcsfile given a user file name and a repository.  If there is    an error, we print an error message and return NULL.  If the file    does not exist, we return NULL without printing anything (I'm not    sure this allows the caller to do anything reasonable, but it is    the current behavior).  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parse
parameter_list|(
name|file
parameter_list|,
name|repos
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCSNode
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|rcsfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FILENAMES_CASE_INSENSITIVE
argument_list|)
elseif|else
if|if
condition|(
name|ign_case
condition|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|found_path
decl_stmt|;
comment|/* The client might be asking for a file which we do have 	   (which the client doesn't know about), but for which the 	   filename case differs.  We only consider this case if the 	   regular CVS_FOPENs fail, because fopen_case is such an 	   expensive call.  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|status
operator|=
name|fopen_case
argument_list|(
name|rcsfile
argument_list|,
literal|"rb"
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|found_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|path
operator|=
name|found_path
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcsfile
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repos
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|status
operator|=
name|fopen_case
argument_list|(
name|rcsfile
argument_list|,
literal|"rb"
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|found_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcs
operator|->
name|flags
operator||=
name|INATTIC
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|VALID
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|path
operator|=
name|found_path
expr_stmt|;
name|retval
operator|=
name|rcs
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"cannot open %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
name|retval
operator|=
name|NULL
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a specific rcsfile.  */
end_comment

begin_function
name|RCSNode
modifier|*
name|RCS_parsercsfile
parameter_list|(
name|rcsfile
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
comment|/* open the rcsfile */
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcs file `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rcs
operator|=
name|RCS_parsercsfile_i
argument_list|(
name|fp
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|RCSNode
modifier|*
name|RCS_parsercsfile_i
parameter_list|(
name|fp
parameter_list|,
name|rcsfile
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
comment|/* make a node */
name|rdata
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSNode
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* Process HEAD and BRANCH keywords from the RCS header.        *      * Most cvs operatations on the main branch don't need any more      * information.  Those that do call XXX to completely parse the      * RCS file.  */
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|RCSHEAD
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|RCSBRANCH
argument_list|,
name|key
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|rdata
operator|->
name|branch
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|rdata
operator|->
name|branch
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* turn it into a branch if it's a revision */
name|cp
operator|=
name|strrchr
argument_list|(
name|rdata
operator|->
name|branch
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|rdata
operator|->
name|flags
operator||=
name|PARTIAL
expr_stmt|;
return|return
name|rdata
return|;
name|l_error
label|:
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
block|}
name|freercsnode
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the real work of parsing an RCS file.     On error, die with a fatal error; if it returns at all it was successful.     If ALL is nonzero, remember all keywords and values.  Otherwise    only keep the ones we will need.     If PFP is NULL, close the file when done.  Otherwise, leave it open    and store the FILE * in *PFP.  */
end_comment

begin_function
specifier|static
name|void
name|RCS_reparsercsfile
parameter_list|(
name|rdata
parameter_list|,
name|all
parameter_list|,
name|pfp
parameter_list|)
name|RCSNode
modifier|*
name|rdata
decl_stmt|;
name|int
name|all
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|pfp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|assert
argument_list|(
name|rdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rcsfile
operator|=
name|rdata
operator|->
name|path
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcsfile
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unable to reopen `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* make a node */
name|rdata
operator|->
name|versions
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * process all the special header information, break out when we get to      * the first revision delta      */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get the next key/value pair */
comment|/* if key is NULL here, then the file is missing some headers 	   or we had trouble reading the file. */
if|if
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading `%s'"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"`%s' does not appear to be a valid rcs file"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSSYMBOLS
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|rdata
operator|->
name|symbols_data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|RCSEXPAND
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rdata
operator|->
name|expand
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * check key for '.''s and digits (probably a rev) if it is a 	 * revision, we are done with the headers and are down to the 	 * revision deltas, so we break out of the loop 	 */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* We always save lock information, so that we can handle            -kkvl correctly when checking out a file.  We don't use a            special field for this information, since it will normally            not be set for a CVS file.  */
if|if
condition|(
name|all
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"locks"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Node
modifier|*
name|kv
decl_stmt|;
if|if
condition|(
name|rdata
operator|->
name|other
operator|==
name|NULL
condition|)
name|rdata
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: duplicate key `%s' in RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we haven't grabbed it yet, we didn't want it */
block|}
comment|/*      * we got out of the loop, so we have the first part of the first      * revision delta in our hand key=the revision and value=the date key and      * its value      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|valp
decl_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vnode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RCSVers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the version before we forget it */
name|vnode
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* grab the value of the date from value */
name|valp
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
expr_stmt|;
comment|/* skip the "date" keyword */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|valp
argument_list|)
condition|)
comment|/* take space off front of value */
name|valp
operator|++
expr_stmt|;
name|vnode
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|valp
argument_list|)
expr_stmt|;
comment|/* Get author field.  */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: should be using errno in case of ferror.  */
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"author"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse rcs file; `author' not in the expected place"
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|author
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Get state field.  */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: should be using errno in case of ferror.  */
if|if
condition|(
name|key
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"state"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ unable to parse rcs file; `state' not in the expected place"
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"dead"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
block|}
comment|/* fill in the branch list (if any branches exist) */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: should be handling various error conditions better.  */
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|vnode
operator|->
name|branches
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_branches
argument_list|(
name|vnode
operator|->
name|branches
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the next field if there is a next revision */
operator|(
name|void
operator|)
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME: should be handling various error conditions better.  */
if|if
condition|(
name|key
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|vnode
operator|->
name|next
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * at this point, we skip any user defined fields XXX - this is where 	 * we put the symbolic link stuff??? 	 */
comment|/* FIXME: Does not correctly handle errors, e.g. from stdio.  */
while|while
condition|(
operator|(
name|n
operator|=
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Enable use of repositories created by certain obsolete 	       versions of CVS.  This code should remain indefinately; 	       there is no procedure for converting old repositories, and 	       checking for it is harmless.  */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDEAD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode
operator|->
name|dead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|state
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vnode
operator|->
name|state
argument_list|)
expr_stmt|;
name|vnode
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
literal|"dead"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if we have a revision, break and do it */
for|for
control|(
name|cp
operator|=
name|key
init|;
operator|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|&&
name|strncmp
argument_list|(
name|RCSDATE
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|RCSDATE
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|all
condition|)
block|{
name|Node
modifier|*
name|kv
decl_stmt|;
if|if
condition|(
name|vnode
operator|->
name|other
operator|==
name|NULL
condition|)
name|vnode
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* get the node */
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|RCSVERS
expr_stmt|;
name|q
operator|->
name|delproc
operator|=
name|rcsvers_delproc
expr_stmt|;
name|q
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|vnode
expr_stmt|;
name|q
operator|->
name|key
operator|=
name|vnode
operator|->
name|version
expr_stmt|;
comment|/* add the nodes to the list */
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|versions
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|purify_printf("WARNING: Adding duplicate version: %s (%s)\n", 			 q->key, rcsfile); 		freenode (q);
endif|#
directive|endif
block|}
comment|/* 	 * if we left the loop because there were no more keys, we break out 	 * of the revision processing loop 	 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|all
operator|&&
name|key
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Node
modifier|*
name|kv
decl_stmt|;
if|if
condition|(
name|rdata
operator|->
name|other
operator|==
name|NULL
condition|)
name|rdata
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|rdata
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: duplicate key `%s' in RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
name|rdata
operator|->
name|delta_pos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|flags
operator|&=
operator|~
name|NODELTA
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pfp
operator|=
name|fp
expr_stmt|;
block|}
name|rdata
operator|->
name|flags
operator|&=
operator|~
name|PARTIAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fully parse the RCS file.  Store all keyword/value pairs, fetch the  * log messages for each revision, and fetch add and delete counts for  * each revision (we could fetch the entire text for each revision,  * but the only caller, log_fileproc, doesn't need that information,  * so we don't waste the memory required to store it).  The add and  * delete counts are stored on the OTHER field of the RCSVERSNODE  * structure, under the names ";add" and ";delete", so that we don't  * waste the memory space of extra fields in RCSVERSNODE for code  * which doesn't need this information.  */
end_comment

begin_function
name|void
name|RCS_fully_parse
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|1
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|size_t
name|vallen
decl_stmt|;
name|Node
modifier|*
name|vers
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
comment|/* Rather than try to keep track of how much information we            have read, just read to the end of the file.  */
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"ungetc failed"
argument_list|)
expr_stmt|;
name|getrcsrev
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|vers
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|vers
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|vallen
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Node
modifier|*
name|kv
decl_stmt|;
if|if
condition|(
name|vnode
operator|->
name|other
operator|==
name|NULL
condition|)
name|vnode
operator|->
name|other
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|long
name|add
decl_stmt|,
name|del
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|Node
modifier|*
name|kv
decl_stmt|;
comment|/* This is a change text.  Store the add and delete                    counts.  */
name|add
operator|=
literal|0
expr_stmt|;
name|del
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|value
operator|+
name|vallen
condition|)
block|{
name|char
name|op
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
name|op
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|'a'
operator|&&
name|op
operator|!=
literal|'d'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized operation '%c' in %s"
argument_list|,
name|op
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|' '
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"space expected in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|count
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\012'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed expected in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'d'
condition|)
name|del
operator|+=
name|count
expr_stmt|;
else|else
block|{
name|add
operator|+=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\012'
condition|)
operator|--
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
name|value
operator|+
name|vallen
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ invalid rcs file %s: premature end of value"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
operator|++
name|cp
expr_stmt|;
block|}
block|}
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|";add"
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|del
argument_list|)
expr_stmt|;
name|kv
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|kv
operator|->
name|type
operator|=
name|RCSFIELD
expr_stmt|;
name|kv
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|";delete"
argument_list|)
expr_stmt|;
name|kv
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|vnode
operator|->
name|other
argument_list|,
name|kv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: duplicate key `%s' in version `%s' of RCS file `%s'"
argument_list|,
name|key
argument_list|,
name|vnode
operator|->
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|kv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We have found the "text" key which ends the data for                this revision.  Break out of the loop and go on to the                next revision.  */
break|break;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * freercsnode - free up the info for an RCSNode  */
end_comment

begin_function
name|void
name|freercsnode
parameter_list|(
name|rnodep
parameter_list|)
name|RCSNode
modifier|*
modifier|*
name|rnodep
decl_stmt|;
block|{
if|if
condition|(
name|rnodep
operator|==
name|NULL
operator|||
operator|*
name|rnodep
operator|==
name|NULL
condition|)
return|return;
operator|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
operator|(
operator|*
name|rnodep
operator|)
operator|->
name|branch
argument_list|)
expr_stmt|;
name|free_rcsnode_contents
argument_list|(
operator|*
name|rnodep
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|rnodep
argument_list|)
expr_stmt|;
operator|*
name|rnodep
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free_rcsnode_contents - free up the contents of an RCSNode without  * freeing the node itself, or the file name, or the head, or the  * path.  This returns the RCSNode to the state it is in immediately  * after a call to RCS_parse.  */
end_comment

begin_function
specifier|static
name|void
name|free_rcsnode_contents
parameter_list|(
name|rnode
parameter_list|)
name|RCSNode
modifier|*
name|rnode
decl_stmt|;
block|{
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|versions
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|symbols
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|symbols_data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|expand
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|expand
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|other
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|other
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rcsvers_delproc - free up an RCSVers type node  */
end_comment

begin_function
specifier|static
name|void
name|rcsvers_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|RCSVers
modifier|*
name|rnode
decl_stmt|;
name|rnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|branches
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|branches
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|date
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|next
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|author
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|state
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|rnode
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnode
operator|->
name|other
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rnode
operator|->
name|other
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * getrcskey - fill in the key and value from the rcs file the algorithm is  *             as follows   *  *    o skip whitespace o fill in key with everything up to next white   *      space or semicolon   *    o if key == "desc" then key and data are NULL and return -1   *    o if key wasn't terminated by a semicolon, skip white space and fill   *      in value with everything up to a semicolon   *    o compress all whitespace down to a single space   *    o if a word starts with @, do funky rcs processing  *    o strip whitespace off end of value or set value to NULL if it empty   *    o return 0 since we found something besides "desc"  *  * Sets *KEYP and *VALUEP to point to storage managed by the getrcskey  * function; the contents are only valid until the next call to  * getrcskey or getrcsrev.  If LENP is not NULL, this sets *LENP to  * the length of *VALUEP; this is needed if the string might contain  * binary data.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|keysize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|valsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|getrcskey
parameter_list|(
name|fp
parameter_list|,
name|keyp
parameter_list|,
name|valp
parameter_list|,
name|lenp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|keyp
decl_stmt|;
name|char
modifier|*
modifier|*
name|valp
decl_stmt|;
name|size_t
modifier|*
name|lenp
decl_stmt|;
block|{
name|char
modifier|*
name|cur
decl_stmt|,
modifier|*
name|max
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|just_string
decl_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
comment|/* skip leading whitespace */
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
comment|/* fill in key */
name|cur
operator|=
name|key
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|key
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|keysize
argument_list|,
name|keysize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|key
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|keysize
argument_list|,
name|keysize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip whitespace between key and val */
while|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* if we ended key with a semicolon, there is no value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* otherwise, there might be a value, so fill it in */
name|cur
operator|=
name|value
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
name|just_string
operator|=
operator|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|RCSDESC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* process the value */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* handle RCS "strings" */
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'@'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'@'
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|value
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|valsize
argument_list|,
name|valsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* The syntax for some key-value pairs is different; they 	   don't end with a semicolon.  */
if|if
condition|(
name|just_string
condition|)
break|break;
comment|/* compress whitespace down to a single space */
if|if
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|value
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|valsize
argument_list|,
name|valsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* if we got a semi-colon we are done with the entire value */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
break|break;
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|value
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|valsize
argument_list|,
name|valsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|keyp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* terminate the string */
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|value
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|valsize
argument_list|,
name|valsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|value
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|value
operator|+
name|valsize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
comment|/* if the string is empty, make it null */
if|if
condition|(
name|value
operator|&&
name|cur
operator|!=
name|value
condition|)
block|{
operator|*
name|valp
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|cur
operator|-
name|value
expr_stmt|;
block|}
else|else
operator|*
name|valp
operator|=
name|NULL
expr_stmt|;
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read an RCS revision number from FP.  Put a pointer to it in *REVP;    it points to space managed by getrcsrev which is only good until    the next call to getrcskey or getrcsrev.  */
end_comment

begin_function
specifier|static
name|void
name|getrcsrev
parameter_list|(
name|fp
parameter_list|,
name|revp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|revp
decl_stmt|;
block|{
name|char
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|max
decl_stmt|;
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* FIXME: should be including filename in error message.  */
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcs file"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading rcs file"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|whitespace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
comment|/* FIXME: should be including filename in error message.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"error reading rcs file; revision number expected"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|key
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|keysize
argument_list|,
name|keysize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* FIXME: should be including filename in error message.  */
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcs file"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file reading rcs file"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur
operator|>=
name|max
condition|)
block|{
name|size_t
name|curoff
init|=
name|cur
operator|-
name|key
decl_stmt|;
name|expand_string
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|keysize
argument_list|,
name|keysize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|=
name|key
operator|+
name|curoff
expr_stmt|;
name|max
operator|=
name|key
operator|+
name|keysize
expr_stmt|;
block|}
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|revp
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process the symbols list of the rcs file  */
end_comment

begin_function
specifier|static
name|void
name|do_symbols
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* split it up into tag and rev */
name|tag
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the branches list of a revision delta  */
end_comment

begin_function
specifier|static
name|void
name|do_branches
parameter_list|(
name|list
parameter_list|,
name|val
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|val
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* skip leading whitespace */
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* if we got to the end, we are done */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* find the end of this branch */
name|branch
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make a new node and add it to the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Version Number  *   * Returns the requested version number of the RCS file, satisfying tags and/or  * dates, and walking branches, if necessary.  *   * The result is returned; null-string if error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getversion
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|,
name|simple_tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
modifier|*
name|simple_tag
decl_stmt|;
block|{
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|date
condition|)
block|{
name|char
modifier|*
name|branch
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
if|if
condition|(
operator|!
name|RCS_isbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* We can't get a particular date if the tag is not a                branch.  */
return|return
name|NULL
return|;
block|}
comment|/* Work out the branch.  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|branch
operator|=
name|RCS_whatbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|branch
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* Fetch the revision of branch as of date.  */
name|rev
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
name|rev
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tag
condition|)
return|return
operator|(
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|,
name|simple_tag
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|date
condition|)
return|return
operator|(
name|RCS_getdate
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the revision for a specific tag.  * If force_tag_match is set, return NULL if an exact match is not  * possible otherwise return RCS_head ().  We are careful to look for  * and handle "magic" revisions specially.  *   * If the matched tag is a branch tag, find the head of the branch.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_gettag
parameter_list|(
name|rcs
parameter_list|,
name|symtag
parameter_list|,
name|force_tag_match
parameter_list|,
name|simple_tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|symtag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
modifier|*
name|simple_tag
decl_stmt|;
block|{
name|char
modifier|*
name|tag
init|=
name|symtag
decl_stmt|;
name|int
name|tag_allocated
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX this is probably not necessary, --jtc */
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If tag is "HEAD", special case to get head RCS revision */
if|if
condition|(
name|tag
operator|&&
operator|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
operator|||
operator|*
name|tag
operator|==
literal|'\0'
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* This #if 0 is only in the Cygnus code.  Why?  Death support?  */
then|if (force_tag_match&& (rcs->flags& VALID)&& (rcs->flags& INATTIC)) 	    return ((char *) NULL);
comment|/* head request for removed file */
then|else
endif|#
directive|endif
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|version
decl_stmt|;
comment|/* If we got a symbolic tag, resolve it to a numeric */
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|magic
decl_stmt|,
modifier|*
name|branch
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|tag
operator|=
name|version
expr_stmt|;
name|tag_allocated
operator|=
literal|1
expr_stmt|;
comment|/* 	     * If this is a magic revision, we turn it into either its 	     * physical branch equivalent (if one exists) or into 	     * its base revision, which we assume exists. 	     */
name|dots
operator|=
name|numdots
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dots
operator|>
literal|2
operator|&&
operator|(
name|dots
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|branch
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|branch
operator|++
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's magic.  See if the branch exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|tag
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|magic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|branch
operator|)
return|;
block|}
return|return
operator|(
name|tag
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The tag wasn't there, so return the head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
comment|/*      * numeric tag processing:      *		1) revision number - just return it      *		2) branch number   - find head of branch      */
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|branch
decl_stmt|;
comment|/* we have a branch tag, so we need to walk the branch */
name|branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|force_tag_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_allocated
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
name|branch
return|;
block|}
else|else
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* we have a revision tag, so make sure it exists */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* We have found a numeric revision for the revision tag. 	       To support expanding the RCS keyword Name, if 	       SIMPLE_TAG is not NULL, tell the the caller that this 	       is a simple tag which co will recognize.  FIXME: Are 	       there other cases in which we should set this?  In 	       particular, what if we expand RCS keywords internally 	       without calling co?  */
if|if
condition|(
name|simple_tag
operator|!=
name|NULL
condition|)
operator|*
name|simple_tag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tag_allocated
condition|)
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
else|else
block|{
comment|/* The revision wasn't there, so return the head or NULL */
if|if
condition|(
name|tag_allocated
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return a "magic" revision as a virtual branch off of REV for the RCS file.  * A "magic" revision is one which is unique in the RCS file.  By unique, I  * mean we return a revision which:  *	- has a branch of 0 (see rcs.h RCS_MAGIC_BRANCH)  *	- has a revision component which is not an existing branch off REV  *	- has a revision component which is not an existing magic revision  *	- is an even-numbered revision, to avoid conflicts with vendor branches  * The first point is what makes it "magic".  *  * As an example, if we pass in 1.37 as REV, we will look for an existing  * branch called 1.37.2.  If it did not exist, we would look for an  * existing symbolic tag with a numeric part equal to 1.37.0.2.  If that  * didn't exist, then we know that the 1.37.2 branch can be reserved by  * creating a symbolic tag with 1.37.0.2 as the numeric part.  *  * This allows us to fork development with very little overhead -- just a  * symbolic tag is used in the RCS file.  When a commit is done, a physical  * branch is dynamically created to hold the new revision.  *  * Note: We assume that REV is an RCS revision and not a branch number.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_rev
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|RCS_magicrev
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|rev_num
decl_stmt|;
name|char
modifier|*
name|xrev
decl_stmt|,
modifier|*
name|test_branch
decl_stmt|,
modifier|*
name|local_branch_num
decl_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rev
argument_list|)
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* enough for .0.number */
name|check_rev
operator|=
name|xrev
expr_stmt|;
name|local_branch_num
operator|=
name|getenv
argument_list|(
literal|"CVS_LOCAL_BRANCH_NUM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_branch_num
condition|)
block|{
name|rev_num
operator|=
name|atoi
argument_list|(
name|local_branch_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev_num
operator|<
literal|2
condition|)
name|rev_num
operator|=
literal|2
expr_stmt|;
else|else
name|rev_num
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
else|else
name|rev_num
operator|=
literal|2
expr_stmt|;
comment|/* only look at even numbered branches */
for|for
control|(
init|;
condition|;
name|rev_num
operator|+=
literal|2
control|)
block|{
comment|/* see if the physical branch exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d"
argument_list|,
name|rev
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
name|test_branch
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|xrev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_branch
operator|!=
name|NULL
condition|)
comment|/* it did, so keep looking */
block|{
name|free
argument_list|(
name|test_branch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now, create a "magic" revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|rev
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|,
name|rev_num
argument_list|)
expr_stmt|;
comment|/* walk the symbols list to see if a magic one already exists */
if|if
condition|(
name|walklist
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|checkmagic_proc
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we found a free magic branch.  Claim it as ours */
return|return
operator|(
name|xrev
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc to look for a match in the symbols list.  * Returns 0 if the symbol does not match, 1 if it does.  */
end_comment

begin_function
specifier|static
name|int
name|checkmagic_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|check_rev
argument_list|,
name|p
operator|->
name|data
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number   * or symbolic tag resolves to a "branch" within the rcs file.  *  * FIXME: this is the same as RCS_nodeisbranch except for the special   *        case for handling a null rcsnode.  */
end_comment

begin_function
name|int
name|RCS_isbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
comment|/* assume a revision if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* now, look for a match in the symbols list */
return|return
operator|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an RCSNode, returns non-zero if the specified revision number  * or symbolic tag resolves to a "branch" within the rcs file.  We do  * take into account any magic branches as well.  */
end_comment

begin_function
name|int
name|RCS_nodeisbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|dots
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
comment|/* numeric revisions are easy -- even number of dots is a branch */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
condition|)
return|return
operator|(
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
return|;
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|version
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to malloc'ed memory which contains the branch  * for the specified *symbolic* tag.  Magic branches are handled correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_whatbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|dots
decl_stmt|;
comment|/* assume no branch if you can't find the RCS info */
if|if
condition|(
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* now, look for a match in the symbols list */
name|version
operator|=
name|translate_symtag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|dots
operator|=
name|numdots
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dots
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|version
operator|)
return|;
comment|/* got a symbolic tag match, but it's not a branch; see if it's magic */
if|if
condition|(
name|dots
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|magic
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|strrchr
argument_list|(
name|version
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|branch
operator|++
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
comment|/* see if we have .magic-branch. (".0.") */
name|magic
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|".%d."
argument_list|,
name|RCS_MAGIC_BRANCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* yep.  it's magic.  now, construct the real branch */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|magic
argument_list|,
literal|"%s.%s"
argument_list|,
name|version
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
name|magic
operator|)
return|;
block|}
name|free
argument_list|(
name|magic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the specified branch.  If the branch does not exist,  * return NULL or RCS_head depending on force_tag_match  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getbranch
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|RCSVers
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|nextvers
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* find out if the tag contains a dot, or is on the trunk */
name|cp
operator|=
name|strrchr
argument_list|(
name|tag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* trunk processing is the special case */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for an extra . */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|rcs
operator|->
name|head
init|;
name|cp
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|xtag
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xstrdup
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
comment|/* if it had a `.', terminate the string so we have the base revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* look up the revision this branch is based on */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* put the . back so we have the branch again */
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* if the base revision didn't exist, return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* find the first element of the branch we are looking for */
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xtag
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 for the extra '.' */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xtag
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xtag
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|head
operator|=
name|vn
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xtag
argument_list|,
name|strlen
argument_list|(
name|xtag
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|head
condition|)
block|{
comment|/* we didn't find a match so return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
comment|/* now walk the next pointers of the branch */
name|nextvers
operator|=
name|p
operator|->
name|key
expr_stmt|;
do|do
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|nextvers
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* a link in the chain is missing - return head or NULL */
if|if
condition|(
name|force_tag_match
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|RCS_head
argument_list|(
name|rcs
argument_list|)
operator|)
return|;
block|}
name|vn
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|nextvers
operator|=
name|vn
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|nextvers
operator|!=
name|NULL
condition|)
do|;
comment|/* we have the version in our hand, so go for it */
return|return
operator|(
name|xstrdup
argument_list|(
name|vn
operator|->
name|version
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the head of the RCS file.  If branch is set, this is the head of the  * branch, otherwise the real head  */
end_comment

begin_function
name|char
modifier|*
name|RCS_head
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * NOTE: we call getbranch with force_tag_match set to avoid any      * possibility of recursion      */
if|if
condition|(
name|rcs
operator|->
name|branch
condition|)
return|return
operator|(
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rcs
operator|->
name|branch
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the most recent revision, based on the supplied date, but use some  * funky stuff and follow the vendor branch maybe  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getdate
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
init|=
name|NULL
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if the head is on a branch, try the branch first */
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
comment|/* if we found a match, we are done */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* otherwise if we have a trunk, try it */
if|if
condition|(
name|rcs
operator|->
name|head
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* if the date of this one is before date, take it */
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
break|break;
block|}
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * at this point, either we have the revision we want, or we have the      * first revision on the trunk (1.1?) in our hands      */
comment|/* if we found what we're looking for, and it's not 1.1 return it */
if|if
condition|(
name|cur_rev
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|cur_rev
argument_list|,
literal|"1.1"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
operator|)
return|;
comment|/* look on the vendor branch */
name|retval
operator|=
name|RCS_getdatebranch
argument_list|(
name|rcs
argument_list|,
name|date
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
comment|/*      * if we found a match, return it; otherwise, we return the first      * revision on the trunk or NULL depending on force_tag_match and the      * date of the first rev      */
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
operator|(
name|retval
operator|)
return|;
if|if
condition|(
operator|!
name|force_tag_match
operator|||
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|xstrdup
argument_list|(
name|vers
operator|->
name|version
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the last element on a branch that was put in before the specified  * date (return the rev or NULL)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|RCS_getdatebranch
parameter_list|(
name|rcs
parameter_list|,
name|date
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
modifier|*
name|cur_rev
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|xbranch
decl_stmt|,
modifier|*
name|xrev
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* look up the first revision on the branch */
name|xrev
operator|=
name|xstrdup
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|xrev
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* turn it into a revision */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|xrev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* Tentatively use this revision, if it is early enough.  */
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
comment|/* if no branches list, return now */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
return|;
comment|/* walk the branches list looking for the branch number */
name|xbranch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|branch
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* +1 for the extra dot */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|xbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|xbranch
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|xbranch
argument_list|,
name|strlen
argument_list|(
name|xbranch
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|free
argument_list|(
name|xbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
block|{
comment|/* FIXME: This case would seem to imply that the RCS file is            somehow invalid.  Should we give an error message?  */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* walk the next pointers until you find the end, or the date is too late */
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|date
argument_list|)
operator|<=
literal|0
condition|)
name|cur_rev
operator|=
name|vers
operator|->
name|version
expr_stmt|;
else|else
break|break;
comment|/* if there is a next version, find the node */
if|if
condition|(
name|vers
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Return whatever we found, which may be NULL.  */
return|return
name|xstrdup
argument_list|(
name|cur_rev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two dates in RCS format. Beware the change in format on January 1,  * 2000, when years go from 2-digit to full format.  */
end_comment

begin_function
name|int
name|RCS_datecmp
parameter_list|(
name|date1
parameter_list|,
name|date2
parameter_list|)
name|char
modifier|*
name|date1
decl_stmt|,
decl|*
name|date2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|date1
argument_list|)
operator|-
name|strlen
argument_list|(
name|date2
argument_list|)
decl_stmt|;
return|return
operator|(
name|length_diff
condition|?
name|length_diff
else|:
name|strcmp
argument_list|(
name|date1
argument_list|,
name|date2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Look up revision REV in RCS and return the date specified for the    revision minus FUDGE seconds (FUDGE will generally be one, so that the    logically previous revision will be found later, or zero, if we want    the exact date).     The return value is the date being returned as a time_t, or (time_t)-1    on error (previously was documented as zero on error; I haven't checked    the callers to make sure that they really check for (time_t)-1, but    the latter is what this function really returns).  If DATE is non-NULL,    then it must point to MAXDATELEN characters, and we store the same    return value there in DATEFORM format.  */
end_comment

begin_function
name|time_t
name|RCS_getrevtime
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|date
parameter_list|,
name|fudge
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|fudge
decl_stmt|;
block|{
name|char
name|tdate
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|struct
name|tm
name|xtm
decl_stmt|,
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|revdate
init|=
literal|0
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* make sure we have something to look at... */
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* look up the revision */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
comment|/* split up the date */
name|ftm
operator|=
operator|&
name|xtm
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|vers
operator|->
name|date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|ftm
operator|->
name|tm_year
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mon
argument_list|,
operator|&
name|ftm
operator|->
name|tm_mday
argument_list|,
operator|&
name|ftm
operator|->
name|tm_hour
argument_list|,
operator|&
name|ftm
operator|->
name|tm_min
argument_list|,
operator|&
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
comment|/* If the year is from 1900 to 1999, RCS files contain only two        digits, and sscanf gives us a year from 0-99.  If the year is        2000+, RCS files contain all four digits and we subtract 1900,        because the tm_year field should contain years since 1900.  */
if|if
condition|(
name|ftm
operator|->
name|tm_year
operator|>
literal|1900
condition|)
name|ftm
operator|->
name|tm_year
operator|-=
literal|1900
expr_stmt|;
comment|/* put the date in a form getdate can grok */
ifdef|#
directive|ifdef
name|HAVE_RCS5
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d GMT %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tdate
argument_list|,
literal|"%d/%d/%d %d:%d:%d"
argument_list|,
name|ftm
operator|->
name|tm_mon
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* turn it into seconds since the epoch */
name|revdate
operator|=
name|get_date
argument_list|(
name|tdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|revdate
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|revdate
operator|-=
name|fudge
expr_stmt|;
comment|/* remove "fudge" seconds */
if|if
condition|(
name|date
condition|)
block|{
comment|/* put an appropriate string into ``date'' if we were given one */
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|revdate
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revdate
operator|)
return|;
block|}
end_function

begin_function
name|List
modifier|*
name|RCS_symbols
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|symbols_data
condition|)
block|{
name|rcs
operator|->
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|do_symbols
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
operator|->
name|symbols_data
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|symbols_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|rcs
operator|->
name|symbols
return|;
block|}
end_function

begin_comment
comment|/*  * Return the version associated with a particular symbolic tag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|translate_symtag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|symbols
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* The symbols have already been converted into a list.  */
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|xstrdup
argument_list|(
name|p
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|rcs
operator|->
name|symbols_data
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Look through the RCS symbols information.  This is like            do_symbols, but we don't add the information to a list.  In            most cases, we will only be called once for this file, so            generating the list is unnecessary overhead.  */
name|len
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rcs
operator|->
name|symbols_data
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
name|tag
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|==
name|rcs
operator|->
name|symbols_data
operator|||
name|whitespace
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|cp
argument_list|,
name|tag
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
index|[
name|len
index|]
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* We found the tag.  Return the version number.  */
name|cp
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|v
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|++
name|cp
expr_stmt|;
name|r
operator|=
name|xmalloc
argument_list|(
name|cp
operator|-
name|v
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|r
argument_list|,
name|v
argument_list|,
name|cp
operator|-
name|v
argument_list|)
expr_stmt|;
name|r
index|[
name|cp
operator|-
name|v
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
while|while
condition|(
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|++
name|cp
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * The argument ARG is the getopt remainder of the -k option specified on the  * command line.  This function returns malloc'ed space that can be used  * directly in calls to RCS V5, with the -k flag munged correctly.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_check_kflag
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|keyword_usage
index|[]
init|=
block|{
literal|"%s %s: invalid RCS keyword expansion mode\n"
block|,
literal|"Valid expansion modes include:\n"
block|,
literal|"   -kkv\tGenerate keywords using the default form.\n"
block|,
literal|"   -kkvl\tLike -kkv, except locker's name inserted.\n"
block|,
literal|"   -kk\tGenerate only keyword names in keyword strings.\n"
block|,
literal|"   -kv\tGenerate only keyword values in keyword strings.\n"
block|,
literal|"   -ko\tGenerate the old keyword string (no changes from checked in file).\n"
block|,
literal|"   -kb\tGenerate binary file unmodified (merges not allowed) (RCS 5.7).\n"
block|,
name|NULL
block|,     }
decl_stmt|;
comment|/* Big enough to hold any of the strings from kflags.  */
name|char
name|karg
index|[
literal|10
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|cpp
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s %s: your version of RCS does not support the -k option"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arg
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
operator|*
name|cpp
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|cpp
operator|==
name|NULL
condition|)
block|{
name|usage
argument_list|(
name|keyword_usage
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|karg
argument_list|,
literal|"-k%s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|xstrdup
argument_list|(
name|karg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do some consistency checks on the symbolic tag... These should equate  * pretty close to what RCS checks, though I don't know for certain.  */
end_comment

begin_function
name|void
name|RCS_check_tag
parameter_list|(
name|tag
parameter_list|)
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|invalid
init|=
literal|"$,.:;@"
decl_stmt|;
comment|/* invalid RCS tag characters */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/*      * The first character must be an alphabetic letter. The remaining      * characters cannot be non-visible graphic characters, and must not be      * in the set of "invalid" RCS identifier characters.      */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|tag
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isgraph
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' has non-visible graphic characters"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|invalid
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must not contain the characters `%s'"
argument_list|,
name|tag
argument_list|,
name|invalid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must start with a letter"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if RCS revision with TAG is a dead revision.  */
end_comment

begin_function
name|int
name|RCS_isdead
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|version
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
return|return
operator|(
name|version
operator|->
name|dead
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the RCS keyword expansion mode.  For example "b" for binary.    Returns a pointer into storage which is allocated and freed along with    the rest of the RCS information; the caller should not modify this    storage.  Returns NULL if the RCS file does not specify a keyword    expansion mode; for all other errors, die with a fatal error.  */
end_comment

begin_function
name|char
modifier|*
name|RCS_getexpand
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|assert
argument_list|(
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|rcs
operator|->
name|expand
return|;
block|}
end_function

begin_comment
comment|/* RCS keywords, and a matching enum.  */
end_comment

begin_struct
struct|struct
name|rcs_keyword
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|expandit
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEYWORD_INIT
parameter_list|(
name|s
parameter_list|)
value|(s), sizeof (s) - 1
end_define

begin_decl_stmt
specifier|static
name|struct
name|rcs_keyword
name|keywords
index|[]
init|=
block|{
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Author"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Date"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"CVSHeader"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Header"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Id"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Locker"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Log"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Name"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"RCSfile"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Revision"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"Source"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|KEYWORD_INIT
argument_list|(
literal|"State"
argument_list|)
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|keyword
block|{
name|KEYWORD_AUTHOR
init|=
literal|0
block|,
name|KEYWORD_DATE
block|,
name|KEYWORD_CVSHEADER
block|,
name|KEYWORD_HEADER
block|,
name|KEYWORD_ID
block|,
name|KEYWORD_LOCKER
block|,
name|KEYWORD_LOG
block|,
name|KEYWORD_NAME
block|,
name|KEYWORD_RCSFILE
block|,
name|KEYWORD_REVISION
block|,
name|KEYWORD_SOURCE
block|,
name|KEYWORD_STATE
block|,
name|KEYWORD_LOCALID
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|keyword
name|keyword_local
init|=
name|KEYWORD_ID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert an RCS date string into a readable string.  This is like    the RCS date2str function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_date
parameter_list|(
name|rcs_date
parameter_list|)
specifier|const
name|char
modifier|*
name|rcs_date
decl_stmt|;
block|{
name|int
name|year
decl_stmt|,
name|mon
decl_stmt|,
name|mday
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|rcs_date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|mon
argument_list|,
operator|&
name|mday
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|<
literal|1900
condition|)
name|year
operator|+=
literal|1900
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%04d/%02d/%02d %02d:%02d:%02d"
argument_list|,
name|year
argument_list|,
name|mon
argument_list|,
name|mday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Escape the characters in a string so that it can be included in an    RCS value.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|escape_keyword_value
parameter_list|(
name|value
parameter_list|,
name|free_value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|int
modifier|*
name|free_value
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|value
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'$'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|free_value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|value
return|;
block|}
name|ret
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|free_value
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
name|value
operator|,
name|t
operator|=
name|ret
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
operator|,
name|t
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
operator|*
name|t
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'4'
expr_stmt|;
operator|*
name|t
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|*
name|t
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'4'
expr_stmt|;
operator|*
name|t
operator|=
literal|'4'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand RCS keywords in the memory buffer BUF of length LEN.  This    applies to file RCS and version VERS.  If NAME is not NULL, and is    not a numeric revision, then it is the symbolic tag used for the    checkout.  EXPAND indicates how to expand the keywords.  This    function sets *RETBUF and *RETLEN to the new buffer and length.    This function may modify the buffer BUF.  If BUF != *RETBUF, then    RETBUF is a newly allocated buffer.  */
end_comment

begin_function
specifier|static
name|void
name|expand_keywords
parameter_list|(
name|rcs
parameter_list|,
name|ver
parameter_list|,
name|name
parameter_list|,
name|log
parameter_list|,
name|loglen
parameter_list|,
name|expand
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|retbuf
parameter_list|,
name|retlen
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|RCSVers
modifier|*
name|ver
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|log
decl_stmt|;
name|size_t
name|loglen
decl_stmt|;
name|enum
name|kflag
name|expand
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|retbuf
decl_stmt|;
name|size_t
modifier|*
name|retlen
decl_stmt|;
block|{
struct|struct
name|expand_buffer
block|{
name|struct
name|expand_buffer
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|free_data
decl_stmt|;
block|}
modifier|*
name|ebufs
init|=
name|NULL
struct|;
name|struct
name|expand_buffer
modifier|*
name|ebuf_last
init|=
name|NULL
decl_stmt|;
name|size_t
name|ebuf_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|locker
decl_stmt|;
name|char
modifier|*
name|srch
decl_stmt|,
modifier|*
name|srch_next
decl_stmt|;
name|size_t
name|srch_len
decl_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_O
operator|||
name|expand
operator|==
name|KFLAG_B
condition|)
block|{
operator|*
name|retbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
return|return;
block|}
comment|/* If we are using -kkvl, dig out the locker information if any.  */
name|locker
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_KVL
operator|&&
name|rcs
operator|->
name|other
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|other
argument_list|,
literal|"locks"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|verlen
decl_stmt|;
comment|/* The format of the locking information is 	         USER:VERSION USER:VERSION ... 	       If we find our version on the list, we set LOCKER to 	       the corresponding user name.  */
name|verlen
operator|=
name|strlen
argument_list|(
name|ver
operator|->
name|version
argument_list|)
expr_stmt|;
name|cp
operator|=
name|p
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|cp
argument_list|,
name|ver
operator|->
name|version
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|>
name|p
operator|->
name|data
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|cp
index|[
name|verlen
index|]
operator|==
literal|'\0'
operator|||
name|whitespace
argument_list|(
name|cp
index|[
name|verlen
index|]
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|cpend
decl_stmt|;
operator|--
name|cp
expr_stmt|;
name|cpend
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|p
operator|->
name|data
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|--
name|cp
expr_stmt|;
name|locker
operator|=
name|xmalloc
argument_list|(
name|cpend
operator|-
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|locker
argument_list|,
name|cp
argument_list|,
name|cpend
operator|-
name|cp
argument_list|)
expr_stmt|;
name|locker
index|[
name|cpend
operator|-
name|cp
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|++
name|cp
expr_stmt|;
block|}
block|}
block|}
comment|/* RCS keywords look like $STRING$ or $STRING: VALUE$.  */
name|srch
operator|=
name|buf
expr_stmt|;
name|srch_len
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|(
name|srch_next
operator|=
name|memchr
argument_list|(
name|srch
argument_list|,
literal|'$'
argument_list|,
name|srch_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|send
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
specifier|const
name|struct
name|rcs_keyword
modifier|*
name|keyword
decl_stmt|;
name|enum
name|keyword
name|kw
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|free_value
decl_stmt|;
name|char
modifier|*
name|sub
decl_stmt|;
name|size_t
name|sublen
decl_stmt|;
name|srch_len
operator|-=
operator|(
name|srch_next
operator|+
literal|1
operator|)
operator|-
name|srch
expr_stmt|;
name|srch
operator|=
name|srch_next
operator|+
literal|1
expr_stmt|;
comment|/* Look for the first non alphabetic character after the '$'.  */
name|send
operator|=
name|srch
operator|+
name|srch_len
expr_stmt|;
for|for
control|(
name|s
operator|=
name|srch
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
condition|)
break|break;
comment|/* If the first non alphabetic character is not '$' or ':',            then this is not an RCS keyword.  */
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'$'
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|)
condition|)
continue|continue;
comment|/* See if this is one of the keywords.  */
name|slen
operator|=
name|s
operator|-
name|srch
expr_stmt|;
for|for
control|(
name|keyword
operator|=
name|keywords
init|;
name|keyword
operator|->
name|string
operator|!=
name|NULL
condition|;
name|keyword
operator|++
control|)
block|{
if|if
condition|(
name|keyword
operator|->
name|expandit
operator|&&
name|keyword
operator|->
name|len
operator|==
name|slen
operator|&&
name|strncmp
argument_list|(
name|keyword
operator|->
name|string
argument_list|,
name|srch
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|keyword
operator|->
name|string
operator|==
name|NULL
condition|)
continue|continue;
name|kw
operator|=
operator|(
expr|enum
name|keyword
operator|)
operator|(
name|keyword
operator|-
name|keywords
operator|)
expr_stmt|;
comment|/* If the keyword ends with a ':', then the old value consists            of the characters up to the next '$'.  If there is no '$'            before the end of the line, though, then this wasn't an RCS            keyword after all.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
for|for
control|(
init|;
name|s
operator|<
name|send
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|*
name|s
operator|!=
literal|'$'
condition|)
continue|continue;
block|}
comment|/* At this point we must replace the string from SRCH to S            with the expansion of the keyword KW.  */
comment|/* Get the value to use.  */
name|free_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_K
condition|)
name|value
operator|=
name|NULL
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|kw
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|KEYWORD_AUTHOR
case|:
name|value
operator|=
name|ver
operator|->
name|author
expr_stmt|;
break|break;
case|case
name|KEYWORD_DATE
case|:
name|value
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEYWORD_CVSHEADER
case|:
case|case
name|KEYWORD_HEADER
case|:
case|case
name|KEYWORD_ID
case|:
case|case
name|KEYWORD_LOCALID
case|:
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|free_path
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|old_path
decl_stmt|;
name|old_path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kw
operator|==
name|KEYWORD_HEADER
operator|||
operator|(
name|kw
operator|==
name|KEYWORD_LOCALID
operator|&&
name|keyword_local
operator|==
name|KEYWORD_HEADER
operator|)
condition|)
name|path
operator|=
name|rcs
operator|->
name|path
expr_stmt|;
elseif|else
if|if
condition|(
name|kw
operator|==
name|KEYWORD_CVSHEADER
operator|||
operator|(
name|kw
operator|==
name|KEYWORD_LOCALID
operator|&&
name|keyword_local
operator|==
name|KEYWORD_CVSHEADER
operator|)
condition|)
name|path
operator|=
name|getfullCVSname
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
operator|&
name|old_path
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|escape_keyword_value
argument_list|(
name|path
argument_list|,
operator|&
name|free_path
argument_list|)
expr_stmt|;
name|date
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|author
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|state
argument_list|)
operator|+
operator|(
name|locker
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|locker
argument_list|)
operator|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%s %s %s %s %s%s%s"
argument_list|,
name|path
argument_list|,
name|ver
operator|->
name|version
argument_list|,
name|date
argument_list|,
name|ver
operator|->
name|author
argument_list|,
name|ver
operator|->
name|state
argument_list|,
name|locker
operator|!=
name|NULL
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|locker
operator|!=
name|NULL
condition|?
name|locker
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_path
condition|)
name|free
argument_list|(
name|old_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|KEYWORD_LOCKER
case|:
name|value
operator|=
name|locker
expr_stmt|;
break|break;
case|case
name|KEYWORD_LOG
case|:
case|case
name|KEYWORD_RCSFILE
case|:
name|value
operator|=
name|escape_keyword_value
argument_list|(
name|last_component
argument_list|(
name|rcs
operator|->
name|path
argument_list|)
argument_list|,
operator|&
name|free_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORD_NAME
case|:
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
else|else
name|value
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|KEYWORD_REVISION
case|:
name|value
operator|=
name|ver
operator|->
name|version
expr_stmt|;
break|break;
case|case
name|KEYWORD_SOURCE
case|:
name|value
operator|=
name|escape_keyword_value
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
operator|&
name|free_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORD_STATE
case|:
name|value
operator|=
name|ver
operator|->
name|state
expr_stmt|;
break|break;
block|}
block|}
name|sub
operator|=
name|xmalloc
argument_list|(
name|keyword
operator|->
name|len
operator|+
operator|(
name|value
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|value
argument_list|)
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|==
name|KFLAG_V
condition|)
block|{
comment|/* Decrement SRCH and increment S to remove the $                characters.  */
operator|--
name|srch
expr_stmt|;
operator|++
name|srch_len
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|sublen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|sub
argument_list|,
name|keyword
operator|->
name|string
argument_list|)
expr_stmt|;
name|sublen
operator|=
name|strlen
argument_list|(
name|keyword
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_K
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|':'
expr_stmt|;
name|sub
index|[
name|sublen
operator|+
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|sublen
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
operator|&&
name|expand
operator|!=
name|KFLAG_K
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|' '
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* The Log keyword requires special handling.  This behaviour            is taken from RCS 5.7.  The special log message is what RCS            uses for ci -k.  */
if|if
condition|(
name|kw
operator|==
name|KEYWORD_LOG
operator|&&
operator|(
sizeof|sizeof
expr|"checked in with -k by "
operator|<=
name|loglen
operator|||
name|strncmp
argument_list|(
name|log
argument_list|,
literal|"checked in with -k by "
argument_list|,
sizeof|sizeof
expr|"checked in with -k by "
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|leader
decl_stmt|;
name|size_t
name|leader_len
decl_stmt|,
name|leader_sp_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|logend
decl_stmt|;
specifier|const
name|char
modifier|*
name|snl
decl_stmt|;
name|int
name|cnl
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|sl
decl_stmt|;
comment|/* We are going to insert the trailing $ ourselves, before                the log message, so we must remove it from S, if we                haven't done so already.  */
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
operator|++
name|s
expr_stmt|;
comment|/* Find the start of the line.  */
name|start
operator|=
name|srch
expr_stmt|;
while|while
condition|(
name|start
operator|>
name|buf
operator|&&
name|start
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|start
expr_stmt|;
comment|/* Copy the start of the line to use as a comment leader.  */
name|leader_len
operator|=
name|srch
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
operator|--
name|leader_len
expr_stmt|;
name|leader
operator|=
name|xmalloc
argument_list|(
name|leader_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|leader
argument_list|,
name|start
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|leader_sp_len
operator|=
name|leader_len
expr_stmt|;
while|while
condition|(
name|leader_sp_len
operator|>
literal|0
operator|&&
name|leader
index|[
name|leader_sp_len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
name|leader_sp_len
expr_stmt|;
comment|/* RCS does some checking for an old style of Log here, 	       but we don't bother.  RCS issues a warning if it 	       changes anything.  */
comment|/* Count the number of newlines in the log message so that 	       we know how many copies of the leader we will need.  */
name|cnl
operator|=
literal|0
expr_stmt|;
name|logend
operator|=
name|log
operator|+
name|loglen
expr_stmt|;
for|for
control|(
name|snl
operator|=
name|log
init|;
name|snl
operator|<
name|logend
condition|;
name|snl
operator|++
control|)
if|if
condition|(
operator|*
name|snl
operator|==
literal|'\n'
condition|)
operator|++
name|cnl
expr_stmt|;
name|date
operator|=
name|printable_date
argument_list|(
name|ver
operator|->
name|date
argument_list|)
expr_stmt|;
name|sub
operator|=
name|xrealloc
argument_list|(
name|sub
argument_list|,
operator|(
name|sublen
operator|+
sizeof|sizeof
expr|"Revision"
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
name|strlen
argument_list|(
name|ver
operator|->
name|author
argument_list|)
operator|+
name|loglen
operator|+
operator|(
name|cnl
operator|+
literal|2
operator|)
operator|*
name|leader_len
operator|+
literal|20
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|KFLAG_V
condition|)
block|{
name|sub
index|[
name|sublen
index|]
operator|=
literal|'$'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
block|}
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_len
expr_stmt|;
name|sprintf
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
literal|"Revision %s  %s  %s\n"
argument_list|,
name|ver
operator|->
name|version
argument_list|,
name|date
argument_list|,
name|ver
operator|->
name|author
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|strlen
argument_list|(
name|sub
operator|+
name|sublen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|sl
operator|=
name|log
expr_stmt|;
while|while
condition|(
name|sl
operator|<
name|logend
condition|)
block|{
if|if
condition|(
operator|*
name|sl
operator|==
literal|'\n'
condition|)
block|{
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_sp_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_sp_len
expr_stmt|;
name|sub
index|[
name|sublen
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|sublen
expr_stmt|;
operator|++
name|sl
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|slnl
decl_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_len
expr_stmt|;
for|for
control|(
name|slnl
operator|=
name|sl
init|;
name|slnl
operator|<
name|logend
operator|&&
operator|*
name|slnl
operator|!=
literal|'\n'
condition|;
operator|++
name|slnl
control|)
empty_stmt|;
if|if
condition|(
name|slnl
operator|<
name|logend
condition|)
operator|++
name|slnl
expr_stmt|;
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|sl
argument_list|,
name|slnl
operator|-
name|sl
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|slnl
operator|-
name|sl
expr_stmt|;
name|sl
operator|=
name|slnl
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|sub
operator|+
name|sublen
argument_list|,
name|leader
argument_list|,
name|leader_sp_len
argument_list|)
expr_stmt|;
name|sublen
operator|+=
name|leader_sp_len
expr_stmt|;
name|free
argument_list|(
name|leader
argument_list|)
expr_stmt|;
block|}
comment|/* Now SUB contains a string which is to replace the string 	   from SRCH to S.  SUBLEN is the length of SUB.  */
if|if
condition|(
name|srch
operator|+
name|sublen
operator|==
name|s
condition|)
block|{
name|memcpy
argument_list|(
name|srch
argument_list|,
name|sub
argument_list|,
name|sublen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|expand_buffer
modifier|*
name|ebuf
decl_stmt|;
comment|/* We need to change the size of the buffer.  We build a                list of expand_buffer structures.  Each expand_buffer                structure represents a portion of the final output.  We                concatenate them back into a single buffer when we are                done.  This minimizes the number of potentially large                buffer copies we must do.  */
if|if
condition|(
name|ebufs
operator|==
name|NULL
condition|)
block|{
name|ebufs
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebufs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebufs
operator|->
name|data
operator|=
name|buf
expr_stmt|;
name|ebufs
operator|->
name|free_data
operator|=
literal|0
expr_stmt|;
name|ebuf_len
operator|=
name|srch
operator|-
name|buf
expr_stmt|;
name|ebufs
operator|->
name|len
operator|=
name|ebuf_len
expr_stmt|;
name|ebuf_last
operator|=
name|ebufs
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|srch
operator|>=
name|ebuf_last
operator|->
name|data
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|srch
operator|<=
name|ebuf_last
operator|->
name|data
operator|+
name|ebuf_last
operator|->
name|len
argument_list|)
expr_stmt|;
name|ebuf_len
operator|-=
name|ebuf_last
operator|->
name|len
operator|-
operator|(
name|srch
operator|-
name|ebuf_last
operator|->
name|data
operator|)
expr_stmt|;
name|ebuf_last
operator|->
name|len
operator|=
name|srch
operator|-
name|ebuf_last
operator|->
name|data
expr_stmt|;
block|}
name|ebuf
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebuf
operator|->
name|data
operator|=
name|sub
expr_stmt|;
name|ebuf
operator|->
name|len
operator|=
name|sublen
expr_stmt|;
name|ebuf
operator|->
name|free_data
operator|=
literal|1
expr_stmt|;
name|ebuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebuf_last
operator|->
name|next
operator|=
name|ebuf
expr_stmt|;
name|ebuf_last
operator|=
name|ebuf
expr_stmt|;
name|ebuf_len
operator|+=
name|sublen
expr_stmt|;
name|ebuf
operator|=
operator|(
expr|struct
name|expand_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ebuf
argument_list|)
expr_stmt|;
name|ebuf
operator|->
name|data
operator|=
name|s
expr_stmt|;
name|ebuf
operator|->
name|len
operator|=
name|srch_len
operator|-
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
name|ebuf
operator|->
name|free_data
operator|=
literal|0
expr_stmt|;
name|ebuf
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ebuf_last
operator|->
name|next
operator|=
name|ebuf
expr_stmt|;
name|ebuf_last
operator|=
name|ebuf
expr_stmt|;
name|ebuf_len
operator|+=
name|srch_len
operator|-
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
block|}
name|srch_len
operator|-=
operator|(
name|s
operator|-
name|srch
operator|)
expr_stmt|;
name|srch
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|locker
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|locker
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebufs
operator|==
name|NULL
condition|)
block|{
operator|*
name|retbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|retlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|ebuf_len
argument_list|)
expr_stmt|;
operator|*
name|retbuf
operator|=
name|ret
expr_stmt|;
operator|*
name|retlen
operator|=
name|ebuf_len
expr_stmt|;
while|while
condition|(
name|ebufs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|expand_buffer
modifier|*
name|next
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ebufs
operator|->
name|data
argument_list|,
name|ebufs
operator|->
name|len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|ebufs
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|ebufs
operator|->
name|free_data
condition|)
name|free
argument_list|(
name|ebufs
operator|->
name|data
argument_list|)
expr_stmt|;
name|next
operator|=
name|ebufs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|ebufs
argument_list|)
expr_stmt|;
name|ebufs
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check out a revision from an RCS file.     If PFN is not NULL, then ignore WORKFILE and SOUT.  Call PFN zero    or more times with the contents of the file.  CALLERDAT is passed,    uninterpreted, to PFN.  (The current code will always call PFN    exactly once for a non empty file; however, the current code    assumes that it can hold the entire file contents in memory, which    is not a good assumption, and might change in the future).     Otherwise, if WORKFILE is not NULL, check out the revision to    WORKFILE.  However, if WORKFILE is not NULL, and noexec is set,    then don't do anything.     Otherwise, if WORKFILE is NULL, check out the revision to SOUT.  If    SOUT is RUN_TTY, then write the contents of the revision to    standard output.  When using SOUT, the output is generally a    temporary file; don't bother to get the file modes correct.     REV is the numeric revision to check out.  It may be NULL, which    means to check out the head of the default branch.     If NAMETAG is not NULL, and is not a numeric revision, then it is    the tag that should be used when expanding the RCS Name keyword.     OPTIONS is a string such as "-kb" or "-kv" for keyword expansion    options.  It may be NULL to use the default expansion mode of the    file, typically "-kkv".  */
end_comment

begin_function
name|int
name|RCS_checkout
parameter_list|(
name|rcs
parameter_list|,
name|workfile
parameter_list|,
name|rev
parameter_list|,
name|nametag
parameter_list|,
name|options
parameter_list|,
name|sout
parameter_list|,
name|pfn
parameter_list|,
name|callerdat
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|nametag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|sout
decl_stmt|;
name|RCSCHECKOUTPROC
name|pfn
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
block|{
name|int
name|free_rev
init|=
literal|0
decl_stmt|;
name|enum
name|kflag
name|expand
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|free_value
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|log
init|=
name|NULL
decl_stmt|;
name|size_t
name|loglen
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> checkout (%s, %s, %s, %s)\n"
argument_list|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|server_active
condition|?
literal|"S"
else|:
literal|" "
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
name|rcs
operator|->
name|path
argument_list|,
name|rev
operator|!=
name|NULL
condition|?
name|rev
else|:
literal|""
argument_list|,
name|options
operator|!=
name|NULL
condition|?
name|options
else|:
literal|""
argument_list|,
operator|(
name|pfn
operator|!=
name|NULL
condition|?
literal|"(function)"
else|:
operator|(
name|workfile
operator|!=
name|NULL
condition|?
name|workfile
else|:
operator|(
name|sout
operator|!=
name|RUN_TTY
condition|?
name|sout
else|:
literal|"(stdout)"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|rev
operator|==
name|NULL
operator|||
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
operator|&&
name|workfile
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|sout
operator|==
name|RUN_TTY
operator|||
name|workfile
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pfn
operator|==
name|NULL
operator|||
operator|(
name|sout
operator|==
name|RUN_TTY
operator|&&
name|workfile
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
comment|/* Some callers, such as Checkin or remove_file, will pass us a        branch.  */
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
operator|(
name|numdots
argument_list|(
name|rev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|rev
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: bad branch tag in checkout"
argument_list|)
expr_stmt|;
name|free_rev
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|rev
argument_list|,
name|rcs
operator|->
name|head
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|gothead
decl_stmt|;
comment|/* We want the head revision.  Try to read it directly.  */
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|NODELTA
condition|)
block|{
name|free_rcsnode_contents
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|flags
operator||=
name|PARTIAL
expr_stmt|;
block|}
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unable to reopen `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|rcs
operator|->
name|delta_pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot fseek RCS file"
argument_list|)
expr_stmt|;
block|}
name|gothead
operator|=
literal|0
expr_stmt|;
name|getrcsrev
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|len
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|log
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|loglen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gothead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|gothead
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: cannot find head text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It isn't the head revision of the trunk.  We'll need to 	   walk through the deltas.  */
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* If RCS_deltas didn't close the file, we could use fstat 	       here too.  Probably should change it thusly....  */
if|if
condition|(
name|stat
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|RCS_deltas
argument_list|(
name|rcs
argument_list|,
name|fp
argument_list|,
name|rev
argument_list|,
name|RCS_FETCH
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|log
argument_list|,
operator|&
name|loglen
argument_list|)
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If OPTIONS is NULL or the empty string, then the old code would        invoke the RCS co program with no -k option, which means that        co would use the string we have stored in rcs->expand.  */
if|if
condition|(
operator|(
name|options
operator|==
name|NULL
operator|||
name|options
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|rcs
operator|->
name|expand
operator|==
name|NULL
condition|)
name|expand
operator|=
name|KFLAG_KV
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|ouroptions
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cpp
decl_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|assert
argument_list|(
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
argument_list|)
expr_stmt|;
name|ouroptions
operator|=
name|options
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|ouroptions
operator|=
name|rcs
operator|->
name|expand
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|kflags
init|;
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
name|ouroptions
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|cpp
operator|!=
name|NULL
condition|)
name|expand
operator|=
operator|(
expr|enum
name|kflag
operator|)
operator|(
name|cpp
operator|-
name|kflags
operator|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: unsupported substitution string -k%s"
argument_list|,
name|ouroptions
argument_list|)
expr_stmt|;
name|expand
operator|=
name|KFLAG_KV
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expand
operator|!=
name|KFLAG_O
operator|&&
name|expand
operator|!=
name|KFLAG_B
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|newvalue
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no revision information for %s"
argument_list|,
name|rev
operator|==
name|NULL
condition|?
name|rcs
operator|->
name|head
else|:
name|rev
argument_list|)
expr_stmt|;
name|expand_keywords
argument_list|(
name|rcs
argument_list|,
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
argument_list|,
name|nametag
argument_list|,
name|log
argument_list|,
name|loglen
argument_list|,
name|expand
argument_list|,
name|value
argument_list|,
name|len
argument_list|,
operator|&
name|newvalue
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvalue
operator|!=
name|value
condition|)
block|{
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|newvalue
expr_stmt|;
name|free_value
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|log
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pfn
operator|!=
name|NULL
condition|)
block|{
comment|/* The PFN interface is very simple to implement right now, as            we always have the entire file in memory.  */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|pfn
argument_list|(
name|callerdat
argument_list|,
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|workfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sout
operator|==
name|RUN_TTY
condition|)
name|ofp
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|ofp
operator|=
name|CVS_FOPEN
argument_list|(
name|sout
argument_list|,
name|expand
operator|==
name|KFLAG_B
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ofp
operator|=
name|CVS_FOPEN
argument_list|(
name|workfile
argument_list|,
name|expand
operator|==
name|KFLAG_B
condition|?
literal|"wb"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|workfile
operator|==
name|NULL
operator|&&
name|sout
operator|==
name|RUN_TTY
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|cvs_output
argument_list|(
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|value
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|ofp
argument_list|)
operator|!=
name|len
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
operator|(
name|workfile
operator|!=
name|NULL
condition|?
name|workfile
else|:
operator|(
name|sout
operator|!=
name|RUN_TTY
condition|?
name|sout
else|:
literal|"stdout"
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|workfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|workfile
argument_list|,
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sout
operator|!=
name|RUN_TTY
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|ofp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|sout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_value
condition|)
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_rev
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This structure is passed between RCS_cmp_file and cmp_file_buffer.  */
end_comment

begin_struct
struct|struct
name|cmp_file_data
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|different
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compare the contents of revision REV of RCS file RCS with the    contents of the file FILENAME.  OPTIONS is a string for the keyword    expansion options.  Return 0 if the contents of the revision are    the same as the contents of the file, 1 if they are different.  */
end_comment

begin_function
name|int
name|RCS_cmp_file
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|options
parameter_list|,
name|filename
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|binary
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|cmp_file_data
name|data
decl_stmt|;
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|binary
operator|=
operator|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|expand
decl_stmt|;
name|expand
operator|=
name|RCS_getexpand
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|expand
argument_list|,
literal|"b"
argument_list|)
operator|==
literal|0
condition|)
name|binary
operator|=
literal|1
expr_stmt|;
else|else
name|binary
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
name|binary
condition|?
name|FOPEN_BINARY_READ
else|:
literal|"r"
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|filename
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|data
operator|.
name|different
operator|=
literal|0
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|rev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|cmp_file_buffer
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* If we have not yet found a difference, make sure that we are at        the end of the file.  */
if|if
condition|(
operator|!
name|data
operator|.
name|different
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
name|EOF
condition|)
name|data
operator|.
name|different
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|data
operator|.
name|different
return|;
block|}
end_function

begin_comment
comment|/* This is a subroutine of RCS_cmp_file.  It is passed to    RCS_checkout.  */
end_comment

begin_define
define|#
directive|define
name|CMP_BUF_SIZE
value|(8 * 1024)
end_define

begin_function
specifier|static
name|void
name|cmp_file_buffer
parameter_list|(
name|callerdat
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|cmp_file_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|cmp_file_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|;
comment|/* If we've already found a difference, we don't need to check        further.  */
if|if
condition|(
name|data
operator|->
name|different
condition|)
return|return;
name|filebuf
operator|=
name|xmalloc
argument_list|(
name|len
operator|>
name|CMP_BUF_SIZE
condition|?
name|CMP_BUF_SIZE
else|:
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|checklen
decl_stmt|;
name|checklen
operator|=
name|len
operator|>
name|CMP_BUF_SIZE
condition|?
name|CMP_BUF_SIZE
else|:
name|len
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|filebuf
argument_list|,
literal|1
argument_list|,
name|checklen
argument_list|,
name|data
operator|->
name|fp
argument_list|)
operator|!=
name|checklen
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|data
operator|->
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|data
operator|->
name|filename
argument_list|)
expr_stmt|;
name|data
operator|->
name|different
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|filebuf
argument_list|,
name|buffer
argument_list|,
name|checklen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|data
operator|->
name|different
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer
operator|+=
name|checklen
expr_stmt|;
name|len
operator|-=
name|checklen
expr_stmt|;
block|}
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For RCS file RCS, make symbolic tag TAG point to revision REV.    This validates that TAG is OK for a user to use.  Return value is    -1 for error (and errno is set to indicate the error), positive for    error (and an error message has been printed), or zero for success.  */
end_comment

begin_function
name|int
name|RCS_settag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
comment|/* FIXME: This check should be moved to RCS_check_tag.  There is no        reason for it to be here.  */
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|TAG_BASE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|tag
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Print the name of the tag might be considered redundant 	   with the caller, which also prints it.  Perhaps this helps 	   clarify why the tag name is considered reserved, I don't 	   know.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Attempt to add reserved tag name %s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ret
operator|=
name|RCS_exec_settag
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|tag
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* If we have already parsed the RCS file, update the tag        information.  If we have not yet parsed it (i.e., the PARTIAL        flag is set), the new tag information will be read when and if        we do parse it.  */
if|if
condition|(
operator|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
operator|)
operator|==
literal|0
condition|)
block|{
name|List
modifier|*
name|symbols
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
comment|/* At this point rcs->symbol_data may not have been parsed. 	   Calling RCS_symbols will force it to be parsed into a list 	   which we can easily manipulate.  */
name|symbols
operator|=
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
block|{
name|symbols
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|rcs
operator|->
name|symbols
operator|=
name|symbols
expr_stmt|;
block|}
name|node
operator|=
name|findnode
argument_list|(
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|symbols
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Setting the tag will most likely have invalidated delta_pos.  */
name|rcs
operator|->
name|flags
operator||=
name|NODELTA
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete the symbolic tag TAG from the RCS file RCS.  NOERR is 1 to    suppress errors--FIXME it would be better to avoid the errors or    some cleaner solution.  */
end_comment

begin_function
name|int
name|RCS_deltag
parameter_list|(
name|rcs
parameter_list|,
name|tag
parameter_list|,
name|noerr
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|RCS_exec_deltag
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|tag
argument_list|,
name|noerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* If we have already parsed the RCS file, update the tag        information.  If we have not yet parsed it (i.e., the PARTIAL        flag is set), the new tag information will be read when and if        we do parse it.  */
if|if
condition|(
operator|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
operator|)
operator|==
literal|0
condition|)
block|{
name|List
modifier|*
name|symbols
decl_stmt|;
comment|/* At this point rcs->symbol_data may not have been parsed. 	   Calling RCS_symbols will force it to be parsed into a list 	   which we can easily manipulate.  */
name|symbols
operator|=
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|findnode
argument_list|(
name|symbols
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deleting the tag will most likely have invalidated delta_pos.  */
name|rcs
operator|->
name|flags
operator||=
name|NODELTA
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the default branch of RCS to REV.  */
end_comment

begin_function
name|int
name|RCS_setbranch
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
operator|&&
name|rcs
operator|->
name|branch
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
name|rcs
operator|->
name|branch
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev
argument_list|,
name|rcs
operator|->
name|branch
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|RCS_exec_setbranch
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|branch
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
comment|/* Changing the branch will have changed the data in the file, so        delta_pos will no longer be correct.  */
name|rcs
operator|->
name|flags
operator||=
name|NODELTA
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lock revision REV.  NOERR is 1 to suppress errors--FIXME it would    be better to avoid the errors or some cleaner solution.  FIXME:    This is only required because the RCS ci program requires a lock.    If we eventually do the checkin ourselves, this can become a no-op.  */
end_comment

begin_function
name|int
name|RCS_lock
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|noerr
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|RCS_exec_lock
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|,
name|noerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Setting a lock will have changed the data in the file, so        delta_pos will no longer be correct.  */
name|rcs
operator|->
name|flags
operator||=
name|NODELTA
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Unlock revision REV.  NOERR is 1 to suppress errors--FIXME it would    be better to avoid the errors or some cleaner solution.  FIXME:    Like RCS_lock, this can become a no-op if we do the checkin    ourselves.  */
end_comment

begin_function
name|int
name|RCS_unlock
parameter_list|(
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|noerr
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|RCS_exec_unlock
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|,
name|noerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
name|ret
return|;
comment|/* Setting a lock will have changed the data in the file, so        delta_pos will no longer be correct.  */
name|rcs
operator|->
name|flags
operator||=
name|NODELTA
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */
end_comment

begin_comment
comment|/* Linked list of allocated blocks.  Seems kind of silly to    reinvent the obstack wheel, and this isn't as nice as obstacks    in some ways, but obstacks are pretty baroque.  */
end_comment

begin_struct
struct|struct
name|allocblock
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|struct
name|allocblock
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|allocblock
modifier|*
name|blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|block_alloc
name|PROTO
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|block_alloc
parameter_list|(
name|n
parameter_list|)
name|size_t
name|n
decl_stmt|;
block|{
name|struct
name|allocblock
modifier|*
name|blk
decl_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|allocblock
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|allocblock
argument_list|)
argument_list|)
expr_stmt|;
name|blk
operator|->
name|text
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|blk
operator|->
name|next
operator|=
name|blocks
expr_stmt|;
name|blocks
operator|=
name|blk
expr_stmt|;
return|return
name|blk
operator|->
name|text
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|block_free
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|block_free
parameter_list|()
block|{
name|struct
name|allocblock
modifier|*
name|p
decl_stmt|;
name|struct
name|allocblock
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|blocks
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|line
block|{
comment|/* Text of this line.  */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Length of this line, not counting \n if has_newline is true.  */
name|size_t
name|len
decl_stmt|;
comment|/* Version in which it was introduced.  */
name|RCSVers
modifier|*
name|vers
decl_stmt|;
comment|/* Nonzero if this line ends with \n.  This will always be true        except possibly for the last line.  */
name|int
name|has_newline
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linevector
block|{
comment|/* How many lines in use for this linevector?  */
name|unsigned
name|int
name|nlines
decl_stmt|;
comment|/* How many lines allocated for this linevector?  */
name|unsigned
name|int
name|lines_alloced
decl_stmt|;
comment|/* Pointer to array containing a pointer to each line.  */
name|struct
name|line
modifier|*
modifier|*
name|vector
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|linevector_init
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize *VEC to be a linevector with no lines.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_init
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
name|vec
operator|->
name|lines_alloced
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|linevector_add
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
name|vec
operator|,
name|char
operator|*
name|text
operator|,
name|size_t
name|len
operator|,
name|RCSVers
operator|*
name|vers
operator|,
name|unsigned
name|int
name|pos
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given some text TEXT, add each of its lines to VEC before line POS    (where line 0 is the first line).  The last line in TEXT may or may    not be \n terminated.  All \n in TEXT are changed to \0 (FIXME: I    don't think this is needed, or used, now that we have the ->len    field).  Set the version for each of the new lines to VERS.  This    function returns non-zero for success.  It returns zero if the line    number is out of range.  */
end_comment

begin_function
specifier|static
name|int
name|linevector_add
parameter_list|(
name|vec
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|,
name|vers
parameter_list|,
name|pos
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
block|{
name|char
modifier|*
name|textend
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|nnew
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|line
modifier|*
name|lines
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|textend
operator|=
name|text
operator|+
name|len
expr_stmt|;
comment|/* Count the number of lines we will need to add.  */
name|nnew
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
name|p
operator|<
name|textend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|&&
name|p
operator|+
literal|1
operator|<
name|textend
condition|)
operator|++
name|nnew
expr_stmt|;
comment|/* Allocate the struct line's.  */
name|lines
operator|=
name|block_alloc
argument_list|(
name|nnew
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand VEC->VECTOR if needed.  */
if|if
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
block|{
if|if
condition|(
name|vec
operator|->
name|lines_alloced
operator|==
literal|0
condition|)
name|vec
operator|->
name|lines_alloced
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|>=
name|vec
operator|->
name|lines_alloced
condition|)
name|vec
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|vec
operator|->
name|vector
operator|=
name|xrealloc
argument_list|(
name|vec
operator|->
name|vector
argument_list|,
name|vec
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|vec
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make room for the new lines in VEC->VECTOR.  */
for|for
control|(
name|i
operator|=
name|vec
operator|->
name|nlines
operator|+
name|nnew
operator|-
literal|1
init|;
name|i
operator|>=
name|pos
operator|+
name|nnew
condition|;
operator|--
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|-
name|nnew
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|vec
operator|->
name|nlines
condition|)
return|return
literal|0
return|;
comment|/* Actually add the lines, to LINES and VEC->VECTOR.  */
name|i
operator|=
name|pos
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|text
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|lines
index|[
literal|0
index|]
operator|.
name|has_newline
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
operator|++
index|]
operator|=
operator|&
name|lines
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
init|;
name|p
operator|<
name|textend
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|has_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|==
name|textend
condition|)
comment|/* If there are no characters beyond the last newline, we 		   don't consider it another line.  */
break|break;
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|text
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|text
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|lines
index|[
name|i
operator|-
name|pos
index|]
operator|.
name|has_newline
operator|=
literal|0
expr_stmt|;
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
operator|&
name|lines
index|[
name|i
operator|-
name|pos
index|]
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|lines
index|[
name|i
operator|-
name|pos
operator|-
literal|1
index|]
operator|.
name|text
expr_stmt|;
name|vec
operator|->
name|nlines
operator|+=
name|nnew
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_delete
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove NLINES lines from VEC at position POS (where line 0 is the    first line).  */
end_comment

begin_function
specifier|static
name|void
name|linevector_delete
parameter_list|(
name|vec
parameter_list|,
name|pos
parameter_list|,
name|nlines
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|unsigned
name|int
name|nlines
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
name|last
operator|=
name|vec
operator|->
name|nlines
operator|-
name|nlines
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pos
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
name|vec
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|vec
operator|->
name|vector
index|[
name|i
operator|+
name|nlines
index|]
expr_stmt|;
name|vec
operator|->
name|nlines
operator|-=
name|nlines
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_copy
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy FROM to TO, copying the vectors but not the lines pointed to.  */
end_comment

begin_function
specifier|static
name|void
name|linevector_copy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|linevector
modifier|*
name|to
decl_stmt|;
name|struct
name|linevector
modifier|*
name|from
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
block|{
if|if
condition|(
name|to
operator|->
name|lines_alloced
operator|==
literal|0
condition|)
name|to
operator|->
name|lines_alloced
operator|=
literal|10
expr_stmt|;
while|while
condition|(
name|from
operator|->
name|nlines
operator|>
name|to
operator|->
name|lines_alloced
condition|)
name|to
operator|->
name|lines_alloced
operator|*=
literal|2
expr_stmt|;
name|to
operator|->
name|vector
operator|=
operator|(
expr|struct
name|line
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|to
operator|->
name|lines_alloced
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|to
operator|->
name|vector
argument_list|,
name|from
operator|->
name|vector
argument_list|,
name|from
operator|->
name|nlines
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|to
operator|->
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|nlines
operator|=
name|from
operator|->
name|nlines
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|linevector_free
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free storage associated with linevector (that is, the vector but    not the lines pointed to).  */
end_comment

begin_function
specifier|static
name|void
name|linevector_free
parameter_list|(
name|vec
parameter_list|)
name|struct
name|linevector
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|vec
operator|->
name|vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vec
operator|->
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|month_printname
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a textual string giving the month (1-12), terminated with any    character not recognized by atoi, return the 3 character name to    print it with.  I do not think it is a good idea to change these    strings based on the locale; they are standard abbreviations (for    example in rfc822 mail messages) which should be widely understood.    Returns a pointer into static readonly storage.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|month_printname
parameter_list|(
name|month
parameter_list|)
name|char
modifier|*
name|month
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|int
name|mnum
decl_stmt|;
name|mnum
operator|=
name|atoi
argument_list|(
name|month
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnum
operator|<
literal|1
operator|||
name|mnum
operator|>
literal|12
condition|)
return|return
literal|"???"
return|;
return|return
operator|(
name|char
operator|*
operator|)
name|months
index|[
name|mnum
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|apply_rcs_changes
name|PROTO
argument_list|(
operator|(
expr|struct
name|linevector
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
specifier|const
name|char
operator|*
operator|,
name|RCSVers
operator|*
operator|,
name|RCSVers
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Apply changes to the line vector LINES.  DIFFBUF is a buffer of    length DIFFLEN holding the change text from an RCS file (the output    of diff -n).  NAME is used in error messages.  The VERS field of    any line added is set to ADDVERS.  The VERS field of any line    deleted is set to DELVERS, unless DELVERS is NULL, in which case    the VERS field of deleted lines is unchanged.  The function returns    non-zero if the change text is applied successfully.  It returns    zero if the change text does not appear to apply to LINES (e.g., a    line number is invalid).  If the change text is improperly    formatted (e.g., it is not the output of diff -n), the function    calls error with a status of 1, causing the program to exit.  */
end_comment

begin_function
specifier|static
name|int
name|apply_rcs_changes
parameter_list|(
name|lines
parameter_list|,
name|diffbuf
parameter_list|,
name|difflen
parameter_list|,
name|name
parameter_list|,
name|addvers
parameter_list|,
name|delvers
parameter_list|)
name|struct
name|linevector
modifier|*
name|lines
decl_stmt|;
specifier|const
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|size_t
name|difflen
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|RCSVers
modifier|*
name|addvers
decl_stmt|;
name|RCSVers
modifier|*
name|delvers
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|op
decl_stmt|;
comment|/* The RCS format throws us for a loop in that the deltafrags (if        we define a deltafrag as an add or a delete) need to be applied        in reverse order.  So we stick them into a linked list.  */
struct|struct
name|deltafrag
block|{
enum|enum
block|{
name|ADD
block|,
name|DELETE
block|}
name|type
enum|;
name|unsigned
name|long
name|pos
decl_stmt|;
name|unsigned
name|long
name|nlines
decl_stmt|;
name|char
modifier|*
name|new_lines
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|deltafrag
modifier|*
name|dfhead
decl_stmt|;
name|struct
name|deltafrag
modifier|*
name|df
decl_stmt|;
name|dfhead
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|diffbuf
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|<
name|diffbuf
operator|+
name|difflen
condition|;
control|)
block|{
name|op
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|!=
literal|'a'
operator|&&
name|op
operator|!=
literal|'d'
condition|)
comment|/* Can't just skip over the deltafrag, because the value 	       of op determines the syntax.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unrecognized operation '%c' in %s"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|df
operator|=
operator|(
expr|struct
name|deltafrag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deltafrag
argument_list|)
argument_list|)
expr_stmt|;
name|df
operator|->
name|next
operator|=
name|dfhead
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
name|df
operator|->
name|pos
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|' '
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"space expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|df
operator|->
name|nlines
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"number expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\012'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed expected in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'a'
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|df
operator|->
name|type
operator|=
name|ADD
expr_stmt|;
name|i
operator|=
name|df
operator|->
name|nlines
expr_stmt|;
comment|/* The text we want is the number of lines specified, or 	       until the end of the value, whichever comes first (it 	       will be the former except in the case where we are 	       adding a line which does not end in newline).  */
for|for
control|(
name|q
operator|=
name|p
init|;
name|i
operator|!=
literal|0
condition|;
operator|++
name|q
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'\n'
condition|)
operator|--
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|==
name|diffbuf
operator|+
name|difflen
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"premature end of change in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Copy the text we are adding into allocated space.  */
name|df
operator|->
name|new_lines
operator|=
name|block_alloc
argument_list|(
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|df
operator|->
name|new_lines
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|df
operator|->
name|len
operator|=
name|q
operator|-
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
comment|/* Correct for the fact that line numbers in RCS files 	       start with 1.  */
operator|--
name|df
operator|->
name|pos
expr_stmt|;
name|assert
argument_list|(
name|op
operator|==
literal|'d'
argument_list|)
expr_stmt|;
name|df
operator|->
name|type
operator|=
name|DELETE
expr_stmt|;
block|}
block|}
for|for
control|(
name|df
operator|=
name|dfhead
init|;
name|df
operator|!=
name|NULL
condition|;
control|)
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
switch|switch
condition|(
name|df
operator|->
name|type
condition|)
block|{
case|case
name|ADD
case|:
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
name|lines
argument_list|,
name|df
operator|->
name|new_lines
argument_list|,
name|df
operator|->
name|len
argument_list|,
name|addvers
argument_list|,
name|df
operator|->
name|pos
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|DELETE
case|:
if|if
condition|(
name|df
operator|->
name|pos
operator|>
name|lines
operator|->
name|nlines
operator|||
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
operator|>
name|lines
operator|->
name|nlines
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|delvers
operator|!=
name|NULL
condition|)
for|for
control|(
name|ln
operator|=
name|df
operator|->
name|pos
init|;
name|ln
operator|<
name|df
operator|->
name|pos
operator|+
name|df
operator|->
name|nlines
condition|;
operator|++
name|ln
control|)
name|lines
operator|->
name|vector
index|[
name|ln
index|]
operator|->
name|vers
operator|=
name|delvers
expr_stmt|;
name|linevector_delete
argument_list|(
name|lines
argument_list|,
name|df
operator|->
name|pos
argument_list|,
name|df
operator|->
name|nlines
argument_list|)
expr_stmt|;
break|break;
block|}
name|df
operator|=
name|df
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dfhead
argument_list|)
expr_stmt|;
name|dfhead
operator|=
name|df
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Apply an RCS change text to a buffer.  The function name starts    with rcs rather than RCS because this does not take an RCSNode    argument.  NAME is used in error messages.  TEXTBUF is the text    buffer to change, and TEXTLEN is the size.  DIFFBUF and DIFFLEN are    the change buffer and size.  The new buffer is returned in *RETBUF    and *RETLEN.  The new buffer is allocated by xmalloc.  The function    changes the contents of TEXTBUF.  This function returns 1 for    success.  On failure, it calls error and returns 0.  */
end_comment

begin_function
name|int
name|rcs_change_text
parameter_list|(
name|name
parameter_list|,
name|textbuf
parameter_list|,
name|textlen
parameter_list|,
name|diffbuf
parameter_list|,
name|difflen
parameter_list|,
name|retbuf
parameter_list|,
name|retlen
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|textbuf
decl_stmt|;
name|size_t
name|textlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|diffbuf
decl_stmt|;
name|size_t
name|difflen
decl_stmt|;
name|char
modifier|*
modifier|*
name|retbuf
decl_stmt|;
name|size_t
modifier|*
name|retlen
decl_stmt|;
block|{
name|struct
name|linevector
name|lines
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|*
name|retbuf
operator|=
name|NULL
expr_stmt|;
operator|*
name|retlen
operator|=
literal|0
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
operator|&
name|lines
argument_list|,
name|textbuf
argument_list|,
name|textlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot initialize line vector"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_rcs_changes
argument_list|(
operator|&
name|lines
argument_list|,
name|diffbuf
argument_list|,
name|difflen
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid change text in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|unsigned
name|int
name|ln
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|lines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
comment|/* 1 for \n */
name|n
operator|+=
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|retbuf
operator|=
name|p
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|lines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|lines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|has_newline
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|retlen
operator|=
name|p
operator|-
operator|*
name|retbuf
expr_stmt|;
name|assert
argument_list|(
operator|*
name|retlen
operator|<=
name|n
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|linevector_free
argument_list|(
operator|&
name|lines
argument_list|)
expr_stmt|;
comment|/* Note that this assumes that we have not called from anything        else which uses the block vectors.  FIXME: We could fix this by        saving and restoring the state of the block allocation code.  */
name|block_free
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Walk the deltas in RCS to get to revision VERSION.     If OP is RCS_ANNOTATE, then write annotations using cvs_output.     If OP is RCS_FETCH, then put the contents of VERSION into a    newly-malloc'd array and put a pointer to it in *TEXT.  Each line    is \n terminated; the caller is responsible for converting text    files if desired.  The total length is put in *LEN.     If FP is non-NULL, it should be a file descriptor open to the file    RCS with file position pointing to the deltas.  We close the file    when we are done.     If LOG is non-NULL, then *LOG is set to the log message of VERSION,    and *LOGLEN is set to the length of the log message.     On error, give a fatal error.  */
end_comment

begin_function
specifier|static
name|void
name|RCS_deltas
parameter_list|(
name|rcs
parameter_list|,
name|fp
parameter_list|,
name|version
parameter_list|,
name|op
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|,
name|log
parameter_list|,
name|loglen
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|enum
name|rcs_delta_op
name|op
decl_stmt|;
name|char
modifier|*
modifier|*
name|text
decl_stmt|;
name|size_t
modifier|*
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|log
decl_stmt|;
name|size_t
modifier|*
name|loglen
decl_stmt|;
block|{
name|char
modifier|*
name|branchversion
decl_stmt|;
name|char
modifier|*
name|cpversion
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|vallen
decl_stmt|;
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|RCSVers
modifier|*
name|prev_vers
decl_stmt|;
name|RCSVers
modifier|*
name|trunk_vers
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|ishead
decl_stmt|,
name|isnext
decl_stmt|,
name|isversion
decl_stmt|,
name|onbranch
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|struct
name|linevector
name|headlines
decl_stmt|;
name|struct
name|linevector
name|curlines
decl_stmt|;
name|struct
name|linevector
name|trunklines
decl_stmt|;
name|int
name|foundhead
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|NODELTA
condition|)
block|{
name|free_rcsnode_contents
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unable to reopen `%s'"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|rcs
operator|->
name|delta_pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot fseek RCS file"
argument_list|)
expr_stmt|;
block|}
block|}
name|ishead
operator|=
literal|1
expr_stmt|;
name|vers
operator|=
name|NULL
expr_stmt|;
name|prev_vers
operator|=
name|NULL
expr_stmt|;
name|trunk_vers
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|onbranch
operator|=
literal|0
expr_stmt|;
name|foundhead
operator|=
literal|0
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|linevector_init
argument_list|(
operator|&
name|trunklines
argument_list|)
expr_stmt|;
comment|/* We set BRANCHVERSION to the version we are currently looking        for.  Initially, this is the version on the trunk from which        VERSION branches off.  If VERSION is not a branch, then        BRANCHVERSION is just VERSION.  */
name|branchversion
operator|=
name|xstrdup
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|branchversion
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
operator|*
name|cpversion
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|getrcsrev
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|next
argument_list|,
name|key
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is not the next version we need.  It is a branch                version which we want to ignore.  */
name|isnext
operator|=
literal|0
expr_stmt|;
name|isversion
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|isnext
operator|=
literal|1
expr_stmt|;
comment|/* look up the revision */
name|node
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"mismatch in rcs file %s between deltas and deltatexts"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Stash the previous version.  */
name|prev_vers
operator|=
name|vers
expr_stmt|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|next
operator|=
name|vers
operator|->
name|next
expr_stmt|;
comment|/* Compare key and trunkversion now, because key points to 	       storage controlled by getrcskey.  */
if|if
condition|(
name|strcmp
argument_list|(
name|branchversion
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
name|isversion
operator|=
literal|1
expr_stmt|;
else|else
name|isversion
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|getrcskey
argument_list|(
name|fp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|vallen
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|log
operator|!=
name|NULL
operator|&&
name|isversion
operator|&&
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"log"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|branchversion
argument_list|,
name|version
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|log
operator|=
name|xmalloc
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|log
argument_list|,
name|value
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
operator|*
name|loglen
operator|=
name|vallen
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ishead
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|block_alloc
argument_list|(
name|vallen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|value
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linevector_add
argument_list|(
operator|&
name|curlines
argument_list|,
name|p
argument_list|,
name|vallen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid rcs file %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|ishead
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isnext
condition|)
block|{
if|if
condition|(
operator|!
name|apply_rcs_changes
argument_list|(
operator|&
name|curlines
argument_list|,
name|value
argument_list|,
name|vallen
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|onbranch
condition|?
name|vers
else|:
name|NULL
argument_list|,
name|onbranch
condition|?
name|NULL
else|:
name|prev_vers
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid change text in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|l_error
goto|;
if|if
condition|(
name|isversion
condition|)
block|{
comment|/* This is either the version we want, or it is the                branchpoint to the version we want.  */
if|if
condition|(
name|strcmp
argument_list|(
name|branchversion
argument_list|,
name|version
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is the version we want.  */
name|linevector_copy
argument_list|(
operator|&
name|headlines
argument_list|,
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|foundhead
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|onbranch
condition|)
block|{
comment|/* We have found this version by tracking up a                        branch.  Restore back to the lines we saved                        when we left the trunk, and continue tracking                        down the trunk.  */
name|onbranch
operator|=
literal|0
expr_stmt|;
name|vers
operator|=
name|trunk_vers
expr_stmt|;
name|next
operator|=
name|vers
operator|->
name|next
expr_stmt|;
name|linevector_copy
argument_list|(
operator|&
name|curlines
argument_list|,
operator|&
name|trunklines
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* We need to look up the branch.  */
name|onbranch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|branchversion
argument_list|)
operator|<
literal|2
condition|)
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
comment|/* We are leaving the trunk; save the current                        lines so that we can restore them when we                        continue tracking down the trunk.  */
name|trunk_vers
operator|=
name|vers
expr_stmt|;
name|linevector_copy
argument_list|(
operator|&
name|trunklines
argument_list|,
operator|&
name|curlines
argument_list|)
expr_stmt|;
comment|/* Reset the version information we have                        accumulated so far.  It only applies to the                        changes from the head to this version.  */
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|curlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
name|curlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* The next version we want is the entry on                    VERS->branches which matches this branch.  For                    example, suppose VERSION is 1.21.4.3 and                    BRANCHVERSION was 1.21.  Then we look for an entry                    starting with "1.21.4" and we'll put it (probably                    1.21.4.1) in NEXT.  We'll advance BRANCHVERSION by                    two dots (in this example, to 1.21.4.3).  */
if|if
condition|(
name|vers
operator|->
name|branches
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing expected branches in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|cpversion
operator|=
literal|'.'
expr_stmt|;
operator|++
name|cpversion
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"version number confusion in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vers
operator|->
name|branches
operator|->
name|list
operator|->
name|next
init|;
name|p
operator|!=
name|vers
operator|->
name|branches
operator|->
name|list
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|branchversion
argument_list|,
name|cpversion
operator|-
name|branchversion
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|vers
operator|->
name|branches
operator|->
name|list
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing expected branch in %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|cpversion
operator|=
name|strchr
argument_list|(
name|cpversion
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpversion
operator|!=
name|NULL
condition|)
operator|*
name|cpversion
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|==
name|RCS_FETCH
operator|&&
name|foundhead
condition|)
break|break;
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
name|free
argument_list|(
name|branchversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundhead
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not find desired version %s in %s"
argument_list|,
name|version
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Now print out or return the data we have just computed.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RCS_ANNOTATE
case|:
block|{
name|unsigned
name|int
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* Period which separates year from month in date.  */
name|char
modifier|*
name|ym
decl_stmt|;
comment|/* Period which separates month from day in date.  */
name|char
modifier|*
name|md
decl_stmt|;
name|RCSVers
modifier|*
name|prvers
decl_stmt|;
name|prvers
operator|=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|vers
expr_stmt|;
if|if
condition|(
name|prvers
operator|==
name|NULL
condition|)
name|prvers
operator|=
name|vers
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%-12s (%-8.8s "
argument_list|,
name|prvers
operator|->
name|version
argument_list|,
name|prvers
operator|->
name|author
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now output the date.  */
name|ym
operator|=
name|strchr
argument_list|(
name|prvers
operator|->
name|date
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ym
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"?\?-??\?-??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|md
operator|=
name|strchr
argument_list|(
name|ym
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"??"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cvs_output
argument_list|(
name|md
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|month_printname
argument_list|(
name|ym
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Only output the last two digits of the year.  Our output 			   lines are long enough as it is without printing the 			   century.  */
name|cvs_output
argument_list|(
name|ym
operator|-
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"): "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RCS_FETCH
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|unsigned
name|int
name|ln
decl_stmt|;
name|assert
argument_list|(
name|text
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
comment|/* 1 for \n */
name|n
operator|+=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|text
operator|=
name|p
expr_stmt|;
for|for
control|(
name|ln
operator|=
literal|0
init|;
name|ln
operator|<
name|headlines
operator|.
name|nlines
condition|;
operator|++
name|ln
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|text
argument_list|,
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|headlines
operator|.
name|vector
index|[
name|ln
index|]
operator|->
name|has_newline
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|p
operator|-
operator|*
name|text
expr_stmt|;
name|assert
argument_list|(
operator|*
name|len
operator|<=
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|linevector_free
argument_list|(
operator|&
name|curlines
argument_list|)
expr_stmt|;
name|linevector_free
argument_list|(
operator|&
name|headlines
argument_list|)
expr_stmt|;
name|linevector_free
argument_list|(
operator|&
name|trunklines
argument_list|)
expr_stmt|;
name|block_free
argument_list|()
expr_stmt|;
return|return;
name|l_error
label|:
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s does not appear to be a valid rcs file"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Annotate command.  In rcs.c for historical reasons (from back when    what is now RCS_deltas was part of annotate_fileproc).  */
end_comment

begin_comment
comment|/* Options from the command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|annotate_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|annotate_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
literal|0
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
name|version
operator|=
name|RCS_getversion
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Distinguish output for various files if we are processing        several files.  */
name|cvs_outerr
argument_list|(
literal|"Annotations for "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n***************\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RCS_deltas
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|fp
argument_list|,
name|version
argument_list|,
name|RCS_ANNOTATE
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|annotate_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lRf] [-r rev|-D date] [files...]\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-f\tUse head revision if tag/date not found.\n"
block|,
literal|"\t-r rev\tAnnotate file as of specified revision/tag.\n"
block|,
literal|"\t-D date\tAnnotate file as of specified date.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command to show the revision, date, and author where each line of a    file was modified.  */
end_comment

begin_function
name|int
name|annotate
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+lr:D:fR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|annotate_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"annotate\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
return|return
name|start_recursion
argument_list|(
name|annotate_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|RCS_setlocalid
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|copy
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|next
operator|=
name|copy
expr_stmt|;
name|key
operator|=
name|strtok
argument_list|(
name|next
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|keywords
index|[
name|KEYWORD_LOCALID
index|]
operator|.
name|string
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|keywords
index|[
name|KEYWORD_LOCALID
index|]
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|keywords
index|[
name|KEYWORD_LOCALID
index|]
operator|.
name|expandit
operator|=
literal|1
expr_stmt|;
comment|/* options? */
while|while
condition|(
name|key
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|keywords
index|[
name|KEYWORD_ID
index|]
operator|.
name|string
argument_list|)
condition|)
name|keyword_local
operator|=
name|KEYWORD_ID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|keywords
index|[
name|KEYWORD_HEADER
index|]
operator|.
name|string
argument_list|)
condition|)
name|keyword_local
operator|=
name|KEYWORD_HEADER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|keywords
index|[
name|KEYWORD_CVSHEADER
index|]
operator|.
name|string
argument_list|)
condition|)
name|keyword_local
operator|=
name|KEYWORD_CVSHEADER
expr_stmt|;
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Unknown LocalId mode: %s"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RCS_setincexc
parameter_list|(
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|include
init|=
literal|0
decl_stmt|;
name|struct
name|rcs_keyword
modifier|*
name|keyword
decl_stmt|;
name|copy
operator|=
name|xstrdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|next
operator|=
name|copy
expr_stmt|;
switch|switch
condition|(
operator|*
name|next
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|include
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|include
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|include
condition|)
for|for
control|(
name|keyword
operator|=
name|keywords
init|;
name|keyword
operator|->
name|string
operator|!=
name|NULL
condition|;
name|keyword
operator|++
control|)
block|{
name|keyword
operator|->
name|expandit
operator|=
literal|0
expr_stmt|;
block|}
name|key
operator|=
name|strtok
argument_list|(
name|next
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|key
condition|)
block|{
for|for
control|(
name|keyword
operator|=
name|keywords
init|;
name|keyword
operator|->
name|string
operator|!=
name|NULL
condition|;
name|keyword
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|keyword
operator|->
name|string
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
name|keyword
operator|->
name|expandit
operator|=
name|include
expr_stmt|;
block|}
name|key
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|ATTIC
value|"/" CVSATTIC
end_define

begin_function
specifier|static
name|char
modifier|*
name|getfullCVSname
parameter_list|(
name|CVSname
parameter_list|,
name|pathstore
parameter_list|)
name|char
modifier|*
name|CVSname
decl_stmt|,
decl|*
modifier|*
name|pathstore
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|CVSroot_directory
condition|)
block|{
name|int
name|rootlen
decl_stmt|;
name|char
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|alen
init|=
sizeof|sizeof
argument_list|(
name|ATTIC
argument_list|)
operator|-
literal|1
decl_stmt|;
operator|*
name|pathstore
operator|=
name|xstrdup
argument_list|(
name|CVSname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|strrchr
argument_list|(
operator|*
name|pathstore
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|c
operator|-
operator|*
name|pathstore
operator|>=
name|alen
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|c
operator|-
name|alen
argument_list|,
name|ATTIC
argument_list|,
name|alen
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
condition|)
block|{
operator|*
operator|(
name|c
operator|-
name|alen
operator|)
operator|=
operator|*
name|c
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|c
operator|-
name|alen
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
name|rootlen
operator|=
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|pathstore
argument_list|,
name|CVSroot_directory
argument_list|,
name|rootlen
argument_list|)
operator|&&
operator|(
operator|*
name|pathstore
operator|)
index|[
name|rootlen
index|]
operator|==
literal|'/'
condition|)
name|CVSname
operator|=
operator|(
operator|*
name|pathstore
operator|+
name|rootlen
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|CVSname
operator|=
operator|(
operator|*
name|pathstore
operator|)
expr_stmt|;
block|}
return|return
name|CVSname
return|;
block|}
end_block

end_unit

