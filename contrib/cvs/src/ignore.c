begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/*  * .cvsignore file support contributed by David G. Grubbs<dgg@odi.com>  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/*  * Ignore file section.  *   *	"!" may be included any time to reset the list (i.e. ignore nothing);  *	"*" may be specified to ignore everything.  It stays as the first  *	    element forever, unless a "!" clears it out.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|ign_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of files to ignore in update 					 * and import */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|s_ign_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ign_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of active entries */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s_ign_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ign_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This many slots available (plus 					 * one for a NULL) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ign_hold
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index where first "temporary" item 					 * is held */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ign_default
init|=
literal|". .. core RCSLOG tags TAGS RCS SCCS .make.state\  .nse_depinfo #* .#* cvslog.* ,* CVS CVS.adm .del-* *.a *.olb *.o *.obj\  *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej *.exe _$* *$"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGN_GROW
value|16
end_define

begin_comment
comment|/* grow the list by 16 elements at a 					 * time */
end_comment

begin_comment
comment|/* Nonzero if we have encountered an -I ! directive, which means one should    no longer ask the server about what is in CVSROOTADM_IGNORE.  */
end_comment

begin_decl_stmt
name|int
name|ign_inhibit_server
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To the "ignore list", add the hard-coded default ignored wildcards above,  * the wildcards found in $CVSROOT/CVSROOT/cvsignore, the wildcards found in  * ~/.cvsignore and the wildcards found in the CVSIGNORE environment  * variable.  */
end_comment

begin_function
name|void
name|ign_setup
parameter_list|()
block|{
name|char
modifier|*
name|home_dir
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|ign_inhibit_server
operator|=
literal|0
expr_stmt|;
comment|/* Start with default list and special case */
name|tmp
operator|=
name|xstrdup
argument_list|(
name|ign_default
argument_list|)
expr_stmt|;
name|ign_add
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* The client handles another way, by (after it does its own ignore file        processing, and only if !ign_inhibit_server), letting the server        know about the files and letting it decide whether to ignore        them based on CVSROOOTADM_IGNORE.  */
if|if
condition|(
operator|!
name|client_active
condition|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|file
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_IGNORE
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
comment|/* Then add entries found in repository, if it exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_IGNORE
argument_list|)
expr_stmt|;
name|ign_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Then add entries found in home dir, (if user has one) and file exists */
name|home_dir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
comment|/* If we can't find a home directory, ignore ~/.cvsignore.  This may        make tracking down problems a bit of a pain, but on the other        hand it might be obnoxious to complain when CVS will function        just fine without .cvsignore (and many users won't even know what        .cvsignore is).  */
if|if
condition|(
name|home_dir
condition|)
block|{
name|char
modifier|*
name|file
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|home_dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSDOTIGNORE
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|home_dir
argument_list|,
name|CVSDOTIGNORE
argument_list|)
expr_stmt|;
name|ign_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Then add entries found in CVSIGNORE environment variable. */
name|ign_add
argument_list|(
name|getenv
argument_list|(
name|IGNORE_ENV
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Later, add ignore entries found in -I arguments */
block|}
end_function

begin_comment
comment|/*  * Open a file and read lines, feeding each line to a line parser. Arrange  * for keeping a temporary list of wildcards at the end, if the "hold"  * argument is set.  */
end_comment

begin_function
name|void
name|ign_add_file
parameter_list|(
name|file
parameter_list|,
name|hold
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|hold
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
comment|/* restore the saved list (if any) */
if|if
condition|(
name|s_ign_list
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s_ign_count
condition|;
name|i
operator|++
control|)
name|ign_list
index|[
name|i
index|]
operator|=
name|s_ign_list
index|[
name|i
index|]
expr_stmt|;
name|ign_count
operator|=
name|s_ign_count
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
name|s_ign_count
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|s_ign_list
argument_list|)
expr_stmt|;
name|s_ign_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* is this a temporary ignore file? */
if|if
condition|(
name|hold
condition|)
block|{
comment|/* re-set if we had already done a temporary file */
if|if
condition|(
name|ign_hold
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ign_hold
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_count
operator|=
name|ign_hold
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ign_hold
operator|=
name|ign_count
expr_stmt|;
block|}
block|}
comment|/* load the file */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
name|ign_add
argument_list|(
name|line
argument_list|,
name|hold
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a line of space-separated wildcards and add them to the list. */
end_comment

begin_function
name|void
name|ign_add
parameter_list|(
name|ign
parameter_list|,
name|hold
parameter_list|)
name|char
modifier|*
name|ign
decl_stmt|;
name|int
name|hold
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ign
operator|||
operator|!
operator|*
name|ign
condition|)
return|return;
for|for
control|(
init|;
operator|*
name|ign
condition|;
name|ign
operator|++
control|)
block|{
name|char
modifier|*
name|mark
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* ignore whitespace before the token */
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ign
argument_list|)
condition|)
continue|continue;
comment|/* 	 * if we find a single character !, we must re-set the ignore list 	 * (saving it if necessary).  We also catch * as a special case in a 	 * global ignore file as an optimization 	 */
if|if
condition|(
operator|(
operator|!
operator|*
operator|(
name|ign
operator|+
literal|1
operator|)
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|ign
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|ign
operator|==
literal|'!'
operator|||
operator|*
name|ign
operator|==
literal|'*'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hold
condition|)
block|{
comment|/* permanently reset the ignore list */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_count
operator|=
literal|0
expr_stmt|;
name|ign_list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* if we are doing a '!', continue; otherwise add the '*' */
if|if
condition|(
operator|*
name|ign
operator|==
literal|'!'
condition|)
block|{
name|ign_inhibit_server
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|ign
operator|==
literal|'!'
condition|)
block|{
comment|/* temporarily reset the ignore list */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ign_hold
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ign_hold
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_hold
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|s_ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ign_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|s_ign_list
index|[
name|i
index|]
operator|=
name|ign_list
index|[
name|i
index|]
expr_stmt|;
name|s_ign_count
operator|=
name|ign_count
expr_stmt|;
name|ign_count
operator|=
literal|0
expr_stmt|;
name|ign_list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we have used up all the space, add some more */
if|if
condition|(
name|ign_count
operator|>=
name|ign_size
condition|)
block|{
name|ign_size
operator|+=
name|IGN_GROW
expr_stmt|;
name|ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ign_list
argument_list|,
operator|(
name|ign_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* find the end of this token */
for|for
control|(
name|mark
operator|=
name|ign
init|;
operator|*
name|mark
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|mark
argument_list|)
condition|;
name|mark
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|save
operator|=
operator|*
name|mark
expr_stmt|;
operator|*
name|mark
operator|=
literal|'\0'
expr_stmt|;
name|ign_list
index|[
name|ign_count
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|ign
argument_list|)
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|mark
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|save
condition|)
name|ign
operator|=
name|mark
expr_stmt|;
else|else
name|ign
operator|=
name|mark
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set to 1 if filenames should be matched in a case-insensitive    fashion.  Note that, contrary to the name and placement in ignore.c,    this is no longer just for ignore patterns.  */
end_comment

begin_decl_stmt
name|int
name|ign_case
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if the given filename should be ignored by update or import. */
end_comment

begin_function
name|int
name|ign_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|cpp
init|=
name|ign_list
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ign_case
condition|)
block|{
comment|/* We do a case-insensitive match by calling fnmatch on copies of 	   the pattern and the name which have been converted to 	   lowercase.  FIXME: would be much cleaner to just unify this 	   with the other case-insensitive fnmatch stuff (FOLD_FN_CHAR 	   in lib/fnmatch.c; os2_fnmatch in emx/system.c).  */
name|char
modifier|*
name|name_lower
decl_stmt|;
name|char
modifier|*
name|pat_lower
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|name_lower
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name_lower
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cpp
condition|)
block|{
name|pat_lower
operator|=
name|xstrdup
argument_list|(
operator|*
name|cpp
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pat_lower
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|pat_lower
argument_list|,
name|name_lower
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|matched
goto|;
name|free
argument_list|(
name|pat_lower
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name_lower
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|matched
label|:
name|free
argument_list|(
name|name_lower
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pat_lower
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|cpp
condition|)
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
operator|*
name|cpp
operator|++
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: This list of dirs to ignore stuff seems not to be used.    Really?  send_dirent_proc and update_dirent_proc both call    ignore_directory and do_module calls ign_dir_add.  No doubt could    use some documentation/testsuite work.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dir_ign_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dir_ign_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dir_ign_current
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a directory to list of dirs to ignore.  */
end_comment

begin_function
name|void
name|ign_dir_add
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Make sure we've got the space for the entry.  */
if|if
condition|(
name|dir_ign_current
operator|<=
name|dir_ign_max
condition|)
block|{
name|dir_ign_max
operator|+=
name|IGN_GROW
expr_stmt|;
name|dir_ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dir_ign_list
argument_list|,
operator|(
name|dir_ign_max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dir_ign_list
index|[
name|dir_ign_current
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if NAME is part of the list of directories to ignore.  */
end_comment

begin_function
name|int
name|ignore_directory
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dir_ign_list
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|dir_ign_current
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|dir_ign_list
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|dir_ign_list
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Process the current directory, looking for files not in ILIST and  * not on the global ignore list for this directory.  If we find one,  * call PROC passing it the name of the file and the update dir.  * ENTRIES is the entries list, which is used to identify known  * directories.  ENTRIES may be NULL, in which case we assume that any  * directory with a CVS administration directory is known.  */
end_comment

begin_function
name|void
name|ignore_files
parameter_list|(
name|ilist
parameter_list|,
name|entries
parameter_list|,
name|update_dir
parameter_list|,
name|proc
parameter_list|)
name|List
modifier|*
name|ilist
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|Ignore_proc
name|proc
decl_stmt|;
block|{
name|int
name|subdirs
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
comment|/* Set SUBDIRS if we have subdirectory information in ENTRIES.  */
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
name|subdirs
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|entries
operator|->
name|list
operator|->
name|data
expr_stmt|;
name|subdirs
operator|=
name|sdtp
operator|==
name|NULL
operator|||
name|sdtp
operator|->
name|subdirs
expr_stmt|;
block|}
comment|/* we get called with update_dir set to "." sometimes... strip it */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|xdir
operator|=
literal|""
expr_stmt|;
else|else
name|xdir
operator|=
name|update_dir
expr_stmt|;
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open current directory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrap_add_file
argument_list|(
name|CVSDOTWRAPPER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|file
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|continue_loop
goto|;
if|if
condition|(
name|findnode_fn
argument_list|(
name|ilist
argument_list|,
name|file
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|continue_loop
goto|;
if|if
condition|(
name|subdirs
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|findnode_fn
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
operator|)
operator|->
name|type
operator|==
name|ENT_SUBDIR
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* For consistency with past behaviour, we only ignore 		   this directory if there is a CVS subdirectory. 		   This will normally be the case, but the user may 		   have messed up the working directory somehow.  */
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
name|CVSADM
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s/%s"
argument_list|,
name|file
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|dir
operator|=
name|isdir
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
goto|goto
name|continue_loop
goto|;
block|}
block|}
comment|/* We could be ignoring FIFOs and other files which are neither 	   regular files nor directories here.  */
if|if
condition|(
name|ign_name
argument_list|(
name|file
argument_list|)
condition|)
goto|goto
name|continue_loop
goto|;
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|||
endif|#
directive|endif
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_DIR
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
else|#
directive|else
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|subdirs
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|file
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|continue_loop
goto|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|S_ISLNK
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
else|#
directive|else
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
condition|)
block|{
goto|goto
name|continue_loop
goto|;
block|}
endif|#
directive|endif
block|}
call|(
modifier|*
name|proc
call|)
argument_list|(
name|file
argument_list|,
name|xdir
argument_list|)
expr_stmt|;
name|continue_loop
label|:
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error reading current directory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

