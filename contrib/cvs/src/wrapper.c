begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/*   Original Author:  athan@morgan.com<Andrew C. Athan> 2/1/94   Modified By:      vdemarco@bou.shl.com    This package was written to support the NEXTSTEP concept of   "wrappers."  These are essentially directories that are to be   treated as "files."  This package allows such wrappers to be   "processed" on the way in and out of CVS.  The intended use is to   wrap up a wrapper into a single tar, such that that tar can be   treated as a single binary file in CVS.  To solve the problem   effectively, it was also necessary to be able to prevent rcsmerge   application at appropriate times.    ------------------   Format of wrapper file ($CVSROOT/CVSROOT/cvswrappers or .cvswrappers)    wildcard	[option value][option value]...    where option is one of   -f		from cvs filter		value: path to filter   -t		to cvs filter		value: path to filter   -m		update methodology	value: MERGE or COPY   -k		default -k rcs option to use on import or add    and value is a single-quote delimited value.    E.g:   *.nib		-f 'gunzipuntar' -t 'targzip' -m 'COPY' */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|wildCard
decl_stmt|;
name|char
modifier|*
name|tocvsFilter
decl_stmt|;
name|char
modifier|*
name|fromcvsFilter
decl_stmt|;
name|char
modifier|*
name|rcsOption
decl_stmt|;
name|WrapMergeMethod
name|mergeMethod
decl_stmt|;
block|}
name|WrapperEntry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WrapperEntry
modifier|*
modifier|*
name|wrap_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WrapperEntry
modifier|*
modifier|*
name|wrap_saved_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_tempcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: the relationship between wrap_count, wrap_tempcount,  * wrap_saved_count, and wrap_saved_tempcount is not entirely clear;  * it is certainly suspicious that wrap_saved_count is never set to a  * value other than zero!  If the variable isn't being used, it should  * be removed.  And in general, we should describe how temporary  * vs. permanent wrappers are implemented, and then make sure the  * implementation is actually doing that.  *  * Right now things seem to be working, but that's no guarantee there  * isn't a bug lurking somewhere in the murk.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_saved_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_saved_tempcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPPER_GROW
value|8
end_define

begin_decl_stmt
name|void
name|wrap_add_entry
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|,
name|int
name|temp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_kill
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_kill_temp
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_free_entry
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_free_entry_internal
name|PROTO
argument_list|(
operator|(
name|WrapperEntry
operator|*
name|e
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|wrap_restore_saved
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|wrap_setup
parameter_list|()
block|{
comment|/* FIXME-reentrancy: if we do a multithreaded server, will need to        move this to a per-connection data structure, or better yet        think about a cleaner solution.  */
specifier|static
name|int
name|wrap_setup_already_done
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|;
if|if
condition|(
name|wrap_setup_already_done
operator|!=
literal|0
condition|)
return|return;
else|else
name|wrap_setup_already_done
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|client_active
condition|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_WRAPPER
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* Then add entries found in repository, if it exists.  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_WRAPPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|wrap_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Then add entries found in home dir, (if user has one) and file        exists.  */
name|homedir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
comment|/* If we can't find a home directory, ignore ~/.cvswrappers.  This may        make tracking down problems a bit of a pain, but on the other        hand it might be obnoxious to complain when CVS will function        just fine without .cvswrappers (and many users won't even know what        .cvswrappers is).  */
if|if
condition|(
name|homedir
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|file
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSDOTWRAPPER
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|homedir
argument_list|,
name|CVSDOTWRAPPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|wrap_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: calling wrap_add() below implies that the CVSWRAPPERS      * environment variable contains exactly one "wrapper" -- a line      * of the form      *       *    FILENAME_PATTERN	FLAG  OPTS [ FLAG OPTS ...]      *      * This may disagree with the documentation, which states:      *       *   `$CVSWRAPPERS'      *      A whitespace-separated list of file name patterns that CVS      *      should treat as wrappers. *Note Wrappers::.      *      * Does this mean the environment variable can hold multiple      * wrappers lines?  If so, a single call to wrap_add() is      * insufficient.      */
comment|/* Then add entries found in CVSWRAPPERS environment variable. */
name|wrap_add
argument_list|(
name|getenv
argument_list|(
name|WRAPPER_ENV
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* Send -W arguments for the wrappers to the server.  The command must    be one that accepts them (e.g. update, import).  */
end_comment

begin_function
name|void
name|wrap_send
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wrap_count
operator|+
name|wrap_tempcount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|tocvsFilter
operator|!=
name|NULL
operator|||
name|wrap_list
index|[
name|i
index|]
operator|->
name|fromcvsFilter
operator|!=
name|NULL
condition|)
comment|/* For greater studliness we would print the offending option 	       and (more importantly) where we found it.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ -t and -f wrapper options are not supported remotely; ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|mergeMethod
operator|==
name|WRAP_COPY
condition|)
comment|/* For greater studliness we would print the offending option 	       and (more importantly) where we found it.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ -m wrapper option is not supported remotely; ignored"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|rcsOption
operator|!=
name|NULL
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Argument -W\012Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|wildCard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|" -k '"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|rcsOption
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"'\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* Output wrapper entries in the format of cvswrappers lines.  *  * This is useful when one side of a client/server connection wants to  * send its wrappers to the other; since the receiving side would like  * to use wrap_add() to incorporate the wrapper, it's best if the  * entry arrives in this format.  *  * The entries are stored in `line', which is allocated here.  Caller  * can free() it.  *  * If first_call_p is nonzero, then start afresh.  */
end_comment

begin_function
name|void
name|wrap_unparse_rcs_options
parameter_list|(
name|line
parameter_list|,
name|first_call_p
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
name|int
name|first_call_p
decl_stmt|;
block|{
comment|/* FIXME-reentrancy: we should design a reentrant interface, like        a callback which gets handed each wrapper (a multithreaded        server being the most concrete reason for this, but the        non-reentrant interface is fairly unnecessary/ugly).  */
specifier|static
name|int
name|i
decl_stmt|;
if|if
condition|(
name|first_call_p
condition|)
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|wrap_count
operator|+
name|wrap_tempcount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|rcsOption
operator|!=
name|NULL
condition|)
block|{
operator|*
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|wildCard
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"\t"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" -k '"
argument_list|)
operator|+
name|strlen
argument_list|(
name|wrap_list
index|[
name|i
index|]
operator|->
name|rcsOption
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"'"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* leave room for '\0' */
name|strcpy
argument_list|(
operator|*
name|line
argument_list|,
name|wrap_list
index|[
name|i
index|]
operator|->
name|wildCard
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|line
argument_list|,
literal|" -k '"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|line
argument_list|,
name|wrap_list
index|[
name|i
index|]
operator|->
name|rcsOption
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|*
name|line
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
comment|/* We're going to miss the increment because we return, so                do it by hand. */
operator|++
name|i
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT || CLIENT_SUPPORT */
end_comment

begin_comment
comment|/*  * Open a file and read lines, feeding each line to a line parser. Arrange  * for keeping a temporary list of wrappers at the end, if the "temp"  * argument is set.  */
end_comment

begin_function
name|void
name|wrap_add_file
parameter_list|(
name|file
parameter_list|,
name|temp
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|temp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|wrap_restore_saved
argument_list|()
expr_stmt|;
name|wrap_kill_temp
argument_list|()
expr_stmt|;
comment|/* Load the file.  */
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
name|wrap_add
argument_list|(
name|line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_kill
parameter_list|()
block|{
name|wrap_kill_temp
argument_list|()
expr_stmt|;
while|while
condition|(
name|wrap_count
condition|)
name|wrap_free_entry
argument_list|(
name|wrap_list
index|[
operator|--
name|wrap_count
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_kill_temp
parameter_list|()
block|{
name|WrapperEntry
modifier|*
modifier|*
name|temps
init|=
name|wrap_list
operator|+
name|wrap_count
decl_stmt|;
while|while
condition|(
name|wrap_tempcount
condition|)
name|wrap_free_entry
argument_list|(
name|temps
index|[
operator|--
name|wrap_tempcount
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_free_entry
parameter_list|(
name|e
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
block|{
name|wrap_free_entry_internal
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_free_entry_internal
parameter_list|(
name|e
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
block|{
name|free
argument_list|(
name|e
operator|->
name|wildCard
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tocvsFilter
condition|)
name|free
argument_list|(
name|e
operator|->
name|tocvsFilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|fromcvsFilter
condition|)
name|free
argument_list|(
name|e
operator|->
name|fromcvsFilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|rcsOption
condition|)
name|free
argument_list|(
name|e
operator|->
name|rcsOption
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_restore_saved
parameter_list|()
block|{
if|if
condition|(
operator|!
name|wrap_saved_list
condition|)
return|return;
name|wrap_kill
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wrap_list
argument_list|)
expr_stmt|;
name|wrap_list
operator|=
name|wrap_saved_list
expr_stmt|;
name|wrap_count
operator|=
name|wrap_saved_count
expr_stmt|;
name|wrap_tempcount
operator|=
name|wrap_saved_tempcount
expr_stmt|;
name|wrap_saved_list
operator|=
name|NULL
expr_stmt|;
name|wrap_saved_count
operator|=
literal|0
expr_stmt|;
name|wrap_saved_tempcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_add
parameter_list|(
name|line
parameter_list|,
name|isTemp
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|isTemp
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|char
name|ctemp
decl_stmt|;
name|WrapperEntry
name|e
decl_stmt|;
name|char
name|opt
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search for the wild card */
while|while
condition|(
operator|*
name|line
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
operator|++
name|line
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|line
init|;
operator|*
name|line
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|;
operator|++
name|line
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|==
name|line
condition|)
return|return;
name|ctemp
operator|=
operator|*
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|.
name|wildCard
operator|=
name|xstrdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|ctemp
expr_stmt|;
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* Search for the option */
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'-'
condition|)
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
operator|++
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
name|opt
operator|=
operator|*
name|line
expr_stmt|;
comment|/* Search for the filter commandline */
for|for
control|(
operator|++
name|line
init|;
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'\''
condition|;
operator|++
name|line
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
for|for
control|(
name|temp
operator|=
operator|++
name|line
init|;
operator|*
name|line
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|'\''
operator|||
name|line
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|;
operator|++
name|line
control|)
empty_stmt|;
comment|/* This used to "break;" (ignore the option) if there was a 	   single character between the single quotes (I'm guessing 	   that was accidental).  Now it "break;"s if there are no 	   characters.  I'm not sure either behavior is particularly 	   necessary--the current options might not require '' 	   arguments, but surely some future option legitimately 	   might.  Also I'm not sure that ignoring the option is a 	   swift way to handle syntax errors in general.  */
if|if
condition|(
name|line
operator|==
name|temp
condition|)
break|break;
name|ctemp
operator|=
operator|*
name|line
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* Before this is reenabled, need to address the problem in 	       commit.c (see http://www.cyclic.com/cvs/dev-wrap.txt).  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-t/-f wrappers not supported by this version of CVS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|fromcvsFilter
condition|)
name|free
argument_list|(
name|e
operator|.
name|fromcvsFilter
argument_list|)
expr_stmt|;
comment|/* FIXME: error message should say where the bad value 	       came from.  */
name|e
operator|.
name|fromcvsFilter
operator|=
name|expand_path
argument_list|(
name|temp
argument_list|,
literal|"<wrapper>"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|fromcvsFilter
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Correct above errors first"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Before this is reenabled, need to address the problem in 	       commit.c (see http://www.cyclic.com/cvs/dev-wrap.txt).  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-t/-f wrappers not supported by this version of CVS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|tocvsFilter
condition|)
name|free
argument_list|(
name|e
operator|.
name|tocvsFilter
argument_list|)
expr_stmt|;
comment|/* FIXME: error message should say where the bad value 	       came from.  */
name|e
operator|.
name|tocvsFilter
operator|=
name|expand_path
argument_list|(
name|temp
argument_list|,
literal|"<wrapper>"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|.
name|tocvsFilter
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Correct above errors first"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|*
name|temp
operator|==
literal|'C'
operator|||
operator|*
name|temp
operator|==
literal|'c'
condition|)
name|e
operator|.
name|mergeMethod
operator|=
name|WRAP_COPY
expr_stmt|;
else|else
name|e
operator|.
name|mergeMethod
operator|=
name|WRAP_MERGE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|e
operator|.
name|rcsOption
condition|)
name|free
argument_list|(
name|e
operator|.
name|rcsOption
argument_list|)
expr_stmt|;
name|e
operator|.
name|rcsOption
operator|=
name|xstrdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|line
operator|=
name|ctemp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
break|break;
operator|++
name|line
expr_stmt|;
block|}
name|wrap_add_entry
argument_list|(
operator|&
name|e
argument_list|,
name|isTemp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrap_add_entry
parameter_list|(
name|e
parameter_list|,
name|temp
parameter_list|)
name|WrapperEntry
modifier|*
name|e
decl_stmt|;
name|int
name|temp
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|wrap_count
operator|+
name|wrap_tempcount
operator|>=
name|wrap_size
condition|)
block|{
name|wrap_size
operator|+=
name|WRAPPER_GROW
expr_stmt|;
name|wrap_list
operator|=
operator|(
name|WrapperEntry
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wrap_list
argument_list|,
name|wrap_size
operator|*
sizeof|sizeof
argument_list|(
name|WrapperEntry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|temp
operator|&&
name|wrap_tempcount
condition|)
block|{
for|for
control|(
name|x
operator|=
name|wrap_count
operator|+
name|wrap_tempcount
operator|-
literal|1
init|;
name|x
operator|>=
name|wrap_count
condition|;
operator|--
name|x
control|)
name|wrap_list
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|wrap_list
index|[
name|x
index|]
expr_stmt|;
block|}
name|x
operator|=
operator|(
name|temp
condition|?
name|wrap_count
operator|+
operator|(
name|wrap_tempcount
operator|++
operator|)
else|:
operator|(
name|wrap_count
operator|++
operator|)
operator|)
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|=
operator|(
name|WrapperEntry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WrapperEntry
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
operator|=
name|e
operator|->
name|wildCard
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|fromcvsFilter
operator|=
name|e
operator|->
name|fromcvsFilter
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|tocvsFilter
operator|=
name|e
operator|->
name|tocvsFilter
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|mergeMethod
operator|=
name|e
operator|->
name|mergeMethod
expr_stmt|;
name|wrap_list
index|[
name|x
index|]
operator|->
name|rcsOption
operator|=
name|e
operator|->
name|rcsOption
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the given filename is a wrapper filename */
end_comment

begin_function
name|int
name|wrap_name_has
parameter_list|(
name|name
parameter_list|,
name|has
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|WrapMergeHas
name|has
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|count
init|=
name|wrap_count
operator|+
name|wrap_tempcount
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|has
condition|)
block|{
case|case
name|WRAP_TOCVS
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|tocvsFilter
expr_stmt|;
break|break;
case|case
name|WRAP_FROMCVS
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|fromcvsFilter
expr_stmt|;
break|break;
case|case
name|WRAP_RCSOPTION
case|:
name|temp
operator|=
name|wrap_list
index|[
name|x
index|]
operator|->
name|rcsOption
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|WrapperEntry
modifier|*
name|wrap_matching_entry
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|WrapperEntry
modifier|*
name|wrap_matching_entry
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|count
init|=
name|wrap_count
operator|+
name|wrap_tempcount
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|wrap_list
index|[
name|x
index|]
operator|->
name|wildCard
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|wrap_list
index|[
name|x
index|]
return|;
return|return
operator|(
name|WrapperEntry
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the RCS options for FILENAME in a newly malloc'd string.  If    ASFLAG, then include "-k" at the beginning (e.g. "-kb"), otherwise    just give the option itself (e.g. "b").  */
end_comment

begin_function
name|char
modifier|*
name|wrap_rcsoption
parameter_list|(
name|filename
parameter_list|,
name|asflag
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|asflag
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|rcsOption
operator|==
name|NULL
operator|||
operator|(
operator|*
name|e
operator|->
name|rcsOption
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|NULL
return|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|e
operator|->
name|rcsOption
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|asflag
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"-k"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|rcsOption
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|rcsOption
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|wrap_tocvs_process_file
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|tocvsFilter
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|args
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|e
operator|->
name|tocvsFilter
argument_list|)
operator|+
name|strlen
argument_list|(
name|fileName
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: sprintf will blow up if the format string contains items other        than %s, or contains too many %s's.  We should instead be parsing        e->tocvsFilter ourselves and giving a real error.  */
name|sprintf
argument_list|(
name|args
argument_list|,
name|e
operator|->
name|tocvsFilter
argument_list|,
name|fileName
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|wrap_merge_is_copy
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|mergeMethod
operator|==
name|WRAP_MERGE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|wrap_fromcvs_process_file
parameter_list|(
name|fileName
parameter_list|)
specifier|const
name|char
modifier|*
name|fileName
decl_stmt|;
block|{
name|char
modifier|*
name|args
decl_stmt|;
name|WrapperEntry
modifier|*
name|e
init|=
name|wrap_matching_entry
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|fromcvsFilter
operator|==
name|NULL
condition|)
return|return;
name|args
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|e
operator|->
name|fromcvsFilter
argument_list|)
operator|+
name|strlen
argument_list|(
name|fileName
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: sprintf will blow up if the format string contains items other        than %s, or contains too many %s's.  We should instead be parsing        e->fromcvsFilter ourselves and giving a real error.  */
name|sprintf
argument_list|(
name|args
argument_list|,
name|e
operator|->
name|fromcvsFilter
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

