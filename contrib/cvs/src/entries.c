begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Entries file to Files file  *   * Creates the file Files containing the names that comprise the project, from  * the Entries file.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|AddEntryNode
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|Entnode
operator|*
name|entnode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Entnode
modifier|*
name|fgetentent
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fputentent
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Entnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Entnode
modifier|*
name|subdir_record
name|PROTO
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|entfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error messages */
end_comment

begin_comment
comment|/*  * Construct an Entnode  */
end_comment

begin_decl_stmt
specifier|static
name|Entnode
modifier|*
name|Entnode_Create
name|PROTO
argument_list|(
operator|(
expr|enum
name|ent_type
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Entnode
modifier|*
name|Entnode_Create
parameter_list|(
name|type
parameter_list|,
name|user
parameter_list|,
name|vn
parameter_list|,
name|ts
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|ts_conflict
parameter_list|)
name|enum
name|ent_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
specifier|const
name|char
modifier|*
name|vn
decl_stmt|;
specifier|const
name|char
modifier|*
name|ts
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|ts_conflict
decl_stmt|;
block|{
name|Entnode
modifier|*
name|ent
decl_stmt|;
comment|/* Note that timestamp and options must be non-NULL */
name|ent
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Entnode
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ent
operator|->
name|user
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|ent
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|vn
argument_list|)
expr_stmt|;
name|ent
operator|->
name|timestamp
operator|=
name|xstrdup
argument_list|(
name|ts
condition|?
name|ts
else|:
literal|""
argument_list|)
expr_stmt|;
name|ent
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|options
condition|?
name|options
else|:
literal|""
argument_list|)
expr_stmt|;
name|ent
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|ent
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|ent
operator|->
name|conflict
operator|=
name|xstrdup
argument_list|(
name|ts_conflict
argument_list|)
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function

begin_comment
comment|/*  * Destruct an Entnode  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|Entnode_Destroy
name|PROTO
argument_list|(
operator|(
name|Entnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|Entnode_Destroy
parameter_list|(
name|ent
parameter_list|)
name|Entnode
modifier|*
name|ent
decl_stmt|;
block|{
name|free
argument_list|(
name|ent
operator|->
name|user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|version
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|tag
condition|)
name|free
argument_list|(
name|ent
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|date
condition|)
name|free
argument_list|(
name|ent
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|conflict
condition|)
name|free
argument_list|(
name|ent
operator|->
name|conflict
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the line associated with a node of an entries file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_ent_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|write_ent_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
name|entnode
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|closure
operator|!=
name|NULL
operator|&&
name|entnode
operator|->
name|type
operator|!=
name|ENT_FILE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|closure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fputentent
argument_list|(
name|entfile
argument_list|,
name|entnode
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write out the current entries file given a list,  making a backup copy  * first of course  */
end_comment

begin_function
specifier|static
name|void
name|write_entries
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|sawdir
decl_stmt|;
name|sawdir
operator|=
literal|0
expr_stmt|;
comment|/* open the new one and walk the list writing entries */
name|entfilename
operator|=
name|CVSADM_ENTBAK
expr_stmt|;
name|entfile
operator|=
name|CVS_FOPEN
argument_list|(
name|entfilename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|entfile
operator|==
name|NULL
condition|)
block|{
comment|/* Make this a warning, not an error.  For example, one user might 	   have checked out a working directory which, for whatever reason, 	   contains an Entries.Log file.  A second user, without write access 	   to that working directory, might want to do a "cvs log".  The 	   problem rewriting Entries shouldn't affect the ability of "cvs log" 	   to work, although the warning is probably a good idea so that 	   whether Entries gets rewritten is not an inexplicable process.  */
comment|/* FIXME: should be including update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot rewrite %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
comment|/* Now just return.  We leave the Entries.Log file around.  As far 	   as I know, there is never any data lying around in 'list' that 	   is not in Entries.Log at this time (if there is an error writing 	   Entries.Log that is a separate problem).  */
return|return;
block|}
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|write_ent_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sawdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sawdir
condition|)
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
comment|/* We didn't write out any directories.  Check the list            private data to see whether subdirectory information is            known.  If it is, we need to write out an empty D line.  */
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|list
operator|->
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sdtp
operator|==
name|NULL
operator|||
name|sdtp
operator|->
name|subdirs
condition|)
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"D\n"
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
comment|/* now, atomically (on systems that support it) rename it */
name|rename_file
argument_list|(
name|entfilename
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
comment|/* now, remove the log file */
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTLOG
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|CVSADM_ENTLOG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the argument file from the Entries file if necessary.  */
end_comment

begin_function
name|void
name|Scratch_Entry
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> Scratch_Entry(%s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* hashlookup to see if it is there */
if|if
condition|(
operator|(
name|node
operator|=
name|findnode_fn
argument_list|(
name|list
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|entfilename
operator|=
name|CVSADM_ENTLOG
expr_stmt|;
name|entfile
operator|=
name|open_file
argument_list|(
name|entfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"R "
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
name|write_ent_proc
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* delete the node */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_scratch
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Enters the given file name/version/time-stamp into the Entries file,  * removing the old entry first, if necessary.  */
end_comment

begin_function
name|void
name|Register
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|,
name|vn
parameter_list|,
name|ts
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|ts_conflict
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|ts_conflict
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_register
argument_list|(
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> Register(%s, %s, %s%s%s, %s, %s %s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
condition|?
name|ts
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
name|ts_conflict
else|:
literal|""
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|entnode
operator|=
name|Entnode_Create
argument_list|(
name|ENT_FILE
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
name|node
operator|=
name|AddEntryNode
argument_list|(
name|list
argument_list|,
name|entnode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|entfilename
operator|=
name|CVSADM_ENTLOG
expr_stmt|;
name|entfile
operator|=
name|CVS_FOPEN
argument_list|(
name|entfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|entfile
operator|==
name|NULL
condition|)
block|{
comment|/* Warning, not error, as in write_entries.  */
comment|/* FIXME-update-dir: should be including update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"A "
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
name|write_ent_proc
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Node delete procedure for list-private sticky dir tag/date info  */
end_comment

begin_function
specifier|static
name|void
name|freesdt
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|tag
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|date
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|date
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the next real Entries line.  On end of file, returns NULL.    On error, prints an error message and returns NULL.  */
end_comment

begin_function
specifier|static
name|Entnode
modifier|*
name|fgetentent
parameter_list|(
name|fpin
parameter_list|,
name|cmd
parameter_list|,
name|sawdir
parameter_list|)
name|FILE
modifier|*
name|fpin
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
modifier|*
name|sawdir
decl_stmt|;
block|{
name|Entnode
modifier|*
name|ent
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|enum
name|ent_type
name|type
decl_stmt|;
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|user
decl_stmt|,
modifier|*
name|vn
decl_stmt|,
modifier|*
name|ts
decl_stmt|,
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag_or_date
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|ts_conflict
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|ent
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fpin
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|line
expr_stmt|;
comment|/* If CMD is not NULL, we are reading an Entries.Log file. 	   Each line in the Entries.Log file starts with a single 	   character command followed by a space.  For backward 	   compatibility, the absence of a space indicates an add 	   command.  */
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|*
name|cmd
operator|=
literal|'A'
expr_stmt|;
else|else
block|{
operator|*
name|cmd
operator|=
name|l
index|[
literal|0
index|]
expr_stmt|;
name|l
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|type
operator|=
name|ENT_FILE
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|==
literal|'D'
condition|)
block|{
name|type
operator|=
name|ENT_SUBDIR
expr_stmt|;
operator|*
name|sawdir
operator|=
literal|1
expr_stmt|;
operator|++
name|l
expr_stmt|;
comment|/* An empty D line is permitted; it is a signal that this 	       Entries file lists all known subdirectories.  */
block|}
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
name|user
operator|=
name|l
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vn
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|vn
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|options
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tag_or_date
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|tag_or_date
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|date
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'T'
condition|)
name|tag
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'D'
condition|)
name|date
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ts_conflict
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'+'
argument_list|)
operator|)
condition|)
operator|*
name|ts_conflict
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * XXX - Convert timestamp from old format to new format. 	 * 	 * If the timestamp doesn't match the file's current 	 * mtime, we'd have to generate a string that doesn't 	 * match anyways, so cheat and base it on the existing 	 * string; it doesn't have to match the same mod time. 	 * 	 * For an unmodified file, write the correct timestamp. 	 */
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ts
argument_list|)
operator|>
literal|30
operator|&&
name|CVS_STAT
argument_list|(
name|user
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ts
operator|+
literal|25
argument_list|,
name|c
argument_list|,
literal|24
argument_list|)
condition|)
name|ts
operator|=
name|time_stamp
argument_list|(
name|user
argument_list|)
expr_stmt|;
else|else
block|{
name|ts
operator|+=
literal|24
expr_stmt|;
name|ts
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
block|}
block|}
block|}
name|ent
operator|=
name|Entnode_Create
argument_list|(
name|type
argument_list|,
name|user
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fpin
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read entries file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fputentent
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Entnode
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|ENT_FILE
case|:
break|break;
case|case
name|ENT_SUBDIR
case|:
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"D"
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/%s/%s/%s"
argument_list|,
name|p
operator|->
name|user
argument_list|,
name|p
operator|->
name|version
argument_list|,
name|p
operator|->
name|timestamp
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|conflict
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"+%s"
argument_list|,
name|p
operator|->
name|conflict
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/%s/"
argument_list|,
name|p
operator|->
name|options
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"T%s\n"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"D%s\n"
argument_list|,
name|p
operator|->
name|date
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read the entries file into a list, hashing on the file name.     UPDATE_DIR is the name of the current directory, for use in error    messages, or NULL if not known (that is, noone has gotten around    to updating the caller to pass in the information).  */
end_comment

begin_function
name|List
modifier|*
name|Entries_Open
parameter_list|(
name|aflag
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|aflag
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|struct
name|stickydirtag
modifier|*
name|sdtp
init|=
name|NULL
decl_stmt|;
name|Entnode
modifier|*
name|ent
decl_stmt|;
name|char
modifier|*
name|dirtag
decl_stmt|,
modifier|*
name|dirdate
decl_stmt|;
name|int
name|dirnonbranch
decl_stmt|;
name|int
name|do_rewrite
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fpin
decl_stmt|;
name|int
name|sawdir
decl_stmt|;
comment|/* get a fresh list... */
name|entries
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Parse the CVS/Tag file, to get any default tag/date settings. Use      * list-private storage to tuck them away for Version_TS().      */
name|ParseTag
argument_list|(
operator|&
name|dirtag
argument_list|,
operator|&
name|dirdate
argument_list|,
operator|&
name|dirnonbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|||
name|dirtag
operator|||
name|dirdate
condition|)
block|{
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|aflag
operator|=
name|aflag
expr_stmt|;
name|sdtp
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|nonbranch
operator|=
name|dirnonbranch
expr_stmt|;
comment|/* feed it into the list-private area */
name|entries
operator|->
name|list
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|sdtp
expr_stmt|;
name|entries
operator|->
name|list
operator|->
name|delproc
operator|=
name|freesdt
expr_stmt|;
block|}
name|sawdir
operator|=
literal|0
expr_stmt|;
name|fpin
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|update_dir
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|ent
operator|=
name|fgetentent
argument_list|(
name|fpin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|sawdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fpin
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME-update-dir: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
name|fpin
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENTLOG
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|!=
name|NULL
condition|)
block|{
name|char
name|cmd
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
while|while
condition|(
operator|(
name|ent
operator|=
name|fgetentent
argument_list|(
name|fpin
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|sawdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'A'
case|:
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|ent
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|node
operator|=
name|findnode_fn
argument_list|(
name|entries
argument_list|,
name|ent
operator|->
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|Entnode_Destroy
argument_list|(
name|ent
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Ignore unrecognized commands.  */
break|break;
block|}
block|}
name|do_rewrite
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fpin
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME-update-dir: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTLOG
argument_list|)
expr_stmt|;
block|}
comment|/* Update the list private data to indicate whether subdirectory        information is known.  Nonexistent list private data is taken        to mean that it is known.  */
if|if
condition|(
name|sdtp
operator|!=
name|NULL
condition|)
name|sdtp
operator|->
name|subdirs
operator|=
name|sawdir
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sawdir
condition|)
block|{
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|subdirs
operator|=
literal|0
expr_stmt|;
name|entries
operator|->
name|list
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|sdtp
expr_stmt|;
name|entries
operator|->
name|list
operator|->
name|delproc
operator|=
name|freesdt
expr_stmt|;
block|}
if|if
condition|(
name|do_rewrite
operator|&&
operator|!
name|noexec
condition|)
name|write_entries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
comment|/* clean up and return */
if|if
condition|(
name|dirtag
condition|)
name|free
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirdate
condition|)
name|free
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
return|return
operator|(
name|entries
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Entries_Close
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM_ENTLOG
argument_list|)
condition|)
name|write_entries
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up the memory associated with the data section of an ENTRIES type  * node  */
end_comment

begin_function
specifier|static
name|void
name|Entries_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|Entnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|Entnode_Destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get an Entries file list node, initialize it, and add it to the specified  * list  */
end_comment

begin_function
specifier|static
name|Node
modifier|*
name|AddEntryNode
parameter_list|(
name|list
parameter_list|,
name|entdata
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* was it already there? */
if|if
condition|(
operator|(
name|p
operator|=
name|findnode_fn
argument_list|(
name|list
argument_list|,
name|entdata
operator|->
name|user
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* take it out */
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* get a node and fill in the regular stuff */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|ENTRIES
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|Entries_delproc
expr_stmt|;
comment|/* this one gets a key of the name for hashing */
comment|/* FIXME This results in duplicated data --- the hash package shouldn't        assume that the key is dynamically allocated.  The user's free proc        should be responsible for freeing the key. */
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|user
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|entdata
expr_stmt|;
comment|/* put the node into the list */
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out/Clear the CVS/Tag file.  */
end_comment

begin_function
name|void
name|WriteTag
parameter_list|(
name|dir
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|nonbranch
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|nonbranch
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
name|tmp
operator|=
name|xmalloc
argument_list|(
operator|(
name|dir
condition|?
name|strlen
argument_list|(
name|dir
argument_list|)
else|:
literal|0
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_TAG
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|||
name|date
condition|)
block|{
name|fout
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|nonbranch
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"N%s\n"
argument_list|,
name|tag
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"T%s\n"
argument_list|,
name|tag
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"D%s\n"
argument_list|,
name|date
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_sticky
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|nonbranch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Parse the CVS/Tag file for the current directory.     If it contains a date, sets *DATEP to the date in a newly malloc'd    string, *TAGP to NULL, and *NONBRANCHP to an unspecified value.     If it contains a branch tag, sets *TAGP to the tag in a newly    malloc'd string, *NONBRANCHP to 0, and *DATEP to NULL.     If it contains a nonbranch tag, sets *TAGP to the tag in a newly    malloc'd string, *NONBRANCHP to 1, and *DATEP to NULL.     If it does not exist, or contains something unrecognized by this    version of CVS, set *DATEP and *TAGP to NULL and *NONBRANCHP to    an unspecified value.     If there is an error, print an error message, set *DATEP and *TAGP    to NULL, and return.  */
end_comment

begin_function
name|void
name|ParseTag
parameter_list|(
name|tagp
parameter_list|,
name|datep
parameter_list|,
name|nonbranchp
parameter_list|)
name|char
modifier|*
modifier|*
name|tagp
decl_stmt|;
name|char
modifier|*
modifier|*
name|datep
decl_stmt|;
name|int
modifier|*
name|nonbranchp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|tagp
condition|)
operator|*
name|tagp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|datep
condition|)
operator|*
name|datep
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Always store a value here, even in the 'D' case where the value        is unspecified.  Shuts up tools which check for references to        uninitialized memory.  */
if|if
condition|(
name|nonbranchp
operator|!=
name|NULL
condition|)
operator|*
name|nonbranchp
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Remove any trailing newline.  */
if|if
condition|(
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
case|case
literal|'T'
case|:
if|if
condition|(
name|tagp
operator|!=
name|NULL
condition|)
operator|*
name|tagp
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|datep
operator|!=
name|NULL
condition|)
operator|*
name|datep
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|tagp
operator|!=
name|NULL
condition|)
operator|*
name|tagp
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonbranchp
operator|!=
name|NULL
condition|)
operator|*
name|nonbranchp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Silently ignore it; it may have been 		       written by a future version of CVS which extends the 		       syntax.  */
break|break;
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
condition|)
block|{
comment|/* FIXME-update-dir: should include update_dir in messages.  */
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot read %s: end of file"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
comment|/* FIXME-update-dir: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
comment|/* FIXME-update-dir: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called if all subdirectory information is known, but there  * aren't any subdirectories.  It records that fact in the list  * private data.  */
end_comment

begin_function
name|void
name|Subdirs_Known
parameter_list|(
name|entries
parameter_list|)
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
comment|/* If there is no list private data, that means that the        subdirectory information is known.  */
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|entries
operator|->
name|list
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sdtp
operator|!=
name|NULL
operator|&&
operator|!
name|sdtp
operator|->
name|subdirs
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|sdtp
operator|->
name|subdirs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
comment|/* Create Entries.Log so that Entries_Close will do something.  */
name|entfilename
operator|=
name|CVSADM_ENTLOG
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|entfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* As in subdir_record, just silently skip the whole thing 		   if there is no CVSADM directory.  */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
return|return;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record subdirectory information.  */
end_comment

begin_function
specifier|static
name|Entnode
modifier|*
name|subdir_record
parameter_list|(
name|cmd
parameter_list|,
name|parent
parameter_list|,
name|dir
parameter_list|)
name|int
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
comment|/* None of the information associated with a directory is        currently meaningful.  */
name|entnode
operator|=
name|Entnode_Create
argument_list|(
name|ENT_SUBDIR
argument_list|,
name|dir
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|entfilename
operator|=
name|CVSADM_ENTLOG
expr_stmt|;
else|else
block|{
name|entfilename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|parent
argument_list|)
operator|+
sizeof|sizeof
name|CVSADM_ENTLOG
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entfilename
argument_list|,
literal|"%s/%s"
argument_list|,
name|parent
argument_list|,
name|CVSADM_ENTLOG
argument_list|)
expr_stmt|;
block|}
name|entfile
operator|=
name|CVS_FOPEN
argument_list|(
name|entfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|entfile
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* It is not an error if there is no CVS administration                directory.  Permitting this case simplifies some                calling code.  */
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
return|return
name|entnode
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|entfilename
argument_list|,
literal|"%s/%s"
argument_list|,
name|parent
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|entfilename
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|entfilename
argument_list|)
expr_stmt|;
name|entfilename
operator|=
name|NULL
expr_stmt|;
return|return
name|entnode
return|;
block|}
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|entfile
argument_list|,
literal|"%c "
argument_list|,
name|cmd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputentent
argument_list|(
name|entfile
argument_list|,
name|entnode
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entfilename
argument_list|)
expr_stmt|;
name|entfilename
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|entnode
return|;
block|}
end_function

begin_comment
comment|/*  * Record the addition of a new subdirectory DIR in PARENT.  PARENT  * may be NULL, which means the current directory.  ENTRIES is the  * current entries list; it may be NULL, which means that it need not  * be updated.  */
end_comment

begin_function
name|void
name|Subdir_Register
parameter_list|(
name|entries
parameter_list|,
name|parent
parameter_list|,
name|dir
parameter_list|)
name|List
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
comment|/* Ignore attempts to register ".".  These can happen in the        server code.  */
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|entnode
operator|=
name|subdir_record
argument_list|(
literal|'A'
argument_list|,
name|parent
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
operator|&&
operator|(
name|parent
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|parent
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|entnode
argument_list|)
expr_stmt|;
else|else
name|Entnode_Destroy
argument_list|(
name|entnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the removal of a subdirectory.  The arguments are the same  * as for Subdir_Register.  */
end_comment

begin_function
name|void
name|Subdir_Deregister
parameter_list|(
name|entries
parameter_list|,
name|parent
parameter_list|,
name|dir
parameter_list|)
name|List
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
name|entnode
operator|=
name|subdir_record
argument_list|(
literal|'R'
argument_list|,
name|parent
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Entnode_Destroy
argument_list|(
name|entnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
operator|&&
operator|(
name|parent
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|parent
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|findnode_fn
argument_list|(
name|entries
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* OK, the following base_* code tracks the revisions of the files in    CVS/Base.  We do this in a file CVS/Baserev.  Separate from    CVS/Entries because it needs to go in separate data structures    anyway (the name in Entries must be unique), so this seemed    cleaner.  The business of rewriting the whole file in    base_deregister and base_register is the kind of thing we used to    do for Entries and which turned out to be slow, which is why there    is now the Entries.Log machinery.  So maybe from that point of    view it is a mistake to do this separately from Entries, I dunno.     We also need something analogous for:     1. CVS/Template (so we can update the Template file automagically    without the user needing to check out a new working directory).    Updating would probably print a message (that part might be    optional, although probably it should be visible because not all    cvs commands would make the update happen and so it is a    user-visible behavior).  Constructing version number for template    is a bit hairy (base it on the timestamp on the server?  Or see if    the template is in checkoutlist and if yes use its versioning and    if no don't version it?)....     2.  cvsignore (need to keep a copy in the working directory to do    "cvs release" on the client side; see comment at src/release.c    (release).  Would also allow us to stop needing Questionable.  */
end_comment

begin_enum
enum|enum
name|base_walk
block|{
comment|/* Set the revision for FILE to *REV.  */
name|BASE_REGISTER
block|,
comment|/* Get the revision for FILE and put it in a newly malloc'd string        in *REV, or put NULL if not mentioned.  */
name|BASE_GET
block|,
comment|/* Remove FILE.  */
name|BASE_DEREGISTER
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|base_walk
name|PROTO
argument_list|(
operator|(
expr|enum
name|base_walk
operator|,
expr|struct
name|file_info
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read through the lines in CVS/Baserev, taking the actions as documented    for CODE.  */
end_comment

begin_function
specifier|static
name|void
name|base_walk
parameter_list|(
name|code
parameter_list|,
name|finfo
parameter_list|,
name|rev
parameter_list|)
name|enum
name|base_walk
name|code
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
modifier|*
name|rev
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|line_allocated
decl_stmt|;
name|FILE
modifier|*
name|newf
decl_stmt|;
name|char
modifier|*
name|baserev_fullname
decl_stmt|;
name|char
modifier|*
name|baserevtmp_fullname
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_allocated
operator|=
literal|0
expr_stmt|;
name|newf
operator|=
name|NULL
expr_stmt|;
comment|/* First compute the fullnames for the error messages.  This        computation probably should be broken out into a separate function,        as recurse.c does it too and places like Entries_Open should be        doing it.  */
name|baserev_fullname
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CVSADM_BASEREV
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|baserev_fullname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|baserevtmp_fullname
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CVSADM_BASEREVTMP
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|baserevtmp_fullname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|baserev_fullname
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|baserev_fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|baserevtmp_fullname
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|baserevtmp_fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|baserev_fullname
argument_list|,
name|CVSADM_BASEREV
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|baserevtmp_fullname
argument_list|,
name|CVSADM_BASEREVTMP
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_BASEREV
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading"
argument_list|,
name|baserev_fullname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BASE_REGISTER
case|:
case|case
name|BASE_DEREGISTER
case|:
name|newf
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_BASEREVTMP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing"
argument_list|,
name|baserevtmp_fullname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|BASE_GET
case|:
operator|*
name|rev
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|linefile
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|linerev
decl_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'B'
condition|)
comment|/* Ignore, for future expansion.  */
continue|continue;
name|linefile
operator|=
name|line
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|linefile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Syntax error, ignore.  */
continue|continue;
name|linerev
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|linerev
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|linerev
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fncmp
argument_list|(
name|linefile
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BASE_REGISTER
case|:
case|case
name|BASE_DEREGISTER
case|:
comment|/* Don't copy over the old entry, we don't want it.  */
break|break;
case|case
name|BASE_GET
case|:
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|rev
operator|=
name|xstrdup
argument_list|(
name|linerev
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
else|else
block|{
name|linerev
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BASE_REGISTER
case|:
case|case
name|BASE_DEREGISTER
case|:
if|if
condition|(
name|fprintf
argument_list|(
name|newf
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error writing %s"
argument_list|,
name|baserevtmp_fullname
argument_list|)
expr_stmt|;
break|break;
case|case
name|BASE_GET
case|:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|baserev_fullname
argument_list|)
expr_stmt|;
block|}
name|got_it
label|:
if|if
condition|(
name|code
operator|==
name|BASE_REGISTER
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|newf
argument_list|,
literal|"B%s/%s/\n"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|*
name|rev
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error writing %s"
argument_list|,
name|baserevtmp_fullname
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|baserev_fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|newf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|baserevtmp_fullname
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|CVSADM_BASEREVTMP
argument_list|,
name|CVSADM_BASEREV
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|baserev_fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|baserevtmp_fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return, in a newly malloc'd string, the revision for FILE in CVS/Baserev,    or NULL if not listed.  */
end_comment

begin_function
name|char
modifier|*
name|base_get
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|rev
decl_stmt|;
name|base_walk
argument_list|(
name|BASE_GET
argument_list|,
name|finfo
argument_list|,
operator|&
name|rev
argument_list|)
expr_stmt|;
return|return
name|rev
return|;
block|}
end_function

begin_comment
comment|/* Set the revision for FILE to REV.  */
end_comment

begin_function
name|void
name|base_register
parameter_list|(
name|finfo
parameter_list|,
name|rev
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|base_walk
argument_list|(
name|BASE_REGISTER
argument_list|,
name|finfo
argument_list|,
operator|&
name|rev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove FILE.  */
end_comment

begin_function
name|void
name|base_deregister
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|base_walk
argument_list|(
name|BASE_DEREGISTER
argument_list|,
name|finfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

