begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * Entries file to Files file  *   * Creates the file Files containing the names that comprise the project, from  * the Entries file.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|AddEntryNode
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|,
name|Entnode
operator|*
name|entnode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Entnode
modifier|*
name|fgetentent
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fputentent
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Entnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|entfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error messages */
end_comment

begin_comment
comment|/*  * Construct an Entnode  */
end_comment

begin_function
name|Entnode
modifier|*
name|Entnode_Create
parameter_list|(
name|user
parameter_list|,
name|vn
parameter_list|,
name|ts
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|ts_conflict
parameter_list|)
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
specifier|const
name|char
modifier|*
name|vn
decl_stmt|;
specifier|const
name|char
modifier|*
name|ts
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|ts_conflict
decl_stmt|;
block|{
name|Entnode
modifier|*
name|ent
decl_stmt|;
comment|/* Note that timestamp and options must be non-NULL */
name|ent
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Entnode
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|user
operator|=
name|xstrdup
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|ent
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|vn
argument_list|)
expr_stmt|;
name|ent
operator|->
name|timestamp
operator|=
name|xstrdup
argument_list|(
name|ts
condition|?
name|ts
else|:
literal|""
argument_list|)
expr_stmt|;
name|ent
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|options
condition|?
name|options
else|:
literal|""
argument_list|)
expr_stmt|;
name|ent
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|ent
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|ent
operator|->
name|conflict
operator|=
name|xstrdup
argument_list|(
name|ts_conflict
argument_list|)
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function

begin_comment
comment|/*  * Destruct an Entnode  */
end_comment

begin_function
name|void
name|Entnode_Destroy
parameter_list|(
name|ent
parameter_list|)
name|Entnode
modifier|*
name|ent
decl_stmt|;
block|{
name|free
argument_list|(
name|ent
operator|->
name|user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|version
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|tag
condition|)
name|free
argument_list|(
name|ent
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|date
condition|)
name|free
argument_list|(
name|ent
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|conflict
condition|)
name|free
argument_list|(
name|ent
operator|->
name|conflict
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write out the line associated with a node of an entries file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_ent_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|write_ent_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|fputentent
argument_list|(
name|entfile
argument_list|,
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write out the current entries file given a list,  making a backup copy  * first of course  */
end_comment

begin_function
specifier|static
name|void
name|write_entries
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
comment|/* open the new one and walk the list writing entries */
name|entfilename
operator|=
name|CVSADM_ENTBAK
expr_stmt|;
name|entfile
operator|=
name|open_file
argument_list|(
name|entfilename
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|write_ent_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|entfilename
argument_list|)
expr_stmt|;
comment|/* now, atomically (on systems that support it) rename it */
name|rename_file
argument_list|(
name|entfilename
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
comment|/* now, remove the log file */
name|unlink_file
argument_list|(
name|CVSADM_ENTLOG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the argument file from the Entries file if necessary.  */
end_comment

begin_function
name|void
name|Scratch_Entry
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> Scratch_Entry(%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> Scratch_Entry(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* hashlookup to see if it is there */
if|if
condition|(
operator|(
name|node
operator|=
name|findnode_fn
argument_list|(
name|list
argument_list|,
name|fname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* delete the node */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_scratch
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|noexec
condition|)
name|write_entries
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* re-write the file */
block|}
block|}
end_function

begin_comment
comment|/*  * Enters the given file name/version/time-stamp into the Entries file,  * removing the old entry first, if necessary.  */
end_comment

begin_function
name|void
name|Register
parameter_list|(
name|list
parameter_list|,
name|fname
parameter_list|,
name|vn
parameter_list|,
name|ts
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|ts_conflict
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|vn
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|ts_conflict
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entnode
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_register
argument_list|(
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|trace
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> Register(%s, %s, %s%s%s, %s, %s %s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
condition|?
name|ts
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
name|ts_conflict
else|:
literal|""
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> Register(%s, %s, %s%s%s, %s, %s %s)\n"
argument_list|,
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
condition|?
name|ts
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|ts_conflict
condition|?
name|ts_conflict
else|:
literal|""
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|entnode
operator|=
name|Entnode_Create
argument_list|(
name|fname
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
name|node
operator|=
name|AddEntryNode
argument_list|(
name|list
argument_list|,
name|entnode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|entfile
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTLOG
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|write_ent_proc
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|entfile
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|CVSADM_ENTLOG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Node delete procedure for list-private sticky dir tag/date info  */
end_comment

begin_function
specifier|static
name|void
name|freesdt
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|tag
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|date
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtp
operator|->
name|options
condition|)
name|free
argument_list|(
name|sdtp
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Entnode
modifier|*
name|fgetentent
parameter_list|(
name|fpin
parameter_list|)
name|FILE
modifier|*
name|fpin
decl_stmt|;
block|{
name|Entnode
modifier|*
name|ent
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|vn
decl_stmt|,
modifier|*
name|ts
decl_stmt|,
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag_or_date
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|ts_conflict
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|ent
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fpin
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
name|user
operator|=
name|line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vn
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|vn
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|options
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|options
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tag_or_date
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|tag_or_date
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|date
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'T'
condition|)
name|tag
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|tag_or_date
operator|==
literal|'D'
condition|)
name|date
operator|=
name|tag_or_date
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ts_conflict
operator|=
name|strchr
argument_list|(
name|ts
argument_list|,
literal|'+'
argument_list|)
operator|)
condition|)
operator|*
name|ts_conflict
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * XXX - Convert timestamp from old format to new format. 	 * 	 * If the timestamp doesn't match the file's current 	 * mtime, we'd have to generate a string that doesn't 	 * match anyways, so cheat and base it on the existing 	 * string; it doesn't have to match the same mod time. 	 * 	 * For an unmodified file, write the correct timestamp. 	 */
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ts
argument_list|)
operator|>
literal|30
operator|&&
name|stat
argument_list|(
name|user
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ts
operator|+
literal|25
argument_list|,
name|c
argument_list|,
literal|24
argument_list|)
condition|)
name|ts
operator|=
name|time_stamp
argument_list|(
name|user
argument_list|)
expr_stmt|;
else|else
block|{
name|ts
operator|+=
literal|24
expr_stmt|;
name|ts
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
block|}
block|}
block|}
name|ent
operator|=
name|Entnode_Create
argument_list|(
name|user
argument_list|,
name|vn
argument_list|,
name|ts
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|ts_conflict
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|ent
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fputentent
parameter_list|(
name|fp
parameter_list|,
name|p
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Entnode
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/%s/%s/%s"
argument_list|,
name|p
operator|->
name|user
argument_list|,
name|p
operator|->
name|version
argument_list|,
name|p
operator|->
name|timestamp
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|conflict
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"+%s"
argument_list|,
name|p
operator|->
name|conflict
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"/%s/"
argument_list|,
name|p
operator|->
name|options
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"T%s\n"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|date
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"D%s\n"
argument_list|,
name|p
operator|->
name|date
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read the entries file into a list, hashing on the file name.  */
end_comment

begin_function
name|List
modifier|*
name|Entries_Open
parameter_list|(
name|aflag
parameter_list|)
name|int
name|aflag
decl_stmt|;
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|Entnode
modifier|*
name|ent
decl_stmt|;
name|char
modifier|*
name|dirtag
decl_stmt|,
modifier|*
name|dirdate
decl_stmt|;
name|int
name|do_rewrite
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fpin
decl_stmt|;
comment|/* get a fresh list... */
name|entries
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Parse the CVS/Tag file, to get any default tag/date settings. Use      * list-private storage to tuck them away for Version_TS().      */
name|ParseTag
argument_list|(
operator|&
name|dirtag
argument_list|,
operator|&
name|dirdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|||
name|dirtag
operator|||
name|dirdate
condition|)
block|{
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sdtp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdtp
argument_list|)
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|aflag
operator|=
name|aflag
expr_stmt|;
name|sdtp
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
name|sdtp
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
comment|/* feed it into the list-private area */
name|entries
operator|->
name|list
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|sdtp
expr_stmt|;
name|entries
operator|->
name|list
operator|->
name|delproc
operator|=
name|freesdt
expr_stmt|;
block|}
name|fpin
operator|=
name|fopen
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for reading"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|ent
operator|=
name|fgetentent
argument_list|(
name|fpin
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
block|}
name|fpin
operator|=
name|fopen
argument_list|(
name|CVSADM_ENTLOG
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ent
operator|=
name|fgetentent
argument_list|(
name|fpin
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|AddEntryNode
argument_list|(
name|entries
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
name|do_rewrite
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_rewrite
operator|&&
operator|!
name|noexec
condition|)
name|write_entries
argument_list|(
name|entries
argument_list|)
expr_stmt|;
comment|/* clean up and return */
if|if
condition|(
name|dirtag
condition|)
name|free
argument_list|(
name|dirtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirdate
condition|)
name|free
argument_list|(
name|dirdate
argument_list|)
expr_stmt|;
return|return
operator|(
name|entries
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Entries_Close
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM_ENTLOG
argument_list|)
condition|)
name|write_entries
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up the memory associated with the data section of an ENTRIES type  * node  */
end_comment

begin_function
specifier|static
name|void
name|Entries_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|Entnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
name|Entnode_Destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get an Entries file list node, initialize it, and add it to the specified  * list  */
end_comment

begin_function
specifier|static
name|Node
modifier|*
name|AddEntryNode
parameter_list|(
name|list
parameter_list|,
name|entdata
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* was it already there? */
if|if
condition|(
operator|(
name|p
operator|=
name|findnode_fn
argument_list|(
name|list
argument_list|,
name|entdata
operator|->
name|user
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* take it out */
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* get a node and fill in the regular stuff */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|ENTRIES
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|Entries_delproc
expr_stmt|;
comment|/* this one gets a key of the name for hashing */
comment|/* FIXME This results in duplicated data --- the hash package shouldn't        assume that the key is dynamically allocated.  The user's free proc        should be responsible for freeing the key. */
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|user
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|entdata
expr_stmt|;
comment|/* put the node into the list */
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out/Clear the CVS/Tag file.  */
end_comment

begin_function
name|void
name|WriteTag
parameter_list|(
name|dir
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|||
name|date
condition|)
block|{
name|fout
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"T%s\n"
argument_list|,
name|tag
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"D%s\n"
argument_list|,
name|date
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse the CVS/Tag file for the current directory.  */
end_comment

begin_function
name|void
name|ParseTag
parameter_list|(
name|tagp
parameter_list|,
name|datep
parameter_list|)
name|char
modifier|*
modifier|*
name|tagp
decl_stmt|;
name|char
modifier|*
modifier|*
name|datep
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|tagp
condition|)
operator|*
name|tagp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|datep
condition|)
operator|*
name|datep
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Remove any trailing newline.  */
if|if
condition|(
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'T'
operator|&&
name|tagp
condition|)
operator|*
name|tagp
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|line
operator|==
literal|'D'
operator|&&
name|datep
condition|)
operator|*
name|datep
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

