begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Status Information  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|Dtype
name|status_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|status_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tag_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|long_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RCSNode
modifier|*
name|xrcsnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|status_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-vlR] [files...]\n"
block|,
literal|"\t-v\tVerbose format; includes tag information for the file\n"
block|,
literal|"\t-l\tProcess this directory only (not recursive).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|status
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|status_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+vlR"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'v'
case|:
name|long_format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|status_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|long_format
condition|)
name|send_arg
argument_list|(
literal|"-v"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
comment|/* For a while, we tried setting SEND_NO_CONTENTS here so this 	 could be a fast operation.  That prevents the 	 server from updating our timestamp if the timestamp is 	 changed but the file is unmodified.  Worse, it is user-visible 	 (shows "locally modified" instead of "up to date" if 	 timestamp is changed but file is not).  And there is no good 	 workaround (you might not want to run "cvs update"; "cvs -n 	 update" doesn't update CVS/Entries; "cvs diff --brief" or 	 something perhaps could be made to work but somehow that 	 seems nonintuitive to me even if so).  Given that timestamps 	 seem to have the potential to get munged for any number of 	 reasons, it seems better to not rely too much on them.  */
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"status\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
endif|#
directive|endif
comment|/* start the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|status_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|status_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * display the status of a file  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|status_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|sstat
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sstat
operator|=
literal|"Classify Error"
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
name|sstat
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
case|case
name|T_CHECKOUT
case|:
name|sstat
operator|=
literal|"Needs Checkout"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
name|sstat
operator|=
literal|"Needs Patch"
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_CONFLICT
case|:
comment|/* I _think_ that "unresolved" is correct; that if it has 	       been resolved then the status will change.  But I'm not 	       sure about that.  */
name|sstat
operator|=
literal|"Unresolved Conflict"
expr_stmt|;
break|break;
case|case
name|T_ADDED
case|:
name|sstat
operator|=
literal|"Locally Added"
expr_stmt|;
break|break;
case|case
name|T_REMOVED
case|:
name|sstat
operator|=
literal|"Locally Removed"
expr_stmt|;
break|break;
case|case
name|T_MODIFIED
case|:
if|if
condition|(
name|vers
operator|->
name|ts_conflict
condition|)
name|sstat
operator|=
literal|"File had conflicts on merge"
expr_stmt|;
else|else
name|sstat
operator|=
literal|"Locally Modified"
expr_stmt|;
break|break;
case|case
name|T_REMOVE_ENTRY
case|:
name|sstat
operator|=
literal|"Entry Invalid"
expr_stmt|;
break|break;
case|case
name|T_UPTODATE
case|:
name|sstat
operator|=
literal|"Up-to-date"
expr_stmt|;
break|break;
case|case
name|T_NEEDS_MERGE
case|:
name|sstat
operator|=
literal|"Needs Merge"
expr_stmt|;
break|break;
case|case
name|T_TITLE
case|:
comment|/* I don't think this case can occur here.  Just print 	       "Classify Error".  */
break|break;
block|}
name|cvs_output
argument_list|(
literal|"\ ===================================================================\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"File: no file "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t\tStatus: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|sstat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|sstat
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"File: %-17s\tStatus: %s\n\n"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|sstat
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Working revision:\tNo entry for "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|cvs_output
argument_list|(
literal|"   Working revision:\tNew file!\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Working revision:\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|cvs_output
argument_list|(
literal|"   Working revision:\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|ts_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"   Repository revision:\tNo revision control file\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|cvs_output
argument_list|(
literal|"   Repository revision:\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|->
name|entdata
condition|)
block|{
name|Entnode
modifier|*
name|edata
decl_stmt|;
name|edata
operator|=
name|vers
operator|->
name|entdata
expr_stmt|;
if|if
condition|(
name|edata
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Sticky Tag:\t\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|edata
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" - MISSING from RCS file!\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|edata
operator|->
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Sticky Tag:\t\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|edata
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|edata
operator|->
name|tag
argument_list|)
condition|)
name|branch
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|edata
operator|->
name|tag
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"   Sticky Tag:\t\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|edata
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" ("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|branch
condition|?
literal|"branch"
else|:
literal|"revision"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|branch
condition|?
name|branch
else|:
name|vers
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|")\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
literal|"   Sticky Tag:\t\t(none)\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata
operator|->
name|date
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Sticky Date:\t\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|edata
operator|->
name|date
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
literal|"   Sticky Date:\t\t(none)\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata
operator|->
name|options
operator|&&
name|edata
operator|->
name|options
index|[
literal|0
index|]
condition|)
block|{
name|cvs_output
argument_list|(
literal|"   Sticky Options:\t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|edata
operator|->
name|options
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
literal|"   Sticky Options:\t(none)\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_format
operator|&&
name|vers
operator|->
name|srcfile
condition|)
block|{
name|List
modifier|*
name|symbols
init|=
name|RCS_symbols
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|)
decl_stmt|;
name|cvs_output
argument_list|(
literal|"\n   Existing Tags:\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbols
condition|)
block|{
name|xrcsnode
operator|=
name|finfo
operator|->
name|rcs
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|symbols
argument_list|,
name|tag_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|cvs_output
argument_list|(
literal|"\tNo Tags Exist\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|status_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out a tag and its type  */
end_comment

begin_function
specifier|static
name|int
name|tag_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|xrcsnode
argument_list|,
name|p
operator|->
name|key
argument_list|)
condition|)
name|branch
operator|=
name|RCS_whatbranch
argument_list|(
name|xrcsnode
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
operator|(
name|branch
condition|?
name|strlen
argument_list|(
name|branch
argument_list|)
else|:
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\t%-25s\t(%s: %s)\n"
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|branch
condition|?
literal|"branch"
else|:
literal|"revision"
argument_list|,
name|branch
condition|?
name|branch
else|:
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

