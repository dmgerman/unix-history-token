begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1996-2005 The Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* Code for the buffer data structure.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS/2 doesn't have EIO.  FIXME: this whole notion of turning    a different error into EIO strikes me as pretty dubious.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EIO
argument_list|)
end_if

begin_define
define|#
directive|define
name|EIO
value|EBADPOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Linked list of available buffer_data structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer_data
modifier|*
name|free_buffer_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|buf_default_memory_error
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|allocate_buffer_datas
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buffer_data
modifier|*
name|get_buffer_data
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a buffer structure.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|buf_initialize
parameter_list|(
name|input
parameter_list|,
name|output
parameter_list|,
name|flush
parameter_list|,
name|block
parameter_list|,
name|shutdown
parameter_list|,
name|memory
parameter_list|,
name|closure
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*input
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*output
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*flush
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*block
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*shutdown
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*memory
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|closure
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|input
operator|=
name|input
expr_stmt|;
name|buf
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|buf
operator|->
name|flush
operator|=
name|flush
expr_stmt|;
name|buf
operator|->
name|block
operator|=
name|block
expr_stmt|;
name|buf
operator|->
name|shutdown
operator|=
name|shutdown
expr_stmt|;
name|buf
operator|->
name|memory_error
operator|=
name|memory
condition|?
name|memory
else|:
name|buf_default_memory_error
expr_stmt|;
name|buf
operator|->
name|closure
operator|=
name|closure
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

begin_comment
comment|/* Free a buffer structure.  */
end_comment

begin_function
name|void
name|buf_free
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|closure
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
operator|->
name|closure
argument_list|)
expr_stmt|;
name|buf
operator|->
name|closure
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a buffer structure which is not to be used for I/O.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|buf_nonio_initialize
parameter_list|(
name|memory
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|buf_initialize
argument_list|(
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|memory
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Default memory error handler.  */
end_comment

begin_function
specifier|static
name|void
name|buf_default_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate more buffer_data structures.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_buffer_datas
parameter_list|()
block|{
name|struct
name|buffer_data
modifier|*
name|alc
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate buffer_data structures in blocks of 16.  */
define|#
directive|define
name|ALLOC_COUNT
value|(16)
name|alc
operator|=
name|xmalloc
argument_list|(
name|ALLOC_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|buffer_data
argument_list|)
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|valloc
argument_list|(
name|ALLOC_COUNT
operator|*
name|BUFFER_DATA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space
condition|)
block|{
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALLOC_COUNT
condition|;
name|i
operator|++
operator|,
name|alc
operator|++
operator|,
name|space
operator|+=
name|BUFFER_DATA_SIZE
control|)
block|{
name|alc
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|alc
expr_stmt|;
name|alc
operator|->
name|text
operator|=
name|space
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a new buffer_data structure.  */
end_comment

begin_function
specifier|static
name|struct
name|buffer_data
modifier|*
name|get_buffer_data
parameter_list|()
block|{
name|struct
name|buffer_data
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|free_buffer_data
operator|==
name|NULL
condition|)
block|{
name|allocate_buffer_datas
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_buffer_data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|ret
operator|->
name|next
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* See whether a buffer and its file descriptor is empty.  */
end_comment

begin_function
name|int
name|buf_empty
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
comment|/* Try and read any data on the file descriptor first. 	 * We already know the descriptor is non-blocking. 	 */
name|buf_input_data
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|buf_empty_p
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See whether a buffer is empty.  */
end_comment

begin_function
name|int
name|buf_empty_p
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
if|if
condition|(
name|data
operator|->
name|size
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Count how much data is stored in the buffer..  * Note that each buffer is a xmalloc'ed chunk BUFFER_DATA_SIZE.  */
end_comment

begin_function
name|int
name|buf_count_mem
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|mem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|mem
operator|+=
name|BUFFER_DATA_SIZE
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/* Add data DATA of length LEN to BUF.  */
end_comment

begin_function
name|void
name|buf_output
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
operator|-
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|)
operator|>=
name|len
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|last
operator|->
name|size
operator|+=
name|len
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|newdata
decl_stmt|;
name|newdata
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|newdata
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|newdata
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|newdata
expr_stmt|;
name|newdata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|newdata
expr_stmt|;
name|newdata
operator|->
name|bufp
operator|=
name|newdata
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|BUFFER_DATA_SIZE
condition|)
block|{
name|newdata
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|newdata
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|newdata
operator|->
name|size
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|memcpy
argument_list|(
name|newdata
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|BUFFER_DATA_SIZE
argument_list|)
expr_stmt|;
name|data
operator|+=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|len
operator|-=
name|BUFFER_DATA_SIZE
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Add a '\0' terminated string to BUF.  */
end_comment

begin_function
name|void
name|buf_output0
parameter_list|(
name|buf
parameter_list|,
name|string
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|buf_output
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a single character to BUF.  */
end_comment

begin_function
name|void
name|buf_append_char
parameter_list|(
name|buf
parameter_list|,
name|ch
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
operator|&&
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|!=
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
condition|)
block|{
operator|*
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|=
name|ch
expr_stmt|;
operator|++
name|buf
operator|->
name|last
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
name|ch
expr_stmt|;
name|buf_output
argument_list|(
name|buf
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send all the output we've been saving up.  Returns 0 for success or  * errno code.  If the buffer has been set to be nonblocking, this  * will just write until the write would block.  */
end_comment

begin_function
name|int
name|buf_send_output
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|output
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nbytes
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|output
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|data
operator|->
name|size
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* Some sort of error.  Discard the data, and return.  */
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|nbytes
operator|!=
name|data
operator|->
name|size
condition|)
block|{
comment|/* Not all the data was written out.  This is only                    permitted in nonblocking mode.  Adjust the buffer,                    and return.  */
name|assert
argument_list|(
name|buf
operator|->
name|nonblocking
argument_list|)
expr_stmt|;
name|data
operator|->
name|size
operator|-=
name|nbytes
expr_stmt|;
name|data
operator|->
name|bufp
operator|+=
name|nbytes
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|buf
operator|->
name|data
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|data
expr_stmt|;
block|}
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Flush any data queued up in the buffer.  If BLOCK is nonzero, then  * if the buffer is in nonblocking mode, put it into blocking mode for  * the duration of the flush.  This returns 0 on success, or an error  * code.  */
end_comment

begin_function
name|int
name|buf_flush
parameter_list|(
name|buf
parameter_list|,
name|block
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|int
name|nonblocking
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|flush
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nonblocking
operator|=
name|buf
operator|->
name|nonblocking
expr_stmt|;
if|if
condition|(
name|nonblocking
operator|&&
name|block
condition|)
block|{
name|status
operator|=
name|set_block
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
name|status
operator|=
name|buf_send_output
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|flush
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonblocking
operator|&&
name|block
condition|)
block|{
name|int
name|blockstat
decl_stmt|;
name|blockstat
operator|=
name|set_nonblock
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|status
operator|=
name|blockstat
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Set buffer BUF to nonblocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
name|int
name|set_nonblock
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|nonblocking
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
operator|->
name|block
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|block
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|buf
operator|->
name|nonblocking
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set buffer BUF to blocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
name|int
name|set_block
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|nonblocking
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
operator|->
name|block
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|block
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|buf
operator|->
name|nonblocking
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a character count and some output.  Returns errno code or 0 for  * success.  *  * Sending the count in binary is OK since this is only used on a pipe  * within the same system.  */
end_comment

begin_function
name|int
name|buf_send_counted
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|size
operator|+=
name|data
operator|->
name|size
expr_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|data
operator|->
name|next
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last
operator|==
name|NULL
condition|)
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|->
name|text
operator|)
operator|=
name|size
expr_stmt|;
return|return
name|buf_send_output
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a special count.  COUNT should be negative.  It will be  * handled speciallyi by buf_copy_counted.  This function returns 0 or  * an errno code.  *  * Sending the count in binary is OK since this is only used on a pipe  * within the same system.  */
end_comment

begin_function
name|int
name|buf_send_special_count
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|data
operator|->
name|next
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last
operator|==
name|NULL
condition|)
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|->
name|text
operator|)
operator|=
name|count
expr_stmt|;
return|return
name|buf_send_output
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append a list of buffer_data structures to an buffer.  */
end_comment

begin_function
name|void
name|buf_append_data
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|,
name|last
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|last
decl_stmt|;
block|{
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append the data on one buffer to another.  This removes the data    from the source buffer.  */
end_comment

begin_function
name|void
name|buf_append_buffer
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|buffer
modifier|*
name|to
decl_stmt|;
name|struct
name|buffer
modifier|*
name|from
decl_stmt|;
block|{
name|buf_append_data
argument_list|(
name|to
argument_list|,
name|from
operator|->
name|data
argument_list|,
name|from
operator|->
name|last
argument_list|)
expr_stmt|;
name|from
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|from
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy the contents of file F into buffer_data structures.  We can't  * copy directly into an buffer, because we want to handle failure and  * succeess differently.  Returns 0 on success, or -2 if out of  * memory, or a status code on error.  Since the caller happens to  * know the size of the file, it is passed in as SIZE.  On success,  * this function sets *RETP and *LASTP, which may be passed to  * buf_append_data.  */
end_comment

begin_function
name|int
name|buf_read_file
parameter_list|(
name|f
parameter_list|,
name|size
parameter_list|,
name|retp
parameter_list|,
name|lastp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|retp
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|lastp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|get
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|*
name|retp
operator|==
name|NULL
condition|)
operator|*
name|retp
operator|=
name|data
expr_stmt|;
else|else
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|BUFFER_DATA_SIZE
condition|)
name|get
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
else|else
name|get
operator|=
name|size
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
operator|->
name|text
argument_list|,
name|get
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|status
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|data
operator|->
name|size
operator|+=
name|get
expr_stmt|;
name|size
operator|-=
name|get
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
operator|*
name|retp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
operator|*
name|retp
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the contents of file F into buffer_data structures.  We can't  * copy directly into an buffer, because we want to handle failure and  * succeess differently.  Returns 0 on success, or -2 if out of  * memory, or a status code on error.  On success, this function sets  * *RETP and *LASTP, which may be passed to buf_append_data.  */
end_comment

begin_function
name|int
name|buf_read_file_to_eof
parameter_list|(
name|f
parameter_list|,
name|retp
parameter_list|,
name|lastp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|retp
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|lastp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|get
decl_stmt|,
name|nread
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|*
name|retp
operator|==
name|NULL
condition|)
operator|*
name|retp
operator|=
name|data
expr_stmt|;
else|else
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|get
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
name|nread
operator|=
name|fread
argument_list|(
name|data
operator|->
name|text
argument_list|,
literal|1
argument_list|,
name|get
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|status
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|data
operator|->
name|size
operator|=
name|nread
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
operator|*
name|retp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
operator|*
name|retp
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes in a chain of buffer_data structures.  */
end_comment

begin_function
name|int
name|buf_chain_length
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer_data
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|size
operator|+=
name|buf
operator|->
name|size
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes in a buffer.  */
end_comment

begin_function
name|int
name|buf_length
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|buf_chain_length
argument_list|(
name|buf
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read an arbitrary amount of data into an input buffer.  The buffer  * will be in nonblocking mode, and we just grab what we can.  Return  * 0 on success, or -1 on end of file, or -2 if out of memory, or an  * error code.  If COUNTP is not NULL, *COUNTP is set to the number of  * bytes read.  */
end_comment

begin_function
name|int
name|buf_input_data
parameter_list|(
name|buf
parameter_list|,
name|countp
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|input
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|countp
operator|!=
name|NULL
condition|)
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|get
decl_stmt|;
name|int
name|status
decl_stmt|,
name|nbytes
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
operator|||
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|==
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|get
operator|=
operator|(
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
operator|-
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|)
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|input
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|get
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|buf
operator|->
name|last
operator|->
name|size
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|countp
operator|!=
name|NULL
condition|)
operator|*
name|countp
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
name|get
condition|)
block|{
comment|/* If we did not fill the buffer, then presumably we read                all the available data.  */
return|return
literal|0
return|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Read a line (characters up to a \012) from an input buffer.  (We  * use \012 rather than \n for the benefit of non Unix clients for  * which \n means something else).  This returns 0 on success, or -1  * on end of file, or -2 if out of memory, or an error code.  If it  * succeeds, it sets *LINE to an allocated buffer holding the contents  * of the line.  The trailing \012 is not included in the buffer.  If  * LENP is not NULL, then *LENP is set to the number of bytes read;  * strlen may not work, because there may be embedded null bytes.  */
end_comment

begin_function
name|int
name|buf_read_line
parameter_list|(
name|buf
parameter_list|,
name|line
parameter_list|,
name|lenp
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|input
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|len
decl_stmt|,
name|finallen
init|=
literal|0
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
comment|/* See if there is a newline in BUF.  */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|data
operator|->
name|bufp
argument_list|,
literal|'\012'
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
block|{
name|finallen
operator|=
name|nl
operator|-
name|data
operator|->
name|bufp
expr_stmt|;
name|len
operator|+=
name|finallen
expr_stmt|;
break|break;
block|}
name|len
operator|+=
name|data
operator|->
name|size
expr_stmt|;
block|}
comment|/* If we found a newline, copy the line into a memory buffer,            and remove it from BUF.  */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|nldata
decl_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
operator|*
name|line
operator|=
name|p
expr_stmt|;
name|nldata
operator|=
name|data
expr_stmt|;
name|data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|data
operator|!=
name|nldata
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|next
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|data
operator|->
name|size
expr_stmt|;
name|next
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|data
expr_stmt|;
name|data
operator|=
name|next
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|finallen
argument_list|)
expr_stmt|;
name|p
index|[
name|finallen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|data
operator|->
name|size
operator|-=
name|finallen
operator|+
literal|1
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|lenp
operator|!=
name|NULL
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Read more data until we get a newline.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|size
decl_stmt|,
name|status
decl_stmt|,
name|nbytes
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
operator|||
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|==
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
condition|)
block|{
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|mem
operator|=
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
expr_stmt|;
name|size
operator|=
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
operator|-
name|mem
expr_stmt|;
comment|/* We need to read at least 1 byte.  We can handle up to                SIZE bytes.  This will only be efficient if the                underlying communication stream does its own buffering,                or is clever about getting more than 1 byte at a time.  */
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|input
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
name|mem
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|buf
operator|->
name|last
operator|->
name|size
operator|+=
name|nbytes
expr_stmt|;
comment|/* Optimize slightly to avoid an unnecessary call to                memchr.  */
if|if
condition|(
name|nbytes
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|mem
operator|==
literal|'\012'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|memchr
argument_list|(
name|mem
argument_list|,
literal|'\012'
argument_list|,
name|nbytes
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Extract data from the input buffer BUF.  This will read up to WANT  * bytes from the buffer.  It will set *RETDATA to point at the bytes,  * and set *GOT to the number of bytes to be found there.  Any buffer  * call which uses BUF may change the contents of the buffer at *DATA,  * so the data should be fully processed before any further calls are  * made.  This returns 0 on success, or -1 on end of file, or -2 if  * out of memory, or an error code.  */
end_comment

begin_function
name|int
name|buf_read_data
parameter_list|(
name|buf
parameter_list|,
name|want
parameter_list|,
name|retdata
parameter_list|,
name|got
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|want
decl_stmt|;
name|char
modifier|*
modifier|*
name|retdata
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|input
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
operator|&&
name|buf
operator|->
name|data
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|buf
operator|->
name|data
operator|->
name|next
expr_stmt|;
name|buf
operator|->
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|get
decl_stmt|,
name|status
decl_stmt|,
name|nbytes
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|want
operator|<
name|BUFFER_DATA_SIZE
condition|)
name|get
operator|=
name|want
expr_stmt|;
else|else
name|get
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|buf
operator|->
name|input
call|)
argument_list|(
name|buf
operator|->
name|closure
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|get
argument_list|,
name|BUFFER_DATA_SIZE
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|data
operator|->
name|size
operator|=
name|nbytes
expr_stmt|;
block|}
operator|*
name|retdata
operator|=
name|buf
operator|->
name|data
operator|->
name|bufp
expr_stmt|;
if|if
condition|(
name|want
operator|<
name|buf
operator|->
name|data
operator|->
name|size
condition|)
block|{
operator|*
name|got
operator|=
name|want
expr_stmt|;
name|buf
operator|->
name|data
operator|->
name|size
operator|-=
name|want
expr_stmt|;
name|buf
operator|->
name|data
operator|->
name|bufp
operator|+=
name|want
expr_stmt|;
block|}
else|else
block|{
operator|*
name|got
operator|=
name|buf
operator|->
name|data
operator|->
name|size
expr_stmt|;
name|buf
operator|->
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Copy lines from an input buffer to an output buffer.  This copies  * all complete lines (characters up to a newline) from INBUF to  * OUTBUF.  Each line in OUTBUF is preceded by the character COMMAND  * and a space.  */
end_comment

begin_function
name|void
name|buf_copy_lines
parameter_list|(
name|outbuf
parameter_list|,
name|inbuf
parameter_list|,
name|command
parameter_list|)
name|struct
name|buffer
modifier|*
name|outbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|inbuf
decl_stmt|;
name|int
name|command
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|nldata
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* See if there is a newline in INBUF.  */
name|nldata
operator|=
name|NULL
expr_stmt|;
name|nl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|data
operator|->
name|bufp
argument_list|,
literal|'\n'
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
block|{
name|nldata
operator|=
name|data
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nldata
operator|==
name|NULL
condition|)
block|{
comment|/* There are no more lines in INBUF.  */
return|return;
block|}
comment|/* Put in the command.  */
name|buf_append_char
argument_list|(
name|outbuf
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|outbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuf
operator|->
name|data
operator|!=
name|nldata
condition|)
block|{
comment|/* 	     * Simply move over all the buffers up to the one containing 	     * the newline. 	     */
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|->
name|next
operator|!=
name|nldata
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
empty_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|inbuf
operator|->
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|nldata
expr_stmt|;
block|}
comment|/* 	 * If the newline is at the very end of the buffer, just move 	 * the buffer onto OUTBUF.  Otherwise we must copy the data. 	 */
name|len
operator|=
name|nl
operator|+
literal|1
operator|-
name|nldata
operator|->
name|bufp
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|nldata
operator|->
name|size
condition|)
block|{
name|inbuf
operator|->
name|data
operator|=
name|nldata
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|inbuf
operator|->
name|data
operator|==
name|NULL
condition|)
name|inbuf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|nldata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|nldata
argument_list|,
name|nldata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output
argument_list|(
name|outbuf
argument_list|,
name|nldata
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nldata
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|nldata
operator|->
name|size
operator|-=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copy counted data from one buffer to another.  The count is an  * integer, host size, host byte order (it is only used across a  * pipe).  If there is enough data, it should be moved over.  If there  * is not enough data, it should remain on the original buffer.  A  * negative count is a special case.  if one is seen, *SPECIAL is set  * to the (negative) count value and no additional data is gathered  * from the buffer; normally *SPECIAL is set to 0.  This function  * returns the number of bytes it needs to see in order to actually  * copy something over.  */
end_comment

begin_function
name|int
name|buf_copy_counted
parameter_list|(
name|outbuf
parameter_list|,
name|inbuf
parameter_list|,
name|special
parameter_list|)
name|struct
name|buffer
modifier|*
name|outbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|inbuf
decl_stmt|;
name|int
modifier|*
name|special
decl_stmt|;
block|{
operator|*
name|special
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
union|union
block|{
name|char
name|intbuf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|u
union|;
name|char
modifier|*
name|intp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|start
decl_stmt|;
name|int
name|startoff
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|stop
decl_stmt|;
name|int
name|stopwant
decl_stmt|;
comment|/* See if we have enough bytes to figure out the count.  */
name|need
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|intp
operator|=
name|u
operator|.
name|intbuf
expr_stmt|;
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
if|if
condition|(
name|data
operator|->
name|size
operator|>=
name|need
condition|)
block|{
name|memcpy
argument_list|(
name|intp
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|need
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|intp
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
name|intp
operator|+=
name|data
operator|->
name|size
expr_stmt|;
name|need
operator|-=
name|data
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have enough bytes to form an integer.  */
return|return
name|need
return|;
block|}
name|count
operator|=
name|u
operator|.
name|i
expr_stmt|;
name|start
operator|=
name|data
expr_stmt|;
name|startoff
operator|=
name|need
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
comment|/* A negative COUNT is a special case meaning that we                don't need any further information.  */
name|stop
operator|=
name|start
expr_stmt|;
name|stopwant
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We have an integer in COUNT.  We have gotten all the 	     * data from INBUF in all buffers before START, and we 	     * have gotten STARTOFF bytes from START.  See if we have 	     * enough bytes remaining in INBUF. 	     */
name|need
operator|=
name|count
operator|-
operator|(
name|start
operator|->
name|size
operator|-
name|startoff
operator|)
expr_stmt|;
if|if
condition|(
name|need
operator|<=
literal|0
condition|)
block|{
name|stop
operator|=
name|start
expr_stmt|;
name|stopwant
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|data
operator|=
name|start
operator|->
name|next
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
if|if
condition|(
name|need
operator|<=
name|data
operator|->
name|size
condition|)
break|break;
name|need
operator|-=
name|data
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have enough bytes.  */
return|return
name|need
return|;
block|}
name|stop
operator|=
name|data
expr_stmt|;
name|stopwant
operator|=
name|need
expr_stmt|;
block|}
block|}
comment|/* 	 * We have enough bytes.  Free any buffers in INBUF before 	 * START, and remove STARTOFF bytes from START, so that we can 	 * forget about STARTOFF. 	 */
name|start
operator|->
name|bufp
operator|+=
name|startoff
expr_stmt|;
name|start
operator|->
name|size
operator|-=
name|startoff
expr_stmt|;
if|if
condition|(
name|start
operator|->
name|size
operator|==
literal|0
condition|)
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|stop
operator|->
name|size
operator|==
name|stopwant
condition|)
block|{
name|stop
operator|=
name|stop
operator|->
name|next
expr_stmt|;
name|stopwant
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|inbuf
operator|->
name|data
operator|!=
name|start
condition|)
block|{
name|data
operator|=
name|inbuf
operator|->
name|data
expr_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|data
expr_stmt|;
block|}
comment|/* If COUNT is negative, set *SPECIAL and get out now.  */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
operator|*
name|special
operator|=
name|count
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * We want to copy over the bytes from START through STOP.  We 	 * only want STOPWANT bytes from STOP. 	 */
if|if
condition|(
name|start
operator|!=
name|stop
condition|)
block|{
comment|/* Attach the buffers from START through STOP to OUTBUF.  */
for|for
control|(
name|data
operator|=
name|start
init|;
name|data
operator|->
name|next
operator|!=
name|stop
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
empty_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|stop
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|start
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stopwant
operator|>
literal|0
condition|)
block|{
name|buf_output
argument_list|(
name|outbuf
argument_list|,
name|stop
operator|->
name|bufp
argument_list|,
name|stopwant
argument_list|)
expr_stmt|;
name|stop
operator|->
name|bufp
operator|+=
name|stopwant
expr_stmt|;
name|stop
operator|->
name|size
operator|-=
name|stopwant
expr_stmt|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Shut down a buffer.  This returns 0 on success, or an errno code.  */
end_comment

begin_function
name|int
name|buf_shutdown
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|shutdown
condition|)
return|return
call|(
modifier|*
name|buf
operator|->
name|shutdown
call|)
argument_list|(
name|buf
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The simplest type of buffer is one built on top of a stdio FILE.    For simplicity, and because it is all that is required, we do not    implement setting this type of buffer into nonblocking mode.  The    closure field is just a FILE *.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdio_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stdio_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stdio_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stdio_buffer_shutdown
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a buffer built on a stdio FILE.  */
end_comment

begin_struct
struct|struct
name|stdio_buffer_closure
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|buffer
modifier|*
name|stdio_buffer_initialize
parameter_list|(
name|fp
parameter_list|,
name|child_pid
parameter_list|,
name|input
parameter_list|,
name|memory
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
name|int
name|input
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bc
argument_list|)
argument_list|)
decl_stmt|;
name|bc
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
name|bc
operator|->
name|child_pid
operator|=
name|child_pid
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|stdio_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|stdio_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|stdio_buffer_flush
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|NULL
argument_list|,
name|stdio_buffer_shutdown
argument_list|,
name|memory
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Return the file associated with a stdio buffer. */
end_comment

begin_function
name|FILE
modifier|*
name|stdio_buffer_get_file
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|shutdown
operator|==
name|stdio_buffer_shutdown
argument_list|)
expr_stmt|;
name|bc
operator|=
operator|(
expr|struct
name|stdio_buffer_closure
operator|*
operator|)
name|buf
operator|->
name|closure
expr_stmt|;
return|return
operator|(
name|bc
operator|->
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The buffer input function for a buffer built on a stdio FILE.  */
end_comment

begin_function
specifier|static
name|int
name|stdio_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
init|=
operator|(
expr|struct
name|stdio_buffer_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* Since stdio does its own buffering, we don't worry about        getting more bytes than we need.  */
if|if
condition|(
name|need
operator|==
literal|0
operator|||
name|need
operator|==
literal|1
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
operator|*
name|data
operator|=
name|ch
expr_stmt|;
operator|*
name|got
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nbytes
operator|=
name|fread
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|need
argument_list|,
name|bc
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
operator|*
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
operator|*
name|got
operator|=
name|nbytes
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer output function for a buffer built on a stdio FILE.  */
end_comment

begin_function
specifier|static
name|int
name|stdio_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
init|=
operator|(
expr|struct
name|stdio_buffer_closure
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|wrote
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|have
operator|>
literal|0
condition|)
block|{
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|fwrite
argument_list|(
name|data
argument_list|,
literal|1
argument_list|,
name|have
argument_list|,
name|bc
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
name|have
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
operator|*
name|wrote
operator|+=
name|nbytes
expr_stmt|;
name|have
operator|-=
name|nbytes
expr_stmt|;
name|data
operator|+=
name|nbytes
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer flush function for a buffer built on a stdio FILE.  */
end_comment

begin_function
specifier|static
name|int
name|stdio_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
init|=
operator|(
expr|struct
name|stdio_buffer_closure
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stdio_buffer_shutdown
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|stdio_buffer_closure
modifier|*
name|bc
init|=
name|buf
operator|->
name|closure
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|closefp
decl_stmt|,
name|statted
decl_stmt|;
comment|/* Must be a pipe or a socket. What could go wrong?      * Well, apparently for disconnected clients under AIX, the      * fstat() will return -1 on the server if the client has gone      * away.      */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|statted
operator|=
literal|0
expr_stmt|;
else|else
name|statted
operator|=
literal|1
expr_stmt|;
name|closefp
operator|=
name|statted
expr_stmt|;
comment|/* Flush the buffer if we can */
if|if
condition|(
name|buf
operator|->
name|flush
condition|)
block|{
name|buf_flush
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|->
name|flush
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|input
condition|)
block|{
comment|/* There used to be a check here for unread data in the buffer of on 	 * the pipe, but it was deemed unnecessary and possibly dangerous.  In 	 * some sense it could be second-guessing the caller who requested it 	 * closed, as well. 	 */
ifdef|#
directive|ifdef
name|SHUTDOWN_SERVER
if|if
condition|(
name|current_parsed_root
operator|->
name|method
operator|!=
name|server_method
condition|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SOCKET_TO_FD
block|{
comment|/* shutdown() sockets */
if|if
condition|(
name|statted
operator|&&
name|S_ISSOCK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
ifdef|#
directive|ifdef
name|START_RSH_WITH_POPEN_RW
comment|/* Can't be set with SHUTDOWN_SERVER defined */
elseif|else
if|if
condition|(
name|pclose
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing connection to %s"
argument_list|,
name|current_parsed_root
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|closefp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* START_RSH_WITH_POPEN_RW */
name|buf
operator|->
name|input
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|output
condition|)
block|{
ifdef|#
directive|ifdef
name|SHUTDOWN_SERVER
comment|/* FIXME:  Should have a SHUTDOWN_SERVER_INPUT& 	 * SHUTDOWN_SERVER_OUTPUT 	 */
if|if
condition|(
name|current_parsed_root
operator|->
name|method
operator|==
name|server_method
condition|)
name|SHUTDOWN_SERVER
argument_list|(
name|fileno
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SOCKET_TO_FD
comment|/* shutdown() sockets */
if|if
condition|(
name|statted
operator|&&
name|S_ISSOCK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
comment|/* I'm not sure I like this empty block, but the alternative 	 * is a another nested NO_SOCKET_TO_FD switch above. 	 */
block|}
endif|#
directive|endif
comment|/* NO_SOCKET_TO_FD */
name|buf
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|statted
operator|&&
name|closefp
operator|&&
name|fclose
argument_list|(
name|bc
operator|->
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* Syslog this? */
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* We are already closing the connection. 	 * On error, print a warning and try to 	 * continue to avoid infinte loops. 	 */
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"closing down connection to %s"
argument_list|,
name|current_parsed_root
operator|->
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|}
comment|/* If we were talking to a process, make sure it exited */
if|if
condition|(
name|bc
operator|->
name|child_pid
condition|)
block|{
name|int
name|w
decl_stmt|;
do|do
name|w
operator|=
name|waitpid
argument_list|(
name|bc
operator|->
name|child_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|while
condition|(
name|w
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
comment|/* We are already closing the connection. 	 * On error, print a warning and try to 	 * continue to avoid infinte loops. 	 */
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"waiting for process %d"
argument_list|,
name|bc
operator|->
name|child_pid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Certain types of communication input and output data in packets,    where each packet is translated in some fashion.  The packetizing    buffer type supports that, given a buffer which handles lower level    I/O and a routine to translate the data in a packet.     This code uses two bytes for the size of a packet, so packets are    restricted to 65536 bytes in total.     The translation functions should just translate; they may not    significantly increase or decrease the amount of data.  The actual    size of the initial data is part of the translated data.  The    output translation routine may add up to PACKET_SLOP additional    bytes, and the input translation routine should shrink the data    correspondingly.  */
end_comment

begin_define
define|#
directive|define
name|PACKET_SLOP
value|(100)
end_define

begin_comment
comment|/* This structure is the closure field of a packetizing buffer.  */
end_comment

begin_struct
struct|struct
name|packetizing_buffer
block|{
comment|/* The underlying buffer.  */
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
comment|/* The input translation function.  Exactly one of inpfn and outfn        will be NULL.  The input translation function should        untranslate the data in INPUT, storing the result in OUTPUT.        SIZE is the amount of data in INPUT, and is also the size of        OUTPUT.  This should return 0 on success, or an errno code.  */
name|int
argument_list|(
argument|*inpfn
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|fnclosure
operator|,
specifier|const
name|char
operator|*
name|input
operator|,
name|char
operator|*
name|output
operator|,
name|int
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* The output translation function.  This should translate the        data in INPUT, storing the result in OUTPUT.  The first two        bytes in INPUT will be the size of the data, and so will SIZE.        This should set *TRANSLATED to the amount of translated data in        OUTPUT.  OUTPUT is large enough to hold SIZE + PACKET_SLOP        bytes.  This should return 0 on success, or an errno code.  */
name|int
argument_list|(
argument|*outfn
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|fnclosure
operator|,
specifier|const
name|char
operator|*
name|input
operator|,
name|char
operator|*
name|output
operator|,
name|int
name|size
operator|,
name|int
operator|*
name|translated
operator|)
argument_list|)
expr_stmt|;
comment|/* A closure for the translation function.  */
name|void
modifier|*
name|fnclosure
decl_stmt|;
comment|/* For an input buffer, we may have to buffer up data here.  */
comment|/* This is non-zero if the buffered data has been translated.        Otherwise, the buffered data has not been translated, and starts        with the two byte packet size.  */
name|int
name|translated
decl_stmt|;
comment|/* The amount of buffered data.  */
name|int
name|holdsize
decl_stmt|;
comment|/* The buffer allocated to hold the data.  */
name|char
modifier|*
name|holdbuf
decl_stmt|;
comment|/* The size of holdbuf.  */
name|int
name|holdbufsize
decl_stmt|;
comment|/* If translated is set, we need another data pointer to track        where we are in holdbuf.  If translated is clear, then this        pointer is not used.  */
name|char
modifier|*
name|holddata
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|packetizing_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetizing_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetizing_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetizing_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packetizing_buffer_shutdown
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a packetizing buffer.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|packetizing_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|inpfn
parameter_list|,
name|outfn
parameter_list|,
name|fnclosure
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*inpfn
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*outfn
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|fnclosure
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*memory
argument_list|)
end_macro

begin_expr_stmt
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
decl_stmt|;
name|pb
operator|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|pb
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|pb
argument_list|)
expr_stmt|;
name|pb
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
name|pb
operator|->
name|inpfn
operator|=
name|inpfn
expr_stmt|;
name|pb
operator|->
name|outfn
operator|=
name|outfn
expr_stmt|;
name|pb
operator|->
name|fnclosure
operator|=
name|fnclosure
expr_stmt|;
if|if
condition|(
name|inpfn
operator|!=
name|NULL
condition|)
block|{
comment|/* Add PACKET_SLOP to handle larger translated packets, and            add 2 for the count.  This buffer is increased if            necessary.  */
name|pb
operator|->
name|holdbufsize
operator|=
name|BUFFER_DATA_SIZE
operator|+
name|PACKET_SLOP
operator|+
literal|2
expr_stmt|;
name|pb
operator|->
name|holdbuf
operator|=
name|xmalloc
argument_list|(
name|pb
operator|->
name|holdbufsize
argument_list|)
expr_stmt|;
block|}
return|return
name|buf_initialize
argument_list|(
name|inpfn
operator|!=
name|NULL
condition|?
name|packetizing_buffer_input
else|:
name|NULL
argument_list|,
name|inpfn
operator|!=
name|NULL
condition|?
name|NULL
else|:
name|packetizing_buffer_output
argument_list|,
name|inpfn
operator|!=
name|NULL
condition|?
name|NULL
else|:
name|packetizing_buffer_flush
argument_list|,
name|packetizing_buffer_block
argument_list|,
name|packetizing_buffer_shutdown
argument_list|,
name|memory
argument_list|,
name|pb
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Input data from a packetizing buffer.  */
end_comment

begin_function
specifier|static
name|int
name|packetizing_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
init|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|holdsize
operator|>
literal|0
operator|&&
name|pb
operator|->
name|translated
condition|)
block|{
name|int
name|copy
decl_stmt|;
name|copy
operator|=
name|pb
operator|->
name|holdsize
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|size
condition|)
block|{
name|memcpy
argument_list|(
name|data
argument_list|,
name|pb
operator|->
name|holddata
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pb
operator|->
name|holdsize
operator|-=
name|size
expr_stmt|;
name|pb
operator|->
name|holddata
operator|+=
name|size
expr_stmt|;
operator|*
name|got
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|pb
operator|->
name|holddata
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|pb
operator|->
name|holdsize
operator|=
literal|0
expr_stmt|;
name|pb
operator|->
name|translated
operator|=
literal|0
expr_stmt|;
name|data
operator|+=
name|copy
expr_stmt|;
name|need
operator|-=
name|copy
expr_stmt|;
name|size
operator|-=
name|copy
expr_stmt|;
operator|*
name|got
operator|=
name|copy
expr_stmt|;
block|}
while|while
condition|(
name|need
operator|>
literal|0
operator|||
operator|*
name|got
operator|==
literal|0
condition|)
block|{
name|int
name|get
decl_stmt|,
name|status
decl_stmt|,
name|nread
decl_stmt|,
name|count
decl_stmt|,
name|tcount
decl_stmt|;
name|char
modifier|*
name|bytes
decl_stmt|;
name|char
name|stackoutbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
name|PACKET_SLOP
index|]
decl_stmt|;
name|char
modifier|*
name|inbuf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
comment|/* If we don't already have the two byte count, get it.  */
if|if
condition|(
name|pb
operator|->
name|holdsize
operator|<
literal|2
condition|)
block|{
name|get
operator|=
literal|2
operator|-
name|pb
operator|->
name|holdsize
expr_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|pb
operator|->
name|buf
argument_list|,
name|get
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* buf_read_data can return -2, but a buffer input                    function is only supposed to return -1, 0, or an                    error code.  */
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|status
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
comment|/* The buffer is in nonblocking mode, and we didn't                    manage to read anything.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|get
operator|==
literal|1
condition|)
name|pb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|=
name|bytes
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|pb
operator|->
name|holdbuf
index|[
literal|0
index|]
operator|=
name|bytes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|2
condition|)
block|{
comment|/* We only got one byte, but we needed two.  Stash                        the byte we got, and try again.  */
name|pb
operator|->
name|holdsize
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|pb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|=
name|bytes
index|[
literal|1
index|]
expr_stmt|;
block|}
name|pb
operator|->
name|holdsize
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Read the packet.  */
name|count
operator|=
operator|(
operator|(
operator|(
name|pb
operator|->
name|holdbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|pb
operator|->
name|holdbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|2
operator|>
name|pb
operator|->
name|holdbufsize
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
comment|/* We didn't allocate enough space in the initialize                function.  */
name|n
operator|=
name|xrealloc
argument_list|(
name|pb
operator|->
name|holdbuf
argument_list|,
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|pb
operator|->
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|pb
operator|->
name|holdbuf
operator|=
name|n
expr_stmt|;
name|pb
operator|->
name|holdbufsize
operator|=
name|count
operator|+
literal|2
expr_stmt|;
block|}
name|get
operator|=
name|count
operator|-
operator|(
name|pb
operator|->
name|holdsize
operator|-
literal|2
operator|)
expr_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|pb
operator|->
name|buf
argument_list|,
name|get
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* buf_read_data can return -2, but a buffer input                function is only supposed to return -1, 0, or an error                code.  */
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|status
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
comment|/* We did not get any data.  Presumably the buffer is in                nonblocking mode.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nread
operator|<
name|get
condition|)
block|{
comment|/* We did not get all the data we need to fill the packet.                buf_read_data does not promise to return all the bytes                requested, so we must try again.  */
name|memcpy
argument_list|(
name|pb
operator|->
name|holdbuf
operator|+
name|pb
operator|->
name|holdsize
argument_list|,
name|bytes
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|pb
operator|->
name|holdsize
operator|+=
name|nread
expr_stmt|;
continue|continue;
block|}
comment|/* We have a complete untranslated packet of COUNT bytes.  */
if|if
condition|(
name|pb
operator|->
name|holdsize
operator|==
literal|2
condition|)
block|{
comment|/* We just read the entire packet (the 2 bytes in                PB->HOLDBUF are the size).  Save a memcpy by                translating directly from BYTES.  */
name|inbuf
operator|=
name|bytes
expr_stmt|;
block|}
else|else
block|{
comment|/* We already had a partial packet in PB->HOLDBUF.  We                need to copy the new data over to make the input                contiguous.  */
name|memcpy
argument_list|(
name|pb
operator|->
name|holdbuf
operator|+
name|pb
operator|->
name|holdsize
argument_list|,
name|bytes
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|inbuf
operator|=
name|pb
operator|->
name|holdbuf
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
sizeof|sizeof
name|stackoutbuf
condition|)
name|outbuf
operator|=
name|stackoutbuf
expr_stmt|;
else|else
block|{
name|outbuf
operator|=
name|xmalloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|pb
operator|->
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
name|status
operator|=
call|(
modifier|*
name|pb
operator|->
name|inpfn
call|)
argument_list|(
name|pb
operator|->
name|fnclosure
argument_list|,
name|inbuf
argument_list|,
name|outbuf
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
comment|/* The first two bytes in the translated buffer are the real            length of the translated data.  */
name|tcount
operator|=
operator|(
operator|(
name|outbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|outbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|tcount
operator|>
name|count
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Input translation failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
operator|>
name|size
condition|)
block|{
comment|/* We have more data than the caller has provided space                for.  We need to save some of it for the next call.  */
name|memcpy
argument_list|(
name|data
argument_list|,
name|outbuf
operator|+
literal|2
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|got
operator|+=
name|size
expr_stmt|;
name|pb
operator|->
name|holdsize
operator|=
name|tcount
operator|-
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|pb
operator|->
name|holdbuf
argument_list|,
name|outbuf
operator|+
literal|2
operator|+
name|size
argument_list|,
name|tcount
operator|-
name|size
argument_list|)
expr_stmt|;
name|pb
operator|->
name|holddata
operator|=
name|pb
operator|->
name|holdbuf
expr_stmt|;
name|pb
operator|->
name|translated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|outbuf
operator|!=
name|stackoutbuf
condition|)
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|data
argument_list|,
name|outbuf
operator|+
literal|2
argument_list|,
name|tcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|!=
name|stackoutbuf
condition|)
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|pb
operator|->
name|holdsize
operator|=
literal|0
expr_stmt|;
name|data
operator|+=
name|tcount
expr_stmt|;
name|need
operator|-=
name|tcount
expr_stmt|;
name|size
operator|-=
name|tcount
expr_stmt|;
operator|*
name|got
operator|+=
name|tcount
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output data to a packetizing buffer.  */
end_comment

begin_function
specifier|static
name|int
name|packetizing_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
init|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|char
name|inbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|stack_outbuf
index|[
name|BUFFER_DATA_SIZE
operator|+
name|PACKET_SLOP
operator|+
literal|4
index|]
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|outdata
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
name|int
name|size
decl_stmt|,
name|status
decl_stmt|,
name|translated
decl_stmt|;
if|if
condition|(
name|have
operator|>
name|BUFFER_DATA_SIZE
condition|)
block|{
comment|/* It would be easy to xmalloc a buffer, but I don't think this            case can ever arise.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|inbuf
index|[
literal|0
index|]
operator|=
operator|(
name|have
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|inbuf
index|[
literal|1
index|]
operator|=
name|have
operator|&
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
name|inbuf
operator|+
literal|2
argument_list|,
name|data
argument_list|,
name|have
argument_list|)
expr_stmt|;
name|size
operator|=
name|have
operator|+
literal|2
expr_stmt|;
comment|/* The output function is permitted to add up to PACKET_SLOP        bytes, and we need 2 bytes for the size of the translated data.        If we can guarantee that the result will fit in a buffer_data,        we translate directly into one to avoid a memcpy in buf_output.  */
if|if
condition|(
name|size
operator|+
name|PACKET_SLOP
operator|+
literal|2
operator|>
name|BUFFER_DATA_SIZE
condition|)
name|outbuf
operator|=
name|stack_outbuf
expr_stmt|;
else|else
block|{
name|outdata
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|pb
operator|->
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|outdata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|outdata
operator|->
name|bufp
operator|=
name|outdata
operator|->
name|text
expr_stmt|;
name|outbuf
operator|=
name|outdata
operator|->
name|text
expr_stmt|;
block|}
name|status
operator|=
call|(
modifier|*
name|pb
operator|->
name|outfn
call|)
argument_list|(
name|pb
operator|->
name|fnclosure
argument_list|,
name|inbuf
argument_list|,
name|outbuf
operator|+
literal|2
argument_list|,
name|size
argument_list|,
operator|&
name|translated
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
comment|/* The output function is permitted to add up to PACKET_SLOP        bytes.  */
if|if
condition|(
name|translated
operator|>
name|size
operator|+
name|PACKET_SLOP
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outbuf
index|[
literal|0
index|]
operator|=
operator|(
name|translated
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|outbuf
index|[
literal|1
index|]
operator|=
name|translated
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|outbuf
operator|==
name|stack_outbuf
condition|)
name|buf_output
argument_list|(
name|pb
operator|->
name|buf
argument_list|,
name|outbuf
argument_list|,
name|translated
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* if ((have + PACKET_SLOP + 4)> BUFFER_DATA_SIZE), then 	   outdata may be NULL. */
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outdata
operator|->
name|size
operator|=
name|translated
operator|+
literal|2
expr_stmt|;
name|buf_append_data
argument_list|(
name|pb
operator|->
name|buf
argument_list|,
name|outdata
argument_list|,
name|outdata
argument_list|)
expr_stmt|;
block|}
operator|*
name|wrote
operator|=
name|have
expr_stmt|;
comment|/* We will only be here because buf_send_output was called on the        packetizing buffer.  That means that we should now call        buf_send_output on the underlying buffer.  */
return|return
name|buf_send_output
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Flush data to a packetizing buffer.  */
end_comment

begin_function
specifier|static
name|int
name|packetizing_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
init|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|closure
decl_stmt|;
comment|/* Flush the underlying buffer.  Note that if the original call to        buf_flush passed 1 for the BLOCK argument, then the buffer will        already have been set into blocking mode, so we should always        pass 0 here.  */
return|return
name|buf_flush
argument_list|(
name|pb
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The block routine for a packetizing buffer.  */
end_comment

begin_function
specifier|static
name|int
name|packetizing_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
init|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|set_block
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
name|set_nonblock
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Shut down a packetizing buffer.  */
end_comment

begin_function
specifier|static
name|int
name|packetizing_buffer_shutdown
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|packetizing_buffer
modifier|*
name|pb
init|=
operator|(
expr|struct
name|packetizing_buffer
operator|*
operator|)
name|buf
operator|->
name|closure
decl_stmt|;
return|return
name|buf_shutdown
argument_list|(
name|pb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT) */
end_comment

end_unit

