begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|time_stamp_server
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Vers_TS
operator|*
operator|,
name|Entnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fill in and return a Vers_TS structure for the file FINFO.  TAG and    DATE are from the command line.  */
end_comment

begin_function
name|Vers_TS
modifier|*
name|Version_TS
parameter_list|(
name|finfo
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|force_tag_match
parameter_list|,
name|set_time
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
comment|/* Keyword expansion options, I think generally from the command        line.  Can be either NULL or "" to indicate none are specified        here.  */
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|force_tag_match
decl_stmt|;
name|int
name|set_time
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSNode
modifier|*
name|rcsdata
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|struct
name|stickydirtag
modifier|*
name|sdtp
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
name|int
name|change_it_back
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* get a new Vers_TS struct */
name|vers_ts
operator|=
operator|(
name|Vers_TS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Vers_TS
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vers_ts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vers_ts
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * look up the entries file entry and fill in the version and timestamp      * if entries is NULL, there is no entries file so don't bother trying to      * look it up (used by checkout -P)      */
if|if
condition|(
name|finfo
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|sdtp
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|findnode_fn
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|sdtp
operator|=
operator|(
expr|struct
name|stickydirtag
operator|*
operator|)
name|finfo
operator|->
name|entries
operator|->
name|list
operator|->
name|data
expr_stmt|;
comment|/* list-private */
block|}
name|entdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|entdata
operator|->
name|type
operator|==
name|ENT_SUBDIR
condition|)
block|{
comment|/* According to cvs.texinfo, the various fields in the Entries 	       file for a directory (other than the name) do not have a 	       defined meaning.  We need to pass them along without getting 	       confused based on what is in them.  Therefore we make sure 	       not to set vn_user and the like from Entries, add.c and 	       perhaps other code will expect these fields to be NULL for 	       a directory.  */
name|vers_ts
operator|->
name|entdata
operator|=
name|entdata
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* An entries line with "D" in the timestamp indicates that the 	   client sent Is-modified without sending Entry.  So we want to 	   use the entries line for the sole purpose of telling 	   time_stamp_server what is up; we don't want the rest of CVS 	   to think there is an entries line.  */
if|if
condition|(
name|strcmp
argument_list|(
name|entdata
operator|->
name|timestamp
argument_list|,
literal|"D"
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|vers_ts
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|version
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|ts_rcs
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|ts_conflict
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|conflict
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tag
operator|||
name|date
operator|)
operator|&&
operator|!
operator|(
name|sdtp
operator|&&
name|sdtp
operator|->
name|aflag
operator|)
condition|)
block|{
name|vers_ts
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|tag
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|date
argument_list|)
expr_stmt|;
block|}
name|vers_ts
operator|->
name|entdata
operator|=
name|entdata
expr_stmt|;
block|}
comment|/* Even if we don't have an "entries line" as such 	   (vers_ts->entdata), we want to pick up options which could 	   have been from a Kopt protocol request.  */
if|if
condition|(
operator|!
name|options
operator|||
operator|*
name|options
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sdtp
operator|&&
name|sdtp
operator|->
name|aflag
operator|)
condition|)
name|vers_ts
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|options
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * -k options specified on the command line override (and overwrite)      * options stored in the entries file      */
if|if
condition|(
name|options
operator|&&
operator|*
name|options
operator|!=
literal|'\0'
condition|)
name|vers_ts
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|options
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vers_ts
operator|->
name|options
operator|||
operator|*
name|vers_ts
operator|->
name|options
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
condition|)
block|{
comment|/* If no keyword expansion was specified on command line, 	       use whatever was in the rcs file (if there is one).  This 	       is how we, if we are the server, tell the client whether 	       a file is binary.  */
name|char
modifier|*
name|rcsexpand
init|=
name|RCS_getexpand
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|)
decl_stmt|;
if|if
condition|(
name|rcsexpand
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vers_ts
operator|->
name|options
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|options
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|options
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rcsexpand
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vers_ts
operator|->
name|options
argument_list|,
literal|"-k"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|vers_ts
operator|->
name|options
argument_list|,
name|rcsexpand
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|vers_ts
operator|->
name|options
condition|)
name|vers_ts
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/*      * if tags were specified on the command line, they override what is in      * the Entries file      */
if|if
condition|(
name|tag
operator|||
name|date
condition|)
block|{
name|vers_ts
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vers_ts
operator|->
name|entdata
operator|&&
operator|(
name|sdtp
operator|&&
name|sdtp
operator|->
name|aflag
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|vers_ts
operator|->
name|tag
condition|)
block|{
name|vers_ts
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|sdtp
operator|->
name|tag
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|nonbranch
operator|=
name|sdtp
operator|->
name|nonbranch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vers_ts
operator|->
name|date
condition|)
name|vers_ts
operator|->
name|date
operator|=
name|xstrdup
argument_list|(
name|sdtp
operator|->
name|date
argument_list|)
expr_stmt|;
block|}
comment|/* Now look up the info on the source controlled file */
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|rcsdata
operator|=
name|finfo
operator|->
name|rcs
expr_stmt|;
name|rcsdata
operator|->
name|refcount
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|finfo
operator|->
name|repository
operator|!=
name|NULL
condition|)
name|rcsdata
operator|=
name|RCS_parse
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
else|else
name|rcsdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rcsdata
operator|!=
name|NULL
condition|)
block|{
comment|/* squirrel away the rcsdata pointer for others */
name|vers_ts
operator|->
name|srcfile
operator|=
name|rcsdata
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|tag
operator|&&
name|strcmp
argument_list|(
name|vers_ts
operator|->
name|tag
argument_list|,
name|TAG_BASE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|xstrdup
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_tag
operator|=
name|xstrdup
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|simple
decl_stmt|;
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|RCS_getversion
argument_list|(
name|rcsdata
argument_list|,
name|vers_ts
operator|->
name|tag
argument_list|,
name|vers_ts
operator|->
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|&
name|simple
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
name|vers_ts
operator|->
name|vn_tag
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|simple
condition|)
name|vers_ts
operator|->
name|vn_tag
operator|=
name|xstrdup
argument_list|(
name|vers_ts
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|vers_ts
operator|->
name|vn_tag
operator|=
name|xstrdup
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the source control file exists and has the requested revision, 	 * get the Date the revision was checked in.  If "user" exists, set 	 * its mtime. 	 */
if|if
condition|(
name|set_time
operator|&&
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_modtime
argument_list|(
name|finfo
argument_list|,
name|vers_ts
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|struct
name|utimbuf
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|RCS_getrevtime
argument_list|(
name|rcsdata
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|modtime
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|t
operator|.
name|actime
operator|=
name|t
operator|.
name|modtime
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
if|if
condition|(
operator|!
name|iswritable
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|change_it_back
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UTIME_EXPECTS_WRITABLE  */
comment|/* This used to need to ignore existence_errors 		       (for cases like where update.c now clears 		       set_time if noexec, but didn't used to).  I 		       think maybe now it doesn't (server_modtime does 		       not like those kinds of cases).  */
operator|(
name|void
operator|)
name|utime
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIME_EXPECTS_WRITABLE
if|if
condition|(
name|change_it_back
operator|==
literal|1
condition|)
block|{
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_it_back
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  UTIME_EXPECTS_WRITABLE  */
block|}
block|}
block|}
block|}
comment|/* get user file time-stamp in ts_user */
if|if
condition|(
name|finfo
operator|->
name|entries
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|time_stamp_server
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|vers_ts
argument_list|,
name|entdata
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vers_ts
operator|->
name|ts_user
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vers_ts
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* Set VERS_TS->TS_USER to time stamp for FILE.  */
end_comment

begin_comment
comment|/* Separate these out to keep the logic below clearer.  */
end_comment

begin_define
define|#
directive|define
name|mark_lost
parameter_list|(
name|V
parameter_list|)
value|((V)->ts_user = 0)
end_define

begin_define
define|#
directive|define
name|mark_unchanged
parameter_list|(
name|V
parameter_list|)
value|((V)->ts_user = xstrdup ((V)->ts_rcs))
end_define

begin_function
specifier|static
name|void
name|time_stamp_server
parameter_list|(
name|file
parameter_list|,
name|vers_ts
parameter_list|,
name|entdata
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat temp file"
argument_list|)
expr_stmt|;
comment|/* Missing file means lost or unmodified; check entries 	   file to see which.  	   XXX FIXME - If there's no entries file line, we 	   wouldn't be getting the file at all, so consider it 	   lost.  I don't know that that's right, but it's not 	   clear to me that either choice is.  Besides, would we 	   have an RCS string in that case anyways?  */
if|if
condition|(
name|entdata
operator|==
name|NULL
condition|)
name|mark_lost
argument_list|(
name|vers_ts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entdata
operator|->
name|timestamp
operator|&&
name|entdata
operator|->
name|timestamp
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
name|mark_unchanged
argument_list|(
name|vers_ts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entdata
operator|->
name|timestamp
operator|!=
name|NULL
operator|&&
operator|(
name|entdata
operator|->
name|timestamp
index|[
literal|0
index|]
operator|==
literal|'M'
operator|||
name|entdata
operator|->
name|timestamp
index|[
literal|0
index|]
operator|==
literal|'D'
operator|)
operator|&&
name|entdata
operator|->
name|timestamp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|vers_ts
operator|->
name|ts_user
operator|=
name|xstrdup
argument_list|(
literal|"Is-modified"
argument_list|)
expr_stmt|;
else|else
name|mark_lost
argument_list|(
name|vers_ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_mtime
operator|==
literal|0
condition|)
block|{
comment|/* We shouldn't reach this case any more!  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|struct
name|tm
modifier|*
name|tm_p
decl_stmt|;
name|struct
name|tm
name|local_tm
decl_stmt|;
name|vers_ts
operator|->
name|ts_user
operator|=
name|xmalloc
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* We want to use the same timestamp format as is stored in the 	   st_mtime.  For unix (and NT I think) this *must* be universal 	   time (UT), so that files don't appear to be modified merely 	   because the timezone has changed.  For VMS, or hopefully other 	   systems where gmtime returns NULL, the modification time is 	   stored in local time, and therefore it is not possible to cause 	   st_mtime to be out of sync by changing the timezone.  */
name|tm_p
operator|=
name|gmtime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm_p
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|local_tm
argument_list|,
name|tm_p
argument_list|,
sizeof|sizeof
argument_list|(
name|local_tm
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|asctime
argument_list|(
operator|&
name|local_tm
argument_list|)
expr_stmt|;
comment|/* copy in the modify time */
block|}
else|else
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|cp
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fix non-standard format.  */
if|if
condition|(
name|cp
index|[
literal|8
index|]
operator|==
literal|'0'
condition|)
name|cp
index|[
literal|8
index|]
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vers_ts
operator|->
name|ts_user
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/*  * Gets the time-stamp for the file "file" and returns it in space it  * allocates  */
end_comment

begin_function
name|char
modifier|*
name|time_stamp
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ts
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|tm
modifier|*
name|tm_p
decl_stmt|;
name|struct
name|tm
name|local_tm
decl_stmt|;
name|ts
operator|=
name|xmalloc
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* We want to use the same timestamp format as is stored in the 	   st_mtime.  For unix (and NT I think) this *must* be universal 	   time (UT), so that files don't appear to be modified merely 	   because the timezone has changed.  For VMS, or hopefully other 	   systems where gmtime returns NULL, the modification time is 	   stored in local time, and therefore it is not possible to cause 	   st_mtime to be out of sync by changing the timezone.  */
name|tm_p
operator|=
name|gmtime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm_p
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|local_tm
argument_list|,
name|tm_p
argument_list|,
sizeof|sizeof
argument_list|(
name|local_tm
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|asctime
argument_list|(
operator|&
name|local_tm
argument_list|)
expr_stmt|;
comment|/* copy in the modify time */
block|}
else|else
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|sb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|cp
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fix non-standard format.  */
if|if
condition|(
name|cp
index|[
literal|8
index|]
operator|==
literal|'0'
condition|)
name|cp
index|[
literal|8
index|]
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ts
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ts
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free up a Vers_TS struct  */
end_comment

begin_function
name|void
name|freevers_ts
parameter_list|(
name|versp
parameter_list|)
name|Vers_TS
modifier|*
modifier|*
name|versp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|srcfile
condition|)
name|freercsnode
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|srcfile
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_user
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_rcs
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_tag
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|vn_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_user
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_rcs
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|options
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|tag
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|date
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_conflict
condition|)
name|free
argument_list|(
operator|(
operator|*
name|versp
operator|)
operator|->
name|ts_conflict
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|versp
argument_list|)
expr_stmt|;
operator|*
name|versp
operator|=
operator|(
name|Vers_TS
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

end_unit

