begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * "update" updates the version in the present directory with respect to the RCS  * repository.  The present version must have been created by "checkout". The  * user can keep up-to-date by calling "update" whenever he feels like it.  *   * The present version can be committed by "commit", but this keeps the version  * in tact.  *   * Arguments following the options are taken to be file names to be updated,  * rather than updating the entire directory.  *   * Modified or non-existent RCS files are checked out and reported as U  *<user_file>  *   * Modified user files are reported as M<user_file>.  If both the RCS file and  * the user file have been modified, the user file is replaced by the result  * of rcsmerge, and a backup file is written for the user in .#file.version.  * If this throws up irreconcilable differences, the file is reported as C  *<user_file>, and as M<user_file> otherwise.  *   * Files added but not yet committed are reported as A<user_file>. Files  * removed but not yet committed are reported as R<user_file>.  *   * If the current directory contains subdirectories that hold concurrent  * versions, these are updated too.  If the -d option was specified, new  * directories added to the repository are automatically created and updated  * as well.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|checkout_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|int
name|adding
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|patch_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|int
operator|*
name|docheckout
operator|,
expr|struct
name|stat
operator|*
name|file_info
operator|,
name|unsigned
name|char
operator|*
name|checksum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_file_write
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|merge_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scratch_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|update_dirent_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_dirleave_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_filesdone_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_letter
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|int
name|letter
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|join_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|join_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a bit of a kludge.  We call WriteTag at the beginning    before we know whether nonbranch is set or not.  And then at the    end, once we have the right value for nonbranch, we call WriteTag    again.  I don't know whether the first call is necessary or not.    rewrite_tag is nonzero if we are going to have to make that second    call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rewrite_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonbranch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
decl_stmt|,
modifier|*
name|date_rev1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
decl_stmt|,
modifier|*
name|date_rev2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_build_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_prune_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|patches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcs_diff_patches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|update_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]\n"
block|,
literal|"    [-I ign] [-W spec] [files...]\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-d\tBuild directories, like checkout does.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-p\tSend updates to standard output (avoids stickiness).\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-r rev\tUpdate using specified revision/tag (is sticky).\n"
block|,
literal|"\t-D date\tSet date to update from (is sticky).\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
literal|"\t-W spec\tWrappers specification line.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * update is the argv,argc based front end for arg parsing  */
end_comment

begin_function
name|int
name|update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
comment|/* recursive by default */
name|int
name|which
decl_stmt|;
comment|/* where to look for files and dirs */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
comment|/* parse the args */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+ApPflRQqduk:r:D:j:I:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|wrap_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|update_build_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|update_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|patches
operator|=
literal|1
expr_stmt|;
name|rcs_diff_patches
operator|=
name|server_use_rcs_diff
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|int
name|pass
decl_stmt|;
comment|/* The first pass does the regular update.  If we receive at least 	   one patch which failed, we do a second pass and just fetch 	   those files whose patches failed.  */
name|pass
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|int
name|status
decl_stmt|;
name|start_server
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_build_dirs
condition|)
name|send_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipeout
condition|)
name|send_arg
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|send_arg
argument_list|(
literal|"-A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
condition|)
name|send_arg
argument_list|(
literal|"-P"
argument_list|)
expr_stmt|;
name|client_prune_dirs
operator|=
name|update_prune_dirs
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|send_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev2
argument_list|)
expr_stmt|;
name|wrap_send
argument_list|()
expr_stmt|;
comment|/* If the server supports the command "update-patches", that means 	       that it knows how to handle the -u argument to update, which 	       means to send patches instead of complete files.  */
if|if
condition|(
name|failed_patches
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|DONT_USE_PATCH
comment|/* Systems which don't have the patch program ported to them 		   will want to define DONT_USE_PATCH; then CVS won't try to 		   invoke patch.  */
if|if
condition|(
name|supported_request
argument_list|(
literal|"update-patches"
argument_list|)
condition|)
name|send_arg
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|failed_patches
operator|==
name|NULL
condition|)
block|{
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
comment|/* If noexec, probably could be setting SEND_NO_CONTENTS. 		   Same caveats as for "cvs status" apply.  */
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|update_build_dirs
condition|?
name|SEND_BUILD_DIRS
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s client: refetching unpatchable files\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|toplevel_wd
operator|!=
name|NULL
operator|&&
name|CVS_CHDIR
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|failed_patches_count
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|failed_patches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|update_build_dirs
condition|?
name|SEND_BUILD_DIRS
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|failed_patches
operator|=
name|NULL
expr_stmt|;
name|failed_patches_count
operator|=
literal|0
expr_stmt|;
name|send_to_server
argument_list|(
literal|"update\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
comment|/* If there are any conflicts, the server will return a                non-zero exit status.  If any patches failed, we still                want to run the update again.  We use a pass count to                avoid an endless loop.  */
comment|/* Notes: (1) assuming that status != 0 implies a 	       potential conflict is the best we can cleanly do given 	       the current protocol.  I suppose that trying to 	       re-fetch in cases where there was a more serious error 	       is probably more or less harmless, but it isn't really 	       ideal.  (2) it would be nice to have a testsuite case for the 	       conflict-and-patch-failed case.  */
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
operator|(
name|failed_patches
operator|==
name|NULL
operator|||
name|pass
operator|>
literal|1
operator|)
condition|)
block|{
return|return
name|status
return|;
block|}
operator|++
name|pass
expr_stmt|;
block|}
do|while
condition|(
name|failed_patches
operator|!=
name|NULL
condition|)
do|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev1
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev2
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*      * If we are updating the entire directory (for real) and building dirs      * as we go, we make sure there is no static entries file and write the      * tag file as appropriate      */
if|if
condition|(
name|argc
operator|<=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_clear_entstat
argument_list|(
literal|"."
argument_list|,
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
block|{
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|0
argument_list|,
literal|"."
argument_list|,
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* look for files/dirs locally and in the repository */
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
comment|/* look in the attic too if a tag or date is specified */
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
operator|||
name|joining
argument_list|()
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* call the command line interface */
name|err
operator|=
name|do_update
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local
argument_list|,
name|update_build_dirs
argument_list|,
name|aflag
argument_list|,
name|update_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* free the space Make_Date allocated if necessary */
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command line interface to update (used by checkout)  */
end_comment

begin_function
name|int
name|do_update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xoptions
parameter_list|,
name|xtag
parameter_list|,
name|xdate
parameter_list|,
name|xforce
parameter_list|,
name|local
parameter_list|,
name|xbuild
parameter_list|,
name|xaflag
parameter_list|,
name|xprune
parameter_list|,
name|xpipeout
parameter_list|,
name|which
parameter_list|,
name|xjoin_rev1
parameter_list|,
name|xjoin_rev2
parameter_list|,
name|preload_update_dir
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|xoptions
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|xdate
decl_stmt|;
name|int
name|xforce
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|xbuild
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xprune
decl_stmt|;
name|int
name|xpipeout
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|xjoin_rev1
decl_stmt|;
name|char
modifier|*
name|xjoin_rev2
decl_stmt|;
name|char
modifier|*
name|preload_update_dir
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* fill in the statics */
name|options
operator|=
name|xoptions
expr_stmt|;
name|tag
operator|=
name|xtag
expr_stmt|;
name|date
operator|=
name|xdate
expr_stmt|;
name|force_tag_match
operator|=
name|xforce
expr_stmt|;
name|update_build_dirs
operator|=
name|xbuild
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|update_prune_dirs
operator|=
name|xprune
expr_stmt|;
name|pipeout
operator|=
name|xpipeout
expr_stmt|;
comment|/* setup the join support */
name|join_rev1
operator|=
name|xjoin_rev1
expr_stmt|;
name|join_rev2
operator|=
name|xjoin_rev2
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev1
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev1
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev2
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev2
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev2
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* call the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|update_fileproc
argument_list|,
name|update_filesdone_proc
argument_list|,
name|update_dirent_proc
argument_list|,
name|update_dirleave_proc
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|preload_update_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* see if we need to sleep before returning */
if|if
condition|(
name|last_register_time
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|last_register_time
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* to avoid time-stamp races */
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the callback proc for update.  It is called for each file in each  * directory by the recursion code.  The current directory is the local  * instantiation.  file is the file name we are to operate on. update_dir is  * set to the path relative to where we started (for pretty printing).  * repository is the repository. entries and srcfiles are the pre-parsed  * entries and source control files.  *   * This routine decides what needs to be done for each file and does the  * appropriate magic for checkout  */
end_comment

begin_function
specifier|static
name|int
name|update_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|Ctype
name|status
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|resurrecting
decl_stmt|;
name|resurrecting
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|options
argument_list|,
name|force_tag_match
argument_list|,
name|aflag
argument_list|,
operator|&
name|vers
argument_list|,
name|pipeout
argument_list|)
expr_stmt|;
comment|/* Keep track of whether TAG is a branch tag.        Note that if it is a branch tag in some files and a nonbranch tag        in others, treat it as a nonbranch tag.  It is possible that case        should elicit a warning or an error.  */
if|if
condition|(
name|rewrite_tag
operator|&&
name|tag
operator|!=
name|NULL
operator|&&
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rev
init|=
name|RCS_getversion
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
operator|!
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|)
condition|)
name|nonbranch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipeout
condition|)
block|{
comment|/* 	 * We just return success without doing anything if any of the really 	 * funky cases occur 	 *  	 * If there is still a valid RCS file, do a regular checkout type 	 * operation 	 */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
comment|/* needs patch */
endif|#
directive|endif
name|retval
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
if|if
condition|(
name|noexec
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wrap_merge_is_copy
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
if|#
directive|if
literal|0
comment|/* Look, we can't clobber the user's file.  We 			   know it is modified and we're going to 			   overwrite their mod?  Puh-leeze.  The 			   correct behavior is probably something like 			   what merge_file does for -kb, which is to 			   give the users both files and tell them 			   what the two filenames are.  Of course, -m 			   in wrappers needs to be documented *much* 			   better.  Anyway, until then, make this a 			   fatal error.  */
comment|/* Should we be warning the user that we are 			 * overwriting the user's copy of the file?  */
then|retval = 			  checkout_file (finfo, vers, 0);
else|#
directive|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"A -m 'COPY' wrapper is specified"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"but file %s needs merge"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ You probably want to avoid -m 'COPY' wrappers"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|retval
operator|=
name|merge_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* 		     * If the timestamp has changed and no conflict indicators 		     * are found, it isn't a 'C' any more. 		     */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|retcode
operator|=
name|vers
operator|->
name|ts_conflict
index|[
literal|0
index|]
operator|!=
literal|'='
expr_stmt|;
else|else
block|{
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
condition|)
block|{
comment|/* The timestamps differ.  But if there are conflict 			   markers print 'C' anyway.  */
name|retcode
operator|=
operator|!
name|file_has_markers
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
block|{
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Reregister to clear conflict flag. */
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|retval
operator|=
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'M'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
comment|/* needs patch */
if|if
condition|(
name|patches
condition|)
block|{
name|int
name|docheckout
decl_stmt|;
name|struct
name|stat
name|file_info
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
name|retval
operator|=
name|patch_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
operator|&
name|docheckout
argument_list|,
operator|&
name|file_info
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|docheckout
condition|)
block|{
if|if
condition|(
name|server_active
operator|&&
name|retval
operator|==
literal|0
condition|)
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
operator|(
name|rcs_diff_patches
condition|?
name|SERVER_RCS_DIFF
else|:
name|SERVER_PATCHED
operator|)
argument_list|,
operator|&
name|file_info
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
comment|/* If we're not running as a server, just check the 		   file out.  It's simpler and faster than starting up 		   two new processes (diff and patch).  */
comment|/* Fall through.  */
endif|#
directive|endif
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|retval
operator|==
literal|0
condition|)
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'A'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
name|retval
operator|=
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'R'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
name|retval
operator|=
name|scratch_file
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|retval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* only try to join if things have gone well thus far */
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|join_rev1
condition|)
name|join_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|)
expr_stmt|;
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|update_ignproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|update_ignproc
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|write_letter
argument_list|(
name|file
argument_list|,
literal|'?'
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_filesdone_proc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|rewrite_tag
condition|)
block|{
name|WriteTag
argument_list|(
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|nonbranch
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|,
name|update_ignproc
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* I'm not sure the existence_error is actually possible (except 	   in cases where we really should print a message), but since 	   this code used to ignore all errors, I'll play it safe.  */
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|CVSADM
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s directory"
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
elseif|else
if|if
condition|(
operator|!
name|server_active
operator|&&
operator|!
name|pipeout
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
operator|!
name|pipeout
condition|)
endif|#
directive|endif
comment|/* SERVER_SUPPORT */
block|{
comment|/* If there is no CVS/Root file, add one */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM_ROOT
argument_list|)
condition|)
name|Create_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  In this case, update_dirent proc  * will probably create the directory unless -d isn't specified and this is a  * new directory.  A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  */
end_comment

begin_function
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* if we aren't building dirs, blow it off */
if|if
condition|(
operator|!
name|update_build_dirs
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* ignore the missing dir if -n is specified */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"New directory `%s' -- ignored"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
else|else
block|{
comment|/* otherwise, create the dir and appropriate adm files */
name|make_directory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
comment|/* This is a guess.  We will rewrite it later 			     via WriteTag.  */
literal|0
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
name|Subdir_Register
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do we need to check noexec here? */
elseif|else
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|char
modifier|*
name|cvsadmdir
decl_stmt|;
comment|/* The directory exists.  Check to see if it has a CVS 	   subdirectory.  */
name|cvsadmdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cvsadmdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|cvsadmdir
argument_list|)
condition|)
block|{
comment|/* We cannot successfully recurse into a directory without a CVS 	       subdirectory.  Generally we will have already printed 	       "? foo".  */
name|free
argument_list|(
name|cvsadmdir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
name|free
argument_list|(
name|cvsadmdir
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are building dirs and not going to stdout, we make sure there is      * no static entries file and write the tag file as appropriate      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_clear_entstat
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
block|{
name|WriteTag
argument_list|(
name|dir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|0
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Updating %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirleave_proc () is called back by the recursion code upon leaving  * a directory.  It will prune empty directories if needed and will execute  * any appropriate update programs.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_dirleave_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* run the update_prog if there is one */
comment|/* FIXME: should be checking for errors from CVS_FOPEN and printing        them if not existence_error.  */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|pipeout
operator|&&
operator|!
name|noexec
operator|&&
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Executing '"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file on %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: chdir ("..") loses with symlinks.  */
comment|/* Prune empty dirs on the way out - if necessary */
operator|(
name|void
operator|)
name|CVS_CHDIR
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
operator|&&
name|isemptydir
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* I'm not sure the existence_error is actually possible (except 	       in cases where we really should print a message), but since 	       this code used to ignore all errors, I'll play it safe.	*/
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Subdir_Deregister
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|isremoved
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns 1 if the file indicated by node has been removed.  */
end_comment

begin_function
specifier|static
name|int
name|isremoved
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entdata
init|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
decl_stmt|;
comment|/* If the first character of the version is a '-', the file has been        removed. */
return|return
operator|(
name|entdata
operator|->
name|version
operator|&&
name|entdata
operator|->
name|version
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the argument directory is completely empty, other than the    existence of the CVS directory entry.  Zero otherwise.  If MIGHT_NOT_EXIST    and the directory doesn't exist, then just return 0.  */
end_comment

begin_function
name|int
name|isemptydir
parameter_list|(
name|dir
parameter_list|,
name|might_not_exist
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|might_not_exist
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|might_not_exist
operator|&&
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s for empty check"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* An entry other than the CVS directory.  The directory 		   is certainly not empty. */
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* The CVS directory entry.  We don't have to worry about 		   this unless the Entries file indicates that files have 		   been removed, but not committed, in this directory. 		   (Removing the directory would prevent people from 		   comitting the fact that they removed the files!) */
name|List
modifier|*
name|l
decl_stmt|;
name|int
name|files_removed
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change directory to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|l
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|files_removed
operator|=
name|walklist
argument_list|(
name|l
argument_list|,
name|isremoved
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Entries_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|files_removed
operator|!=
literal|0
condition|)
block|{
comment|/* There are files that have been removed, but not 		       committed!  Do not consider the directory empty. */
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * scratch the Entries file entry associated with a file  */
end_comment

begin_function
specifier|static
name|int
name|scratch_file
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|history_write
argument_list|(
literal|'W'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|""
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"unable to remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check out a file.  */
end_comment

begin_function
specifier|static
name|int
name|checkout_file
parameter_list|(
name|finfo
parameter_list|,
name|vers_ts
parameter_list|,
name|adding
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|int
name|adding
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|int
name|set_time
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|file_is_dead
decl_stmt|;
comment|/* don't screw with backup files if we're going to stdout */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
comment|/* If -f/-t wrappers are being used to wrap up a directory, 	       then backup might be a directory instead of just a file.  */
operator|(
name|void
operator|)
name|unlink_file_dir
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
name|file_is_dead
operator|=
name|RCS_isdead
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_is_dead
condition|)
block|{
comment|/* 	 * if we are checking out to stdout, print a nice message to 	 * stderr, and add the -p flag to the command */
if|if
condition|(
name|pipeout
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|cvs_outerr
argument_list|(
literal|"\ ===================================================================\n\ Checking out "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n\ RCS:  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n\ VERS: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n***************\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
name|pipeout
condition|?
name|NULL
else|:
name|finfo
operator|->
name|file
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|vn_tag
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_is_dead
operator|||
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
if|if
condition|(
name|cvswrite
operator|==
name|TRUE
operator|&&
operator|!
name|file_is_dead
operator|&&
operator|!
name|fileattr_get
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|)
condition|)
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
comment|/* A newly checked out file is never under the spell 		   of "cvs edit".  If we think we were editing it 		   from a previous life, clean up.  Would be better to 		   check for same the working directory instead of 		   same user, but that is hairy.  */
name|struct
name|addremove_args
name|args
decl_stmt|;
name|editor_set
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|remove_temp
operator|=
literal|1
expr_stmt|;
name|watch_modify_watchers
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* set the time from the RCS file iff it was unknown before */
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|vers_ts
operator|->
name|ts_rcs
argument_list|,
literal|"Initial"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_time
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|set_time
operator|=
literal|0
expr_stmt|;
name|wrap_fromcvs_process_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|set_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_is_dead
condition|)
block|{
if|if
condition|(
name|xvers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: %s is not (any longer) pertinent"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|xvers_ts
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FIXME: Rather than always unlink'ing, and ignoring the 		   existence_error, we should do the unlink only if 		   vers_ts->ts_user is non-NULL.  Then there would be no 		   need to ignore an existence_error (for example, if the 		   user removes the file while we are running).  */
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|adding
condition|?
literal|"0"
else|:
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear conflict flag on fresh checkout */
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'U'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
operator|&&
operator|!
name|file_is_dead
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'U'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* save errno value over the rename */
if|if
condition|(
operator|!
name|pipeout
operator|&&
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not check out %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|retval
operator|=
name|retcode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
comment|/* If -f/-t wrappers are being used to wrap up a directory, 	   then backup might be a directory instead of just a file.  */
operator|(
name|void
operator|)
name|unlink_file_dir
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* This structure is used to pass information between patch_file and    patch_file_write.  */
end_comment

begin_struct
struct|struct
name|patch_file_data
block|{
comment|/* File name, for error messages.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* File to which to write.  */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Whether to compute the MD5 checksum.  */
name|int
name|compute_checksum
decl_stmt|;
comment|/* Data structure for computing the MD5 checksum.  */
name|struct
name|MD5Context
name|context
decl_stmt|;
comment|/* Set if the file has a final newline.  */
name|int
name|final_nl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Patch a file.  Runs diff.  This is only done when running as the  * server.  The hope is that the diff will be smaller than the file  * itself.  */
end_comment

begin_function
specifier|static
name|int
name|patch_file
parameter_list|(
name|finfo
parameter_list|,
name|vers_ts
parameter_list|,
name|docheckout
parameter_list|,
name|file_info
parameter_list|,
name|checksum
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|int
modifier|*
name|docheckout
decl_stmt|;
name|struct
name|stat
modifier|*
name|file_info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|checksum
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|patch_file_data
name|data
decl_stmt|;
operator|*
name|docheckout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noexec
operator|||
name|pipeout
operator|||
name|joining
argument_list|()
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If this file has been marked as being binary, then never send a        patch.  */
if|if
condition|(
name|strcmp
argument_list|(
name|vers_ts
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|file1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file1
argument_list|,
literal|"%s/%s%s-1"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|file2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file2
argument_list|,
literal|"%s/%s%s-2"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
comment|/* We need to check out both revisions first, to see if either one        has a trailing newline.  Because of this, we don't use rcsdiff,        but just use diff.  */
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|file1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|file1
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|e
expr_stmt|;
name|data
operator|.
name|final_nl
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|compute_checksum
operator|=
literal|0
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|vn_user
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|patch_file_write
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|||
operator|!
name|data
operator|.
name|final_nl
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|file2
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|file2
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|e
expr_stmt|;
name|data
operator|.
name|final_nl
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|compute_checksum
operator|=
literal|1
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|data
operator|.
name|context
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|patch_file_write
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|||
operator|!
name|data
operator|.
name|final_nl
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
else|else
name|MD5Final
argument_list|(
name|checksum
argument_list|,
operator|&
name|data
operator|.
name|context
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
specifier|const
name|char
modifier|*
name|diff_options
decl_stmt|;
comment|/* FIXME: It might be better to come up with a diff library            which can be shared with the diffutils.  */
comment|/* If the client does not support the Rcs-diff command, we            send a context diff, and the client must invoke patch.            That approach was problematical for various reasons.  The            new approach only requires running diff in the server; the            client can handle everything without invoking an external            program.  */
if|if
condition|(
operator|!
name|rcs_diff_patches
condition|)
block|{
comment|/* We use -c, not -u, because we have no way of knowing 	       which DIFF is in use.  */
name|diff_options
operator|=
literal|"-c"
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: We should use -a if diff supports it.  We should                probably just copy over most or all of the diff                handling in the RCS configure script.  */
comment|/* IMHO, we shouldn't copy over anything which even 	       vaguely resembles the RCS configure script.  That kind of 	       thing tends to be ugly, slow, and fragile.  It also is a 	       a support headache for CVS to behave differently in subtle 	       ways based on whether it was installed correctly.  Instead we 	       should come up with a diff library.  -kingdon, Apr 1997.  */
name|diff_options
operator|=
literal|"-n"
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s %s %s %s"
argument_list|,
name|DIFF
argument_list|,
name|diff_options
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* A retcode of 0 means no differences.  1 means some differences.  */
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|retcode
operator|!=
literal|1
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|BINARY
value|"Binary"
name|char
name|buf
index|[
sizeof|sizeof
name|BINARY
index|]
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
comment|/* Stat the original RCS file, and then adjust it the way 	       that RCS_checkout would.  FIXME: This is an abstraction 	       violation.  */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|file_info
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not stat %s"
argument_list|,
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|file_info
operator|->
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvswrite
operator|==
name|TRUE
operator|&&
operator|!
name|fileattr_get
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|)
condition|)
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check the diff output to make sure patch will be handle it.  */
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open diff output file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|c
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|BINARY
operator|-
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|buf
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|BINARY
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* These are binary files.  We could use diff -a, but 		   patch can't handle that.  */
name|fail
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
comment|/* This stuff is just copied blindly from checkout_file.  I 	   don't really know what it does.  */
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|file_info
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not stat %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'P'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'P'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* save errno value over the rename */
if|if
condition|(
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|&&
name|retcode
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not diff %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|retcode
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write data to a file.  Record whether the last byte written was a    newline.  Optionally compute a checksum.  This is called by    patch_file via RCS_checkout.  */
end_comment

begin_function
specifier|static
name|void
name|patch_file_write
parameter_list|(
name|callerdat
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|patch_file_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|patch_file_data
operator|*
operator|)
name|callerdat
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|data
operator|->
name|fp
argument_list|)
operator|!=
name|len
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|data
operator|->
name|filename
argument_list|)
expr_stmt|;
name|data
operator|->
name|final_nl
operator|=
operator|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|compute_checksum
condition|)
name|MD5Update
argument_list|(
operator|&
name|data
operator|->
name|context
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/*  * Several of the types we process only print a bit of information consisting  * of a single letter and the name.  */
end_comment

begin_function
specifier|static
name|int
name|write_letter
parameter_list|(
name|file
parameter_list|,
name|letter
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|letter
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|letter
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
condition|)
block|{
name|cvs_output
argument_list|(
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be merged  */
end_comment

begin_function
specifier|static
name|int
name|merge_file
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* For binary files, a merge is always a conflict.  We give the 	   user the two files, and let them resolve it.  It is possible 	   that we should require a "touch foo" or similar step before 	   we allow a checkin.  */
name|status
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* Send the new contents of the file before the message.  If we 	   wanted to be totally correct, we would have the client write 	   the message only after the file has safely been written.  */
if|if
condition|(
name|server_active
condition|)
block|{
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_MERGED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"binary file needs merge"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"revision %s from repository is now in %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file from working directory is now in %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|RCS_merge
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|vers
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|cp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* Send the new contents of the file before the message.  If we        wanted to be totally correct, we would have the client write        the message only after the file has safely been written.  */
if|if
condition|(
name|server_active
condition|)
block|{
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_MERGED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|noexec
operator|&&
operator|!
name|xcmp
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s already contains the differences between %s and %s\n"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"conflicts found in %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining update of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_letter
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|'M'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be joined  * (-j option)  */
end_comment

begin_function
specifier|static
name|void
name|join_file
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
name|char
modifier|*
name|jrev1
decl_stmt|;
name|char
modifier|*
name|jrev2
decl_stmt|;
name|char
modifier|*
name|jdate1
decl_stmt|;
name|char
modifier|*
name|jdate2
decl_stmt|;
name|jrev1
operator|=
name|join_rev1
expr_stmt|;
name|jrev2
operator|=
name|join_rev2
expr_stmt|;
name|jdate1
operator|=
name|date_rev1
expr_stmt|;
name|jdate2
operator|=
name|date_rev2
expr_stmt|;
if|if
condition|(
name|wrap_merge_is_copy
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Cannot merge %s because it is a merge-by-copy file."
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine if we need to do anything at all.  */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* If only one join revision is specified, it becomes the second        revision.  */
if|if
condition|(
name|jrev2
operator|==
name|NULL
condition|)
block|{
name|jrev2
operator|=
name|jrev1
expr_stmt|;
name|jrev1
operator|=
name|NULL
expr_stmt|;
name|jdate2
operator|=
name|jdate1
expr_stmt|;
name|jdate1
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Convert the second revision, walking branches and dates.  */
name|rev2
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a merge of two revisions, get the first revision.        If only one join tag was specified, then the first revision is        the greatest common ancestor of the second revision and the        working file.  */
if|if
condition|(
name|jrev1
operator|!=
name|NULL
condition|)
name|rev1
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev1
argument_list|,
name|jdate1
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Note that we use vn_rcs here, since vn_user may contain a            special string such as "-nn".  */
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
name|rev1
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
block|{
comment|/* This means that the file never existed on the branch.                It does not mean that the file was removed on the                branch: that case is represented by a dead rev2.  If                the file never existed on the branch, then we have                nothing to merge, so we just return.  */
return|return;
block|}
else|else
name|rev1
operator|=
name|gca
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a nonexistent or dead merge target.  */
if|if
condition|(
name|rev2
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev2
argument_list|)
condition|)
block|{
name|char
modifier|*
name|mrev
decl_stmt|;
if|if
condition|(
name|rev2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
comment|/* If the first revision doesn't exist either, then there is            no change between the two revisions, so we don't do            anything.  */
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev1
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are merging two revisions, then the file was removed 	   between the first revision and the second one.  In this 	   case we want to mark the file for removal.  	   If we are merging one revision, then the file has been 	   removed between the greatest common ancestor and the merge 	   revision.  From the perspective of the branch on to which 	   we ar emerging, which may be the trunk, either 1) the file 	   does not currently exist on the target, or 2) the file has 	   not been modified on the target branch since the greatest 	   common ancestor, or 3) the file has been modified on the 	   target branch since the greatest common ancestor.  In case 	   1 there is nothing to do.  In case 2 we mark the file for 	   removal.  In case 3 we have a conflict.  	   Note that the handling is slightly different depending upon 	   whether one or two join targets were specified.  If two 	   join targets were specified, we don't check whether the 	   file was modified since a given point.  My reasoning is 	   that if you ask for an explicit merge between two tags, 	   then you want to merge in whatever was changed between 	   those two tags.  If a file was removed between the two 	   tags, then you want it to be removed.  However, if you ask 	   for a merge of a branch, then you want to merge in all 	   changes which were made on the branch.  If a file was 	   removed on the branch, that is a change to the file.  If 	   the file was also changed on the main line, then that is 	   also a change.  These two changes--the file removal and the 	   modification--must be merged.  This is a conflict.  */
comment|/* If the user file is dead, or does not exist, or has been            marked for removal, then there is nothing to do.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the user file has been marked for addition, or has been 	   locally modified, then we have a conflict which we can not 	   resolve.  No_Difference will already have been called in 	   this case, so comparing the timestamps is sufficient to 	   determine whether the file is locally modified.  */
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is locally modified, but has been removed in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is locally modified, but has been removed in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit                status?  */
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If only one join tag was specified, and the user file has            been changed since the greatest common ancestor (rev1),            then there is a conflict we can not resolve.  See above for            the rationale.  */
if|if
condition|(
name|join_rev2
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s has been modified, but has been removed in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s has been modified, but has been removed in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit                status?  */
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
comment|/* The user file exists and has not been modified.  Mark it            for removal.  FIXME: If we are doing a checkout, this has            the effect of first checking out the file, and then            removing it.  It would be better to just register the            removal.  */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_scratch
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mrev
argument_list|,
literal|"-%s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|mrev
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|vers
operator|->
name|ts_conflict
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mrev
argument_list|)
expr_stmt|;
comment|/* We need to check existence_error here because if we are            running as the server, and the file is up to date in the            working directory, the client will not have sent us a copy.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_checked_in
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"scheduling %s for removal"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the target of the merge is the same as the working file        revision, then there is nothing to do.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev2
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If rev1 is dead or does not exist, then the file was added        between rev1 and rev2.  */
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev1
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
comment|/* If the file does not exist in the working directory, then            we can just check out the new revision and mark it for            addition.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers
decl_stmt|;
name|xvers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: If checkout_file fails, we should arrange to                return a non-zero exit status.  */
name|status
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|xvers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|status
operator|==
literal|0
condition|)
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|xvers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freevers_ts
argument_list|(
operator|&
name|xvers
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The file currently exists in the working directory, so we            have a conflict which we can not resolve.  Note that this            is true even if the file is marked for addition or removal.  */
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s exists, but has been added in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s exists, but has been added in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the two merge revisions are the same, then there is nothing        to do.  */
if|if
condition|(
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is no working file, then we can't do the merge.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is present in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is present in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit status?  */
return|return;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
operator|!
name|isreadable
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|int
name|retcode
decl_stmt|;
comment|/* The file is up to date.  Need to check out the current contents.  */
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to check out %s file"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|options
operator|=
name|vers
operator|->
name|options
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
if|#
directive|if
literal|0
block|if (*options == '\0') 	options = "-kk";
comment|/* to ignore keyword expansions */
endif|#
directive|endif
endif|#
directive|endif
name|status
operator|=
name|RCS_merge
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|options
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|rev2
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/*      * If we're in server mode, then we need to re-register the file      * even if there were no conflicts (status == 0).      * This tells server_updated() to send the modified file back to      * the client.      */
if|if
condition|(
name|status
operator|==
literal|1
operator|||
operator|(
name|status
operator|==
literal|0
operator|&&
name|server_active
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|status
operator|==
literal|1
condition|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
name|cp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_MERGED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|joining
parameter_list|()
block|{
return|return
operator|(
name|join_rev1
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

end_unit

