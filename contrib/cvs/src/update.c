begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *  * "update" updates the version in the present directory with respect to the RCS  * repository.  The present version must have been created by "checkout". The  * user can keep up-to-date by calling "update" whenever he feels like it.  *  * The present version can be committed by "commit", but this keeps the version  * in tact.  *  * Arguments following the options are taken to be file names to be updated,  * rather than updating the entire directory.  *  * Modified or non-existent RCS files are checked out and reported as U  *<user_file>  *  * Modified user files are reported as M<user_file>.  If both the RCS file and  * the user file have been modified, the user file is replaced by the result  * of rcsmerge, and a backup file is written for the user in .#file.version.  * If this throws up irreconcilable differences, the file is reported as C  *<user_file>, and as M<user_file> otherwise.  *  * Files added but not yet committed are reported as A<user_file>. Files  * removed but not yet committed are reported as R<user_file>.  *  * If the current directory contains subdirectories that hold concurrent  * versions, these are updated too.  If the -d option was specified, new  * directories added to the repository are automatically created and updated  * as well.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"hardlink.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|checkout_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|int
name|adding
operator|,
name|int
name|merging
operator|,
name|int
name|update_server
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|checkout_to_buffer
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|patch_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|,
name|int
operator|*
name|docheckout
operator|,
expr|struct
name|stat
operator|*
name|file_info
operator|,
name|unsigned
name|char
operator|*
name|checksum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patch_file_write
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|merge_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scratch_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|update_dirent_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_dirleave_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_filesdone_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|get_linkinfo_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|write_letter
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|int
name|letter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|join_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|Vers_TS
operator|*
name|vers_ts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a bit of a kludge.  We call WriteTag at the beginning    before we know whether nonbranch is set or not.  And then at the    end, once we have the right value for nonbranch, we call WriteTag    again.  I don't know whether the first call is necessary or not.    rewrite_tag is nonzero if we are going to have to make that second    call.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rewrite_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonbranch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we set the tag or date for a subdirectory, we use this to undo    the setting.  See update_dirent_proc.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag_update_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
decl_stmt|,
modifier|*
name|date_rev1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
decl_stmt|,
modifier|*
name|date_rev2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|toss_local_changes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_build_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_prune_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|patches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcs_diff_patches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ignlist
init|=
operator|(
name|List
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|update_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]\n"
block|,
literal|"    [-I ign] [-W spec] [files...]\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-C\tOverwrite locally modified files with clean repository copies.\n"
block|,
literal|"\t-d\tBuild directories, like checkout does.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-p\tSend updates to standard output (avoids stickiness).\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-r rev\tUpdate using specified revision/tag (is sticky).\n"
block|,
literal|"\t-D date\tSet date to update from (is sticky).\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
literal|"\t-W spec\tWrappers specification line.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * update is the argv,argc based front end for arg parsing  */
end_comment

begin_function
name|int
name|update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|err
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
comment|/* recursive by default */
name|int
name|which
decl_stmt|;
comment|/* where to look for files and dirs */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
comment|/* parse the args */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+ApCPflRQqduk:r:D:j:I:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|toss_local_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|wrap_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|update_build_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|update_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|patches
operator|=
literal|1
expr_stmt|;
name|rcs_diff_patches
operator|=
name|server_use_rcs_diff
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|update_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|int
name|pass
decl_stmt|;
comment|/* The first pass does the regular update.  If we receive at least 	   one patch which failed, we do a second pass and just fetch 	   those files whose patches failed.  */
name|pass
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|int
name|status
decl_stmt|;
name|start_server
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_build_dirs
condition|)
name|send_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipeout
condition|)
name|send_arg
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|send_arg
argument_list|(
literal|"-A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toss_local_changes
condition|)
name|send_arg
argument_list|(
literal|"-C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
condition|)
name|send_arg
argument_list|(
literal|"-P"
argument_list|)
expr_stmt|;
name|client_prune_dirs
operator|=
name|update_prune_dirs
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|send_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev2
argument_list|)
expr_stmt|;
name|wrap_send
argument_list|()
expr_stmt|;
if|if
condition|(
name|failed_patches_count
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/* If the server supports the command "update-patches", that  		   means that it knows how to handle the -u argument to update, 		   which means to send patches instead of complete files.  		   We don't send -u if failed_patches != NULL, so that the 		   server doesn't try to send patches which will just fail 		   again.  At least currently, the client also clobbers the 		   file and tells the server it is lost, which also will get 		   a full file instead of a patch, but it seems clean to omit 		   -u.  */
if|if
condition|(
name|supported_request
argument_list|(
literal|"update-patches"
argument_list|)
condition|)
name|send_arg
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_build_dirs
condition|)
name|flags
operator||=
name|SEND_BUILD_DIRS
expr_stmt|;
if|if
condition|(
name|toss_local_changes
condition|)
block|{
name|flags
operator||=
name|SEND_NO_CONTENTS
expr_stmt|;
name|flags
operator||=
name|BACKUP_MODIFIED_FILES
expr_stmt|;
block|}
comment|/* If noexec, probably could be setting SEND_NO_CONTENTS. 		   Same caveats as for "cvs status" apply.  */
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s client: refetching unpatchable files\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|toplevel_wd
operator|!=
name|NULL
operator|&&
name|CVS_CHDIR
argument_list|(
name|toplevel_wd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|toplevel_wd
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|failed_patches_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|unlink_file
argument_list|(
name|failed_patches
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|failed_patches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|update_build_dirs
condition|?
name|SEND_BUILD_DIRS
else|:
literal|0
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_names
argument_list|(
operator|&
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"update\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
comment|/* If there are any conflicts, the server will return a                non-zero exit status.  If any patches failed, we still                want to run the update again.  We use a pass count to                avoid an endless loop.  */
comment|/* Notes: (1) assuming that status != 0 implies a 	       potential conflict is the best we can cleanly do given 	       the current protocol.  I suppose that trying to 	       re-fetch in cases where there was a more serious error 	       is probably more or less harmless, but it isn't really 	       ideal.  (2) it would be nice to have a testsuite case for the 	       conflict-and-patch-failed case.  */
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
operator|(
name|failed_patches_count
operator|==
literal|0
operator|||
name|pass
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|failed_patches_count
operator|>
literal|0
condition|)
name|free_names
argument_list|(
operator|&
name|failed_patches_count
argument_list|,
name|failed_patches
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
operator|++
name|pass
expr_stmt|;
block|}
do|while
condition|(
name|failed_patches_count
operator|>
literal|0
condition|)
do|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev1
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev2
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*      * If we are updating the entire directory (for real) and building dirs      * as we go, we make sure there is no static entries file and write the      * tag file as appropriate      */
if|if
condition|(
name|argc
operator|<=
literal|0
operator|&&
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|char
modifier|*
name|repos
init|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|server_clear_entstat
argument_list|(
literal|"."
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
block|{
name|char
modifier|*
name|repos
init|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|0
argument_list|,
literal|"."
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* look for files/dirs locally and in the repository */
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
comment|/* look in the attic too if a tag or date is specified */
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
operator|||
name|joining
argument_list|()
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* call the command line interface */
name|err
operator|=
name|do_update
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local
argument_list|,
name|update_build_dirs
argument_list|,
name|aflag
argument_list|,
name|update_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* free the space Make_Date allocated if necessary */
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Command line interface to update (used by checkout)  */
end_comment

begin_function
name|int
name|do_update
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xoptions
parameter_list|,
name|xtag
parameter_list|,
name|xdate
parameter_list|,
name|xforce
parameter_list|,
name|local
parameter_list|,
name|xbuild
parameter_list|,
name|xaflag
parameter_list|,
name|xprune
parameter_list|,
name|xpipeout
parameter_list|,
name|which
parameter_list|,
name|xjoin_rev1
parameter_list|,
name|xjoin_rev2
parameter_list|,
name|preload_update_dir
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|xoptions
decl_stmt|;
name|char
modifier|*
name|xtag
decl_stmt|;
name|char
modifier|*
name|xdate
decl_stmt|;
name|int
name|xforce
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|xbuild
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xprune
decl_stmt|;
name|int
name|xpipeout
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|xjoin_rev1
decl_stmt|;
name|char
modifier|*
name|xjoin_rev2
decl_stmt|;
name|char
modifier|*
name|preload_update_dir
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* fill in the statics */
name|options
operator|=
name|xoptions
expr_stmt|;
name|tag
operator|=
name|xtag
expr_stmt|;
name|date
operator|=
name|xdate
expr_stmt|;
name|force_tag_match
operator|=
name|xforce
expr_stmt|;
name|update_build_dirs
operator|=
name|xbuild
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|update_prune_dirs
operator|=
name|xprune
expr_stmt|;
name|pipeout
operator|=
name|xpipeout
expr_stmt|;
comment|/* setup the join support */
name|join_rev1
operator|=
name|xjoin_rev1
expr_stmt|;
name|join_rev2
operator|=
name|xjoin_rev2
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev1
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev1
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|join_rev2
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|date_rev2
operator|=
name|Make_Date
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|date_rev2
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|preserve_perms
condition|)
block|{
comment|/* We need to do an extra recursion, bleah.  It's to make sure 	   that we know as much as possible about file linkage. */
name|hardlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|working_dir
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
comment|/* save top-level working dir */
comment|/* FIXME-twp: the arguments to start_recursion make me dizzy.  This 	   function call was copied from the update_fileproc call that 	   follows it; someone should make sure that I did it right. */
name|err
operator|=
name|start_recursion
argument_list|(
name|get_linkinfo_proc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|preload_update_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* FIXME-twp: at this point we should walk the hardlist 	   and update the `links' field of each hardlink_info struct 	   to list the files that are linked on dist.  That would make 	   it easier& more efficient to compare the disk linkage with 	   the repository linkage (a simple strcmp). */
block|}
endif|#
directive|endif
comment|/* call the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|update_fileproc
argument_list|,
name|update_filesdone_proc
argument_list|,
name|update_dirent_proc
argument_list|,
name|update_dirleave_proc
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|preload_update_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* see if we need to sleep before returning to avoid time-stamp races */
if|if
condition|(
name|last_register_time
condition|)
block|{
while|while
condition|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|last_register_time
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
end_ifdef

begin_comment
comment|/*  * The get_linkinfo_proc callback adds each file to the hardlist  * (see hardlink.c).  */
end_comment

begin_function
specifier|static
name|int
name|get_linkinfo_proc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
name|Node
modifier|*
name|linkp
decl_stmt|;
name|struct
name|hardlink_info
modifier|*
name|hlinfo
decl_stmt|;
comment|/* Get the full pathname of the current file. */
name|fullpath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|working_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|working_dir
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* To permit recursing into subdirectories, files        are keyed on the full pathname and not on the basename. */
name|linkp
operator|=
name|lookup_file_by_inode
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkp
operator|==
name|NULL
condition|)
block|{
comment|/* The file isn't on disk; we are probably restoring 	   a file that was removed. */
return|return
literal|0
return|;
block|}
comment|/* Create a new, empty hardlink_info node. */
name|hlinfo
operator|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardlink_info
argument_list|)
argument_list|)
expr_stmt|;
name|hlinfo
operator|->
name|status
operator|=
operator|(
name|Ctype
operator|)
literal|0
expr_stmt|;
comment|/* is this dumb? */
name|hlinfo
operator|->
name|checked_out
operator|=
literal|0
expr_stmt|;
name|linkp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|hlinfo
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is the callback proc for update.  It is called for each file in each  * directory by the recursion code.  The current directory is the local  * instantiation.  file is the file name we are to operate on. update_dir is  * set to the path relative to where we started (for pretty printing).  * repository is the repository. entries and srcfiles are the pre-parsed  * entries and source control files.  *   * This routine decides what needs to be done for each file and does the  * appropriate magic for checkout  */
end_comment

begin_function
specifier|static
name|int
name|update_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|Ctype
name|status
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|resurrecting
decl_stmt|;
name|resurrecting
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|options
argument_list|,
name|force_tag_match
argument_list|,
name|aflag
argument_list|,
operator|&
name|vers
argument_list|,
name|pipeout
argument_list|)
expr_stmt|;
comment|/* Keep track of whether TAG is a branch tag.        Note that if it is a branch tag in some files and a nonbranch tag        in others, treat it as a nonbranch tag.  It is possible that case        should elicit a warning or an error.  */
if|if
condition|(
name|rewrite_tag
operator|&&
name|tag
operator|!=
name|NULL
operator|&&
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rev
init|=
name|RCS_getversion
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
operator|!
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|)
condition|)
name|nonbranch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipeout
condition|)
block|{
comment|/* 	 * We just return success without doing anything if any of the really 	 * funky cases occur 	 *  	 * If there is still a valid RCS file, do a regular checkout type 	 * operation 	 */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
comment|/* needs patch */
endif|#
directive|endif
name|retval
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_UNKNOWN
case|:
comment|/* unknown file was explicitly asked 					 * about */
case|case
name|T_UPTODATE
case|:
comment|/* file was already up-to-date */
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_CONFLICT
case|:
comment|/* old punt-type errors */
name|retval
operator|=
literal|1
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NEEDS_MERGE
case|:
comment|/* needs merging */
name|retval
operator|=
name|merge_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MODIFIED
case|:
comment|/* locally modified */
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toss_local_changes
condition|)
block|{
name|char
modifier|*
name|bakname
decl_stmt|;
name|bakname
operator|=
name|backup_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
comment|/* This behavior is sufficiently unexpected to                        justify overinformativeness, I think. */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
operator|(
operator|!
name|really_quiet
operator|)
operator|&&
operator|(
operator|!
name|server_active
operator|)
condition|)
else|#
directive|else
comment|/* ! SERVER_SUPPORT */
if|if
condition|(
operator|!
name|really_quiet
condition|)
endif|#
directive|endif
comment|/* SERVER_SUPPORT */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(Locally modified %s moved to %s)\n"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|bakname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bakname
argument_list|)
expr_stmt|;
comment|/* The locally modified file is still present, but                        it will be overwritten by the repository copy                        after this. */
name|status
operator|=
name|T_CHECKOUT
expr_stmt|;
name|retval
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/*                          * If the timestamp has changed and no                          * conflict indicators are found, it isn't a                          * 'C' any more.                          */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|retcode
operator|=
name|vers
operator|->
name|ts_conflict
index|[
literal|0
index|]
operator|!=
literal|'='
expr_stmt|;
else|else
block|{
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
condition|)
block|{
comment|/* The timestamps differ.  But if there                                are conflict markers print 'C' anyway.  */
name|retcode
operator|=
operator|!
name|file_has_markers
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retcode
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Reregister to clear conflict flag. */
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
comment|/* needs patch */
if|if
condition|(
name|patches
condition|)
block|{
name|int
name|docheckout
decl_stmt|;
name|struct
name|stat
name|file_info
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
name|retval
operator|=
name|patch_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
operator|&
name|docheckout
argument_list|,
operator|&
name|file_info
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|docheckout
condition|)
block|{
if|if
condition|(
name|server_active
operator|&&
name|retval
operator|==
literal|0
condition|)
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
operator|(
name|rcs_diff_patches
condition|?
name|SERVER_RCS_DIFF
else|:
name|SERVER_PATCHED
operator|)
argument_list|,
name|file_info
operator|.
name|st_mode
argument_list|,
name|checksum
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we're not running as a server, just check the 		   file out.  It's simpler and faster than producing 		   and applying patches.  */
comment|/* Fall through.  */
endif|#
directive|endif
case|case
name|T_CHECKOUT
case|:
comment|/* needs checkout */
name|retval
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ADDED
case|:
comment|/* added but not committed */
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_REMOVED
case|:
comment|/* removed but not committed */
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_REMOVE_ENTRY
case|:
comment|/* needs to be un-registered */
name|retval
operator|=
name|scratch_file
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|retval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
comment|/* can't ever happen :-) */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown file status %d for file %s"
argument_list|,
name|status
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* only try to join if things have gone well thus far */
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|join_rev1
condition|)
name|join_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|)
expr_stmt|;
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|ignlist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|update_ignproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|update_ignproc
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|file_info
name|finfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|finfo
argument_list|)
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|finfo
operator|.
name|update_dir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|finfo
operator|.
name|fullname
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|finfo
operator|.
name|fullname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|finfo
operator|.
name|fullname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|finfo
operator|.
name|fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|finfo
operator|.
name|fullname
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|write_letter
argument_list|(
operator|&
name|finfo
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_filesdone_proc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|rewrite_tag
condition|)
block|{
name|WriteTag
argument_list|(
name|NULL
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|nonbranch
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|ignlist
condition|)
block|{
name|ignore_files
argument_list|(
name|ignlist
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|,
name|update_ignproc
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up CVS admin dirs if we are export */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* I'm not sure the existence_error is actually possible (except 	   in cases where we really should print a message), but since 	   this code used to ignore all errors, I'll play it safe.  */
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|CVSADM
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s directory"
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
elseif|else
if|if
condition|(
operator|!
name|server_active
operator|&&
operator|!
name|pipeout
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
operator|!
name|pipeout
condition|)
endif|#
directive|endif
comment|/* SERVER_SUPPORT */
block|{
comment|/* If there is no CVS/Root file, add one */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM_ROOT
argument_list|)
condition|)
name|Create_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirent_proc () is called back by the recursion processor before a  * sub-directory is processed for update.  In this case, update_dirent proc  * will probably create the directory unless -d isn't specified and this is a  * new directory.  A return code of 0 indicates the directory should be  * processed by the recursion code.  A return of non-zero indicates the  * recursion code should skip this directory.  */
end_comment

begin_function
specifier|static
name|Dtype
name|update_dirent_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
comment|/* if we aren't building dirs, blow it off */
if|if
condition|(
operator|!
name|update_build_dirs
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
comment|/* Various CVS administrators are in the habit of removing 	   the repository directory for things they don't want any 	   more.  I've even been known to do it myself (on rare 	   occasions).  Not the usual recommended practice, but we 	   want to try to come up with some kind of 	   reasonable/documented/sensible behavior.  Generally 	   the behavior is to just skip over that directory (see 	   dirs test in sanity.sh; the case which reaches here 	   is when update -d is specified, and the working directory 	   is gone but the subdirectory is still mentioned in 	   CVS/Entries).  */
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* In the remote case, the client should refrain from 	       sending us the directory in the first place.  So we 	       want to continue to give an error, so clients make 	       sure to do this.  */
operator|&&
operator|!
name|server_active
endif|#
directive|endif
operator|&&
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
return|return
name|R_SKIP_ALL
return|;
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* ignore the missing dir if -n is specified */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"New directory `%s' -- ignored"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
block|}
else|else
block|{
comment|/* otherwise, create the dir and appropriate adm files */
comment|/* If no tag or date were specified on the command line,                and we're not using -A, we want the subdirectory to use                the tag and date, if any, of the current directory.                That way, update -d will work correctly when working on                a branch.  	       We use TAG_UPDATE_DIR to undo the tag setting in 	       update_dirleave_proc.  If we did not do this, we would 	       not correctly handle a working directory with multiple 	       tags (and maybe we should prohibit such working 	       directories, but they work now and we shouldn't make 	       them stop working without more thought).  */
if|if
condition|(
operator|(
name|tag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|aflag
condition|)
block|{
name|ParseTag
argument_list|(
operator|&
name|tag
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|nonbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
condition|)
name|tag_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
block|}
name|make_directory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
comment|/* This is a guess.  We will rewrite it later 			     via WriteTag.  */
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
name|Subdir_Register
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do we need to check noexec here? */
elseif|else
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|char
modifier|*
name|cvsadmdir
decl_stmt|;
comment|/* The directory exists.  Check to see if it has a CVS 	   subdirectory.  */
name|cvsadmdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cvsadmdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|cvsadmdir
argument_list|)
condition|)
block|{
comment|/* We cannot successfully recurse into a directory without a CVS 	       subdirectory.  Generally we will have already printed 	       "? foo".  */
name|free
argument_list|(
name|cvsadmdir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
name|free
argument_list|(
name|cvsadmdir
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we are building dirs and not going to stdout, we make sure there is      * no static entries file and write the tag file as appropriate      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|update_build_dirs
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_clear_entstat
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* keep the CVS/Tag file current with the specified arguments */
if|if
condition|(
name|aflag
operator|||
name|tag
operator|||
name|date
condition|)
block|{
name|WriteTag
argument_list|(
name|dir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
literal|0
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rewrite_tag
operator|=
literal|1
expr_stmt|;
name|nonbranch
operator|=
literal|0
expr_stmt|;
block|}
comment|/* initialize the ignore list for this directory */
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Updating %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update_dirleave_proc () is called back by the recursion code upon leaving  * a directory.  It will prune empty directories if needed and will execute  * any appropriate update programs.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|update_dirleave_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Delete the ignore list if it hasn't already been done.  */
if|if
condition|(
name|ignlist
condition|)
name|dellist
argument_list|(
operator|&
name|ignlist
argument_list|)
expr_stmt|;
comment|/* If we set the tag or date for a new subdirectory in        update_dirent_proc, and we're now done with that subdirectory,        undo the tag/date setting.  Note that we know that the tag and        date were both originally NULL in this case.  */
if|if
condition|(
name|tag_update_dir
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|update_dir
argument_list|,
name|tag_update_dir
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|date
operator|=
name|NULL
expr_stmt|;
block|}
name|nonbranch
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|tag_update_dir
argument_list|)
expr_stmt|;
name|tag_update_dir
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* run the update_prog if there is one */
comment|/* FIXME: should be checking for errors from CVS_FOPEN and printing        them if not existence_error.  */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|pipeout
operator|&&
operator|!
name|noexec
operator|&&
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|run_setup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Executing '"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_flushout
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unexpected end of file on %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: chdir ("..") loses with symlinks.  */
comment|/* Prune empty dirs on the way out - if necessary */
operator|(
name|void
operator|)
name|CVS_CHDIR
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_prune_dirs
operator|&&
name|isemptydir
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* I'm not sure the existence_error is actually possible (except 	       in cases where we really should print a message), but since 	       this code used to ignore all errors, I'll play it safe.	*/
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Subdir_Deregister
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|isremoved
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns 1 if the file indicated by node has been removed.  */
end_comment

begin_function
specifier|static
name|int
name|isremoved
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Entnode
modifier|*
name|entdata
init|=
operator|(
name|Entnode
operator|*
operator|)
name|node
operator|->
name|data
decl_stmt|;
comment|/* If the first character of the version is a '-', the file has been        removed. */
return|return
operator|(
name|entdata
operator|->
name|version
operator|&&
name|entdata
operator|->
name|version
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the argument directory is completely empty, other than the    existence of the CVS directory entry.  Zero otherwise.  If MIGHT_NOT_EXIST    and the directory doesn't exist, then just return 0.  */
end_comment

begin_function
name|int
name|isemptydir
parameter_list|(
name|dir
parameter_list|,
name|might_not_exist
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|might_not_exist
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|might_not_exist
operator|&&
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s for empty check"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* An entry other than the CVS directory.  The directory 		   is certainly not empty. */
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* The CVS directory entry.  We don't have to worry about 		   this unless the Entries file indicates that files have 		   been removed, but not committed, in this directory. 		   (Removing the directory would prevent people from 		   comitting the fact that they removed the files!) */
name|List
modifier|*
name|l
decl_stmt|;
name|int
name|files_removed
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change directory to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|l
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|files_removed
operator|=
name|walklist
argument_list|(
name|l
argument_list|,
name|isremoved
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Entries_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|files_removed
operator|!=
literal|0
condition|)
block|{
comment|/* There are files that have been removed, but not 		       committed!  Do not consider the directory empty. */
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * scratch the Entries file entry associated with a file  */
end_comment

begin_function
specifier|static
name|int
name|scratch_file
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|history_write
argument_list|(
literal|'W'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|""
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"unable to remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check out a file.  */
end_comment

begin_function
specifier|static
name|int
name|checkout_file
parameter_list|(
name|finfo
parameter_list|,
name|vers_ts
parameter_list|,
name|adding
parameter_list|,
name|merging
parameter_list|,
name|update_server
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|int
name|adding
decl_stmt|;
name|int
name|merging
decl_stmt|;
name|int
name|update_server
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|int
name|set_time
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|file_is_dead
decl_stmt|;
name|struct
name|buffer
modifier|*
name|revbuf
decl_stmt|;
name|backup
operator|=
name|NULL
expr_stmt|;
name|revbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Don't screw with backup files if we're going to stdout, or if        we are the server.  */
if|if
condition|(
operator|!
name|pipeout
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|&&
operator|!
name|server_active
endif|#
directive|endif
condition|)
block|{
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If -f/-t wrappers are being used to wrap up a directory, 	       then backup might be a directory instead of just a file.  */
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|backup
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not sure if the existence_error check is needed here.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
comment|/* FIXME: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error removing %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|backup
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|file_is_dead
operator|=
name|RCS_isdead
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_is_dead
condition|)
block|{
comment|/* 	 * if we are checking out to stdout, print a nice message to 	 * stderr, and add the -p flag to the command */
if|if
condition|(
name|pipeout
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|cvs_outerr
argument_list|(
literal|"\ ===================================================================\n\ Checking out "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n\ RCS:  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n\ VERS: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n***************\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|update_server
operator|&&
name|server_active
operator|&&
operator|!
name|pipeout
operator|&&
operator|!
name|file_gzip_level
operator|&&
operator|!
name|joining
argument_list|()
operator|&&
operator|!
name|wrap_name_has
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|WRAP_FROMCVS
argument_list|)
condition|)
block|{
name|revbuf
operator|=
name|buf_nonio_initialize
argument_list|(
operator|(
name|BUFMEMERRPROC
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|vn_tag
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|checkout_to_buffer
argument_list|,
name|revbuf
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|status
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
name|pipeout
condition|?
name|NULL
else|:
name|finfo
operator|->
name|file
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|vn_tag
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_is_dead
operator|||
name|status
operator|==
literal|0
condition|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
name|mode_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
if|if
condition|(
name|revbuf
operator|!=
name|NULL
operator|&&
operator|!
name|noexec
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* FIXME: We should have RCS_checkout return the mode. 		   That would also fix the kludge with noexec, above, which 		   is here only because noexec doesn't write srcfile->path 		   for us to stat.  */
if|if
condition|(
name|stat
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cvswrite
operator|&&
operator|!
name|file_is_dead
operator|&&
operator|!
name|fileattr_get
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|)
condition|)
block|{
if|if
condition|(
name|revbuf
operator|==
name|NULL
condition|)
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We know that we are the server here, so                        although xchmod checks umask, we don't bother.  */
name|mode
operator||=
operator|(
operator|(
operator|(
name|mode
operator|&
name|S_IRUSR
operator|)
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mode
operator|&
name|S_IRGRP
operator|)
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|mode
operator|&
name|S_IROTH
operator|)
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|{
comment|/* A newly checked out file is never under the spell 		   of "cvs edit".  If we think we were editing it 		   from a previous life, clean up.  Would be better to 		   check for same the working directory instead of 		   same user, but that is hairy.  */
name|struct
name|addremove_args
name|args
decl_stmt|;
name|editor_set
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|remove_temp
operator|=
literal|1
expr_stmt|;
name|watch_modify_watchers
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* set the time from the RCS file iff it was unknown before */
name|set_time
operator|=
operator|(
operator|!
name|noexec
operator|&&
operator|(
name|vers_ts
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|vers_ts
operator|->
name|ts_rcs
argument_list|,
literal|"Initial"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|file_is_dead
operator|)
expr_stmt|;
name|wrap_fromcvs_process_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|set_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|revbuf
operator|!=
name|NULL
condition|)
block|{
comment|/* If we stored the file data into a buffer, then we                    didn't create a file at all, so xvers_ts->ts_user                    is wrong.  The correct value is to have it be the                    same as xvers_ts->ts_rcs, meaning that the working                    file is unchanged from the RCS file.  		   FIXME: We should tell Version_TS not to waste time 		   statting the nonexistent file.  		   FIXME: Actually, I don't think the ts_user value 		   matters at all here.  The only use I know of is 		   that it is printed in a trace message by 		   Server_Register.  */
if|if
condition|(
name|xvers_ts
operator|->
name|ts_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xvers_ts
operator|->
name|ts_user
argument_list|)
expr_stmt|;
name|xvers_ts
operator|->
name|ts_user
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|ts_rcs
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_is_dead
condition|)
block|{
if|if
condition|(
name|xvers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: %s is not (any longer) pertinent"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|xvers_ts
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* FIXME: Rather than always unlink'ing, and ignoring the 		   existence_error, we should do the unlink only if 		   vers_ts->ts_user is non-NULL.  Then there would be no 		   need to ignore an existence_error (for example, if the 		   user removes the file while we are running).  */
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|adding
condition|?
literal|"0"
else|:
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear conflict flag on fresh checkout */
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers_ts
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|vers_ts
operator|->
name|vn_rcs
operator|=
name|xstrdup
argument_list|(
name|xvers_ts
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'U'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
operator|&&
operator|!
name|file_is_dead
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|update_server
operator|&&
name|server_active
condition|)
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers_ts
argument_list|,
name|merging
condition|?
name|SERVER_MERGED
else|:
name|SERVER_UPDATED
argument_list|,
name|mode
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|revbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|backup
operator|!=
name|NULL
condition|)
block|{
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|backup
operator|=
name|NULL
expr_stmt|;
block|}
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not check out %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|retval
operator|=
name|status
expr_stmt|;
block|}
if|if
condition|(
name|backup
operator|!=
name|NULL
condition|)
block|{
comment|/* If -f/-t wrappers are being used to wrap up a directory, 	   then backup might be a directory instead of just a file.  */
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|backup
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not sure if the existence_error check is needed here.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
comment|/* FIXME: should include update_dir in message.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error removing %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* This function is used to write data from a file being checked out    into a buffer.  */
end_comment

begin_function
specifier|static
name|void
name|checkout_to_buffer
parameter_list|(
name|callerdat
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|buf
init|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|callerdat
decl_stmt|;
name|buf_output
argument_list|(
name|buf
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* This structure is used to pass information between patch_file and    patch_file_write.  */
end_comment

begin_struct
struct|struct
name|patch_file_data
block|{
comment|/* File name, for error messages.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* File to which to write.  */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Whether to compute the MD5 checksum.  */
name|int
name|compute_checksum
decl_stmt|;
comment|/* Data structure for computing the MD5 checksum.  */
name|struct
name|cvs_MD5Context
name|context
decl_stmt|;
comment|/* Set if the file has a final newline.  */
name|int
name|final_nl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Patch a file.  Runs diff.  This is only done when running as the  * server.  The hope is that the diff will be smaller than the file  * itself.  */
end_comment

begin_function
specifier|static
name|int
name|patch_file
parameter_list|(
name|finfo
parameter_list|,
name|vers_ts
parameter_list|,
name|docheckout
parameter_list|,
name|file_info
parameter_list|,
name|checksum
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
name|int
modifier|*
name|docheckout
decl_stmt|;
name|struct
name|stat
modifier|*
name|file_info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|checksum
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|FILE
modifier|*
name|e
decl_stmt|;
name|struct
name|patch_file_data
name|data
decl_stmt|;
operator|*
name|docheckout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noexec
operator|||
name|pipeout
operator|||
name|joining
argument_list|()
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If this file has been marked as being binary, then never send a        patch.  */
if|if
condition|(
name|strcmp
argument_list|(
name|vers_ts
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* First check that the first revision exists.  If it has been nuked        by cvs admin -o, then just fall back to checking out entire        revisions.  In some sense maybe we don't have to do this; after        all cvs.texinfo says "Make sure that no-one has checked out a        copy of the revision you outdate" but then again, that advice        doesn't really make complete sense, because "cvs admin" operates        on a working directory and so _someone_ will almost always have        _some_ revision checked out.  */
block|{
name|char
modifier|*
name|rev
decl_stmt|;
name|rev
operator|=
name|RCS_gettag
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers_ts
operator|->
name|vn_user
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
comment|/* If the revision is dead, let checkout_file handle it rather        than duplicating the processing here.  */
if|if
condition|(
name|RCS_isdead
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|)
condition|)
block|{
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rename_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|backup
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
block|}
name|file1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file1
argument_list|,
literal|"%s/%s%s-1"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|file2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file2
argument_list|,
literal|"%s/%s%s-2"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
comment|/* We need to check out both revisions first, to see if either one        has a trailing newline.  Because of this, we don't use rcsdiff,        but just use diff.  */
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|file1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|file1
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|e
expr_stmt|;
name|data
operator|.
name|final_nl
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|compute_checksum
operator|=
literal|0
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|vn_user
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|patch_file_write
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|||
operator|!
name|data
operator|.
name|final_nl
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|file2
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|data
operator|.
name|filename
operator|=
name|file2
expr_stmt|;
name|data
operator|.
name|fp
operator|=
name|e
expr_stmt|;
name|data
operator|.
name|final_nl
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|compute_checksum
operator|=
literal|1
expr_stmt|;
name|cvs_MD5Init
argument_list|(
operator|&
name|data
operator|.
name|context
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers_ts
operator|->
name|srcfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|vers_ts
operator|->
name|vn_tag
argument_list|,
name|vers_ts
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|patch_file_write
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|||
operator|!
name|data
operator|.
name|final_nl
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
else|else
name|cvs_MD5Final
argument_list|(
name|checksum
argument_list|,
operator|&
name|data
operator|.
name|context
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|char
modifier|*
name|diff_options
decl_stmt|;
comment|/* If the client does not support the Rcs-diff command, we            send a context diff, and the client must invoke patch.            That approach was problematical for various reasons.  The            new approach only requires running diff in the server; the            client can handle everything without invoking an external            program.  */
if|if
condition|(
operator|!
name|rcs_diff_patches
condition|)
block|{
comment|/* We use -c, not -u, because that is what CVS has 	       traditionally used.  Kind of a moot point, now that 	       Rcs-diff is preferred, so there is no point in making 	       the compatibility issues worse.  */
name|diff_options
operator|=
literal|"-c"
expr_stmt|;
block|}
else|else
block|{
comment|/* Now that diff is librarified, we could be passing -a if 	       we wanted to.  However, it is unclear to me whether we 	       would want to.  Does diff -a, in any significant 	       percentage of cases, produce patches which are smaller 	       than the files it is patching?  I guess maybe text 	       files with character sets which diff regards as 	       'binary'.  Conversely, do they tend to be much larger 	       in the bad cases?  This needs some more 	       thought/investigation, I suspect.  */
name|diff_options
operator|=
literal|"-n"
expr_stmt|;
block|}
name|retcode
operator|=
name|diff_exec
argument_list|(
name|file1
argument_list|,
name|file2
argument_list|,
name|diff_options
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* A retcode of 0 means no differences.  1 means some differences.  */
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|&&
name|retcode
operator|!=
literal|1
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
define|#
directive|define
name|BINARY
value|"Binary"
name|char
name|buf
index|[
sizeof|sizeof
name|BINARY
index|]
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
comment|/* Stat the original RCS file, and then adjust it the way 	       that RCS_checkout would.  FIXME: This is an abstraction 	       violation.  */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|file_info
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not stat %s"
argument_list|,
name|vers_ts
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|file_info
operator|->
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvswrite
operator|&&
operator|!
name|fileattr_get
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|)
condition|)
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check the diff output to make sure patch will be handle it.  */
name|e
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not open diff output file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|c
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|BINARY
operator|-
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|buf
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|BINARY
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* These are binary files.  We could use diff -a, but 		   patch can't handle that.  */
name|fail
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fail
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers_ts
decl_stmt|;
comment|/* This stuff is just copied blindly from checkout_file.  I 	   don't really know what it does.  */
name|xvers_ts
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|xvers_ts
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|xvers_ts
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|xvers_ts
operator|->
name|ts_user
argument_list|,
name|xvers_ts
operator|->
name|options
argument_list|,
name|xvers_ts
operator|->
name|tag
argument_list|,
name|xvers_ts
operator|->
name|date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|file_info
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not stat %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* If this is really Update and not Checkout, recode history */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"update"
argument_list|)
operator|==
literal|0
condition|)
name|history_write
argument_list|(
literal|'P'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|xvers_ts
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers_ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* save errno value over the rename */
if|if
condition|(
name|isfile
argument_list|(
name|backup
argument_list|)
condition|)
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
operator|&&
name|retcode
operator|!=
literal|1
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|old_errno
else|:
literal|0
argument_list|,
literal|"could not diff %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
operator|*
name|docheckout
operator|=
literal|1
expr_stmt|;
name|retval
operator|=
name|retcode
expr_stmt|;
block|}
if|if
condition|(
name|unlink_file
argument_list|(
name|backup
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|file1
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|file2
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file2
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write data to a file.  Record whether the last byte written was a    newline.  Optionally compute a checksum.  This is called by    patch_file via RCS_checkout.  */
end_comment

begin_function
specifier|static
name|void
name|patch_file_write
parameter_list|(
name|callerdat
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|patch_file_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|patch_file_data
operator|*
operator|)
name|callerdat
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|data
operator|->
name|fp
argument_list|)
operator|!=
name|len
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|data
operator|->
name|filename
argument_list|)
expr_stmt|;
name|data
operator|->
name|final_nl
operator|=
operator|(
name|buffer
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|compute_checksum
condition|)
name|cvs_MD5Update
argument_list|(
operator|&
name|data
operator|->
name|context
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/*  * Several of the types we process only print a bit of information consisting  * of a single letter and the name.  */
end_comment

begin_function
specifier|static
name|void
name|write_letter
parameter_list|(
name|finfo
parameter_list|,
name|letter
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
comment|/* Big enough for "+updated" or any of its ilk.  */
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
switch|switch
condition|(
name|letter
condition|)
block|{
case|case
literal|'U'
case|:
name|tag
operator|=
literal|"updated"
expr_stmt|;
break|break;
default|default:
comment|/* We don't yet support tagged output except for "U".  */
break|break;
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"+%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|letter
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"fname"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-%s"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be merged  */
end_comment

begin_function
specifier|static
name|int
name|merge_file
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|backup
argument_list|)
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"unable to remove %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
operator|||
name|wrap_merge_is_copy
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|||
name|special_file_mismatch
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
condition|)
block|{
comment|/* For binary files, a merge is always a conflict.  Same for 	   files whose permissions or linkage do not match.  We give the 	   user the two files, and let them resolve it.  It is possible 	   that we should require a "touch foo" or similar step before 	   we allow a checkin.  */
comment|/* TODO: it may not always be necessary to regard a permission 	   mismatch as a conflict.  The working file and the RCS file 	   have a common ancestor `A'; if the working file's permissions 	   match A's, then it's probably safe to overwrite them with the 	   RCS permissions.  Only if the working file, the RCS file, and 	   A all disagree should this be considered a conflict.  But more 	   thought needs to go into this, and in the meantime it is safe 	   to treat any such mismatch as an automatic conflict. -twp */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Is there a better term than "nonmergeable file"?  What we 	   really mean is, not something that CVS cannot or does not 	   want to merge (there might be an external manual or 	   automatic merge process).  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nonmergeable file needs merge"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"revision %s from repository is now in %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file from working directory is now in %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|status
operator|=
name|RCS_merge
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|vers
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* This file is the result of a merge, which means that it has        been modified.  We use a special timestamp string which will        not compare equal to any actual timestamp.  */
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|cp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
literal|"Result of merge"
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* fix up the vers structure, in case it is used by join */
if|if
condition|(
name|join_rev1
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|vn_user
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* Send the new contents of the file before the message.  If we        wanted to be totally correct, we would have the client write        the message only after the file has safely been written.  */
if|if
condition|(
name|server_active
condition|)
block|{
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_MERGED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FIXME: the noexec case is broken.  RCS_merge could be doing the        xcmp on the temporary files without much hassle, I think.  */
if|if
condition|(
operator|!
name|noexec
operator|&&
operator|!
name|xcmp
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" already contains the differences between "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" and "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"conflicts found in %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining update of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
literal|'G'
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Do all the magic associated with a file which needs to be joined  * (-j option)  */
end_comment

begin_function
specifier|static
name|void
name|join_file
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
block|{
name|char
modifier|*
name|backup
decl_stmt|;
name|char
modifier|*
name|t_options
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
name|char
modifier|*
name|jrev1
decl_stmt|;
name|char
modifier|*
name|jrev2
decl_stmt|;
name|char
modifier|*
name|jdate1
decl_stmt|;
name|char
modifier|*
name|jdate2
decl_stmt|;
name|jrev1
operator|=
name|join_rev1
expr_stmt|;
name|jrev2
operator|=
name|join_rev2
expr_stmt|;
name|jdate1
operator|=
name|date_rev1
expr_stmt|;
name|jdate2
operator|=
name|date_rev2
expr_stmt|;
comment|/* Determine if we need to do anything at all.  */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* If only one join revision is specified, it becomes the second        revision.  */
if|if
condition|(
name|jrev2
operator|==
name|NULL
condition|)
block|{
name|jrev2
operator|=
name|jrev1
expr_stmt|;
name|jrev1
operator|=
name|NULL
expr_stmt|;
name|jdate2
operator|=
name|jdate1
expr_stmt|;
name|jdate1
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Convert the second revision, walking branches and dates.  */
name|rev2
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a merge of two revisions, get the first revision.        If only one join tag was specified, then the first revision is        the greatest common ancestor of the second revision and the        working file.  */
if|if
condition|(
name|jrev1
operator|!=
name|NULL
condition|)
name|rev1
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|jrev1
argument_list|,
name|jdate1
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Note that we use vn_rcs here, since vn_user may contain a            special string such as "-nn".  */
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
name|rev1
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
block|{
comment|/* This means that the file never existed on the branch.                It does not mean that the file was removed on the                branch: that case is represented by a dead rev2.  If                the file never existed on the branch, then we have                nothing to merge, so we just return.  */
return|return;
block|}
else|else
name|rev1
operator|=
name|gca
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
block|}
comment|/* Handle a nonexistent or dead merge target.  */
if|if
condition|(
name|rev2
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev2
argument_list|)
condition|)
block|{
name|char
modifier|*
name|mrev
decl_stmt|;
if|if
condition|(
name|rev2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
comment|/* If the first revision doesn't exist either, then there is            no change between the two revisions, so we don't do            anything.  */
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev1
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are merging two revisions, then the file was removed 	   between the first revision and the second one.  In this 	   case we want to mark the file for removal.  	   If we are merging one revision, then the file has been 	   removed between the greatest common ancestor and the merge 	   revision.  From the perspective of the branch on to which 	   we ar emerging, which may be the trunk, either 1) the file 	   does not currently exist on the target, or 2) the file has 	   not been modified on the target branch since the greatest 	   common ancestor, or 3) the file has been modified on the 	   target branch since the greatest common ancestor.  In case 	   1 there is nothing to do.  In case 2 we mark the file for 	   removal.  In case 3 we have a conflict.  	   Note that the handling is slightly different depending upon 	   whether one or two join targets were specified.  If two 	   join targets were specified, we don't check whether the 	   file was modified since a given point.  My reasoning is 	   that if you ask for an explicit merge between two tags, 	   then you want to merge in whatever was changed between 	   those two tags.  If a file was removed between the two 	   tags, then you want it to be removed.  However, if you ask 	   for a merge of a branch, then you want to merge in all 	   changes which were made on the branch.  If a file was 	   removed on the branch, that is a change to the file.  If 	   the file was also changed on the main line, then that is 	   also a change.  These two changes--the file removal and the 	   modification--must be merged.  This is a conflict.  */
comment|/* If the user file is dead, or does not exist, or has been            marked for removal, then there is nothing to do.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
operator|||
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the user file has been marked for addition, or has been 	   locally modified, then we have a conflict which we can not 	   resolve.  No_Difference will already have been called in 	   this case, so comparing the timestamps is sufficient to 	   determine whether the file is locally modified.  */
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is locally modified, but has been removed in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s is locally modified, but has been removed in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit                status?  */
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If only one join tag was specified, and the user file has            been changed since the greatest common ancestor (rev1),            then there is a conflict we can not resolve.  See above for            the rationale.  */
if|if
condition|(
name|join_rev2
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s has been modified, but has been removed in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s has been modified, but has been removed in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit                status?  */
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
comment|/* The user file exists and has not been modified.  Mark it            for removal.  FIXME: If we are doing a checkout, this has            the effect of first checking out the file, and then            removing it.  It would be better to just register the            removal.  */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_scratch
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mrev
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mrev
argument_list|,
literal|"-%s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|mrev
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|vers
operator|->
name|ts_conflict
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mrev
argument_list|)
expr_stmt|;
comment|/* We need to check existence_error here because if we are            running as the server, and the file is up to date in the            working directory, the client will not have sent us a copy.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_checked_in
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"scheduling %s for removal"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the target of the merge is the same as the working file        revision, then there is nothing to do.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev2
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If rev1 is dead or does not exist, then the file was added        between rev1 and rev2.  */
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|||
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|rev1
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
comment|/* If the file does not exist in the working directory, then            we can just check out the new revision and mark it for            addition.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
name|Vers_TS
modifier|*
name|xvers
decl_stmt|;
name|xvers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset any keyword expansion option.  Otherwise, when a 	       command like `cvs update -kk -jT1 -jT2' creates a new file 	       (because a file had the T2 tag, but not T1), the subsequent 	       commit of that just-added file effectively would set the 	       admin `-kk' option for that file in the repository.  */
name|options
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: If checkout_file fails, we should arrange to                return a non-zero exit status.  */
name|status
operator|=
name|checkout_file
argument_list|(
name|finfo
argument_list|,
name|xvers
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|xvers
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The file currently exists in the working directory, so we            have a conflict which we can not resolve.  Note that this            is true even if the file is marked for addition or removal.  */
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s exists, but has been added in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s exists, but has been added in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the two merge revisions are the same, then there is nothing        to do.  */
if|if
condition|(
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is no working file, then we can't do the merge.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|jdate2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s does not exist, but is present in revision %s as of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|,
name|jdate2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file %s does not exist, but is present in revision %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|jrev2
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we arrange to return a non-zero exit status?  */
return|return;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
operator|!
name|isreadable
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
block|{
name|int
name|retcode
decl_stmt|;
comment|/* The file is up to date.  Need to check out the current contents.  */
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"failed to check out %s file"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * The users currently modified file is moved to a backup file name      * ".#filename.version", so that it will stay around for a few days      * before being automatically removed by some cron daemon.  The "version"      * is the version of the file that the user was most up-to-date with      * before the merge.      */
name|backup
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BAKPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|backup
argument_list|,
literal|"%s%s.%s"
argument_list|,
name|BAKPREFIX
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|backup
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t_options
operator|=
name|vers
operator|->
name|options
expr_stmt|;
if|#
directive|if
literal|0
block|if (*t_options == '\0') 	t_options = "-kk";
comment|/* to ignore keyword expansions */
endif|#
directive|endif
comment|/* If the source of the merge is the same as the working file        revision, then we can just RCS_checkout the target (no merging        as such).  In the text file case, this is probably quite        similar to the RCS_merge, but in the binary file case,        RCS_merge gives all kinds of trouble.  */
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rev1
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
operator|==
literal|0
comment|/* See comments above about how No_Difference has already been 	   called.  */
operator|&&
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|==
literal|0
comment|/* This is because of the worry below about $Name.  If that 	   isn't a problem, I suspect this code probably works for 	   text files too.  */
operator|&&
operator|(
name|strcmp
argument_list|(
name|t_options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
operator|||
name|wrap_merge_is_copy
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|)
condition|)
block|{
comment|/* FIXME: what about nametag?  What does RCS_merge do with 	   $Name?  */
if|if
condition|(
name|RCS_checkout
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev2
argument_list|,
name|NULL
argument_list|,
name|t_options
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|status
operator|=
literal|2
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
comment|/* OK, this is really stupid.  RCS_checkout carefully removes 	   write permissions, and we carefully put them back.  But 	   until someone gets around to fixing it, that seems like the 	   easiest way to get what would seem to be the right mode. 	   I don't check CVSWRITE or _watched; I haven't thought about 	   that in great detail, but it seems like a watched file should 	   be checked out (writable) after a merge.  */
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Traditionally, the text file case prints a whole bunch of 	   scary looking and verbose output which fails to tell the user 	   what is really going on (it gives them rev1 and rev2 but doesn't 	   indicate in any way that rev1 == vn_user).  I think just a 	   simple "U foo" is good here; it seems analogous to the case in 	   which the file was added on the branch in terms of what to 	   print.  */
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|t_options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
operator|||
name|wrap_merge_is_copy
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|||
name|special_file_mismatch
argument_list|(
name|finfo
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
condition|)
block|{
comment|/* We are dealing with binary files, or files with a 	   permission/linkage mismatch, and real merging would 	   need to take place.  This is a conflict.  We give the user 	   the two files, and let them resolve it.  It is possible 	   that we should require a "touch foo" or similar step before 	   we allow a checkin.  */
if|if
condition|(
name|RCS_checkout
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev2
argument_list|,
name|NULL
argument_list|,
name|t_options
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|status
operator|=
literal|2
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
comment|/* OK, this is really stupid.  RCS_checkout carefully removes 	   write permissions, and we carefully put them back.  But 	   until someone gets around to fixing it, that seems like the 	   easiest way to get what would seem to be the right mode. 	   I don't check CVSWRITE or _watched; I haven't thought about 	   that in great detail, but it seems like a watched file should 	   be checked out (writable) after a merge.  */
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Hmm.  We don't give them REV1 anywhere.  I guess most people 	   probably don't have a 3-way merge tool for the file type in 	   question, and might just get confused if we tried to either 	   provide them with a copy of the file from REV1, or even just 	   told them what REV1 is so they can get it themself, but it 	   might be worth thinking about.  */
comment|/* See comment in merge_file about the "nonmergeable file" 	   terminology.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nonmergeable file needs merge"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"revision %s from repository is now in %s"
argument_list|,
name|rev2
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file from working directory is now in %s"
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
name|finfo
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|RCS_merge
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|t_options
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not merge revision %s of %s"
argument_list|,
name|rev2
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|status
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restoring %s from backup file %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|backup
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
comment|/* The file has changed, but if we just checked it out it may        still have the same timestamp it did when it was first        registered above in checkout_file.  We register it again with a        dummy timestamp to make sure that later runs of CVS will        recognize that it has changed.         We don't actually need to register again if we called        RCS_checkout above, and we aren't running as the server.        However, that is not the normal case, and calling Register        again won't cost much in that case.  */
block|{
name|char
modifier|*
name|cp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|cp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
condition|?
name|vers
operator|->
name|vn_rcs
else|:
literal|"0"
argument_list|,
literal|"Result of merge"
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_copy_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_MERGED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Report whether revisions REV1 and REV2 of FINFO agree on:  *   . file ownership  *   . permissions  *   . major and minor device numbers  *   . symbolic links  *   . hard links  *  * If either REV1 or REV2 is NULL, the working copy is used instead.  *  * Return 1 if the files differ on these data.  */
end_comment

begin_function
name|int
name|special_file_mismatch
parameter_list|(
name|finfo
parameter_list|,
name|rev1
parameter_list|,
name|rev2
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
name|struct
name|stat
name|sb
decl_stmt|;
name|RCSVers
modifier|*
name|vp
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|uid_t
name|rev1_uid
decl_stmt|,
name|rev2_uid
decl_stmt|;
name|gid_t
name|rev1_gid
decl_stmt|,
name|rev2_gid
decl_stmt|;
name|mode_t
name|rev1_mode
decl_stmt|,
name|rev2_mode
decl_stmt|;
name|unsigned
name|long
name|dev_long
decl_stmt|;
name|dev_t
name|rev1_dev
decl_stmt|,
name|rev2_dev
decl_stmt|;
name|char
modifier|*
name|rev1_symlink
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rev2_symlink
init|=
name|NULL
decl_stmt|;
name|List
modifier|*
name|rev1_hardlinks
init|=
name|NULL
decl_stmt|;
name|List
modifier|*
name|rev2_hardlinks
init|=
name|NULL
decl_stmt|;
name|int
name|check_uids
decl_stmt|,
name|check_gids
decl_stmt|,
name|check_modes
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* If we don't care about special file info, then        don't report a mismatch in any case. */
if|if
condition|(
operator|!
name|preserve_perms
condition|)
return|return
literal|0
return|;
comment|/* When special_file_mismatch is called from No_Difference, the        RCS file has been only partially parsed.  We must read the        delta tree in order to compare special file info recorded in        the delta nodes.  (I think this is safe. -twp) */
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_uids
operator|=
name|check_gids
operator|=
name|check_modes
operator|=
literal|1
expr_stmt|;
comment|/* Obtain file information for REV1.  If this is null, then stat        finfo->file and use that info. */
comment|/* If a revision does not know anything about its status,        then presumably it doesn't matter, and indicates no conflict. */
if|if
condition|(
name|rev1
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|islink
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rev1_symlink
operator|=
name|xreadlink
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ST_RDEV
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get file information for %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|rev1_uid
operator|=
name|sb
operator|.
name|st_uid
expr_stmt|;
name|rev1_gid
operator|=
name|sb
operator|.
name|st_gid
expr_stmt|;
name|rev1_mode
operator|=
name|sb
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|S_ISBLK
argument_list|(
name|rev1_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|rev1_mode
argument_list|)
condition|)
name|rev1_dev
operator|=
name|sb
operator|.
name|st_rdev
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot handle device files on this system (%s)"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rev1_hardlinks
operator|=
name|list_linked_files_on_disk
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|findnode
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|versions
argument_list|,
name|rev1
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"symlink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|rev1_symlink
operator|=
name|xstrdup
argument_list|(
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"owner"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_uids
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev1_uid
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_gids
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev1_gid
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"permissions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_modes
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev1_mode
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"special"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|rev1_mode
operator||=
name|S_IFREG
expr_stmt|;
else|else
block|{
comment|/* If the size of `ftype' changes, fix the sscanf call also */
name|char
name|ftype
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|n
operator|->
name|data
argument_list|,
literal|"%16s %lu"
argument_list|,
name|ftype
argument_list|,
operator|&
name|dev_long
argument_list|)
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s:%s has bad `special' newphrase %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev1
argument_list|,
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
name|rev1_dev
operator|=
name|dev_long
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ftype
argument_list|,
literal|"character"
argument_list|)
operator|==
literal|0
condition|)
name|rev1_mode
operator||=
name|S_IFCHR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ftype
argument_list|,
literal|"block"
argument_list|)
operator|==
literal|0
condition|)
name|rev1_mode
operator||=
name|S_IFBLK
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%s unknown file type `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev1
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
name|rev1_hardlinks
operator|=
name|vp
operator|->
name|hardlinks
expr_stmt|;
if|if
condition|(
name|rev1_hardlinks
operator|==
name|NULL
condition|)
name|rev1_hardlinks
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Obtain file information for REV2. */
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|islink
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
condition|)
name|rev2_symlink
operator|=
name|xreadlink
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_ST_RDEV
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get file information for %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|rev2_uid
operator|=
name|sb
operator|.
name|st_uid
expr_stmt|;
name|rev2_gid
operator|=
name|sb
operator|.
name|st_gid
expr_stmt|;
name|rev2_mode
operator|=
name|sb
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|S_ISBLK
argument_list|(
name|rev2_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|rev2_mode
argument_list|)
condition|)
name|rev2_dev
operator|=
name|sb
operator|.
name|st_rdev
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot handle device files on this system (%s)"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rev2_hardlinks
operator|=
name|list_linked_files_on_disk
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|findnode
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|versions
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"symlink"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|rev2_symlink
operator|=
name|xstrdup
argument_list|(
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"owner"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_uids
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev2_uid
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_gids
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev2_gid
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"permissions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|check_modes
operator|=
literal|0
expr_stmt|;
comment|/* don't care */
else|else
name|rev2_mode
operator|=
name|strtoul
argument_list|(
name|n
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|vp
operator|->
name|other_delta
argument_list|,
literal|"special"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|rev2_mode
operator||=
name|S_IFREG
expr_stmt|;
else|else
block|{
comment|/* If the size of `ftype' changes, fix the sscanf call also */
name|char
name|ftype
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|n
operator|->
name|data
argument_list|,
literal|"%16s %lu"
argument_list|,
name|ftype
argument_list|,
operator|&
name|dev_long
argument_list|)
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s:%s has bad `special' newphrase %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev2
argument_list|,
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
name|rev2_dev
operator|=
name|dev_long
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ftype
argument_list|,
literal|"character"
argument_list|)
operator|==
literal|0
condition|)
name|rev2_mode
operator||=
name|S_IFCHR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ftype
argument_list|,
literal|"block"
argument_list|)
operator|==
literal|0
condition|)
name|rev2_mode
operator||=
name|S_IFBLK
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%s unknown file type `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev2
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
name|rev2_hardlinks
operator|=
name|vp
operator|->
name|hardlinks
expr_stmt|;
if|if
condition|(
name|rev2_hardlinks
operator|==
name|NULL
condition|)
name|rev2_hardlinks
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Check the user/group ownerships and file permissions, printing        an error for each mismatch found.  Return 0 if all characteristics        matched, and 1 otherwise. */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Compare symlinks first, since symlinks are simpler (don't have        any other characteristics). */
if|if
condition|(
name|rev1_symlink
operator|!=
name|NULL
operator|&&
name|rev2_symlink
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is a symbolic link"
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rev1_symlink
operator|==
name|NULL
operator|&&
name|rev2_symlink
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is a symbolic link"
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rev1_symlink
operator|!=
name|NULL
condition|)
name|result
operator|=
operator|(
name|strcmp
argument_list|(
name|rev1_symlink
argument_list|,
name|rev2_symlink
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
else|else
block|{
comment|/* Compare user ownership. */
if|if
condition|(
name|check_uids
operator|&&
name|rev1_uid
operator|!=
name|rev2_uid
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: owner mismatch between %s and %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compare group ownership. */
if|if
condition|(
name|check_gids
operator|&&
name|rev1_gid
operator|!=
name|rev2_gid
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: group mismatch between %s and %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compare permissions. */
if|if
condition|(
name|check_modes
operator|&&
operator|(
name|rev1_mode
operator|&
literal|07777
operator|)
operator|!=
operator|(
name|rev2_mode
operator|&
literal|07777
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: permission mismatch between %s and %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compare device file characteristics. */
if|if
condition|(
operator|(
name|rev1_mode
operator|&
name|S_IFMT
operator|)
operator|!=
operator|(
name|rev2_mode
operator|&
name|S_IFMT
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: %s and %s are different file types"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|rev1_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|rev1_dev
operator|!=
name|rev2_dev
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: device numbers of %s and %s do not match"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Compare hard links. */
if|if
condition|(
name|compare_linkage_lists
argument_list|(
name|rev1_hardlinks
argument_list|,
name|rev2_hardlinks
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: hard linkage of %s and %s do not match"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|rev1
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev1
operator|)
argument_list|,
operator|(
name|rev2
operator|==
name|NULL
condition|?
literal|"working file"
else|:
name|rev2
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rev1_symlink
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev1_symlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2_symlink
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev2_symlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1_hardlinks
operator|!=
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rev1_hardlinks
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2_hardlinks
operator|!=
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|rev2_hardlinks
argument_list|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|joining
parameter_list|()
block|{
return|return
operator|(
name|join_rev1
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

end_unit

