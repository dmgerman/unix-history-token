begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Polk's hash list manager.  So cool.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* Global caches.  The idea is that we maintain a linked list of "free"d    nodes or lists, and get new items from there.  It has been suggested    to use an obstack instead, but off the top of my head, I'm not sure    that would gain enough to be worth worrying about.  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|listcache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Node
modifier|*
name|nodecache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freenode_mem
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash function */
end_comment

begin_function
specifier|static
name|int
name|hashp
parameter_list|(
name|key
parameter_list|)
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|g
decl_stmt|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|key
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|c
init|=
operator|*
name|key
operator|++
decl_stmt|;
comment|/* The FOLD_FN_CHAR is so that findnode_fn works.  */
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|FOLD_FN_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0
condition|)
name|h
operator|=
operator|(
name|h
operator|^
operator|(
name|g
operator|>>
literal|24
operator|)
operator|)
operator|^
name|g
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a new list (or get an old one from the cache)  */
end_comment

begin_function
name|List
modifier|*
name|getlist
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|listcache
operator|!=
name|NULL
condition|)
block|{
comment|/* get a list from the cache and clear it */
name|list
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
name|listcache
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
name|list
operator|->
name|hasharray
index|[
name|i
index|]
operator|=
operator|(
name|Node
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new list from scratch */
name|list
operator|=
operator|(
name|List
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|List
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|list
operator|->
name|list
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|node
operator|->
name|prev
operator|=
name|node
expr_stmt|;
block|}
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free up a list  */
end_comment

begin_function
name|void
name|dellist
parameter_list|(
name|listp
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return;
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|list
expr_stmt|;
comment|/* free each node in the list (except header) */
while|while
condition|(
name|p
operator|->
name|next
operator|!=
name|p
condition|)
name|delnode
argument_list|(
name|p
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* free any list-private data, without freeing the actual header */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* free up the header nodes for hash lists (if any) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|hasharray
index|[
name|i
index|]
operator|)
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* put the nodes into the cache */
ifndef|#
directive|ifndef
name|NOCACHE
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
else|#
directive|else
comment|/* If NOCACHE is defined we turn off the cache.  This can make 	       it easier to tools to determine where items were allocated 	       and freed, for tracking down memory leaks and the like.  */
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* put it on the cache */
ifndef|#
directive|ifndef
name|NOCACHE
operator|(
operator|*
name|listp
operator|)
operator|->
name|next
operator|=
name|listcache
expr_stmt|;
name|listcache
operator|=
operator|*
name|listp
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
operator|*
name|listp
operator|)
operator|->
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|listp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|listp
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new list node  */
end_comment

begin_function
name|Node
modifier|*
name|getnode
parameter_list|()
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nodecache
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* get one from the cache */
name|p
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* make a new one */
name|p
operator|=
operator|(
name|Node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* always make it clean */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove a node from it's list (maybe hash list too) and free it  */
end_comment

begin_function
name|void
name|delnode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* take it out of the list */
name|p
operator|->
name|next
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
comment|/* if it was hashed, remove it from there too */
if|if
condition|(
name|p
operator|->
name|hashnext
operator|!=
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|->
name|hashnext
operator|->
name|hashprev
operator|=
name|p
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
operator|->
name|hashnext
expr_stmt|;
block|}
comment|/* free up the storage */
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node  */
end_comment

begin_function
specifier|static
name|void
name|freenode_mem
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|delproc
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
condition|)
name|p
operator|->
name|delproc
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* call the specified delproc */
else|else
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
comment|/* otherwise free() it if necessary */
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* free the key if necessary */
name|free
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* to be safe, re-initialize these */
name|p
operator|->
name|key
operator|=
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free up the storage associated with a node and recycle it  */
end_comment

begin_function
name|void
name|freenode
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
comment|/* first free the memory */
name|freenode_mem
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* then put it in the cache */
ifndef|#
directive|ifndef
name|NOCACHE
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nodecache
expr_stmt|;
name|nodecache
operator|=
name|p
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Link item P into list LIST before item MARKER.  If P->KEY is non-NULL and  * that key is already in the hash table, return -1 without modifying any  * parameter.  *   * return 0 on success  */
end_comment

begin_function
name|int
name|insert_before
parameter_list|(
name|list
parameter_list|,
name|marker
parameter_list|,
name|p
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|marker
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|key
operator|!=
name|NULL
condition|)
comment|/* hash it too? */
block|{
name|int
name|hashval
decl_stmt|;
name|Node
modifier|*
name|q
decl_stmt|;
name|hashval
operator|=
name|hashp
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|==
name|NULL
condition|)
comment|/* make a header for list? */
block|{
name|q
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|HEADER
expr_stmt|;
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|=
name|q
operator|->
name|hashnext
operator|=
name|q
operator|->
name|hashprev
operator|=
name|q
expr_stmt|;
block|}
comment|/* put it into the hash list if it's not already there */
for|for
control|(
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
operator|->
name|hashnext
init|;
name|q
operator|!=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
condition|;
name|q
operator|=
name|q
operator|->
name|hashnext
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|q
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashval
index|]
expr_stmt|;
name|p
operator|->
name|hashprev
operator|=
name|q
operator|->
name|hashprev
expr_stmt|;
name|p
operator|->
name|hashnext
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|hashprev
operator|->
name|hashnext
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|hashprev
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|marker
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|marker
operator|->
name|prev
expr_stmt|;
name|marker
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|marker
operator|->
name|prev
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * insert item p at end of list "list" (maybe hash it too) if hashing and it  * already exists, return -1 and don't actually put it in the list  *   * return 0 on success  */
end_comment

begin_function
name|int
name|addnode
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|insert_before
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|list
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like addnode, but insert p at the front of `list'.  This bogosity is  * necessary to preserve last-to-first output order for some RCS functions.  */
end_comment

begin_function
name|int
name|addnode_at_front
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|insert_before
argument_list|(
name|list
argument_list|,
name|list
operator|->
name|list
operator|->
name|next
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in hash list table and return a pointer to the    node.  Return NULL if not found.  Abort with a fatal error for    errors.  */
end_comment

begin_function
name|Node
modifier|*
name|findnode
parameter_list|(
name|list
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* This probably should be "assert (list != NULL)" (or if not we        should document the current behavior), but only if we check all        the callers to see if any are relying on this behavior.  */
if|if
condition|(
operator|(
name|list
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
operator|)
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashp
argument_list|(
name|key
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
comment|/* Not found.  */
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|hashnext
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|hashnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like findnode, but for a filename.  */
end_comment

begin_function
name|Node
modifier|*
name|findnode_fn
parameter_list|(
name|list
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* This probably should be "assert (list != NULL)" (or if not we        should document the current behavior), but only if we check all        the callers to see if any are relying on this behavior.  */
if|if
condition|(
name|list
operator|==
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|list
operator|->
name|hasharray
index|[
name|hashp
argument_list|(
name|key
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|(
name|Node
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|hashnext
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|hashnext
control|)
if|if
condition|(
name|fncmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
operator|(
name|Node
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * walk a list with a specific proc  */
end_comment

begin_function_decl
name|int
name|walklist
parameter_list|(
name|list
parameter_list|,
name|proc
parameter_list|,
name|closure
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*proc
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|closure
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|err
operator|+=
name|proc
argument_list|(
name|p
argument_list|,
name|closure
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_function
name|int
name|list_isempty
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
return|return
name|list
operator|==
name|NULL
operator|||
name|list
operator|->
name|list
operator|->
name|next
operator|==
name|list
operator|->
name|list
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*client_comp
argument_list|)
name|PROTO
argument_list|(
operator|(
specifier|const
name|Node
operator|*
operator|,
specifier|const
name|Node
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|qsort_comp
name|PROTO
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|qsort_comp
parameter_list|(
name|elem1
parameter_list|,
name|elem2
parameter_list|)
specifier|const
name|void
modifier|*
name|elem1
decl_stmt|;
specifier|const
name|void
modifier|*
name|elem2
decl_stmt|;
block|{
name|Node
modifier|*
modifier|*
name|node1
init|=
operator|(
name|Node
operator|*
operator|*
operator|)
name|elem1
decl_stmt|;
name|Node
modifier|*
modifier|*
name|node2
init|=
operator|(
name|Node
operator|*
operator|*
operator|)
name|elem2
decl_stmt|;
return|return
name|client_comp
argument_list|(
operator|*
name|node1
argument_list|,
operator|*
name|node2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * sort the elements of a list (in place)  */
end_comment

begin_function_decl
name|void
name|sortlist
parameter_list|(
name|list
parameter_list|,
name|comp
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*comp
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
specifier|const
name|Node
operator|*
operator|,
specifier|const
name|Node
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|remain
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* save the old first element of the list */
name|head
operator|=
name|list
operator|->
name|list
expr_stmt|;
name|remain
operator|=
name|head
operator|->
name|next
expr_stmt|;
comment|/* count the number of nodes in the list */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|remain
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|n
operator|++
expr_stmt|;
comment|/* allocate an array of nodes and populate it */
name|array
operator|=
operator|(
name|Node
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Node
operator|*
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|remain
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|array
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
comment|/* sort the array of nodes */
name|client_comp
operator|=
name|comp
expr_stmt|;
name|qsort
argument_list|(
name|array
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|Node
operator|*
argument_list|)
argument_list|,
name|qsort_comp
argument_list|)
expr_stmt|;
comment|/* rebuild the list from beginning to end */
name|head
operator|->
name|next
operator|=
name|head
operator|->
name|prev
operator|=
name|head
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|p
operator|->
name|prev
operator|=
name|head
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|head
operator|->
name|prev
operator|=
name|p
expr_stmt|;
block|}
comment|/* release the array of nodes */
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * compare two files list node (for sort)  */
end_comment

begin_function
name|int
name|fsortcmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|const
name|Node
modifier|*
name|p
decl_stmt|;
specifier|const
name|Node
modifier|*
name|q
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Debugging functions.  Quite useful to call from within gdb. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nodetypestring
name|PROTO
argument_list|(
operator|(
name|Ntype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|nodetypestring
parameter_list|(
name|type
parameter_list|)
name|Ntype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UNKNOWN
case|:
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
case|case
name|HEADER
case|:
return|return
operator|(
literal|"HEADER"
operator|)
return|;
case|case
name|ENTRIES
case|:
return|return
operator|(
literal|"ENTRIES"
operator|)
return|;
case|case
name|FILES
case|:
return|return
operator|(
literal|"FILES"
operator|)
return|;
case|case
name|LIST
case|:
return|return
operator|(
literal|"LIST"
operator|)
return|;
case|case
name|RCSNODE
case|:
return|return
operator|(
literal|"RCSNODE"
operator|)
return|;
case|case
name|RCSVERS
case|:
return|return
operator|(
literal|"RCSVERS"
operator|)
return|;
case|case
name|DIRS
case|:
return|return
operator|(
literal|"DIRS"
operator|)
return|;
case|case
name|UPDATE
case|:
return|return
operator|(
literal|"UPDATE"
operator|)
return|;
case|case
name|LOCK
case|:
return|return
operator|(
literal|"LOCK"
operator|)
return|;
case|case
name|NDBMNODE
case|:
return|return
operator|(
literal|"NDBMNODE"
operator|)
return|;
case|case
name|FILEATTR
case|:
return|return
operator|(
literal|"FILEATTR"
operator|)
return|;
case|case
name|VARIABLE
case|:
return|return
operator|(
literal|"VARIABLE"
operator|)
return|;
case|case
name|RCSFIELD
case|:
return|return
operator|(
literal|"RCSFIELD"
operator|)
return|;
block|}
return|return
operator|(
literal|"<trash>"
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|printnode
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|printnode
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL node.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Node at 0x%p: type = %s, key = 0x%p = \"%s\", data = 0x%p, next = 0x%p, prev = 0x%p\n"
argument_list|,
name|node
argument_list|,
name|nodetypestring
argument_list|(
name|node
operator|->
name|type
argument_list|)
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|node
operator|->
name|data
argument_list|,
name|node
operator|->
name|next
argument_list|,
name|node
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is global, not static, so that its name is unique and to avoid    compiler warnings about it not being used.  But it is not used by CVS;    it exists so one can call it from a debugger.  */
end_comment

begin_decl_stmt
name|void
name|printlist
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|printlist
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NULL list.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"List at 0x%p: list = 0x%p, HASHSIZE = %d, next = 0x%p\n"
argument_list|,
name|list
argument_list|,
name|list
operator|->
name|list
argument_list|,
name|HASHSIZE
argument_list|,
name|list
operator|->
name|next
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|printnode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

