begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Tag and Rtag  *   * Add or delete a symbolic name to an RCS file, or a collection of RCS files.  * Tag uses the checked out revision in the current directory, rtag uses  * the modules database, if necessary.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|rtag_proc
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|char
operator|*
name|xwhere
operator|,
name|char
operator|*
name|mwhere
operator|,
name|char
operator|*
name|mfile
operator|,
name|int
name|shorten
operator|,
name|int
name|local_specified
operator|,
name|char
operator|*
name|mname
operator|,
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pretag_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|masterlist_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tag_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pretag_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|tag_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtag_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtag_delete
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcsfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tag_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|numtag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* specific revision to tag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numtag_validated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symtag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tag to add or delete */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delete_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adding a tag by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|branch_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make an automagic "branch" tag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force tag to match by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_move
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't force tag to move by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_uptodate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no uptodate-check by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|attic_too
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove tag from Attic files */
end_comment

begin_decl_stmt
specifier|static
name|int
name|is_rtag
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tag_info
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|tlist
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mtlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|tlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rtag_opts
index|[]
init|=
literal|"+abdFflnQqRr:D:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|rtag_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-abdFflnR] [-r rev|-D date] tag modules...\n"
block|,
literal|"\t-a\tClear tag from removed files that would not otherwise be tagged.\n"
block|,
literal|"\t-b\tMake the tag a \"branch\" tag, allowing concurrent development.\n"
block|,
literal|"\t-d\tDelete the given tag.\n"
block|,
literal|"\t-F\tMove tag if it already exists.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive.\n"
block|,
literal|"\t-n\tNo execution of 'tag program'.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-r rev\tExisting revision/tag.\n"
block|,
literal|"\t-D\tExisting date.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tag_opts
index|[]
init|=
literal|"+bcdFflQqRr:D:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tag_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-bcdFflR] [-r rev|-D date] tag [files...]\n"
block|,
literal|"\t-b\tMake the tag a \"branch\" tag, allowing concurrent development.\n"
block|,
literal|"\t-c\tCheck that working files are unmodified.\n"
block|,
literal|"\t-d\tDelete the given tag.\n"
block|,
literal|"\t-F\tMove tag if it already exists.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-r rev\tExisting revision/tag.\n"
block|,
literal|"\t-D\tExisting date.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|cvstag
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
name|is_rtag
operator|=
operator|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"rtag"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|is_rtag
condition|?
name|rtag_usage
else|:
name|tag_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|is_rtag
condition|?
name|rtag_opts
else|:
name|tag_opts
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|attic_too
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|branch_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|check_uptodate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force_tag_move
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|numtag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|date
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|is_rtag
condition|?
name|rtag_usage
else|:
name|tag_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
operator|(
name|is_rtag
condition|?
literal|2
else|:
literal|1
operator|)
condition|)
name|usage
argument_list|(
name|is_rtag
condition|?
name|rtag_usage
else|:
name|tag_usage
argument_list|)
expr_stmt|;
name|symtag
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|date
operator|&&
name|numtag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-r and -D options are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_flag
operator|&&
name|branch_mode
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: -b ignored with -d options"
argument_list|)
expr_stmt|;
name|RCS_check_tag
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
comment|/* We're the client side.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|attic_too
condition|)
name|send_arg
argument_list|(
literal|"-a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|send_arg
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_uptodate
condition|)
name|send_arg
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_flag
condition|)
name|send_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_move
condition|)
name|send_arg
argument_list|(
literal|"-F"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|run_module_prog
condition|)
name|send_arg
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtag
condition|)
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|numtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rtag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"rtag\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
comment|/* I think the -c case is like "cvs status", in 		       which we really better be correct rather than 		       being fast; it is just too confusing otherwise.  */
name|check_uptodate
condition|?
literal|0
else|:
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"tag\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|is_rtag
condition|)
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|;
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX last arg should be repository, but doesn't make sense here */
name|history_write
argument_list|(
literal|'T'
argument_list|,
operator|(
name|delete_flag
condition|?
literal|"D"
else|:
operator|(
name|numtag
condition|?
name|numtag
else|:
operator|(
name|date
condition|?
name|date
else|:
literal|"A"
operator|)
operator|)
operator|)
argument_list|,
name|symtag
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|TAG
argument_list|,
name|delete_flag
condition|?
literal|"Untagging"
else|:
literal|"Tagging"
argument_list|,
name|rtag_proc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|run_module_prog
argument_list|,
literal|0
argument_list|,
name|symtag
argument_list|)
expr_stmt|;
block|}
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|rtag_proc
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * callback proc for doing the real work of tagging  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|rtag_proc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xwhere
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|mname
parameter_list|,
name|msg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|xwhere
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
comment|/* Begin section which is identical to patch_proc--should this        be abstracted out somehow?  */
name|char
modifier|*
name|myargv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|is_rtag
condition|)
block|{
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* if mfile isn't null, we need to set up to do only part of the module */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* if the portion of the module is a path, put the dir part on repos */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* take care of the rest */
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* directory means repository gets the dir tacked on */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|myargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|myargv
index|[
literal|1
index|]
operator|=
name|mfile
expr_stmt|;
name|argc
operator|=
literal|2
expr_stmt|;
name|argv
operator|=
name|myargv
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* cd to the starting repository */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* End section which is identical to patch_proc.  */
if|if
condition|(
name|delete_flag
operator|||
name|attic_too
operator|||
operator|(
name|force_tag_match
operator|&&
name|numtag
operator|)
condition|)
name|which
operator|=
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
else|else
name|which
operator|=
name|W_REPOS
expr_stmt|;
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|where
operator|=
name|NULL
expr_stmt|;
name|which
operator|=
name|W_LOCAL
expr_stmt|;
name|repository
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|numtag
operator|!=
name|NULL
operator|&&
operator|!
name|numtag_validated
condition|)
block|{
name|tag_check_valid
argument_list|(
name|numtag
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|numtag_validated
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check to make sure they are authorized to tag all the         specified files in the repository */
name|mtlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct the above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/* It would be nice to provide consistency with respect to        commits; however CVS lacks the infrastructure to do that (see        Concurrency in cvs.texinfo and comment in do_recursion).  We        do need to ensure that the RCS file info that gets read and        cached in do_recursion isn't stale by the time we get around        to using it to rewrite the RCS file in the callback, and this        is the easiest way to accomplish that.  */
name|lock_tree_for_write
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|is_rtag
condition|?
name|rtag_fileproc
else|:
name|tag_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|tag_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mtlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check file that is to be tagged */
end_comment

begin_comment
comment|/* All we do here is add it to our list */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
if|if
condition|(
name|check_uptodate
condition|)
block|{
name|Ctype
name|status
init|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|vers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|T_UPTODATE
operator|)
operator|&&
operator|(
name|status
operator|!=
name|T_CHECKOUT
operator|)
operator|&&
operator|(
name|status
operator|!=
name|T_PATCH
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is locally modified"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|finfo
operator|->
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mtlist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tlist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|tlist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|tlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|tlist
operator|=
name|tlist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|masterlist_delproc
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mtlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* do tlist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|tag_delproc
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Here we duplicate the calculation in tag_fileproc about which        version we are going to tag.  There probably are some subtle races        (e.g. numtag is "foo" which gets moved between here and        tag_fileproc).  */
if|if
condition|(
operator|!
name|is_rtag
operator|&&
name|numtag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
condition|)
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|data
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|numtag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|int
name|addit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|oversion
decl_stmt|;
name|oversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oversion
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|delete_flag
condition|)
block|{
comment|/* Deleting a tag which did not exist is a noop and 		   should not be logged.  */
name|addit
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|delete_flag
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oversion
argument_list|,
name|p
operator|->
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addit
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|force_tag_move
condition|)
block|{
name|addit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oversion
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addit
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|tlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mtlist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|tlist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|tlist
expr_stmt|;
block|}
else|else
block|{
name|tlist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tlist
operator|->
name|list
operator|->
name|next
operator|==
name|tlist
operator|->
name|list
operator|)
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_TAGINFO
argument_list|,
name|repos
argument_list|,
name|pretag_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-tag check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pretag_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
if|if
condition|(
name|filter
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-tag filter '%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|delete_flag
condition|?
literal|"del"
else|:
name|force_tag_move
condition|?
literal|"mov"
else|:
literal|"add"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|tlist
argument_list|,
name|pretag_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|masterlist_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|tlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ml
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|pretag_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to rtag a particular file, as appropriate with the options that were  * set above.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|rtag_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* find the parsed RCS data */
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|finfo
operator|->
name|rcs
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*      * For tagging an RCS file which is a symbolic link, you'd best be      * running with RCS 5.6, since it knows how to handle symbolic links      * correctly without breaking your link!      */
if|if
condition|(
name|delete_flag
condition|)
return|return
operator|(
name|rtag_delete
argument_list|(
name|rcsfile
argument_list|)
operator|)
return|;
comment|/*      * If we get here, we are adding a tag.  But, if -a was specified, we      * need to check to see if a -r or -D option was specified.  If neither      * was specified and the file is in the Attic, remove the tag.      */
if|if
condition|(
name|attic_too
operator|&&
operator|(
operator|!
name|numtag
operator|&&
operator|!
name|date
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rcsfile
operator|->
name|flags
operator|&
name|VALID
operator|)
operator|&&
operator|(
name|rcsfile
operator|->
name|flags
operator|&
name|INATTIC
operator|)
condition|)
return|return
operator|(
name|rtag_delete
argument_list|(
name|rcsfile
argument_list|)
operator|)
return|;
block|}
name|version
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|numtag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
comment|/* If -a specified, clean up any old tags */
if|if
condition|(
name|attic_too
condition|)
operator|(
name|void
operator|)
name|rtag_delete
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|force_tag_match
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find tag `%s' in `%s'"
argument_list|,
name|numtag
condition|?
name|numtag
else|:
literal|"head"
argument_list|,
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|numtag
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|numtag
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|numtag
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * We didn't find a match for the numeric tag that was specified, but 	 * that's OK.  just pass the numeric tag on to rcs, to be tagged as 	 * specified.  Could get here if one tried to tag "1.1.1" and there 	 * was a 1.1.1 branch with some head revision.  In this case, we want 	 * the tag to reference "1.1.1" and not the revision at the head of 	 * the branch.  Use a symbolic tag for that. 	 */
name|rev
operator|=
name|branch_mode
condition|?
name|RCS_magicrev
argument_list|(
name|rcsfile
argument_list|,
name|version
argument_list|)
else|:
name|numtag
expr_stmt|;
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcsfile
argument_list|,
name|symtag
argument_list|,
name|numtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
name|RCS_rewrite
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|oversion
decl_stmt|;
comment|/* 	 * As an enhancement for the case where a tag is being re-applied to 	 * a large body of a module, make one extra call to RCS_getversion to 	 * see if the tag is already set in the RCS file.  If so, check to 	 * see if it needs to be moved.  If not, do nothing.  This will 	 * likely save a lot of time when simply moving the tag to the 	 * "current" head revisions of a module -- which I have found to be a 	 * typical tagging operation. 	 */
name|rev
operator|=
name|branch_mode
condition|?
name|RCS_magicrev
argument_list|(
name|rcsfile
argument_list|,
name|version
argument_list|)
else|:
name|version
expr_stmt|;
name|oversion
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oversion
operator|!=
name|NULL
condition|)
block|{
name|int
name|isbranch
init|=
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|symtag
argument_list|)
decl_stmt|;
comment|/* 	     * if versions the same and neither old or new are branches don't 	     * have to do anything 	     */
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
name|oversion
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|branch_mode
operator|&&
operator|!
name|isbranch
condition|)
block|{
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|force_tag_move
condition|)
block|{
comment|/* we're NOT going to move the tag */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"W %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" : %s already exists on %s %s"
argument_list|,
name|symtag
argument_list|,
name|isbranch
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
name|oversion
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" : NOT MOVING tag to %s %s\n"
argument_list|,
name|branch_mode
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcsfile
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
name|RCS_rewrite
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to set tag `%s' to revision `%s' in `%s'"
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|,
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If -d is specified, "force_tag_match" is set, so that this call to  * RCS_getversion() will return a NULL version string if the symbolic  * tag does not exist in the RCS file.  *   * If the -r flag was used, numtag is set, and we only delete the  * symtag from files that have numtag.  *   * This is done here because it's MUCH faster than just blindly calling  * "rcs" to remove the tag... trust me.  */
end_comment

begin_function
specifier|static
name|int
name|rtag_delete
parameter_list|(
name|rcsfile
parameter_list|)
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
block|{
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|numtag
condition|)
block|{
name|version
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|numtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|rcsfile
argument_list|,
name|symtag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag `%s' from `%s'"
argument_list|,
name|symtag
argument_list|,
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to tag a particular file (the currently checked out version is  * tagged with the specified tag - or the specified tag is deleted).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tag_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|version
decl_stmt|,
modifier|*
name|oversion
decl_stmt|;
name|char
modifier|*
name|nversion
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numtag
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|date
operator|!=
name|NULL
operator|)
condition|)
block|{
name|nversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|numtag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nversion
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|delete_flag
condition|)
block|{
comment|/* 	 * If -d is specified, "force_tag_match" is set, so that this call to 	 * RCS_getversion() will return a NULL version string if the symbolic 	 * tag does not exist in the RCS file. 	 *  	 * This is done here because it's MUCH faster than just blindly calling 	 * "rcs" to remove the tag... trust me. 	 */
name|version
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag %s from %s"
argument_list|,
name|symtag
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* warm fuzzies */
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"D "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * If we are adding a tag, we need to know which version we have checked      * out and we'll tag that version.      */
if|if
condition|(
name|nversion
operator|==
name|NULL
condition|)
block|{
name|version
operator|=
name|vers
operator|->
name|vn_user
expr_stmt|;
block|}
else|else
block|{
name|version
operator|=
name|nversion
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"couldn't tag added but un-commited file `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|version
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"skipping removed but un-commited file `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision control file for `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * As an enhancement for the case where a tag is being re-applied to a      * large number of files, make one extra call to RCS_getversion to see      * if the tag is already set in the RCS file.  If so, check to see if it      * needs to be moved.  If not, do nothing.  This will likely save a lot of      * time when simply moving the tag to the "current" head revisions of a      * module -- which I have found to be a typical tagging operation.      */
name|rev
operator|=
name|branch_mode
condition|?
name|RCS_magicrev
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|version
argument_list|)
else|:
name|version
expr_stmt|;
name|oversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oversion
operator|!=
name|NULL
condition|)
block|{
name|int
name|isbranch
init|=
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|symtag
argument_list|)
decl_stmt|;
comment|/* 	 * if versions the same and neither old or new are branches don't have  	 * to do anything 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
name|oversion
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|branch_mode
operator|&&
operator|!
name|isbranch
condition|)
block|{
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|force_tag_move
condition|)
block|{
comment|/* we're NOT going to move the tag */
name|cvs_output
argument_list|(
literal|"W "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" : "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|symtag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" already exists on "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|isbranch
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|oversion
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" : NOT MOVING tag to "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|branch_mode
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to set tag %s to revision %s in %s"
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|branch_mode
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* more warm fuzzies */
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"T "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nversion
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nversion
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|tag_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
name|ignore_directory
argument_list|(
name|update_dir
argument_list|)
condition|)
block|{
comment|/* print the warm fuzzy message */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Ignoring %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
name|R_SKIP_ALL
return|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s %s"
argument_list|,
name|delete_flag
condition|?
literal|"Untagging"
else|:
literal|"Tagging"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code relating to the val-tags file.  Note that this file has no way    of knowing when a tag has been deleted.  The problem is that there    is no way of knowing whether a tag still exists somewhere, when we    delete it some places.  Using per-directory val-tags files (in    CVSREP) might be better, but that might slow down the process of    verifying that a tag is correct (maybe not, for the likely cases,    if carefully done), and/or be harder to implement correctly.  */
end_comment

begin_struct
struct|struct
name|val_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|found
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|val_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|val_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsdata
decl_stmt|;
name|struct
name|val_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|val_args
operator|*
operator|)
name|callerdat
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|rcsdata
operator|=
name|finfo
operator|->
name|rcs
operator|)
operator|==
name|NULL
condition|)
comment|/* Not sure this can happen, after all we passed only 	   W_REPOS | W_ATTIC.  */
return|return
literal|0
return|;
name|tag
operator|=
name|RCS_gettag
argument_list|(
name|rcsdata
argument_list|,
name|args
operator|->
name|name
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: should find out a way to stop the search at this point.  */
name|args
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Dtype
name|val_direntproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Dtype
name|val_direntproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
comment|/* This is not quite right--it doesn't get right the case of "cvs        update -d -r foobar" where foobar is a tag which exists only in        files in a directory which does not exist yet, but which is        about to be created.  */
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
name|R_PROCESS
return|;
return|return
name|R_SKIP_ALL
return|;
block|}
end_function

begin_comment
comment|/* Check to see whether NAME is a valid tag.  If so, return.  If not    print an error message and exit.  ARGC, ARGV, LOCAL, and AFLAG specify    which files we will be operating on.     REPOSITORY is the repository if we need to cd into it, or NULL if    we are already there, or "" if we should do a W_LOCAL recursion.    Sorry for three cases, but the "" case is needed in case the    working directories come from diverse parts of the repository, the    NULL case avoids an unneccesary chdir, and the non-NULL, non-""    case is needed for checkout, where we don't want to chdir if the    tag is found in CVSROOTADM_VALTAGS, but there is not (yet) any    local directory.  */
end_comment

begin_function
name|void
name|tag_check_valid
parameter_list|(
name|name
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|valtags_filename
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|nowrite
init|=
literal|0
decl_stmt|;
name|datum
name|mytag
decl_stmt|;
name|struct
name|val_args
name|the_val_args
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|int
name|which
decl_stmt|;
comment|/* Numeric tags require only a syntactic check.  */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ Numeric tag %s contains characters other than digits and '.'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Special tags are always valid.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_BASE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* FIXME: This routine doesn't seem to do any locking whatsoever        (and it is called from places which don't have locks in place).        If two processes try to write val-tags at the same time, it would        seem like we are in trouble.  */
name|mytag
operator|.
name|dptr
operator|=
name|name
expr_stmt|;
name|mytag
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|valtags_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
name|CVSROOTADM
operator|+
sizeof|sizeof
name|CVSROOTADM_VALTAGS
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|valtags_filename
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_VALTAGS
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|valtags_filename
argument_list|,
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot open %s read/write"
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|valtags_filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|nowrite
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
block|}
comment|/* If the file merely fails to exist, we just keep going and create 	   it later if need be.  */
block|}
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|datum
name|val
decl_stmt|;
name|val
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|mytag
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Found.  The tag is valid.  */
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: should check errors somehow (add dbm_error to myndbm.c?).  */
block|}
comment|/* We didn't find the tag in val-tags, so look through all the RCS files        to see whether it exists there.  Yes, this is expensive, but there        is no other way to cope with a tag which might have been created        by an old version of CVS, from before val-tags was invented.         Since we need this code anyway, we also use it to create        entries in val-tags in general (that is, the val-tags entry        will get created the first time the tag is used, not when the        tag is created).  */
name|the_val_args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|the_val_args
operator|.
name|found
operator|=
literal|0
expr_stmt|;
name|which
operator|=
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
if|if
condition|(
name|repository
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|which
operator||=
name|W_LOCAL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change to %s directory"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|start_recursion
argument_list|(
name|val_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|val_direntproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|the_val_args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|!=
name|NULL
operator|&&
name|repository
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|the_val_args
operator|.
name|found
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such tag %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The tags is valid but not mentioned in val-tags.  Add it.  */
name|datum
name|value
decl_stmt|;
if|if
condition|(
name|noexec
operator|||
name|nowrite
condition|)
block|{
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|valtags_filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot create %s"
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|value
operator|.
name|dptr
operator|=
literal|"y"
expr_stmt|;
name|value
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dbm_store
argument_list|(
name|db
argument_list|,
name|mytag
argument_list|,
name|value
argument_list|,
name|DBM_REPLACE
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot store %s into %s"
argument_list|,
name|name
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether a join tag is valid.  This is just like  * tag_check_valid, but we must stop before the colon if there is one.  */
end_comment

begin_function
name|void
name|tag_check_valid_join
parameter_list|(
name|join_tag
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|join_tag
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|c
operator|=
name|xstrdup
argument_list|(
name|join_tag
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|join_tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Numeric join tag %s may not contain a date specifier"
argument_list|,
name|join_tag
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* hmmm...  I think it makes sense to allow -j:<date>, but 	 * for now this fixes a bug where CVS just spins and spins (I 	 * think in the RCS code) looking for a zero length tag. 	 */
if|if
condition|(
operator|!
operator|*
name|c
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"argument to join may not contain a date specifier without a tag"
argument_list|)
expr_stmt|;
block|}
name|tag_check_valid
argument_list|(
name|c
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

