begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Tag  *   * Add or delete a symbolic name to an RCS file, or a collection of RCS files.  * Uses the checked out revision in the current directory.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|check_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pretag_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|masterlist_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tag_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pretag_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|tag_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tag_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tag_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|numtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delete_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adding a tag by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|branch_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make an automagic "branch" tag */
end_comment

begin_decl_stmt
specifier|static
name|int
name|local
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force tag to match by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_tag_move
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't force tag to move by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_uptodate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no uptodate-check by default */
end_comment

begin_struct
struct|struct
name|tag_info
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|tlist
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mtlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|tlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tag_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lRF] [-b] [-d] [-c] [-r tag|-D date] tag [files...]\n"
block|,
literal|"\t-l\tLocal directory only, not recursive.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-d\tDelete the given tag.\n"
block|,
literal|"\t-r rev\tExisting revision/tag.\n"
block|,
literal|"\t-D\tExisting date.\n"
block|,
literal|"\t-f\tForce a head revision if specified tag not found.\n"
block|,
literal|"\t-b\tMake the tag a \"branch\" tag, allowing concurrent development.\n"
block|,
literal|"\t-F\tMove tag if it already exists.\n"
block|,
literal|"\t-c\tCheck that working files are unmodified.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|cvstag
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|tag_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+FQqlRcdr:D:bf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|check_uptodate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|numtag
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|date
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|branch_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force_tag_move
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|tag_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|tag_usage
argument_list|)
expr_stmt|;
name|symtag
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|date
operator|&&
name|numtag
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-r and -D options are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_flag
operator|&&
name|branch_mode
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: -b ignored with -d options"
argument_list|)
expr_stmt|;
name|RCS_check_tag
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
comment|/* We're the client side.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_flag
condition|)
name|send_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_uptodate
condition|)
name|send_arg
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_mode
condition|)
name|send_arg
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_tag_move
condition|)
name|send_arg
argument_list|(
literal|"-F"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numtag
condition|)
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|numtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
comment|/* SEND_NO_CONTENTS has a mildly bizarre interaction with 	   check_uptodate; if the timestamp is modified but the file 	   is unmodified, the check will fail, only to have "cvs diff" 	   show no differences (and one must do "update" or something to 	   reset the client's notion of the timestamp).  */
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"tag\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|numtag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|numtag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* check to make sure they are authorized to tag all the         specified files in the repository */
name|mtlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct the above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/* start the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|tag_fileproc
argument_list|,
name|tag_filesdoneproc
argument_list|,
name|tag_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mtlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check file that is to be tagged */
end_comment

begin_comment
comment|/* All we do here is add it to our list */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
if|if
condition|(
name|check_uptodate
condition|)
block|{
name|Ctype
name|status
init|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|vers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|T_UPTODATE
operator|)
operator|&&
operator|(
name|status
operator|!=
name|T_CHECKOUT
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is locally modified"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|finfo
operator|->
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mtlist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tlist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|tlist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|tlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|tlist
operator|=
name|tlist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|masterlist_delproc
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mtlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* do tlist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|tag_delproc
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Here we duplicate the calculation in tag_fileproc about which        version we are going to tag.  There probably are some subtle races        (e.g. numtag is "foo" which gets moved between here and        tag_fileproc).  */
if|if
condition|(
name|numtag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
condition|)
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|data
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|numtag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|int
name|addit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|oversion
decl_stmt|;
name|oversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oversion
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|delete_flag
condition|)
block|{
name|addit
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|oversion
argument_list|,
name|p
operator|->
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addit
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|force_tag_move
condition|)
block|{
name|addit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|oversion
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addit
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|tlist
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mtlist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|tlist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|tlist
expr_stmt|;
block|}
else|else
block|{
name|tlist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tlist
operator|->
name|list
operator|->
name|next
operator|==
name|tlist
operator|->
name|list
operator|)
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_TAGINFO
argument_list|,
name|repos
argument_list|,
name|pretag_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-tag check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pretag_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
if|if
condition|(
name|filter
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-tag filter '%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|symtag
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|delete_flag
condition|?
literal|"del"
else|:
name|force_tag_move
condition|?
literal|"mov"
else|:
literal|"add"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|tlist
argument_list|,
name|pretag_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|masterlist_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|tlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ml
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|pretag_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to tag a particular file (the currently checked out version is  * tagged with the specified tag - or the specified tag is deleted).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|tag_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|version
decl_stmt|,
modifier|*
name|oversion
decl_stmt|;
name|char
modifier|*
name|nversion
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
comment|/* Lock the directory if it is not already locked.  We can't rely        on tag_dirproc because it won't handle the case where the user        specifies a list of files on the command line.  */
comment|/* We do not need to acquire a full write lock for the tag operation:        the revisions are obtained from the working directory, so we do not        require consistency across the entire repository.  However, we do        need to prevent simultaneous tag operations from interfering with        each other.  Therefore, we write lock each directory as we enter        it, and unlock it as we leave it.  */
name|lock_dir_for_write
argument_list|(
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numtag
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|date
operator|!=
name|NULL
operator|)
condition|)
block|{
name|nversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|numtag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nversion
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|delete_flag
condition|)
block|{
comment|/* 	 * If -d is specified, "force_tag_match" is set, so that this call to 	 * RCS_getversion() will return a NULL version string if the symbolic 	 * tag does not exist in the RCS file. 	 *  	 * This is done here because it's MUCH faster than just blindly calling 	 * "rcs" to remove the tag... trust me. 	 */
name|version
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
operator|||
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag %s from %s"
argument_list|,
name|symtag
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* warm fuzzies */
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"D "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * If we are adding a tag, we need to know which version we have checked      * out and we'll tag that version.      */
if|if
condition|(
name|nversion
operator|==
name|NULL
condition|)
block|{
name|version
operator|=
name|vers
operator|->
name|vn_user
expr_stmt|;
block|}
else|else
block|{
name|version
operator|=
name|nversion
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"couldn't tag added but un-commited file `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|version
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"skipping removed but un-commited file `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find revision control file for `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * As an enhancement for the case where a tag is being re-applied to a      * large number of files, make one extra call to RCS_getversion to see      * if the tag is already set in the RCS file.  If so, check to see if it      * needs to be moved.  If not, do nothing.  This will likely save a lot of      * time when simply moving the tag to the "current" head revisions of a      * module -- which I have found to be a typical tagging operation.      */
name|rev
operator|=
name|branch_mode
condition|?
name|RCS_magicrev
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|version
argument_list|)
else|:
name|version
expr_stmt|;
name|oversion
operator|=
name|RCS_getversion
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|oversion
operator|!=
name|NULL
condition|)
block|{
name|int
name|isbranch
init|=
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|symtag
argument_list|)
decl_stmt|;
comment|/* 	 * if versions the same and neither old or new are branches don't have  	 * to do anything 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
name|oversion
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|branch_mode
operator|&&
operator|!
name|isbranch
condition|)
block|{
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|force_tag_move
condition|)
block|{
comment|/* we're NOT going to move the tag */
name|cvs_output
argument_list|(
literal|"W "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" : "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|symtag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" already exists on "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|isbranch
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|oversion
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" : NOT MOVING tag to "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|branch_mode
condition|?
literal|"branch"
else|:
literal|"version"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|oversion
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to set tag %s to revision %s in %s"
argument_list|,
name|symtag
argument_list|,
name|rev
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* more warm fuzzies */
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"T "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nversion
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nversion
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear any lock we may hold on the current directory.  */
end_comment

begin_function
specifier|static
name|int
name|tag_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|Lock_Cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|tag_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s %s"
argument_list|,
name|delete_flag
condition|?
literal|"Untagging"
else|:
literal|"Tagging"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code relating to the val-tags file.  Note that this file has no way    of knowing when a tag has been deleted.  The problem is that there    is no way of knowing whether a tag still exists somewhere, when we    delete it some places.  Using per-directory val-tags files (in    CVSREP) might be better, but that might slow down the process of    verifying that a tag is correct (maybe not, for the likely cases,    if carefully done), and/or be harder to implement correctly.  */
end_comment

begin_struct
struct|struct
name|val_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|found
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|val_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|val_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsdata
decl_stmt|;
name|struct
name|val_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|val_args
operator|*
operator|)
name|callerdat
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|rcsdata
operator|=
name|finfo
operator|->
name|rcs
operator|)
operator|==
name|NULL
condition|)
comment|/* Not sure this can happen, after all we passed only 	   W_REPOS | W_ATTIC.  */
return|return
literal|0
return|;
name|tag
operator|=
name|RCS_gettag
argument_list|(
name|rcsdata
argument_list|,
name|args
operator|->
name|name
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: should find out a way to stop the search at this point.  */
name|args
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|Dtype
name|val_direntproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Dtype
name|val_direntproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
comment|/* This is not quite right--it doesn't get right the case of "cvs        update -d -r foobar" where foobar is a tag which exists only in        files in a directory which does not exist yet, but which is        about to be created.  */
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|R_SKIP_ALL
return|;
block|}
end_function

begin_comment
comment|/* Check to see whether NAME is a valid tag.  If so, return.  If not    print an error message and exit.  ARGC, ARGV, LOCAL, and AFLAG specify    which files we will be operating on.     REPOSITORY is the repository if we need to cd into it, or NULL if    we are already there, or "" if we should do a W_LOCAL recursion.    Sorry for three cases, but the "" case is needed in case the    working directories come from diverse parts of the repository, the    NULL case avoids an unneccesary chdir, and the non-NULL, non-""    case is needed for checkout, where we don't want to chdir if the    tag is found in CVSROOTADM_VALTAGS, but there is not (yet) any    local directory.  */
end_comment

begin_function
name|void
name|tag_check_valid
parameter_list|(
name|name
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|valtags_filename
decl_stmt|;
name|int
name|err
decl_stmt|;
name|datum
name|mytag
decl_stmt|;
name|struct
name|val_args
name|the_val_args
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|int
name|which
decl_stmt|;
comment|/* Numeric tags require only a syntactic check.  */
if|if
condition|(
name|isdigit
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ Numeric tag %s contains characters other than digits and '.'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Special tags are always valid.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_BASE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|TAG_HEAD
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* FIXME: This routine doesn't seem to do any locking whatsoever        (and it is called from places which don't have locks in place).        If two processes try to write val-tags at the same time, it would        seem like we are in trouble.  */
name|mytag
operator|.
name|dptr
operator|=
name|name
expr_stmt|;
name|mytag
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|valtags_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
name|CVSROOTADM
operator|+
sizeof|sizeof
name|CVSROOTADM_VALTAGS
operator|+
literal|20
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|valtags_filename
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|valtags_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|valtags_filename
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|valtags_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|valtags_filename
argument_list|,
name|CVSROOTADM_VALTAGS
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|valtags_filename
argument_list|,
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
comment|/* If the file merely fails to exist, we just keep going and create 	   it later if need be.  */
block|}
else|else
block|{
name|datum
name|val
decl_stmt|;
name|val
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|mytag
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Found.  The tag is valid.  */
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FIXME: should check errors somehow (add dbm_error to myndbm.c?).  */
block|}
comment|/* We didn't find the tag in val-tags, so look through all the RCS files        to see whether it exists there.  Yes, this is expensive, but there        is no other way to cope with a tag which might have been created        by an old version of CVS, from before val-tags was invented.         Since we need this code anyway, we also use it to create        entries in val-tags in general (that is, the val-tags entry        will get created the first time the tag is used, not when the        tag is created).  */
name|the_val_args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|the_val_args
operator|.
name|found
operator|=
literal|0
expr_stmt|;
name|which
operator|=
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
if|if
condition|(
name|repository
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|which
operator||=
name|W_LOCAL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot change to %s directory"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|start_recursion
argument_list|(
name|val_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|val_direntproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|the_val_args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|!=
name|NULL
operator|&&
name|repository
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|the_val_args
operator|.
name|found
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such tag %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The tags is valid but not mentioned in val-tags.  Add it.  */
name|datum
name|value
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
block|{
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|valtags_filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s"
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|value
operator|.
name|dptr
operator|=
literal|"y"
expr_stmt|;
name|value
operator|.
name|dsize
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dbm_store
argument_list|(
name|db
argument_list|,
name|mytag
argument_list|,
name|value
argument_list|,
name|DBM_REPLACE
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot store %s into %s"
argument_list|,
name|name
argument_list|,
name|valtags_filename
argument_list|)
expr_stmt|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|valtags_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether a join tag is valid.  This is just like  * tag_check_valid, but we must stop before the colon if there is one.  */
end_comment

begin_function
name|void
name|tag_check_valid_join
parameter_list|(
name|join_tag
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|join_tag
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|c
operator|=
name|xstrdup
argument_list|(
name|join_tag
argument_list|)
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
name|c
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|join_tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Numeric join tag %s may not contain a date specifier"
argument_list|,
name|join_tag
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
name|tag_check_valid
argument_list|(
name|c
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

