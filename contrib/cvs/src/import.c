begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * "import" checks in the vendor release located in the current directory into  * the CVS source repository.  The CVS vendor branch support is utilized.  *   * At least three arguments are expected to follow the options:  *	repository	Where the source belongs relative to the CVSROOT  *	VendorTag	Vendor's major tag  *	VendorReleTag	Tag for this particular release  *  * Additional arguments specify more Vendor Release Tags.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_comment
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_rev
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_tags
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_import_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_rcs_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|,
name|int
name|inattic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_log
name|PROTO
argument_list|(
operator|(
name|int
name|ch
operator|,
name|char
operator|*
name|fname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|repos_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vbranch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_file_modtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|import_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-d] [-k subst] [-I ign] [-m msg] [-b branch]\n"
block|,
literal|"    [-W spec] repository vendor-tag release-tags...\n"
block|,
literal|"\t-d\tUse the file's modification time as the time of import.\n"
block|,
literal|"\t-k sub\tSet default RCS keyword substitution mode.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
literal|"\t-b bra\tVendor branch id.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-W spec\tWrappers specification line.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|import
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmpfile
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|msglen
decl_stmt|,
name|err
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
name|vbranch
operator|=
name|xstrdup
argument_list|(
name|CVSBRANCH
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+Qqdb:m:I:k:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|cvs_cmd_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* CVS 1.10 and older clients will send this, but it 		       doesn't do any good.  So tell the user we can't 		       cope, rather than silently losing.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: not setting the time of import from the file"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"due to client limitations"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|use_file_modtime
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|free
argument_list|(
name|vbranch
argument_list|)
expr_stmt|;
name|vbranch
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* RCS_check_kflag returns strings of the form -kxx.  We 		   only use it for validation, so we can free the value 		   as soon as it is returned. */
name|free
argument_list|(
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|keyword_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|wrap_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* This is for handling the Checkin-time request.  It might seem a        bit odd to enable the use_file_modtime code even in the case        where Checkin-time was not sent for a particular file.  The        effect is that we use the time of upload, rather than the time        when we call RCS_checkin.  Since those times are both during        CVS's run, that seems OK, and it is easier to implement than        putting the "was Checkin-time sent" flag in CVS/Entries or some        such place.  */
if|if
condition|(
name|server_active
condition|)
name|use_file_modtime
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Don't allow "CVS" as any directory in module path.      *      * Could abstract this to valid_module_path, but I don't think we'll need      * to call it from anywhere else.      */
if|if
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"CVS"
argument_list|)
operator|)
operator|&&
comment|/* path contains "CVS" AND ... */
operator|(
operator|(
name|cp
operator|==
name|argv
index|[
literal|0
index|]
operator|)
operator|||
name|ISDIRSEP
argument_list|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|&&
comment|/* /^CVS/ OR m#/CVS# AND ... */
operator|(
operator|(
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
operator|==
literal|'\0'
operator|)
operator|||
name|ISDIRSEP
argument_list|(
operator|*
operator|(
name|cp
operator|+
literal|3
operator|)
argument_list|)
operator|)
comment|/* /CVS$/ OR m#CVS/# */
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"The word `CVS' is reserved by CVS and may not be used"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"as a directory in a path or as a file name."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
comment|/* check the tags for validity */
block|{
name|int
name|j
decl_stmt|;
name|RCS_check_tag
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|j
index|]
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' was specified more than once"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - this should be a module, not just a pathname */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|&&
name|pathname_levels
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_parsed_root
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing CVSROOT environment variable\n"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set it or specify the '-d' option to %s."
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repos_len
operator|=
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is somewhere between a security hole and "unexpected" to 	   let the client start mucking around outside the cvsroot 	   (wouldn't get the right CVSROOT configuration,&c).  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"directory %s not relative within the repository"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*      * Consistency checks on the specified vendor branch.  It must be      * composed of only numbers and dots ('.').  Also, for now we only      * support branching to a single level, so the specified vendor branch      * must only have two dots in it (like "1.1.1").      */
for|for
control|(
name|cp
operator|=
name|vbranch
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s is not a numeric branch"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|vbranch
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Only branches with two dots are supported: %s"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|vhead
operator|=
name|xstrdup
argument_list|(
name|vbranch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|vhead
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
comment|/* For rationale behind calling start_server before do_editor, see 	   commit.c  */
name|start_server
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|!
name|server_active
operator|&&
endif|#
directive|endif
name|use_editor
condition|)
block|{
name|do_editor
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|message
argument_list|,
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|current_parsed_root
operator|->
name|isremote
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
endif|#
directive|endif
name|repository
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|do_verify
argument_list|(
operator|&
name|message
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|message
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|==
literal|0
operator|||
name|message
index|[
name|msglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|nm
init|=
name|xmalloc
argument_list|(
name|msglen
operator|+
literal|2
argument_list|)
decl_stmt|;
operator|*
name|nm
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nm
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nm
operator|+
name|msglen
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|message
operator|=
name|nm
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|vbranch
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|option_with_arg
argument_list|(
literal|"-b"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|message
condition|?
name|message
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword_opt
operator|!=
name|NULL
condition|)
name|option_with_arg
argument_list|(
literal|"-k"
argument_list|,
name|keyword_opt
argument_list|)
expr_stmt|;
comment|/* The only ignore processing which takes place on the server side 	   is the CVSROOT/cvsignore file.  But if the user specified -I !, 	   the documented behavior is to not process said file.  */
if|if
condition|(
name|ign_inhibit_server
condition|)
block|{
name|send_arg
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
block|}
name|wrap_send
argument_list|()
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|logfp
operator|=
name|stdin
expr_stmt|;
name|client_import_setup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|client_import_done
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vbranch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vhead
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"import\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|get_responses_and_close
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|safe_location
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"attempt to import the repository"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make all newly created directories writable.  Should really use a more      * sophisticated security mechanism here.      */
operator|(
name|void
operator|)
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|make_directories
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* Create the logfile that will be logged upon completion */
if|if
condition|(
operator|(
name|logfp
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|tmpfile
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file `%s'"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
comment|/* On systems where we can unlink an open file, do so, so it will go        away no matter how we exit.  FIXME-maybe: Should be checking for        errors but I'm not sure which error(s) we get if we are on a system        where one can't unlink open files.  */
operator|(
name|void
operator|)
name|CVS_UNLINK
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nVendor Tag:\t%s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Release Tags:\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%s\n\t\t"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Just Do It.  */
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"+importmergecmd"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"conflicts"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|" conflicts created by this import."
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|"Use the following command to help the merge:"
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot_cmdline
operator|!=
name|NULL
condition|)
block|{
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|" -d "
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
name|CVSroot_cmdline
argument_list|)
expr_stmt|;
block|}
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|" checkout -j"
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"mergetag1"
argument_list|,
literal|"<prev_rel_tag>"
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|" -j"
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"mergetag2"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"text"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"repository"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"newline"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output_tagged
argument_list|(
literal|"-importmergecmd"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: I'm not sure whether we need to put this information            into the loginfo.  If we do, then note that it does not            report any required -d option.  There is no particularly            clean way to tell the server about the -d option used by            the client.  */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n%d conflicts created by this import.\n"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Use the following command to help the merge:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\t%s checkout "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"-j%s:yesterday -j%s %s\n\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
literal|"\nNo conflicts created by this import\n\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nNo conflicts created by this import\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Write out the logfile and clean up.      */
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"- Imported sources"
argument_list|)
expr_stmt|;
name|li
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|logfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|type
operator|=
name|T_TITLE
expr_stmt|;
name|li
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vbranch
argument_list|)
expr_stmt|;
name|li
operator|->
name|rev_old
operator|=
name|li
operator|->
name|rev_new
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|li
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|logfp
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ulist
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|logfp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
comment|/* Make sure the temporary file goes away, even on systems that don't let        you delete a file that's in use.  */
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vbranch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vhead
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Process all the files in ".", then descend into other directories.    Returns 0 for success, or>0 on error (in which case a message    will have been printed).  */
end_comment

begin_function
specifier|static
name|int
name|import_descend
parameter_list|(
name|message
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
comment|/* first, load up any per-directory ignore lists */
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrap_add_file
argument_list|(
name|CVSDOTWRAPPER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory"
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|CVS_READDIR
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|one_more_time_boys
goto|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* CVS directories are created in the temp directory by 	       server.c because it doesn't special-case import.  So 	       don't print a message about them, regardless of -I!.  */
if|if
condition|(
name|server_active
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|one_more_time_boys
goto|;
endif|#
directive|endif
if|if
condition|(
name|ign_name
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|add_log
argument_list|(
literal|'I'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|one_more_time_boys
goto|;
block|}
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_DIR
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|)
operator|)
else|#
directive|else
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
name|wrap_name_has
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|)
block|{
name|Node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|dirlist
operator|==
name|NULL
condition|)
name|dirlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|dirlist
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
name|islink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|)
else|#
directive|else
name|islink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|add_log
argument_list|(
literal|'L'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
name|err
operator|+=
name|client_process_import_file
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|repository
argument_list|,
name|keyword_opt
operator|!=
name|NULL
operator|&&
name|keyword_opt
index|[
literal|0
index|]
operator|==
literal|'b'
argument_list|,
name|use_file_modtime
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|err
operator|+=
name|process_import_file
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
block|}
name|one_more_time_boys
label|:
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory"
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|head
operator|=
name|dirlist
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|err
operator|+=
name|import_descend_dir
argument_list|(
name|message
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the argument import file.  */
end_comment

begin_function
specifier|static
name|int
name|process_import_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|rcs
decl_stmt|;
name|int
name|inattic
init|=
literal|0
decl_stmt|;
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|vfile
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|attic_name
decl_stmt|;
name|attic_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|vfile
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|attic_name
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|attic_name
argument_list|)
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|char
modifier|*
name|free_opt
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|our_opt
init|=
name|keyword_opt
decl_stmt|;
name|free
argument_list|(
name|attic_name
argument_list|)
expr_stmt|;
comment|/* 	     * A new import source file; it doesn't exist as a ,v within the 	     * repository nor in the Attic -- create it anew. 	     */
name|add_log
argument_list|(
literal|'N'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The most reliable information on whether the file is binary 	       is what the client told us.  That is because if the client had 	       the wrong idea about binaryness, it corrupted the file, so 	       we might as well believe the client.  */
if|if
condition|(
name|server_active
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
comment|/* Reading all the entries for each file is fairly silly, and 		   probably slow.  But I am too lazy at the moment to do 		   anything else.  */
name|entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|findnode_fn
argument_list|(
name|entries
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|Entnode
modifier|*
name|entdata
init|=
name|node
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|entdata
operator|->
name|type
operator|==
name|ENT_FILE
condition|)
block|{
name|assert
argument_list|(
name|entdata
operator|->
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|entdata
operator|->
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
argument_list|)
expr_stmt|;
name|our_opt
operator|=
name|xstrdup
argument_list|(
name|entdata
operator|->
name|options
operator|+
literal|2
argument_list|)
expr_stmt|;
name|free_opt
operator|=
name|our_opt
expr_stmt|;
block|}
block|}
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|retval
operator|=
name|add_rcs_file
argument_list|(
name|message
argument_list|,
name|rcs
argument_list|,
name|vfile
argument_list|,
name|vhead
argument_list|,
name|our_opt
argument_list|,
name|vbranch
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|logfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|free
argument_list|(
name|attic_name
argument_list|)
expr_stmt|;
name|inattic
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
comment|/*      * an rcs file exists. have to do things the official, slow, way.      */
return|return
operator|(
name|update_rcs_file
argument_list|(
name|message
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|inattic
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The RCS file exists; update it by adding the new import file to the  * (possibly already existing) vendor branch.  */
end_comment

begin_function
specifier|static
name|int
name|update_rcs_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|inattic
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
name|int
name|inattic
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|letter
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
name|char
modifier|*
name|expand
decl_stmt|;
name|struct
name|file_info
name|finfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|finfo
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|vfile
expr_stmt|;
comment|/* Not used, so don't worry about it.  */
name|finfo
operator|.
name|update_dir
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|fullname
operator|=
name|finfo
operator|.
name|file
expr_stmt|;
name|finfo
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vbranch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|!=
name|NULL
operator|&&
operator|!
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
condition|)
block|{
name|int
name|different
decl_stmt|;
comment|/* 	 * The rcs file does have a revision on the vendor branch. Compare 	 * this revision with the import file; if they match exactly, there 	 * is no need to install the new import file as a new revision to the 	 * branch.  Just tag the revision with the new import tags. 	 *  	 * This is to try to cut down the number of "C" conflict messages for 	 * locally modified import source files. 	 */
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
comment|/* FIXME: Why don't we pass tocvsPath to RCS_cmp_file if it is            not NULL?  */
name|expand
operator|=
name|vers
operator|->
name|srcfile
operator|->
name|expand
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|srcfile
operator|->
name|expand
index|[
literal|0
index|]
operator|==
literal|'b'
condition|?
literal|"-kb"
else|:
literal|"-ko"
expr_stmt|;
name|different
operator|=
name|RCS_cmp_file
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|expand
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|different
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	     * The two files are identical.  Just update the tags, print the 	     * "U", signifying that the file has changed, but needs no 	     * attention, and we're done. 	     */
if|if
condition|(
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
name|add_log
argument_list|(
literal|'U'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
comment|/* We may have failed to parse the RCS file; check just in case */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|add_rev
argument_list|(
name|message
argument_list|,
name|vers
operator|->
name|srcfile
argument_list|,
name|vfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
operator|||
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
operator|==
name|NULL
operator|||
name|inattic
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
argument_list|,
name|vbranch
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflicts
operator|++
expr_stmt|;
name|letter
operator|=
literal|'C'
expr_stmt|;
block|}
else|else
name|letter
operator|=
literal|'U'
expr_stmt|;
name|add_log
argument_list|(
name|letter
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the revision to the vendor branch  */
end_comment

begin_function
specifier|static
name|int
name|add_rev
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vers
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vers
decl_stmt|;
block|{
name|int
name|locked
decl_stmt|,
name|status
decl_stmt|,
name|ierrno
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|!=
name|NULL
condition|)
block|{
comment|/* Before RCS_lock existed, we were directing stdout, as well as 	   stderr, from the RCS command, to DEVNULL.  I wouldn't guess that 	   was necessary, but I don't know for sure.  */
comment|/* Earlier versions of this function printed a `fork failed' error 	   when RCS_lock returned an error code.  That's not appropriate 	   now that RCS_lock is librarified, but should the error text be 	   preserved? */
if|if
condition|(
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|vbranch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|locked
operator|=
literal|1
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkin
argument_list|(
name|rcs
argument_list|,
name|tocvsPath
operator|==
name|NULL
condition|?
name|vfile
else|:
name|tocvsPath
argument_list|,
name|message
argument_list|,
name|vbranch
argument_list|,
operator|(
name|RCS_FLAGS_QUIET
operator||
name|RCS_FLAGS_KEEPFILE
operator||
operator|(
name|use_file_modtime
condition|?
name|RCS_FLAGS_MODTIME
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ierrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|(
name|tocvsPath
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
block|{
operator|(
name|void
operator|)
name|RCS_unlock
argument_list|(
name|rcs
argument_list|,
name|vbranch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the vendor branch tag and all the specified import release tags to the  * RCS file.  The vendor branch tag goes on the branch root (1.1.1) while the  * vendor release tags go on the newly added leaf of the branch (1.1.1.1,  * 1.1.1.2, ...).  */
end_comment

begin_function
specifier|static
name|int
name|add_tags
parameter_list|(
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ierrno
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|struct
name|file_info
name|finfo
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|vtag
argument_list|,
name|vbranch
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|finfo
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|vfile
expr_stmt|;
comment|/* Not used, so don't worry about it.  */
name|finfo
operator|.
name|update_dir
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|fullname
operator|=
name|finfo
operator|.
name|file
expr_stmt|;
name|finfo
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|finfo
argument_list|,
name|NULL
argument_list|,
name|vtag
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stolen from rcs/src/rcsfnms.c, and adapted/extended.  */
end_comment

begin_struct
struct|struct
name|compair
block|{
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|compair
name|comtable
index|[]
init|=
block|{
comment|/*  * comtable pairs each filename suffix with a comment leader. The comment  * leader is placed before each line generated by the $Log keyword. This  * table is used to guess the proper comment leader from the working file's  * suffix during initial ci (see InitAdmin()). Comment leaders are needed for  * languages without multiline comments; for others they are optional.  *  * I believe that the comment leader is unused if you are using RCS 5.7, which  * decides what leader to use based on the text surrounding the $Log keyword  * rather than a specified comment leader.  */
block|{
literal|"a"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"ada"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"adb"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"asm"
block|,
literal|";; "
block|}
block|,
comment|/* assembler (MS-DOS) */
block|{
literal|"ads"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"bas"
block|,
literal|"' "
block|}
block|,
comment|/* Visual Basic code */
block|{
literal|"bat"
block|,
literal|":: "
block|}
block|,
comment|/* batch (MS-DOS) */
block|{
literal|"body"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"c"
block|,
literal|" * "
block|}
block|,
comment|/* C		 */
block|{
literal|"c++"
block|,
literal|"// "
block|}
block|,
comment|/* C++ in all its infinite guises */
block|{
literal|"cc"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cpp"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"m"
block|,
literal|"// "
block|}
block|,
comment|/* Objective-C */
block|{
literal|"cl"
block|,
literal|";;; "
block|}
block|,
comment|/* Common Lisp	 */
block|{
literal|"cmd"
block|,
literal|":: "
block|}
block|,
comment|/* command (OS/2) */
block|{
literal|"cmf"
block|,
literal|"c "
block|}
block|,
comment|/* CM Fortran	 */
block|{
literal|"cs"
block|,
literal|" * "
block|}
block|,
comment|/* C*		 */
block|{
literal|"csh"
block|,
literal|"# "
block|}
block|,
comment|/* shell	 */
block|{
literal|"dlg"
block|,
literal|" * "
block|}
block|,
comment|/* MS Windows dialog file */
block|{
literal|"e"
block|,
literal|"# "
block|}
block|,
comment|/* efl		 */
block|{
literal|"epsf"
block|,
literal|"% "
block|}
block|,
comment|/* encapsulated postscript */
block|{
literal|"epsi"
block|,
literal|"% "
block|}
block|,
comment|/* encapsulated postscript */
block|{
literal|"el"
block|,
literal|"; "
block|}
block|,
comment|/* Emacs Lisp	 */
block|{
literal|"f"
block|,
literal|"c "
block|}
block|,
comment|/* Fortran	 */
block|{
literal|"for"
block|,
literal|"c "
block|}
block|,
block|{
literal|"frm"
block|,
literal|"' "
block|}
block|,
comment|/* Visual Basic form */
block|{
literal|"h"
block|,
literal|" * "
block|}
block|,
comment|/* C-header	 */
block|{
literal|"hh"
block|,
literal|"// "
block|}
block|,
comment|/* C++ header	 */
block|{
literal|"hpp"
block|,
literal|"// "
block|}
block|,
block|{
literal|"hxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"in"
block|,
literal|"# "
block|}
block|,
comment|/* for Makefile.in */
block|{
literal|"l"
block|,
literal|" * "
block|}
block|,
comment|/* lex (conflict between lex and 					 * franzlisp) */
block|{
literal|"mac"
block|,
literal|";; "
block|}
block|,
comment|/* macro (DEC-10, MS-DOS, PDP-11, 					 * VMS, etc) */
block|{
literal|"mak"
block|,
literal|"# "
block|}
block|,
comment|/* makefile, e.g. Visual C++ */
block|{
literal|"me"
block|,
literal|".\\\" "
block|}
block|,
comment|/* me-macros	t/nroff	 */
block|{
literal|"ml"
block|,
literal|"; "
block|}
block|,
comment|/* mocklisp	 */
block|{
literal|"mm"
block|,
literal|".\\\" "
block|}
block|,
comment|/* mm-macros	t/nroff	 */
block|{
literal|"ms"
block|,
literal|".\\\" "
block|}
block|,
comment|/* ms-macros	t/nroff	 */
block|{
literal|"man"
block|,
literal|".\\\" "
block|}
block|,
comment|/* man-macros	t/nroff	 */
block|{
literal|"1"
block|,
literal|".\\\" "
block|}
block|,
comment|/* feeble attempt at man pages... */
block|{
literal|"2"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"3"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"4"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"5"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"6"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"7"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"8"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"9"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"p"
block|,
literal|" * "
block|}
block|,
comment|/* pascal	 */
block|{
literal|"pas"
block|,
literal|" * "
block|}
block|,
block|{
literal|"pl"
block|,
literal|"# "
block|}
block|,
comment|/* perl	(conflict with Prolog) */
block|{
literal|"ps"
block|,
literal|"% "
block|}
block|,
comment|/* postscript	 */
block|{
literal|"psw"
block|,
literal|"% "
block|}
block|,
comment|/* postscript wrap */
block|{
literal|"pswm"
block|,
literal|"% "
block|}
block|,
comment|/* postscript wrap */
block|{
literal|"r"
block|,
literal|"# "
block|}
block|,
comment|/* ratfor	 */
block|{
literal|"rc"
block|,
literal|" * "
block|}
block|,
comment|/* Microsoft Windows resource file */
block|{
literal|"red"
block|,
literal|"% "
block|}
block|,
comment|/* psl/rlisp	 */
ifdef|#
directive|ifdef
name|sparc
block|{
literal|"s"
block|,
literal|"! "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
block|{
literal|"s"
block|,
literal|"| "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
block|{
literal|"s"
block|,
literal|"/ "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
block|{
literal|"s"
block|,
literal|"# "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ksr__
block|{
literal|"s"
block|,
literal|"# "
block|}
block|,
comment|/* assembler	 */
block|{
literal|"S"
block|,
literal|"# "
block|}
block|,
comment|/* Macro assembler */
endif|#
directive|endif
block|{
literal|"sh"
block|,
literal|"# "
block|}
block|,
comment|/* shell	 */
block|{
literal|"sl"
block|,
literal|"% "
block|}
block|,
comment|/* psl		 */
block|{
literal|"spec"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"tex"
block|,
literal|"% "
block|}
block|,
comment|/* tex		 */
block|{
literal|"y"
block|,
literal|" * "
block|}
block|,
comment|/* yacc		 */
block|{
literal|"ye"
block|,
literal|" * "
block|}
block|,
comment|/* yacc-efl	 */
block|{
literal|"yr"
block|,
literal|" * "
block|}
block|,
comment|/* yacc-ratfor	 */
block|{
literal|""
block|,
literal|"# "
block|}
block|,
comment|/* default for empty suffix	 */
block|{
name|NULL
block|,
literal|"# "
block|}
comment|/* default for unknown suffix;	 */
comment|/* must always be last		 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_comment
parameter_list|(
name|user
parameter_list|)
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|suffix_path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|suffix_path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|user
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Convert to lower-case, since we are not concerned about the 	 * case-ness of the suffix. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|suffix_path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|suffix_path
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|suffix_path
expr_stmt|;
block|}
else|else
name|suffix
operator|=
literal|""
expr_stmt|;
comment|/* will use the default */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
operator|==
name|NULL
condition|)
block|{
comment|/* Default.  Note we'll always hit this case before we 	       ever return NULL.  */
name|retval
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|suffix_path
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Create a new RCS file from scratch.     This probably should be moved to rcs.c now that it is called from    places outside import.c.     Return value is 0 for success, or nonzero for failure (in which    case an error message will have already been printed).  */
end_comment

begin_function
name|int
name|add_rcs_file
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|user
parameter_list|,
name|add_vhead
parameter_list|,
name|key_opt
parameter_list|,
name|add_vbranch
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|desctext
parameter_list|,
name|desclen
parameter_list|,
name|add_logfp
parameter_list|)
comment|/* Log message for the addition.  Not used if add_vhead == NULL.  */
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
comment|/* Filename of the RCS file to create.  */
specifier|const
name|char
modifier|*
name|rcs
decl_stmt|;
comment|/* Filename of the file to serve as the contents of the initial        revision.  Even if add_vhead is NULL, we use this to determine        the modes to give the new RCS file.  */
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
comment|/* Revision number of head that we are adding.  Normally 1.1 but        could be another revision as long as ADD_VBRANCH is a branch        from it.  If NULL, then just add an empty file without any        revisions (similar to the one created by "rcs -i").  */
specifier|const
name|char
modifier|*
name|add_vhead
decl_stmt|;
comment|/* Keyword expansion mode, e.g., "b" for binary.  NULL means the        default behavior.  */
specifier|const
name|char
modifier|*
name|key_opt
decl_stmt|;
comment|/* Vendor branch to import to, or NULL if none.  If non-NULL, then        vtag should also be non-NULL.  */
specifier|const
name|char
modifier|*
name|add_vbranch
decl_stmt|;
specifier|const
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
comment|/* If non-NULL, description for the file.  If NULL, the description        will be empty.  */
specifier|const
name|char
modifier|*
name|desctext
decl_stmt|;
name|size_t
name|desclen
decl_stmt|;
comment|/* Write errors to here as well as via error (), or NULL if we should        use only error ().  */
name|FILE
modifier|*
name|add_logfp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fprcs
decl_stmt|,
modifier|*
name|fpuser
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|altdate1
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|char
modifier|*
name|author
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ierrno
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
specifier|const
name|char
modifier|*
name|userfile
decl_stmt|;
name|char
modifier|*
name|free_opt
init|=
name|NULL
decl_stmt|;
name|mode_t
name|file_type
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Note that as the code stands now, the -k option overrides any        settings in wrappers (whether CVSROOT/cvswrappers, -W, or        whatever).  Some have suggested this should be the other way        around.  As far as I know the documentation doesn't say one way        or the other.  Before making a change of this sort, should think        about what is best, document it (in cvs.texinfo and NEWS),&c.  */
if|if
condition|(
name|key_opt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|wrap_name_has
argument_list|(
name|user
argument_list|,
name|WRAP_RCSOPTION
argument_list|)
condition|)
block|{
name|key_opt
operator|=
name|free_opt
operator|=
name|wrap_rcsoption
argument_list|(
name|user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|userfile
operator|=
operator|(
name|tocvsPath
operator|==
name|NULL
condition|?
name|user
else|:
name|tocvsPath
operator|)
expr_stmt|;
comment|/* Opening in text mode is probably never the right thing for the        server (because the protocol encodes text files in a fashion        which does not depend on what the client or server OS is, as        documented in cvsclient.texi), but as long as the server just        runs on unix it is a moot point.  */
comment|/* If PreservePermissions is set, then make sure that the file        is a plain file before trying to open it.  Longstanding (although        often unpopular) CVS behavior has been to follow symlinks, so we        maintain that behavior if PreservePermissions is not on.         NOTE: this error message used to be `cannot fstat', but is now        `cannot lstat'.  I don't see a way around this, since we must        stat the file before opening it. -twp */
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|userfile
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* not fatal, continue import */
if|if
condition|(
name|add_logfp
operator|!=
name|NULL
condition|)
name|fperrmsg
argument_list|(
name|add_logfp
argument_list|,
literal|0
argument_list|,
name|errno
argument_list|,
literal|"ERROR: cannot lstat file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot lstat file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
goto|goto
name|read_error
goto|;
block|}
name|file_type
operator|=
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
expr_stmt|;
name|fpuser
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|preserve_perms
operator|||
name|file_type
operator|==
name|S_IFREG
condition|)
block|{
name|fpuser
operator|=
name|CVS_FOPEN
argument_list|(
name|userfile
argument_list|,
operator|(
operator|(
name|key_opt
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key_opt
argument_list|,
literal|"b"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|"rb"
else|:
literal|"r"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpuser
operator|==
name|NULL
condition|)
block|{
comment|/* not fatal, continue import */
if|if
condition|(
name|add_logfp
operator|!=
name|NULL
condition|)
name|fperrmsg
argument_list|(
name|add_logfp
argument_list|,
literal|0
argument_list|,
name|errno
argument_list|,
literal|"ERROR: cannot read file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"ERROR: cannot read file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
goto|goto
name|read_error
goto|;
block|}
block|}
name|fprcs
operator|=
name|CVS_FOPEN
argument_list|(
name|rcs
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprcs
operator|==
name|NULL
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|write_error_noclose
goto|;
block|}
comment|/*      * putadmin()      */
if|if
condition|(
name|add_vhead
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"head     %s;\012"
argument_list|,
name|add_vhead
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"head     ;\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branch   %s;\012"
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"access   ;\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"symbols  "
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
for|for
control|(
name|i
operator|=
name|targc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* RCS writes the symbols backwards */
name|assert
argument_list|(
name|add_vbranch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s.1 "
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s"
argument_list|,
name|vtag
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|";\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"locks    ; strict;\012"
argument_list|)
operator|<
literal|0
operator|||
comment|/* XXX - make sure @@ processing works in the RCS file */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"comment  @%s@;\012"
argument_list|,
name|get_comment
argument_list|(
name|user
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|key_opt
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|key_opt
argument_list|,
literal|"kv"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"expand   @%s@;\012"
argument_list|,
name|key_opt
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
comment|/* Write the revision(s), with the date and author and so on        (that is "delta" rather than "deltatext" from rcsfile(5)).  */
if|if
condition|(
name|add_vhead
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|use_file_modtime
condition|)
name|now
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|altdate1
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s\012"
argument_list|,
name|add_vhead
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\012"
argument_list|,
name|altdate1
argument_list|,
name|author
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|" %s.1"
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|";\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* Store initial permissions if necessary. */
if|if
condition|(
name|preserve_perms
condition|)
block|{
if|if
condition|(
name|file_type
operator|==
name|S_IFLNK
condition|)
block|{
name|char
modifier|*
name|link
init|=
name|xreadlink
argument_list|(
name|userfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"symlink\t@"
argument_list|)
operator|<
literal|0
operator|||
name|expand_at_signs
argument_list|(
name|link
argument_list|,
name|strlen
argument_list|(
name|link
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@;\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"owner\t%u;\012"
argument_list|,
name|sb
operator|.
name|st_uid
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"group\t%u;\012"
argument_list|,
name|sb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"permissions\t%o;\012"
argument_list|,
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
switch|switch
condition|(
name|file_type
condition|)
block|{
case|case
name|S_IFREG
case|:
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
ifdef|#
directive|ifdef
name|HAVE_STRUCT_STAT_ST_RDEV
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"special\t%s %lu;\012"
argument_list|,
operator|(
name|file_type
operator|==
name|S_IFCHR
condition|?
literal|"character"
else|:
literal|"block"
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_rdev
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
else|#
directive|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't import %s: unable to import device files on this system"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't import %s: unknown kind of special file"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s.1\012"
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\012"
argument_list|,
name|altdate1
argument_list|,
name|author
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches ;\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* Store initial permissions if necessary. */
if|if
condition|(
name|preserve_perms
condition|)
block|{
if|if
condition|(
name|file_type
operator|==
name|S_IFLNK
condition|)
block|{
name|char
modifier|*
name|link
init|=
name|xreadlink
argument_list|(
name|userfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"symlink\t@"
argument_list|)
operator|<
literal|0
operator|||
name|expand_at_signs
argument_list|(
name|link
argument_list|,
name|strlen
argument_list|(
name|link
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@;\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"owner\t%u;\012"
argument_list|,
name|sb
operator|.
name|st_uid
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"group\t%u;\012"
argument_list|,
name|sb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"permissions\t%o;\012"
argument_list|,
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
switch|switch
condition|(
name|file_type
condition|)
block|{
case|case
name|S_IFREG
case|:
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
ifdef|#
directive|ifdef
name|HAVE_STRUCT_STAT_ST_RDEV
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"special\t%s %lu;\012"
argument_list|,
operator|(
name|file_type
operator|==
name|S_IFCHR
condition|?
literal|"character"
else|:
literal|"block"
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_rdev
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
else|#
directive|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't import %s: unable to import device files on this system"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot import %s: special file of unknown type"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
block|}
comment|/* Now write the description (possibly empty).  */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012desc\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|desctext
operator|!=
name|NULL
condition|)
block|{
comment|/* The use of off_t not size_t for the second argument is very 	   strange, since we are dealing with something which definitely 	   fits in memory.  */
if|if
condition|(
name|expand_at_signs
argument_list|(
name|desctext
argument_list|,
operator|(
name|off_t
operator|)
name|desclen
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012\012\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
comment|/* Now write the log messages and contents for the revision(s) (that        is, "deltatext" rather than "delta" from rcsfile(5)).  */
if|if
condition|(
name|add_vhead
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s\012"
argument_list|,
name|add_vhead
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\012@"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
comment|/* We are going to put the log message in the revision on the 	       branch.  So putting it here too seems kind of redundant, I 	       guess (and that is what CVS has always done, anyway).  */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"Initial revision\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
else|else
block|{
if|if
condition|(
name|expand_at_signs
argument_list|(
name|message
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|message
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"text\012@"
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
comment|/* Now copy over the contents of the file, expanding at signs. 	   If preserve_perms is set, do this only for regular files. */
if|if
condition|(
operator|!
name|preserve_perms
operator|||
name|file_type
operator|==
name|S_IFREG
condition|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fpuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fpuser
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|user
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|expand_at_signs
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|add_vbranch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s.1\012"
argument_list|,
name|add_vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\012@"
argument_list|)
operator|<
literal|0
operator|||
name|expand_at_signs
argument_list|(
name|message
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|message
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012text\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@@\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fprcs
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|write_error_noclose
goto|;
block|}
comment|/* Close fpuser only if we opened it to begin with. */
if|if
condition|(
name|fpuser
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fpuser
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|/*      * Fix the modes on the RCS files.  The user modes of the original      * user file are propagated to the group and other modes as allowed      * by the repository umask, except that all write permissions are      * turned off.      */
name|mode
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRWXU
operator|)
operator|>>
literal|3
operator||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRWXU
operator|)
operator|>>
literal|6
operator|)
operator|&
operator|~
name|cvsumask
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|rcs
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|add_logfp
operator|!=
name|NULL
condition|)
name|fperrmsg
argument_list|(
name|add_logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
name|write_error
label|:
name|ierrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fprcs
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|write_error_noclose
label|:
if|if
condition|(
name|fclose
argument_list|(
name|fpuser
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_logfp
operator|!=
name|NULL
condition|)
name|fperrmsg
argument_list|(
name|add_logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ierrno
operator|==
name|ENOSPC
condition|)
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|rcs
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_logfp
operator|!=
name|NULL
condition|)
name|fperrmsg
argument_list|(
name|add_logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
block|}
name|read_error
label|:
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_opt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write SIZE bytes at BUF to FP, expanding @ signs into double @  * signs.  If an error occurs, return a negative value and set errno  * to indicate the error.  If not, return a nonnegative value.  */
end_comment

begin_function
name|int
name|expand_at_signs
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'@'
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
operator|++
name|next
operator|-
name|cp
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
operator|!=
name|len
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
name|cp
operator|=
name|next
expr_stmt|;
name|size
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|fp
argument_list|)
operator|!=
name|size
condition|)
return|return
name|EOF
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Write an update message to (potentially) the screen and the log file.  */
end_comment

begin_function
specifier|static
name|void
name|add_log
parameter_list|(
name|ch
parameter_list|,
name|fname
parameter_list|)
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
comment|/* write to terminal */
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_len
condition|)
block|{
name|cvs_output
argument_list|(
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cvs_output
argument_list|(
name|repository
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repos_len
condition|)
comment|/* write to logfile */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s\n"
argument_list|,
name|ch
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the recursive function that walks the argument directory looking  * for sub-directories that have CVS administration files in them and updates  * them recursively.  *   * Note that we do not follow symbolic links here, which is a feature!  */
end_comment

begin_function
specifier|static
name|int
name|import_descend_dir
parameter_list|(
name|message
parameter_list|,
name|dir
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ierrno
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|rcs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|islink
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
block|{
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: cannot get working directory"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Concatenate DIR to the end of REPOSITORY.  */
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|new
init|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|new
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|new
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
name|new
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|current_parsed_root
operator|->
name|isremote
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|quiet
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Importing %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|current_parsed_root
operator|->
name|isremote
operator|&&
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s%s"
argument_list|,
name|repository
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|repository
argument_list|)
operator|||
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|noexec
operator|==
literal|0
operator|&&
name|CVS_MKDIR
argument_list|(
name|repository
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperrmsg
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|rcs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repository
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|repository
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

