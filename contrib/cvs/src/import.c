begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * "import" checks in the vendor release located in the current directory into  * the CVS source repository.  The CVS vendor branch support is utilized.  *   * At least three arguments are expected to follow the options:  *	repository	Where the source belongs relative to the CVSROOT  *	VendorTag	Vendor's major tag  *	VendorReleTag	Tag for this particular release  *  * Additional arguments specify more Vendor Release Tags.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_define
define|#
directive|define
name|FILE_HOLDER
value|".#cvsxxx"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_comment
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_rcs_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|user
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_at_signs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|off_t
name|size
operator|,
name|FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_rev
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_tags
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_import_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_rcs_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|,
name|int
name|inattic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_log
name|PROTO
argument_list|(
operator|(
name|int
name|ch
operator|,
name|char
operator|*
name|fname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|repos_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vhead
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vbranch
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_file_modtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|import_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-d] [-k subst] [-I ign] [-m msg] [-b branch]\n"
block|,
literal|"    [-W spec] repository vendor-tag release-tags...\n"
block|,
literal|"\t-d\tUse the file's modification time as the time of import.\n"
block|,
literal|"\t-k sub\tSet default RCS keyword substitution mode.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
literal|"\t-b bra\tVendor branch id.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-W spec\tWrappers specification line.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|import
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|char
name|tmpfile
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|msglen
decl_stmt|,
name|err
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vbranch
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Qqdb:m:I:k:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|use_file_modtime
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vbranch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* RCS_check_kflag returns strings of the form -kxx.  We 		   only use it for validation, so we can free the value 		   as soon as it is returned. */
name|free
argument_list|(
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|keyword_opt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|wrap_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
comment|/* check the tags for validity */
name|RCS_check_tag
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* XXX - this should be a module, not just a pathname */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|CVSroot
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing CVSROOT environment variable\n"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set it or specify the '-d' option to %s."
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repos_len
operator|=
name|strlen
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repos_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Consistency checks on the specified vendor branch.  It must be      * composed of only numbers and dots ('.').  Also, for now we only      * support branching to a single level, so the specified vendor branch      * must only have two dots in it (like "1.1.1").      */
for|for
control|(
name|cp
operator|=
name|vbranch
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s is not a numeric branch"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|vbranch
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Only branches with two dots are supported: %s"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vhead
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|vhead
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
comment|/* Do this now; don't ask for a log message if we can't talk to the 	   server.  But if there is a syntax error in the options, give 	   an error message without connecting.  */
name|start_server
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|use_editor
condition|)
block|{
name|do_editor
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|message
argument_list|,
name|repository
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|msglen
operator|=
name|message
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|==
literal|0
operator|||
name|message
index|[
name|msglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|nm
init|=
name|xmalloc
argument_list|(
name|msglen
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nm
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nm
operator|+
name|msglen
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|message
operator|=
name|nm
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|use_file_modtime
condition|)
name|send_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbranch
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|option_with_arg
argument_list|(
literal|"-b"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword_opt
operator|!=
name|NULL
condition|)
name|option_with_arg
argument_list|(
literal|"-k"
argument_list|,
name|keyword_opt
argument_list|)
expr_stmt|;
comment|/* The only ignore processing which takes place on the server side 	   is the CVSROOT/cvsignore file.  But if the user specified -I !, 	   the documented behavior is to not process said file.  */
if|if
condition|(
name|ign_inhibit_server
condition|)
block|{
name|send_arg
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|logfp
operator|=
name|stdin
expr_stmt|;
name|client_import_setup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
name|client_import_done
argument_list|()
expr_stmt|;
name|send_to_server
argument_list|(
literal|"import\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|get_responses_and_close
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
endif|#
directive|endif
comment|/*      * Make all newly created directories writable.  Should really use a more      * sophisticated security mechanism here.      */
operator|(
name|void
operator|)
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|make_directories
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* Create the logfile that will be logged upon completion */
if|if
condition|(
operator|(
name|logfp
operator|=
name|fopen
argument_list|(
name|tmpnam
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file `%s'"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
comment|/* to be sure it goes away */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nVendor Tag:\t%s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Release Tags:\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%s\n\t\t"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Just Do It.  */
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n%d conflicts created by this import.\n"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"Use the following command to help the merge:\n\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" checkout -j"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|":yesterday -j"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n%d conflicts created by this import.\n"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Use the following command to help the merge:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\t%s checkout -j%s:yesterday -j%s %s\n\n"
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
literal|"\nNo conflicts created by this import\n\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nNo conflicts created by this import\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Write out the logfile and clean up.      */
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"- Imported sources"
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|T_TITLE
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|vbranch
argument_list|,
name|logfp
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ulist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logfp
argument_list|)
expr_stmt|;
comment|/* Make sure the temporary file goes away, even on systems that don't let        you delete a file that's in use.  */
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process all the files in ".", then descend into other directories.  */
end_comment

begin_function
specifier|static
name|int
name|import_descend
parameter_list|(
name|message
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
comment|/* first, load up any per-directory ignore lists */
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrap_add_file
argument_list|(
name|CVSDOTWRAPPER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* CVS directories are created in the temp directory by 	       server.c because it doesn't special-case import.  So 	       don't print a message about them, regardless of -I!.  */
if|if
condition|(
name|server_active
operator|&&
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|ign_name
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|add_log
argument_list|(
literal|'I'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_DIR
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|)
operator|)
else|#
directive|else
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
name|wrap_name_has
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|)
block|{
name|Node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|dirlist
operator|==
name|NULL
condition|)
name|dirlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|dirlist
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|DT_DIR
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
operator|||
name|dp
operator|->
name|d_type
operator|==
name|DT_UNKNOWN
operator|&&
endif|#
directive|endif
name|islink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|add_log
argument_list|(
literal|'L'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
name|err
operator|+=
name|client_process_import_file
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|err
operator|+=
name|process_import_file
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|head
operator|=
name|dirlist
operator|->
name|list
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|err
operator|+=
name|import_descend_dir
argument_list|(
name|message
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the argument import file.  */
end_comment

begin_function
specifier|static
name|int
name|process_import_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|char
name|attic_name
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|inattic
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|attic_name
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|attic_name
argument_list|)
condition|)
block|{
comment|/* 	     * A new import source file; it doesn't exist as a ,v within the 	     * repository nor in the Attic -- create it anew. 	     */
name|add_log
argument_list|(
literal|'N'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_rcs_file
argument_list|(
name|message
argument_list|,
name|rcs
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
operator|)
return|;
block|}
name|inattic
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * an rcs file exists. have to do things the official, slow, way.      */
return|return
operator|(
name|update_rcs_file
argument_list|(
name|message
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|inattic
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The RCS file exists; update it by adding the new import file to the  * (possibly already existing) vendor branch.  */
end_comment

begin_function
specifier|static
name|int
name|update_rcs_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|inattic
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
name|int
name|inattic
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|letter
decl_stmt|;
name|int
name|ierrno
decl_stmt|;
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vbranch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|!=
name|NULL
operator|&&
operator|!
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
condition|)
block|{
name|char
name|xtmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|different
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpdir
operator|==
name|NULL
operator|||
name|tmpdir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|tmpdir
operator|=
literal|"/tmp"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xtmpfile
argument_list|,
literal|"%s/cvs-imp%ld"
argument_list|,
name|tmpdir
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * The rcs file does have a revision on the vendor branch. Compare 	 * this revision with the import file; if they match exactly, there 	 * is no need to install the new import file as a new revision to the 	 * branch.  Just tag the revision with the new import tags. 	 *  	 * This is to try to cut down the number of "C" conflict messages for 	 * locally modified import source files. 	 */
comment|/* Why is RCS_FLAGS_FORCE here?  I wouldn't think that it would have any 	   effect in conjunction with passing NULL for workfile (i.e. to stdout).  */
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_RCS5
literal|"-ko"
argument_list|,
else|#
directive|else
name|NULL
argument_list|,
endif|#
directive|endif
name|xtmpfile
argument_list|,
name|RCS_FLAGS_FORCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: cannot co revision %s of file %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: cannot co revision %s of file %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|xtmpfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
name|different
operator|=
name|xcmp
argument_list|(
name|xtmpfile
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|xtmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|different
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	     * The two files are identical.  Just update the tags, print the 	     * "U", signifying that the file has changed, but needs no 	     * attention, and we're done. 	     */
if|if
condition|(
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
name|add_log
argument_list|(
literal|'U'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
comment|/* We may have failed to parse the RCS file; check just in case */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|add_rev
argument_list|(
name|message
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
operator|||
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
operator|==
name|NULL
operator|||
name|inattic
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
argument_list|,
name|vbranch
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflicts
operator|++
expr_stmt|;
name|letter
operator|=
literal|'C'
expr_stmt|;
block|}
else|else
name|letter
operator|=
literal|'U'
expr_stmt|;
name|add_log
argument_list|(
name|letter
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the revision to the vendor branch  */
end_comment

begin_function
specifier|static
name|int
name|add_rev
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vers
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vers
decl_stmt|;
block|{
name|int
name|locked
decl_stmt|,
name|status
decl_stmt|,
name|ierrno
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|!=
name|NULL
condition|)
block|{
comment|/* Before RCS_lock existed, we were directing stdout, as well as 	   stderr, from the RCS command, to DEVNULL.  I wouldn't guess that 	   was necessary, but I don't know for sure.  */
if|if
condition|(
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|vbranch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|vfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocvsPath
operator|==
name|NULL
condition|)
block|{
comment|/* We play with hard links rather than passing -u to ci to avoid 	   expanding RCS keywords (see test 106.5 in sanity.sh).  */
if|if
condition|(
name|link_file
argument_list|(
name|vfile
argument_list|,
name|FILE_HOLDER
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|FILE_HOLDER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|link_file
argument_list|(
name|vfile
argument_list|,
name|FILE_HOLDER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot create link to %s"
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot create link to %s"
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|status
operator|=
name|RCS_checkin
argument_list|(
name|rcs
argument_list|,
name|tocvsPath
operator|==
name|NULL
condition|?
name|vfile
else|:
name|tocvsPath
argument_list|,
name|message
argument_list|,
name|vbranch
argument_list|,
operator|(
name|RCS_FLAGS_QUIET
operator||
operator|(
name|use_file_modtime
condition|?
name|RCS_FLAGS_MODTIME
else|:
literal|0
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ierrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tocvsPath
operator|==
name|NULL
condition|)
name|rename_file
argument_list|(
name|FILE_HOLDER
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
block|{
operator|(
name|void
operator|)
name|RCS_unlock
argument_list|(
name|rcs
argument_list|,
name|vbranch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the vendor branch tag and all the specified import release tags to the  * RCS file.  The vendor branch tag goes on the branch root (1.1.1) while the  * vendor release tags go on the newly added leaf of the branch (1.1.1.1,  * 1.1.1.2, ...).  */
end_comment

begin_function
specifier|static
name|int
name|add_tags
parameter_list|(
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ierrno
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|vtag
argument_list|,
name|vbranch
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vers
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stolen from rcs/src/rcsfnms.c, and adapted/extended.  */
end_comment

begin_struct
struct|struct
name|compair
block|{
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|compair
name|comtable
index|[]
init|=
block|{
comment|/*  * comtable pairs each filename suffix with a comment leader. The comment  * leader is placed before each line generated by the $Log keyword. This  * table is used to guess the proper comment leader from the working file's  * suffix during initial ci (see InitAdmin()). Comment leaders are needed for  * languages without multiline comments; for others they are optional.  */
block|{
literal|"a"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"ada"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"adb"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"asm"
block|,
literal|";; "
block|}
block|,
comment|/* assembler (MS-DOS) */
block|{
literal|"ads"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"bas"
block|,
literal|"' "
block|}
block|,
comment|/* Visual Basic code */
block|{
literal|"bat"
block|,
literal|":: "
block|}
block|,
comment|/* batch (MS-DOS) */
block|{
literal|"body"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"c"
block|,
literal|" * "
block|}
block|,
comment|/* C		 */
block|{
literal|"c++"
block|,
literal|"// "
block|}
block|,
comment|/* C++ in all its infinite guises */
block|{
literal|"cc"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cpp"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"m"
block|,
literal|"// "
block|}
block|,
comment|/* Objective-C */
block|{
literal|"cl"
block|,
literal|";;; "
block|}
block|,
comment|/* Common Lisp	 */
block|{
literal|"cmd"
block|,
literal|":: "
block|}
block|,
comment|/* command (OS/2) */
block|{
literal|"cmf"
block|,
literal|"c "
block|}
block|,
comment|/* CM Fortran	 */
block|{
literal|"cs"
block|,
literal|" * "
block|}
block|,
comment|/* C*		 */
block|{
literal|"csh"
block|,
literal|"# "
block|}
block|,
comment|/* shell	 */
block|{
literal|"dlg"
block|,
literal|" * "
block|}
block|,
comment|/* MS Windows dialog file */
block|{
literal|"e"
block|,
literal|"# "
block|}
block|,
comment|/* efl		 */
block|{
literal|"epsf"
block|,
literal|"% "
block|}
block|,
comment|/* encapsulated postscript */
block|{
literal|"epsi"
block|,
literal|"% "
block|}
block|,
comment|/* encapsulated postscript */
block|{
literal|"el"
block|,
literal|"; "
block|}
block|,
comment|/* Emacs Lisp	 */
block|{
literal|"f"
block|,
literal|"c "
block|}
block|,
comment|/* Fortran	 */
block|{
literal|"for"
block|,
literal|"c "
block|}
block|,
block|{
literal|"frm"
block|,
literal|"' "
block|}
block|,
comment|/* Visual Basic form */
block|{
literal|"h"
block|,
literal|" * "
block|}
block|,
comment|/* C-header	 */
block|{
literal|"hh"
block|,
literal|"// "
block|}
block|,
comment|/* C++ header	 */
block|{
literal|"hpp"
block|,
literal|"// "
block|}
block|,
block|{
literal|"hxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"in"
block|,
literal|"# "
block|}
block|,
comment|/* for Makefile.in */
block|{
literal|"l"
block|,
literal|" * "
block|}
block|,
comment|/* lex (conflict between lex and 					 * franzlisp) */
block|{
literal|"mac"
block|,
literal|";; "
block|}
block|,
comment|/* macro (DEC-10, MS-DOS, PDP-11, 					 * VMS, etc) */
block|{
literal|"mak"
block|,
literal|"# "
block|}
block|,
comment|/* makefile, e.g. Visual C++ */
block|{
literal|"me"
block|,
literal|".\\\" "
block|}
block|,
comment|/* me-macros	t/nroff	 */
block|{
literal|"ml"
block|,
literal|"; "
block|}
block|,
comment|/* mocklisp	 */
block|{
literal|"mm"
block|,
literal|".\\\" "
block|}
block|,
comment|/* mm-macros	t/nroff	 */
block|{
literal|"ms"
block|,
literal|".\\\" "
block|}
block|,
comment|/* ms-macros	t/nroff	 */
block|{
literal|"man"
block|,
literal|".\\\" "
block|}
block|,
comment|/* man-macros	t/nroff	 */
block|{
literal|"1"
block|,
literal|".\\\" "
block|}
block|,
comment|/* feeble attempt at man pages... */
block|{
literal|"2"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"3"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"4"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"5"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"6"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"7"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"8"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"9"
block|,
literal|".\\\" "
block|}
block|,
block|{
literal|"p"
block|,
literal|" * "
block|}
block|,
comment|/* pascal	 */
block|{
literal|"pas"
block|,
literal|" * "
block|}
block|,
block|{
literal|"pl"
block|,
literal|"# "
block|}
block|,
comment|/* perl	(conflict with Prolog) */
block|{
literal|"ps"
block|,
literal|"% "
block|}
block|,
comment|/* postscript	 */
block|{
literal|"psw"
block|,
literal|"% "
block|}
block|,
comment|/* postscript wrap */
block|{
literal|"pswm"
block|,
literal|"% "
block|}
block|,
comment|/* postscript wrap */
block|{
literal|"r"
block|,
literal|"# "
block|}
block|,
comment|/* ratfor	 */
block|{
literal|"rc"
block|,
literal|" * "
block|}
block|,
comment|/* Microsoft Windows resource file */
block|{
literal|"red"
block|,
literal|"% "
block|}
block|,
comment|/* psl/rlisp	 */
ifdef|#
directive|ifdef
name|sparc
block|{
literal|"s"
block|,
literal|"! "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
block|{
literal|"s"
block|,
literal|"| "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
block|{
literal|"s"
block|,
literal|"/ "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
block|{
literal|"s"
block|,
literal|"# "
block|}
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ksr__
block|{
literal|"s"
block|,
literal|"# "
block|}
block|,
comment|/* assembler	 */
block|{
literal|"S"
block|,
literal|"# "
block|}
block|,
comment|/* Macro assembler */
endif|#
directive|endif
block|{
literal|"sh"
block|,
literal|"# "
block|}
block|,
comment|/* shell	 */
block|{
literal|"sl"
block|,
literal|"% "
block|}
block|,
comment|/* psl		 */
block|{
literal|"spec"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada		 */
block|{
literal|"tex"
block|,
literal|"% "
block|}
block|,
comment|/* tex		 */
block|{
literal|"y"
block|,
literal|" * "
block|}
block|,
comment|/* yacc		 */
block|{
literal|"ye"
block|,
literal|" * "
block|}
block|,
comment|/* yacc-efl	 */
block|{
literal|"yr"
block|,
literal|" * "
block|}
block|,
comment|/* yacc-ratfor	 */
block|{
literal|""
block|,
literal|"# "
block|}
block|,
comment|/* default for empty suffix	 */
block|{
name|NULL
block|,
literal|"# "
block|}
comment|/* default for unknown suffix;	 */
comment|/* must always be last		 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_comment
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
name|suffix_path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|user
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Convert to lower-case, since we are not concerned about the 	 * case-ness of the suffix. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|suffix_path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|suffix_path
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|suffix_path
expr_stmt|;
block|}
else|else
name|suffix
operator|=
literal|""
expr_stmt|;
comment|/* will use the default */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
operator|==
name|NULL
condition|)
comment|/* default */
return|return
operator|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_rcs_file
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|user
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fprcs
decl_stmt|,
modifier|*
name|fpuser
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|altdate1
index|[
literal|50
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
name|char
name|altdate2
index|[
literal|50
index|]
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|author
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ierrno
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|char
modifier|*
name|tocvsPath
decl_stmt|;
name|char
modifier|*
name|userfile
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FIXME?  We always import files as text files (note that means        that files get stored with straight linefeeds).  There isn't an        obvious, clean, way to let people specify which files are binary.        Maybe based on the file name....  */
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|userfile
operator|=
operator|(
name|tocvsPath
operator|==
name|NULL
condition|?
name|user
else|:
name|tocvsPath
operator|)
expr_stmt|;
name|fpuser
operator|=
name|fopen
argument_list|(
name|userfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpuser
operator|==
name|NULL
condition|)
block|{
comment|/* not fatal, continue import */
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|errno
argument_list|,
literal|"ERROR: cannot read file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"ERROR: cannot read file %s"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
goto|goto
name|read_error
goto|;
block|}
name|fprcs
operator|=
name|fopen
argument_list|(
name|rcs
argument_list|,
literal|"w+b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprcs
operator|==
name|NULL
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|write_error_noclose
goto|;
block|}
comment|/*      * putadmin()      */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"head     %s;\012"
argument_list|,
name|vhead
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branch   %s;\012"
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"access   ;\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"symbols  "
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
for|for
control|(
name|i
operator|=
name|targc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* RCS writes the symbols backwards */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s.1 "
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s;\012"
argument_list|,
name|vtag
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"locks    ; strict;\012"
argument_list|)
operator|<
literal|0
operator|||
comment|/* XXX - make sure @@ processing works in the RCS file */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"comment  @%s@;\012"
argument_list|,
name|get_comment
argument_list|(
name|user
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|keyword_opt
operator|!=
name|NULL
condition|)
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"expand   @%s@;\012"
argument_list|,
name|keyword_opt
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012"
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
comment|/*      * puttree()      */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fpuser
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_file_modtime
condition|)
name|now
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|altdate1
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
define|#
directive|define
name|altdate2
value|altdate1
else|#
directive|else
comment|/*      * If you don't have RCS V5 or later, you need to lie about the ci      * time, since RCS V4 and earlier insist that the times differ.      */
name|now
operator|++
expr_stmt|;
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|altdate2
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s\012"
argument_list|,
name|vhead
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\012"
argument_list|,
name|altdate1
argument_list|,
name|author
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches %s.1;\012"
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s.1\012"
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\012"
argument_list|,
name|altdate2
argument_list|,
name|author
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches ;\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\012\012"
argument_list|)
operator|<
literal|0
operator|||
comment|/* 	 * putdesc() 	 */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012desc\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@@\012\012\012"
argument_list|)
operator|<
literal|0
operator|||
comment|/* 	 * putdelta() 	 */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s\012"
argument_list|,
name|vhead
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@Initial revision\012@\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"text\012@"
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
comment|/* Now copy over the contents of the file, expanding at signs.  */
block|{
name|unsigned
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|len
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fpuser
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fpuser
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|user
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|expand_at_signs
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|write_error
goto|;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\012%s.1\012"
argument_list|,
name|vbranch
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\012@"
argument_list|)
operator|<
literal|0
operator|||
name|expand_at_signs
argument_list|(
name|message
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|message
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\012text\012"
argument_list|)
operator|<
literal|0
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@@\012"
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fprcs
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|write_error_noclose
goto|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpuser
argument_list|)
expr_stmt|;
comment|/*      * Fix the modes on the RCS files.  The user modes of the original      * user file are propagated to the group and other modes as allowed      * by the repository umask, except that all write permissions are      * turned off.      */
name|mode
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRWXU
operator|)
operator|>>
literal|3
operator||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRWXU
operator|)
operator|>>
literal|6
operator|)
operator|&
operator|~
name|cvsumask
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|rcs
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
name|write_error
label|:
name|ierrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fprcs
argument_list|)
expr_stmt|;
name|write_error_noclose
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpuser
argument_list|)
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ierrno
operator|==
name|ENOSPC
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
block|}
name|read_error
label|:
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write SIZE bytes at BUF to FP, expanding @ signs into double @  * signs.  If an error occurs, return a negative value and set errno  * to indicate the error.  If not, return a nonnegative value.  */
end_comment

begin_function
specifier|static
name|int
name|expand_at_signs
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|,
name|end
operator|=
name|buf
operator|+
name|size
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|&&
name|errno
operator|!=
literal|0
condition|)
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
operator|&&
name|errno
operator|!=
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write an update message to (potentially) the screen and the log file.  */
end_comment

begin_function
specifier|static
name|void
name|add_log
parameter_list|(
name|ch
parameter_list|,
name|fname
parameter_list|)
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
comment|/* write to terminal */
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_len
condition|)
block|{
name|cvs_output
argument_list|(
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cvs_output
argument_list|(
name|repository
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repos_len
condition|)
comment|/* write to logfile */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s\n"
argument_list|,
name|ch
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the recursive function that walks the argument directory looking  * for sub-directories that have CVS administration files in them and updates  * them recursively.  *   * Note that we do not follow symbolic links here, which is a feature!  */
end_comment

begin_function
specifier|static
name|int
name|import_descend_dir
parameter_list|(
name|message
parameter_list|,
name|dir
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ierrno
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|islink
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: cannot get working directory"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|client_active
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|quiet
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Importing %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|client_active
operator|&&
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s%s"
argument_list|,
name|repository
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|repository
argument_list|)
operator|||
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|noexec
operator|==
literal|0
operator|&&
name|CVS_MKDIR
argument_list|(
name|repository
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repository
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|repository
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

