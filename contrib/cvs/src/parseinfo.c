begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/*  * Parse the INFOFILE file for the specified REPOSITORY.  Invoke CALLPROC for  * the first line in the file that matches the REPOSITORY, or if ALL != 0, any lines  * matching "ALL", or if no lines match, the last line matching "DEFAULT".  *  * Return 0 for success, -1 if there was not an INFOFILE, and>0 for failure.  */
end_comment

begin_function
name|int
name|Parse_Info
parameter_list|(
name|infofile
parameter_list|,
name|repository
parameter_list|,
name|callproc
parameter_list|,
name|all
parameter_list|)
name|char
modifier|*
name|infofile
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|CALLPROC
name|callproc
decl_stmt|;
name|int
name|all
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp_info
decl_stmt|;
name|char
modifier|*
name|infopath
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|default_value
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|expanded_value
init|=
name|NULL
decl_stmt|;
name|int
name|callback_done
decl_stmt|,
name|line_number
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|exp
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|srepos
decl_stmt|;
specifier|const
name|char
modifier|*
name|regex_err
decl_stmt|;
if|if
condition|(
name|CVSroot_original
operator|==
name|NULL
condition|)
block|{
comment|/* XXX - should be error maybe? */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT variable not set"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* find the info file and open it */
name|infopath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|infofile
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|infopath
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|infofile
argument_list|)
expr_stmt|;
name|fp_info
operator|=
name|CVS_FOPEN
argument_list|(
name|infopath
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_info
operator|==
name|NULL
condition|)
block|{
comment|/* If no file, don't do anything special.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* strip off the CVSROOT if repository was absolute */
name|srepos
operator|=
name|Short_Repository
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -> ParseInfo(%s, %s, %s)\n"
argument_list|,
name|infopath
argument_list|,
name|srepos
argument_list|,
name|all
condition|?
literal|"ALL"
else|:
literal|"not ALL"
argument_list|)
expr_stmt|;
comment|/* search the info file for lines that match */
name|callback_done
operator|=
name|line_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp_info
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|line_number
operator|++
expr_stmt|;
comment|/* skip lines starting with # */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip whitespace at beginning of line */
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
comment|/* if *cp is null, the whole line was blank */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* the regular expression is everything up to the first space */
for|for
control|(
name|exp
operator|=
name|cp
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip whitespace up to the start of the matching value */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* no value to match with the regular expression is an error */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"syntax error at line %d file %s; ignored"
argument_list|,
name|line_number
argument_list|,
name|infofile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|value
operator|=
name|cp
expr_stmt|;
comment|/* strip the newline off the end of the value */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|value
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|expanded_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|expanded_value
argument_list|)
expr_stmt|;
name|expanded_value
operator|=
name|expand_path
argument_list|(
name|value
argument_list|,
name|infofile
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expanded_value
condition|)
block|{
continue|continue;
block|}
comment|/* 	 * At this point, exp points to the regular expression, and value 	 * points to the value to call the callback routine with.  Evaluate 	 * the regular expression against srepos and callback with the value 	 * if it matches. 	 */
comment|/* save the default value so we have it later if we need it */
if|if
condition|(
name|strcmp
argument_list|(
name|exp
argument_list|,
literal|"DEFAULT"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Is it OK to silently ignore all but the last DEFAULT                expression?  */
if|if
condition|(
name|default_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|default_value
argument_list|)
expr_stmt|;
name|default_value
operator|=
name|xstrdup
argument_list|(
name|expanded_value
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * For a regular expression of "ALL", do the callback always We may 	 * execute lots of ALL callbacks in addition to *one* regular matching 	 * callback or default 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|exp
argument_list|,
literal|"ALL"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|all
condition|)
name|err
operator|+=
name|callproc
argument_list|(
name|repository
argument_list|,
name|expanded_value
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Keyword `ALL' is ignored at line %d in %s file"
argument_list|,
name|line_number
argument_list|,
name|infofile
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|callback_done
condition|)
comment|/* only first matching, plus "ALL"'s */
continue|continue;
comment|/* see if the repository matched this regular expression */
if|if
condition|(
operator|(
name|regex_err
operator|=
name|re_comp
argument_list|(
name|exp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad regular expression at line %d file %s: %s"
argument_list|,
name|line_number
argument_list|,
name|infofile
argument_list|,
name|regex_err
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|re_exec
argument_list|(
name|srepos
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* no match */
comment|/* it did, so do the callback and note that we did one */
name|err
operator|+=
name|callproc
argument_list|(
name|repository
argument_list|,
name|expanded_value
argument_list|)
expr_stmt|;
name|callback_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp_info
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp_info
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
comment|/* if we fell through and didn't callback at all, do the default */
if|if
condition|(
name|callback_done
operator|==
literal|0
operator|&&
name|default_value
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|callproc
argument_list|(
name|repository
argument_list|,
name|default_value
argument_list|)
expr_stmt|;
comment|/* free up space if necessary */
if|if
condition|(
name|default_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|default_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|expanded_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the CVS config file.  The syntax right now is a bit ad hoc    but tries to draw on the best or more common features of the other    *info files and various unix (or non-unix) config file syntaxes.    Lines starting with # are comments.  Settings are lines of the form    KEYWORD=VALUE.  There is currently no way to have a multi-line    VALUE (would be nice if there was, probably).     CVSROOT is the $CVSROOT directory (CVSroot_directory might not be    set yet).     Returns 0 for success, negative value for failure.  Call    error(0, ...) on errors in addition to the return value.  */
end_comment

begin_function
name|int
name|parse_config
parameter_list|(
name|cvsroot
parameter_list|)
name|char
modifier|*
name|cvsroot
decl_stmt|;
block|{
name|char
modifier|*
name|infopath
decl_stmt|;
name|FILE
modifier|*
name|fp_info
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* FIXME-reentrancy: If we do a multi-threaded server, this would need        to go to the per-connection data structures.  */
specifier|static
name|int
name|parsed
init|=
literal|0
decl_stmt|;
comment|/* Authentication code and serve_root might both want to call us.        Let this happen smoothly.  */
if|if
condition|(
name|parsed
condition|)
return|return
literal|0
return|;
name|parsed
operator|=
literal|1
expr_stmt|;
name|infopath
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cvsroot
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_CONFIG
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|infopath
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"out of memory; cannot allocate infopath"
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|cvsroot
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|CVSROOTADM_CONFIG
argument_list|)
expr_stmt|;
name|fp_info
operator|=
name|CVS_FOPEN
argument_list|(
name|infopath
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_info
operator|==
name|NULL
condition|)
block|{
comment|/* If no file, don't do anything special.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Just a warning message; doesn't affect return 	       value, currently at least.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp_info
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Skip comments.  */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* At least for the moment we don't skip whitespace at the start 	   of the line.  Too picky?  Maybe.  But being insufficiently 	   picky leads to all sorts of confusion, and it is a lot easier 	   to start out picky and relax it than the other way around.  	   Is there any kind of written standard for the syntax of this 	   sort of config file?  Anywhere in POSIX for example (I guess 	   makefiles are sort of close)?  Red Hat Linux has a bunch of 	   these too (with some GUI tools which edit them)...  	   Along the same lines, we might want a table of keywords, 	   with various types (boolean, string,&c), as a mechanism 	   for making sure the syntax is consistent.  Any good examples 	   to follow there (Apache?)?  */
comment|/* Strip the training newline.  There will be one unless we 	   read a partial line without a newline, and then got end of 	   file (or error?).  */
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|line
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip blank lines.  */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* The first '=' separates keyword from value.  */
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Probably should be printing line number.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"syntax error in %s: line '%s' is missing '='"
argument_list|,
name|infopath
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"RCSBIN"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This option used to specify the directory for RCS 	       executables.  But since we don't run them any more, 	       this is a noop.  Silently ignore it so that a 	       repository can work with either new or old CVS.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"SystemAuth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|system_auth
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* Still parse the syntax but ignore the 		   option.  That way the same config file can 		   be used for local and server.  */
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|system_auth
operator|=
literal|1
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unrecognized value '%s' for SystemAuth"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"PreservePermissions"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
name|preserve_perms
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
name|preserve_perms
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: this CVS does not support PreservePermissions"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unrecognized value '%s' for PreservePermissions"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
else|else
block|{
comment|/* We may be dealing with a keyword which was added in a 	       subsequent version of CVS.  In that case it is a good idea 	       to complain, as (1) the keyword might enable a behavior like 	       alternate locking behavior, in which it is dangerous and hard 	       to detect if some CVS's have it one way and others have it 	       the other way, (2) in general, having us not do what the user 	       had in mind when they put in the keyword violates the 	       principle of least surprise.  Note that one corollary is 	       adding new keywords to your CVSROOT/config file is not 	       particularly recommended unless you are planning on using 	       the new features.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unrecognized keyword '%s'"
argument_list|,
name|infopath
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp_info
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp_info
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
name|infopath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

