begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * General recursion handler  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|do_dir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_file_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addlist
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unroll_files_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addfile
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local static versions eliminates the need for globals  */
end_comment

begin_decl_stmt
specifier|static
name|FILEPROC
name|fileproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIRENTPROC
name|direntproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dosrcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|update_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of files on which to operate */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of directories on which to operate */
end_comment

begin_struct
struct|struct
name|recursion_frame
block|{
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Called to start a recursive command.  *  * Command line arguments dictate the directories and files on which  * we operate.  In the special case of no arguments, we default to  * ".".  *  * The general algorithm is as follows.  */
end_comment

begin_function
name|int
name|start_recursion
parameter_list|(
name|fileproc
parameter_list|,
name|filesdoneproc
parameter_list|,
name|direntproc
parameter_list|,
name|dirleaveproc
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|readlock
parameter_list|,
name|update_preload
parameter_list|,
name|dosrcs
parameter_list|,
name|wd_is_repos
parameter_list|)
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|char
modifier|*
name|update_preload
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
name|int
name|wd_is_repos
decl_stmt|;
comment|/* Set if caller has already cd'd to the repository */
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|List
modifier|*
name|files_by_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|recursion_frame
name|frame
decl_stmt|;
name|expand_wild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_preload
operator|==
name|NULL
condition|)
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|update_preload
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|flags
operator|=
name|R_SKIP_DIRS
expr_stmt|;
else|else
name|flags
operator|=
name|R_PROCESS
expr_stmt|;
comment|/* clean up from any previous calls to start_recursion */
if|if
condition|(
name|repository
condition|)
block|{
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
comment|/* FIXME-krp: no longer correct. */
comment|/* FIXME-krp: clean up files_by_dir */
if|if
condition|(
name|dirlist
condition|)
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* 	 * There were no arguments, so we'll probably just recurse. The 	 * exception to the rule is when we are called from a directory 	 * without any CVS administration files.  That has always meant to 	 * process each of the sub-directories, so we pretend like we were 	 * called with the list of sub-dirs of the current dir as args 	 */
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|dirlist
operator|=
name|Find_Directories
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|flags
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*      * There were arguments, so we have to handle them by hand. To do      * that, we set up the filelist and dirlist with the arguments and      * call do_recursion.  do_recursion recognizes the fact that the      * lists are non-null when it starts and doesn't update them.      *      * explicitly named directories are stored in dirlist.      * explicitly named files are stored in filelist.      * other possibility is named entities whicha are not currently in      * the working directory.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* if this argument is a directory, then add it to the list of 	   directories. */
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise, split argument into directory and component names. */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|comp
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|file_to_try
decl_stmt|;
comment|/* Now break out argv[i] into directory part (DIR) and file part (COMP). 		   DIR and COMP will each point to a newly malloc'd string.  */
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|comp
operator|=
name|last_component
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|dir
condition|)
block|{
comment|/* no dir component.  What we have is an implied "./" */
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|comp
decl_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comp
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if this argument exists as a file in the current 	       working directory tree, then add it to the files list.  */
if|if
condition|(
name|wd_is_repos
condition|)
block|{
comment|/* If doing rtag, we've done a chdir to the repository. */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|file_to_try
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|file_to_try
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file_to_try
argument_list|)
condition|)
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
comment|/* otherwise, look for it in the repository. */
name|char
modifier|*
name|save_update_dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
comment|/* save& set (aka push) update_dir */
name|save_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* look for it in the repository. */
name|repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|comp
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|update_dir
argument_list|,
literal|"%s"
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_update_dir
argument_list|)
expr_stmt|;
block|}
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such directory `%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point we have looped over all named arguments and built        a coupla lists.  Now we unroll the lists, setting up and        calling do_recursion. */
name|frame
operator|.
name|fileproc
operator|=
name|fileproc
expr_stmt|;
name|frame
operator|.
name|filesdoneproc
operator|=
name|filesdoneproc
expr_stmt|;
name|frame
operator|.
name|direntproc
operator|=
name|direntproc
expr_stmt|;
name|frame
operator|.
name|dirleaveproc
operator|=
name|dirleaveproc
expr_stmt|;
name|frame
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|frame
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|frame
operator|.
name|aflag
operator|=
name|aflag
expr_stmt|;
name|frame
operator|.
name|readlock
operator|=
name|readlock
expr_stmt|;
name|frame
operator|.
name|dosrcs
operator|=
name|dosrcs
expr_stmt|;
name|err
operator|+=
name|walklist
argument_list|(
name|files_by_dir
argument_list|,
name|unroll_files_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* then do_recursion on the dirlist. */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
operator|.
name|fileproc
argument_list|,
name|frame
operator|.
name|filesdoneproc
argument_list|,
name|frame
operator|.
name|direntproc
argument_list|,
name|frame
operator|.
name|dirleaveproc
argument_list|,
name|frame
operator|.
name|flags
argument_list|,
name|frame
operator|.
name|which
argument_list|,
name|frame
operator|.
name|aflag
argument_list|,
name|frame
operator|.
name|readlock
argument_list|,
name|frame
operator|.
name|dosrcs
argument_list|)
expr_stmt|;
comment|/* Free the data which expand_wild allocated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the recursive policies on the local directory.  This may be  * called directly, or may be called by start_recursion  */
end_comment

begin_function
name|int
name|do_recursion
parameter_list|(
name|xfileproc
parameter_list|,
name|xfilesdoneproc
parameter_list|,
name|xdirentproc
parameter_list|,
name|xdirleaveproc
parameter_list|,
name|xflags
parameter_list|,
name|xwhich
parameter_list|,
name|xaflag
parameter_list|,
name|xreadlock
parameter_list|,
name|xdosrcs
parameter_list|)
name|FILEPROC
name|xfileproc
decl_stmt|;
name|FILESDONEPROC
name|xfilesdoneproc
decl_stmt|;
name|DIRENTPROC
name|xdirentproc
decl_stmt|;
name|DIRLEAVEPROC
name|xdirleaveproc
decl_stmt|;
name|Dtype
name|xflags
decl_stmt|;
name|int
name|xwhich
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xreadlock
decl_stmt|;
name|int
name|xdosrcs
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dodoneproc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|List
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
comment|/* do nothing if told */
if|if
condition|(
name|xflags
operator|==
name|R_SKIP_ALL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* set up the static vars */
name|fileproc
operator|=
name|xfileproc
expr_stmt|;
name|filesdoneproc
operator|=
name|xfilesdoneproc
expr_stmt|;
name|direntproc
operator|=
name|xdirentproc
expr_stmt|;
name|dirleaveproc
operator|=
name|xdirleaveproc
expr_stmt|;
name|flags
operator|=
name|xflags
expr_stmt|;
name|which
operator|=
name|xwhich
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|readlock
operator|=
name|noexec
condition|?
literal|0
else|:
name|xreadlock
expr_stmt|;
name|dosrcs
operator|=
name|xdosrcs
expr_stmt|;
comment|/* The fact that locks are not active here is what makes us fail to have        the             If someone commits some changes in one cvs command, 	   then an update by someone else will either get all the 	   changes, or none of them.         property (see node Concurrency in cvs.texinfo).         The most straightforward fix would just to readlock the whole        tree before starting an update, but that means that if a commit        gets blocked on a big update, it might need to wait a *long*        time.         A more adequate fix would be a two-pass design for update,        checkout, etc.  The first pass would go through the repository,        with the whole tree readlocked, noting what versions of each        file we want to get.  The second pass would release all locks        (except perhaps short-term locks on one file at a        time--although I think RCS already deals with this) and        actually get the files, specifying the particular versions it wants.         This could be sped up by separating out the data needed for the        first pass into a separate file(s)--for example a file        attribute for each file whose value contains the head revision        for each branch.  The structure should be designed so that        commit can relatively quickly update the information for a        single file or a handful of files (file attributes, as        implemented in Jan 96, are probably acceptable; improvements        would be possible such as branch attributes which are in        separate files for each branch).  */
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_FLOWCONTROL
argument_list|)
comment|/*      * Now would be a good time to check to see if we need to stop      * generating data, to give the buffers a chance to drain to the      * remote client.  We should not have locks active at this point.      */
if|if
condition|(
name|server_active
comment|/* If there are writelocks around, we cannot pause here.  */
operator|&&
operator|(
name|readlock
operator|||
name|noexec
operator|)
condition|)
name|server_pause_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Fill in repository with the current repository      */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|repository
operator|=
name|xmalloc
argument_list|(
name|PATH_MAX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getwd
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
name|srepository
operator|=
name|repository
expr_stmt|;
comment|/* remember what to free */
name|fileattr_startdir
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/*      * The filesdoneproc needs to be called for each directory where files      * processed, or each directory that is processed by a call where no      * directories were passed in.  In fact, the only time we don't want to      * call back the filesdoneproc is when we are processing directories that      * were passed in on the command line (or in the special case of `.' when      * we were called with no args      */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
operator|&&
name|filelist
operator|==
name|NULL
condition|)
name|dodoneproc
operator|=
literal|0
expr_stmt|;
comment|/*      * If filelist or dirlist is already set, we don't look again. Otherwise,      * find the files and directories      */
if|if
condition|(
name|filelist
operator|==
name|NULL
operator|&&
name|dirlist
operator|==
name|NULL
condition|)
block|{
comment|/* both lists were NULL, so start from scratch */
if|if
condition|(
name|fileproc
operator|!=
name|NULL
operator|&&
name|flags
operator|!=
name|R_SKIP_FILES
condition|)
block|{
name|int
name|lwhich
init|=
name|which
decl_stmt|;
comment|/* be sure to look in the attic if we have sticky tags/date */
if|if
condition|(
operator|(
name|lwhich
operator|&
name|W_ATTIC
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|isreadable
argument_list|(
name|CVSADM_TAG
argument_list|)
condition|)
name|lwhich
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* find the files and fill in entries if appropriate */
name|filelist
operator|=
name|Find_Names
argument_list|(
name|repository
argument_list|,
name|lwhich
argument_list|,
name|aflag
argument_list|,
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* find sub-directories if we will recurse */
if|if
condition|(
name|flags
operator|!=
name|R_SKIP_DIRS
condition|)
name|dirlist
operator|=
name|Find_Directories
argument_list|(
name|repository
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something was passed on the command line */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|fileproc
operator|!=
name|NULL
condition|)
block|{
comment|/* we will process files, so pre-parse entries */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
name|entries
operator|=
name|Entries_Open
argument_list|(
name|aflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the files (if any) */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|fileproc
condition|)
block|{
name|struct
name|file_info
name|finfo_struct
decl_stmt|;
comment|/* read lock it if necessary */
if|if
condition|(
name|readlock
operator|&&
name|repository
operator|&&
name|Reader_Lock
argument_list|(
name|repository
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"read lock failed - giving up"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* For the server, we handle notifications in a completely different 	   place (server_notify).  For local, we can't do them here--we don't 	   have writelocks in place, and there is no way to get writelocks 	   here.  */
if|if
condition|(
name|client_active
condition|)
name|notify_check
argument_list|(
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|finfo_struct
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo_struct
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|finfo_struct
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
comment|/* do_file_proc will fill in finfo_struct.file.  */
comment|/* process the files */
name|err
operator|+=
name|walklist
argument_list|(
name|filelist
argument_list|,
name|do_file_proc
argument_list|,
operator|&
name|finfo_struct
argument_list|)
expr_stmt|;
comment|/* unlock it */
if|if
condition|(
name|readlock
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up */
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entries
condition|)
block|{
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* call-back files done proc (if any) */
if|if
condition|(
name|dodoneproc
operator|&&
name|filesdoneproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|filesdoneproc
argument_list|(
name|err
argument_list|,
name|repository
argument_list|,
name|update_dir
index|[
literal|0
index|]
condition|?
name|update_dir
else|:
literal|"."
argument_list|)
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
comment|/* process the directories (if necessary) */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|do_dir_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
elseif|else
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|dirleaveproc
argument_list|(
literal|"."
argument_list|,
name|err
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
comment|/* free the saved copy of the pointer if necessary */
if|if
condition|(
name|srepository
condition|)
block|{
name|free
argument_list|(
name|srepository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the files in the list with the callback proc  */
end_comment

begin_function
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|file_info
modifier|*
name|finfo
init|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|finfo
operator|->
name|file
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|finfo
operator|->
name|fullname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|fullname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosrcs
operator|&&
name|repository
condition|)
name|finfo
operator|->
name|rcs
operator|=
name|RCS_parse
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
name|finfo
operator|->
name|rcs
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
name|ret
operator|=
name|fileproc
argument_list|(
name|finfo
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the directories in the list (recursing as we go)  */
end_comment

begin_function
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
name|p
operator|->
name|key
decl_stmt|;
name|char
name|newrepos
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|List
modifier|*
name|sdirlist
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Dtype
name|dir_return
init|=
name|R_PROCESS
decl_stmt|;
name|int
name|stripped_dot
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* set up update_dir - skip dots if not at start */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* 	 * Here we need a plausible repository name for the sub-directory. We 	 * create one by concatenating the new directory name onto the 	 * previous repository name.  The only case where the name should be 	 * used is in the case where we are creating a new sub-directory for 	 * update -d and in that case the generated name will be correct. 	 */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newrepos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* call-back dir entry proc (if any) */
if|if
condition|(
name|direntproc
operator|!=
name|NULL
condition|)
name|dir_return
operator|=
name|direntproc
argument_list|(
name|dir
argument_list|,
name|newrepos
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* only process the dir if the return code was 0 */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
comment|/* save our current directory and static vars */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|sdirlist
operator|=
name|dirlist
expr_stmt|;
name|srepository
operator|=
name|repository
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
comment|/* cd to the sub-directory */
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* honor the global SKIP_DIRS (a.k.a. local) */
if|if
condition|(
name|flags
operator|==
name|R_SKIP_DIRS
condition|)
name|dir_return
operator|=
name|R_SKIP_DIRS
expr_stmt|;
comment|/* remember if the `.' will be stripped for subsequent dirs */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stripped_dot
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make the recursive call */
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|dir_return
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
comment|/* put the `.' back if necessary */
if|if
condition|(
name|stripped_dot
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* call-back dir leave proc (if any) */
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|dirleaveproc
argument_list|(
name|dir
argument_list|,
name|err
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get back to where we started and restore state vars */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|dirlist
operator|=
name|sdirlist
expr_stmt|;
name|repository
operator|=
name|srepository
expr_stmt|;
block|}
comment|/* put back update_dir */
name|cp
operator|=
name|last_component
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|update_dir
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a list allocating the list if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|addlist
parameter_list|(
name|listp
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
operator|*
name|listp
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
operator|*
name|listp
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfile
parameter_list|(
name|listp
parameter_list|,
name|dir
parameter_list|,
name|file
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
comment|/* add this dir. */
name|addlist
argument_list|(
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
operator|*
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can't find recently added dir node `%s' in start_recursion."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|addlist
argument_list|(
operator|(
name|List
operator|*
operator|*
operator|)
operator|&
name|n
operator|->
name|data
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|unroll_files_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
operator|(
expr|struct
name|recursion_frame
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|save_dirlist
decl_stmt|;
name|char
modifier|*
name|save_update_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* if this dir was also an explicitly named argument, then skip        it.  We'll catch it later when we do dirs. */
name|n
operator|=
name|findnode
argument_list|(
name|dirlist
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* otherwise, call dorecusion for this list of files. */
name|filelist
operator|=
operator|(
name|List
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|save_dirlist
operator|=
name|dirlist
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|save_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
operator|->
name|fileproc
argument_list|,
name|frame
operator|->
name|filesdoneproc
argument_list|,
name|frame
operator|->
name|direntproc
argument_list|,
name|frame
operator|->
name|dirleaveproc
argument_list|,
name|frame
operator|->
name|flags
argument_list|,
name|frame
operator|->
name|which
argument_list|,
name|frame
operator|->
name|aflag
argument_list|,
name|frame
operator|->
name|readlock
argument_list|,
name|frame
operator|->
name|dosrcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_update_dir
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
name|dirlist
operator|=
name|save_dirlist
expr_stmt|;
name|filelist
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

