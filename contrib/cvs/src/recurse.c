begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * General recursion handler  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|do_dir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_file_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addlist
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unroll_files_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addfile
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|update_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of files on which to operate */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of directories on which to operate */
end_comment

begin_struct
struct|struct
name|recursion_frame
block|{
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|do_recursion
name|PROTO
argument_list|(
operator|(
expr|struct
name|recursion_frame
operator|*
name|frame
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I am half tempted to shove a struct file_info * into the struct    recursion_frame (but then we would need to modify or create a    recursion_frame for each file), or shove a struct recursion_frame *    into the struct file_info (more tempting, although it isn't completely    clear that the struct file_info should contain info about recursion    processor internals).  So instead use this struct.  */
end_comment

begin_struct
struct|struct
name|frame_and_file
block|{
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Similarly, we need to pass the entries list to do_dir_proc.  */
end_comment

begin_struct
struct|struct
name|frame_and_entries
block|{
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Start a recursive command.     Command line arguments (ARGC, ARGV) dictate the directories and    files on which we operate.  In the special case of no arguments, we    default to ".".  */
end_comment

begin_function
name|int
name|start_recursion
parameter_list|(
name|fileproc
parameter_list|,
name|filesdoneproc
parameter_list|,
name|direntproc
parameter_list|,
name|dirleaveproc
parameter_list|,
name|callerdat
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|readlock
parameter_list|,
name|update_preload
parameter_list|,
name|dosrcs
parameter_list|)
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
comment|/* This specifies the kind of recursion.  There are several cases:         1.  W_LOCAL is not set but W_REPOS or W_ATTIC is.  The current        directory when we are called must be the repository and        recursion proceeds according to what exists in the repository.         2a.  W_LOCAL is set but W_REPOS and W_ATTIC are not.  The        current directory when we are called must be the working        directory.  Recursion proceeds according to what exists in the        working directory, never (I think) consulting any part of the        repository which does not correspond to the working directory        ("correspond" == Name_Repository).         2b.  W_LOCAL is set and so is W_REPOS or W_ATTIC.  This is the        weird one.  The current directory when we are called must be        the working directory.  We recurse through working directories,        but we recurse into a directory if it is exists in the working        directory *or* it exists in the repository.  If a directory        does not exist in the working directory, the direntproc must        either tell us to skip it (R_SKIP_ALL), or must create it (I        think those are the only two cases).  */
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|char
modifier|*
name|update_preload
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|List
modifier|*
name|args_to_send_when_finished
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|List
modifier|*
name|files_by_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|recursion_frame
name|frame
decl_stmt|;
name|frame
operator|.
name|fileproc
operator|=
name|fileproc
expr_stmt|;
name|frame
operator|.
name|filesdoneproc
operator|=
name|filesdoneproc
expr_stmt|;
name|frame
operator|.
name|direntproc
operator|=
name|direntproc
expr_stmt|;
name|frame
operator|.
name|dirleaveproc
operator|=
name|dirleaveproc
expr_stmt|;
name|frame
operator|.
name|callerdat
operator|=
name|callerdat
expr_stmt|;
name|frame
operator|.
name|flags
operator|=
name|local
condition|?
name|R_SKIP_DIRS
else|:
name|R_PROCESS
expr_stmt|;
name|frame
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|frame
operator|.
name|aflag
operator|=
name|aflag
expr_stmt|;
name|frame
operator|.
name|readlock
operator|=
name|readlock
expr_stmt|;
name|frame
operator|.
name|dosrcs
operator|=
name|dosrcs
expr_stmt|;
name|expand_wild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_preload
operator|==
name|NULL
condition|)
name|update_dir
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|update_dir
operator|=
name|xstrdup
argument_list|(
name|update_preload
argument_list|)
expr_stmt|;
comment|/* clean up from any previous calls to start_recursion */
if|if
condition|(
name|repository
condition|)
block|{
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
comment|/* FIXME-krp: no longer correct. */
if|if
condition|(
name|dirlist
condition|)
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|server_pathname_check
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|int
name|just_subdirs
init|=
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|just_subdirs
operator|&&
name|CVSroot_cmdline
operator|==
name|NULL
operator|&&
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
name|char
modifier|*
name|root
init|=
name|Name_Root
argument_list|(
name|NULL
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|&&
name|strcmp
argument_list|(
name|root
argument_list|,
name|current_parsed_root
operator|->
name|original
argument_list|)
operator|!=
literal|0
condition|)
comment|/* We're skipping this directory because it is for 		   a different root.  Therefore, we just want to 		   do the subdirectories only.  Processing files would 		   cause a working directory from one repository to be 		   processed against a different repository, which could 		   cause all kinds of spurious conflicts and such.  		   Question: what about the case of "cvs update foo" 		   where we process foo/bar and not foo itself?  That 		   seems to be handled somewhere (else) but why should 		   it be a separate case?  Needs investigation...  */
name|just_subdirs
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * There were no arguments, so we'll probably just recurse. The 	 * exception to the rule is when we are called from a directory 	 * without any CVS administration files.  That has always meant to 	 * process each of the sub-directories, so we pretend like we were 	 * called with the list of sub-dirs of the current dir as args 	 */
if|if
condition|(
name|just_subdirs
condition|)
block|{
name|dirlist
operator|=
name|Find_Directories
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If there are no sub-directories, there is a certain logic in 	       favor of doing nothing, but in fact probably the user is just 	       confused about what directory they are in, or whether they 	       cvs add'd a new directory.  In the case of at least one 	       sub-directory, at least when we recurse into them we 	       notice (hopefully) whether they are under CVS control.  */
if|if
condition|(
name|list_isempty
argument_list|(
name|dirlist
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory .:"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"there is no version here; run '%s checkout' first"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
elseif|else
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
operator|&&
name|server_started
condition|)
block|{
comment|/* In the the case "cvs update foo bar baz", a call to 		   send_file_names in update.c will have sent the 		   appropriate "Argument" commands to the server.  In 		   this case, that won't have happened, so we need to 		   do it here.  While this example uses "update", this 		   generalizes to other commands.  */
comment|/* This is the same call to Find_Directories as above.                    FIXME: perhaps it would be better to write a                    function that duplicates a list. */
name|args_to_send_when_finished
operator|=
name|Find_Directories
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
goto|goto
name|do_the_work
goto|;
block|}
comment|/*      * There were arguments, so we have to handle them by hand. To do      * that, we set up the filelist and dirlist with the arguments and      * call do_recursion.  do_recursion recognizes the fact that the      * lists are non-null when it starts and doesn't update them.      *      * explicitly named directories are stored in dirlist.      * explicitly named files are stored in filelist.      * other possibility is named entities whicha are not currently in      * the working directory.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* if this argument is a directory, then add it to the list of 	   directories. */
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise, split argument into directory and component names. */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|comp
decl_stmt|;
name|char
modifier|*
name|file_to_try
decl_stmt|;
comment|/* Now break out argv[i] into directory part (DIR) and file part (COMP). 		   DIR and COMP will each point to a newly malloc'd string.  */
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|comp
operator|=
name|last_component
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|dir
condition|)
block|{
comment|/* no dir component.  What we have is an implied "./" */
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|comp
decl_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comp
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if this argument exists as a file in the current 	       working directory tree, then add it to the files list.  */
if|if
condition|(
operator|!
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
condition|)
block|{
comment|/* If doing rtag, we've done a chdir to the repository. */
name|file_to_try
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|file_to_try
argument_list|,
literal|"%s%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
else|else
name|file_to_try
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file_to_try
argument_list|)
condition|)
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
name|isdir
argument_list|(
name|CVSADM
argument_list|)
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
name|current_parsed_root
operator|->
name|isremote
endif|#
directive|endif
condition|)
block|{
comment|/* otherwise, look for it in the repository. */
name|char
modifier|*
name|tmp_update_dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|reposfile
decl_stmt|;
name|tmp_update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp_update_dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tmp_update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmp_update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmp_update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* look for it in the repository. */
name|repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|tmp_update_dir
argument_list|)
expr_stmt|;
name|reposfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|comp
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|reposfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|comp
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|reposfile
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposfile
argument_list|)
expr_stmt|;
block|}
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such directory `%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_to_try
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point we have looped over all named arguments and built        a coupla lists.  Now we unroll the lists, setting up and        calling do_recursion. */
name|err
operator|+=
name|walklist
argument_list|(
name|files_by_dir
argument_list|,
name|unroll_files_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|files_by_dir
argument_list|)
expr_stmt|;
comment|/* then do_recursion on the dirlist. */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
block|{
name|do_the_work
label|:
name|err
operator|+=
name|do_recursion
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
block|}
comment|/* Free the data which expand_wild allocated.  */
name|free_names
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|args_to_send_when_finished
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME (njc): in the multiroot case, we don't want to send 	   argument commands for those top-level directories which do 	   not contain any subdirectories which have files checked out 	   from current_parsed_root->original.  If we do, and two repositories 	   have a module with the same name, nasty things could happen.  	   This is hard.  Perhaps we should send the Argument commands 	   later in this procedure, after we've had a chance to notice 	   which directores we're using (after do_recursion has been 	   called once).  This means a _lot_ of rewriting, however.  	   What we need to do for that to happen is descend the tree 	   and construct a list of directories which are checked out 	   from current_cvsroot.  Now, we eliminate from the list all 	   of those directories which are immediate subdirectories of 	   another directory in the list.  To say that the opposite 	   way, we keep the directories which are not immediate 	   subdirectories of any other in the list.  Here's a picture:  			      a 			     / \ 			    B   C 			   / \ 			  D   e 			     / \ 			    F   G 			       / \ 			      H   I  	   The node in capitals are those directories which are 	   checked out from current_cvsroot.  We want the list to 	   contain B, C, F, and G.  D, H, and I are not included, 	   because their parents are also checked out from 	   current_cvsroot.  	   The algorithm should be: 		    	   1) construct a tree of all directory names where each 	   element contains a directory name and a flag which notes if 	   that directory is checked out from current_cvsroot  			      a0 			     / \ 			    B1  C1 			   / \ 			  D1  e0 			     / \ 			    F1  G1 			       / \ 			      H1  I1  	   2) Recursively descend the tree.  For each node, recurse 	   before processing the node.  If the flag is zero, do 	   nothing.  If the flag is 1, check the node's parent.  If 	   the parent's flag is one, change the current entry's flag 	   to zero.  			      a0 			     / \ 			    B1  C1 			   / \ 			  D0  e0 			     / \ 			    F1  G1 			       / \ 			      H0  I0  	   3) Walk the tree and spit out "Argument" commands to tell 	   the server which directories to munge. 		    	   Yuck.  It's not clear this is worth spending time on, since 	   we might want to disable cvs commands entirely from 	   directories that do not have CVSADM files...  	   Anyways, the solution as it stands has modified server.c 	   (dirswitch) to create admin files [via server.c 	   (create_adm_p)] in all path elements for a client's 	   "Directory xxx" command, which forces the server to descend 	   and serve the files there.  client.c (send_file_names) has 	   also been modified to send only those arguments which are 	   appropriate to current_parsed_root->original.  	*/
comment|/* Construct a fake argc/argv pair. */
name|int
name|our_argc
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|our_argv
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|list_isempty
argument_list|(
name|args_to_send_when_finished
argument_list|)
condition|)
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|head
operator|=
name|args_to_send_when_finished
operator|->
name|list
expr_stmt|;
comment|/* count the number of nodes */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|i
operator|++
expr_stmt|;
name|our_argc
operator|=
name|i
expr_stmt|;
comment|/* create the argument vector */
name|our_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|our_argc
argument_list|)
expr_stmt|;
comment|/* populate it */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|head
operator|->
name|next
init|;
name|p
operator|!=
name|head
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|our_argv
index|[
name|i
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* We don't want to expand widcards, since we've just created 	   a list of directories directly from the filesystem. */
name|send_file_names
argument_list|(
name|our_argc
argument_list|,
name|our_argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free our argc/argv. */
if|if
condition|(
name|our_argv
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|our_argc
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|our_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|our_argv
argument_list|)
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|args_to_send_when_finished
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the recursive policies on the local directory.  This may be  * called directly, or may be called by start_recursion  */
end_comment

begin_function
specifier|static
name|int
name|do_recursion
parameter_list|(
name|frame
parameter_list|)
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dodoneproc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|List
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|int
name|should_readlock
decl_stmt|;
name|int
name|process_this_directory
init|=
literal|1
decl_stmt|;
comment|/* do nothing if told */
if|if
condition|(
name|frame
operator|->
name|flags
operator|==
name|R_SKIP_ALL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|should_readlock
operator|=
name|noexec
condition|?
literal|0
else|:
name|frame
operator|->
name|readlock
expr_stmt|;
comment|/* The fact that locks are not active here is what makes us fail to have        the             If someone commits some changes in one cvs command, 	   then an update by someone else will either get all the 	   changes, or none of them.         property (see node Concurrency in cvs.texinfo).         The most straightforward fix would just to readlock the whole        tree before starting an update, but that means that if a commit        gets blocked on a big update, it might need to wait a *long*        time.         A more adequate fix would be a two-pass design for update,        checkout, etc.  The first pass would go through the repository,        with the whole tree readlocked, noting what versions of each        file we want to get.  The second pass would release all locks        (except perhaps short-term locks on one file at a        time--although I think RCS already deals with this) and        actually get the files, specifying the particular versions it wants.         This could be sped up by separating out the data needed for the        first pass into a separate file(s)--for example a file        attribute for each file whose value contains the head revision        for each branch.  The structure should be designed so that        commit can relatively quickly update the information for a        single file or a handful of files (file attributes, as        implemented in Jan 96, are probably acceptable; improvements        would be possible such as branch attributes which are in        separate files for each branch).  */
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_FLOWCONTROL
argument_list|)
comment|/*      * Now would be a good time to check to see if we need to stop      * generating data, to give the buffers a chance to drain to the      * remote client.  We should not have locks active at this point.      */
if|if
condition|(
name|server_active
comment|/* If there are writelocks around, we cannot pause here.  */
operator|&&
operator|(
name|should_readlock
operator|||
name|noexec
operator|)
condition|)
name|server_pause_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Check the value in CVSADM_ROOT and see if it's in the list.  If        not, add it to our lists of CVS/Root directories and do not        process the files in this directory.  Otherwise, continue as        usual.  THIS_ROOT might be NULL if we're doing an initial        checkout -- check before using it.  The default should be that        we process a directory's contents and only skip those contents        if a CVS/Root file exists.          If we're running the server, we want to process all        directories, since we're guaranteed to have only one CVSROOT --        our own.  */
if|if
condition|(
comment|/* If -d was specified, it should override CVS/Root.  	   In the single-repository case, it is long-standing CVS behavior 	   and makes sense - the user might want another access method, 	   another server (which mounts the same repository),&c.  	   In the multiple-repository case, -d overrides all CVS/Root 	   files.  That is the only plausible generalization I can 	   think of.  */
name|CVSroot_cmdline
operator|==
name|NULL
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|&&
operator|!
name|server_active
endif|#
directive|endif
condition|)
block|{
name|char
modifier|*
name|this_root
init|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|findnode
argument_list|(
name|root_directories
argument_list|,
name|this_root
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Add it to our list. */
name|Node
modifier|*
name|n
init|=
name|getnode
argument_list|()
decl_stmt|;
name|n
operator|->
name|type
operator|=
name|NT_UNKNOWN
expr_stmt|;
name|n
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|this_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|root_directories
argument_list|,
name|n
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot add new CVSROOT %s"
argument_list|,
name|this_root
argument_list|)
expr_stmt|;
block|}
name|process_this_directory
operator|=
operator|(
name|strcmp
argument_list|(
name|current_parsed_root
operator|->
name|original
argument_list|,
name|this_root
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|free
argument_list|(
name|this_root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Fill in repository with the current repository      */
if|if
condition|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|repository
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get working directory"
argument_list|)
expr_stmt|;
block|}
name|srepository
operator|=
name|repository
expr_stmt|;
comment|/* remember what to free */
name|fileattr_startdir
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/*      * The filesdoneproc needs to be called for each directory where files      * processed, or each directory that is processed by a call where no      * directories were passed in.  In fact, the only time we don't want to      * call back the filesdoneproc is when we are processing directories that      * were passed in on the command line (or in the special case of `.' when      * we were called with no args      */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
operator|&&
name|filelist
operator|==
name|NULL
condition|)
name|dodoneproc
operator|=
literal|0
expr_stmt|;
comment|/*      * If filelist or dirlist is already set, we don't look again. Otherwise,      * find the files and directories      */
if|if
condition|(
name|filelist
operator|==
name|NULL
operator|&&
name|dirlist
operator|==
name|NULL
condition|)
block|{
comment|/* both lists were NULL, so start from scratch */
if|if
condition|(
name|frame
operator|->
name|fileproc
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|flags
operator|!=
name|R_SKIP_FILES
condition|)
block|{
name|int
name|lwhich
init|=
name|frame
operator|->
name|which
decl_stmt|;
comment|/* be sure to look in the attic if we have sticky tags/date */
if|if
condition|(
operator|(
name|lwhich
operator|&
name|W_ATTIC
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|isreadable
argument_list|(
name|CVSADM_TAG
argument_list|)
condition|)
name|lwhich
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* In the !(which& W_LOCAL) case, we filled in repository 	       earlier in the function.  In the (which& W_LOCAL) case, 	       the Find_Names function is going to look through the 	       Entries file.  If we do not have a repository, that 	       does not make sense, so we insist upon having a 	       repository at this point.  Name_Repository will give a 	       reasonable error message.  */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* find the files and fill in entries if appropriate */
if|if
condition|(
name|process_this_directory
condition|)
block|{
name|filelist
operator|=
name|Find_Names
argument_list|(
name|repository
argument_list|,
name|lwhich
argument_list|,
name|frame
operator|->
name|aflag
argument_list|,
operator|&
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelist
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"skipping directory %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* Note that Find_Directories and the filesdoneproc 		       in particular would do bad things ("? foo.c" in 		       the case of some filesdoneproc's).  */
goto|goto
name|skip_directory
goto|;
block|}
block|}
block|}
comment|/* find sub-directories if we will recurse */
if|if
condition|(
name|frame
operator|->
name|flags
operator|!=
name|R_SKIP_DIRS
condition|)
name|dirlist
operator|=
name|Find_Directories
argument_list|(
name|process_this_directory
condition|?
name|repository
else|:
name|NULL
argument_list|,
name|frame
operator|->
name|which
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something was passed on the command line */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|fileproc
operator|!=
name|NULL
condition|)
block|{
comment|/* we will process files, so pre-parse entries */
if|if
condition|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
condition|)
name|entries
operator|=
name|Entries_Open
argument_list|(
name|frame
operator|->
name|aflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the files (if any) */
if|if
condition|(
name|process_this_directory
operator|&&
name|filelist
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|fileproc
condition|)
block|{
name|struct
name|file_info
name|finfo_struct
decl_stmt|;
name|struct
name|frame_and_file
name|frfile
decl_stmt|;
comment|/* read lock it if necessary */
if|if
condition|(
name|should_readlock
operator|&&
name|repository
operator|&&
name|Reader_Lock
argument_list|(
name|repository
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"read lock failed - giving up"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* For the server, we handle notifications in a completely different 	   place (server_notify).  For local, we can't do them here--we don't 	   have writelocks in place, and there is no way to get writelocks 	   here.  */
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
name|notify_check
argument_list|(
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|finfo_struct
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo_struct
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|finfo_struct
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
comment|/* do_file_proc will fill in finfo_struct.file.  */
name|frfile
operator|.
name|finfo
operator|=
operator|&
name|finfo_struct
expr_stmt|;
name|frfile
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
comment|/* process the files */
name|err
operator|+=
name|walklist
argument_list|(
name|filelist
argument_list|,
name|do_file_proc
argument_list|,
operator|&
name|frfile
argument_list|)
expr_stmt|;
comment|/* unlock it */
if|if
condition|(
name|should_readlock
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up */
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
block|}
comment|/* call-back files done proc (if any) */
if|if
condition|(
name|process_this_directory
operator|&&
name|dodoneproc
operator|&&
name|frame
operator|->
name|filesdoneproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|frame
operator|->
name|filesdoneproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|err
argument_list|,
name|repository
argument_list|,
name|update_dir
index|[
literal|0
index|]
condition|?
name|update_dir
else|:
literal|"."
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|skip_directory
label|:
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
comment|/* process the directories (if necessary) */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_and_entries
name|frent
decl_stmt|;
name|frent
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|frent
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
name|err
operator|+=
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|do_dir_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frent
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (frame->dirleaveproc != NULL) 	err += frame->dirleaveproc (frame->callerdat, ".", err, ".");
endif|#
directive|endif
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* free the saved copy of the pointer if necessary */
if|if
condition|(
name|srepository
condition|)
block|{
name|free
argument_list|(
name|srepository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the files in the list with the callback proc  */
end_comment

begin_function
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|frame_and_file
modifier|*
name|frfile
init|=
operator|(
expr|struct
name|frame_and_file
operator|*
operator|)
name|closure
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
init|=
name|frfile
operator|->
name|finfo
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|finfo
operator|->
name|file
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|finfo
operator|->
name|fullname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|fullname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|frfile
operator|->
name|frame
operator|->
name|dosrcs
operator|&&
name|repository
condition|)
block|{
name|finfo
operator|->
name|rcs
operator|=
name|RCS_parse
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* OK, without W_LOCAL the error handling becomes relatively 	   simple.  The file names came from readdir() on the 	   repository and so we know any ENOENT is an error 	   (e.g. symlink pointing to nothing).  Now, the logic could 	   be simpler - since we got the name from readdir, we could 	   just be calling RCS_parsercsfile.  */
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|frfile
operator|->
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not read RCS file for %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|cvs_flushout
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
name|finfo
operator|->
name|rcs
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
name|ret
operator|=
name|frfile
operator|->
name|frame
operator|->
name|fileproc
argument_list|(
name|frfile
operator|->
name|frame
operator|->
name|callerdat
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* Allow the user to monitor progress with tail -f.  Doing this once        per file should be no big deal, but we don't want the performance        hit of flushing on every line like previous versions of CVS.  */
name|cvs_flushout
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the directories in the list (recursing as we go)  */
end_comment

begin_function
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|frame_and_entries
modifier|*
name|frent
init|=
operator|(
expr|struct
name|frame_and_entries
operator|*
operator|)
name|closure
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
name|frent
operator|->
name|frame
decl_stmt|;
name|struct
name|recursion_frame
name|xframe
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|p
operator|->
name|key
decl_stmt|;
name|char
modifier|*
name|newrepos
decl_stmt|;
name|List
modifier|*
name|sdirlist
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|Dtype
name|dir_return
init|=
name|R_PROCESS
decl_stmt|;
name|int
name|stripped_dot
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|saved_update_dir
decl_stmt|;
name|int
name|process_this_directory
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|fncmp
argument_list|(
name|dir
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This seems to most often happen when users (beginning users, 	   generally), try "cvs ci *" or something similar.  On that 	   theory, it is possible that we should just silently skip the 	   CVSADM directories, but on the other hand, using a wildcard 	   like this isn't necessarily a practice to encourage (it operates 	   only on files which exist in the working directory, unlike 	   regular CVS recursion).  */
comment|/* FIXME-reentrancy: printed_cvs_msg should be in a "command 	   struct" or some such, so that it gets cleared for each new 	   command (this is possible using the remote protocol and a 	   custom-written client).  The struct recursion_frame is not 	   far back enough though, some commands (commit at least) 	   will call start_recursion several times.  An alternate solution 	   would be to take this whole check and move it to a new function 	   validate_arguments or some such that all the commands call 	   and which snips the offending directory from the argc,argv 	   vector.  */
specifier|static
name|int
name|printed_cvs_msg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|printed_cvs_msg
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: directory %s specified in argument"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ but CVS uses %s for its own purposes; skipping %s directory"
argument_list|,
name|CVSADM
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|printed_cvs_msg
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|saved_update_dir
operator|=
name|update_dir
expr_stmt|;
name|update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|saved_update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|saved_update_dir
argument_list|)
expr_stmt|;
comment|/* set up update_dir - skip dots if not at start */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* 	 * Here we need a plausible repository name for the sub-directory. We 	 * create one by concatenating the new directory name onto the 	 * previous repository name.  The only case where the name should be 	 * used is in the case where we are creating a new sub-directory for 	 * update -d and in that case the generated name will be correct. 	 */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|newrepos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|newrepos
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that the CVSADM directory, if it exists, seems to be        well-formed.  It can be missing files if the user hit ^C in the        middle of a previous run.  We want to (a) make this a nonfatal        error, and (b) make sure we print which directory has the        problem.         Do this before the direntproc, so that (1) the direntproc        doesn't have to guess/deduce whether we will skip the directory        (e.g. send_dirent_proc and whether to send the directory), and        (2) so that the warm fuzzy doesn't get printed if we skip the        directory.  */
if|if
condition|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
condition|)
block|{
name|char
modifier|*
name|cvsadmdir
decl_stmt|;
name|cvsadmdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_REP
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ENT
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cvsadmdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|cvsadmdir
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|cvsadmdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|cvsadmdir
argument_list|)
condition|)
block|{
comment|/* Some commands like update may have printed "? foo" but 		   if we were planning to recurse, and don't on account of 		   CVS/Repository, we want to say why.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s (%s missing)"
argument_list|,
name|update_dir
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|dir_return
operator|=
name|R_SKIP_ALL
expr_stmt|;
block|}
comment|/* Likewise for CVS/Entries.  */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
name|strcpy
argument_list|(
name|cvsadmdir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cvsadmdir
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|cvsadmdir
argument_list|)
condition|)
block|{
comment|/* Some commands like update may have printed "? foo" but 		       if we were planning to recurse, and don't on account of 		       CVS/Repository, we want to say why.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s (%s missing)"
argument_list|,
name|update_dir
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|dir_return
operator|=
name|R_SKIP_ALL
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|cvsadmdir
argument_list|)
expr_stmt|;
block|}
comment|/* Only process this directory if the root matches.  This nearly        duplicates code in do_recursion. */
if|if
condition|(
comment|/* If -d was specified, it should override CVS/Root.  	   In the single-repository case, it is long-standing CVS behavior 	   and makes sense - the user might want another access method, 	   another server (which mounts the same repository),&c.  	   In the multiple-repository case, -d overrides all CVS/Root 	   files.  That is the only plausible generalization I can 	   think of.  */
name|CVSroot_cmdline
operator|==
name|NULL
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|&&
operator|!
name|server_active
endif|#
directive|endif
condition|)
block|{
name|char
modifier|*
name|this_root
init|=
name|Name_Root
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|findnode
argument_list|(
name|root_directories
argument_list|,
name|this_root
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Add it to our list. */
name|Node
modifier|*
name|n
init|=
name|getnode
argument_list|()
decl_stmt|;
name|n
operator|->
name|type
operator|=
name|NT_UNKNOWN
expr_stmt|;
name|n
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|this_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|root_directories
argument_list|,
name|n
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot add new CVSROOT %s"
argument_list|,
name|this_root
argument_list|)
expr_stmt|;
block|}
name|process_this_directory
operator|=
operator|(
name|strcmp
argument_list|(
name|current_parsed_root
operator|->
name|original
argument_list|,
name|this_root
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|free
argument_list|(
name|this_root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* call-back dir entry proc (if any) */
if|if
condition|(
name|dir_return
operator|==
name|R_SKIP_ALL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|frame
operator|->
name|direntproc
operator|!=
name|NULL
condition|)
block|{
comment|/* If we're doing the actual processing, call direntproc.            Otherwise, assume that we need to process this directory            and recurse. FIXME. */
if|if
condition|(
name|process_this_directory
condition|)
name|dir_return
operator|=
name|frame
operator|->
name|direntproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|dir
argument_list|,
name|newrepos
argument_list|,
name|update_dir
argument_list|,
name|frent
operator|->
name|entries
argument_list|)
expr_stmt|;
else|else
name|dir_return
operator|=
name|R_PROCESS
expr_stmt|;
block|}
else|else
block|{
comment|/* Generic behavior.  I don't see a reason to make the caller specify 	   a direntproc just to get this.  */
if|if
condition|(
operator|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
name|dir_return
operator|=
name|R_SKIP_ALL
expr_stmt|;
block|}
name|free
argument_list|(
name|newrepos
argument_list|)
expr_stmt|;
comment|/* only process the dir if the return code was 0 */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
comment|/* save our current directory and static vars */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|sdirlist
operator|=
name|dirlist
expr_stmt|;
name|srepository
operator|=
name|repository
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
comment|/* cd to the sub-directory */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* honor the global SKIP_DIRS (a.k.a. local) */
if|if
condition|(
name|frame
operator|->
name|flags
operator|==
name|R_SKIP_DIRS
condition|)
name|dir_return
operator|=
name|R_SKIP_DIRS
expr_stmt|;
comment|/* remember if the `.' will be stripped for subsequent dirs */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stripped_dot
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make the recursive call */
name|xframe
operator|=
operator|*
name|frame
expr_stmt|;
name|xframe
operator|.
name|flags
operator|=
name|dir_return
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
operator|&
name|xframe
argument_list|)
expr_stmt|;
comment|/* put the `.' back if necessary */
if|if
condition|(
name|stripped_dot
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* call-back dir leave proc (if any) */
if|if
condition|(
name|process_this_directory
operator|&&
name|frame
operator|->
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|frame
operator|->
name|dirleaveproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|dir
argument_list|,
name|err
argument_list|,
name|update_dir
argument_list|,
name|frent
operator|->
name|entries
argument_list|)
expr_stmt|;
comment|/* get back to where we started and restore state vars */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|dirlist
operator|=
name|sdirlist
expr_stmt|;
name|repository
operator|=
name|srepository
expr_stmt|;
block|}
name|free
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|saved_update_dir
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a list allocating the list if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|addlist
parameter_list|(
name|listp
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
operator|*
name|listp
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
operator|*
name|listp
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfile
parameter_list|(
name|listp
parameter_list|,
name|dir
parameter_list|,
name|file
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|List
modifier|*
name|fl
decl_stmt|;
comment|/* add this dir. */
name|addlist
argument_list|(
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
operator|*
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can't find recently added dir node `%s' in start_recursion."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|fl
operator|=
operator|(
name|List
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|addlist
argument_list|(
operator|&
name|fl
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|n
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|fl
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|unroll_files_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
operator|(
expr|struct
name|recursion_frame
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|save_dirlist
decl_stmt|;
name|char
modifier|*
name|save_update_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* if this dir was also an explicitly named argument, then skip        it.  We'll catch it later when we do dirs. */
name|n
operator|=
name|findnode
argument_list|(
name|dirlist
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* otherwise, call dorecusion for this list of files. */
name|filelist
operator|=
operator|(
name|List
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|save_dirlist
operator|=
name|dirlist
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|save_update_dir
operator|=
name|update_dir
expr_stmt|;
name|update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|save_update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_update_dir
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|save_update_dir
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
name|dirlist
operator|=
name|save_dirlist
expr_stmt|;
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

