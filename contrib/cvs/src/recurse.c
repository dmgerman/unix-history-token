begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * General recursion handler  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|do_dir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_file_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addlist
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unroll_files_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addfile
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|update_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of files on which to operate */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of directories on which to operate */
end_comment

begin_struct
struct|struct
name|recursion_frame
block|{
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|do_recursion
name|PROTO
argument_list|(
operator|(
expr|struct
name|recursion_frame
operator|*
name|frame
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I am half tempted to shove a struct file_info * into the struct    recursion_frame (but then we would need to modify or create a    recursion_frame for each file), or shove a struct recursion_frame *    into the struct file_info (more tempting, although it isn't completely    clear that the struct file_info should contain info about recursion    processor internals).  So instead use this struct.  */
end_comment

begin_struct
struct|struct
name|frame_and_file
block|{
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Similarly, we need to pass the entries list to do_dir_proc.  */
end_comment

begin_struct
struct|struct
name|frame_and_entries
block|{
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Start a recursive command.     Command line arguments (ARGC, ARGV) dictate the directories and    files on which we operate.  In the special case of no arguments, we    default to ".".  */
end_comment

begin_function
name|int
name|start_recursion
parameter_list|(
name|fileproc
parameter_list|,
name|filesdoneproc
parameter_list|,
name|direntproc
parameter_list|,
name|dirleaveproc
parameter_list|,
name|callerdat
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|readlock
parameter_list|,
name|update_preload
parameter_list|,
name|dosrcs
parameter_list|)
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
comment|/* This specifies the kind of recursion.  There are several cases:         1.  W_LOCAL is not set but W_REPOS or W_ATTIC is.  The current        directory when we are called must be the repository and        recursion proceeds according to what exists in the repository.         2a.  W_LOCAL is set but W_REPOS and W_ATTIC are not.  The        current directory when we are called must be the working        directory.  Recursion proceeds according to what exists in the        working directory, never (I think) consulting any part of the        repository which does not correspond to the working directory        ("correspond" == Name_Repository).         2b.  W_LOCAL is set and so is W_REPOS or W_ATTIC.  This is the        weird one.  The current directory when we are called must be        the working directory.  We recurse through working directories,        but we recurse into a directory if it is exists in the working        directory *or* it exists in the repository.  If a directory        does not exist in the working directory, the direntproc must        either tell us to skip it (R_SKIP_ALL), or must create it (I        think those are the only two cases).  */
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|char
modifier|*
name|update_preload
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|files_by_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|recursion_frame
name|frame
decl_stmt|;
name|frame
operator|.
name|fileproc
operator|=
name|fileproc
expr_stmt|;
name|frame
operator|.
name|filesdoneproc
operator|=
name|filesdoneproc
expr_stmt|;
name|frame
operator|.
name|direntproc
operator|=
name|direntproc
expr_stmt|;
name|frame
operator|.
name|dirleaveproc
operator|=
name|dirleaveproc
expr_stmt|;
name|frame
operator|.
name|callerdat
operator|=
name|callerdat
expr_stmt|;
name|frame
operator|.
name|flags
operator|=
name|local
condition|?
name|R_SKIP_DIRS
else|:
name|R_PROCESS
expr_stmt|;
name|frame
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|frame
operator|.
name|aflag
operator|=
name|aflag
expr_stmt|;
name|frame
operator|.
name|readlock
operator|=
name|readlock
expr_stmt|;
name|frame
operator|.
name|dosrcs
operator|=
name|dosrcs
expr_stmt|;
name|expand_wild
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_preload
operator|==
name|NULL
condition|)
name|update_dir
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|update_dir
operator|=
name|xstrdup
argument_list|(
name|update_preload
argument_list|)
expr_stmt|;
comment|/* clean up from any previous calls to start_recursion */
if|if
condition|(
name|repository
condition|)
block|{
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
comment|/* FIXME-krp: no longer correct. */
if|if
condition|(
name|dirlist
condition|)
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|server_pathname_check
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* 	 * There were no arguments, so we'll probably just recurse. The 	 * exception to the rule is when we are called from a directory 	 * without any CVS administration files.  That has always meant to 	 * process each of the sub-directories, so we pretend like we were 	 * called with the list of sub-dirs of the current dir as args 	 */
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|dirlist
operator|=
name|Find_Directories
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * There were arguments, so we have to handle them by hand. To do      * that, we set up the filelist and dirlist with the arguments and      * call do_recursion.  do_recursion recognizes the fact that the      * lists are non-null when it starts and doesn't update them.      *      * explicitly named directories are stored in dirlist.      * explicitly named files are stored in filelist.      * other possibility is named entities whicha are not currently in      * the working directory.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* if this argument is a directory, then add it to the list of 	   directories. */
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise, split argument into directory and component names. */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|comp
decl_stmt|;
name|char
modifier|*
name|file_to_try
decl_stmt|;
comment|/* Now break out argv[i] into directory part (DIR) and file part (COMP). 		   DIR and COMP will each point to a newly malloc'd string.  */
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|comp
operator|=
name|last_component
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|dir
condition|)
block|{
comment|/* no dir component.  What we have is an implied "./" */
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|comp
decl_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|comp
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if this argument exists as a file in the current 	       working directory tree, then add it to the files list.  */
if|if
condition|(
operator|!
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
condition|)
block|{
comment|/* If doing rtag, we've done a chdir to the repository. */
name|file_to_try
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|file_to_try
argument_list|,
literal|"%s%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
else|else
name|file_to_try
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file_to_try
argument_list|)
condition|)
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
name|isdir
argument_list|(
name|CVSADM
argument_list|)
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
name|client_active
endif|#
directive|endif
condition|)
block|{
comment|/* otherwise, look for it in the repository. */
name|char
modifier|*
name|tmp_update_dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|reposfile
decl_stmt|;
name|tmp_update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp_update_dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tmp_update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmp_update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmp_update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* look for it in the repository. */
name|repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|tmp_update_dir
argument_list|)
expr_stmt|;
name|reposfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|comp
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|reposfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|comp
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|reposfile
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reposfile
argument_list|)
expr_stmt|;
block|}
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such directory `%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_to_try
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point we have looped over all named arguments and built        a coupla lists.  Now we unroll the lists, setting up and        calling do_recursion. */
name|err
operator|+=
name|walklist
argument_list|(
name|files_by_dir
argument_list|,
name|unroll_files_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|files_by_dir
argument_list|)
expr_stmt|;
comment|/* then do_recursion on the dirlist. */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|do_recursion
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Free the data which expand_wild allocated.  */
name|free_names
argument_list|(
operator|&
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the recursive policies on the local directory.  This may be  * called directly, or may be called by start_recursion  */
end_comment

begin_function
specifier|static
name|int
name|do_recursion
parameter_list|(
name|frame
parameter_list|)
name|struct
name|recursion_frame
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dodoneproc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|List
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|int
name|should_readlock
decl_stmt|;
comment|/* do nothing if told */
if|if
condition|(
name|frame
operator|->
name|flags
operator|==
name|R_SKIP_ALL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|should_readlock
operator|=
name|noexec
condition|?
literal|0
else|:
name|frame
operator|->
name|readlock
expr_stmt|;
comment|/* The fact that locks are not active here is what makes us fail to have        the             If someone commits some changes in one cvs command, 	   then an update by someone else will either get all the 	   changes, or none of them.         property (see node Concurrency in cvs.texinfo).         The most straightforward fix would just to readlock the whole        tree before starting an update, but that means that if a commit        gets blocked on a big update, it might need to wait a *long*        time.         A more adequate fix would be a two-pass design for update,        checkout, etc.  The first pass would go through the repository,        with the whole tree readlocked, noting what versions of each        file we want to get.  The second pass would release all locks        (except perhaps short-term locks on one file at a        time--although I think RCS already deals with this) and        actually get the files, specifying the particular versions it wants.         This could be sped up by separating out the data needed for the        first pass into a separate file(s)--for example a file        attribute for each file whose value contains the head revision        for each branch.  The structure should be designed so that        commit can relatively quickly update the information for a        single file or a handful of files (file attributes, as        implemented in Jan 96, are probably acceptable; improvements        would be possible such as branch attributes which are in        separate files for each branch).  */
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_FLOWCONTROL
argument_list|)
comment|/*      * Now would be a good time to check to see if we need to stop      * generating data, to give the buffers a chance to drain to the      * remote client.  We should not have locks active at this point.      */
if|if
condition|(
name|server_active
comment|/* If there are writelocks around, we cannot pause here.  */
operator|&&
operator|(
name|should_readlock
operator|||
name|noexec
operator|)
condition|)
name|server_pause_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Fill in repository with the current repository      */
if|if
condition|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|repository
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get working directory"
argument_list|)
expr_stmt|;
block|}
name|srepository
operator|=
name|repository
expr_stmt|;
comment|/* remember what to free */
name|fileattr_startdir
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/*      * The filesdoneproc needs to be called for each directory where files      * processed, or each directory that is processed by a call where no      * directories were passed in.  In fact, the only time we don't want to      * call back the filesdoneproc is when we are processing directories that      * were passed in on the command line (or in the special case of `.' when      * we were called with no args      */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
operator|&&
name|filelist
operator|==
name|NULL
condition|)
name|dodoneproc
operator|=
literal|0
expr_stmt|;
comment|/*      * If filelist or dirlist is already set, we don't look again. Otherwise,      * find the files and directories      */
if|if
condition|(
name|filelist
operator|==
name|NULL
operator|&&
name|dirlist
operator|==
name|NULL
condition|)
block|{
comment|/* both lists were NULL, so start from scratch */
if|if
condition|(
name|frame
operator|->
name|fileproc
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|flags
operator|!=
name|R_SKIP_FILES
condition|)
block|{
name|int
name|lwhich
init|=
name|frame
operator|->
name|which
decl_stmt|;
comment|/* be sure to look in the attic if we have sticky tags/date */
if|if
condition|(
operator|(
name|lwhich
operator|&
name|W_ATTIC
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|isreadable
argument_list|(
name|CVSADM_TAG
argument_list|)
condition|)
name|lwhich
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* In the !(which& W_LOCAL) case, we filled in repository 	       earlier in the function.  In the (which& W_LOCAL) case, 	       the Find_Names function is going to look through the 	       Entries file.  If we do not have a repository, that 	       does not make sense, so we insist upon having a 	       repository at this point.  Name_Repository will give a 	       reasonable error message.  */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* find the files and fill in entries if appropriate */
name|filelist
operator|=
name|Find_Names
argument_list|(
name|repository
argument_list|,
name|lwhich
argument_list|,
name|frame
operator|->
name|aflag
argument_list|,
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* find sub-directories if we will recurse */
if|if
condition|(
name|frame
operator|->
name|flags
operator|!=
name|R_SKIP_DIRS
condition|)
name|dirlist
operator|=
name|Find_Directories
argument_list|(
name|repository
argument_list|,
name|frame
operator|->
name|which
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something was passed on the command line */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|fileproc
operator|!=
name|NULL
condition|)
block|{
comment|/* we will process files, so pre-parse entries */
if|if
condition|(
name|frame
operator|->
name|which
operator|&
name|W_LOCAL
condition|)
name|entries
operator|=
name|Entries_Open
argument_list|(
name|frame
operator|->
name|aflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the files (if any) */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|frame
operator|->
name|fileproc
condition|)
block|{
name|struct
name|file_info
name|finfo_struct
decl_stmt|;
name|struct
name|frame_and_file
name|frfile
decl_stmt|;
comment|/* read lock it if necessary */
if|if
condition|(
name|should_readlock
operator|&&
name|repository
operator|&&
name|Reader_Lock
argument_list|(
name|repository
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"read lock failed - giving up"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* For the server, we handle notifications in a completely different 	   place (server_notify).  For local, we can't do them here--we don't 	   have writelocks in place, and there is no way to get writelocks 	   here.  */
if|if
condition|(
name|client_active
condition|)
name|notify_check
argument_list|(
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|finfo_struct
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo_struct
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|finfo_struct
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
comment|/* do_file_proc will fill in finfo_struct.file.  */
name|frfile
operator|.
name|finfo
operator|=
operator|&
name|finfo_struct
expr_stmt|;
name|frfile
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
comment|/* process the files */
name|err
operator|+=
name|walklist
argument_list|(
name|filelist
argument_list|,
name|do_file_proc
argument_list|,
operator|&
name|frfile
argument_list|)
expr_stmt|;
comment|/* unlock it */
if|if
condition|(
name|should_readlock
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up */
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
block|}
comment|/* call-back files done proc (if any) */
if|if
condition|(
name|dodoneproc
operator|&&
name|frame
operator|->
name|filesdoneproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|frame
operator|->
name|filesdoneproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|err
argument_list|,
name|repository
argument_list|,
name|update_dir
index|[
literal|0
index|]
condition|?
name|update_dir
else|:
literal|"."
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
comment|/* process the directories (if necessary) */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|frame_and_entries
name|frent
decl_stmt|;
name|frent
operator|.
name|frame
operator|=
name|frame
expr_stmt|;
name|frent
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
name|err
operator|+=
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|do_dir_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frent
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (frame->dirleaveproc != NULL) 	err += frame->dirleaveproc (frame->callerdat, ".", err, ".");
endif|#
directive|endif
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
condition|)
block|{
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* free the saved copy of the pointer if necessary */
if|if
condition|(
name|srepository
condition|)
block|{
name|free
argument_list|(
name|srepository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the files in the list with the callback proc  */
end_comment

begin_function
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|frame_and_file
modifier|*
name|frfile
init|=
operator|(
expr|struct
name|frame_and_file
operator|*
operator|)
name|closure
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
init|=
name|frfile
operator|->
name|finfo
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|finfo
operator|->
name|file
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|finfo
operator|->
name|fullname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|finfo
operator|->
name|fullname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|frfile
operator|->
name|frame
operator|->
name|dosrcs
operator|&&
name|repository
condition|)
name|finfo
operator|->
name|rcs
operator|=
name|RCS_parse
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
name|finfo
operator|->
name|rcs
operator|=
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
expr_stmt|;
name|ret
operator|=
name|frfile
operator|->
name|frame
operator|->
name|fileproc
argument_list|(
name|frfile
operator|->
name|frame
operator|->
name|callerdat
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* Allow the user to monitor progress with tail -f.  Doing this once        per file should be no big deal, but we don't want the performance        hit of flushing on every line like previous versions of CVS.  */
name|cvs_flushout
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the directories in the list (recursing as we go)  */
end_comment

begin_function
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|frame_and_entries
modifier|*
name|frent
init|=
operator|(
expr|struct
name|frame_and_entries
operator|*
operator|)
name|closure
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
name|frent
operator|->
name|frame
decl_stmt|;
name|struct
name|recursion_frame
name|xframe
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|p
operator|->
name|key
decl_stmt|;
name|char
modifier|*
name|newrepos
decl_stmt|;
name|List
modifier|*
name|sdirlist
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Dtype
name|dir_return
init|=
name|R_PROCESS
decl_stmt|;
name|int
name|stripped_dot
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|saved_update_dir
decl_stmt|;
if|if
condition|(
name|fncmp
argument_list|(
name|dir
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This seems to most often happen when users (beginning users, 	   generally), try "cvs ci *" or something similar.  On that 	   theory, it is possible that we should just silently skip the 	   CVSADM directories, but on the other hand, using a wildcard 	   like this isn't necessarily a practice to encourage (it operates 	   only on files which exist in the working directory, unlike 	   regular CVS recursion).  */
comment|/* FIXME-reentrancy: printed_cvs_msg should be in a "command 	   struct" or some such, so that it gets cleared for each new 	   command (this is possible using the remote protocol and a 	   custom-written client).  The struct recursion_frame is not 	   far back enough though, some commands (commit at least) 	   will call start_recursion several times.  An alternate solution 	   would be to take this whole check and move it to a new function 	   validate_arguments or some such that all the commands call 	   and which snips the offending directory from the argc,argv 	   vector.  */
specifier|static
name|int
name|printed_cvs_msg
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|printed_cvs_msg
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: directory %s specified in argument"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ but CVS uses %s for its own purposes; skipping %s directory"
argument_list|,
name|CVSADM
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|printed_cvs_msg
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|saved_update_dir
operator|=
name|update_dir
expr_stmt|;
name|update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|saved_update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|saved_update_dir
argument_list|)
expr_stmt|;
comment|/* set up update_dir - skip dots if not at start */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* 	 * Here we need a plausible repository name for the sub-directory. We 	 * create one by concatenating the new directory name onto the 	 * previous repository name.  The only case where the name should be 	 * used is in the case where we are creating a new sub-directory for 	 * update -d and in that case the generated name will be correct. 	 */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|newrepos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
name|newrepos
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* call-back dir entry proc (if any) */
if|if
condition|(
name|frame
operator|->
name|direntproc
operator|!=
name|NULL
condition|)
name|dir_return
operator|=
name|frame
operator|->
name|direntproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|dir
argument_list|,
name|newrepos
argument_list|,
name|update_dir
argument_list|,
name|frent
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newrepos
argument_list|)
expr_stmt|;
comment|/* only process the dir if the return code was 0 */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
comment|/* save our current directory and static vars */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|sdirlist
operator|=
name|dirlist
expr_stmt|;
name|srepository
operator|=
name|repository
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
comment|/* cd to the sub-directory */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* honor the global SKIP_DIRS (a.k.a. local) */
if|if
condition|(
name|frame
operator|->
name|flags
operator|==
name|R_SKIP_DIRS
condition|)
name|dir_return
operator|=
name|R_SKIP_DIRS
expr_stmt|;
comment|/* remember if the `.' will be stripped for subsequent dirs */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stripped_dot
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make the recursive call */
name|xframe
operator|=
operator|*
name|frame
expr_stmt|;
name|xframe
operator|.
name|flags
operator|=
name|dir_return
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
operator|&
name|xframe
argument_list|)
expr_stmt|;
comment|/* put the `.' back if necessary */
if|if
condition|(
name|stripped_dot
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* call-back dir leave proc (if any) */
if|if
condition|(
name|frame
operator|->
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|frame
operator|->
name|dirleaveproc
argument_list|(
name|frame
operator|->
name|callerdat
argument_list|,
name|dir
argument_list|,
name|err
argument_list|,
name|update_dir
argument_list|,
name|frent
operator|->
name|entries
argument_list|)
expr_stmt|;
comment|/* get back to where we started and restore state vars */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|dirlist
operator|=
name|sdirlist
expr_stmt|;
name|repository
operator|=
name|srepository
expr_stmt|;
block|}
comment|/* Put back update_dir.  I think this is the same as just setting        update_dir back to saved_update_dir, but there are a few cases I'm        not sure about (in particular, if DIR is "." and update_dir is        not ""), so for conservatism I'm leaving this here.  */
name|cp
operator|=
name|last_component
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|update_dir
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|saved_update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a list allocating the list if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|addlist
parameter_list|(
name|listp
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
operator|*
name|listp
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
operator|*
name|listp
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfile
parameter_list|(
name|listp
parameter_list|,
name|dir
parameter_list|,
name|file
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
comment|/* add this dir. */
name|addlist
argument_list|(
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
operator|*
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can't find recently added dir node `%s' in start_recursion."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|addlist
argument_list|(
operator|(
name|List
operator|*
operator|*
operator|)
operator|&
name|n
operator|->
name|data
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|unroll_files_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
operator|(
expr|struct
name|recursion_frame
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|save_dirlist
decl_stmt|;
name|char
modifier|*
name|save_update_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* if this dir was also an explicitly named argument, then skip        it.  We'll catch it later when we do dirs. */
name|n
operator|=
name|findnode
argument_list|(
name|dirlist
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* otherwise, call dorecusion for this list of files. */
name|filelist
operator|=
operator|(
name|List
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|save_dirlist
operator|=
name|dirlist
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|save_update_dir
operator|=
name|update_dir
expr_stmt|;
name|update_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|save_update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_update_dir
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|save_update_dir
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
name|dirlist
operator|=
name|save_dirlist
expr_stmt|;
name|filelist
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

