begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Release: "cancel" a checkout in the history log.  *   * - Enter a line in the history log indicating the "release". - If asked to,  * delete the local working directory.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|release_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-d] directories...\n"
block|,
literal|"\t-d\tDelete the given directory.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|release_server
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the server side of cvs release.  */
end_comment

begin_function
specifier|static
name|int
name|release_server
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Note that we skip argv[0].  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|history_write
argument_list|(
literal|'F'
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/* There are various things to improve about this implementation:     1.  Using run_popen to run "cvs update" could be replaced by a    fairly simple start_recursion/classify_file loop--a win for    portability, performance, and cleanliness.  In particular, there is    no particularly good way to find the right "cvs".     2.  The fact that "cvs update" contacts the server slows things down;    it undermines the case for using "cvs release" rather than "rm -rf".    However, for correctly printing "? foo" and correctly handling    CVSROOTADM_IGNORE, we currently need to contact the server.  (One    idea for how to fix this is to stash a copy of CVSROOTADM_IGNORE in    the working directories; see comment at base_* in entries.c for a    few thoughts on that).     3.  Would be nice to take processing things on the client side one step    further, and making it like edit/unedit in terms of working well if    disconnected from the network, and then sending a delayed    notification.     4.  Having separate network turnarounds for the "Notify" request    which we do as part of unedit, and for the "release" itself, is slow    and unnecessary.  */
end_comment

begin_function
name|int
name|release
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|update_cmd
decl_stmt|;
name|char
modifier|*
name|thisarg
decl_stmt|;
name|int
name|arg_start_idx
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|short
name|delete_flag
init|=
literal|0
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
return|return
name|release_server
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
endif|#
directive|endif
comment|/* Everything from here on is client or local.  */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|release_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+Qdq"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_flag
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|release_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* We're going to run "cvs -n -q update" and check its output; if      * the output is sufficiently unalarming, then we release with no      * questions asked.  Else we prompt, then maybe release.      * (Well, actually we ask no matter what.  Our notion of "sufficiently      * unalarming" doesn't take into account "? foo.c" files, so it is      * up to the user to take note of them, at least currently      * (ignore-193 in testsuite)).      */
comment|/* Construct the update command. */
name|update_cmd
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|program_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot_original
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|update_cmd
argument_list|,
literal|"%s -n -q -d %s update"
argument_list|,
name|program_path
argument_list|,
name|CVSroot_original
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* Start the server; we'll close it after looping. */
if|if
condition|(
name|client_active
condition|)
block|{
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
comment|/* Remember the directory where "cvs release" was invoked because        all args are relative to this directory and we chdir around.        */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|arg_start_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg_start_idx
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|thisarg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|thisarg
argument_list|)
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|thisarg
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"can't chdir to: %s"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"no repository directory: %s"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"no such directory: %s"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|int
name|line_length
decl_stmt|;
comment|/* The "release" command piggybacks on "update", which 	       does the real work of finding out if anything is not 	       up-to-date with the repository.  Then "release" prompts 	       the user, telling her how many files have been 	       modified, and asking if she still wants to do the 	       release.  */
name|fp
operator|=
name|run_popen
argument_list|(
name|update_cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot run command %s"
argument_list|,
name|update_cmd
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_allocated
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"MARCZ"
argument_list|,
operator|*
name|line
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read from subprocess"
argument_list|)
expr_stmt|;
comment|/* If the update exited with an error, then we just want to 	       complain and go on to the next arg.  Especially, we do 	       not want to delete the local copy, since it's obviously 	       not what the user thinks it is.  */
if|if
condition|(
operator|(
name|pclose
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unable to release `%s'"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"You have [%d] altered files in this repository.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Are you sure you want to release %sdirectory `%s': "
argument_list|,
name|delete_flag
condition|?
literal|"(and delete) "
else|:
literal|""
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
name|c
operator|=
operator|!
name|yesno
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
condition|)
comment|/* "No" */
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** `%s' aborted by user choice.\n"
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
operator|(
name|client_active
operator|&&
operator|(
operator|!
name|supported_request
argument_list|(
literal|"noop"
argument_list|)
operator|||
operator|!
name|supported_request
argument_list|(
literal|"Notify"
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* We are chdir'ed into the directory in question.   	       So don't pass args to unedit.  */
name|int
name|argc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"dummy"
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|err
operator|+=
name|unedit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|thisarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"release\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|{
name|history_write
argument_list|(
literal|'F'
argument_list|,
name|thisarg
argument_list|,
literal|""
argument_list|,
name|thisarg
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* F == Free */
block|}
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|delete_flag
condition|)
block|{
comment|/* FIXME?  Shouldn't this just delete the CVS-controlled 	       files and, perhaps, the files that would normally be 	       ignored and leave everything else?  */
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|thisarg
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"deletion of directory %s failed"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
name|err
operator|+=
name|get_server_responses
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|}
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
comment|/* Unfortunately, client.c doesn't offer a way to close 	   the connection without waiting for responses.  The extra 	   network turnaround here is quite unnecessary other than 	   that....  */
name|send_to_server
argument_list|(
literal|"noop\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|+=
name|get_responses_and_close
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|free
argument_list|(
name|update_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

