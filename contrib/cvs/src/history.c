begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS 1.0 kit.  *  * **************** History of Users and Module ****************  *  * LOGGING:  Append record to "${CVSROOT}/CVSROOTADM/CVSROOTADM_HISTORY".  *  * On For each Tag, Add, Checkout, Commit, Update or Release command,  * one line of text is written to a History log.  *  *	X date | user | CurDir | special | rev(s) | argument '\n'  *  * where: [The spaces in the example line above are not in the history file.]  *  *  X		is a single character showing the type of event:  *		T	"Tag" cmd.  *		O	"Checkout" cmd.  *              E       "Export" cmd.  *		F	"Release" cmd.  *		W	"Update" cmd - No User file, Remove from Entries file.  *		U	"Update" cmd - File was checked out over User file.  *		G	"Update" cmd - File was merged successfully.  *		C	"Update" cmd - File was merged and shows overlaps.  *		M	"Commit" cmd - "Modified" file.  *		A	"Commit" cmd - "Added" file.  *		R	"Commit" cmd - "Removed" file.  *  *  date	is a fixed length 8-char hex representation of a Unix time_t.  *		[Starting here, variable fields are delimited by '|' chars.]  *  *  user	is the username of the person who typed the command.  *  *  CurDir	The directory where the action occurred.  This should be the  *		absolute path of the directory which is at the same level as  *		the "Repository" field (for W,U,G,C& M,A,R).  *  *  Repository	For record types [W,U,G,C,M,A,R] this field holds the  *		repository read from the administrative data where the  *		command was typed.  *		T	"A" --> New Tag, "D" --> Delete Tag  *			Otherwise it is the Tag or Date to modify.  *		O,F,E	A "" (null field)  *  *  rev(s)	Revision number or tag.  *		T	The Tag to apply.  *		O,E	The Tag or Date, if specified, else "" (null field).  *		F	"" (null field)  *		W	The Tag or Date, if specified, else "" (null field).  *		U	The Revision checked out over the User file.  *		G,C	The Revision(s) involved in merge.  *		M,A,R	RCS Revision affected.  *  *  argument	The module (for [TOEUF]) or file (for [WUGCMAR]) affected.  *  *  *** Report categories: "User" and "Since" modifiers apply to all reports.  *			[For "sort" ordering see the "sort_order" routine.]  *  *   Extract list of record types  *  *	-e, -x [TOEFWUGCMAR]  *  *		Extracted records are simply printed, No analysis is performed.  *		All "field" modifiers apply.  -e chooses all types.  *  *   Checked 'O'ut modules  *  *	-o, -w  *		Checked out modules.  'F' and 'O' records are examined and if  *		the last record for a repository/file is an 'O', a line is  *		printed.  "-w" forces the "working dir" to be used in the  *		comparison instead of the repository.  *  *   Committed (Modified) files  *  *	-c, -l, -w  *		All 'M'odified, 'A'dded and 'R'emoved records are examined.  *		"Field" modifiers apply.  -l forces a sort by file within user  *		and shows only the last modifier.  -w works as in Checkout.  *  *		Warning: Be careful with what you infer from the output of  *			 "cvs hi -c -l".  It means the last time *you*  *			 changed the file, not the list of files for which  *			 you were the last changer!!!  *  *   Module history for named modules.  *	-m module, -l  *  *		This is special.  If one or more modules are specified, the  *		module names are remembered and the files making up the  *		modules are remembered.  Only records matching exactly those  *		files and repositories are shown.  Sorting by "module", then  *		filename, is implied.  If -l ("last modified") is specified,  *		then "update" records (types WUCG), tag and release records  *		are ignored and the last (by date) "modified" record.  *  *   TAG history  *  *	-T	All Tag records are displayed.  *  *** Modifiers.  *  *   Since ...		[All records contain a timestamp, so any report  *			 category can be limited by date.]  *  *	-D date		- The "date" is parsed into a Unix "time_t" and  *			  records with an earlier time stamp are ignored.  *	-r rev/tag	- A "rev" begins with a digit.  A "tag" does not.  If  *			  you use this option, every file is searched for the  *			  indicated rev/tag.  *	-t tag		- The "tag" is searched for in the history file and no  *			  record is displayed before the tag is found.  An  *			  error is printed if the tag is never found.  *	-b string	- Records are printed only back to the last reference  *			  to the string in the "module", "file" or  *			  "repository" fields.  *  *   Field Selections	[Simple comparisons on existing fields.  All field  *			 selections are repeatable.]  *  *	-a		- All users.  *	-u user		- If no user is given and '-a' is not given, only  *			  records for the user typing the command are shown.  *			  ==> If -a or -u is not specified, just use "self".  *  *	-f filematch	- Only records in which the "file" field contains the  *			  string "filematch" are considered.  *  *	-p repository	- Only records in which the "repository" string is a  *			  prefix of the "repos" field are considered.  *  *	-n modulename	- Only records which contain "modulename" in the  *			  "module" field are considered.  *  *  * EXAMPLES: ("cvs history", "cvs his" or "cvs hi")  *  *** Checked out files for username.  (default self, e.g. "dgg")  *	cvs hi			[equivalent to: "cvs hi -o -u dgg"]  *	cvs hi -u user		[equivalent to: "cvs hi -o -u user"]  *	cvs hi -o		[equivalent to: "cvs hi -o -u dgg"]  *  *** Committed (modified) files from the beginning of the file.  *	cvs hi -c [-u user]  *  *** Committed (modified) files since Midnight, January 1, 1990:  *	cvs hi -c -D 'Jan 1 1990' [-u user]  *  *** Committed (modified) files since tag "TAG" was stored in the history file:  *	cvs hi -c -t TAG [-u user]  *  *** Committed (modified) files since tag "TAG" was placed on the files:  *	cvs hi -c -r TAG [-u user]  *  *** Who last committed file/repository X?  *	cvs hi -c -l -[fp] X  *  *** Modified files since tag/date/file/repos?  *	cvs hi -c {-r TAG | -D Date | -b string}  *  *** Tag history  *	cvs hi -T  *  *** History of file/repository/module X.  *	cvs hi -[fpn] X  *  *** History of user "user".  *	cvs hi -e -u user  *  *** Dump (eXtract) specified record types  *	cvs hi -x [TOFWUGCMAR]  *  *  * FUTURE:		J[Join], I[Import]  (Not currently implemented.)  *  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_struct
specifier|static
struct|struct
name|hrec
block|{
name|char
modifier|*
name|type
decl_stmt|;
comment|/* Type of record (In history record) */
name|char
modifier|*
name|user
decl_stmt|;
comment|/* Username (In history record) */
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* "Compressed" Working dir (In history record) */
name|char
modifier|*
name|repos
decl_stmt|;
comment|/* (Tag is special.) Repository (In history record) */
name|char
modifier|*
name|rev
decl_stmt|;
comment|/* Revision affected (In history record) */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Filename (In history record) */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Ptr into repository to copy at end of workdir */
name|char
modifier|*
name|mod
decl_stmt|;
comment|/* The module within which the file is contained */
name|time_t
name|date
decl_stmt|;
comment|/* Calculated from date stored in record */
name|long
name|idx
decl_stmt|;
comment|/* Index of record, for "stable" sort. */
block|}
modifier|*
name|hrec_head
struct|;
end_struct

begin_decl_stmt
specifier|static
name|long
name|hrec_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_hrec
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|line
operator|,
expr|struct
name|hrec
operator|*
name|hr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|accept_hrec
name|PROTO
argument_list|(
operator|(
expr|struct
name|hrec
operator|*
name|hr
operator|,
expr|struct
name|hrec
operator|*
name|lr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|select_hrec
name|PROTO
argument_list|(
operator|(
expr|struct
name|hrec
operator|*
name|hr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sort_order
name|PROTO
argument_list|(
operator|(
specifier|const
name|PTR
name|l
operator|,
specifier|const
name|PTR
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|within
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|find
operator|,
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expand_modules
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_hrecs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|fname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|report_hrecs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|module
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_module
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|module
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_user
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALL_REC_TYPES
value|"TOEFWUCGMAR"
end_define

begin_define
define|#
directive|define
name|USER_INCREMENT
value|2
end_define

begin_define
define|#
directive|define
name|FILE_INCREMENT
value|128
end_define

begin_define
define|#
directive|define
name|MODULE_INCREMENT
value|5
end_define

begin_define
define|#
directive|define
name|HREC_INCREMENT
value|128
end_define

begin_decl_stmt
specifier|static
name|short
name|report_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|v_checkout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|modified
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|tag_report
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|module_report
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|working
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|last_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|all_users
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|user_sort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|repos_sort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|file_sort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|module_sort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|tz_local
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|tz_seconds_east_of_GMT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tz_name
init|=
literal|"+0000"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|logHistory
init|=
name|ALL_REC_TYPES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -r, -t, or -b options, malloc'd.  These are "" if the option in    question is not specified or is overridden by another option.  The    main reason for using "" rather than NULL is historical.  Together    with since_date, these are a mutually exclusive set; one overrides the    others.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|since_rev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|since_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D option, or 0 if not specified.  RCS format.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|since_date
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hrec
modifier|*
name|last_since_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hrec
modifier|*
name|last_backto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record types to look for, malloc'd.  Probably could be statically    allocated, but only if we wanted to check for duplicates more than    we do.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rec_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hrec_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hrec_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|user_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to array of ptrs to user names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|user_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|user_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements used */
end_comment

begin_struct
specifier|static
struct|struct
name|file_list_str
block|{
name|char
modifier|*
name|l_file
decl_stmt|;
name|char
modifier|*
name|l_module
decl_stmt|;
block|}
modifier|*
name|file_list
struct|;
end_struct

begin_comment
comment|/* Ptr to array file name structs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements used */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|mod_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to array of ptrs to module names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mod_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mod_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements used */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|histfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to the history file name */
end_comment

begin_comment
comment|/* This is pretty unclear.  First of all, separating "flags" vs.    "options" (I think the distinction is that "options" take arguments)    is nonstandard, and not something we do elsewhere in CVS.  Second of    all, what does "reports" mean?  I think it means that you can only    supply one of those options, but "reports" hardly has that meaning in    a self-explanatory way.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|history_usg
index|[]
init|=
block|{
literal|"Usage: %s %s [-report] [-flags] [-options args] [files...]\n\n"
block|,
literal|"   Reports:\n"
block|,
literal|"        -T              Produce report on all TAGs\n"
block|,
literal|"        -c              Committed (Modified) files\n"
block|,
literal|"        -o              Checked out modules\n"
block|,
literal|"        -m<module>     Look for specified module (repeatable)\n"
block|,
literal|"        -x [TOEFWUCGMAR] Extract by record type\n"
block|,
literal|"        -e              Everything (same as -x, but all record types)\n"
block|,
literal|"   Flags:\n"
block|,
literal|"        -a              All users (Default is self)\n"
block|,
literal|"        -l              Last modified (committed or modified report)\n"
block|,
literal|"        -w              Working directory must match\n"
block|,
literal|"   Options:\n"
block|,
literal|"        -D<date>       Since date (Many formats)\n"
block|,
literal|"        -b<str>        Back to record with str in module/file/repos field\n"
block|,
literal|"        -f<file>       Specified file (same as command line) (repeatable)\n"
block|,
literal|"        -n<modulename> In module (repeatable)\n"
block|,
literal|"        -p<repos>      In repository (repeatable)\n"
block|,
literal|"        -r<rev/tag>    Since rev or tag (looks inside RCS files!)\n"
block|,
literal|"        -t<tag>        Since tag record placed in history file (by anyone).\n"
block|,
literal|"        -u<user>       For user name (repeatable)\n"
block|,
literal|"        -z<tz>         Output for time zone<tz> (e.g. -z -0700)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sort routine for qsort:    - If a user is selected at all, sort it first. User-within-file is useless.    - If a module was selected explicitly, sort next on module.    - Then sort by file.  "File" is "repository/file" unless "working" is set,      then it is "workdir/file".  (Revision order should always track date.)    - Always sort timestamp last. */
end_comment

begin_function
specifier|static
name|int
name|sort_order
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
specifier|const
name|PTR
name|l
decl_stmt|;
specifier|const
name|PTR
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|hrec
modifier|*
name|left
init|=
operator|(
specifier|const
expr|struct
name|hrec
operator|*
operator|)
name|l
decl_stmt|;
specifier|const
name|struct
name|hrec
modifier|*
name|right
init|=
operator|(
specifier|const
expr|struct
name|hrec
operator|*
operator|)
name|r
decl_stmt|;
if|if
condition|(
name|user_sort
condition|)
comment|/* If Sort by username, compare users */
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|user
argument_list|,
name|right
operator|->
name|user
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|module_sort
condition|)
comment|/* If sort by modules, compare module names */
block|{
if|if
condition|(
name|left
operator|->
name|mod
operator|&&
name|right
operator|->
name|mod
condition|)
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|mod
argument_list|,
name|right
operator|->
name|mod
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|repos_sort
condition|)
comment|/* If sort by repository, compare them. */
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|repos
argument_list|,
name|right
operator|->
name|repos
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|file_sort
condition|)
comment|/* If sort by filename, compare files, NOT dirs. */
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|file
argument_list|,
name|right
operator|->
name|file
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
name|working
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|dir
argument_list|,
name|right
operator|->
name|dir
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|strcmp
argument_list|(
name|left
operator|->
name|end
argument_list|,
name|right
operator|->
name|end
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
comment|/*      * By default, sort by date, time      * XXX: This fails after 2030 when date slides into sign bit      */
if|if
condition|(
operator|(
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|left
operator|->
name|date
argument_list|)
operator|-
call|(
name|long
call|)
argument_list|(
name|right
operator|->
name|date
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
comment|/* For matching dates, keep the sort stable by using record index */
return|return
operator|(
name|left
operator|->
name|idx
operator|-
name|right
operator|->
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|history
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|history_usg
argument_list|)
expr_stmt|;
name|since_rev
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|since_tag
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|backto
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+Tacelow?D:b:f:m:n:p:r:t:u:x:X:z:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* Tag list */
name|report_count
operator|++
expr_stmt|;
name|tag_report
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* For all usernames */
name|all_users
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|report_count
operator|++
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|report_count
operator|++
expr_stmt|;
name|extract
operator|++
expr_stmt|;
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
name|ALL_REC_TYPES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Find Last file record */
name|last_entry
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|report_count
operator|++
expr_stmt|;
name|v_checkout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Match Working Dir (CurDir) fields */
name|working
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Undocumented debugging flag */
name|histfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Since specified date */
if|if
condition|(
operator|*
name|since_rev
operator|||
operator|*
name|since_tag
operator|||
operator|*
name|backto
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"date overriding rev/tag/backto"
argument_list|)
expr_stmt|;
operator|*
name|since_rev
operator|=
operator|*
name|since_tag
operator|=
operator|*
name|backto
operator|=
literal|'\0'
expr_stmt|;
block|}
name|since_date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Since specified file/Repos */
if|if
condition|(
name|since_date
operator|||
operator|*
name|since_rev
operator|||
operator|*
name|since_tag
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"backto overriding date/rev/tag"
argument_list|)
expr_stmt|;
operator|*
name|since_rev
operator|=
operator|*
name|since_tag
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|since_date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|since_date
argument_list|)
expr_stmt|;
name|since_date
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|backto
argument_list|)
expr_stmt|;
name|backto
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* For specified file */
name|save_file
argument_list|(
literal|""
argument_list|,
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Full module report */
if|if
condition|(
operator|!
name|module_report
operator|++
condition|)
name|report_count
operator|++
expr_stmt|;
comment|/* fall through */
case|case
literal|'n'
case|:
comment|/* Look for specified module */
name|save_module
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* For specified directory */
name|save_file
argument_list|(
name|optarg
argument_list|,
literal|""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Since specified Tag/Rev */
if|if
condition|(
name|since_date
operator|||
operator|*
name|since_tag
operator|||
operator|*
name|backto
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"rev overriding date/tag/backto"
argument_list|)
expr_stmt|;
operator|*
name|since_tag
operator|=
operator|*
name|backto
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|since_date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|since_date
argument_list|)
expr_stmt|;
name|since_date
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|since_rev
argument_list|)
expr_stmt|;
name|since_rev
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Since specified Tag/Rev */
if|if
condition|(
name|since_date
operator|||
operator|*
name|since_rev
operator|||
operator|*
name|backto
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"tag overriding date/marker/file/repos"
argument_list|)
expr_stmt|;
operator|*
name|since_rev
operator|=
operator|*
name|backto
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|since_date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|since_date
argument_list|)
expr_stmt|;
name|since_date
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|since_tag
argument_list|)
expr_stmt|;
name|since_tag
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* For specified username */
name|save_user
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|report_count
operator|++
expr_stmt|;
name|extract
operator|++
expr_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|optarg
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|ALL_REC_TYPES
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%c is not a valid report type"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|tz_local
operator|=
operator|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|optarg
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|optarg
index|[
literal|1
index|]
operator|==
literal|'T'
operator|)
operator|&&
operator|!
name|optarg
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|tz_local
condition|)
name|tz_name
operator|=
name|optarg
expr_stmt|;
else|else
block|{
comment|/* 		     * Convert a known time with the given timezone to time_t. 		     * Use the epoch + 23 hours, so timezones east of GMT work. 		     */
specifier|static
name|char
name|f
index|[]
init|=
literal|"1/1/1970 23:00 %s"
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|f
argument_list|)
operator|-
literal|2
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|f
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_date
argument_list|(
name|buf
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is not a known time zone"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * Convert to seconds east of GMT, removing the 			 * 23-hour offset mentioned above. 			 */
name|tz_seconds_east_of_GMT
operator|=
operator|(
name|time_t
operator|)
literal|23
operator|*
literal|60
operator|*
literal|60
operator|-
name|t
expr_stmt|;
name|tz_name
operator|=
name|optarg
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|history_usg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|save_file
argument_list|(
literal|""
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* ================ Now analyze the arguments a bit */
if|if
condition|(
operator|!
name|report_count
condition|)
name|v_checkout
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|report_count
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Only one report type allowed from: \"-Tcomxe\"."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
name|struct
name|file_list_str
modifier|*
name|f1
decl_stmt|;
name|char
modifier|*
modifier|*
name|mod
decl_stmt|;
comment|/* We're the client side.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_report
condition|)
name|send_arg
argument_list|(
literal|"-T"
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_users
condition|)
name|send_arg
argument_list|(
literal|"-a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
condition|)
name|send_arg
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_entry
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_checkout
condition|)
name|send_arg
argument_list|(
literal|"-o"
argument_list|)
expr_stmt|;
if|if
condition|(
name|working
condition|)
name|send_arg
argument_list|(
literal|"-w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|histfile
condition|)
name|send_arg
argument_list|(
literal|"-X"
argument_list|)
expr_stmt|;
if|if
condition|(
name|since_date
condition|)
name|client_senddate
argument_list|(
name|since_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|backto
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|option_with_arg
argument_list|(
literal|"-b"
argument_list|,
name|backto
argument_list|)
expr_stmt|;
for|for
control|(
name|f1
operator|=
name|file_list
init|;
name|f1
operator|<
operator|&
name|file_list
index|[
name|file_count
index|]
condition|;
operator|++
name|f1
control|)
block|{
if|if
condition|(
name|f1
operator|->
name|l_file
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|option_with_arg
argument_list|(
literal|"-p"
argument_list|,
name|f1
operator|->
name|l_file
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|option_with_arg
argument_list|(
literal|"-f"
argument_list|,
name|f1
operator|->
name|l_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|module_report
condition|)
name|send_arg
argument_list|(
literal|"-m"
argument_list|)
expr_stmt|;
for|for
control|(
name|mod
operator|=
name|mod_list
init|;
name|mod
operator|<
operator|&
name|mod_list
index|[
name|mod_count
index|]
condition|;
operator|++
name|mod
control|)
name|option_with_arg
argument_list|(
literal|"-n"
argument_list|,
operator|*
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|since_rev
condition|)
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|since_rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|since_tag
condition|)
name|option_with_arg
argument_list|(
literal|"-t"
argument_list|,
name|since_tag
argument_list|)
expr_stmt|;
for|for
control|(
name|mod
operator|=
name|user_list
init|;
name|mod
operator|<
operator|&
name|user_list
index|[
name|user_count
index|]
condition|;
operator|++
name|mod
control|)
name|option_with_arg
argument_list|(
literal|"-u"
argument_list|,
operator|*
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract
condition|)
name|option_with_arg
argument_list|(
literal|"-x"
argument_list|,
name|rec_types
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-z"
argument_list|,
name|tz_name
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"history\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|all_users
condition|)
name|save_user
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_list
condition|)
name|expand_modules
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_report
condition|)
block|{
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|rec_types
argument_list|,
literal|'T'
argument_list|)
condition|)
block|{
name|rec_types
operator|=
name|xrealloc
argument_list|(
name|rec_types
argument_list|,
name|strlen
argument_list|(
name|rec_types
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rec_types
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|extract
condition|)
block|{
if|if
condition|(
name|user_list
condition|)
name|user_sort
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified
condition|)
block|{
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
literal|"MAR"
argument_list|)
expr_stmt|;
comment|/* 	 * If the user has not specified a date oriented flag ("Since"), sort 	 * by Repository/file before date.  Default is "just" date. 	 */
if|if
condition|(
name|last_entry
operator|||
operator|(
operator|!
name|since_date
operator|&&
operator|!
operator|*
name|since_rev
operator|&&
operator|!
operator|*
name|since_tag
operator|&&
operator|!
operator|*
name|backto
operator|)
condition|)
block|{
name|repos_sort
operator|++
expr_stmt|;
name|file_sort
operator|++
expr_stmt|;
comment|/* 	     * If we are not looking for last_modified and the user specified 	     * one or more users to look at, sort by user before filename. 	     */
if|if
condition|(
operator|!
name|last_entry
operator|&&
name|user_list
condition|)
name|user_sort
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|module_report
condition|)
block|{
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
name|last_entry
condition|?
literal|"OMAR"
else|:
name|ALL_REC_TYPES
argument_list|)
expr_stmt|;
name|module_sort
operator|++
expr_stmt|;
name|repos_sort
operator|++
expr_stmt|;
name|file_sort
operator|++
expr_stmt|;
name|working
operator|=
literal|0
expr_stmt|;
comment|/* User's workdir doesn't count here */
block|}
else|else
comment|/* Must be "checkout" or default */
block|{
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
name|rec_types
operator|=
name|xstrdup
argument_list|(
literal|"OF"
argument_list|)
expr_stmt|;
comment|/* See comments in "modified" above */
if|if
condition|(
operator|!
name|last_entry
operator|&&
name|user_list
condition|)
name|user_sort
operator|++
expr_stmt|;
if|if
condition|(
name|last_entry
operator|||
operator|(
operator|!
name|since_date
operator|&&
operator|!
operator|*
name|since_rev
operator|&&
operator|!
operator|*
name|since_tag
operator|&&
operator|!
operator|*
name|backto
operator|)
condition|)
name|file_sort
operator|++
expr_stmt|;
block|}
comment|/* If no users were specified, use self (-a saves a universal ("") user) */
if|if
condition|(
operator|!
name|user_list
condition|)
name|save_user
argument_list|(
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If we're looking back to a Tag value, must consider "Tag" records */
if|if
condition|(
operator|*
name|since_tag
operator|&&
operator|!
name|strchr
argument_list|(
name|rec_types
argument_list|,
literal|'T'
argument_list|)
condition|)
block|{
name|rec_types
operator|=
name|xrealloc
argument_list|(
name|rec_types
argument_list|,
name|strlen
argument_list|(
name|rec_types
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|rec_types
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|histfile
condition|)
name|fname
operator|=
name|xstrdup
argument_list|(
name|histfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_HISTORY
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
block|}
name|read_hrecs
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hrec_count
operator|>
literal|0
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|hrec_head
argument_list|,
name|hrec_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hrec
argument_list|)
argument_list|,
name|sort_order
argument_list|)
expr_stmt|;
block|}
name|report_hrecs
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|since_date
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|since_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|since_rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|since_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backto
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rec_types
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|history_write
parameter_list|(
name|type
parameter_list|,
name|update_dir
parameter_list|,
name|revs
parameter_list|,
name|name
parameter_list|,
name|repository
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|revs
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|workdir
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|getcaller
argument_list|()
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|slash
init|=
literal|""
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|repos
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|tilde
init|=
literal|""
decl_stmt|;
specifier|static
name|char
modifier|*
name|PrCurDir
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|logoff
condition|)
comment|/* History is turned off by cmd line switch */
return|return;
if|if
condition|(
name|strchr
argument_list|(
name|logHistory
argument_list|,
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_HISTORY
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
comment|/* turn off history logging if the history file does not exist */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|logoff
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> fopen(%s,a)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
goto|goto
name|out
goto|;
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
operator||
name|OPEN_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot write to history file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|repos
operator|=
name|Short_Repository
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PrCurDir
condition|)
block|{
name|char
modifier|*
name|pwdir
decl_stmt|;
name|pwdir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
name|PrCurDir
operator|=
name|CurDir
expr_stmt|;
if|if
condition|(
name|pwdir
operator|!=
name|NULL
condition|)
block|{
comment|/* Assumes neither CurDir nor pwdir ends in '/' */
name|i
operator|=
name|strlen
argument_list|(
name|pwdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|CurDir
argument_list|,
name|pwdir
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|PrCurDir
operator|+=
name|i
expr_stmt|;
comment|/* Point to '/' separator */
name|tilde
operator|=
literal|"~"
expr_stmt|;
block|}
else|else
block|{
comment|/* Try harder to find a "homedir" */
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|pwdir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't chdir(%s)"
argument_list|,
name|pwdir
argument_list|)
expr_stmt|;
name|homedir
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|homedir
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't getwd in %s"
argument_list|,
name|pwdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|CurDir
argument_list|,
name|homedir
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|PrCurDir
operator|+=
name|i
expr_stmt|;
comment|/* Point to '/' separator */
name|tilde
operator|=
literal|"~"
expr_stmt|;
block|}
name|free
argument_list|(
name|homedir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|'T'
condition|)
block|{
name|repos
operator|=
name|update_dir
expr_stmt|;
name|update_dir
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|update_dir
operator|&&
operator|*
name|update_dir
condition|)
name|slash
operator|=
literal|"/"
expr_stmt|;
else|else
name|update_dir
operator|=
literal|""
expr_stmt|;
name|workdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tilde
argument_list|)
operator|+
name|strlen
argument_list|(
name|PrCurDir
argument_list|)
operator|+
name|strlen
argument_list|(
name|slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|update_dir
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|workdir
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|tilde
argument_list|,
name|PrCurDir
argument_list|,
name|slash
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/*      * "workdir" is the directory where the file "name" is. ("^~" == $HOME)      * "repos"	is the Repository, relative to $CVSROOT where the RCS file is.      *      * "$workdir/$name" is the working file name.      * "$CVSROOT/$repos/$name,v" is the RCS file in the Repository.      *      * First, note that the history format was intended to save space, not      * to be human readable.      *      * The working file directory ("workdir") and the Repository ("repos")      * usually end with the same one or more directory elements.  To avoid      * duplication (and save space), the "workdir" field ends with      * an integer offset into the "repos" field.  This offset indicates the      * beginning of the "tail" of "repos", after which all characters are      * duplicates.      *      * In other words, if the "workdir" field has a '*' (a very stupid thing      * to put in a filename) in it, then every thing following the last '*'      * is a hex offset into "repos" of the first character from "repos" to      * append to "workdir" to finish the pathname.      *      * It might be easier to look at an example:      *      *  M273b3463|dgg|~/work*9|usr/local/cvs/examples|1.2|loginfo      *      * Indicates that the workdir is really "~/work/cvs/examples", saving      * 10 characters, where "~/work*d" would save 6 characters and mean that      * the workdir is really "~/work/examples".  It will mean more on      * directories like: usr/local/gnu/emacs/dist-19.17/lisp/term      *      * "workdir" is always an absolute pathname (~/xxx is an absolute path)      * "repos" is always a relative pathname.  So we can assume that we will      * never run into the top of "workdir" -- there will always be a '/' or      * a '~' at the head of "workdir" that is not matched by anything in      * "repos".  On the other hand, we *can* run off the top of "repos".      *      * Only "compress" if we save characters.      */
if|if
condition|(
operator|!
name|repos
condition|)
name|repos
operator|=
literal|""
expr_stmt|;
name|cp
operator|=
name|workdir
operator|+
name|strlen
argument_list|(
name|workdir
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cp2
operator|=
name|repos
operator|+
name|strlen
argument_list|(
name|repos
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cp2
operator|>=
name|repos
operator|&&
name|cp
operator|>
name|workdir
operator|&&
operator|*
name|cp
operator|==
operator|*
name|cp2
operator|--
condition|;
name|cp
operator|--
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|repos
argument_list|)
operator|-
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
literal|"*%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|revs
condition|)
name|revs
operator|=
literal|""
expr_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
name|strlen
argument_list|(
name|workdir
argument_list|)
operator|+
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|revs
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%08lx|%s|%s|%s|%s|%s\n"
argument_list|,
name|type
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|username
argument_list|,
name|workdir
argument_list|,
name|repos
argument_list|,
name|revs
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Lessen some race conditions on non-Posix-compliant hosts.  */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot seek to end of history file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write to history file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close history file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|workdir
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * save_user() adds a user name to the user list to select.  Zero-length  *		username ("") matches any user.  */
end_comment

begin_function
specifier|static
name|void
name|save_user
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|user_count
operator|==
name|user_max
condition|)
block|{
name|user_max
operator|+=
name|USER_INCREMENT
expr_stmt|;
name|user_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|user_list
argument_list|,
operator|(
name|int
operator|)
name|user_max
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|user_list
index|[
name|user_count
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * save_file() adds file name and associated module to the file list to select.  *  * If "dir" is null, store a file name as is.  * If "name" is null, store a directory name with a '*' on the front.  * Else, store concatenated "dir/name".  *  * Later, in the "select" stage:  *	- if it starts with '*', it is prefix-matched against the repository.  *	- if it has a '/' in it, it is matched against the repository/file.  *	- else it is matched against the file name.  */
end_comment

begin_function
specifier|static
name|void
name|save_file
parameter_list|(
name|dir
parameter_list|,
name|name
parameter_list|,
name|module
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|module
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|file_list_str
modifier|*
name|fl
decl_stmt|;
if|if
condition|(
name|file_count
operator|==
name|file_max
condition|)
block|{
name|file_max
operator|+=
name|FILE_INCREMENT
expr_stmt|;
name|file_list
operator|=
operator|(
expr|struct
name|file_list_str
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_list
argument_list|,
name|file_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fl
operator|=
operator|&
name|file_list
index|[
name|file_count
operator|++
index|]
expr_stmt|;
name|fl
operator|->
name|l_file
operator|=
name|cp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fl
operator|->
name|l_module
operator|=
name|module
expr_stmt|;
if|if
condition|(
name|dir
operator|&&
operator|*
name|dir
condition|)
block|{
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"save_file: null dir and file name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|save_module
parameter_list|(
name|module
parameter_list|)
name|char
modifier|*
name|module
decl_stmt|;
block|{
if|if
condition|(
name|mod_count
operator|==
name|mod_max
condition|)
block|{
name|mod_max
operator|+=
name|MODULE_INCREMENT
expr_stmt|;
name|mod_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mod_list
argument_list|,
name|mod_max
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mod_list
index|[
name|mod_count
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|module
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expand_modules
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* fill_hrec  *  * Take a ptr to 7-part history line, ending with a newline, for example:  *  *	M273b3463|dgg|~/work*9|usr/local/cvs/examples|1.2|loginfo  *  * Split it into 7 parts and drop the parts into a "struct hrec".  * Return a pointer to the character following the newline.  *   */
end_comment

begin_define
define|#
directive|define
name|NEXT_BAR
parameter_list|(
name|here
parameter_list|)
value|do { \ 	while (isspace(*line)) line++; \ 	hr->here = line; \ 	while ((c = *line++)&& c != '|') ; \ 	if (!c) return; line[-1] = '\0'; \ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|fill_hrec
parameter_list|(
name|line
parameter_list|,
name|hr
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|struct
name|hrec
modifier|*
name|hr
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|hr
operator|->
name|type
operator|=
name|hr
operator|->
name|user
operator|=
name|hr
operator|->
name|dir
operator|=
name|hr
operator|->
name|repos
operator|=
name|hr
operator|->
name|rev
operator|=
name|hr
operator|->
name|file
operator|=
name|hr
operator|->
name|end
operator|=
name|hr
operator|->
name|mod
operator|=
name|NULL
expr_stmt|;
name|hr
operator|->
name|date
operator|=
operator|-
literal|1
expr_stmt|;
name|hr
operator|->
name|idx
operator|=
operator|++
name|hrec_idx
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
name|hr
operator|->
name|type
operator|=
name|line
operator|++
expr_stmt|;
name|hr
operator|->
name|date
operator|=
name|strtoul
argument_list|(
name|line
argument_list|,
operator|&
name|cp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|line
operator|||
operator|*
name|cp
operator|!=
literal|'|'
condition|)
return|return;
name|line
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|NEXT_BAR
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|NEXT_BAR
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|hr
operator|->
name|dir
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|hr
operator|->
name|end
operator|=
name|line
operator|+
name|strtoul
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|hr
operator|->
name|end
operator|=
name|line
operator|-
literal|1
expr_stmt|;
comment|/* A handy pointer to '\0' */
name|NEXT_BAR
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|NEXT_BAR
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"FOET"
argument_list|,
operator|*
operator|(
name|hr
operator|->
name|type
operator|)
argument_list|)
condition|)
name|hr
operator|->
name|mod
operator|=
name|line
expr_stmt|;
name|NEXT_BAR
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|STAT_BLOCKSIZE
end_ifndef

begin_if
if|#
directive|if
name|HAVE_ST_BLKSIZE
end_if

begin_define
define|#
directive|define
name|STAT_BLOCKSIZE
parameter_list|(
name|s
parameter_list|)
value|(s).st_blksize
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAT_BLOCKSIZE
parameter_list|(
name|s
parameter_list|)
value|(4 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* read_hrecs's job is to read the history file and fill in all the "hrec"  * (history record) array elements with the ones we need to print.  *  * Logic:  * - Read a block from the file.   * - Walk through the block parsing line into hr records.   * - if the hr isn't used, free its strings, if it is, bump the hrec counter  * - at the end of a block, copy the end of the current block to the start   * of space for the next block, then read in the next block.  If we get less  * than the whole block, we're done.   */
end_comment

begin_function
specifier|static
name|void
name|read_hrecs
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|cpstart
decl_stmt|,
modifier|*
name|cpend
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|char
modifier|*
name|hrline
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|st_buf
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open history file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st_buf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't stat history file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|st_buf
operator|.
name|st_size
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"history file is empty"
argument_list|)
expr_stmt|;
name|cpstart
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|STAT_BLOCKSIZE
argument_list|(
name|st_buf
argument_list|)
argument_list|)
expr_stmt|;
name|cpstart
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|cpend
operator|=
name|cpstart
expr_stmt|;
name|hrec_max
operator|=
name|HREC_INCREMENT
expr_stmt|;
name|hrec_head
operator|=
name|xmalloc
argument_list|(
name|hrec_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hrec
argument_list|)
argument_list|)
expr_stmt|;
name|hrec_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|nl
operator|=
name|cp
init|;
name|nl
operator|<
name|cpend
operator|&&
operator|*
name|nl
operator|!=
literal|'\n'
condition|;
name|nl
operator|++
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|nl
argument_list|)
condition|)
operator|*
name|nl
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|nl
operator|>=
name|cpend
condition|)
block|{
if|if
condition|(
name|nl
operator|-
name|cp
operator|>=
name|STAT_BLOCKSIZE
argument_list|(
name|st_buf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"history line %ld too long (> %lu)"
argument_list|,
name|hrec_idx
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|STAT_BLOCKSIZE
argument_list|(
name|st_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nl
operator|>
name|cp
condition|)
name|memmove
argument_list|(
name|cpstart
argument_list|,
name|cp
argument_list|,
name|nl
operator|-
name|cp
argument_list|)
expr_stmt|;
name|nl
operator|=
name|cpstart
operator|+
operator|(
name|nl
operator|-
name|cp
operator|)
expr_stmt|;
name|cp
operator|=
name|cpstart
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|nl
argument_list|,
name|STAT_BLOCKSIZE
argument_list|(
name|st_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|cpend
operator|=
name|nl
operator|+
name|i
expr_stmt|;
operator|*
name|cpend
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"error reading history file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|==
name|cp
condition|)
break|break;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: no newline at end of history file"
argument_list|)
expr_stmt|;
block|}
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|hrec_count
operator|==
name|hrec_max
condition|)
block|{
name|struct
name|hrec
modifier|*
name|old_head
init|=
name|hrec_head
decl_stmt|;
name|hrec_max
operator|+=
name|HREC_INCREMENT
expr_stmt|;
name|hrec_head
operator|=
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hrec_head
argument_list|,
name|hrec_max
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hrec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_since_tag
condition|)
name|last_since_tag
operator|=
name|hrec_head
operator|+
operator|(
name|last_since_tag
operator|-
name|old_head
operator|)
expr_stmt|;
if|if
condition|(
name|last_backto
condition|)
name|last_backto
operator|=
name|hrec_head
operator|+
operator|(
name|last_backto
operator|-
name|old_head
operator|)
expr_stmt|;
block|}
comment|/* fill_hrec dates from when history read the entire  	   history file in one chunk, and then records were pulled out 	   by pointing to the various parts of this big chunk.  This is 	   why there are ugly hacks here:  I don't want to completely 	   re-write the whole history stuff right now.  */
name|hrline
operator|=
name|xstrdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|fill_hrec
argument_list|(
name|hrline
argument_list|,
operator|&
name|hrec_head
index|[
name|hrec_count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_hrec
argument_list|(
operator|&
name|hrec_head
index|[
name|hrec_count
index|]
argument_list|)
condition|)
name|hrec_count
operator|++
expr_stmt|;
else|else
name|free
argument_list|(
name|hrline
argument_list|)
expr_stmt|;
name|cp
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|cpstart
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Special selection problem: If "since_tag" is set, we have saved every      * record from the 1st occurrence of "since_tag", when we want to save      * records since the *last* occurrence of "since_tag".  So what we have      * to do is bump hrec_head forward and reduce hrec_count accordingly.      */
if|if
condition|(
name|last_since_tag
condition|)
block|{
name|hrec_count
operator|-=
operator|(
name|last_since_tag
operator|-
name|hrec_head
operator|)
expr_stmt|;
name|hrec_head
operator|=
name|last_since_tag
expr_stmt|;
block|}
comment|/* Much the same thing is necessary for the "backto" option. */
if|if
condition|(
name|last_backto
condition|)
block|{
name|hrec_count
operator|-=
operator|(
name|last_backto
operator|-
name|hrec_head
operator|)
expr_stmt|;
name|hrec_head
operator|=
name|last_backto
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Utility program for determining whether "find" is inside "string" */
end_comment

begin_function
specifier|static
name|int
name|within
parameter_list|(
name|find
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|find
decl_stmt|,
decl|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|find
operator|||
operator|!
name|string
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
operator|*
name|find
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|find
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|string
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
name|c
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|find
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The purpose of "select_hrec" is to apply the selection criteria based on  * the command arguments and defaults and return a flag indicating whether  * this record should be remembered for printing.  */
end_comment

begin_function
specifier|static
name|int
name|select_hrec
parameter_list|(
name|hr
parameter_list|)
name|struct
name|hrec
modifier|*
name|hr
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|struct
name|file_list_str
modifier|*
name|fl
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* basic validity checking */
if|if
condition|(
operator|!
name|hr
operator|->
name|type
operator|||
operator|!
name|hr
operator|->
name|user
operator|||
operator|!
name|hr
operator|->
name|dir
operator|||
operator|!
name|hr
operator|->
name|repos
operator|||
operator|!
name|hr
operator|->
name|rev
operator|||
operator|!
name|hr
operator|->
name|file
operator|||
operator|!
name|hr
operator|->
name|end
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: history line %ld invalid"
argument_list|,
name|hr
operator|->
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* "Since" checking:  The argument parser guarantees that only one of the      *			  following four choices is set:      *      * 1. If "since_date" is set, it contains the date specified on the      *    command line. hr->date fields earlier than "since_date" are ignored.      * 2. If "since_rev" is set, it contains either an RCS "dotted" revision      *    number (which is of limited use) or a symbolic TAG.  Each RCS file      *    is examined and the date on the specified revision (or the revision      *    corresponding to the TAG) in the RCS file (CVSROOT/repos/file) is      *    compared against hr->date as in 1. above.      * 3. If "since_tag" is set, matching tag records are saved.  The field      *    "last_since_tag" is set to the last one of these.  Since we don't      *    know where the last one will be, all records are saved from the      *    first occurrence of the TAG.  Later, at the end of "select_hrec"      *    records before the last occurrence of "since_tag" are skipped.      * 4. If "backto" is set, all records with a module name or file name      *    matching "backto" are saved.  In addition, all records with a      *    repository field with a *prefix* matching "backto" are saved.      *    The field "last_backto" is set to the last one of these.  As in      *    3. above, "select_hrec" adjusts to include the last one later on.      */
if|if
condition|(
name|since_date
condition|)
block|{
name|char
modifier|*
name|ourdate
init|=
name|date_from_time_t
argument_list|(
name|hr
operator|->
name|date
argument_list|)
decl_stmt|;
name|count
operator|=
name|RCS_datecmp
argument_list|(
name|ourdate
argument_list|,
name|since_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ourdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|since_rev
condition|)
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|file_info
name|finfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|finfo
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|hr
operator|->
name|file
expr_stmt|;
comment|/* Not used, so don't worry about it.  */
name|finfo
operator|.
name|update_dir
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|fullname
operator|=
name|finfo
operator|.
name|file
expr_stmt|;
name|finfo
operator|.
name|repository
operator|=
name|hr
operator|->
name|repos
expr_stmt|;
name|finfo
operator|.
name|entries
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|since_rev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_rcs
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|RCS_getrevtime
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|hr
operator|->
name|date
operator|<
name|t
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|since_tag
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|hr
operator|->
name|type
operator|)
operator|==
literal|'T'
condition|)
block|{
comment|/* 	     * A 'T'ag record, the "rev" field holds the tag to be set, 	     * while the "repos" field holds "D"elete, "A"dd or a rev. 	     */
if|if
condition|(
name|within
argument_list|(
name|since_tag
argument_list|,
name|hr
operator|->
name|rev
argument_list|)
condition|)
block|{
name|last_since_tag
operator|=
name|hr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|last_since_tag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|backto
condition|)
block|{
if|if
condition|(
name|within
argument_list|(
name|backto
argument_list|,
name|hr
operator|->
name|file
argument_list|)
operator|||
name|within
argument_list|(
name|backto
argument_list|,
name|hr
operator|->
name|mod
argument_list|)
operator|||
name|within
argument_list|(
name|backto
argument_list|,
name|hr
operator|->
name|repos
argument_list|)
condition|)
name|last_backto
operator|=
name|hr
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* User checking:      *      * Run down "user_list", match username ("" matches anything)      * If "" is not there and actual username is not there, return failure.      */
if|if
condition|(
name|user_list
operator|&&
name|hr
operator|->
name|user
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|user_list
operator|,
name|count
operator|=
name|user_count
init|;
name|count
condition|;
name|cpp
operator|++
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
operator|!
operator|*
operator|*
name|cpp
condition|)
break|break;
comment|/* null user == accept */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hr
operator|->
name|user
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
comment|/* found listed user */
break|break;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not this user */
block|}
comment|/* Record type checking:      *      * 1. If Record type is not in rec_types field, skip it.      * 2. If mod_list is null, keep everything.  Otherwise keep only modules      *    on mod_list.      * 3. If neither a 'T', 'F' nor 'O' record, run through "file_list".  If      *    file_list is null, keep everything.  Otherwise, keep only files on      *    file_list, matched appropriately.      */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|rec_types
argument_list|,
operator|*
operator|(
name|hr
operator|->
name|type
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"TFOE"
argument_list|,
operator|*
operator|(
name|hr
operator|->
name|type
operator|)
argument_list|)
condition|)
comment|/* Don't bother with "file" if "TFOE" */
block|{
if|if
condition|(
name|file_list
condition|)
comment|/* If file_list is null, accept all */
block|{
for|for
control|(
name|fl
operator|=
name|file_list
operator|,
name|count
operator|=
name|file_count
init|;
name|count
condition|;
name|fl
operator|++
operator|,
name|count
operator|--
control|)
block|{
comment|/* 1. If file_list entry starts with '*', skip the '*' and 		 *    compare it against the repository in the hrec. 		 * 2. If file_list entry has a '/' in it, compare it against 		 *    the concatenation of the repository and file from hrec. 		 * 3. Else compare the file_list entry against the hrec file. 		 */
name|char
modifier|*
name|cmpfile
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|fl
operator|->
name|l_file
operator|)
operator|==
literal|'*'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* if argument to -p is a prefix of repository */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
argument_list|,
name|hr
operator|->
name|repos
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
condition|)
block|{
name|hr
operator|->
name|mod
operator|=
name|fl
operator|->
name|l_module
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|cmpfile
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|hr
operator|->
name|repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|hr
operator|->
name|file
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmpfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|hr
operator|->
name|repos
argument_list|,
name|hr
operator|->
name|file
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|cmpfile
expr_stmt|;
block|}
else|else
block|{
name|cp2
operator|=
name|hr
operator|->
name|file
expr_stmt|;
block|}
comment|/* if requested file is found within {repos}/file fields */
if|if
condition|(
name|within
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|)
condition|)
block|{
name|hr
operator|->
name|mod
operator|=
name|fl
operator|->
name|l_module
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmpfile
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmpfile
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* String specified and no match */
block|}
block|}
if|if
condition|(
name|mod_list
condition|)
block|{
for|for
control|(
name|cpp
operator|=
name|mod_list
operator|,
name|count
operator|=
name|mod_count
init|;
name|count
condition|;
name|cpp
operator|++
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
name|hr
operator|->
name|mod
operator|&&
operator|!
name|strcmp
argument_list|(
name|hr
operator|->
name|mod
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
comment|/* found module */
break|break;
block|}
if|if
condition|(
operator|!
name|count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Module specified& this record is not one of them. */
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Select this record unless rejected above. */
block|}
end_function

begin_comment
comment|/* The "sort_order" routine (when handed to qsort) has arranged for the  * hrecs files to be in the right order for the report.  *  * Most of the "selections" are done in the select_hrec routine, but some  * selections are more easily done after the qsort by "accept_hrec".  */
end_comment

begin_function
specifier|static
name|void
name|report_hrecs
parameter_list|()
block|{
name|struct
name|hrec
modifier|*
name|hr
decl_stmt|,
modifier|*
name|lr
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|ty
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|user_len
decl_stmt|,
name|file_len
decl_stmt|,
name|rev_len
decl_stmt|,
name|mod_len
decl_stmt|,
name|repos_len
decl_stmt|;
if|if
condition|(
operator|*
name|since_tag
operator|&&
operator|!
name|last_since_tag
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No tag found: %s\n"
argument_list|,
name|since_tag
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|backto
operator|&&
operator|!
name|last_backto
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No module, file or repository with: %s\n"
argument_list|,
name|backto
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|hrec_count
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No records selected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|user_len
operator|=
name|file_len
operator|=
name|rev_len
operator|=
name|mod_len
operator|=
name|repos_len
operator|=
literal|0
expr_stmt|;
comment|/* Run through lists and find maximum field widths */
name|hr
operator|=
name|lr
operator|=
name|hrec_head
expr_stmt|;
name|hr
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
name|hrec_count
init|;
name|count
operator|--
condition|;
name|lr
operator|=
name|hr
operator|,
name|hr
operator|++
control|)
block|{
name|char
modifier|*
name|repos
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
name|hr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|accept_hrec
argument_list|(
name|lr
argument_list|,
name|hr
argument_list|)
condition|)
continue|continue;
name|ty
operator|=
operator|*
operator|(
name|lr
operator|->
name|type
operator|)
expr_stmt|;
name|repos
operator|=
name|xstrdup
argument_list|(
name|lr
operator|->
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repos
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lr
operator|->
name|mod
operator|&&
operator|!
name|strcmp
argument_list|(
operator|++
name|cp
argument_list|,
name|lr
operator|->
name|mod
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|lr
operator|->
name|user
argument_list|)
operator|)
operator|>
name|user_len
condition|)
name|user_len
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|lr
operator|->
name|file
argument_list|)
operator|)
operator|>
name|file_len
condition|)
name|file_len
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
literal|'T'
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|repos
argument_list|)
operator|)
operator|>
name|repos_len
condition|)
name|repos_len
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
literal|'T'
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|lr
operator|->
name|rev
argument_list|)
operator|)
operator|>
name|rev_len
condition|)
name|rev_len
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|mod
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|lr
operator|->
name|mod
argument_list|)
operator|)
operator|>
name|mod_len
condition|)
name|mod_len
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
comment|/* Walk through hrec array setting "lr" (Last Record) to each element.      * "hr" points to the record following "lr" -- It is NULL in the last      * pass.      *      * There are two sections in the loop below:      * 1. Based on the report type (e.g. extract, checkout, tag, etc.),      *    decide whether the record should be printed.      * 2. Based on the record type, format and print the data.      */
for|for
control|(
name|lr
operator|=
name|hrec_head
operator|,
name|hr
operator|=
operator|(
name|lr
operator|+
literal|1
operator|)
init|;
name|hrec_count
operator|--
condition|;
name|lr
operator|=
name|hr
operator|,
name|hr
operator|++
control|)
block|{
name|char
modifier|*
name|workdir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
if|if
condition|(
operator|!
name|hrec_count
condition|)
name|hr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|accept_hrec
argument_list|(
name|lr
argument_list|,
name|hr
argument_list|)
condition|)
continue|continue;
name|ty
operator|=
operator|*
operator|(
name|lr
operator|->
name|type
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|tz_local
condition|)
block|{
name|time_t
name|t
init|=
name|lr
operator|->
name|date
operator|+
name|tz_seconds_east_of_GMT
decl_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|tm
operator|=
name|localtime
argument_list|(
operator|&
operator|(
name|lr
operator|->
name|date
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %04d-%02d-%02d %02d:%02d %s %-*s"
argument_list|,
name|ty
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tz_name
argument_list|,
name|user_len
argument_list|,
name|lr
operator|->
name|user
argument_list|)
expr_stmt|;
name|workdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lr
operator|->
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|lr
operator|->
name|end
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|workdir
argument_list|,
literal|"%s%s"
argument_list|,
name|lr
operator|->
name|dir
argument_list|,
name|lr
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|workdir
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lr
operator|->
name|mod
operator|&&
operator|!
name|strcmp
argument_list|(
operator|++
name|cp
argument_list|,
name|lr
operator|->
name|mod
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
name|repos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lr
operator|->
name|repos
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repos
argument_list|,
name|lr
operator|->
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repos
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lr
operator|->
name|mod
operator|&&
operator|!
name|strcmp
argument_list|(
operator|++
name|cp
argument_list|,
name|lr
operator|->
name|mod
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ty
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* 'T'ag records: repository is a "tag type", rev is the tag */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %-*s [%s:%s]"
argument_list|,
name|mod_len
argument_list|,
name|lr
operator|->
name|mod
argument_list|,
name|lr
operator|->
name|rev
argument_list|,
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
name|working
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" {%s}"
argument_list|,
name|workdir
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
case|case
literal|'E'
case|:
case|case
literal|'O'
case|:
if|if
condition|(
name|lr
operator|->
name|rev
operator|&&
operator|*
operator|(
name|lr
operator|->
name|rev
operator|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" [%s]"
argument_list|,
name|lr
operator|->
name|rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %-*s =%s%-*s %s"
argument_list|,
name|repos_len
argument_list|,
name|repos
argument_list|,
name|lr
operator|->
name|mod
argument_list|,
name|mod_len
operator|+
literal|1
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|lr
operator|->
name|mod
argument_list|)
argument_list|,
literal|"="
argument_list|,
name|workdir
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'U'
case|:
case|case
literal|'C'
case|:
case|case
literal|'G'
case|:
case|case
literal|'M'
case|:
case|case
literal|'A'
case|:
case|case
literal|'R'
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %-*s %-*s %-*s =%s= %s"
argument_list|,
name|rev_len
argument_list|,
name|lr
operator|->
name|rev
argument_list|,
name|file_len
argument_list|,
name|lr
operator|->
name|file
argument_list|,
name|repos_len
argument_list|,
name|repos
argument_list|,
name|lr
operator|->
name|mod
condition|?
name|lr
operator|->
name|mod
else|:
literal|""
argument_list|,
name|workdir
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Hey! What is this junk? RecType[0x%2.2x]"
argument_list|,
name|ty
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|workdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|accept_hrec
parameter_list|(
name|lr
parameter_list|,
name|hr
parameter_list|)
name|struct
name|hrec
modifier|*
name|hr
decl_stmt|,
decl|*
name|lr
decl_stmt|;
end_function

begin_block
block|{
name|int
name|ty
decl_stmt|;
name|ty
operator|=
operator|*
operator|(
name|lr
operator|->
name|type
operator|)
expr_stmt|;
if|if
condition|(
name|last_since_tag
operator|&&
name|ty
operator|==
literal|'T'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|v_checkout
condition|)
block|{
if|if
condition|(
name|ty
operator|!=
literal|'O'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Only interested in 'O' records */
comment|/* We want to identify all the states that cause the next record 	 * ("hr") to be different from the current one ("lr") and only 	 * print a line at the allowed boundaries. 	 */
if|if
condition|(
operator|!
name|hr
operator|||
comment|/* The last record */
name|strcmp
argument_list|(
name|hr
operator|->
name|user
argument_list|,
name|lr
operator|->
name|user
argument_list|)
operator|||
comment|/* User has changed */
name|strcmp
argument_list|(
name|hr
operator|->
name|mod
argument_list|,
name|lr
operator|->
name|mod
argument_list|)
operator|||
comment|/* Module has changed */
operator|(
name|working
operator|&&
comment|/* If must match "workdir" */
operator|(
name|strcmp
argument_list|(
name|hr
operator|->
name|dir
argument_list|,
name|lr
operator|->
name|dir
argument_list|)
operator|||
comment|/*    and the 1st parts or */
name|strcmp
argument_list|(
name|hr
operator|->
name|end
argument_list|,
name|lr
operator|->
name|end
argument_list|)
operator|)
operator|)
condition|)
comment|/*    the 2nd parts differ */
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|modified
condition|)
block|{
if|if
condition|(
operator|!
name|last_entry
operator|||
comment|/* Don't want only last rec */
operator|!
name|hr
operator|||
comment|/* Last entry is a "last entry" */
name|strcmp
argument_list|(
name|hr
operator|->
name|repos
argument_list|,
name|lr
operator|->
name|repos
argument_list|)
operator|||
comment|/* Repository has changed */
name|strcmp
argument_list|(
name|hr
operator|->
name|file
argument_list|,
name|lr
operator|->
name|file
argument_list|)
condition|)
comment|/* File has changed */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|working
condition|)
block|{
comment|/* If must match "workdir" */
if|if
condition|(
name|strcmp
argument_list|(
name|hr
operator|->
name|dir
argument_list|,
name|lr
operator|->
name|dir
argument_list|)
operator|||
comment|/*    and the 1st parts or */
name|strcmp
argument_list|(
name|hr
operator|->
name|end
argument_list|,
name|lr
operator|->
name|end
argument_list|)
condition|)
comment|/*    the 2nd parts differ */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|module_report
condition|)
block|{
if|if
condition|(
operator|!
name|last_entry
operator|||
comment|/* Don't want only last rec */
operator|!
name|hr
operator|||
comment|/* Last entry is a "last entry" */
name|strcmp
argument_list|(
name|hr
operator|->
name|mod
argument_list|,
name|lr
operator|->
name|mod
argument_list|)
operator|||
comment|/* Module has changed */
name|strcmp
argument_list|(
name|hr
operator|->
name|repos
argument_list|,
name|lr
operator|->
name|repos
argument_list|)
operator|||
comment|/* Repository has changed */
name|strcmp
argument_list|(
name|hr
operator|->
name|file
argument_list|,
name|lr
operator|->
name|file
argument_list|)
condition|)
comment|/* File has changed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* "extract" and "tag_report" always print selected records. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

