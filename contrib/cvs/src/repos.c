begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/* Determine the name of the RCS repository for directory DIR in the    current working directory, or for the current working directory    itself if DIR is NULL.  Returns the name in a newly-malloc'd    string.  On error, gives a fatal error and does not return.    UPDATE_DIR is the path from where cvs was invoked (for use in error    messages), and should contain DIR as its last component.    UPDATE_DIR can be NULL to signify the directory in which cvs was    invoked.  */
end_comment

begin_function
name|char
modifier|*
name|Name_Repository
parameter_list|(
name|dir
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fpin
decl_stmt|;
name|char
modifier|*
name|xupdate_dir
decl_stmt|;
name|char
modifier|*
name|repos
init|=
name|NULL
decl_stmt|;
name|size_t
name|repos_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|update_dir
operator|&&
operator|*
name|update_dir
condition|)
name|xupdate_dir
operator|=
name|update_dir
expr_stmt|;
else|else
name|xupdate_dir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_REP
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|xstrdup
argument_list|(
name|CVSADM_REP
argument_list|)
expr_stmt|;
comment|/*      * The assumption here is that the repository is always contained in the      * first line of the "Repository" file.      */
name|fpin
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpin
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|char
modifier|*
name|cvsadm
decl_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|cvsadm
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cvsadm
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
block|}
else|else
name|cvsadm
operator|=
name|xstrdup
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|cvsadm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"there is no version here; do '%s checkout' first"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cvsadm
argument_list|)
expr_stmt|;
if|if
condition|(
name|existence_error
argument_list|(
name|save_errno
argument_list|)
condition|)
block|{
comment|/* FIXME: This is a very poorly worded error message.  It 	       occurs at least in the case where the user manually 	       creates a directory named CVS, so the error message 	       should be more along the lines of "CVS directory found 	       without administrative files; use CVS to create the CVS 	       directory, or rename it to something else if the 	       intention is to store something besides CVS 	       administrative files".  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"*PANIC* administration files missing"
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getline
argument_list|(
operator|&
name|repos
argument_list|,
operator|&
name|repos_allocated
argument_list|,
name|fpin
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: should be checking for end of file separately.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fpin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repos
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the newline */
comment|/*      * If this is a relative repository pathname, turn it into an absolute      * one by tacking on the CVSROOT environment variable. If the CVSROOT      * environment variable is not set, die now.      */
if|if
condition|(
name|strcmp
argument_list|(
name|repos
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|repos
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`..'-relative repositories are not supported."
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal source repository"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|repos
argument_list|)
condition|)
block|{
name|char
modifier|*
name|newrepos
decl_stmt|;
if|if
condition|(
name|CVSroot_original
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"must set the CVSROOT environment variable\n"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"or specify the '-d' option to %s."
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal repository setting"
argument_list|)
expr_stmt|;
block|}
name|newrepos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|repos
operator|=
name|newrepos
expr_stmt|;
block|}
name|Sanitize_Repository_Name
argument_list|(
name|repos
argument_list|)
expr_stmt|;
return|return
name|repos
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the repository name relative to CVSROOT from a  * possibly fully qualified repository  */
end_comment

begin_function
name|char
modifier|*
name|Short_Repository
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* If repository matches CVSroot at the beginning, strip off CVSroot */
comment|/* And skip leading '/' in rep, in case CVSroot ended with '/'. */
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_directory
argument_list|,
name|repository
argument_list|,
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|rep
init|=
name|repository
operator|+
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
decl_stmt|;
return|return
operator|(
operator|*
name|rep
operator|==
literal|'/'
operator|)
condition|?
name|rep
operator|+
literal|1
else|:
name|rep
return|;
block|}
else|else
return|return
operator|(
name|repository
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sanitize the repository name (in place) by removing trailing  * slashes and a trailing "." if present.  It should be safe for  * callers to use strcat and friends to create repository names.  * Without this check, names like "/path/to/repos/./foo" and  * "/path/to/repos//foo" would be created.  For example, one  * significant case is the CVSROOT-detection code in commit.c.  It  * decides whether or not it needs to rebuild the administrative file  * database by doing a string compare.  If we've done a `cvs co .' to  * get the CVSROOT files, "/path/to/repos/./CVSROOT" and  * "/path/to/repos/CVSROOT" are the arguments that are compared!  *  * This function ends up being called from the same places as  * strip_path, though what it does is much more conservative.  Many  * comments about this operation (which was scattered around in  * several places in the source code) ran thus:  *  *    ``repository ends with "/."; omit it.  This sort of thing used  *    to be taken care of by strip_path.  Now we try to be more  *    selective.  I suspect that it would be even better to push it  *    back further someday, so that the trailing "/." doesn't get into  *    repository in the first place, but we haven't taken things that  *    far yet.''        --Jim Kingdon (recurse.c, 07-Sep-97)  *  * Ahh, all too true.  The major consideration is RELATIVE_REPOS.  If  * the "/." doesn't end up in the repository while RELATIVE_REPOS is  * defined, there will be nothing in the CVS/Repository file.  I  * haven't verified that the remote protocol will handle that  * correctly yet, so I've not made that change. */
end_comment

begin_function
name|void
name|Sanitize_Repository_Name
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|repository
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|strip_trailing_slashes
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|repository
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|ISDIRSEP
argument_list|(
name|repository
index|[
name|len
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
name|repository
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

end_unit

