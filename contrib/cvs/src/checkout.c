begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Create Version  *   * "checkout" creates a "version" of an RCS repository.  This version is owned  * totally by the user and is actually an independent copy, to be dealt with  * as seen fit.  Once "checkout" has been called in a given directory, it  * never needs to be called again.  The user can keep up-to-date by calling  * "update" when he feels like it; this will supply him with a merge of his  * own modifications and the changes made in the RCS original.  See "update"  * for details.  *   * "checkout" can be given a list of directories or files to be updated and in  * the case of a directory, will recursivley create any sub-directories that  * exist in the repository.  *   * When the user is satisfied with his own modifications, the present version  * can be committed by "commit"; this keeps the present version in tact,  * usually.  *   * The call is cvs checkout [options]<module-name>...  *   * "checkout" creates a directory ./CVS, in which it keeps its administration,  * in two files, Repository and Entries. The first contains the name of the  * repository.  The second contains one line for each registered file,  * consisting of the version number it derives from, its time stamp at  * derivation time and its name.  Both files are normal files and can be  * edited by the user, if necessary (when the repository is moved, e.g.)  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|findslash
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|start
operator|,
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkout_proc
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|char
operator|*
name|where
operator|,
name|char
operator|*
name|mwhere
operator|,
name|char
operator|*
name|mfile
operator|,
name|int
name|shorten
operator|,
name|int
name|local_specified
operator|,
name|char
operator|*
name|omodule
operator|,
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|checkout_usage
index|[]
init|=
block|{
literal|"Usage:\n  %s %s [-ANPRcflnps] [-r rev | -D date] [-d dir]\n"
block|,
literal|"    [-j rev1] [-j rev2] [-k kopt] modules...\n"
block|,
literal|"\t-A\tReset any sticky tags/date/kopts.\n"
block|,
literal|"\t-N\tDon't shorten module paths if -d specified.\n"
block|,
literal|"\t-P\tPrune empty directories.\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-c\t\"cat\" the module database.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive\n"
block|,
literal|"\t-n\tDo not run module program (if any).\n"
block|,
literal|"\t-p\tCheck out files to standard output (avoids stickiness).\n"
block|,
literal|"\t-s\tLike -c, but include module status.\n"
block|,
literal|"\t-r rev\tCheck out revision or tag. (implies -P) (is sticky)\n"
block|,
literal|"\t-D date\tCheck out revisions as of date. (implies -P) (is sticky)\n"
block|,
literal|"\t-d dir\tCheck out into dir instead of module name.\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"\t-j rev\tMerge in changes made between current revision and rev.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|export_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-NRfln] [-r rev | -D date] [-d dir] [-k kopt] module...\n"
block|,
literal|"\t-N\tDon't shorten module paths if -d specified.\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive\n"
block|,
literal|"\t-R\tProcess directories recursively (default).\n"
block|,
literal|"\t-n\tDo not run module program (if any).\n"
block|,
literal|"\t-r rev\tExport revision or tag.\n"
block|,
literal|"\t-D date\tExport revisions as of date.\n"
block|,
literal|"\t-d dir\tExport into dir instead of module name.\n"
block|,
literal|"\t-k kopt\tUse RCS kopt -k option on checkout.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkout_prune_dirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tag_validated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|join_rev2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|join_tags_validated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|preload_update_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|mtype
name|m_type
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|checkout
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|int
name|cat
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|shorten
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|where
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|valid_options
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|valid_usage
decl_stmt|;
comment|/*      * A smaller subset of options are allowed for the export command, which      * is essentially like checkout, except that it hard-codes certain      * options to be default (like -kv) and takes care to remove the CVS      * directory when it has done its duty      */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_type
operator|=
name|EXPORT
expr_stmt|;
name|valid_options
operator|=
literal|"+Nnk:d:flRQqr:D:"
expr_stmt|;
name|valid_usage
operator|=
name|export_usage
expr_stmt|;
block|}
else|else
block|{
name|m_type
operator|=
name|CHECKOUT
expr_stmt|;
name|valid_options
operator|=
literal|"+ANnk:d:flRpQqcsr:D:j:P"
expr_stmt|;
name|valid_usage
operator|=
name|checkout_usage
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|valid_options
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|shorten
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pipeout
operator|=
literal|1
expr_stmt|;
name|run_module_prog
operator|=
literal|0
expr_stmt|;
comment|/* don't run module prog when piping */
name|noexec
operator|=
literal|1
expr_stmt|;
comment|/* so no locks will be created */
break|break;
case|case
literal|'c'
case|:
name|cat
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|where
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|shorten
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|status
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|tag
operator|=
name|optarg
expr_stmt|;
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|date
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|checkout_prune_dirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|join_rev2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only two -j options can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
condition|)
name|join_rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|join_rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|valid_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|shorten
operator|==
operator|-
literal|1
condition|)
name|shorten
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cat
operator|||
name|status
operator|)
operator|&&
name|argc
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-c and -s must not get any arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cat
operator|||
name|status
operator|)
operator|&&
name|argc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"must specify at least one module or directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|&&
name|pipeout
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-d and -p are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_type
operator|==
name|EXPORT
condition|)
block|{
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
name|date
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"must specify a tag or date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tag
index|[
literal|0
index|]
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"tag `%s' must be a symbolic tag"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|where
operator|!=
name|NULL
condition|)
block|{
name|server_pathname_check
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|safe_location
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Cannot check out files into the repository itself"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|int
name|expand_modules
decl_stmt|;
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* We have to expand names here because the "expand-modules"            directive to the server has the side-effect of having the            server send the check-in and update programs for the            various modules/dirs requested.  If we turn this off and            simply request the names of the modules and directories (as            below in !expand_modules), those files (CVS/Checkin.prog            or CVS/Update.prog) don't get created.  Grrr.  */
name|expand_modules
operator|=
operator|(
operator|!
name|cat
operator|&&
operator|!
name|status
operator|&&
operator|!
name|pipeout
operator|&&
name|supported_request
argument_list|(
literal|"expand-modules"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|expand_modules
condition|)
block|{
comment|/* This is done here because we need to read responses                from the server before we send the command checkout or                export files. */
name|client_expand_modules
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|run_module_prog
condition|)
name|send_arg
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipeout
condition|)
name|send_arg
argument_list|(
literal|"-p"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|send_arg
argument_list|(
literal|"-A"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shorten
condition|)
name|send_arg
argument_list|(
literal|"-N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkout_prune_dirs
operator|&&
name|m_type
operator|==
name|CHECKOUT
condition|)
name|send_arg
argument_list|(
literal|"-P"
argument_list|)
expr_stmt|;
name|client_prune_dirs
operator|=
name|checkout_prune_dirs
expr_stmt|;
if|if
condition|(
name|cat
condition|)
name|send_arg
argument_list|(
literal|"-c"
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
name|option_with_arg
argument_list|(
literal|"-d"
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|send_arg
argument_list|(
literal|"-s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|send_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|client_senddate
argument_list|(
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev1
operator|!=
name|NULL
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|!=
name|NULL
condition|)
name|option_with_arg
argument_list|(
literal|"-j"
argument_list|,
name|join_rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_modules
condition|)
block|{
name|client_send_expansions
argument_list|(
name|local
argument_list|,
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|client_nonexpanded_setup
argument_list|()
expr_stmt|;
block|}
name|send_to_server
argument_list|(
name|m_type
operator|==
name|EXPORT
condition|?
literal|"export\012"
else|:
literal|"co\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
if|if
condition|(
name|cat
operator|||
name|status
condition|)
block|{
name|cat_module
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
comment|/* If we've specified something like "cvs co foo/bar baz/quux"        don't try to shorten names.  There are a few cases in which we        could shorten (e.g. "cvs co foo/bar foo/baz"), but we don't        handle those yet.  Better to have an extra directory created        than the thing checked out under the wrong directory name. */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|shorten
operator|=
literal|0
expr_stmt|;
comment|/* If we will be calling history_write, work out the name to pass        it.  */
if|if
condition|(
name|m_type
operator|==
name|CHECKOUT
operator|&&
operator|!
name|pipeout
condition|)
block|{
if|if
condition|(
name|tag
operator|&&
name|date
condition|)
block|{
name|history_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|history_name
argument_list|,
literal|"%s:%s"
argument_list|,
name|tag
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
condition|)
name|history_name
operator|=
name|tag
expr_stmt|;
else|else
name|history_name
operator|=
name|date
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|m_type
argument_list|,
literal|"Updating"
argument_list|,
name|checkout_proc
argument_list|,
name|where
argument_list|,
name|shorten
argument_list|,
name|local
argument_list|,
name|run_module_prog
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FIXME: This is and emptydir_name are in checkout.c for historical    reasons, probably want to move them.  */
end_comment

begin_function
name|int
name|safe_location
parameter_list|()
block|{
name|char
modifier|*
name|current
decl_stmt|;
name|char
name|hardpath
index|[
name|PATH_MAX
operator|+
literal|5
index|]
decl_stmt|;
name|size_t
name|hardpath_len
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_READLINK
comment|/* FIXME-arbitrary limit: should be retrying this like xgetwd.        But how does readlink let us know that the buffer was too small?        (by returning sizeof hardpath - 1?).  */
name|x
operator|=
name|readlink
argument_list|(
name|CVSroot_directory
argument_list|,
name|hardpath
argument_list|,
sizeof|sizeof
name|hardpath
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|x
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|hardpath
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hardpath
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|current
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not get working directory"
argument_list|)
expr_stmt|;
name|hardpath_len
operator|=
name|strlen
argument_list|(
name|hardpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|current
argument_list|)
operator|>=
name|hardpath_len
operator|&&
name|strncmp
argument_list|(
name|current
argument_list|,
name|hardpath
argument_list|,
name|hardpath_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
comment|/* Current is a subdirectory of hardpath.  */
name|current
index|[
name|hardpath_len
index|]
operator|==
literal|'/'
comment|/* Current is hardpath itself.  */
operator|||
name|current
index|[
name|hardpath_len
index|]
operator|==
literal|'\0'
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
comment|/* It isn't a problem.  For example, current is 	       "/foo/cvsroot-bar" and hardpath is "/foo/cvsroot".  */
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|retval
operator|=
literal|1
expr_stmt|;
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_struct
struct|struct
name|dir_to_build
block|{
comment|/* What to put in CVS/Repository.  */
name|char
modifier|*
name|repository
decl_stmt|;
comment|/* The path to the directory.  */
name|char
modifier|*
name|dirpath
decl_stmt|;
comment|/* If set, don't build the directory, just change to it.        The caller will also want to set REPOSITORY to NULL.  */
name|int
name|just_chdir
decl_stmt|;
name|struct
name|dir_to_build
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|build_dirs_and_chdir
name|PROTO
argument_list|(
operator|(
expr|struct
name|dir_to_build
operator|*
name|list
operator|,
name|int
name|sticky
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_one_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|build_one_dir
parameter_list|(
name|repository
parameter_list|,
name|dirpath
parameter_list|,
name|sticky
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|dirpath
decl_stmt|;
name|int
name|sticky
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_type
operator|==
name|EXPORT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot export into a working directory"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m_type
operator|==
name|CHECKOUT
condition|)
block|{
comment|/* I suspect that this check could be omitted.  */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"there is no repository %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|dirpath
argument_list|,
name|repository
argument_list|,
name|sticky
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|tag
argument_list|,
name|sticky
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|date
argument_list|,
comment|/* FIXME?  This is a guess.  If it is important 			     for nonbranch to be set correctly here I 			     think we need to write it one way now and 			     then rewrite it later via WriteTag, once 			     we've had a chance to call RCS_nodeisbranch 			     on each file.  */
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_entstat
argument_list|(
name|dirpath
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process_module calls us back here so we do the actual checkout stuff  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|checkout_proc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|where_orig
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|omodule
parameter_list|,
name|msg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|where_orig
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|omodule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
modifier|*
name|myargv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|oldupdate
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
comment|/*      * OK, so we're doing the checkout! Our args are as follows:       *  argc,argv contain either dir or dir followed by a list of files       *  where contains where to put it (if supplied by checkout)       *  mwhere contains the module name or -d from module file       *  mfile says do only that part of the module      *  shorten = 1 says shorten as much as possible       *  omodule is the original arg to do_module()      */
comment|/* Set up the repository (maybe) for the bottom directory.        Allocate more space than we need so we don't need to keep        reallocating this string. */
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Sanitize_Repository_Name
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* save the original value of preload_update_dir */
if|if
condition|(
name|preload_update_dir
operator|!=
name|NULL
condition|)
name|oldupdate
operator|=
name|xstrdup
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
comment|/* Allocate space and set up the where variable.  We allocate more        space than necessary here so that we don't have to keep        reallocaing it later on. */
name|where
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|)
operator|+
operator|(
name|mwhere
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mwhere
argument_list|)
operator|)
operator|+
operator|(
name|where_orig
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|where_orig
argument_list|)
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* Yes, this could be written in a less verbose way, but in this        form it is quite easy to read.             FIXME?  The following code that sets should probably be moved        to do_module in modules.c, since there is similar code in        patch.c and rtag.c. */
if|if
condition|(
name|shorten
condition|)
block|{
if|if
condition|(
name|where_orig
operator|!=
name|NULL
condition|)
block|{
comment|/* If the user has specified a directory with `-d' on the 	       command line, use it preferentially, even over the `-d' 	       flag in the modules file. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|where_orig
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mwhere
operator|!=
name|NULL
condition|)
block|{
comment|/* Second preference is the value of mwhere, which is from 	       the `-d' flag in the modules file. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|mwhere
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Third preference is the directory specified in argv[0] 	       which is this module'e directory in the repository. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use the same preferences here, bug don't shorten -- that            is, tack on where_orig if it exists. */
operator|*
name|where
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|where_orig
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|where_orig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
comment|/* If the -d flag in the modules file specified an absolute            directory, let the user override it with the command-line            -d option. */
if|if
condition|(
operator|(
name|mwhere
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|isabsolute
argument_list|(
name|mwhere
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mwhere
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|strip_trailing_slashes
argument_list|(
name|where
argument_list|)
expr_stmt|;
comment|/* necessary? */
comment|/* At this point, the user may have asked for a single file or        directory from within a module.  In that case, we should modify        where, repository, and argv as appropriate. */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
comment|/* The mfile variable can have one or more path elements.  If 	   it has multiple elements, we want to tack those onto both 	   repository and where.  The last element may refer to either 	   a file or directory.  Here's what to do:  	   it refers to a directory 	     -> simply tack it on to where and repository 	   it refers to a file 	     -> munge argv to contain `basename mfile` */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Paranoia check. */
if|if
condition|(
name|mfile
index|[
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"checkout_proc: trailing slash on mfile (%s)!"
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
comment|/* Does mfile have multiple path elements? */
name|cp
operator|=
name|strrchr
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Now mfile is a single path element. */
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* It's a directory, so tack it on to repository and                where, as we did above. */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a file, which means we have to screw around with                argv. */
name|myargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|myargv
index|[
literal|1
index|]
operator|=
name|mfile
expr_stmt|;
name|argc
operator|=
literal|2
expr_stmt|;
name|argv
operator|=
name|myargv
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preload_update_dir
operator|!=
name|NULL
condition|)
block|{
name|preload_update_dir
operator|=
name|xrealloc
argument_list|(
name|preload_update_dir
argument_list|,
name|strlen
argument_list|(
name|preload_update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|where
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preload_update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preload_update_dir
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
else|else
name|preload_update_dir
operator|=
name|xstrdup
argument_list|(
name|where
argument_list|)
expr_stmt|;
comment|/*      * At this point, where is the directory we want to build, repository is      * the repository for the lowest level of the path.      *      * We need to tell build_dirs not only the path we want it to      * build, but also the repositories we want it to populate the      * path with.  To accomplish this, we walk the path backwards, one      * pathname component at a time, constucting a linked list of      * struct dir_to_build.      */
comment|/*      * If we are sending everything to stdout, we can skip a whole bunch of      * work from here      */
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|struct
name|dir_to_build
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|reposcopy
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|repository
argument_list|,
name|CVSroot_directory
argument_list|,
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ internal error: %s doesn't start with %s in checkout_proc"
argument_list|,
name|repository
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
comment|/* We always create at least one directory, which corresponds to 	   the entire strings for WHERE and REPOSITORY.  */
name|head
operator|=
operator|(
expr|struct
name|dir_to_build
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_to_build
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special marker to indicate that we don't want build_dirs_and_chdir 	   to create the CVSADM directory for us.  */
name|head
operator|->
name|repository
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|dirpath
operator|=
name|xstrdup
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|just_chdir
operator|=
literal|0
expr_stmt|;
comment|/* Make a copy of the repository name to play with. */
name|reposcopy
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* FIXME: this should be written in terms of last_component 	   instead of hardcoding '/'.  This presumably affects OS/2, 	   NT,&c, if the user specifies '\'.  Likewise for the call 	   to findslash.  */
name|cp
operator|=
name|where
operator|+
name|strlen
argument_list|(
name|where
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|where
condition|)
block|{
name|struct
name|dir_to_build
modifier|*
name|new
decl_stmt|;
name|cp
operator|=
name|findslash
argument_list|(
name|where
argument_list|,
name|cp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
comment|/* we're done */
name|new
operator|=
operator|(
expr|struct
name|dir_to_build
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dir_to_build
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|dirpath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|where
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the user specified an absolute path for where, the                last path element we create should be the top-level                directory. */
if|if
condition|(
name|cp
operator|>
name|where
condition|)
block|{
name|strncpy
argument_list|(
name|new
operator|->
name|dirpath
argument_list|,
name|where
argument_list|,
name|cp
operator|-
name|where
argument_list|)
expr_stmt|;
name|new
operator|->
name|dirpath
index|[
name|cp
operator|-
name|where
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* where should always be at least one character long. */
name|assert
argument_list|(
name|where
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|dirpath
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|new
expr_stmt|;
comment|/* If where consists of multiple pathname components, 	       then we want to just cd into it, without creating 	       directories or modifying CVS directories as we go. 	       In CVS 1.9 and earlier, the code actually does a 	       CVS_CHDIR up-front; I'm not going to try to go back 	       to that exact code but this is somewhat similar 	       in spirit.  */
if|if
condition|(
name|where_orig
operator|!=
name|NULL
operator|&&
name|cp
operator|-
name|where
operator|<
name|strlen
argument_list|(
name|where_orig
argument_list|)
condition|)
block|{
name|new
operator|->
name|repository
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|just_chdir
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|new
operator|->
name|just_chdir
operator|=
literal|0
expr_stmt|;
comment|/* Now figure out what repository directory to generate.                The most complete case would be something like this:  	       The modules file contains 	         foo -d bar/baz quux  	       The command issued was: 	         cvs co -d what/ever -N foo 	        	       The results in the CVS/Repository files should be: 	         .     -> (don't touch CVS/Repository) 			  (I think this case might be buggy currently) 		 what  -> (don't touch CVS/Repository) 		 ever  -> .          (same as "cd what/ever; cvs co -N foo") 		 bar   -> Emptydir   (generated dir -- not in repos) 		 baz   -> quux       (finally!) */
if|if
condition|(
name|strcmp
argument_list|(
name|reposcopy
argument_list|,
name|CVSroot_directory
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We can't walk up past CVSROOT.  Instead, the                    repository should be Emptydir. */
name|new
operator|->
name|repository
operator|=
name|emptydir_name
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|where_orig
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|new
operator|->
name|dirpath
argument_list|,
name|where_orig
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* It's the case that the user specified a 		     * destination directory with the "-d" flag.  The 		     * repository in this directory should be "." 		     * since the user's command is equivalent to: 		     * 		     *   cd<dir>; cvs co blah   */
name|strcpy
argument_list|(
name|reposcopy
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
goto|goto
name|allocate_repos
goto|;
block|}
elseif|else
if|if
condition|(
name|mwhere
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a generated directory, so point to                        CVSNULLREPOS. */
name|new
operator|->
name|repository
operator|=
name|emptydir_name
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a directory in the repository! */
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* We'll always be below CVSROOT, but check for 		       paranoia's sake. */
name|rp
operator|=
name|strrchr
argument_list|(
name|reposcopy
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: %s doesn't contain a slash"
argument_list|,
name|reposcopy
argument_list|)
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
name|allocate_repos
label|:
name|new
operator|->
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|reposcopy
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new
operator|->
name|repository
argument_list|,
name|reposcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|reposcopy
argument_list|,
name|CVSroot_directory
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Special case -- the repository name needs 			   to be "/path/to/repos/." (the trailing dot 			   is important).  We might be able to get rid 			   of this after the we check out the other 			   code that handles repository names. */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|new
operator|->
name|repository
argument_list|,
literal|"/."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* clean up */
name|free
argument_list|(
name|reposcopy
argument_list|)
expr_stmt|;
block|{
name|int
name|where_is_absolute
init|=
name|isabsolute
argument_list|(
name|where
argument_list|)
decl_stmt|;
comment|/* The top-level CVSADM directory should always be 	       CVSroot_directory.  Create it, but only if WHERE is 	       relative.  If WHERE is absolute, our current directory 	       may not have a thing to do with where the sources are 	       being checked out.  If it does, build_dirs_and_chdir 	       will take care of creating adm files here. */
comment|/* FIXME: checking where_is_absolute is a horrid kludge; 	       I suspect we probably can just skip the call to 	       build_one_dir whenever the -d command option was specified 	       to checkout.  */
if|if
condition|(
operator|!
name|where_is_absolute
operator|&&
name|top_level_admin
condition|)
block|{
comment|/* It may be argued that we shouldn't set any sticky 		   bits for the top-level repository.  FIXME?  */
name|build_one_dir
argument_list|(
name|CVSroot_directory
argument_list|,
literal|"."
argument_list|,
name|argc
operator|<=
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* We _always_ want to have a top-level admin 		   directory.  If we're running in client/server mode, 		   send a "Clear-static-directory" command to make 		   sure it is created on the client side.  (See 5.10 		   in cvsclient.dvi to convince yourself that this is 		   OK.)  If this is a duplicate command being sent, it 		   will be ignored on the client side.  */
if|if
condition|(
name|server_active
condition|)
name|server_clear_entstat
argument_list|(
literal|"."
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Build dirs on the path if necessary and leave us in the 	       bottom directory (where if where was specified) doesn't 	       contain a CVS subdir yet, but all the others contain 	       CVS and Entries.Static files */
if|if
condition|(
name|build_dirs_and_chdir
argument_list|(
name|head
argument_list|,
name|argc
operator|<=
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring module %s"
argument_list|,
name|omodule
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* set up the repository (or make sure the old one matches) */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|noexec
operator|&&
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* I'm not sure whether this check is redundant.  */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"there is no repository %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|preload_update_dir
argument_list|,
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_type
operator|==
name|CHECKOUT
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_entstat
argument_list|(
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* I'm not sure whether this check is redundant.  */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"there is no repository %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|preload_update_dir
argument_list|,
name|repository
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
comment|/* FIXME?  This is a guess.  If it is important 				 for nonbranch to be set correctly here I 				 think we need to write it one way now and 				 then rewrite it later via WriteTag, once 				 we've had a chance to call RCS_nodeisbranch 				 on each file.  */
literal|0
argument_list|,
literal|0
argument_list|,
name|m_type
operator|==
name|CHECKOUT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|repos
decl_stmt|;
if|if
condition|(
name|m_type
operator|==
name|EXPORT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot export into working directory"
argument_list|)
expr_stmt|;
comment|/* get the contents of the previously existing repository */
name|repos
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fncmp
argument_list|(
name|repository
argument_list|,
name|repos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"existing repository %s does not match %s"
argument_list|,
name|repos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring module %s"
argument_list|,
name|omodule
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If we are going to be updating to stdout, we need to cd to the      * repository directory so the recursion processor can use the current      * directory as the place to find repository information      */
if|if
condition|(
name|pipeout
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|which
operator|=
name|W_REPOS
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|&&
operator|!
name|tag_validated
condition|)
block|{
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|aflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tag_validated
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|&&
operator|!
name|tag_validated
condition|)
block|{
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|tag_validated
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
operator|||
name|date
operator|!=
name|NULL
operator|||
name|join_rev1
operator|!=
name|NULL
condition|)
name|which
operator||=
name|W_ATTIC
expr_stmt|;
if|if
condition|(
operator|!
name|join_tags_validated
condition|)
block|{
if|if
condition|(
name|join_rev1
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev1
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_rev2
operator|!=
name|NULL
condition|)
name|tag_check_valid_join
argument_list|(
name|join_rev2
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|aflag
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|join_tags_validated
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * if we are going to be recursive (building dirs), go ahead and call the      * update recursion processor.  We will be recursive unless either local      * only was specified, or we were passed arguments      */
if|if
condition|(
operator|!
operator|(
name|local_specified
operator|||
name|argc
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|m_type
operator|==
name|CHECKOUT
operator|&&
operator|!
name|pipeout
condition|)
name|history_write
argument_list|(
literal|'O'
argument_list|,
name|preload_update_dir
argument_list|,
name|history_name
argument_list|,
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m_type
operator|==
name|EXPORT
operator|&&
operator|!
name|pipeout
condition|)
name|history_write
argument_list|(
literal|'E'
argument_list|,
name|preload_update_dir
argument_list|,
name|tag
condition|?
name|tag
else|:
name|date
argument_list|,
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_update
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
literal|0
comment|/* !local */
argument_list|,
literal|1
comment|/* update -d */
argument_list|,
name|aflag
argument_list|,
name|checkout_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|pipeout
condition|)
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
comment|/* we are only doing files, so register them */
name|entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|file_info
name|finfo
decl_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|finfo
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* Shouldn't be used, so set to arbitrary value.  */
name|finfo
operator|.
name|update_dir
operator|=
name|NULL
expr_stmt|;
name|finfo
operator|.
name|fullname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|finfo
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
comment|/* The rcs slot is needed to get the options from the RCS                file */
name|finfo
operator|.
name|rcs
operator|=
name|RCS_parse
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|finfo
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
operator|+
literal|15
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"Initial %s"
argument_list|,
name|finfo
operator|.
name|file
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
condition|?
name|vers
operator|->
name|vn_rcs
else|:
literal|"0"
argument_list|,
name|line
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|finfo
operator|.
name|rcs
argument_list|)
expr_stmt|;
block|}
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* Don't log "export", just regular "checkouts" */
if|if
condition|(
name|m_type
operator|==
name|CHECKOUT
operator|&&
operator|!
name|pipeout
condition|)
name|history_write
argument_list|(
literal|'O'
argument_list|,
name|preload_update_dir
argument_list|,
name|history_name
argument_list|,
name|where
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* go ahead and call update now that everything is set */
name|err
operator|+=
name|do_update
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|force_tag_match
argument_list|,
name|local_specified
argument_list|,
literal|1
comment|/* update -d */
argument_list|,
name|aflag
argument_list|,
name|checkout_prune_dirs
argument_list|,
name|pipeout
argument_list|,
name|which
argument_list|,
name|join_rev1
argument_list|,
name|join_rev2
argument_list|,
name|preload_update_dir
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|preload_update_dir
argument_list|)
expr_stmt|;
name|preload_update_dir
operator|=
name|oldupdate
expr_stmt|;
name|free
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|findslash
parameter_list|(
name|start
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
return|return
name|p
return|;
if|if
condition|(
name|p
operator|==
name|start
condition|)
break|break;
operator|--
name|p
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a newly malloc'd string containing a pathname for CVSNULLREPOS,    and make sure that it exists.  If there is an error creating the    directory, give a fatal error.  Otherwise, the directory is guaranteed    to exist when we return.  */
end_comment

begin_function
name|char
modifier|*
name|emptydir_name
parameter_list|()
block|{
name|char
modifier|*
name|repository
decl_stmt|;
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSNULLREPOS
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSNULLREPOS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|repository
argument_list|)
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|repository
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
return|return
name|repository
return|;
block|}
end_function

begin_comment
comment|/* Build all the dirs along the path to DIRS with CVS subdirs with appropriate    repositories.  If ->repository is NULL, do not create a CVSADM directory    for that subdirectory; just CVS_CHDIR into it.  */
end_comment

begin_function
specifier|static
name|int
name|build_dirs_and_chdir
parameter_list|(
name|dirs
parameter_list|,
name|sticky
parameter_list|)
name|struct
name|dir_to_build
modifier|*
name|dirs
decl_stmt|;
name|int
name|sticky
decl_stmt|;
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|dir_to_build
modifier|*
name|nextdir
decl_stmt|;
while|while
condition|(
name|dirs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|dir
init|=
name|last_component
argument_list|(
name|dirs
operator|->
name|dirpath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dirs
operator|->
name|just_chdir
condition|)
block|{
name|mkdir_if_needed
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|Subdir_Register
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dirs
operator|->
name|repository
operator|!=
name|NULL
condition|)
block|{
name|build_one_dir
argument_list|(
name|dirs
operator|->
name|repository
argument_list|,
name|dirs
operator|->
name|dirpath
argument_list|,
name|sticky
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirs
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
name|nextdir
operator|=
name|dirs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dirs
operator|->
name|dirpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|dirs
operator|=
name|nextdir
expr_stmt|;
block|}
name|out
label|:
while|while
condition|(
name|dirs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dirs
operator|->
name|repository
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dirs
operator|->
name|repository
argument_list|)
expr_stmt|;
name|nextdir
operator|=
name|dirs
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dirs
operator|->
name|dirpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
name|dirs
operator|=
name|nextdir
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

end_unit

