begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * The functions in this file provide an interface for performing   * operations directly on RCS files.   *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"diffrun.h"
end_include

begin_comment
comment|/* This file, rcs.h, and rcs.c, together sometimes known as the "RCS    library", are intended to define our interface to RCS files.     Whether there will also be a version of RCS which uses this    library, or whether the library will be packaged for uses beyond    CVS or RCS (many people would like such a thing) is an open    question.  Some considerations:     1.  An RCS library for CVS must have the capabilities of the    existing CVS code which accesses RCS files.  In particular, simple    approaches will often be slow.     2.  An RCS library should not use code from the current RCS    (5.7 and its ancestors).  The code has many problems.  Too few    comments, too many layers of abstraction, too many global variables    (the correct number for a library is zero), too much intricately    interwoven functionality, and too many clever hacks.  Paul Eggert,    the current RCS maintainer, agrees.     3.  More work needs to be done in terms of separating out the RCS    library from the rest of CVS (for example, cvs_output should be    replaced by a callback, and the declarations should be centralized    into rcs.h, and probably other such cleanups).     4.  To be useful for RCS and perhaps for other uses, the library    may need features beyond those needed by CVS.     5.  Any changes to the RCS file format *must* be compatible.  Many,    many tools (not just CVS and RCS) can at least import this format.    RCS and CVS must preserve the current ability to import/export it    (preferably improved--magic branches are currently a roadblock).    See doc/RCSFILES in the CVS distribution for documentation of this    file format.     On a related note, see the comments at diff_exec, later in this file,    for more on the diff library.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|RCS_output_diff_options
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff to deal with passing arguments the way libdiff.a wants to deal    with them.  This is a crufty interface; there is no good reason for it    to resemble a command line rather than something closer to "struct    log_data" in log.c.  */
end_comment

begin_comment
comment|/* First call call_diff_setup to setup any initial arguments.  The    argument will be parsed into whitespace separated words and added    to the global call_diff_argv list.     Then, optionally, call call_diff_arg for each additional argument    that you'd like to pass to the diff library.     Finally, call call_diff or call_diff3 to produce the diffs.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|call_diff_argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_diff_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_diff_argc_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_add_arg
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_setup
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|prog
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_diff
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|out
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|call_diff3
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|out
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_write_output
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_flush_output
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_write_stdout
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_diff_error
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|call_diff_setup
parameter_list|(
name|prog
parameter_list|)
specifier|const
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|call_diff_prog
decl_stmt|;
comment|/* clean out any malloc'ed values from call_diff_argv */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|call_diff_argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|call_diff_argv
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|call_diff_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|call_diff_argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|call_diff_argc
operator|=
literal|0
expr_stmt|;
name|call_diff_prog
operator|=
name|xstrdup
argument_list|(
name|prog
argument_list|)
expr_stmt|;
comment|/* put each word into call_diff_argv, allocating it as we go */
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|call_diff_prog
argument_list|,
literal|" \t"
argument_list|)
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
name|call_diff_add_arg
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|call_diff_prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|call_diff_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|call_diff_add_arg
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|call_diff_add_arg
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* allocate more argv entries if we've run out */
if|if
condition|(
name|call_diff_argc
operator|>=
name|call_diff_argc_allocated
condition|)
block|{
name|call_diff_argc_allocated
operator|+=
literal|50
expr_stmt|;
name|call_diff_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|call_diff_argv
argument_list|,
name|call_diff_argc_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
condition|)
name|call_diff_argv
index|[
name|call_diff_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
comment|/* Not post-incremented on purpose!  */
name|call_diff_argv
index|[
name|call_diff_argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback function for the diff library to write data to the output    file.  This is used when we are producing output to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|call_diff_write_output
parameter_list|(
name|text
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|cvs_output
argument_list|(
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back function for the diff library to flush the output file.    This is used when we are producing output to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|call_diff_flush_output
parameter_list|()
block|{
name|cvs_flushout
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back function for the diff library to write to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|call_diff_write_stdout
parameter_list|(
name|text
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|cvs_output
argument_list|(
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back function for the diff library to write to stderr.  */
end_comment

begin_function
specifier|static
name|void
name|call_diff_error
parameter_list|(
name|format
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
name|a1
decl_stmt|;
specifier|const
name|char
modifier|*
name|a2
decl_stmt|;
block|{
comment|/* FIXME: Should we somehow indicate that this error is coming from        the diff library?  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This set of callback functions is used if we are sending the diff    to stdout.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|diff_callbacks
name|call_diff_stdout_callbacks
init|=
block|{
name|call_diff_write_output
block|,
name|call_diff_flush_output
block|,
name|call_diff_write_stdout
block|,
name|call_diff_error
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This set of callback functions is used if we are sending the diff    to a file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|diff_callbacks
name|call_diff_file_callbacks
init|=
block|{
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
expr|,
name|size_t
operator|)
argument_list|)
operator|)
name|NULL
block|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|NULL
block|,
name|call_diff_write_stdout
block|,
name|call_diff_error
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|call_diff
parameter_list|(
name|out
parameter_list|)
name|char
modifier|*
name|out
decl_stmt|;
block|{
if|if
condition|(
name|out
operator|==
name|RUN_TTY
condition|)
return|return
name|diff_run
argument_list|(
name|call_diff_argc
argument_list|,
name|call_diff_argv
argument_list|,
name|NULL
argument_list|,
operator|&
name|call_diff_stdout_callbacks
argument_list|)
return|;
else|else
return|return
name|diff_run
argument_list|(
name|call_diff_argc
argument_list|,
name|call_diff_argv
argument_list|,
name|out
argument_list|,
operator|&
name|call_diff_file_callbacks
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_diff3
parameter_list|(
name|out
parameter_list|)
name|char
modifier|*
name|out
decl_stmt|;
block|{
if|if
condition|(
name|out
operator|==
name|RUN_TTY
condition|)
return|return
name|diff3_run
argument_list|(
name|call_diff_argc
argument_list|,
name|call_diff_argv
argument_list|,
name|NULL
argument_list|,
operator|&
name|call_diff_stdout_callbacks
argument_list|)
return|;
else|else
return|return
name|diff3_run
argument_list|(
name|call_diff_argc
argument_list|,
name|call_diff_argv
argument_list|,
name|out
argument_list|,
operator|&
name|call_diff_file_callbacks
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge revisions REV1 and REV2. */
end_comment

begin_function
name|int
name|RCS_merge
parameter_list|(
name|rcs
parameter_list|,
name|path
parameter_list|,
name|workfile
parameter_list|,
name|options
parameter_list|,
name|rev1
parameter_list|,
name|rev2
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
name|char
modifier|*
name|xrev1
decl_stmt|,
modifier|*
name|xrev2
decl_stmt|;
name|char
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|char
modifier|*
name|diffout
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|assert
argument_list|(
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"RCS file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Calculate numeric revision numbers from rev1 and rev2 (may be        symbolic). */
name|xrev1
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|rev1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xrev2
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|rev2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check out chosen revisions.  The error message when RCS_checkout        fails is not very informative -- it is taken verbatim from RCS 5.7,        and relies on RCS_checkout saying something intelligent upon failure. */
name|cvs_output
argument_list|(
literal|"retrieving revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|xrev1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|xrev1
argument_list|,
name|rev1
argument_list|,
name|options
argument_list|,
name|tmp1
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|cvs_outerr
argument_list|(
literal|"rcsmerge: co failed\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"retrieving revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|xrev2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|xrev2
argument_list|,
name|rev2
argument_list|,
name|options
argument_list|,
name|tmp2
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|cvs_outerr
argument_list|(
literal|"rcsmerge: co failed\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
comment|/* Merge changes. */
name|cvs_output
argument_list|(
literal|"Merging differences between "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|xrev1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" and "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|xrev2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" into "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|workfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Remember that the first word in the `call_diff_setup' string is used now        only for diagnostic messages -- CVS no longer forks to run diff3. */
name|diffout
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|call_diff_setup
argument_list|(
literal|"diff3"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
literal|"-E"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
literal|"-am"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
literal|"-L"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
literal|"-L"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|xrev1
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
literal|"-L"
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|xrev2
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|retval
operator|=
name|call_diff3
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|1
condition|)
name|cvs_outerr
argument_list|(
literal|"rcsmerge: warning: conflicts during merge\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
name|error_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|diffout
condition|)
name|copy_file
argument_list|(
name|diffout
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
comment|/* Clean up. */
block|{
name|int
name|save_noexec
init|=
name|noexec
decl_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file %s"
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmp2
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file %s"
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffout
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|diffout
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file %s"
argument_list|,
name|diffout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xrev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xrev2
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Diff revisions and/or files.  OPTS controls the format of the diff    (it contains options such as "-w -c",&c), or "" for the default.    OPTIONS controls keyword expansion, as a string starting with "-k",    or "" to use the default.  REV1 is the first revision to compare    against; it must be non-NULL.  If REV2 is non-NULL, compare REV1    and REV2; if REV2 is NULL compare REV1 with the file in the working    directory, whose name is WORKFILE.  LABEL1 and LABEL2 are default    file labels, and (if non-NULL) should be added as -L options    to diff.  Output goes to stdout.     Return value is 0 for success, -1 for a failure which set errno,    or positive for a failure which printed a message on stderr.     This used to exec rcsdiff, but now calls RCS_checkout and diff_exec.     An issue is what timezone is used for the dates which appear in the    diff output.  rcsdiff uses the -z flag, which is not presently    processed by CVS diff, but I'm not sure exactly how hard to worry    about this--any such features are undocumented in the context of    CVS, and I'm not sure how important to users.  */
end_comment

begin_function
name|int
name|RCS_exec_rcsdiff
parameter_list|(
name|rcsfile
parameter_list|,
name|opts
parameter_list|,
name|options
parameter_list|,
name|rev1
parameter_list|,
name|rev2
parameter_list|,
name|label1
parameter_list|,
name|label2
parameter_list|,
name|workfile
parameter_list|)
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
name|char
modifier|*
name|label1
decl_stmt|;
name|char
modifier|*
name|label2
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
block|{
name|char
modifier|*
name|tmpfile1
decl_stmt|;
name|char
modifier|*
name|tmpfile2
decl_stmt|;
name|char
modifier|*
name|use_file2
decl_stmt|;
name|int
name|status
decl_stmt|,
name|retval
decl_stmt|;
name|tmpfile1
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|tmpfile2
operator|=
name|NULL
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\ ===================================================================\n\ RCS file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Historically, `cvs diff' has expanded the $Name keyword to the        empty string when checking out revisions.  This is an accident,        but no one has considered the issue thoroughly enough to determine        what the best behavior is.  Passing NULL for the `nametag' argument        preserves the existing behavior. */
name|cvs_output
argument_list|(
literal|"retrieving revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|rev1
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
name|tmpfile1
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|retval
operator|=
name|status
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot check out revision %s of %s"
argument_list|,
name|rev1
argument_list|,
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|rev2
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|workfile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|use_file2
operator|=
name|workfile
expr_stmt|;
block|}
else|else
block|{
name|tmpfile2
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|cvs_output
argument_list|(
literal|"retrieving revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|rev2
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
name|tmpfile2
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|retval
operator|=
name|status
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot check out revision %s of %s"
argument_list|,
name|rev2
argument_list|,
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|use_file2
operator|=
name|tmpfile2
expr_stmt|;
block|}
name|RCS_output_diff_options
argument_list|(
name|opts
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|,
name|workfile
argument_list|)
expr_stmt|;
name|status
operator|=
name|diff_execv
argument_list|(
name|tmpfile1
argument_list|,
name|use_file2
argument_list|,
name|label1
argument_list|,
name|label2
argument_list|,
name|opts
argument_list|,
name|RUN_TTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|retval
operator|=
name|status
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot diff %s and %s"
argument_list|,
name|tmpfile1
argument_list|,
name|use_file2
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|error_return
label|:
block|{
name|int
name|save_noexec
init|=
name|noexec
decl_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file %s"
argument_list|,
name|tmpfile1
argument_list|)
expr_stmt|;
block|}
name|noexec
operator|=
name|save_noexec
expr_stmt|;
block|}
name|free
argument_list|(
name|tmpfile1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfile2
operator|!=
name|NULL
condition|)
block|{
name|int
name|save_noexec
init|=
name|noexec
decl_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile2
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file %s"
argument_list|,
name|tmpfile2
argument_list|)
expr_stmt|;
block|}
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|free
argument_list|(
name|tmpfile2
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Show differences between two files.  This is the start of a diff library.     Some issues:     * Should option parsing be part of the library or the caller?  The    former allows the library to add options without changing the callers,    but it causes various problems.  One is that something like --brief really    wants special handling in CVS, and probably the caller should retain    some flexibility in this area.  Another is online help (the library could    have some feature for providing help, but how does that interact with    the help provided by the caller directly?).  Another is that as things    stand currently, there is no separate namespace for diff options versus    "cvs diff" options like -l (that is, if the library adds an option which    conflicts with a CVS option, it is trouble).     * This isn't required for a first-cut diff library, but if there    would be a way for the caller to specify the timestamps that appear    in the diffs (rather than the library getting them from the files),    that would clean up the kludgy utime() calls in patch.c.     Show differences between FILE1 and FILE2.  Either one can be    DEVNULL to indicate a nonexistent file (same as an empty file    currently, I suspect, but that may be an issue in and of itself).    OPTIONS is a list of diff options, or "" if none.  At a minimum,    CVS expects that -c (update.c, patch.c) and -n (update.c) will be    supported.  Other options, like -u, --speed-large-files,&c, will    be specified if the user specified them.     OUT is a filename to send the diffs to, or RUN_TTY to send them to    stdout.  Error messages go to stderr.  Return value is 0 for    success, -1 for a failure which set errno, 1 for success (and some    differences were found), or>1 for a failure which printed a    message on stderr.  */
end_comment

begin_function
name|int
name|diff_exec
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|,
name|options
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
block|{
name|char
modifier|*
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* If either file1 or file2 are special files, pretend they are        /dev/null.  Reason: suppose a file that represents a block        special device in one revision becomes a regular file.  CVS        must find the `difference' between these files, but a special        file contains no data useful for calculating this metric.  The        safe thing to do is to treat the special file as an empty file,        thus recording the regular file's full contents.  Doing so will        create extremely large deltas at the point of transition        between device files and regular files, but this is probably        very rare anyway.         There may be ways around this, but I think they are fraught        with danger. -twp */
if|if
condition|(
name|preserve_perms
operator|&&
name|strcmp
argument_list|(
name|file1
argument_list|,
name|DEVNULL
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|file2
argument_list|,
name|DEVNULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file1
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get file information for %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file2
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get file information for %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
condition|)
name|file1
operator|=
name|DEVNULL
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb2
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|sb2
operator|.
name|st_mode
argument_list|)
condition|)
name|file2
operator|=
name|DEVNULL
expr_stmt|;
block|}
endif|#
directive|endif
name|args
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* The first word in this string is used only for error reporting. */
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"diff %s"
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|call_diff_setup
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|call_diff
argument_list|(
name|out
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|diff_execv
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|,
name|label1
parameter_list|,
name|label2
parameter_list|,
name|options
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
name|char
modifier|*
name|label1
decl_stmt|;
name|char
modifier|*
name|label2
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
block|{
name|char
modifier|*
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* Pretend that special files are /dev/null for purposes of making        diffs.  See comments in diff_exec. */
if|if
condition|(
name|preserve_perms
operator|&&
name|strcmp
argument_list|(
name|file1
argument_list|,
name|DEVNULL
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|file2
argument_list|,
name|DEVNULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file1
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get file information for %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file2
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get file information for %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
condition|)
name|file1
operator|=
name|DEVNULL
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb2
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|sb2
operator|.
name|st_mode
argument_list|)
condition|)
name|file2
operator|=
name|DEVNULL
expr_stmt|;
block|}
endif|#
directive|endif
name|args
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* The first word in this string is used only for error reporting.  */
comment|/* I guess we are pretty confident that options starts with a space.  */
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"diff%s"
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|call_diff_setup
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|label1
condition|)
name|call_diff_arg
argument_list|(
name|label1
argument_list|)
expr_stmt|;
if|if
condition|(
name|label2
condition|)
name|call_diff_arg
argument_list|(
name|label2
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|call_diff_arg
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|call_diff
argument_list|(
name|out
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the options passed to DIFF, in the format used by rcsdiff.    The rcsdiff code that produces this output is extremely hairy, and    it is not clear how rcsdiff decides which options to print and    which not to print.  The code below reproduces every rcsdiff run    that I have seen. */
end_comment

begin_function
specifier|static
name|void
name|RCS_output_diff_options
parameter_list|(
name|opts
parameter_list|,
name|rev1
parameter_list|,
name|rev2
parameter_list|,
name|workfile
parameter_list|)
name|char
modifier|*
name|opts
decl_stmt|;
name|char
modifier|*
name|rev1
decl_stmt|;
name|char
modifier|*
name|rev2
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|opts
argument_list|)
operator|+
name|strlen
argument_list|(
name|rev1
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"diff%s -r%s"
argument_list|,
name|opts
argument_list|,
name|rev1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
condition|)
block|{
name|cvs_output
argument_list|(
literal|" -r"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|workfile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|workfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

