begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * The functions in this file provide an interface for performing   * operations directly on RCS files.   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* This file, rcs.h, and rcs.c, are intended to define our interface    to RCS files.  As of July, 1996, there are still a few places that    still exec RCS commands directly.  The intended long-term direction    is to have CVS access RCS files via an RCS library (rcs.c can be    considered a start at one), for performance, cleanliness (CVS has    some awful hacks to work around RCS behaviors which don't make    sense for CVS), installation hassles, ease of implementing the CVS    server (I don't think that the output-out-of-order bug can be    completely fixed as long as CVS calls RCS), and perhaps other    reasons.     Whether there will also be a version of RCS which uses this    library, or whether the library will be packaged for uses beyond    CVS or RCS (many people would like such a thing) is an open    question.  Some considerations:     1.  An RCS library for CVS must have the capabilities of the    existing CVS code which accesses RCS files.  In particular, simple    approaches will often be slow.     2.  An RCS library should not use the code from the current RCS    (5.7 and its ancestors).  The code has many problems.  Too few    comments, too many layers of abstraction, too many global variables    (the correct number for a library is zero), too much intricately    interwoven functionality, and too many clever hacks.  Paul Eggert,    the current RCS maintainer, agrees.     3.  More work needs to be done in terms of separating out the RCS    library from the rest of CVS (for example, cvs_output should be    replaced by a callback, and the declarations should be centralized    into rcs.h, and probably other such cleanups).     4.  To be useful for RCS and perhaps for other uses, the library    may need features beyond those needed by CVS.     5.  Any changes to the RCS file format *must* be compatible.  Many,    many tools (not just CVS and RCS) can at least import this format.    RCS and CVS must preserve the current ability to import/export it    (preferably improved--magic branches are currently a roadblock).    See doc/RCSFILES in the CVS distribution for documentation of this    file format.     On somewhat related notes:     1.  A library for diff is an obvious idea.  The one thing which I'm    not so sure about is that I think CVS probably wants the ability to    allow arbitrarily-bizarre (and possibly customized for particular    file formats) external diff programs.     2.  A library for patch is another such idea.  CVS's needs are    smaller than the functionality of the standalone patch program (it    only calls patch in the client, and only needs to be able to patch    unmodified versions, which is something that RCS_deltas already    does in a different context).  But it is silly for CVS to be making    people install patch as well as CVS for such a simple purpose.  */
end_comment

begin_comment
comment|/* For RCS file PATH, make symbolic tag TAG point to revision REV.    This validates that TAG is OK for a user to use.  Return value is    -1 for error (and errno is set to indicate the error), positive for    error (and an error message has been printed), or zero for success.  */
end_comment

begin_function
name|int
name|RCS_exec_settag
parameter_list|(
name|path
parameter_list|,
name|tag
parameter_list|,
name|rev
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -q -N%s:%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|tag
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* NOERR is 1 to suppress errors--FIXME it would    be better to avoid the errors or some cleaner solution.  */
end_comment

begin_function
name|int
name|RCS_exec_deltag
parameter_list|(
name|path
parameter_list|,
name|tag
parameter_list|,
name|noerr
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -q -N%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|noerr
condition|?
name|DEVNULL
else|:
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* set RCS branch to REV */
end_comment

begin_function
name|int
name|RCS_exec_setbranch
parameter_list|(
name|path
parameter_list|,
name|rev
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -q -b%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|rev
condition|?
name|rev
else|:
literal|""
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lock revision REV.  NOERR is 1 to suppress errors--FIXME it would    be better to avoid the errors or some cleaner solution.  */
end_comment

begin_function
name|int
name|RCS_exec_lock
parameter_list|(
name|path
parameter_list|,
name|rev
parameter_list|,
name|noerr
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -q -l%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|rev
condition|?
name|rev
else|:
literal|""
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|noerr
condition|?
name|DEVNULL
else|:
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unlock revision REV.  NOERR is 1 to suppress errors--FIXME it would    be better to avoid the errors or some cleaner solution.  */
end_comment

begin_function
name|int
name|RCS_exec_unlock
parameter_list|(
name|path
parameter_list|,
name|rev
parameter_list|,
name|noerr
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|noerr
decl_stmt|;
block|{
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -q -u%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|rev
condition|?
name|rev
else|:
literal|""
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|noerr
condition|?
name|DEVNULL
else|:
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge revisions REV1 and REV2. */
end_comment

begin_function
name|int
name|RCS_merge
parameter_list|(
name|path
parameter_list|,
name|options
parameter_list|,
name|rev1
parameter_list|,
name|rev2
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev1
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev2
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
comment|/* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */
name|run_setup
argument_list|(
literal|"%s%s -x,v/ %s -r%s -r%s %s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_RCSMERGE
argument_list|,
name|options
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS no longer supports RCS versions older than RCS5"
argument_list|)
expr_stmt|;
comment|/* This case needs to call file_has_markers to see if the file 	   contains conflict indicators.  But is anyone using the !HAVE_RCS5 	   code any more?  */
block|}
endif|#
directive|endif
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Check in to RCSFILE with revision REV (which must be greater than the    largest revision) and message MESSAGE (which is checked for legality).    If FLAGS& RCS_FLAGS_DEAD, check in a dead revision.  If FLAGS&    RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS& RCS_FLAGS_MODTIME,    use the working file's modification time for the checkin time.    WORKFILE is the working file to check in from, or NULL to use the usual    RCS rules for deriving it from the RCSFILE.        Return value is -1 for error (and errno is set to indicate the    error), positive for error (and an error message has been printed),    or zero for success.  */
end_comment

begin_function
name|int
name|RCS_checkin
parameter_list|(
name|rcsfile
parameter_list|,
name|workfile
parameter_list|,
name|message
parameter_list|,
name|rev
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|workfile
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* The desired behavior regarding permissions is to preserve the        permissions on RCSFILE if it already exists.  Based on looking        at the RCS 5.7 source, it would appear that RCS_CI does this        except when it is creating RCSFILE (reasonable), or when        RCSFILE was created with rcs -i (this is strange, and quite        possibly unintentional).  In those two cases it copies the        permissions from the workfile.         Anyway, the fix is simple enough: we preserve the mode ourself.  */
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fix_mode
init|=
literal|1
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|rcsfile
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fix_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot stat %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -w%s -f %s%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CI
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|rev
condition|?
literal|"-r"
else|:
literal|""
argument_list|,
name|rev
condition|?
name|rev
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RCS_FLAGS_DEAD
condition|)
name|run_arg
argument_list|(
literal|"-sdead"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RCS_FLAGS_QUIET
condition|)
name|run_arg
argument_list|(
literal|"-q"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RCS_FLAGS_MODTIME
condition|)
name|run_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|run_args
argument_list|(
literal|"-m%s"
argument_list|,
name|make_message_rcslegal
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|workfile
operator|!=
name|NULL
condition|)
name|run_arg
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
name|retval
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
operator|&&
name|fix_mode
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|rcsfile
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot change permissions on %s"
argument_list|,
name|rcsfile
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

end_unit

