begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * A simple ndbm-emulator for CVS.  It parses a text file of the format:  *   * key	value  *   * at dbm_open time, and loads the entire file into memory.  As such, it is  * probably only good for fairly small modules files.  Ours is about 30K in  * size, and this code works fine.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MY_NDBM
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|mydbm_load_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns NULL on error in which case errno has been set to indicate    the error.  Can also call error() itself.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|DBM
modifier|*
name|mydbm_open
parameter_list|(
name|file
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|file
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|existence_error
argument_list|(
name|errno
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|)
condition|)
return|return
operator|(
operator|(
name|DBM
operator|*
operator|)
literal|0
operator|)
return|;
name|db
operator|=
operator|(
name|DBM
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|dbm_list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|db
operator|->
name|modified
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|mydbm_load_file
argument_list|(
name|fp
argument_list|,
name|db
operator|->
name|dbm_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|write_item
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|write_item
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
name|fputs
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\012"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mydbm_close
parameter_list|(
name|db
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
block|{
if|if
condition|(
name|db
operator|->
name|modified
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|db
operator|->
name|name
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|db
operator|->
name|dbm_list
argument_list|,
name|write_item
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|db
operator|->
name|name
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|db
operator|->
name|dbm_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|datum
name|mydbm_fetch
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
name|datum
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|datum
name|val
decl_stmt|;
comment|/* make sure it's null-terminated */
name|s
operator|=
name|xmalloc
argument_list|(
name|key
operator|.
name|dsize
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|s
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|key
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|s
index|[
name|key
operator|.
name|dsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|db
operator|->
name|dbm_list
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|val
operator|.
name|dptr
operator|=
name|p
operator|->
name|data
expr_stmt|;
name|val
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|val
operator|.
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|datum
name|mydbm_firstkey
parameter_list|(
name|db
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|head
operator|=
name|db
operator|->
name|dbm_list
operator|->
name|list
expr_stmt|;
name|p
operator|=
name|head
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|head
condition|)
block|{
name|key
operator|.
name|dptr
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
name|db
operator|->
name|dbm_next
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
end_function

begin_function
name|datum
name|mydbm_nextkey
parameter_list|(
name|db
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|head
operator|=
name|db
operator|->
name|dbm_list
operator|->
name|list
expr_stmt|;
name|p
operator|=
name|db
operator|->
name|dbm_next
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|head
condition|)
block|{
name|key
operator|.
name|dptr
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
name|db
operator|->
name|dbm_next
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Note: only updates the in-memory copy, which is written out at    mydbm_close time.  Note: Also differs from DBM in that on duplication,    it gives a warning, rather than either DBM_INSERT or DBM_REPLACE    behavior.  */
end_comment

begin_function
name|int
name|mydbm_store
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|,
name|value
parameter_list|,
name|flags
parameter_list|)
name|DBM
modifier|*
name|db
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|value
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|NDBMNODE
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xmalloc
argument_list|(
name|key
operator|.
name|dsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|key
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|node
operator|->
name|key
index|[
name|key
operator|.
name|dsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|value
operator|.
name|dsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|value
operator|.
name|dptr
argument_list|,
name|value
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
index|[
name|value
operator|.
name|dsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|db
operator|->
name|modified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|db
operator|->
name|dbm_list
argument_list|,
name|node
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"attempt to insert duplicate key `%s'"
argument_list|,
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mydbm_load_file
parameter_list|(
name|fp
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_size
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|size_t
name|value_allocated
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|cont
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|value_allocated
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
name|value_allocated
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getstr
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_size
argument_list|,
name|fp
argument_list|,
literal|'\012'
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|line_length
operator|>
literal|0
operator|&&
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\012'
condition|)
block|{
comment|/* Strip the newline.  */
operator|--
name|line_length
expr_stmt|;
name|line
index|[
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|line_length
operator|>
literal|0
operator|&&
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\015'
condition|)
block|{
comment|/* If the file (e.g. modules) was written on an NT box, it will 	       contain CRLF at the ends of lines.  Strip them (we can't do 	       this by opening the file in text mode because we might be 	       running on unix).  */
operator|--
name|line_length
expr_stmt|;
name|line
index|[
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Add the line to the value, at the end if this is a continuation 	 * line; otherwise at the beginning, but only after any trailing 	 * backslash is removed. 	 */
if|if
condition|(
operator|!
name|cont
condition|)
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * See if the line we read is a continuation line, and strip the 	 * backslash if so. 	 */
if|if
condition|(
name|line_length
operator|>
literal|0
condition|)
name|cp
operator|=
operator|&
name|line
index|[
name|line_length
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
condition|)
block|{
name|cont
operator|=
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|line_length
expr_stmt|;
block|}
else|else
block|{
name|cont
operator|=
literal|0
expr_stmt|;
block|}
name|expand_string
argument_list|(
operator|&
name|value
argument_list|,
operator|&
name|value_allocated
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|line_length
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|value
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* comment line */
name|vp
operator|=
name|value
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* empty line */
comment|/* 	 * If this was not a continuation line, add the entry to the database 	 */
if|if
condition|(
operator|!
name|cont
condition|)
block|{
name|Node
modifier|*
name|p
init|=
name|getnode
argument_list|()
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|kp
operator|=
name|vp
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* NULL terminate the key */
name|p
operator|->
name|type
operator|=
name|NDBMNODE
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|kp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|vp
argument_list|)
condition|)
name|vp
operator|++
expr_stmt|;
comment|/* skip whitespace to value */
if|if
condition|(
operator|*
name|vp
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: NULL value for key `%s'"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate key found for `%s'"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
comment|/* FIXME: should give the name of the file.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read file in mydbm_load_file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MY_NDBM */
end_comment

end_unit

