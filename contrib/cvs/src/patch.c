begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1986-2005 The Free Software Foundation, Inc.  *  * Portions Copyright (C) 1998-2005 Derek Price, Ximbiot<http://ximbiot.com>,  *                                  and others.  *  * Portions Copyright (C) 1992, Brian Berliner and Jeff Polk  * Portions Copyright (C) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Patch  *   * Create a Larry Wall format "patch" file between a previous release and the  * current head of a module, or between two releases.  Can specify the  * release as either a date or a revision number.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|patch_cleanup
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|patch_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
specifier|const
name|char
operator|*
name|dir
operator|,
specifier|const
name|char
operator|*
name|repos
operator|,
specifier|const
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_proc
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|char
operator|*
name|xwhere
operator|,
name|char
operator|*
name|mwhere
operator|,
name|char
operator|*
name|mfile
operator|,
name|int
name|shorten
operator|,
name|int
name|local_specified
operator|,
name|char
operator|*
name|mname
operator|,
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|force_tag_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_short
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|toptwo_diffs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rev1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rev1_validated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rev2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rev2_validated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|date2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpfile1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpfile2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpfile3
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unidiff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|patch_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-flR] [-c|-u] [-s|-t] [-V %%d] [-k kopt]\n"
block|,
literal|"    -r rev|-D date [-r rev2 | -D date2] modules...\n"
block|,
literal|"\t-f\tForce a head revision match if tag/date not found.\n"
block|,
literal|"\t-l\tLocal directory only, not recursive\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-c\tContext diffs (default)\n"
block|,
literal|"\t-u\tUnidiff format.\n"
block|,
literal|"\t-s\tShort patch - one liner per file.\n"
block|,
literal|"\t-t\tTop two diffs - last change made to the file.\n"
block|,
literal|"\t-V vers\tUse RCS Version \"vers\" for keyword expansion.\n"
block|,
literal|"\t-k kopt\tSpecify keyword expansion mode.\n"
block|,
literal|"\t-D date\tDate.\n"
block|,
literal|"\t-r rev\tRevision - symbolic or numeric.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|patch
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|patch_usage
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+V:k:cuftsQqlRD:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
comment|/* The CVS 1.5 client sends these options (in addition to 		   Global_option requests), so we must ignore them.  */
if|if
condition|(
operator|!
name|server_active
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-q or -Q must be specified before \"%s\""
argument_list|,
name|cvs_cmd_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_tag_match
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|toptwo_diffs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|patch_short
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|rev2
operator|!=
name|NULL
operator|||
name|date2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no more than two revisions/dates can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|!=
name|NULL
operator|||
name|date1
operator|!=
name|NULL
condition|)
name|date2
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
name|date1
operator|=
name|Make_Date
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|rev2
operator|!=
name|NULL
operator|||
name|date2
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no more than two revisions/dates can be specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|!=
name|NULL
operator|||
name|date1
operator|!=
name|NULL
condition|)
name|rev2
operator|=
name|optarg
expr_stmt|;
else|else
name|rev1
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* This option is pretty seriously broken: 		   1.  It is not clear what it does (does it change keyword 		   expansion behavior?  If so, how?  Or does it have 		   something to do with what version of RCS we are using? 		   Or the format we write RCS files in?). 		   2.  Because both it and -k use the options variable, 		   specifying both -V and -k doesn't work. 		   3.  At least as of CVS 1.9, it doesn't work (failed 		   assertion in RCS_checkout where it asserts that options 		   starts with -k).  Few people seem to be complaining. 		   In the future (perhaps the near future), I have in mind 		   removing it entirely, and updating NEWS and cvs.texinfo, 		   but in case it is a good idea to give people more time 		   to complain if they would miss it, I'll just add this 		   quick and dirty error message for now.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"the -V option is obsolete and should not be used"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (atoi (optarg)<= 0) 		    error (1, 0, "must specify a version number to -V"); 		if (options) 		    free (options); 		options = xmalloc (strlen (optarg) + 1 + 2);
comment|/* for the -V */
block|(void) sprintf (options, "-V%s", optarg);
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
name|unidiff
operator|=
literal|1
expr_stmt|;
comment|/* Unidiff */
break|break;
case|case
literal|'c'
case|:
comment|/* Context diff */
name|unidiff
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|patch_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|patch_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|toptwo_diffs
operator|&&
name|patch_short
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-t and -s options are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toptwo_diffs
operator|&&
operator|(
name|date1
operator|!=
name|NULL
operator|||
name|date2
operator|!=
name|NULL
operator|||
name|rev1
operator|!=
name|NULL
operator|||
name|rev2
operator|!=
name|NULL
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"must not specify revisions/dates with -t option!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toptwo_diffs
operator|&&
operator|(
name|date1
operator|==
name|NULL
operator|&&
name|date2
operator|==
name|NULL
operator|&&
name|rev1
operator|==
name|NULL
operator|&&
name|rev2
operator|==
name|NULL
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"must specify at least one revision/date!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|date1
operator|!=
name|NULL
operator|&&
name|date2
operator|!=
name|NULL
condition|)
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|date1
argument_list|,
name|date2
argument_list|)
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"second date must come after first date!"
argument_list|)
expr_stmt|;
comment|/* if options is NULL, make it a NULL string */
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
comment|/* We're the client side.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force_tag_match
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|toptwo_diffs
condition|)
name|send_arg
argument_list|(
literal|"-t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch_short
condition|)
name|send_arg
argument_list|(
literal|"-s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unidiff
condition|)
name|send_arg
argument_list|(
literal|"-u"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
condition|)
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|date1
condition|)
name|client_senddate
argument_list|(
name|date1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
condition|)
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|date2
condition|)
name|client_senddate
argument_list|(
name|date2
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|send_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"rdiff\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* clean up if we get a signal */
ifdef|#
directive|ifdef
name|SIGABRT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGABRT
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|patch_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|PATCH
argument_list|,
literal|"Patching"
argument_list|,
name|patch_proc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|patch_cleanup
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * callback proc for doing the real work of patching  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|patch_proc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xwhere
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|mname
parameter_list|,
name|msg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|xwhere
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
modifier|*
name|myargv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* if mfile isn't null, we need to set up to do only part of the module */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* if the portion of the module is a path, put the dir part on repos */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* take care of the rest */
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* directory means repository gets the dir tacked on */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|myargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|myargv
index|[
literal|1
index|]
operator|=
name|mfile
expr_stmt|;
name|argc
operator|=
literal|2
expr_stmt|;
name|argv
operator|=
name|myargv
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* cd to the starting repository */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|force_tag_match
condition|)
name|which
operator|=
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
else|else
name|which
operator|=
name|W_REPOS
expr_stmt|;
if|if
condition|(
name|rev1
operator|!=
name|NULL
operator|&&
operator|!
name|rev1_validated
condition|)
block|{
name|tag_check_valid
argument_list|(
name|rev1
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local_specified
argument_list|,
literal|0
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rev1_validated
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rev2
operator|!=
name|NULL
operator|&&
operator|!
name|rev2_validated
condition|)
block|{
name|tag_check_valid
argument_list|(
name|rev2
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local_specified
argument_list|,
literal|0
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|rev2_validated
operator|=
literal|1
expr_stmt|;
block|}
comment|/* start the recursion processor */
name|err
operator|=
name|start_recursion
argument_list|(
name|patch_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|patch_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local_specified
argument_list|,
name|which
argument_list|,
literal|0
argument_list|,
name|CVS_LOCK_READ
argument_list|,
name|where
argument_list|,
literal|1
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|where
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Called to examine a particular RCS file, as appropriate with the options  * that were set above.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|patch_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|struct
name|utimbuf
name|t
decl_stmt|;
name|char
modifier|*
name|vers_tag
decl_stmt|,
modifier|*
name|vers_head
decl_stmt|;
name|char
modifier|*
name|rcs
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rcs_orig
init|=
name|NULL
decl_stmt|;
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|FILE
modifier|*
name|fp1
decl_stmt|,
modifier|*
name|fp2
decl_stmt|,
modifier|*
name|fp3
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|isattic
init|=
literal|0
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file1
decl_stmt|;
name|char
modifier|*
name|file2
decl_stmt|;
name|char
modifier|*
name|strippath
decl_stmt|;
name|char
modifier|*
name|line1
decl_stmt|,
modifier|*
name|line2
decl_stmt|;
name|size_t
name|line1_chars_allocated
decl_stmt|;
name|size_t
name|line2_chars_allocated
decl_stmt|;
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|int
name|dargc
init|=
literal|0
decl_stmt|;
name|size_t
name|darg_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|dargv
init|=
name|NULL
decl_stmt|;
name|line1
operator|=
name|NULL
expr_stmt|;
name|line1_chars_allocated
operator|=
literal|0
expr_stmt|;
name|line2
operator|=
name|NULL
expr_stmt|;
name|line2_chars_allocated
operator|=
literal|0
expr_stmt|;
name|vers_tag
operator|=
name|vers_head
operator|=
name|NULL
expr_stmt|;
comment|/* find the parsed rcs file */
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|finfo
operator|->
name|rcs
operator|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
operator|(
name|rcsfile
operator|->
name|flags
operator|&
name|VALID
operator|)
operator|&&
operator|(
name|rcsfile
operator|->
name|flags
operator|&
name|INATTIC
operator|)
condition|)
name|isattic
operator|=
literal|1
expr_stmt|;
name|rcs_orig
operator|=
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s%s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
comment|/* if vers_head is NULL, may have been removed from the release */
if|if
condition|(
name|isattic
operator|&&
name|rev2
operator|==
name|NULL
operator|&&
name|date2
operator|==
name|NULL
condition|)
name|vers_head
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|vers_head
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|rev2
argument_list|,
name|date2
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_head
operator|!=
name|NULL
operator|&&
name|RCS_isdead
argument_list|(
name|rcsfile
argument_list|,
name|vers_head
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|vers_head
argument_list|)
expr_stmt|;
name|vers_head
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toptwo_diffs
condition|)
block|{
if|if
condition|(
name|vers_head
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
operator|!
name|date1
condition|)
name|date1
operator|=
name|xmalloc
argument_list|(
name|MAXDATELEN
argument_list|)
expr_stmt|;
operator|*
name|date1
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|RCS_getrevtime
argument_list|(
name|rcsfile
argument_list|,
name|vers_head
argument_list|,
name|date1
argument_list|,
literal|1
argument_list|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find date in rcs file %s revision %s"
argument_list|,
name|rcs
argument_list|,
name|vers_head
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
name|vers_tag
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|rev1
argument_list|,
name|date1
argument_list|,
name|force_tag_match
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_tag
operator|!=
name|NULL
operator|&&
name|RCS_isdead
argument_list|(
name|rcsfile
argument_list|,
name|vers_tag
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|vers_tag
argument_list|)
expr_stmt|;
name|vers_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vers_tag
operator|==
name|NULL
operator|&&
name|vers_head
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vers_tag
operator|!=
name|NULL
operator|&&
name|vers_head
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers_head
argument_list|,
name|vers_tag
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Nothing known about specified revs or 	 * not changed between releases. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|patch_short
operator|&&
operator|(
name|vers_tag
operator|==
name|NULL
operator|||
name|vers_head
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* For adds& removes with a short patch requested, we can print our 	 * error message now and get out. 	 */
name|cvs_output
argument_list|(
literal|"File "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_tag
operator|==
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|" is new; "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev2
condition|?
name|rev2
else|:
name|date2
condition|?
name|date2
else|:
literal|"current"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvs_output
argument_list|(
literal|" is removed; "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rev1
condition|?
name|rev1
else|:
name|date1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers_tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
comment|/* Create 3 empty files.  I'm not really sure there is any advantage      * to doing so now rather than just waiting until later.      *      * There is - cvs_temp_file opens the file so that it can guarantee that      * we have exclusive write access to the file.  Unfortunately we spoil that      * by closing it and reopening it again.  Of course any better solution      * requires that the RCS functions accept open file pointers rather than      * simple file names.      */
if|if
condition|(
operator|(
name|fp1
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|tmpfile1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|tmpfile1
condition|?
name|tmpfile1
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|fp1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|tmpfile1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp2
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|tmpfile2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|tmpfile2
condition|?
name|tmpfile2
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|fp2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|tmpfile2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp3
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|tmpfile3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|tmpfile3
condition|?
name|tmpfile3
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|fp3
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_tag
operator|!=
name|NULL
condition|)
block|{
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcsfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_tag
argument_list|,
name|rev1
argument_list|,
name|options
argument_list|,
name|tmpfile1
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot check out revision %s of %s"
argument_list|,
name|vers_tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|actime
operator|=
name|t
operator|.
name|modtime
operator|=
name|RCS_getrevtime
argument_list|(
name|rcsfile
argument_list|,
name|vers_tag
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
comment|/* I believe this timestamp only affects the dates in our diffs, 	       and therefore should be on the server, not the client.  */
operator|(
name|void
operator|)
name|utime
argument_list|(
name|tmpfile1
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toptwo_diffs
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vers_head
operator|!=
name|NULL
condition|)
block|{
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcsfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vers_head
argument_list|,
name|rev2
argument_list|,
name|options
argument_list|,
name|tmpfile2
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot check out revision %s of %s"
argument_list|,
name|vers_head
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|t
operator|.
name|actime
operator|=
name|t
operator|.
name|modtime
operator|=
name|RCS_getrevtime
argument_list|(
name|rcsfile
argument_list|,
name|vers_head
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
comment|/* I believe this timestamp only affects the dates in our diffs, 	       and therefore should be on the server, not the client.  */
operator|(
name|void
operator|)
name|utime
argument_list|(
name|tmpfile2
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unidiff
condition|)
name|run_add_arg_p
argument_list|(
operator|&
name|dargc
argument_list|,
operator|&
name|darg_allocated
argument_list|,
operator|&
name|dargv
argument_list|,
literal|"-u"
argument_list|)
expr_stmt|;
else|else
name|run_add_arg_p
argument_list|(
operator|&
name|dargc
argument_list|,
operator|&
name|darg_allocated
argument_list|,
operator|&
name|dargv
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|diff_exec
argument_list|(
name|tmpfile1
argument_list|,
name|tmpfile2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dargc
argument_list|,
name|dargv
argument_list|,
name|tmpfile3
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* fork/wait failure */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork for diff failed on %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* nothing to do */
break|break;
case|case
literal|1
case|:
comment|/* 	     * The two revisions are really different, so read the first two 	     * lines of the diff output file, and munge them to include more 	     * reasonable file names that "patch" will understand, unless the 	     * user wanted a short patch.  In that case, just output the short 	     * message. 	     */
if|if
condition|(
name|patch_short
condition|)
block|{
name|cvs_output
argument_list|(
literal|"File "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" changed from revision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers_tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" to "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|vers_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Output an "Index:" line for patch to use */
name|cvs_output
argument_list|(
literal|"Index: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now the munging. */
name|fp
operator|=
name|open_file
argument_list|(
name|tmpfile3
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|line1_chars_allocated
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
operator|||
name|getline
argument_list|(
operator|&
name|line2
argument_list|,
operator|&
name|line2_chars_allocated
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ failed to read diff file header %s for %s: end of file"
argument_list|,
name|tmpfile3
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to read diff file header %s for %s"
argument_list|,
name|tmpfile3
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|unidiff
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line1
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
name|strncmp
argument_list|(
name|line2
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|cp1
operator|=
name|strchr
argument_list|(
name|line1
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cp2
operator|=
name|strchr
argument_list|(
name|line2
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid diff header for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|line1
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
name|strncmp
argument_list|(
name|line2
argument_list|,
literal|"+++ "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|cp1
operator|=
name|strchr
argument_list|(
name|line1
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cp2
operator|=
name|strchr
argument_list|(
name|line2
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid unidiff header for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error closing %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|assert
argument_list|(
name|current_parsed_root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|current_parsed_root
operator|->
name|directory
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|{
name|strippath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|strippath
argument_list|,
literal|"%s/"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
block|}
comment|/*else 		strippath = xstrdup (REPOS_STRIP); */
if|if
condition|(
name|strncmp
argument_list|(
name|rcs
argument_list|,
name|strippath
argument_list|,
name|strlen
argument_list|(
name|strippath
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|rcs
operator|+=
name|strlen
argument_list|(
name|strippath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strippath
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_tag
operator|!=
name|NULL
condition|)
block|{
name|file1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
operator|+
name|strlen
argument_list|(
name|vers_tag
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file1
argument_list|,
literal|"%s:%s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file1
operator|=
name|xstrdup
argument_list|(
name|DEVNULL
argument_list|)
expr_stmt|;
block|}
name|file2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
operator|+
operator|(
name|vers_head
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|vers_head
argument_list|)
else|:
literal|10
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file2
argument_list|,
literal|"%s:%s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers_head
condition|?
name|vers_head
else|:
literal|"removed"
argument_list|)
expr_stmt|;
comment|/* Note that the string "diff" is specified by POSIX (for -c) 	       and is part of the diff output format, not the name of a 	       program.  */
if|if
condition|(
name|unidiff
condition|)
block|{
name|cvs_output
argument_list|(
literal|"diff -u "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"--- "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|cp1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"+++ "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvs_output
argument_list|(
literal|"diff -c "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"*** "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|file1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|cp1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"--- "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|cp2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* spew the rest of the diff out */
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|line1_chars_allocated
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|cvs_output
argument_list|(
name|line1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"diff failed for %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|line1
condition|)
name|free
argument_list|(
name|line1
argument_list|)
expr_stmt|;
if|if
condition|(
name|line2
condition|)
name|free
argument_list|(
name|line2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfile1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmpfile1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot unlink %s"
argument_list|,
name|tmpfile1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile1
argument_list|)
expr_stmt|;
name|tmpfile1
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tmpfile2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmpfile2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot unlink %s"
argument_list|,
name|tmpfile2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile2
argument_list|)
expr_stmt|;
name|tmpfile2
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tmpfile3
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmpfile3
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot unlink %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile3
argument_list|)
expr_stmt|;
name|tmpfile3
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dargc
condition|)
block|{
name|run_arg_free_p
argument_list|(
name|dargc
argument_list|,
name|dargv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dargv
argument_list|)
expr_stmt|;
block|}
name|out2
label|:
if|if
condition|(
name|vers_tag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers_head
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|vers_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs_orig
condition|)
name|free
argument_list|(
name|rcs_orig
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|patch_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos
decl_stmt|;
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Diffing %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up temporary files  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|patch_cleanup
parameter_list|()
block|{
comment|/* Note that the checks for existence_error are because we are        called from a signal handler, without SIG_begincrsect, so        we don't know whether the files got created.  */
if|if
condition|(
name|tmpfile1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile1
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmpfile1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpfile2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile2
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmpfile2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpfile3
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink_file
argument_list|(
name|tmpfile3
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tmpfile3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpfile3
argument_list|)
expr_stmt|;
block|}
name|tmpfile1
operator|=
name|tmpfile2
operator|=
name|tmpfile3
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

