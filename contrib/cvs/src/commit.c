begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *  * Commit Files  *  * "commit" commits the present version to the RCS repository, AFTER  * having done a test on conflicts.  *  * The call is: cvs commit [options] files...  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"hardlink.h"
end_include

begin_decl_stmt
specifier|static
name|Dtype
name|check_direntproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|,
name|RCSNode
operator|*
operator|*
name|rcsnode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|commit_direntproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_dirleaveproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finaladd
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|char
operator|*
name|revision
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findmaxrev
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_RCS
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|,
name|RCSNode
operator|*
name|rcs
operator|,
name|char
operator|*
name|rev
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_rcs_modes
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixbranch
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unlockrcs
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ci_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|masterlist_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|locate_rcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|commit_info
block|{
name|Ctype
name|status
decl_stmt|;
comment|/* as returned from Classify_File() */
name|char
modifier|*
name|rev
decl_stmt|;
comment|/* a numeric rev, if we know it */
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* any sticky tag, or -r option */
name|char
modifier|*
name|options
decl_stmt|;
comment|/* Any sticky -k option */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
comment|/* list for Update_Logfile */
name|List
modifier|*
name|cilist
decl_stmt|;
comment|/* list with commit_info structs */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|force_ci
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|write_dirtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_dirnonbranch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|saved_ulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|commit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n"
block|,
literal|"\t-n\tDo not run the module program (if any).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-l\tLocal directory only (not recursive).\n"
block|,
literal|"\t-f\tForce the file to be committed; disables recursion.\n"
block|,
literal|"\t-F file\tRead the log message from file.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-r rev\tCommit to this branch or trunk revision.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* Identify a file which needs "? foo" or a Questionable request.  */
end_comment

begin_struct
struct|struct
name|question
block|{
comment|/* The two fields for the Directory request.  */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
comment|/* The file name.  */
name|char
modifier|*
name|file
decl_stmt|;
name|struct
name|question
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|find_data
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* This is used from dirent to filesdone time, for each directory,        to make a list of files we have already seen.  */
name|List
modifier|*
name|ignlist
decl_stmt|;
comment|/* Linked list of files which need "? foo" or a Questionable request.  */
name|struct
name|question
modifier|*
name|questionables
decl_stmt|;
comment|/* Only good within functions called from the filesdoneproc.  Stores        the repository (pointer into storage managed by the recursion        processor.  */
name|char
modifier|*
name|repository
decl_stmt|;
comment|/* Non-zero if we should force the commit.  This is enabled by        either -f or -r options, unlike force_ci which is just -f.  */
name|int
name|force
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|Dtype
name|find_dirent_proc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Dtype
name|find_dirent_proc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|struct
name|find_data
modifier|*
name|find_data
init|=
operator|(
expr|struct
name|find_data
operator|*
operator|)
name|callerdat
decl_stmt|;
comment|/* This check seems to slowly be creeping throughout CVS (update        and send_dirent_proc by CVS 1.5, diff in 31 Oct 1995.  My guess        is that it (or some variant thereof) should go in all the        dirent procs.  Unless someone has some better idea...  */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
comment|/* initialize the ignore list for this directory */
name|find_data
operator|->
name|ignlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* Print the same warm fuzzy as in check_direntproc, since that        code will never be run during client/server operation and we        want the messages to match. */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
name|R_PROCESS
return|;
block|}
end_function

begin_comment
comment|/* Here as a static until we get around to fixing ignore_files to pass    it along as an argument.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|find_data
modifier|*
name|find_data_static
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_ignproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_ignproc
parameter_list|(
name|file
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|question
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|question
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|question
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|dir
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|p
operator|->
name|repos
operator|=
name|xstrdup
argument_list|(
name|find_data_static
operator|->
name|repository
argument_list|)
expr_stmt|;
name|p
operator|->
name|file
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|find_data_static
operator|->
name|questionables
expr_stmt|;
name|find_data_static
operator|->
name|questionables
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|find_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|find_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|struct
name|find_data
modifier|*
name|find_data
init|=
operator|(
expr|struct
name|find_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|find_data
operator|->
name|repository
operator|=
name|repository
expr_stmt|;
comment|/* if this directory has an ignore list, process it then free it */
if|if
condition|(
name|find_data
operator|->
name|ignlist
condition|)
block|{
name|find_data_static
operator|=
name|find_data
expr_stmt|;
name|ignore_files
argument_list|(
name|find_data
operator|->
name|ignlist
argument_list|,
name|entries
argument_list|,
name|update_dir
argument_list|,
name|find_ignproc
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|find_data
operator|->
name|ignlist
argument_list|)
expr_stmt|;
block|}
name|find_data
operator|->
name|repository
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|find_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machinery to find out what is modified, added, and removed.  It is    possible this should be broken out into a new client_classify function;    merging it with classify_file is almost sure to be a mess, though,    because classify_file has all kinds of repository processing.  */
end_comment

begin_function
specifier|static
name|int
name|find_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|enum
name|classify_type
name|status
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|struct
name|find_data
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|data
decl_stmt|;
name|struct
name|file_info
name|xfinfo
decl_stmt|;
comment|/* if this directory has an ignore list, add this file to it */
if|if
condition|(
name|args
operator|->
name|ignlist
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|args
operator|->
name|ignlist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|xfinfo
operator|=
operator|*
name|finfo
expr_stmt|;
name|xfinfo
operator|.
name|repository
operator|=
name|NULL
expr_stmt|;
name|xfinfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|xfinfo
argument_list|,
name|NULL
argument_list|,
name|saved_tag
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
comment|/* FIXME: If vn_user is starts with "-" but ts_user is 	   non-NULL, what classify_file does is print "%s should be 	   removed and is still there".  I'm not sure what it does 	   then.  We probably should do the same.  */
name|status
operator|=
name|T_REMOVED
expr_stmt|;
elseif|else
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"use `%s add' to create an entry for %s"
argument_list|,
name|program_name
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
comment|/* FIXME: If vn_user is "0" but ts_user is NULL, what classify_file 	   does is print "new-born %s has disappeared" and removes the entry. 	   We probably should do the same.  */
name|status
operator|=
name|T_ADDED
expr_stmt|;
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|ts_rcs
operator|!=
name|NULL
operator|&&
operator|(
name|args
operator|->
name|force
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/* If we are forcing commits, pretend that the file is            modified.  */
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
else|else
block|{
comment|/* This covers unmodified files, as well as a variety of other 	   cases.  FIXME: we probably should be printing a message and 	   returning 1 for many of those cases (but I'm not sure 	   exactly which ones).  */
return|return
literal|0
return|;
block|}
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|logfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|type
operator|=
name|status
expr_stmt|;
name|data
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|data
operator|->
name|rev_old
operator|=
name|data
operator|->
name|rev_new
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|node
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|args
operator|->
name|ulist
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|++
name|args
operator|->
name|argc
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|copy_ulist
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|copy_ulist
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|find_data
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_data
operator|*
operator|)
name|data
decl_stmt|;
name|args
operator|->
name|argv
index|[
name|args
operator|->
name|argc
operator|++
index|]
operator|=
name|node
operator|->
name|key
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_function
name|int
name|commit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVS_BADROOT
comment|/*      * For log purposes, do not allow "root" to commit files.  If you look      * like root, but are really logged in as a non-root user, it's OK.      */
comment|/* FIXME: Shouldn't this check be much more closely related to the        readonly user stuff (CVSROOT/readers,&c).  That is, why should        root be able to "cvs init", "cvs import",&c, but not "cvs ci"?  */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
name|client_active
endif|#
directive|endif
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|getcaller
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"you are unknown to this system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot commit files as 'root'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CVS_BADROOT */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+nlRm:fF:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|saved_message
condition|)
block|{
name|free
argument_list|(
name|saved_message
argument_list|)
expr_stmt|;
name|saved_message
operator|=
name|NULL
expr_stmt|;
block|}
name|saved_message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|saved_tag
condition|)
name|free
argument_list|(
name|saved_tag
argument_list|)
expr_stmt|;
name|saved_tag
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_ci
operator|=
literal|1
expr_stmt|;
name|local
operator|=
literal|1
expr_stmt|;
comment|/* also disable recursion */
break|break;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* numeric specified revision means we ignore sticky tags... */
if|if
condition|(
name|saved_tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|saved_tag
argument_list|)
condition|)
block|{
name|aflag
operator|=
literal|1
expr_stmt|;
comment|/* strip trailing dots */
while|while
condition|(
name|saved_tag
index|[
name|strlen
argument_list|(
name|saved_tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|saved_tag
index|[
name|strlen
argument_list|(
name|saved_tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* some checks related to the "-F logfile" option */
if|if
condition|(
name|logfile
condition|)
block|{
name|int
name|n
decl_stmt|,
name|logfd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|saved_message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot specify both a message and a log file"
argument_list|)
expr_stmt|;
comment|/* FIXME: Why is this binary?  Needs more investigation.  */
if|if
condition|(
operator|(
name|logfd
operator|=
name|CVS_OPEN
argument_list|(
name|logfile
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|logfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot find size of log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
name|saved_message
operator|=
name|xmalloc
argument_list|(
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: Should keep reading until EOF, rather than assuming the 	   first read gets the whole thing.  */
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|logfd
argument_list|,
name|saved_message
argument_list|,
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read log message from %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
name|saved_message
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|struct
name|find_data
name|find_args
decl_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
name|find_args
operator|.
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|find_args
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
name|find_args
operator|.
name|questionables
operator|=
name|NULL
expr_stmt|;
name|find_args
operator|.
name|ignlist
operator|=
name|NULL
expr_stmt|;
name|find_args
operator|.
name|repository
operator|=
name|NULL
expr_stmt|;
comment|/* It is possible that only a numeric tag should set this. 	   I haven't really thought about it much. 	   Anyway, I suspect that setting it unnecessarily only causes 	   a little unneeded network traffic.  */
name|find_args
operator|.
name|force
operator|=
name|force_ci
operator|||
name|saved_tag
operator|!=
name|NULL
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|find_fileproc
argument_list|,
name|find_filesdoneproc
argument_list|,
name|find_dirent_proc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|find_args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_args
operator|.
name|argc
operator|==
literal|0
condition|)
comment|/* Nothing to commit.  Exit now without contacting the 	       server (note that this means that we won't print "? 	       foo" for files which merit it, because we don't know 	       what is in the CVSROOT/cvsignore file).  */
return|return
literal|0
return|;
comment|/* Now we keep track of which files we actually are going to 	   operate on, and only work with those files in the future. 	   This saves time--we don't want to search the file system 	   of the working directory twice.  */
name|find_args
operator|.
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|find_args
operator|.
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|find_args
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
name|walklist
argument_list|(
name|find_args
operator|.
name|ulist
argument_list|,
name|copy_ulist
argument_list|,
operator|&
name|find_args
argument_list|)
expr_stmt|;
comment|/* Do this before calling do_editor; don't ask for a log 	   message if we can't talk to the server.  But do it after we 	   have made the checks that we can locally (to more quickly 	   catch syntax errors, the case where no files are modified, 	   added or removed, etc.).  	   On the other hand, calling start_server before do_editor 	   means that we chew up server resources the whole time that 	   the user has the editor open (hours or days if the user 	   forgets about it), which seems dubious.  */
name|start_server
argument_list|()
expr_stmt|;
comment|/* 	 * We do this once, not once for each directory as in normal CVS. 	 * The protocol is designed this way.  This is a feature. 	 */
if|if
condition|(
name|use_editor
condition|)
name|do_editor
argument_list|(
literal|"."
argument_list|,
operator|&
name|saved_message
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|find_args
operator|.
name|ulist
argument_list|)
expr_stmt|;
comment|/* Run the user-defined script to verify/check information in 	 *the log message 	 */
name|do_verify
argument_list|(
operator|&
name|saved_message
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* We always send some sort of message, even if empty.  */
comment|/* FIXME: is that true?  There seems to be some code in do_editor 	   which can leave the message NULL.  */
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|saved_message
argument_list|)
expr_stmt|;
comment|/* OK, now process all the questionable files we have been saving 	   up.  */
block|{
name|struct
name|question
modifier|*
name|p
decl_stmt|;
name|struct
name|question
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|find_args
operator|.
name|questionables
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ign_inhibit_server
operator|||
operator|!
name|supported_request
argument_list|(
literal|"Questionable"
argument_list|)
condition|)
block|{
name|cvs_output
argument_list|(
literal|"? "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cvs_output
argument_list|(
name|p
operator|->
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|p
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_to_server
argument_list|(
literal|"Directory "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|p
operator|->
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|p
operator|->
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|p
operator|->
name|repos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Questionable "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|p
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|file
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_ci
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|run_module_prog
condition|)
name|send_arg
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|saved_tag
argument_list|)
expr_stmt|;
comment|/* Sending only the names of the files which were modified, added, 	   or removed means that the server will only do an up-to-date 	   check on those files.  This is different from local CVS and 	   previous versions of client/server CVS, but it probably is a Good 	   Thing, or at least Not Such A Bad Thing.  */
name|send_file_names
argument_list|(
name|find_args
operator|.
name|argc
argument_list|,
name|find_args
operator|.
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This whole find_args.force/SEND_FORCE business is a 	   kludge.  It would seem to be a server bug that we have to 	   say that files are modified when they are not.  This makes 	   "cvs commit -r 2" across a whole bunch of files a very slow 	   operation (and it isn't documented in cvsclient.texi).  I 	   haven't looked at the server code carefully enough to be 	   _sure_ why this is needed, but if it is because the "ci" 	   program, which we used to call, wanted the file to exist, 	   then it would be relatively simple to fix in the server.  */
name|send_files
argument_list|(
name|find_args
operator|.
name|argc
argument_list|,
name|find_args
operator|.
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|find_args
operator|.
name|force
condition|?
name|SEND_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"ci\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|use_editor
operator|&&
name|saved_message
operator|!=
name|NULL
condition|)
block|{
comment|/* If there was an error, don't nuke the user's carefully 	       constructed prose.  This is something of a kludge; a better 	       solution is probably more along the lines of #150 in TODO 	       (doing a second up-to-date check before accepting the 	       log message has also been suggested, but that seems kind of 	       iffy because the real up-to-date check could still fail, 	       another error could occur,&c.  Also, a second check would 	       slow things down).  */
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fname
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fname
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot create temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|saved_message
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|saved_message
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|strlen
argument_list|(
name|saved_message
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close temporary file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"saving log message in %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|saved_tag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|saved_tag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* XXX - this is not the perfect check for this */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|write_dirtag
operator|=
name|saved_tag
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
name|lock_tree_for_write
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|)
expr_stmt|;
comment|/*      * Set up the master update list and hard link list      */
name|mulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|preserve_perms
condition|)
block|{
name|hardlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* 	 * We need to save the working directory so that 	 * check_fileproc can construct a full pathname for each file. 	 */
name|working_dir
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Run the recursion processor to verify the files are all up-to-date      */
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
name|check_direntproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Run the recursion processor to commit the files      */
name|write_dirnonbranch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noexec
operator|==
literal|0
condition|)
name|err
operator|=
name|start_recursion
argument_list|(
name|commit_fileproc
argument_list|,
name|commit_filesdoneproc
argument_list|,
name|commit_direntproc
argument_list|,
name|commit_dirleaveproc
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Unlock all the dirs and clean up      */
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mulist
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_register_time
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|last_register_time
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* to avoid time-stamp races */
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine determines the status of a given file and retrieves    the version information that is associated with that file. */
end_comment

begin_function
specifier|static
name|Ctype
name|classify_file_internal
parameter_list|(
name|finfo
parameter_list|,
name|vers
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
modifier|*
name|vers
decl_stmt|;
block|{
name|int
name|save_noexec
decl_stmt|,
name|save_quiet
decl_stmt|,
name|save_really_quiet
decl_stmt|;
name|Ctype
name|status
decl_stmt|;
comment|/* FIXME: Do we need to save quiet as well as really_quiet?  Last        time I glanced at Classify_File I only saw it looking at really_quiet        not quiet.  */
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|save_quiet
operator|=
name|quiet
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|noexec
operator|=
name|quiet
operator|=
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* handle specified numeric revision specially */
if|if
condition|(
name|saved_tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|saved_tag
argument_list|)
condition|)
block|{
comment|/* If the tag is for the trunk, make sure we're at the head */
if|if
condition|(
name|numdots
argument_list|(
name|saved_tag
argument_list|)
operator|<
literal|2
condition|)
block|{
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_MODIFIED
operator|||
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|Ctype
name|xstatus
decl_stmt|;
name|freevers_ts
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|xstatus
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|saved_tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstatus
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|xstatus
operator|==
name|T_CONFLICT
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
else|else
name|status
operator|=
name|xstatus
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|xtag
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* 	     * The revision is off the main trunk; make sure we're 	     * up-to-date with the head of the specified branch. 	     */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|saved_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|xtag
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|T_REMOVE_ENTRY
operator|||
name|status
operator|==
name|T_CONFLICT
operator|)
operator|&&
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* pluck one more dot off the revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|freevers_ts
argument_list|(
name|vers
argument_list|)
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
block|}
comment|/* now, muck with vers to make the tag correct */
name|free
argument_list|(
operator|(
operator|*
name|vers
operator|)
operator|->
name|tag
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vers
operator|)
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|saved_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
argument_list|,
name|saved_tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|quiet
operator|=
name|save_quiet
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a file is ok to commit and make sure all files are  * up-to-date  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
name|status
operator|=
name|classify_file_internal
argument_list|(
name|finfo
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
comment|/*      * If the force-commit option is enabled, and the file in question      * appears to be up-to-date, just make it look modified so that      * it will be committed.      */
if|if
condition|(
name|force_ci
operator|&&
name|status
operator|==
name|T_UPTODATE
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_CHECKOUT
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
endif|#
directive|endif
case|case
name|T_NEEDS_MERGE
case|:
case|case
name|T_CONFLICT
case|:
case|case
name|T_REMOVE_ENTRY
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Up-to-date check failed for `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MODIFIED
case|:
case|case
name|T_ADDED
case|:
case|case
name|T_REMOVED
case|:
comment|/* 	     * some quick sanity checks; if no numeric -r option specified: 	     *	- can't have a sticky date 	     *	- can't have a sticky tag that is not a branch 	     * Also, 	     *	- if status is T_REMOVED, can't have a numeric tag 	     *	- if status is T_ADDED, rcs file must not exist unless on 	     *    a branch 	     *	- if status is T_ADDED, can't have a non-trunk numeric rev 	     *	- if status is T_MODIFIED and a Conflict marker exists, don't 	     *    allow the commit if timestamp is identical or if we find 	     *    an RCS_MERGE_PAT in the file. 	     */
if|if
condition|(
operator|!
name|saved_tag
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|saved_tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|date
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot commit with sticky date for file `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|vers
operator|->
name|tag
operator|&&
operator|!
name|RCS_isbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sticky tag `%s' for file `%s' is not a branch"
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
operator|!
name|force_ci
operator|&&
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* 		 * We found a "conflict" marker. 		 * 		 * If the timestamp on the file is the same as the 		 * timestamp stored in the Entries file, we block the commit. 		 */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|retcode
operator|=
name|vers
operator|->
name|ts_conflict
index|[
literal|0
index|]
operator|!=
literal|'='
expr_stmt|;
else|else
block|{
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' had a conflict and has not been modified"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|file_has_markers
argument_list|(
name|finfo
argument_list|)
condition|)
block|{
comment|/* Make this a warning, not an error, because we have 		       no way of knowing whether the "conflict indicators" 		       are really from a conflict or whether they are part 		       of the document itself (cvs.texinfo and sanity.sh in 		       CVS itself, for example, tend to want to have strings 		       like ">>>>>>>" at the start of a line).  Making people 		       kludge this the way they need to kludge keyword 		       expansion seems undesirable.  And it is worse than 		       keyword expansion, because there is no -ko 		       analogue.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ warning: file `%s' seems to still contain conflict indicators"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_REMOVED
operator|&&
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
comment|/* Remove also tries to forbid this, but we should check 		   here.  I'm only _sure_ about somewhat obscure cases 		   (hacking the Entries file, using an old version of 		   CVS for the remove and a new one for the commit), but 		   there might be other cases.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove file `%s' which has a numeric sticky tag of `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_ADDED
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|tag
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|rcs
decl_stmt|;
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
name|RCSEXT
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* Don't look in the attic; if it exists there we 		       will move it back out in checkaddfile.  */
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' when RCS file `%s' already exists"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
operator|&&
name|numdots
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' with revision `%s'; must be on trunk"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* done with consistency checks; now, to get on with the commit */
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|finfo
operator|->
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|cilist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ulist
operator|=
name|ulist
expr_stmt|;
name|ml
operator|->
name|cilist
operator|=
name|cilist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|masterlist_delproc
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* first do ulist, then cilist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|li
operator|=
operator|(
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|logfile_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|li
operator|->
name|type
operator|=
name|status
expr_stmt|;
name|li
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|li
operator|->
name|rev_old
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|li
operator|->
name|rev_new
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|li
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|ci_delproc
expr_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_info
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
name|ci
operator|->
name|rev
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ci
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ci
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|options
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ci
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|cilist
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
if|if
condition|(
name|preserve_perms
condition|)
block|{
comment|/* Add this file to hardlist, indexed on its inode.  When 		   we are done, we can find out what files are hardlinked 		   to a given file by looking up its inode in hardlist. */
name|char
modifier|*
name|fullpath
decl_stmt|;
name|Node
modifier|*
name|linkp
decl_stmt|;
name|struct
name|hardlink_info
modifier|*
name|hlinfo
decl_stmt|;
comment|/* Get the full pathname of the current file. */
name|fullpath
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|working_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|working_dir
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* To permit following links in subdirectories, files                    are keyed on finfo->fullname, not on finfo->name. */
name|linkp
operator|=
name|lookup_file_by_inode
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
comment|/* If linkp is NULL, the file doesn't exist... maybe 		   we're doing a remove operation? */
if|if
condition|(
name|linkp
operator|!=
name|NULL
condition|)
block|{
comment|/* Create a new hardlink_info node, which will record 		       the current file's status and the links listed in its 		       `hardlinks' delta field.  We will append this 		       hardlink_info node to the appropriate hardlist entry. */
name|hlinfo
operator|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardlink_info
argument_list|)
argument_list|)
expr_stmt|;
name|hlinfo
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|linkp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|hlinfo
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|T_UNKNOWN
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_UPTODATE
case|:
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS internal error: unknown status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * By default, return the code that tells do_recursion to examine all  * directories  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|check_direntproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walklist proc to run pre-commit checks  */
end_comment

begin_function
specifier|static
name|int
name|precommit_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
name|li
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|type
operator|==
name|T_ADDED
operator|||
name|li
operator|->
name|type
operator|==
name|T_MODIFIED
operator|||
name|li
operator|->
name|type
operator|==
name|T_REMOVED
condition|)
block|{
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback proc for pre-commit checking  */
end_comment

begin_function
specifier|static
name|int
name|precommit_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
comment|/* see if the filter is there, only if it's a full path */
if|if
condition|(
name|isabsolute
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-commit filter `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* so it fails! */
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|saved_ulist
argument_list|,
name|precommit_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the pre-commit checks for the dir  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|saved_ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|saved_ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the checks if there's nothing to do */
if|if
condition|(
name|saved_ulist
operator|==
name|NULL
operator|||
name|saved_ulist
operator|->
name|list
operator|->
name|next
operator|==
name|saved_ulist
operator|->
name|list
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* run any pre-commit checks */
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_COMMITINFO
argument_list|,
name|repos
argument_list|,
name|precommit_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-commit check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the work of committing a file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sbranch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
comment|/* Keep track of whether write_dirtag is a branch tag.        Note that if it is a branch tag in some files and a nonbranch tag        in others, treat it as a nonbranch tag.  It is possible that case        should elicit a warning or an error.  */
if|if
condition|(
name|write_dirtag
operator|!=
name|NULL
operator|&&
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|rev
init|=
name|RCS_getversion
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|write_dirtag
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
operator|&&
operator|!
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|write_dirtag
argument_list|)
condition|)
name|write_dirnonbranch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
comment|/*      * if p is null, there were file type command line args which were      * all up-to-date so nothing really needs to be done      */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
comment|/*      * At this point, we should have the commit message unless we were called      * with files as args from the command line.  In that latter case, we      * need to get the commit message ourselves      */
if|if
condition|(
operator|!
operator|(
name|got_message
operator|)
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|use_editor
condition|)
name|do_editor
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
operator|&
name|saved_message
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|do_verify
argument_list|(
operator|&
name|saved_message
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|cilist
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no parsed RCS file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_RCS
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
if|if
condition|(
name|checkaddfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
operator|&
name|finfo
operator|->
name|rcs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fixaddfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* adding files with a tag, now means adding them on a branch. 	   Since the branch test was done in check_fileproc for 	   modified files, we need to stub it in again here. */
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no parsed RCS file"
argument_list|)
expr_stmt|;
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|ci
operator|->
name|tag
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|finfo
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|saved_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|T_UPTODATE
expr_stmt|;
block|}
block|}
comment|/*      * Add the file for real      */
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
modifier|*
name|xrev
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
operator|==
name|NULL
condition|)
block|{
comment|/* find the max major rev number in this directory */
name|maxrev
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|findmaxrev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrev
operator|==
literal|0
condition|)
name|maxrev
operator|=
literal|1
expr_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%d"
argument_list|,
name|maxrev
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - an added file with symbolic -r should add tag as well */
name|err
operator|=
name|finaladd
argument_list|(
name|finfo
argument_list|,
name|ci
operator|->
name|rev
condition|?
name|ci
operator|->
name|rev
else|:
name|xrev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
condition|)
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
name|err
operator|=
name|Checkin
argument_list|(
literal|'M'
argument_list|,
name|finfo
argument_list|,
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|saved_message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_REMOVED
condition|)
block|{
name|err
operator|=
name|remove_file
argument_list|(
name|finfo
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|saved_message
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
comment|/* Doesn't matter, it won't get checked.  */
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Clearly this is right for T_MODIFIED.  I haven't thought so much        about T_ADDED or T_REMOVED.  */
name|notify_do
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* on failure, remove the file from ulist */
name|p
operator|=
name|findnode
argument_list|(
name|ulist
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* On success, retrieve the new version number of the file and            copy it into the log information (see logmsg.c            (logfile_write) for more details).  We should only update            the version number for files that have been added or            modified but not removed.  Why?  classify_file_internal            will return the version number of a file even after it has            been removed from the archive, which is not the behavior we            want for our commitlog messages; we want the old version            number and then "NONE." */
if|if
condition|(
name|ci
operator|->
name|status
operator|!=
name|T_REMOVED
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|ulist
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
operator|(
name|void
operator|)
name|classify_file_internal
argument_list|(
name|finfo
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
name|li
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|li
operator|->
name|rev_new
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log the commit and clean up the update list  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|got_message
operator|=
literal|0
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|saved_message
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
comment|/* Build the administrative files if necessary.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot_directory
argument_list|,
name|repository
argument_list|,
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: repository (%s) doesn't begin with root (%s)"
argument_list|,
name|repository
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|p
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"CVSROOT"
argument_list|,
name|p
argument_list|)
operator|==
literal|0
comment|/* Check for subdirectories because people may want to create 	       subdirectories and list files therein in checkoutlist.  */
operator|||
name|strncmp
argument_list|(
literal|"CVSROOT/"
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
literal|"CVSROOT/"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* "Database" might a little bit grandiose and/or vague, 	       but "checked-out copies of administrative files, unless 	       in the case of modules and you are using ndbm in which 	       case modules.{pag,dir,db}" is verbose and excessively 	       focused on how the database is implemented.  */
comment|/* mkmodules requires the absolute name of the CVSROOT directory. 	       Remove anything after the `CVSROOT' component -- this is 	       necessary when committing in a subdirectory of CVSROOT.  */
name|char
modifier|*
name|admin_dir
init|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
decl_stmt|;
name|int
name|cvsrootlen
init|=
name|strlen
argument_list|(
literal|"CVSROOT"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|admin_dir
index|[
name|p
operator|-
name|repository
operator|+
name|cvsrootlen
index|]
operator|==
literal|'\0'
operator|||
name|admin_dir
index|[
name|p
operator|-
name|repository
operator|+
name|cvsrootlen
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|admin_dir
index|[
name|p
operator|-
name|repository
operator|+
name|cvsrootlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Rebuilding administrative file database\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mkmodules
argument_list|(
name|admin_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|admin_dir
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|run_module_prog
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|>
literal|0
condition|)
block|{
comment|/* Remove any trailing newline.  */
if|if
condition|(
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|repos
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Executing '"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: error reading %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot open %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the log message for a dir  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|char
modifier|*
name|real_repos
decl_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the files as an optimization */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|R_SKIP_FILES
operator|)
return|;
comment|/* get commit message */
name|real_repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|got_message
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|use_editor
condition|)
name|do_editor
argument_list|(
name|update_dir
argument_list|,
operator|&
name|saved_message
argument_list|,
name|real_repos
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|do_verify
argument_list|(
operator|&
name|saved_message
argument_list|,
name|real_repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_repos
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the post-commit proc if necessary  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
comment|/* update the per-directory tag info */
comment|/* FIXME?  Why?  The "commit examples" node of cvs.texinfo briefly        mentions commit -r being sticky, but apparently in the context of        this being a confusing feature!  */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|write_dirtag
operator|!=
name|NULL
condition|)
block|{
name|WriteTag
argument_list|(
name|NULL
argument_list|,
name|write_dirtag
argument_list|,
name|NULL
argument_list|,
name|write_dirnonbranch
argument_list|,
name|update_dir
argument_list|,
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find the maximum major rev number in an entries file  */
end_comment

begin_function
specifier|static
name|int
name|findmaxrev
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|thisrev
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|entdata
operator|->
name|type
operator|!=
name|ENT_FILE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|entdata
operator|->
name|version
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|thisrev
operator|=
name|atoi
argument_list|(
name|entdata
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|thisrev
operator|>
name|maxrev
condition|)
name|maxrev
operator|=
name|thisrev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually remove a file by moving it to the attic  * XXX - if removing a ,v file that is a relative symbolic link to  * another ,v file, we probably should add a ".." component to the  * link to keep it relative after we move it into the attic.  */
end_comment

begin_function
specifier|static
name|int
name|remove_file
parameter_list|(
name|finfo
parameter_list|,
name|tag
parameter_list|,
name|message
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|mode_t
name|omask
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|branch
decl_stmt|;
name|int
name|lockflag
decl_stmt|;
name|char
modifier|*
name|corev
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|prev_rev
decl_stmt|;
name|char
modifier|*
name|old_path
decl_stmt|;
name|corev
operator|=
name|NULL
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|prev_rev
operator|=
name|NULL
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|rcs
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: no parsed RCS file"
argument_list|)
expr_stmt|;
name|branch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
operator|!
operator|(
name|branch
operator|=
name|RCS_nodeisbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|)
operator|)
condition|)
block|{
comment|/* a symbolic tag is specified; just remove the tag from the file */
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag `%s' from `%s'"
argument_list|,
name|tag
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* we are removing the file from either the head or a branch */
comment|/* commit a new, dead revision. */
comment|/* Print message indicating that file is going to be removed. */
name|cvs_output
argument_list|(
literal|"Removing "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|lockflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|branch
condition|)
block|{
name|char
modifier|*
name|branchname
decl_stmt|;
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find branch \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|branchname
operator|=
name|RCS_getbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchname
operator|==
name|NULL
condition|)
block|{
comment|/* no revision exists on this branch.  use the previous 	       revision but do not lock. */
name|corev
operator|=
name|RCS_gettag
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|lockflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|corev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Not a branch */
block|{
comment|/* Get current head revision of file. */
name|prev_rev
operator|=
name|RCS_head
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
block|}
comment|/* if removing without a tag or a branch, then make sure the default        branch is the trunk. */
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
name|branch
condition|)
block|{
if|if
condition|(
name|RCS_setbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|RCS_rewrite
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* If this is the server, there will be a file sitting in the 	   temp directory which is the kludgy way in which server.c 	   tells time_stamp that the file is no longer around.  Remove 	   it so we can create temp files with that name (ignore errors).  */
name|unlink_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* check something out.  Generally this is the head.  If we have a        particular rev, then name it.  */
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev
condition|?
name|corev
else|:
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"failed to check out `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Except when we are creating a branch, lock the revision so that        we can check in the new revision.  */
if|if
condition|(
name|lockflag
condition|)
block|{
if|if
condition|(
name|RCS_lock
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|rev
condition|?
name|corev
else|:
name|NULL
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|RCS_rewrite
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|corev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|corev
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkin
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|message
argument_list|,
name|rev
argument_list|,
name|RCS_FLAGS_DEAD
operator||
name|RCS_FLAGS_QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to commit dead revision for `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|old_path
operator|=
name|finfo
operator|->
name|rcs
operator|->
name|path
expr_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
block|{
comment|/* this was the head; really move it into the Attic */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|'/'
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|'/'
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CVS_MKDIR
argument_list|(
name|tmp
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|,
name|tmp
argument_list|)
operator|!=
literal|0
operator|&&
name|CVS_RENAME
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|,
name|tmp
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|isreadable
argument_list|(
name|finfo
operator|->
name|rcs
operator|->
name|path
argument_list|)
operator|||
operator|!
name|isreadable
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* The old value of finfo->rcs->path is in old_path, and is            freed below.  */
name|finfo
operator|->
name|rcs
operator|->
name|path
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Print message that file was removed. */
name|cvs_output
argument_list|(
name|old_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"<--  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\nnew revision: delete; previous revision: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|prev_rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\ndone\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_path
operator|!=
name|finfo
operator|->
name|rcs
operator|->
name|path
condition|)
name|free
argument_list|(
name|old_path
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the actual checkin for added files  */
end_comment

begin_function
specifier|static
name|int
name|finaladd
parameter_list|(
name|finfo
parameter_list|,
name|rev
parameter_list|,
name|tag
parameter_list|,
name|options
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|rcs
operator|=
name|locate_rcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|finfo
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|tag
argument_list|,
name|options
argument_list|,
name|saved_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSEXT_LOG
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|fixaddfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|unlockrcs
parameter_list|(
name|rcs
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|{
name|int
name|retcode
decl_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_unlock
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not unlock %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a partially added file.  if we can parse it, leave it alone.  */
end_comment

begin_function
specifier|static
name|void
name|fixaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|int
name|save_really_quiet
decl_stmt|;
name|rcs
operator|=
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|really_quiet
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
else|else
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put the branch back on an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|fixbranch
parameter_list|(
name|rcs
parameter_list|,
name|branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|int
name|retcode
decl_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"cannot restore branch to %s for %s"
argument_list|,
name|branch
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * do the initial part of a file add for the named file.  if adding  * with a tag, put the file in the Attic and point the symbolic tag  * at the committed revision.  */
end_comment

begin_function
specifier|static
name|int
name|checkaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|options
parameter_list|,
name|rcsnode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|RCSNode
modifier|*
modifier|*
name|rcsnode
decl_stmt|;
block|{
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|mode_t
name|omask
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|newfile
init|=
literal|0
decl_stmt|;
name|RCSNode
modifier|*
name|rcsfile
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|rcs
argument_list|,
literal|0777
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
empty_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|rcs
operator|=
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
comment|/* file has existed in the past.  Prepare to resurrect. */
name|char
modifier|*
name|rev
decl_stmt|;
if|if
condition|(
operator|(
name|rcsfile
operator|=
operator|*
name|rcsnode
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not find parsed rcsfile %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|oldfile
decl_stmt|;
comment|/* we are adding on the trunk, so move the file out of the 	       Attic. */
name|oldfile
operator|=
name|xstrdup
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|oldfile
argument_list|,
name|rcs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: confused about attic for %s"
argument_list|,
name|oldfile
argument_list|)
expr_stmt|;
name|out1
label|:
name|free
argument_list|(
name|oldfile
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|CVS_RENAME
argument_list|(
name|oldfile
argument_list|,
name|rcs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to move `%s' out of the attic"
argument_list|,
name|oldfile
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
name|isreadable
argument_list|(
name|oldfile
argument_list|)
operator|||
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ internal error: `%s' didn't move out of the attic"
argument_list|,
name|oldfile
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|free
argument_list|(
name|oldfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcsfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|rcsfile
operator|->
name|path
operator|=
name|xstrdup
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
block|}
name|rev
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* and lock it */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcsfile
argument_list|,
name|rev
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is the first time we have ever seen this file; create 	   an rcs file.  */
name|char
modifier|*
name|desc
decl_stmt|;
name|size_t
name|descalloc
decl_stmt|;
name|size_t
name|desclen
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|desc
operator|=
name|NULL
expr_stmt|;
name|descalloc
operator|=
literal|0
expr_stmt|;
name|desclen
operator|=
literal|0
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSEXT_LOG
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
comment|/* If the file does not exist, no big deal.  In particular, the 	   server does not (yet at least) create CVSEXT_LOG files.  */
if|if
condition|(
name|isfile
argument_list|(
name|fname
argument_list|)
condition|)
comment|/* FIXME: Should be including update_dir in the appropriate 	       place here.  */
name|get_file
argument_list|(
name|fname
argument_list|,
name|fname
argument_list|,
literal|"r"
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|descalloc
argument_list|,
operator|&
name|desclen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the 	   end of the log message if the message is nonempty. 	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg, 	   which we don't try to do here.  */
if|if
condition|(
name|desclen
operator|>
literal|0
condition|)
block|{
name|expand_string
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|descalloc
argument_list|,
name|desclen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|desc
index|[
name|desclen
operator|++
index|]
operator|=
literal|'\012'
expr_stmt|;
block|}
comment|/* Set RCS keyword expansion options.  */
if|if
condition|(
name|options
operator|&&
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
condition|)
name|opt
operator|=
name|options
operator|+
literal|2
expr_stmt|;
else|else
name|opt
operator|=
name|NULL
expr_stmt|;
comment|/* This message is an artifact of the time when this 	   was implemented via "rcs -i".  It should be revised at 	   some point (does the "initial revision" in the message from 	   RCS_checkin indicate that this is a new file?  Or does the 	   "RCS file" message serve some function?).  */
name|cvs_output
argument_list|(
literal|"RCS file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\ndone\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_rcs_file
argument_list|(
name|NULL
argument_list|,
name|rcs
argument_list|,
name|file
argument_list|,
name|NULL
argument_list|,
name|opt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|desc
argument_list|,
name|desclen
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|newfile
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
comment|/* when adding a file for the first time, and using a tag, we need        to create a dead revision on the trunk.  */
if|if
condition|(
name|tag
operator|&&
name|newfile
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* move the new file out of the way. */
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSPREFIX
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* Create empty FILE.  Can't use copy_file with a DEVNULL 	   argument -- copy_file now ignores device files. */
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for writing"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
comment|/* commit a dead revision. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"file %s was initially added on branch %s."
argument_list|,
name|file
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkin
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|RCS_FLAGS_DEAD
operator||
name|RCS_FLAGS_QUIET
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not create initial dead revision %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* put the new file back where it was */
name|rename_file
argument_list|(
name|fname
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* double-check that the file was written correctly */
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
name|rcsfile
operator|=
name|RCS_parse
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not read %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|rcsnode
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
operator|*
name|rcsnode
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rcsnode
operator|=
name|rcsfile
expr_stmt|;
block|}
comment|/* and lock it once again. */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
comment|/* when adding with a tag, we need to stub a branch, if it 	   doesn't already exist.  */
if|if
condition|(
name|rcsfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rcsnode
operator|!=
name|NULL
operator|&&
operator|*
name|rcsnode
operator|!=
name|NULL
condition|)
name|rcsfile
operator|=
operator|*
name|rcsnode
expr_stmt|;
else|else
block|{
name|rcsfile
operator|=
name|RCS_parse
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not read %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|RCS_nodeisbranch
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* branch does not exist.  Stub it.  */
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|magicrev
decl_stmt|;
name|fixbranch
argument_list|(
name|rcsfile
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
name|head
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|magicrev
operator|=
name|RCS_magicrev
argument_list|(
name|rcsfile
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|,
name|magicrev
argument_list|)
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magicrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not stub branch %s for %s"
argument_list|,
name|tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* lock the branch. (stubbed branches need not be locked.)  */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|rcsnode
operator|&&
operator|*
name|rcsnode
operator|!=
name|rcsfile
condition|)
block|{
name|freercsnode
argument_list|(
name|rcsnode
argument_list|)
expr_stmt|;
operator|*
name|rcsnode
operator|=
name|rcsfile
expr_stmt|;
block|}
block|}
name|fileattr_newfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* I don't think fix_rcs_modes is needed any more.  In the        add_rcs_file case, the algorithms used by add_rcs_file and        fix_rcs_modes are the same, so there is no need to go through        it all twice.  In the other cases, I think we want to just        preserve the mode that the file had before we started.  That is        a behavior change, but I would think a desirable one.  */
name|fix_rcs_modes
argument_list|(
name|rcs
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it  * couldn't.  If the RCS file currently has a branch as the head, we must  * move the head back to the trunk before locking the file, and be sure to  * put the branch back as the head if there are any errors.  */
end_comment

begin_function
specifier|static
name|int
name|lock_RCS
parameter_list|(
name|user
parameter_list|,
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/*      * For a specified, numeric revision of the form "1" or "1.1", (or when      * no revision is specified ""), definitely move the branch to the trunk      * before locking the RCS file.      *      * The assumption is that if there is more than one revision on the trunk,      * the head points to the trunk, not a branch... and as such, it's not      * necessary to move the head in this case.      */
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|(
name|rev
operator|&&
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
operator|&&
name|numdots
argument_list|(
name|rev
argument_list|)
operator|<
literal|2
operator|)
condition|)
block|{
name|branch
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|err
operator|=
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We used to call RCS_rewrite here, and that might seem        appropriate in order to write out the locked revision        information.  However, such a call would actually serve no        purpose.  CVS locks will prevent any interference from other        CVS processes.  The comment above rcs_internal_lockfile        explains that it is already unsafe to use RCS and CVS        simultaneously.  It follows that writing out the locked        revision information here would add no additional security.         If we ever do care about it, the proper fix is to create the        RCS lock file before calling this function, and maintain it        until the checkin is complete.         The call to RCS_lock is still required at present, since in        some cases RCS_checkin will determine which revision to check        in by looking for a lock.  FIXME: This is rather roundabout,        and a more straightforward approach would probably be easier to        understand.  */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sbranch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sbranch
argument_list|)
expr_stmt|;
name|sbranch
operator|=
name|branch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* try to restore the branch if we can on error */
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
name|fixbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called when "add"ing files to the RCS respository.  It doesn't seem to    be possible to get RCS to use the right mode, so we change it after    the fact.  TODO: now that RCS has been librarified, we have the power    to change this. */
end_comment

begin_function
specifier|static
name|void
name|fix_rcs_modes
parameter_list|(
name|rcs
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|rcs_mode
decl_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_PERMISSIONS_SUPPORT
comment|/* Do ye nothing to the modes on a symbolic link. */
if|if
condition|(
name|preserve_perms
operator|&&
name|islink
argument_list|(
name|user
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|CVS_STAT
argument_list|(
name|user
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: Should be ->fullname.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot stat %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now we compute the new mode.         TODO: decide whether this whole thing can/should be skipped        when `preserve_perms' is set.  Almost certainly so. -twp         The algorithm that we use is:         Write permission is always off (this is what RCS and CVS have always        done).         If S_IRUSR is on (user read), then the read permission of        the RCS file will be on.  It would seem that if this is off,        then other users can't do "cvs update" and such, so perhaps this        should be hardcoded to being on (it is a strange case, though--the        case in which a user file doesn't have user read permission on).         If S_IXUSR is on (user execute), then set execute permission        on the RCS file.  This allows other users who check out the file        to get the right setting for whether a shell script (for example)        has the executable bit set.         The result of that calculation is modified by CVSUMASK.  The        reason, of course, that the read and execute settings take the        user bit and copy it to all three bits (user, group, other), is        that it should be CVSUMASK, not the umask of individual users,        which is the sole determiner of modes in the repository.  */
name|rcs_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRUSR
condition|)
name|rcs_mode
operator||=
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IXUSR
condition|)
name|rcs_mode
operator||=
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
expr_stmt|;
name|rcs_mode
operator|&=
operator|~
name|cvsumask
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|rcs
argument_list|,
name|rcs_mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot change mode of %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free an UPDATE node's data  */
end_comment

begin_function
name|void
name|update_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
name|li
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|tag
condition|)
name|free
argument_list|(
name|li
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|rev_old
condition|)
name|free
argument_list|(
name|li
operator|->
name|rev_old
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|rev_new
condition|)
name|free
argument_list|(
name|li
operator|->
name|rev_new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|li
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the commit_info structure in p.  */
end_comment

begin_function
specifier|static
name|void
name|ci_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
condition|)
name|free
argument_list|(
name|ci
operator|->
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
name|free
argument_list|(
name|ci
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|options
condition|)
name|free
argument_list|(
name|ci
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the commit_info structure in p.  */
end_comment

begin_function
specifier|static
name|void
name|masterlist_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|cilist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ml
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find an RCS file in the repository.  Most parts of CVS will want to    rely instead on RCS_parse which performs a similar operation and is    called by recurse.c which then puts the result in useful places    like the rcs field of struct file_info.     REPOSITORY is the repository (including the directory) and FILE is    the filename within that directory (without RCSEXT).  Returns a    newly-malloc'd array containing the absolute pathname of the RCS    file that was found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|locate_rcs
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|rcs
decl_stmt|;
name|rcs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
return|return
name|rcs
return|;
block|}
end_function

end_unit

