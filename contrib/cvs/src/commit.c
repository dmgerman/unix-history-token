begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * Commit Files  *   * "commit" commits the present version to the RCS repository, AFTER  * having done a test on conflicts.  *  * The call is: cvs commit [options] files...  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_decl_stmt
specifier|static
name|Dtype
name|check_direntproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_fileproc
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|,
name|RCSNode
operator|*
operator|*
name|rcsnode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|commit_direntproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_dirleaveproc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_fileproc
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|commit_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finaladd
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|revision
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|options
operator|,
name|char
operator|*
name|update_dir
operator|,
name|char
operator|*
name|repository
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findmaxrev
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_RCS
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|rev
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lockrcsfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|rev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_list_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|precommit_proc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|filter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remove_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|tag
operator|,
name|char
operator|*
name|message
operator|,
name|List
operator|*
name|entries
operator|,
name|RCSNode
operator|*
name|rcsnode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_rcs_modes
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixaddfile
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixbranch
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|branch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unlockrcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ci_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|masterlist_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|locate_rcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|rcs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|commit_info
block|{
name|Ctype
name|status
decl_stmt|;
comment|/* as returned from Classify_File() */
name|char
modifier|*
name|rev
decl_stmt|;
comment|/* a numeric rev, if we know it */
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* any sticky tag, or -r option */
name|char
modifier|*
name|options
decl_stmt|;
comment|/* Any sticky -k option */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|master_lists
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
comment|/* list for Update_Logfile */
name|List
modifier|*
name|cilist
decl_stmt|;
comment|/* list with commit_info structs */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|force_ci
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_module_prog
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|write_dirtag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|mulist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|last_register_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|commit_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n"
block|,
literal|"\t-n\tDo not run the module program (if any).\n"
block|,
literal|"\t-R\tProcess directories recursively.\n"
block|,
literal|"\t-l\tLocal directory only (not recursive).\n"
block|,
literal|"\t-f\tForce the file to be committed; disables recursion.\n"
block|,
literal|"\t-F file\tRead the log message from file.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
literal|"\t-r rev\tCommit to this branch or trunk revision.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_struct
struct|struct
name|find_data
block|{
name|List
modifier|*
name|ulist
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pass as a static until we get around to fixing start_recursion to    pass along a void * where we can stash it.  */
end_comment

begin_decl_stmt
name|struct
name|find_data
modifier|*
name|find_data_static
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_fileproc
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machinery to find out what is modified, added, and removed.  It is    possible this should be broken out into a new client_classify function;    merging it with classify_file is almost sure to be a mess, though,    because classify_file has all kinds of repository processing.  */
end_comment

begin_function
specifier|static
name|int
name|find_fileproc
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|enum
name|classify_type
name|status
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|struct
name|find_data
modifier|*
name|args
init|=
name|find_data_static
decl_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
operator|(
name|RCSNode
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|status
operator|=
name|T_REMOVED
expr_stmt|;
elseif|else
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"use `cvs add' to create an entry for %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|status
operator|=
name|T_ADDED
expr_stmt|;
elseif|else
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
operator|&&
name|vers
operator|->
name|ts_rcs
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|ts_rcs
argument_list|)
operator|!=
literal|0
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
else|else
block|{
comment|/* This covers unmodified files, as well as a variety of other 	   cases.  FIXME: we probably should be printing a message and 	   returning 1 for many of those cases (but I'm not sure 	   exactly which ones).  */
return|return
literal|0
return|;
block|}
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|node
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|status
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|args
operator|->
name|ulist
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|++
name|args
operator|->
name|argc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|copy_ulist
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|copy_ulist
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|find_data
modifier|*
name|args
init|=
operator|(
expr|struct
name|find_data
operator|*
operator|)
name|data
decl_stmt|;
name|args
operator|->
name|argv
index|[
name|args
operator|->
name|argc
operator|++
index|]
operator|=
name|node
operator|->
name|key
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CLIENT_SUPPORT */
end_comment

begin_function
name|int
name|commit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVS_BADROOT
comment|/*      * For log purposes, do not allow "root" to commit files.  If you look      * like root, but are really logged in as a non-root user, it's OK.      */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|getcaller
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"you are unknown to this system"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot commit files as 'root'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CVS_BADROOT */
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nlRm:fF:r:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|run_module_prog
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|message
condition|)
block|{
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
block|}
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|tag
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|local
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force_ci
operator|=
literal|1
expr_stmt|;
name|local
operator|=
literal|1
expr_stmt|;
comment|/* also disable recursion */
break|break;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|commit_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* numeric specified revision means we ignore sticky tags... */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
name|aflag
operator|=
literal|1
expr_stmt|;
comment|/* strip trailing dots */
while|while
condition|(
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tag
index|[
name|strlen
argument_list|(
name|tag
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* some checks related to the "-F logfile" option */
if|if
condition|(
name|logfile
condition|)
block|{
name|int
name|n
decl_stmt|,
name|logfd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot specify both a message and a log file"
argument_list|)
expr_stmt|;
comment|/* FIXME: Why is this binary?  Needs more investigation.  */
if|if
condition|(
operator|(
name|logfd
operator|=
name|open
argument_list|(
name|logfile
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|logfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot find size of log file %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
name|message
operator|=
name|xmalloc
argument_list|(
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: Should keep reading until EOF, rather than assuming the 	   first read gets the whole thing.  */
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|logfd
argument_list|,
name|message
argument_list|,
name|statbuf
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read log message from %s"
argument_list|,
name|logfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
name|message
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
name|struct
name|find_data
name|find_args
decl_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* Note that we don't do ignore file processing here, and we 	   don't call ignore_files.  This means that we won't print "? 	   foo" for stray files.  Sounds OK, the doc only promises 	   that update does that.  */
name|find_args
operator|.
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|find_args
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
name|find_data_static
operator|=
operator|&
name|find_args
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|find_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_args
operator|.
name|argc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Now we keep track of which files we actually are going to 	   operate on, and only work with those files in the future. 	   This saves time--we don't want to search the file system 	   of the working directory twice.  */
name|find_args
operator|.
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|find_args
operator|.
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|find_args
operator|.
name|argc
operator|=
literal|0
expr_stmt|;
name|walklist
argument_list|(
name|find_args
operator|.
name|ulist
argument_list|,
name|copy_ulist
argument_list|,
operator|&
name|find_args
argument_list|)
expr_stmt|;
comment|/* 	 * Do this before calling do_editor; don't ask for a log 	 * message if we can't talk to the server.  But do it after we 	 * have made the checks that we can locally (to more quickly 	 * catch syntax errors, the case where no files are modified, 	 * added or removed, etc.).  */
name|start_server
argument_list|()
expr_stmt|;
comment|/* 	 * We do this once, not once for each directory as in normal CVS. 	 * The protocol is designed this way.  This is a feature. 	 */
if|if
condition|(
name|use_editor
condition|)
name|do_editor
argument_list|(
literal|"."
argument_list|,
operator|&
name|message
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|find_args
operator|.
name|ulist
argument_list|)
expr_stmt|;
comment|/* We always send some sort of message, even if empty.  */
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_ci
condition|)
name|send_arg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|run_module_prog
condition|)
name|send_arg
argument_list|(
literal|"-n"
argument_list|)
expr_stmt|;
name|option_with_arg
argument_list|(
literal|"-r"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* Sending only the names of the files which were modified, added, 	   or removed means that the server will only do an up-to-date 	   check on those files.  This is different from local CVS and 	   previous versions of client/server CVS, but it probably is a Good 	   Thing, or at least Not Such A Bad Thing.  */
name|send_file_names
argument_list|(
name|find_args
operator|.
name|argc
argument_list|,
name|find_args
operator|.
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|find_args
operator|.
name|argc
argument_list|,
name|find_args
operator|.
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"ci\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
name|tag_check_valid
argument_list|(
name|tag
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* XXX - this is not the perfect check for this */
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|write_dirtag
operator|=
name|tag
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
name|lock_tree_for_write
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|aflag
argument_list|)
expr_stmt|;
comment|/*      * Set up the master update list      */
name|mulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/*      * Run the recursion processor to verify the files are all up-to-date      */
name|err
operator|=
name|start_recursion
argument_list|(
name|check_fileproc
argument_list|,
name|check_filesdoneproc
argument_list|,
name|check_direntproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|lock_tree_cleanup
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"correct above errors first!"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Run the recursion processor to commit the files      */
if|if
condition|(
name|noexec
operator|==
literal|0
condition|)
name|err
operator|=
name|start_recursion
argument_list|(
name|commit_fileproc
argument_list|,
name|commit_filesdoneproc
argument_list|,
name|commit_direntproc
argument_list|,
name|commit_dirleaveproc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Unlock all the dirs and clean up      */
name|lock_tree_cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|mulist
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_register_time
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
name|last_register_time
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* to avoid time-stamp races */
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a file is ok to commit and make sure all files are  * up-to-date  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_fileproc
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Ctype
name|status
decl_stmt|;
name|char
modifier|*
name|xdir
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|int
name|save_noexec
decl_stmt|,
name|save_quiet
decl_stmt|,
name|save_really_quiet
decl_stmt|;
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|save_quiet
operator|=
name|quiet
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|noexec
operator|=
name|quiet
operator|=
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* handle specified numeric revision specially */
if|if
condition|(
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
comment|/* If the tag is for the trunk, make sure we're at the head */
if|if
condition|(
name|numdots
argument_list|(
name|tag
argument_list|)
operator|<
literal|2
condition|)
block|{
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|vers
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_MODIFIED
operator|||
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|Ctype
name|xstatus
decl_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|xstatus
operator|=
name|Classify_File
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|vers
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstatus
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|xstatus
operator|==
name|T_CONFLICT
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
else|else
name|status
operator|=
name|xstatus
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|xtag
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* 	     * The revision is off the main trunk; make sure we're 	     * up-to-date with the head of the specified branch. 	     */
name|xtag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|xtag
argument_list|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|vers
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|T_REMOVE_ENTRY
operator|||
name|status
operator|==
name|T_CONFLICT
operator|)
operator|&&
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|xtag
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* pluck one more dot off the revision */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|aflag
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|vers
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|T_UPTODATE
operator|||
name|status
operator|==
name|T_REMOVE_ENTRY
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
block|}
comment|/* now, muck with vers to make the tag correct */
name|free
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|vers
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
name|Classify_File
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|,
operator|&
name|vers
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
name|quiet
operator|=
name|save_quiet
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
comment|/*      * If the force-commit option is enabled, and the file in question      * appears to be up-to-date, just make it look modified so that      * it will be committed.      */
if|if
condition|(
name|force_ci
operator|&&
name|status
operator|==
name|T_UPTODATE
condition|)
name|status
operator|=
name|T_MODIFIED
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|T_CHECKOUT
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
case|case
name|T_PATCH
case|:
endif|#
directive|endif
case|case
name|T_NEEDS_MERGE
case|:
case|case
name|T_CONFLICT
case|:
case|case
name|T_REMOVE_ENTRY
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Up-to-date check failed for `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MODIFIED
case|:
case|case
name|T_ADDED
case|:
case|case
name|T_REMOVED
case|:
comment|/* 	     * some quick sanity checks; if no numeric -r option specified: 	     *	- can't have a sticky date 	     *	- can't have a sticky tag that is not a branch 	     * Also, 	     *	- if status is T_REMOVED, can't have a numeric tag 	     *	- if status is T_ADDED, rcs file must not exist 	     *	- if status is T_ADDED, can't have a non-trunk numeric rev 	     *	- if status is T_MODIFIED and a Conflict marker exists, don't 	     *    allow the commit if timestamp is identical or if we find 	     *    an RCS_MERGE_PAT in the file. 	     */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|tag
argument_list|)
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|date
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot commit with sticky date for file `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
name|vers
operator|->
name|tag
operator|&&
operator|!
name|RCS_isbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"sticky tag `%s' for file `%s' is not a branch"
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_MODIFIED
operator|&&
operator|!
name|force_ci
operator|&&
name|vers
operator|->
name|ts_conflict
condition|)
block|{
name|char
modifier|*
name|filestamp
decl_stmt|;
name|int
name|retcode
decl_stmt|;
comment|/* 		 * We found a "conflict" marker. 		 * 		 * If the timestamp on the file is the same as the 		 * timestamp stored in the Entries file, we block the commit. 		 */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|retcode
operator|=
name|vers
operator|->
name|ts_conflict
index|[
literal|0
index|]
operator|!=
literal|'='
expr_stmt|;
else|else
block|{
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|filestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|strcmp
argument_list|(
name|vers
operator|->
name|ts_conflict
argument_list|,
name|filestamp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filestamp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' had a conflict and has not been modified"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * If the timestamps differ, look for Conflict indicators 		 * in the file to see if we should block the commit anyway 		 */
name|run_setup
argument_list|(
literal|"%s"
argument_list|,
name|GREP
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|RCS_MERGE_PAT
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_REALLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fork failed while examining conflict in `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retcode
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' still contains conflict indicators"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|T_REMOVED
operator|&&
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot remove file `%s' which has a numeric sticky tag of `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* Don't look in the attic; if it exists there we will 		   move it back out in checkaddfile.  */
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' when RCS file `%s' already exists"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|tag
operator|&&
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
operator|&&
name|numdots
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' with revision `%s'; must be on trunk"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* done with consistency checks; now, to get on with the commit */
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xdir
operator|=
literal|"."
expr_stmt|;
else|else
name|xdir
operator|=
name|finfo
operator|->
name|update_dir
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|xdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
block|}
else|else
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|cilist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|xdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|master_lists
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ulist
operator|=
name|ulist
expr_stmt|;
name|ml
operator|->
name|cilist
operator|=
name|cilist
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ml
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|masterlist_delproc
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|mulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* first do ulist, then cilist */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|status
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|ci_delproc
expr_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|commit_info
argument_list|)
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|vers
operator|->
name|tag
argument_list|)
condition|)
name|ci
operator|->
name|rev
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|ci
operator|->
name|rev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ci
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ci
operator|->
name|options
operator|=
name|xstrdup
argument_list|(
name|vers
operator|->
name|options
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|ci
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|cilist
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UNKNOWN
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_UPTODATE
case|:
break|break;
default|default:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS internal error: unknown status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print warm fuzzies while examining the dirs  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|check_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Examining %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walklist proc to run pre-commit checks  */
end_comment

begin_function
specifier|static
name|int
name|precommit_list_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_ADDED
operator|||
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_MODIFIED
operator|||
name|p
operator|->
name|data
operator|==
operator|(
name|char
operator|*
operator|)
name|T_REMOVED
condition|)
block|{
name|run_arg
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback proc for pre-commit checking  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|ulist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|precommit_proc
parameter_list|(
name|repository
parameter_list|,
name|filter
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
block|{
comment|/* see if the filter is there, only if it's a full path */
if|if
condition|(
name|isabsolute
argument_list|(
name|filter
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|s
operator|=
name|xstrdup
argument_list|(
name|filter
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot find pre-commit filter `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* so it fails! */
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|filter
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|ulist
argument_list|,
name|precommit_list_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the pre-commit checks for the dir  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|check_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the checks if there's nothing to do */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* run any pre-commit checks */
if|if
condition|(
operator|(
name|n
operator|=
name|Parse_Info
argument_list|(
name|CVSROOTADM_COMMITINFO
argument_list|,
name|repos
argument_list|,
name|precommit_proc
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Pre-commit check failed"
argument_list|)
expr_stmt|;
name|err
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the work of committing a file  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sbranch
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_fileproc
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|,
modifier|*
name|cilist
decl_stmt|;
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|)
expr_stmt|;
comment|/*      * if p is null, there were file type command line args which were      * all up-to-date so nothing really needs to be done      */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|cilist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|cilist
expr_stmt|;
comment|/*      * At this point, we should have the commit message unless we were called      * with files as args from the command line.  In that latter case, we      * need to get the commit message ourselves      */
if|if
condition|(
name|use_editor
operator|&&
operator|!
name|got_message
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|do_editor
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
operator|&
name|message
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
name|cilist
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
if|if
condition|(
name|lockrcsfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ci
operator|->
name|rev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
if|if
condition|(
name|checkaddfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
operator|&
name|finfo
operator|->
name|rcs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fixaddfile
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* adding files with a tag, now means adding them on a branch. 	   Since the branch test was done in check_fileproc for 	   modified files, we need to stub it in again here. */
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
block|{
name|locate_rcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ci
operator|->
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|ci
operator|->
name|tag
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|message
argument_list|,
name|finfo
operator|->
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
name|ci
operator|->
name|status
operator|=
name|T_UPTODATE
expr_stmt|;
block|}
block|}
comment|/*      * Add the file for real      */
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_ADDED
condition|)
block|{
name|char
modifier|*
name|xrev
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
operator|==
name|NULL
condition|)
block|{
comment|/* find the max major rev number in this directory */
name|maxrev
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|findmaxrev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrev
operator|==
literal|0
condition|)
name|maxrev
operator|=
literal|1
expr_stmt|;
name|xrev
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xrev
argument_list|,
literal|"%d"
argument_list|,
name|maxrev
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - an added file with symbolic -r should add tag as well */
name|err
operator|=
name|finaladd
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|ci
operator|->
name|rev
condition|?
name|ci
operator|->
name|rev
else|:
name|xrev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|finfo
operator|->
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|xrev
condition|)
name|free
argument_list|(
name|xrev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_MODIFIED
condition|)
block|{
name|locate_rcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|=
name|Checkin
argument_list|(
literal|'M'
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|rcs
argument_list|,
name|ci
operator|->
name|rev
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|ci
operator|->
name|options
argument_list|,
name|message
argument_list|,
name|finfo
operator|->
name|entries
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|unlockrcs
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|fixbranch
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|sbranch
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ci
operator|->
name|status
operator|==
name|T_REMOVED
condition|)
block|{
name|err
operator|=
name|remove_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
name|ci
operator|->
name|tag
argument_list|,
name|message
argument_list|,
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|rcs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_scratch_entry_only
argument_list|()
expr_stmt|;
name|server_updated
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|,
comment|/* Doesn't matter, it won't get checked.  */
name|SERVER_UPDATED
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Clearly this is right for T_MODIFIED.  I haven't thought so much        about T_ADDED or T_REMOVED.  */
name|notify_do
argument_list|(
literal|'C'
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* on failure, remove the file from ulist */
name|p
operator|=
name|findnode
argument_list|(
name|ulist
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Log the commit and clean up the update list  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_filesdoneproc
parameter_list|(
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|)
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|char
modifier|*
name|xtag
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
name|got_message
operator|=
literal|0
expr_stmt|;
comment|/* see if we need to specify a per-directory or -r option tag */
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
name|ParseTag
argument_list|(
operator|&
name|xtag
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|tag
condition|?
name|tag
else|:
name|xtag
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtag
condition|)
name|free
argument_list|(
name|xtag
argument_list|)
expr_stmt|;
comment|/* Build the administrative files if necessary.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|CVSroot
argument_list|,
name|repository
argument_list|,
name|strlen
argument_list|(
name|CVSroot
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: repository doesn't begin with root"
argument_list|)
expr_stmt|;
name|p
operator|=
name|repository
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"CVSROOT"
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* "Database" might a little bit grandiose and/or vague, 	       but "checked-out copies of administrative files, unless 	       in the case of modules and you are using ndbm in which 	       case modules.{pag,dir,db}" is verbose and excessively 	       focused on how the database is implemented.  */
name|cvs_output
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|command_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": Rebuilding administrative file database\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mkmodules
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|run_module_prog
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_length
operator|>
literal|0
condition|)
block|{
comment|/* Remove any trailing newline.  */
if|if
condition|(
name|line
index|[
name|line_length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
operator|--
name|line_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|run_setup
argument_list|(
literal|"%s %s"
argument_list|,
name|line
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s: Executing '"
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
name|run_print
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: error reading %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"warning: cannot open %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the log message for a dir and print a warm fuzzy  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|commit_direntproc
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|char
modifier|*
name|real_repos
decl_stmt|;
comment|/* find the update list for this dir */
name|p
operator|=
name|findnode
argument_list|(
name|mulist
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|ulist
operator|=
operator|(
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|ulist
expr_stmt|;
else|else
name|ulist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* skip the files as an optimization */
if|if
condition|(
name|ulist
operator|==
name|NULL
operator|||
name|ulist
operator|->
name|list
operator|->
name|next
operator|==
name|ulist
operator|->
name|list
condition|)
return|return
operator|(
name|R_SKIP_FILES
operator|)
return|;
comment|/* print the warm fuzzy */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Committing %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get commit message */
if|if
condition|(
name|use_editor
condition|)
block|{
name|got_message
operator|=
literal|1
expr_stmt|;
name|real_repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|do_editor
argument_list|(
name|update_dir
argument_list|,
operator|&
name|message
argument_list|,
name|real_repos
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|real_repos
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the post-commit proc if necessary  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|commit_dirleaveproc
parameter_list|(
name|dir
parameter_list|,
name|err
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
comment|/* update the per-directory tag info */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|write_dirtag
operator|!=
name|NULL
condition|)
block|{
name|WriteTag
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|write_dirtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_set_sticky
argument_list|(
name|update_dir
argument_list|,
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
argument_list|,
name|write_dirtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find the maximum major rev number in an entries file  */
end_comment

begin_function
specifier|static
name|int
name|findmaxrev
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|thisrev
decl_stmt|;
name|Entnode
modifier|*
name|entdata
decl_stmt|;
name|entdata
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|entdata
operator|->
name|version
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|thisrev
operator|=
name|atoi
argument_list|(
name|entdata
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|thisrev
operator|>
name|maxrev
condition|)
name|maxrev
operator|=
name|thisrev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually remove a file by moving it to the attic  * XXX - if removing a ,v file that is a relative symbolic link to  * another ,v file, we probably should add a ".." component to the  * link to keep it relative after we move it into the attic.  */
end_comment

begin_function
specifier|static
name|int
name|remove_file
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|message
parameter_list|,
name|entries
parameter_list|,
name|rcsnode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|RCSNode
modifier|*
name|rcsnode
decl_stmt|;
block|{
name|mode_t
name|omask
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|branch
decl_stmt|;
name|int
name|lockflag
decl_stmt|;
name|char
modifier|*
name|corev
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|prev_rev
decl_stmt|;
name|corev
operator|=
name|NULL
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|prev_rev
operator|=
name|NULL
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|branch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|&&
operator|!
operator|(
name|branch
operator|=
name|RCS_isbranch
argument_list|(
name|rcsnode
argument_list|,
name|tag
argument_list|)
operator|)
condition|)
block|{
comment|/* a symbolic tag is specified; just remove the tag from the file */
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_deltag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to remove tag `%s' from `%s'"
argument_list|,
name|tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* we are removing the file from either the head or a branch */
comment|/* commit a new, dead revision. */
comment|/* Print message indicating that file is going to be removed. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Removing %s;\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rev
operator|=
name|NULL
expr_stmt|;
name|lockflag
operator|=
name|RCS_FLAGS_LOCK
expr_stmt|;
if|if
condition|(
name|branch
condition|)
block|{
name|char
modifier|*
name|branchname
decl_stmt|;
name|rev
operator|=
name|RCS_whatbranch
argument_list|(
name|rcsnode
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot find branch \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rcsnode
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"boy, I'm confused."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|branchname
operator|=
name|RCS_getbranch
argument_list|(
name|rcsnode
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|branchname
operator|==
name|NULL
condition|)
block|{
comment|/* no revision exists on this branch.  use the previous 	       revision but do not lock. */
name|corev
operator|=
name|RCS_gettag
argument_list|(
name|rcsnode
argument_list|,
name|tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|lockflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|corev
operator|=
name|xstrdup
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|prev_rev
operator|=
name|xstrdup
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branchname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Not a branch */
block|{
comment|/* Get current head revision of file. */
if|if
condition|(
name|rcsnode
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not find parsed rcsfile %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev_rev
operator|=
name|RCS_head
argument_list|(
name|rcsnode
argument_list|)
expr_stmt|;
block|}
comment|/* if removing without a tag or a branch, then make sure the default        branch is the trunk. */
if|if
condition|(
operator|!
name|tag
operator|&&
operator|!
name|branch
condition|)
block|{
if|if
condition|(
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* If this is the server, there will be a file sitting in the 	   temp directory which is the kludgy way in which server.c 	   tells time_stamp that the file is no longer around.  Remove 	   it so we can create temp files with that name (ignore errors).  */
name|unlink_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* check something out.  Generally this is the head.  If we have a        particular rev, then name it.  except when creating a branch,        lock the rev we're checking out.  */
name|retcode
operator|=
name|RCS_checkout
argument_list|(
name|rcs
argument_list|,
literal|""
argument_list|,
name|rev
condition|?
name|corev
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
name|RUN_TTY
argument_list|,
name|lockflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to check out `%s'"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|corev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|corev
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkin
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|message
argument_list|,
name|rev
argument_list|,
name|RCS_FLAGS_DEAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"failed to commit dead revision for `%s'"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branch
condition|)
block|{
comment|/* this was the head; really move it into the Attic */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|'/'
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSATTIC
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|'/'
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RCSEXT
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CVS_MKDIR
argument_list|(
name|tmp
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rcs
argument_list|,
name|tmp
argument_list|)
operator|!=
literal|0
operator|&&
name|rename
argument_list|(
name|rcs
argument_list|,
name|tmp
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
operator|||
operator|!
name|isreadable
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Print message that file was removed. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s<--  %s\n"
argument_list|,
name|rcs
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"new revision: delete; "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"previous revision: %s\n"
argument_list|,
name|prev_rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev_rev
argument_list|)
expr_stmt|;
name|Scratch_Entry
argument_list|(
name|entries
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the actual checkin for added files  */
end_comment

begin_function
specifier|static
name|int
name|finaladd
parameter_list|(
name|file
parameter_list|,
name|rev
parameter_list|,
name|tag
parameter_list|,
name|options
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|entries
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Checkin
argument_list|(
literal|'A'
argument_list|,
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|tag
argument_list|,
name|options
argument_list|,
name|message
argument_list|,
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|fixaddfile
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|last_register_time
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|unlockrcs
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_unlock
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not unlock %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a partially added file.  if we can parse it, leave it alone.  */
end_comment

begin_function
specifier|static
name|void
name|fixaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_really_quiet
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|save_really_quiet
operator|=
name|really_quiet
expr_stmt|;
name|really_quiet
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
else|else
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
name|really_quiet
operator|=
name|save_really_quiet
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put the branch back on an rcs file  */
end_comment

begin_function
specifier|static
name|void
name|fixbranch
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|branch
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
operator|&&
name|branch
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"cannot restore branch to %s for %s"
argument_list|,
name|branch
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * do the initial part of a file add for the named file.  if adding  * with a tag, put the file in the Attic and point the symbolic tag  * at the committed revision.  */
end_comment

begin_function
specifier|static
name|int
name|checkaddfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|options
parameter_list|,
name|rcsnode
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|RCSNode
modifier|*
modifier|*
name|rcsnode
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|fname
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|mode_t
name|omask
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|int
name|newfile
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|rcs
argument_list|,
literal|0777
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory `%s'"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
empty_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
else|else
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
comment|/* file has existed in the past.  Prepare to resurrect. */
name|char
name|oldfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
comment|/* we are adding on the trunk, so move the file out of the 	       Attic. */
name|strcpy
argument_list|(
name|oldfile
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|oldfile
argument_list|,
name|rcs
argument_list|)
operator|==
literal|0
operator|||
name|rename
argument_list|(
name|oldfile
argument_list|,
name|rcs
argument_list|)
operator|!=
literal|0
operator|||
name|isreadable
argument_list|(
name|oldfile
argument_list|)
operator|||
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"failed to move `%s' out of the attic."
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|rcsfile
operator|=
operator|*
name|rcsnode
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not find parsed rcsfile %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rev
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* and lock it */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is the first time we have ever seen this file; create 	   an rcs file.  */
name|run_setup
argument_list|(
literal|"%s%s -x,v/ -i"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
comment|/* If the file does not exist, no big deal.  In particular, the 	   server does not (yet at least) create CVSEXT_LOG files.  */
if|if
condition|(
name|isfile
argument_list|(
name|fname
argument_list|)
condition|)
name|run_args
argument_list|(
literal|"-t%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|file
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
comment|/* Set RCS keyword expansion options.  */
if|if
condition|(
name|options
operator|&&
name|options
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|options
index|[
literal|1
index|]
operator|==
literal|'k'
condition|)
name|run_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not create %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|newfile
operator|=
literal|1
expr_stmt|;
block|}
comment|/* when adding a file for the first time, and using a tag, we need        to create a dead revision on the trunk.  */
if|if
condition|(
name|tag
operator|&&
name|newfile
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* move the new file out of the way. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|CVSPREFIX
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|copy_file
argument_list|(
name|DEVNULL
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
comment|/* commit a dead revision. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"file %s was initially added on branch %s."
argument_list|,
name|file
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|RCS_checkin
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|RCS_FLAGS_DEAD
operator||
name|RCS_FLAGS_QUIET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not create initial dead revision %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* put the new file back where it was */
name|rename_file
argument_list|(
name|fname
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* and lock it once again. */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcs
argument_list|,
name|NULL
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
comment|/* when adding with a tag, we need to stub a branch, if it 	   doesn't already exist.  */
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|rcsfile
operator|=
name|RCS_parse
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not read %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|RCS_nodeisbranch
argument_list|(
name|rcsfile
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* branch does not exist.  Stub it.  */
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|magicrev
decl_stmt|;
name|head
operator|=
name|RCS_getversion
argument_list|(
name|rcsfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|magicrev
operator|=
name|RCS_magicrev
argument_list|(
name|rcsfile
argument_list|,
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|magicrev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|retcode
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"could not stub branch %s for %s"
argument_list|,
name|tag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* reparse the file, then add it to our list. */
name|rcsfile
operator|=
name|RCS_parse
argument_list|(
name|file
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not reparse %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|magicrev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* lock the branch. (stubbed branches need not be locked.)  */
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcs
argument_list|,
name|NULL
argument_list|,
name|repository
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot lock `%s'."
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rcsnode
condition|)
name|freercsnode
argument_list|(
name|rcsnode
argument_list|)
expr_stmt|;
operator|*
name|rcsnode
operator|=
name|rcsfile
expr_stmt|;
block|}
name|fileattr_newfile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fix_rcs_modes
argument_list|(
name|rcs
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the rcs file ``file''  */
end_comment

begin_function
specifier|static
name|int
name|lockrcsfile
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|rev
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
block|{
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|locate_rcs
argument_list|(
name|file
argument_list|,
name|repository
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_RCS
argument_list|(
name|file
argument_list|,
name|rcs
argument_list|,
name|rev
argument_list|,
name|repository
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it  * couldn't.  If the RCS file currently has a branch as the head, we must  * move the head back to the trunk before locking the file, and be sure to  * put the branch back as the head if there are any errors.  */
end_comment

begin_function
specifier|static
name|int
name|lock_RCS
parameter_list|(
name|user
parameter_list|,
name|rcs
parameter_list|,
name|rev
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
modifier|*
name|branch
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/*      * For a specified, numeric revision of the form "1" or "1.1", (or when      * no revision is specified ""), definitely move the branch to the trunk      * before locking the RCS file.      *       * The assumption is that if there is more than one revision on the trunk,      * the head points to the trunk, not a branch... and as such, it's not      * necessary to move the head in this case.      */
if|if
condition|(
name|rev
operator|==
name|NULL
operator|||
operator|(
name|rev
operator|&&
name|isdigit
argument_list|(
operator|*
name|rev
argument_list|)
operator|&&
name|numdots
argument_list|(
name|rev
argument_list|)
operator|<
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|RCS_parsercsfile
argument_list|(
name|rcs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* invalid rcs file? */
name|err
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* rcsfile is valid */
name|branch
operator|=
name|xstrdup
argument_list|(
name|rcsfile
operator|->
name|branch
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|rcsfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot change branch to default for %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|err
operator|=
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|branch
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sbranch
argument_list|,
name|branch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
else|else
name|sbranch
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* try to restore the branch if we can on error */
if|if
condition|(
name|branch
operator|!=
name|NULL
condition|)
name|fixbranch
argument_list|(
name|user
argument_list|,
name|repository
argument_list|,
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
condition|)
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when "add"ing files to the RCS respository, as it is necessary to  * preserve the file modes in the same fashion that RCS does.  This would be  * automatic except that we are placing the RCS ,v file very far away from  * the user file, and I can't seem to convince RCS of the location of the  * user file.  So we munge it here, after the ,v file has been successfully  * initialized with "rcs -i".  */
end_comment

begin_function
specifier|static
name|void
name|fix_rcs_modes
parameter_list|(
name|rcs
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|user
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|rcs
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
operator|~
literal|0222
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free an UPDATE node's data (really nothing to do)  */
end_comment

begin_function
name|void
name|update_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the commit_info structure in p.  */
end_comment

begin_function
specifier|static
name|void
name|ci_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|commit_info
modifier|*
name|ci
decl_stmt|;
name|ci
operator|=
operator|(
expr|struct
name|commit_info
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|rev
condition|)
name|free
argument_list|(
name|ci
operator|->
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|tag
condition|)
name|free
argument_list|(
name|ci
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|options
condition|)
name|free
argument_list|(
name|ci
operator|->
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the commit_info structure in p.  */
end_comment

begin_function
specifier|static
name|void
name|masterlist_delproc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|master_lists
modifier|*
name|ml
decl_stmt|;
name|ml
operator|=
operator|(
expr|struct
name|master_lists
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ml
operator|->
name|cilist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ml
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an RCS file in the repository.  */
end_comment

begin_function
specifier|static
name|void
name|locate_rcs
parameter_list|(
name|file
parameter_list|,
name|repository
parameter_list|,
name|rcs
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|rcs
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|file
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

