begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Check In  *   * Does a very careful checkin of the file "user", and tries not to spoil its  * modification time (to avoid needless recompilations). When RCS ID keywords  * get expanded on checkout, however, the modification time is updated and  * there is no good way to get around this.  *   * Returns non-zero on error.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_function
name|int
name|Checkin
parameter_list|(
name|type
parameter_list|,
name|finfo
parameter_list|,
name|rev
parameter_list|,
name|tag
parameter_list|,
name|options
parameter_list|,
name|message
parameter_list|)
name|int
name|type
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|char
modifier|*
name|rev
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|set_time
decl_stmt|;
name|char
modifier|*
name|tocvsPath
init|=
name|NULL
decl_stmt|;
comment|/* Hmm.  This message goes to stdout and the "foo,v<--  foo"        message from "ci" goes to stderr.  This doesn't make a whole        lot of sense, but making everything go to stdout can only be        gracefully achieved once RCS_checkin is librarified.  */
name|cvs_output
argument_list|(
literal|"Checking in "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|finfo
operator|->
name|fullname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tocvsPath
operator|=
name|wrap_tocvs_process_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
if|if
condition|(
name|tocvsPath
condition|)
block|{
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|rename_file
argument_list|(
name|tocvsPath
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There use to be a check for finfo->rcs == NULL here and then a      * call to RCS_parse when necessary, but Checkin() isn't called      * if the RCS file hasn't already been parsed in one of the      * check functions.      */
name|assert
argument_list|(
name|finfo
operator|->
name|rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|RCS_checkin
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|message
argument_list|,
name|rev
argument_list|,
name|RCS_FLAGS_KEEPFILE
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* everything normal */
comment|/* The checkin succeeded.  If checking the file out again                would not cause any changes, we are done.  Otherwise,                we need to check out the file, which will change the                modification time of the file.  	       The only way checking out the file could cause any 	       changes is if the file contains RCS keywords.  So we if 	       we are not expanding RCS keywords, we are done.  */
if|if
condition|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
comment|/* upgrade to V5 now */
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* FIXME: If PreservePermissions is on, RCS_cmp_file is                going to call RCS_checkout into a temporary file                anyhow.  In that case, it would be more efficient to                call RCS_checkout here, compare the resulting files                using xcmp, and rename if necessary.  I think this                should be fixed in RCS_cmp_file.  */
if|if
condition|(
operator|(
operator|!
name|preserve_perms
operator|&&
name|options
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-ko"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|options
argument_list|,
literal|"-kb"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
name|RCS_cmp_file
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|rev
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The existing file is correct.  We don't have to do                    anything.  */
name|set_time
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* The existing file is incorrect.  We need to check                    out the correct file contents.  */
if|if
condition|(
name|RCS_checkout
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|rev
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|options
argument_list|,
name|RUN_TTY
argument_list|,
operator|(
name|RCSCHECKOUTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"failed when checking out new copy of %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_time
operator|=
literal|1
expr_stmt|;
block|}
name|wrap_fromcvs_process_file
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* 	     * If we want read-only files, muck the permissions here, before 	     * getting the file time-stamp. 	     */
if|if
condition|(
operator|!
name|cvswrite
operator|||
name|fileattr_get
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"_watched"
argument_list|)
condition|)
name|xchmod
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Re-register with the new data.  */
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|set_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vers
operator|->
name|options
argument_list|,
literal|"-V4"
argument_list|)
operator|==
literal|0
condition|)
name|vers
operator|->
name|options
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Register
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|history_write
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
comment|/* fork failed */
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not check in %s -- fork failed"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* ci failed */
comment|/* The checkin failed, for some unknown reason, so we 	       print an error, and return an error.  We assume that 	       the original file has not been touched.  */
if|if
condition|(
name|tocvsPath
condition|)
if|if
condition|(
name|unlink_file_dir
argument_list|(
name|tocvsPath
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|tocvsPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"could not check in %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*      * When checking in a specific revision, we may have locked the wrong      * branch, so to be sure, we do an extra unlock here before      * returning.      */
if|if
condition|(
name|rev
condition|)
block|{
operator|(
name|void
operator|)
name|RCS_unlock
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RCS_rewrite
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
if|if
condition|(
name|set_time
condition|)
comment|/* Need to update the checked out file on the client side.  */
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|server_checked_in
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|mark_up_to_date
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

