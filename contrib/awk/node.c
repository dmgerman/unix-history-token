begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * node.c -- routines for node management  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991-2000 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_comment
comment|/* r_force_number --- force a value to be numeric */
end_comment

begin_function
name|AWKNUM
name|r_force_number
parameter_list|(
name|n
parameter_list|)
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpend
decl_stmt|;
name|char
name|save
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|newflags
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|Node_val
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|flags
operator|==
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NUM
condition|)
return|return
name|n
operator|->
name|numbr
return|;
endif|#
directive|endif
comment|/* all the conditionals are an attempt to avoid the expensive strtod */
name|n
operator|->
name|numbr
operator|=
literal|0.0
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|NUM
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|stlen
operator|==
literal|0
condition|)
return|return
literal|0.0
return|;
name|cp
operator|=
name|n
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0.0
return|;
name|cpend
operator|=
name|cp
operator|+
name|n
operator|->
name|stlen
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|cpend
operator|||
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
block|{
name|newflags
operator|=
name|NUMBER
expr_stmt|;
name|n
operator|->
name|flags
operator|&=
operator|~
name|MAYBE_NUM
expr_stmt|;
block|}
else|else
name|newflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpend
operator|-
name|cp
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|n
operator|->
name|numbr
operator|=
call|(
name|AWKNUM
call|)
argument_list|(
operator|*
name|cp
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|newflags
expr_stmt|;
block|}
return|return
name|n
operator|->
name|numbr
return|;
block|}
ifdef|#
directive|ifdef
name|NONDECDATA
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|isnondecimal
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|n
operator|->
name|numbr
operator|=
name|nondec2awknum
argument_list|(
name|cp
argument_list|,
name|cpend
operator|-
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
endif|#
directive|endif
comment|/* NONDECDATA */
name|errno
operator|=
literal|0
expr_stmt|;
name|save
operator|=
operator|*
name|cpend
expr_stmt|;
operator|*
name|cpend
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|->
name|numbr
operator|=
operator|(
name|AWKNUM
operator|)
name|strtod
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
comment|/* POSIX says trailing space is OK for NUMBER */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
operator|*
name|cpend
operator|=
name|save
expr_stmt|;
name|finish
label|:
comment|/* the>= should be ==, but for SunOS 3.5 strtod() */
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
name|ptr
operator|>=
name|cpend
condition|)
name|n
operator|->
name|flags
operator||=
name|newflags
expr_stmt|;
else|else
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|n
operator|->
name|numbr
return|;
block|}
end_function

begin_comment
comment|/*  * the following lookup table is used as an optimization in force_string  * (more complicated) variations on this theme didn't seem to pay off, but   * systematic testing might be in order at some point  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|values
index|[]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NVAL
value|(sizeof(values)/sizeof(values[0]))
end_define

begin_comment
comment|/* format_val --- format a numeric value based on format */
end_comment

begin_function
name|NODE
modifier|*
name|format_val
parameter_list|(
name|format
parameter_list|,
name|index
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|index
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
init|=
name|buf
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* not an integral value, or out of range */
if|if
condition|(
operator|(
name|val
operator|=
name|double_to_int
argument_list|(
name|s
operator|->
name|numbr
argument_list|)
operator|)
operator|!=
name|s
operator|->
name|numbr
operator|||
name|val
operator|<
name|LONG_MIN
operator|||
name|val
operator|>
name|LONG_MAX
condition|)
block|{
comment|/* 		 * Once upon a time, if GFMT_WORKAROUND wasn't defined, 		 * we just blindly did this: 		 *	sprintf(sp, format, s->numbr); 		 *	s->stlen = strlen(sp); 		 *	s->stfmt = (char) index; 		 * but that's no good if, e.g., OFMT is %s. So we punt, 		 * and just always format the value ourselves. 		 */
name|NODE
modifier|*
name|dummy
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|unsigned
name|short
name|oflags
decl_stmt|;
specifier|extern
name|NODE
modifier|*
name|format_tree
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|NODE
modifier|*
modifier|*
name|fmt_list
decl_stmt|;
comment|/* declared in eval.c */
comment|/* create dummy node for a sole use of format_tree */
name|getnode
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|lnode
operator|=
name|s
expr_stmt|;
name|dummy
operator|->
name|rnode
operator|=
name|NULL
expr_stmt|;
name|oflags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|PERM
expr_stmt|;
comment|/* prevent from freeing by format_tree() */
name|r
operator|=
name|format_tree
argument_list|(
name|format
argument_list|,
name|fmt_list
index|[
name|index
index|]
operator|->
name|stlen
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator|=
name|oflags
expr_stmt|;
name|s
operator|->
name|stfmt
operator|=
operator|(
name|char
operator|)
name|index
expr_stmt|;
name|s
operator|->
name|stlen
operator|=
name|r
operator|->
name|stlen
expr_stmt|;
name|s
operator|->
name|stptr
operator|=
name|r
operator|->
name|stptr
expr_stmt|;
name|freenode
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Do not free_temp(r)!  We want */
name|freenode
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
comment|/* to keep s->stptr == r->stpr.  */
goto|goto
name|no_malloc
goto|;
block|}
else|else
block|{
comment|/* integral value */
comment|/* force conversion to long only once */
specifier|register
name|long
name|num
init|=
operator|(
name|long
operator|)
name|val
decl_stmt|;
if|if
condition|(
name|num
operator|<
name|NVAL
operator|&&
name|num
operator|>=
literal|0
condition|)
block|{
name|sp
operator|=
operator|(
name|char
operator|*
operator|)
name|values
index|[
name|num
index|]
expr_stmt|;
name|s
operator|->
name|stlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"%ld"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|s
operator|->
name|stlen
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|stfmt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|emalloc
argument_list|(
name|s
operator|->
name|stptr
argument_list|,
name|char
operator|*
argument_list|,
name|s
operator|->
name|stlen
operator|+
literal|2
argument_list|,
literal|"format_val"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|stptr
argument_list|,
name|sp
argument_list|,
name|s
operator|->
name|stlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|no_malloc
label|:
name|s
operator|->
name|stref
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|STR
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* r_force_string --- force a value to be a string */
end_comment

begin_function
name|NODE
modifier|*
name|r_force_string
parameter_list|(
name|s
parameter_list|)
specifier|register
name|NODE
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|Node_val
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
comment|/* 	if ((s->flags& NUM) == 0) 		cant_happen(); */
if|if
condition|(
name|s
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|STR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|->
name|stfmt
operator|==
operator|-
literal|1
operator|||
name|s
operator|->
name|stfmt
operator|==
name|CONVFMTidx
operator|)
condition|)
return|return
name|s
return|;
endif|#
directive|endif
return|return
name|format_val
argument_list|(
name|CONVFMT
argument_list|,
name|CONVFMTidx
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * dupnode:  * Duplicate a node.  (For strings, "duplicate" means crank up the  * reference count.)  */
end_comment

begin_function
name|NODE
modifier|*
name|dupnode
parameter_list|(
name|n
parameter_list|)
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|flags
operator|&
name|TEMP
operator|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|->
name|flags
operator|&=
operator|~
name|TEMP
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|MALLOC
expr_stmt|;
return|return
name|n
return|;
block|}
if|if
condition|(
operator|(
name|n
operator|->
name|flags
operator|&
operator|(
name|MALLOC
operator||
name|STR
operator|)
operator|)
operator|==
operator|(
name|MALLOC
operator||
name|STR
operator|)
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|stref
operator|<
name|LONG_MAX
condition|)
name|n
operator|->
name|stref
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|n
expr_stmt|;
name|r
operator|->
name|flags
operator|&=
operator|~
operator|(
name|PERM
operator||
name|TEMP
operator||
name|FIELD
operator|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|MALLOC
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_val
operator|&&
operator|(
name|n
operator|->
name|flags
operator|&
name|STR
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|->
name|stref
operator|=
literal|1
expr_stmt|;
name|emalloc
argument_list|(
name|r
operator|->
name|stptr
argument_list|,
name|char
operator|*
argument_list|,
name|r
operator|->
name|stlen
operator|+
literal|2
argument_list|,
literal|"dupnode"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|stptr
argument_list|,
name|n
operator|->
name|stptr
argument_list|,
name|r
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|r
operator|->
name|stptr
index|[
name|r
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* mk_number --- allocate a node with defined number */
end_comment

begin_function
name|NODE
modifier|*
name|mk_number
parameter_list|(
name|x
parameter_list|,
name|flags
parameter_list|)
name|AWKNUM
name|x
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_val
expr_stmt|;
name|r
operator|->
name|numbr
operator|=
name|x
expr_stmt|;
name|r
operator|->
name|flags
operator|=
name|flags
operator||
name|SCALAR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|r
operator|->
name|stref
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|stptr
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|stlen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* make_str_node --- make a string node */
end_comment

begin_function
name|NODE
modifier|*
name|make_str_node
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_val
expr_stmt|;
name|r
operator|->
name|flags
operator|=
operator|(
name|STRING
operator||
name|STR
operator||
name|MALLOC
operator||
name|SCALAR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ALREADY_MALLOCED
condition|)
name|r
operator|->
name|stptr
operator|=
name|s
expr_stmt|;
else|else
block|{
name|emalloc
argument_list|(
name|r
operator|->
name|stptr
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|->
name|stptr
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|stptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCAN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* scan for escape sequences */
name|char
modifier|*
name|pf
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptm
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
operator|&
operator|(
name|r
operator|->
name|stptr
index|[
name|len
index|]
operator|)
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|ptm
operator|=
name|r
operator|->
name|stptr
init|;
name|pf
operator|<
name|end
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|pf
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|warning
argument_list|(
literal|"backslash at end of string"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
operator|*
name|ptm
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
operator|*
name|ptm
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|len
operator|=
name|ptm
operator|-
name|r
operator|->
name|stptr
expr_stmt|;
name|erealloc
argument_list|(
name|r
operator|->
name|stptr
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|,
literal|"make_str_node"
argument_list|)
expr_stmt|;
name|r
operator|->
name|stptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|PERM
expr_stmt|;
block|}
name|r
operator|->
name|stlen
operator|=
name|len
expr_stmt|;
name|r
operator|->
name|stref
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|stfmt
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* tmp_string --- allocate a temporary string */
end_comment

begin_function
name|NODE
modifier|*
name|tmp_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* more_nodes --- allocate more nodes */
end_comment

begin_define
define|#
directive|define
name|NODECHUNK
value|100
end_define

begin_decl_stmt
name|NODE
modifier|*
name|nextfree
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|NODE
modifier|*
name|more_nodes
parameter_list|()
block|{
specifier|register
name|NODE
modifier|*
name|np
decl_stmt|;
comment|/* get more nodes and initialize list */
name|emalloc
argument_list|(
name|nextfree
argument_list|,
name|NODE
operator|*
argument_list|,
name|NODECHUNK
operator|*
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|,
literal|"newnode"
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nextfree
init|;
name|np
operator|<=
operator|&
name|nextfree
index|[
name|NODECHUNK
operator|-
literal|1
index|]
condition|;
name|np
operator|++
control|)
block|{
name|np
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|nextp
operator|=
name|np
operator|+
literal|1
expr_stmt|;
block|}
operator|--
name|np
expr_stmt|;
name|np
operator|->
name|nextp
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|nextfree
expr_stmt|;
name|nextfree
operator|=
name|nextfree
operator|->
name|nextp
expr_stmt|;
return|return
name|np
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* freenode --- release a node back to the pool */
end_comment

begin_function
name|void
name|freenode
parameter_list|(
name|it
parameter_list|)
name|NODE
modifier|*
name|it
decl_stmt|;
block|{
name|it
operator|->
name|flags
operator|&=
operator|~
name|SCALAR
expr_stmt|;
ifdef|#
directive|ifdef
name|MPROF
name|it
operator|->
name|stref
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|it
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not MPROF */
comment|/* add it to head of freelist */
name|it
operator|->
name|nextp
operator|=
name|nextfree
expr_stmt|;
name|nextfree
operator|=
name|it
expr_stmt|;
endif|#
directive|endif
comment|/* not MPROF */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* unref --- remove reference to a particular node */
end_comment

begin_function
name|void
name|unref
parameter_list|(
name|tmp
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
block|{
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|PERM
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|MALLOC
operator||
name|TEMP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|->
name|flags
operator|&=
operator|~
name|TEMP
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|STR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|stref
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|stref
operator|!=
name|LONG_MAX
condition|)
name|tmp
operator|->
name|stref
operator|--
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|)
expr_stmt|;
block|}
name|freenode
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
name|FIELD
operator|)
operator|!=
literal|0
condition|)
block|{
name|freenode
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * parse_escape:  *  * Parse a C escape sequence.  STRING_PTR points to a variable containing a  * pointer to the string to parse.  That pointer is updated past the  * characters we use.  The value of the escape sequence is returned.   *  * A negative value means the sequence \ newline was seen, which is supposed to  * be equivalent to nothing at all.   *  * If \ is followed by a null character, we return a negative value and leave  * the string pointer pointing at the null character.   *  * If \ is followed by 000, we return 0 and leave the string pointer after the  * zeros.  A value of 0 does not mean end of string.    *  * Posix doesn't allow \x.  */
end_comment

begin_function
name|int
name|parse_escape
parameter_list|(
name|string_ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|string_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
return|return
name|BELL
return|;
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'v'
case|:
return|return
literal|'\v'
return|;
case|case
literal|'\n'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|0
case|:
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|i
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|*=
literal|8
expr_stmt|;
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
case|case
literal|'x'
case|:
if|if
condition|(
name|do_lint
condition|)
block|{
specifier|static
name|int
name|didwarn
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|didwarn
condition|)
block|{
name|didwarn
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|(
literal|"POSIX does not allow \"\\x\" escapes"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_posix
condition|)
return|return
operator|(
literal|'x'
operator|)
return|;
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|(
operator|*
name|string_ptr
operator|)
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"no hex digits in \\x escape sequence"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'x'
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* do outside test to avoid multiple side effects */
name|c
operator|=
operator|*
operator|(
operator|*
name|string_ptr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|i
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|i
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|i
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
name|i
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|string_ptr
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
default|default:
if|if
condition|(
name|do_lint
condition|)
block|{
specifier|static
name|short
name|warned
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|uc
init|=
operator|(
name|unsigned
name|char
operator|)
name|c
decl_stmt|;
comment|/* N.B.: use unsigned char here to avoid Latin-1 problems */
if|if
condition|(
operator|!
name|warned
index|[
name|uc
index|]
condition|)
block|{
name|warned
index|[
name|uc
index|]
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|(
literal|"escape sequence `\\%c' treated as plain `%c'"
argument_list|,
name|uc
argument_list|,
name|uc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

end_unit

