begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ext.c - Builtin function that links external gawk functions and related  *	   utilities.  *  * Christos Zoulas, Thu Jun 29 17:40:41 EDT 1995  * Arnold Robbins, update for 3.1, Mon Nov 23 12:53:39 EST 1998  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1995 - 2001 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|long
name|dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fake out gcc for dynamic loading? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do_ext --- load an extension */
end_comment

begin_function
name|NODE
modifier|*
name|do_ext
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|obj
decl_stmt|;
name|NODE
modifier|*
name|fun
decl_stmt|;
name|NODE
operator|*
operator|(
operator|*
name|func
operator|)
name|P
argument_list|(
operator|(
name|NODE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
modifier|*
name|dl
decl_stmt|;
name|int
name|flags
init|=
name|RTLD_LAZY
decl_stmt|;
ifdef|#
directive|ifdef
name|__GNUC__
name|AWKNUM
name|junk
decl_stmt|;
name|junk
operator|=
operator|(
name|AWKNUM
operator|)
name|dummy
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"`extension' is a gawk extension"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_traditional
operator|||
name|do_posix
condition|)
block|{
name|errcount
operator|++
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"`extension' is a gawk extension"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|force_string
argument_list|(
name|obj
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTLD_GLOBAL
name|flags
operator||=
name|RTLD_GLOBAL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|dl
operator|=
name|dlopen
argument_list|(
name|obj
operator|->
name|stptr
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"extension: cannot open `%s' (%s)\n"
argument_list|)
argument_list|,
name|obj
operator|->
name|stptr
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
name|fun
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|force_string
argument_list|(
name|fun
argument_list|)
expr_stmt|;
name|func
operator|=
operator|(
name|NODE
operator|*
operator|(
operator|*
operator|)
name|P
argument_list|(
operator|(
name|NODE
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
operator|)
name|dlsym
argument_list|(
name|dl
argument_list|,
name|fun
operator|->
name|stptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"extension: library `%s': cannot call function `%s' (%s)\n"
argument_list|)
argument_list|,
name|obj
operator|->
name|stptr
argument_list|,
name|fun
operator|->
name|stptr
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|fun
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|tree
argument_list|,
name|dl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* make_builtin --- register name to be called as func with a builtin body */
end_comment

begin_decl_stmt
name|void
name|make_builtin
argument_list|(
name|char
operator|*
name|name
argument_list|,
name|NODE
operator|*
operator|(
operator|*
name|func
operator|)
name|P
argument_list|(
operator|(
name|NODE
operator|*
operator|)
argument_list|)
argument_list|,
name|int
name|count
argument_list|)
block|{
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
modifier|*
name|vnames
decl_stmt|,
modifier|*
name|parm_names
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|space_needed
decl_stmt|,
name|i
decl_stmt|;
comment|/* count parameters, create artificial list of param names */
name|space_needed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"p%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|space_needed
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|emalloc
argument_list|(
name|parm_names
argument_list|,
name|char
operator|*
argument_list|,
name|space_needed
argument_list|,
literal|"make_builtin"
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|vnames
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|"make_builtin"
argument_list|)
expr_stmt|;
name|sp
operator|=
name|parm_names
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|sp
argument_list|,
literal|"p%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vnames
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|getnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|Node_param_list
expr_stmt|;
name|p
operator|->
name|rnode
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|param
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|param_cnt
operator|=
name|count
expr_stmt|;
if|#
directive|if
literal|0
comment|/* setting these  blows away the param_cnt. dang unions! */
block|p->source_line = __LINE__; 	p->source_file = __FILE__;
endif|#
directive|endif
name|getnode
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|Node_builtin
expr_stmt|;
name|b
operator|->
name|proc
operator|=
name|func
expr_stmt|;
name|b
operator|->
name|subnode
operator|=
name|p
expr_stmt|;
name|b
operator|->
name|source_line
operator|=
name|__LINE__
expr_stmt|;
name|b
operator|->
name|source_file
operator|=
name|__FILE__
expr_stmt|;
name|f
operator|=
name|node
argument_list|(
name|p
argument_list|,
name|Node_func
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|f
operator|->
name|parmlist
operator|=
name|vnames
expr_stmt|;
name|install
argument_list|(
name|name
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* get_argument --- Get the n'th argument of a dynamically linked function */
end_comment

begin_function
name|NODE
modifier|*
name|get_argument
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|extern
name|NODE
modifier|*
modifier|*
name|stack_ptr
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|tree
operator|->
name|param_cnt
condition|)
return|return
name|NULL
return|;
name|tree
operator|=
name|stack_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|Nnull_string
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_array_ref
condition|)
name|tree
operator|=
name|tree
operator|->
name|orig_array
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_var_array
condition|)
return|return
name|tree
return|;
return|return
name|tree
operator|->
name|lnode
return|;
block|}
end_function

begin_comment
comment|/* set_value --- set the return value of a dynamically linked function */
end_comment

begin_function
name|void
name|set_value
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
specifier|extern
name|NODE
modifier|*
name|ret_node
decl_stmt|;
if|if
condition|(
name|tree
condition|)
name|ret_node
operator|=
name|tree
expr_stmt|;
else|else
name|ret_node
operator|=
name|Nnull_string
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* do_ext --- dummy version if extensions not available */
end_comment

begin_function
name|NODE
modifier|*
name|do_ext
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|char
modifier|*
name|emsg
init|=
name|_
argument_list|(
literal|"Operation Not Supported"
argument_list|)
decl_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|emsg
argument_list|,
name|strlen
argument_list|(
name|emsg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

