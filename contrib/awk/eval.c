begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * eval.c - gawk parse tree interpreter   */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991-1997 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
specifier|extern
name|double
name|pow
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
name|y
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|modf
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
operator|*
name|yp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|double
name|fmod
name|P
argument_list|(
operator|(
name|double
name|x
operator|,
name|double
name|y
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eval_condition
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|op_assign
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|func_call
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|name
operator|,
name|NODE
operator|*
name|arg_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|match_op
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_args
name|P
argument_list|(
operator|(
name|int
name|count
operator|,
name|NODE
operator|*
name|arglist
operator|,
name|NODE
operator|*
operator|*
name|oldstack
operator|,
name|char
operator|*
name|func_name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_fcall_stack
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_fcall
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_function
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nodetype2str
name|P
argument_list|(
operator|(
name|NODETYPE
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flags2str
name|P
argument_list|(
operator|(
name|int
name|flagval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__GNUC__
operator|<
literal|2
end_if

begin_decl_stmt
name|NODE
modifier|*
name|_t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used as a temporary in macros */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
name|double
name|_msc51bug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to get around a bug in MSC 5.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|NODE
modifier|*
name|ret_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OFSlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ORSlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OFMTidx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CONVFMTidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros and variables to save and restore function and loop bindings */
end_comment

begin_comment
comment|/*  * the val variable allows return/continue/break-out-of-context to be  * caught and diagnosed  */
end_comment

begin_define
define|#
directive|define
name|PUSH_BINDING
parameter_list|(
name|stack
parameter_list|,
name|x
parameter_list|,
name|val
parameter_list|)
value|(memcpy((char *)(stack), (char *)(x), sizeof(jmp_buf)), val++)
end_define

begin_define
define|#
directive|define
name|RESTORE_BINDING
parameter_list|(
name|stack
parameter_list|,
name|x
parameter_list|,
name|val
parameter_list|)
value|(memcpy((char *)(x), (char *)(stack), sizeof(jmp_buf)), val--)
end_define

begin_decl_stmt
specifier|static
name|jmp_buf
name|loop_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* always the current binding */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_tag_valid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero when loop_tag valid */
end_comment

begin_decl_stmt
specifier|static
name|int
name|func_tag_valid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|func_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|exiting
decl_stmt|,
name|exit_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This table is used by the regexp routines to do case independant  * matching. Basically, every ascii character maps to itself, except  * uppercase letters map to lower case ones. This table has 256  * entries, for ISO 8859-1. Note also that if the system this  * is compiled on doesn't use 7-bit ascii, casetable[] should not be  * defined to the linker, so gawk should not load.  *  * Do NOT make this array static, it is used in several spots, not  * just in this file.  */
end_comment

begin_if
if|#
directive|if
literal|'a'
operator|==
literal|97
end_if

begin_comment
comment|/* it's ascii */
end_comment

begin_decl_stmt
name|char
name|casetable
index|[]
init|=
block|{
literal|'\000'
block|,
literal|'\001'
block|,
literal|'\002'
block|,
literal|'\003'
block|,
literal|'\004'
block|,
literal|'\005'
block|,
literal|'\006'
block|,
literal|'\007'
block|,
literal|'\010'
block|,
literal|'\011'
block|,
literal|'\012'
block|,
literal|'\013'
block|,
literal|'\014'
block|,
literal|'\015'
block|,
literal|'\016'
block|,
literal|'\017'
block|,
literal|'\020'
block|,
literal|'\021'
block|,
literal|'\022'
block|,
literal|'\023'
block|,
literal|'\024'
block|,
literal|'\025'
block|,
literal|'\026'
block|,
literal|'\027'
block|,
literal|'\030'
block|,
literal|'\031'
block|,
literal|'\032'
block|,
literal|'\033'
block|,
literal|'\034'
block|,
literal|'\035'
block|,
literal|'\036'
block|,
literal|'\037'
block|,
comment|/* ' '     '!'     '"'     '#'     '$'     '%'     '&'     ''' */
literal|'\040'
block|,
literal|'\041'
block|,
literal|'\042'
block|,
literal|'\043'
block|,
literal|'\044'
block|,
literal|'\045'
block|,
literal|'\046'
block|,
literal|'\047'
block|,
comment|/* '('     ')'     '*'     '+'     ','     '-'     '.'     '/' */
literal|'\050'
block|,
literal|'\051'
block|,
literal|'\052'
block|,
literal|'\053'
block|,
literal|'\054'
block|,
literal|'\055'
block|,
literal|'\056'
block|,
literal|'\057'
block|,
comment|/* '0'     '1'     '2'     '3'     '4'     '5'     '6'     '7' */
literal|'\060'
block|,
literal|'\061'
block|,
literal|'\062'
block|,
literal|'\063'
block|,
literal|'\064'
block|,
literal|'\065'
block|,
literal|'\066'
block|,
literal|'\067'
block|,
comment|/* '8'     '9'     ':'     ';'     '<'     '='     '>'     '?' */
literal|'\070'
block|,
literal|'\071'
block|,
literal|'\072'
block|,
literal|'\073'
block|,
literal|'\074'
block|,
literal|'\075'
block|,
literal|'\076'
block|,
literal|'\077'
block|,
comment|/* '@'     'A'     'B'     'C'     'D'     'E'     'F'     'G' */
literal|'\100'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
comment|/* 'H'     'I'     'J'     'K'     'L'     'M'     'N'     'O' */
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
comment|/* 'P'     'Q'     'R'     'S'     'T'     'U'     'V'     'W' */
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
comment|/* 'X'     'Y'     'Z'     '['     '\'     ']'     '^'     '_' */
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\133'
block|,
literal|'\134'
block|,
literal|'\135'
block|,
literal|'\136'
block|,
literal|'\137'
block|,
comment|/* '`'     'a'     'b'     'c'     'd'     'e'     'f'     'g' */
literal|'\140'
block|,
literal|'\141'
block|,
literal|'\142'
block|,
literal|'\143'
block|,
literal|'\144'
block|,
literal|'\145'
block|,
literal|'\146'
block|,
literal|'\147'
block|,
comment|/* 'h'     'i'     'j'     'k'     'l'     'm'     'n'     'o' */
literal|'\150'
block|,
literal|'\151'
block|,
literal|'\152'
block|,
literal|'\153'
block|,
literal|'\154'
block|,
literal|'\155'
block|,
literal|'\156'
block|,
literal|'\157'
block|,
comment|/* 'p'     'q'     'r'     's'     't'     'u'     'v'     'w' */
literal|'\160'
block|,
literal|'\161'
block|,
literal|'\162'
block|,
literal|'\163'
block|,
literal|'\164'
block|,
literal|'\165'
block|,
literal|'\166'
block|,
literal|'\167'
block|,
comment|/* 'x'     'y'     'z'     '{'     '|'     '}'     '~' */
literal|'\170'
block|,
literal|'\171'
block|,
literal|'\172'
block|,
literal|'\173'
block|,
literal|'\174'
block|,
literal|'\175'
block|,
literal|'\176'
block|,
literal|'\177'
block|,
ifndef|#
directive|ifndef
name|USE_PURE_ASCII
literal|'\200'
block|,
literal|'\201'
block|,
literal|'\202'
block|,
literal|'\203'
block|,
literal|'\204'
block|,
literal|'\205'
block|,
literal|'\206'
block|,
literal|'\207'
block|,
literal|'\210'
block|,
literal|'\211'
block|,
literal|'\212'
block|,
literal|'\213'
block|,
literal|'\214'
block|,
literal|'\215'
block|,
literal|'\216'
block|,
literal|'\217'
block|,
literal|'\220'
block|,
literal|'\221'
block|,
literal|'\222'
block|,
literal|'\223'
block|,
literal|'\224'
block|,
literal|'\225'
block|,
literal|'\226'
block|,
literal|'\227'
block|,
literal|'\230'
block|,
literal|'\231'
block|,
literal|'\232'
block|,
literal|'\233'
block|,
literal|'\234'
block|,
literal|'\235'
block|,
literal|'\236'
block|,
literal|'\237'
block|,
literal|'\240'
block|,
literal|'\241'
block|,
literal|'\242'
block|,
literal|'\243'
block|,
literal|'\244'
block|,
literal|'\245'
block|,
literal|'\246'
block|,
literal|'\247'
block|,
literal|'\250'
block|,
literal|'\251'
block|,
literal|'\252'
block|,
literal|'\253'
block|,
literal|'\254'
block|,
literal|'\255'
block|,
literal|'\256'
block|,
literal|'\257'
block|,
literal|'\260'
block|,
literal|'\261'
block|,
literal|'\262'
block|,
literal|'\263'
block|,
literal|'\264'
block|,
literal|'\265'
block|,
literal|'\266'
block|,
literal|'\267'
block|,
literal|'\270'
block|,
literal|'\271'
block|,
literal|'\272'
block|,
literal|'\273'
block|,
literal|'\274'
block|,
literal|'\275'
block|,
literal|'\276'
block|,
literal|'\277'
block|,
literal|'\340'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\327'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\373'
block|,
literal|'\374'
block|,
literal|'\375'
block|,
literal|'\376'
block|,
literal|'\337'
block|,
literal|'\340'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\367'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\373'
block|,
literal|'\374'
block|,
literal|'\375'
block|,
literal|'\376'
block|,
literal|'\377'
block|,
else|#
directive|else
literal|'\200'
block|,
literal|'\201'
block|,
literal|'\202'
block|,
literal|'\203'
block|,
literal|'\204'
block|,
literal|'\205'
block|,
literal|'\206'
block|,
literal|'\207'
block|,
literal|'\210'
block|,
literal|'\211'
block|,
literal|'\212'
block|,
literal|'\213'
block|,
literal|'\214'
block|,
literal|'\215'
block|,
literal|'\216'
block|,
literal|'\217'
block|,
literal|'\220'
block|,
literal|'\221'
block|,
literal|'\222'
block|,
literal|'\223'
block|,
literal|'\224'
block|,
literal|'\225'
block|,
literal|'\226'
block|,
literal|'\227'
block|,
literal|'\230'
block|,
literal|'\231'
block|,
literal|'\232'
block|,
literal|'\233'
block|,
literal|'\234'
block|,
literal|'\235'
block|,
literal|'\236'
block|,
literal|'\237'
block|,
literal|'\240'
block|,
literal|'\241'
block|,
literal|'\242'
block|,
literal|'\243'
block|,
literal|'\244'
block|,
literal|'\245'
block|,
literal|'\246'
block|,
literal|'\247'
block|,
literal|'\250'
block|,
literal|'\251'
block|,
literal|'\252'
block|,
literal|'\253'
block|,
literal|'\254'
block|,
literal|'\255'
block|,
literal|'\256'
block|,
literal|'\257'
block|,
literal|'\260'
block|,
literal|'\261'
block|,
literal|'\262'
block|,
literal|'\263'
block|,
literal|'\264'
block|,
literal|'\265'
block|,
literal|'\266'
block|,
literal|'\267'
block|,
literal|'\270'
block|,
literal|'\271'
block|,
literal|'\272'
block|,
literal|'\273'
block|,
literal|'\274'
block|,
literal|'\275'
block|,
literal|'\276'
block|,
literal|'\277'
block|,
literal|'\300'
block|,
literal|'\301'
block|,
literal|'\302'
block|,
literal|'\303'
block|,
literal|'\304'
block|,
literal|'\305'
block|,
literal|'\306'
block|,
literal|'\307'
block|,
literal|'\310'
block|,
literal|'\311'
block|,
literal|'\312'
block|,
literal|'\313'
block|,
literal|'\314'
block|,
literal|'\315'
block|,
literal|'\316'
block|,
literal|'\317'
block|,
literal|'\320'
block|,
literal|'\321'
block|,
literal|'\322'
block|,
literal|'\323'
block|,
literal|'\324'
block|,
literal|'\325'
block|,
literal|'\326'
block|,
literal|'\327'
block|,
literal|'\330'
block|,
literal|'\331'
block|,
literal|'\332'
block|,
literal|'\333'
block|,
literal|'\334'
block|,
literal|'\335'
block|,
literal|'\336'
block|,
literal|'\337'
block|,
literal|'\340'
block|,
literal|'\341'
block|,
literal|'\342'
block|,
literal|'\343'
block|,
literal|'\344'
block|,
literal|'\345'
block|,
literal|'\346'
block|,
literal|'\347'
block|,
literal|'\350'
block|,
literal|'\351'
block|,
literal|'\352'
block|,
literal|'\353'
block|,
literal|'\354'
block|,
literal|'\355'
block|,
literal|'\356'
block|,
literal|'\357'
block|,
literal|'\360'
block|,
literal|'\361'
block|,
literal|'\362'
block|,
literal|'\363'
block|,
literal|'\364'
block|,
literal|'\365'
block|,
literal|'\366'
block|,
literal|'\367'
block|,
literal|'\370'
block|,
literal|'\371'
block|,
literal|'\372'
block|,
literal|'\373'
block|,
literal|'\374'
block|,
literal|'\375'
block|,
literal|'\376'
block|,
literal|'\377'
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"You lose. You will need a translation table for your character set."
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This table maps node types to strings for debugging.  * KEEP IN SYNC WITH awk.h!!!!  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nodetypes
index|[]
init|=
block|{
literal|"Node_illegal"
block|,
literal|"Node_times"
block|,
literal|"Node_quotient"
block|,
literal|"Node_mod"
block|,
literal|"Node_plus"
block|,
literal|"Node_minus"
block|,
literal|"Node_cond_pair"
block|,
literal|"Node_subscript"
block|,
literal|"Node_concat"
block|,
literal|"Node_exp"
block|,
literal|"Node_preincrement"
block|,
literal|"Node_predecrement"
block|,
literal|"Node_postincrement"
block|,
literal|"Node_postdecrement"
block|,
literal|"Node_unary_minus"
block|,
literal|"Node_field_spec"
block|,
literal|"Node_assign"
block|,
literal|"Node_assign_times"
block|,
literal|"Node_assign_quotient"
block|,
literal|"Node_assign_mod"
block|,
literal|"Node_assign_plus"
block|,
literal|"Node_assign_minus"
block|,
literal|"Node_assign_exp"
block|,
literal|"Node_and"
block|,
literal|"Node_or"
block|,
literal|"Node_equal"
block|,
literal|"Node_notequal"
block|,
literal|"Node_less"
block|,
literal|"Node_greater"
block|,
literal|"Node_leq"
block|,
literal|"Node_geq"
block|,
literal|"Node_match"
block|,
literal|"Node_nomatch"
block|,
literal|"Node_not"
block|,
literal|"Node_rule_list"
block|,
literal|"Node_rule_node"
block|,
literal|"Node_statement_list"
block|,
literal|"Node_if_branches"
block|,
literal|"Node_expression_list"
block|,
literal|"Node_param_list"
block|,
literal|"Node_K_if"
block|,
literal|"Node_K_while"
block|,
literal|"Node_K_for"
block|,
literal|"Node_K_arrayfor"
block|,
literal|"Node_K_break"
block|,
literal|"Node_K_continue"
block|,
literal|"Node_K_print"
block|,
literal|"Node_K_printf"
block|,
literal|"Node_K_next"
block|,
literal|"Node_K_exit"
block|,
literal|"Node_K_do"
block|,
literal|"Node_K_return"
block|,
literal|"Node_K_delete"
block|,
literal|"Node_K_getline"
block|,
literal|"Node_K_function"
block|,
literal|"Node_K_nextfile"
block|,
literal|"Node_redirect_output"
block|,
literal|"Node_redirect_append"
block|,
literal|"Node_redirect_pipe"
block|,
literal|"Node_redirect_pipein"
block|,
literal|"Node_redirect_input"
block|,
literal|"Node_var"
block|,
literal|"Node_var_array"
block|,
literal|"Node_val"
block|,
literal|"Node_builtin"
block|,
literal|"Node_line_range"
block|,
literal|"Node_in_array"
block|,
literal|"Node_func"
block|,
literal|"Node_func_call"
block|,
literal|"Node_cond_exp"
block|,
literal|"Node_regex"
block|,
literal|"Node_hashnode"
block|,
literal|"Node_ahash"
block|,
literal|"Node_NF"
block|,
literal|"Node_NR"
block|,
literal|"Node_FNR"
block|,
literal|"Node_FS"
block|,
literal|"Node_RS"
block|,
literal|"Node_FIELDWIDTHS"
block|,
literal|"Node_IGNORECASE"
block|,
literal|"Node_OFS"
block|,
literal|"Node_ORS"
block|,
literal|"Node_OFMT"
block|,
literal|"Node_CONVFMT"
block|,
literal|"Node_final"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|nodetype2str
parameter_list|(
name|type
parameter_list|)
name|NODETYPE
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|>=
name|Node_illegal
operator|&&
name|type
operator|<=
name|Node_final
condition|)
return|return
name|nodetypes
index|[
operator|(
name|int
operator|)
name|type
index|]
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unknown nodetype %d"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* flags2str --- make a flags value readable */
end_comment

begin_function
name|char
modifier|*
name|flags2str
parameter_list|(
name|flagval
parameter_list|)
name|int
name|flagval
decl_stmt|;
block|{
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|flagval
operator|&
name|MALLOC
condition|)
block|{
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"MALLOC"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|TEMP
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"TEMP"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|PERM
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"PERM"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|STRING
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"STRING"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|STR
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"STR"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|NUM
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"NUM"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|NUMBER
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"NUMBER"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|MAYBE_NUM
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"MAYBE_NUM"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|ARRAYMAXED
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"ARRAYMAXED"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|SCALAR
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"SCALAR"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|FUNC
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"FUNC"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagval
operator|&
name|FIELD
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|buffer
condition|)
operator|*
name|sp
operator|++
operator|=
literal|'|'
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
literal|"FIELD"
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*  * interpret:  * Tree is a bunch of rules to run. Returns zero if it hit an exit()  * statement   */
end_comment

begin_function
name|int
name|interpret
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
specifier|volatile
name|tree
decl_stmt|;
block|{
name|jmp_buf
specifier|volatile
name|loop_tag_stack
decl_stmt|;
comment|/* shallow binding stack for loop_tag */
specifier|static
name|jmp_buf
name|rule_tag
decl_stmt|;
comment|/* tag the rule currently being run, for NEXT 				  * and EXIT statements.  It is static because 				  * there are no nested rules */
specifier|register
name|NODE
modifier|*
specifier|volatile
name|t
init|=
name|NULL
decl_stmt|;
comment|/* temporary */
name|NODE
modifier|*
modifier|*
specifier|volatile
name|lhs
decl_stmt|;
comment|/* lhs == Left Hand Side for assigns, etc */
name|NODE
modifier|*
specifier|volatile
name|stable_tree
decl_stmt|;
name|int
specifier|volatile
name|traverse
init|=
name|TRUE
decl_stmt|;
comment|/* True => loop thru tree (Node_rule_list) */
comment|/* avoid false source indications */
name|source
operator|=
name|NULL
expr_stmt|;
name|sourceline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_rule_node
case|:
name|traverse
operator|=
name|FALSE
expr_stmt|;
comment|/* False => one for-loop iteration only */
comment|/* FALL THROUGH */
case|case
name|Node_rule_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
block|{
if|if
condition|(
name|traverse
condition|)
name|tree
operator|=
name|t
operator|->
name|lnode
expr_stmt|;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|rule_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
comment|/* test pattern, if any */
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
operator|||
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* NEXT statement */
return|return
literal|1
return|;
case|case
name|TAG_BREAK
case|:
return|return
literal|0
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|traverse
condition|)
comment|/* case Node_rule_node */
break|break;
comment|/* don't loop */
block|}
break|break;
case|case
name|Node_statement_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|t
operator|->
name|lnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_if
case|:
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_while
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
while|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_do
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
condition|)
do|;
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_for
case|:
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|tree
operator|->
name|forloop
operator|->
name|init
argument_list|)
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
while|while
condition|(
name|eval_condition
argument_list|(
name|stable_tree
operator|->
name|forloop
operator|->
name|cond
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* normal non-jump */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|TAG_CONTINUE
case|:
comment|/* continue statement */
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|forloop
operator|->
name|incr
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_BREAK
case|:
comment|/* break statement */
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_arrayfor
case|:
block|{
specifier|volatile
name|struct
name|search
name|l
decl_stmt|;
comment|/* For array_for */
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|hakvar
value|forloop->init
define|#
directive|define
name|arrvar
value|forloop->incr
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|hakvar
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree
operator|->
name|arrvar
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|t
operator|=
name|stack_ptr
index|[
name|t
operator|->
name|param_cnt
index|]
expr_stmt|;
name|stable_tree
operator|=
name|tree
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|SCALAR
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"attempt to use scalar as array"
argument_list|)
expr_stmt|;
for|for
control|(
name|assoc_scan
argument_list|(
name|t
argument_list|,
operator|(
expr|struct
name|search
operator|*
operator|)
operator|&
name|l
argument_list|)
init|;
name|l
operator|.
name|retval
condition|;
name|assoc_next
argument_list|(
operator|(
expr|struct
name|search
operator|*
operator|)
operator|&
name|l
argument_list|)
control|)
block|{
name|unref
argument_list|(
operator|*
operator|(
operator|(
name|NODE
operator|*
operator|*
operator|)
name|lhs
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|dupnode
argument_list|(
name|l
operator|.
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|setjmp
argument_list|(
name|loop_tag
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|stable_tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
case|case
name|TAG_CONTINUE
case|:
break|break;
case|case
name|TAG_BREAK
case|:
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|loop_tag_valid
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node_K_break
case|:
if|if
condition|(
operator|!
name|loop_tag_valid
condition|)
block|{
comment|/* 			 * Old AT&T nawk treats break outside of loops like 			 * next. New ones catch it at parse time. Allow it if 			 * do_traditional is on, and complain if lint. 			 */
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warning
argument_list|(
literal|"use of `break' outside a loop is not portable"
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_traditional
operator|||
name|do_posix
condition|)
name|fatal
argument_list|(
literal|"use of `break' outside a loop is not allowed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_function
argument_list|()
condition|)
name|pop_fcall_stack
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
block|}
else|else
name|longjmp
argument_list|(
name|loop_tag
argument_list|,
name|TAG_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_continue
case|:
if|if
condition|(
operator|!
name|loop_tag_valid
condition|)
block|{
comment|/* 			 * Old AT&T nawk treats continue outside of loops like 			 * next. New ones catch it at parse time. Allow it if 			 * do_traditional is on, and complain if lint. 			 */
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warning
argument_list|(
literal|"use of `continue' outside a loop is not portable"
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_traditional
operator|||
name|do_posix
condition|)
name|fatal
argument_list|(
literal|"use of `continue' outside a loop is not allowed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_function
argument_list|()
condition|)
name|pop_fcall_stack
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
block|}
else|else
name|longjmp
argument_list|(
name|loop_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_print
case|:
name|do_print
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_printf
case|:
name|do_printf
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_delete
case|:
name|do_delete
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_next
case|:
if|if
condition|(
name|in_function
argument_list|()
condition|)
name|pop_fcall_stack
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_CONTINUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_nextfile
case|:
if|if
condition|(
name|in_function
argument_list|()
condition|)
name|pop_fcall_stack
argument_list|()
expr_stmt|;
name|do_nextfile
argument_list|()
expr_stmt|;
break|break;
case|case
name|Node_K_exit
case|:
comment|/* 		 * In A,K,&W, p. 49, it says that an exit statement "... 		 * causes the program to behave as if the end of input had 		 * occurred; no more input is read, and the END actions, if 		 * any are executed." This implies that the rest of the rules 		 * are not done. So we immediately break out of the main loop. 		 */
name|exiting
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|exit_val
operator|=
operator|(
name|int
operator|)
name|force_number
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|rule_tag
argument_list|,
name|TAG_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_return
case|:
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|ret_node
operator|=
name|dupnode
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|func_tag
argument_list|,
name|TAG_RETURN
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Appears to be an expression statement.  Throw away the 		 * value.  		 */
if|if
condition|(
name|do_lint
operator|&&
name|tree
operator|->
name|type
operator|==
name|Node_var
condition|)
name|warning
argument_list|(
literal|"statement has no effect"
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* r_tree_eval --- evaluate a subtree */
end_comment

begin_function
name|NODE
modifier|*
name|r_tree_eval
parameter_list|(
name|tree
parameter_list|,
name|iscond
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
name|int
name|iscond
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
comment|/* return value& temporary subtrees */
specifier|register
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
specifier|register
name|int
name|di
decl_stmt|;
name|AWKNUM
name|x
decl_stmt|,
name|x1
decl_stmt|,
name|x2
decl_stmt|;
name|long
name|lx
decl_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
name|long
name|lx2
decl_stmt|;
endif|#
directive|endif
name|char
name|namebuf
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|Nnull_string
return|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_val
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
return|return
name|tree
return|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_var
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|var_value
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
return|return
name|tree
operator|->
name|var_value
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_param_list
condition|)
block|{
name|int
name|paramnum
init|=
name|tree
operator|->
name|param_cnt
operator|+
literal|1
decl_stmt|;
name|tree
operator|=
name|stack_ptr
index|[
name|tree
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|Nnull_string
return|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"parameter #%d"
argument_list|,
name|paramnum
argument_list|)
expr_stmt|;
name|tree
operator|->
name|vname
operator|=
name|namebuf
expr_stmt|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_var
case|:
return|return
name|tree
operator|->
name|var_value
return|;
case|case
name|Node_and
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
operator|&&
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Node_or
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
operator|||
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Node_not
case|:
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|!
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
return|;
comment|/* Builtins */
case|case
name|Node_builtin
case|:
return|return
call|(
modifier|*
name|tree
operator|->
name|proc
call|)
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
return|;
case|case
name|Node_K_getline
case|:
return|return
operator|(
name|do_getline
argument_list|(
name|tree
argument_list|)
operator|)
return|;
case|case
name|Node_in_array
case|:
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|in_array
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
argument_list|)
return|;
case|case
name|Node_func_call
case|:
return|return
name|func_call
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
name|tree
operator|->
name|lnode
argument_list|)
return|;
comment|/* unary operations */
case|case
name|Node_NR
case|:
case|case
name|Node_FNR
case|:
case|case
name|Node_NF
case|:
case|case
name|Node_FIELDWIDTHS
case|:
case|case
name|Node_FS
case|:
case|case
name|Node_RS
case|:
case|case
name|Node_field_spec
case|:
case|case
name|Node_subscript
case|:
case|case
name|Node_IGNORECASE
case|:
case|case
name|Node_OFS
case|:
case|case
name|Node_ORS
case|:
case|case
name|Node_OFMT
case|:
case|case
name|Node_CONVFMT
case|:
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
argument_list|,
operator|(
name|Func_ptr
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|*
name|lhs
return|;
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
case|case
name|Node_unary_minus
case|:
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x
argument_list|)
return|;
case|case
name|Node_cond_exp
case|:
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
condition|)
return|return
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
return|;
return|return
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
return|;
case|case
name|Node_match
case|:
case|case
name|Node_nomatch
case|:
case|case
name|Node_regex
case|:
return|return
name|match_op
argument_list|(
name|tree
argument_list|)
return|;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
literal|"function `%s' called with space between name and (,\n%s"
argument_list|,
name|tree
operator|->
name|lnode
operator|->
name|param
argument_list|,
literal|"or used in other expression context"
argument_list|)
expr_stmt|;
comment|/* assignments */
case|case
name|Node_assign
case|:
block|{
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|iscond
operator|&&
name|do_lint
condition|)
name|warning
argument_list|(
literal|"assignment used in conditional context"
argument_list|)
expr_stmt|;
name|r
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
operator|*
name|lhs
condition|)
block|{
name|NODE
modifier|*
name|save
decl_stmt|;
name|save
operator|=
operator|*
name|lhs
expr_stmt|;
operator|*
name|lhs
operator|=
name|dupnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lnode
operator|->
name|flags
operator||=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
block|}
case|case
name|Node_concat
case|:
block|{
name|NODE
modifier|*
modifier|*
name|treelist
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|strlist
decl_stmt|;
name|NODE
modifier|*
name|save_tree
decl_stmt|;
specifier|register
name|NODE
modifier|*
modifier|*
name|treep
decl_stmt|;
specifier|register
name|NODE
modifier|*
modifier|*
name|strp
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 		 * This is an efficiency hack for multiple adjacent string 		 * concatenations, to avoid recursion and string copies. 		 * 		 * Node_concat trees grow downward to the left, so 		 * descend to lowest (first) node, accumulating nodes 		 * to evaluate to strings as we go. 		 */
comment|/* 		 * But first, no arbitrary limits. Count the number of 		 * nodes and malloc the treelist and strlist arrays. 		 * There will be count + 1 items to concatenate. We 		 * also leave room for an extra pointer at the end to 		 * use as a sentinel.  Thus, start count at 2. 		 */
name|save_tree
operator|=
name|tree
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|2
init|;
name|tree
operator|&&
name|tree
operator|->
name|type
operator|==
name|Node_concat
condition|;
name|tree
operator|=
name|tree
operator|->
name|lnode
control|)
name|count
operator|++
expr_stmt|;
name|tree
operator|=
name|save_tree
expr_stmt|;
name|emalloc
argument_list|(
name|treelist
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
operator|*
name|count
argument_list|,
literal|"tree_eval"
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|strlist
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
operator|*
name|count
argument_list|,
literal|"tree_eval"
argument_list|)
expr_stmt|;
comment|/* Now, here we go. */
name|treep
operator|=
name|treelist
expr_stmt|;
while|while
condition|(
name|tree
operator|&&
name|tree
operator|->
name|type
operator|==
name|Node_concat
condition|)
block|{
operator|*
name|treep
operator|++
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
block|}
operator|*
name|treep
operator|=
name|tree
expr_stmt|;
comment|/* 		 * Now, evaluate to strings in LIFO order, accumulating 		 * the string length, so we can do a single malloc at the 		 * end. 		 */
name|strp
operator|=
name|strlist
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|treep
operator|>=
name|treelist
condition|)
block|{
operator|*
name|strp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
operator|*
name|treep
operator|--
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
operator|*
name|strp
operator|=
name|NULL
expr_stmt|;
name|emalloc
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
literal|"tree_eval"
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
name|str
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* for good measure */
name|dest
operator|=
name|str
expr_stmt|;
name|strp
operator|=
name|strlist
expr_stmt|;
while|while
condition|(
operator|*
name|strp
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
operator|*
name|strp
operator|)
operator|->
name|stptr
argument_list|,
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|dest
operator|+=
operator|(
operator|*
name|strp
operator|)
operator|->
name|stlen
expr_stmt|;
name|free_temp
argument_list|(
operator|*
name|strp
argument_list|)
expr_stmt|;
name|strp
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|make_str_node
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|ALREADY_MALLOCED
argument_list|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
name|free
argument_list|(
name|strlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|treelist
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
comment|/* other assignment types are easier because they are numeric */
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
case|case
name|Node_assign_exp
case|:
case|case
name|Node_assign_times
case|:
case|case
name|Node_assign_quotient
case|:
case|case
name|Node_assign_mod
case|:
case|case
name|Node_assign_plus
case|:
case|case
name|Node_assign_minus
case|:
return|return
name|op_assign
argument_list|(
name|tree
argument_list|)
return|;
default|default:
break|break;
comment|/* handled below */
block|}
comment|/* evaluate subtrees in order to do binary operation, then keep going */
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_geq
case|:
case|case
name|Node_leq
case|:
case|case
name|Node_greater
case|:
case|case
name|Node_less
case|:
case|case
name|Node_notequal
case|:
case|case
name|Node_equal
case|:
name|di
operator|=
name|cmp_nodes
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_equal
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|==
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_notequal
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|!=
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_less
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|<
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_greater
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|>
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_leq
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|<=
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|Node_geq
case|:
return|return
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|di
operator|>=
literal|0
argument_list|)
argument_list|)
return|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
break|break;
comment|/* handled below */
block|}
name|x1
operator|=
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|x2
operator|=
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_exp
case|:
if|if
condition|(
operator|(
name|lx
operator|=
name|x2
operator|)
operator|==
name|x2
operator|&&
name|lx
operator|>=
literal|0
condition|)
block|{
comment|/* integer exponent */
if|if
condition|(
name|lx
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lx
operator|==
literal|1
condition|)
name|x
operator|=
name|x1
expr_stmt|;
else|else
block|{
comment|/* doing it this way should be more precise */
for|for
control|(
name|x
operator|=
name|x1
init|;
operator|--
name|lx
condition|;
control|)
name|x
operator|*=
name|x1
expr_stmt|;
block|}
block|}
else|else
name|x
operator|=
name|pow
argument_list|(
operator|(
name|double
operator|)
name|x1
argument_list|,
operator|(
name|double
operator|)
name|x2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x
argument_list|)
return|;
case|case
name|Node_times
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|*
name|x2
argument_list|)
return|;
case|case
name|Node_quotient
case|:
if|if
condition|(
name|x2
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* special case for integer division, put in for Cray */
name|lx2
operator|=
name|x2
expr_stmt|;
if|if
condition|(
name|lx2
operator|==
literal|0
condition|)
return|return
name|tmp_number
argument_list|(
name|x1
operator|/
name|x2
argument_list|)
return|;
name|lx
operator|=
operator|(
name|long
operator|)
name|x1
operator|/
name|lx2
expr_stmt|;
if|if
condition|(
name|lx
operator|*
name|x2
operator|==
name|x1
condition|)
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|lx
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|tmp_number
argument_list|(
name|x1
operator|/
name|x2
argument_list|)
return|;
case|case
name|Node_mod
case|:
if|if
condition|(
name|x2
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in mod"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FMOD
return|return
name|tmp_number
argument_list|(
name|fmod
argument_list|(
name|x1
argument_list|,
name|x2
argument_list|)
argument_list|)
return|;
else|#
directive|else
comment|/* ! HAVE_FMOD */
operator|(
name|void
operator|)
name|modf
argument_list|(
name|x1
operator|/
name|x2
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|x1
operator|-
name|x
operator|*
name|x2
argument_list|)
return|;
endif|#
directive|endif
comment|/* ! HAVE_FMOD */
case|case
name|Node_plus
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|+
name|x2
argument_list|)
return|;
case|case
name|Node_minus
case|:
return|return
name|tmp_number
argument_list|(
name|x1
operator|-
name|x2
argument_list|)
return|;
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
default|default:
name|fatal
argument_list|(
literal|"illegal type (%s) in tree_eval"
argument_list|,
name|nodetype2str
argument_list|(
name|tree
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* eval_condition --- is TREE true or false? Returns 0==false, non-zero==true */
end_comment

begin_function
specifier|static
name|int
name|eval_condition
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
comment|/* Null trees are the easiest kinds */
return|return
name|TRUE
return|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_line_range
condition|)
block|{
comment|/* 		 * Node_line_range is kind of like Node_match, EXCEPT: the 		 * lnode field (more properly, the condpair field) is a node 		 * of a Node_cond_pair; whether we evaluate the lnode of that 		 * node or the rnode depends on the triggered word.  More 		 * precisely:  if we are not yet triggered, we tree_eval the 		 * lnode; if that returns true, we set the triggered word.  		 * If we are triggered (not ELSE IF, note), we tree_eval the 		 * rnode, clear triggered if it succeeds, and perform our 		 * action (regardless of success or failure).  We want to be 		 * able to begin and end on a single input record, so this 		 * isn't an ELSE IF, as noted above. 		 */
if|if
condition|(
operator|!
name|tree
operator|->
name|triggered
condition|)
if|if
condition|(
operator|!
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|lnode
argument_list|)
condition|)
return|return
name|FALSE
return|;
else|else
name|tree
operator|->
name|triggered
operator|=
name|TRUE
expr_stmt|;
comment|/* Else we are triggered */
if|if
condition|(
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|rnode
argument_list|)
condition|)
name|tree
operator|->
name|triggered
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* 	 * Could just be J.random expression. in which case, null and 0 are 	 * false, anything else is true  	 */
name|t1
operator|=
name|m_tree_eval
argument_list|(
name|tree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|NUMBER
condition|)
name|ret
operator|=
operator|(
name|t1
operator|->
name|numbr
operator|!=
literal|0.0
operator|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|t1
operator|->
name|stlen
operator|!=
literal|0
operator|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* cmp_nodes --- compare two nodes, returning negative, 0, positive */
end_comment

begin_function
name|int
name|cmp_nodes
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|;
specifier|register
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
name|int
name|ldiff
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t1
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|->
name|flags
operator|&
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t1
operator|->
name|flags
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|t2
operator|->
name|flags
operator|&
name|NUMBER
operator|)
condition|)
block|{
if|if
condition|(
name|t1
operator|->
name|numbr
operator|==
name|t2
operator|->
name|numbr
condition|)
return|return
literal|0
return|;
comment|/* don't subtract, in case one or both are infinite */
elseif|else
if|if
condition|(
name|t1
operator|->
name|numbr
operator|<
name|t2
operator|->
name|numbr
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|len1
operator|=
name|t1
operator|->
name|stlen
expr_stmt|;
name|len2
operator|=
name|t2
operator|->
name|stlen
expr_stmt|;
name|ldiff
operator|=
name|len1
operator|-
name|len2
expr_stmt|;
if|if
condition|(
name|len1
operator|==
literal|0
operator|||
name|len2
operator|==
literal|0
condition|)
return|return
name|ldiff
return|;
name|l
operator|=
operator|(
name|ldiff
operator|<=
literal|0
condition|?
name|len1
else|:
name|len2
operator|)
expr_stmt|;
if|if
condition|(
name|IGNORECASE
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|cp1
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t1
operator|->
name|stptr
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp2
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t2
operator|->
name|stptr
decl_stmt|;
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|l
operator|--
operator|>
literal|0
operator|&&
name|ret
operator|==
literal|0
condition|;
name|cp1
operator|++
operator|,
name|cp2
operator|++
control|)
name|ret
operator|=
name|casetable
index|[
operator|*
name|cp1
index|]
operator|-
name|casetable
index|[
operator|*
name|cp2
index|]
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|memcmp
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t2
operator|->
name|stptr
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|==
literal|0
condition|?
name|ldiff
else|:
name|ret
operator|)
return|;
block|}
end_block

begin_comment
comment|/* op_assign --- do +=, -=, etc. */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|op_assign
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|AWKNUM
name|rval
decl_stmt|,
name|lval
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
name|AWKNUM
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|long
name|ltemp
decl_stmt|;
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|lval
operator|=
name|force_number
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
comment|/* 	 * Can't unref *lhs until we know the type; doing so 	 * too early breaks   x += x   sorts of things. 	 */
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
operator|(
name|tree
operator|->
name|type
operator|==
name|Node_preincrement
condition|?
literal|1.0
else|:
operator|-
literal|1.0
operator|)
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lnode
operator|->
name|flags
operator||=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
operator|(
name|tree
operator|->
name|type
operator|==
name|Node_postincrement
condition|?
literal|1.0
else|:
operator|-
literal|1.0
operator|)
argument_list|)
expr_stmt|;
name|tree
operator|->
name|lnode
operator|->
name|flags
operator||=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
name|tmp_number
argument_list|(
name|lval
argument_list|)
return|;
default|default:
break|break;
comment|/* handled below */
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|rval
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* 	 * Do this again; the lhs and the rhs could both be fields. 	 * Accessing the rhs could cause the lhs to have moved around. 	 * (Yet another special case. Gack.) 	 */
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_assign_exp
case|:
if|if
condition|(
operator|(
name|ltemp
operator|=
name|rval
operator|)
operator|==
name|rval
condition|)
block|{
comment|/* integer exponent */
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltemp
operator|==
literal|1
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* doing it this way should be more precise */
for|for
control|(
name|t1
operator|=
name|t2
operator|=
name|lval
init|;
operator|--
name|ltemp
condition|;
control|)
name|t1
operator|*=
name|t2
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
name|lval
argument_list|,
operator|(
name|double
operator|)
name|rval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_times
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|*
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_quotient
case|:
if|if
condition|(
name|rval
operator|==
operator|(
name|AWKNUM
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in /="
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* special case for integer division, put in for Cray */
name|ltemp
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|ltemp
operator|==
literal|0
condition|)
block|{
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|/
name|rval
argument_list|)
expr_stmt|;
break|break;
block|}
name|ltemp
operator|=
operator|(
name|long
operator|)
name|lval
operator|/
name|ltemp
expr_stmt|;
if|if
condition|(
name|ltemp
operator|*
name|lval
operator|==
name|rval
condition|)
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ltemp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _CRAY */
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|/
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_mod
case|:
if|if
condition|(
name|rval
operator|==
operator|(
name|AWKNUM
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"division by zero attempted in %%="
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FMOD
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|fmod
argument_list|(
name|lval
argument_list|,
name|rval
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_FMOD */
operator|(
name|void
operator|)
name|modf
argument_list|(
name|lval
operator|/
name|rval
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|lval
operator|-
name|rval
operator|*
name|t1
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_FMOD */
break|break;
case|case
name|Node_assign_plus
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|+
name|rval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_minus
case|:
operator|*
name|lhs
operator|=
name|make_number
argument_list|(
name|lval
operator|-
name|rval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
name|tree
operator|->
name|lnode
operator|->
name|flags
operator||=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|after_assign
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
return|return
operator|*
name|lhs
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|fcall
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
name|NODE
modifier|*
name|arglist
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|prevstack
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|stack
decl_stmt|;
block|}
modifier|*
name|fcall_list
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|long
name|fcall_list_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|curfcall
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in_function --- return true/false if we need to unwind awk functions */
end_comment

begin_function
specifier|static
name|int
name|in_function
parameter_list|()
block|{
return|return
operator|(
name|curfcall
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* pop_fcall --- pop off a single function call */
end_comment

begin_function
specifier|static
name|void
name|pop_fcall
parameter_list|()
block|{
name|NODE
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|sp
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|argp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|fcall
modifier|*
name|f
decl_stmt|;
name|assert
argument_list|(
name|curfcall
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|f
operator|=
operator|&
name|fcall_list
index|[
name|curfcall
index|]
expr_stmt|;
name|stack_ptr
operator|=
name|f
operator|->
name|prevstack
expr_stmt|;
comment|/* 	 * here, we pop each parameter and check whether 	 * it was an array.  If so, and if the arg. passed in was 	 * a simple variable, then the value should be copied back. 	 * This achieves "call-by-reference" for arrays. 	 */
name|sp
operator|=
name|f
operator|->
name|stack
expr_stmt|;
name|count
operator|=
name|f
operator|->
name|count
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|f
operator|->
name|arglist
init|;
name|count
operator|>
literal|0
operator|&&
name|argp
operator|!=
name|NULL
condition|;
name|argp
operator|=
name|argp
operator|->
name|rnode
control|)
block|{
name|arg
operator|=
name|argp
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|arg
operator|=
name|stack_ptr
index|[
name|arg
operator|->
name|param_cnt
index|]
expr_stmt|;
name|n
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|type
operator|==
name|Node_var
operator|||
name|arg
operator|->
name|type
operator|==
name|Node_var_array
operator|)
operator|&&
name|n
operator|->
name|type
operator|==
name|Node_var_array
condition|)
block|{
comment|/* should we free arg->var_value ? */
name|arg
operator|->
name|var_array
operator|=
name|n
operator|->
name|var_array
expr_stmt|;
name|arg
operator|->
name|type
operator|=
name|Node_var_array
expr_stmt|;
name|arg
operator|->
name|array_size
operator|=
name|n
operator|->
name|array_size
expr_stmt|;
name|arg
operator|->
name|table_size
operator|=
name|n
operator|->
name|table_size
expr_stmt|;
name|arg
operator|->
name|flags
operator|=
name|n
operator|->
name|flags
expr_stmt|;
block|}
comment|/* n->lnode overlays the array size, don't unref it if array */
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|Node_var_array
condition|)
name|unref
argument_list|(
name|n
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* if n is a local array, all the elements should be freed */
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_var_array
condition|)
name|assoc_clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|n
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|freenode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|stack
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|stack
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fcall
argument_list|)
argument_list|)
expr_stmt|;
name|curfcall
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pop_fcall_stack --- pop off all function args, don't leak memory */
end_comment

begin_function
specifier|static
name|void
name|pop_fcall_stack
parameter_list|()
block|{
while|while
condition|(
name|curfcall
operator|>=
literal|0
condition|)
name|pop_fcall
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* push_args --- push function arguments onto the stack */
end_comment

begin_function
specifier|static
name|void
name|push_args
parameter_list|(
name|count
parameter_list|,
name|arglist
parameter_list|,
name|oldstack
parameter_list|,
name|func_name
parameter_list|)
name|int
name|count
decl_stmt|;
name|NODE
modifier|*
name|arglist
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|oldstack
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
block|{
name|struct
name|fcall
modifier|*
name|f
decl_stmt|;
name|NODE
modifier|*
name|arg
decl_stmt|,
modifier|*
name|argp
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
modifier|*
name|sp
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|fcall_list_size
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|emalloc
argument_list|(
name|fcall_list
argument_list|,
expr|struct
name|fcall
operator|*
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fcall
argument_list|)
argument_list|,
literal|"push_args"
argument_list|)
expr_stmt|;
name|fcall_list_size
operator|=
literal|10
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|curfcall
operator|>=
name|fcall_list_size
condition|)
block|{
name|fcall_list_size
operator|*=
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|fcall_list
argument_list|,
expr|struct
name|fcall
operator|*
argument_list|,
name|fcall_list_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fcall
argument_list|)
argument_list|,
literal|"push_args"
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
operator|&
name|fcall_list
index|[
name|curfcall
index|]
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fcall
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|emalloc
argument_list|(
name|f
operator|->
name|stack
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"func_call"
argument_list|)
expr_stmt|;
name|f
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|f
operator|->
name|fname
operator|=
name|func_name
expr_stmt|;
comment|/* not used, for debugging, just in case */
name|f
operator|->
name|arglist
operator|=
name|arglist
expr_stmt|;
name|f
operator|->
name|prevstack
operator|=
name|oldstack
expr_stmt|;
name|sp
operator|=
name|f
operator|->
name|stack
expr_stmt|;
comment|/* for each calling arg. add NODE * on stack */
for|for
control|(
name|argp
operator|=
name|arglist
init|;
name|count
operator|>
literal|0
operator|&&
name|argp
operator|!=
name|NULL
condition|;
name|argp
operator|=
name|argp
operator|->
name|rnode
control|)
block|{
name|arg
operator|=
name|argp
operator|->
name|lnode
expr_stmt|;
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_var
expr_stmt|;
comment|/* call by reference for arrays; see below also */
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|arg
operator|=
name|f
operator|->
name|prevstack
index|[
name|arg
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|type
operator|==
name|Node_var_array
condition|)
operator|*
name|r
operator|=
operator|*
name|arg
expr_stmt|;
else|else
block|{
name|n
operator|=
name|tree_eval
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|->
name|lnode
operator|=
name|dupnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|r
operator|->
name|rnode
operator|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|flags
operator|&
name|SCALAR
operator|)
operator|!=
literal|0
condition|)
name|r
operator|->
name|flags
operator||=
name|SCALAR
expr_stmt|;
name|free_temp
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|++
operator|=
name|r
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argp
operator|!=
name|NULL
condition|)
comment|/* left over calling args. */
name|warning
argument_list|(
literal|"function `%s' called with more arguments than declared"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
comment|/* add remaining params. on stack with null value */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|getnode
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|Node_var
expr_stmt|;
name|r
operator|->
name|lnode
operator|=
name|Nnull_string
expr_stmt|;
name|r
operator|->
name|flags
operator|&=
operator|~
name|SCALAR
expr_stmt|;
name|r
operator|->
name|rnode
operator|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|r
expr_stmt|;
block|}
comment|/* 	 * We have to reassign f. Why, you may ask?  It is possible that 	 * other functions were called during the course of tree_eval()-ing 	 * the arguments to this function. As a result of that, fcall_list 	 * may have been realloc()'ed, with the result that f is now 	 * pointing into free()'d space.  This was a nasty one to track down. 	 */
name|f
operator|=
operator|&
name|fcall_list
index|[
name|curfcall
index|]
expr_stmt|;
name|stack_ptr
operator|=
name|f
operator|->
name|stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* func_call --- call a function, call by reference for arrays */
end_comment

begin_decl_stmt
name|NODE
modifier|*
modifier|*
name|stack_ptr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|NODE
modifier|*
name|func_call
parameter_list|(
name|name
parameter_list|,
name|arg_list
parameter_list|)
name|NODE
modifier|*
name|name
decl_stmt|;
comment|/* name is a Node_val giving function name */
name|NODE
modifier|*
name|arg_list
decl_stmt|;
comment|/* Node_expression_list of calling args. */
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|jmp_buf
specifier|volatile
name|func_tag_stack
decl_stmt|;
name|jmp_buf
specifier|volatile
name|loop_tag_stack
decl_stmt|;
name|int
specifier|volatile
name|save_loop_tag_valid
init|=
name|FALSE
decl_stmt|;
name|NODE
modifier|*
name|save_ret_node
decl_stmt|;
specifier|extern
name|NODE
modifier|*
name|ret_node
decl_stmt|;
comment|/* retrieve function definition node */
name|f
operator|=
name|lookup
argument_list|(
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|type
operator|!=
name|Node_func
condition|)
name|fatal
argument_list|(
literal|"function `%s' not defined"
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNC_TRACE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function %s called\n"
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|push_args
argument_list|(
name|f
operator|->
name|lnode
operator|->
name|param_cnt
argument_list|,
name|arg_list
argument_list|,
name|stack_ptr
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* 	 * Execute function body, saving context, as a return statement 	 * will longjmp back here. 	 * 	 * Have to save and restore the loop_tag stuff so that a return 	 * inside a loop in a function body doesn't scrog any loops going 	 * on in the main program.  We save the necessary info in variables 	 * local to this function so that function nesting works OK. 	 * We also only bother to save the loop stuff if we're in a loop 	 * when the function is called. 	 */
if|if
condition|(
name|loop_tag_valid
condition|)
block|{
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|save_loop_tag_valid
operator|=
operator|(
specifier|volatile
name|int
operator|)
name|loop_tag_valid
expr_stmt|;
name|PUSH_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|loop_tag_valid
operator|=
name|FALSE
expr_stmt|;
block|}
name|PUSH_BINDING
argument_list|(
name|func_tag_stack
argument_list|,
name|func_tag
argument_list|,
name|func_tag_valid
argument_list|)
expr_stmt|;
name|save_ret_node
operator|=
name|ret_node
expr_stmt|;
name|ret_node
operator|=
name|Nnull_string
expr_stmt|;
comment|/* default return value */
if|if
condition|(
name|setjmp
argument_list|(
name|func_tag
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|interpret
argument_list|(
name|f
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret_node
expr_stmt|;
name|ret_node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|save_ret_node
expr_stmt|;
name|RESTORE_BINDING
argument_list|(
name|func_tag_stack
argument_list|,
name|func_tag
argument_list|,
name|func_tag_valid
argument_list|)
expr_stmt|;
name|pop_fcall
argument_list|()
expr_stmt|;
comment|/* Restore the loop_tag stuff if necessary. */
if|if
condition|(
name|save_loop_tag_valid
condition|)
block|{
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|loop_tag_valid
operator|=
operator|(
name|int
operator|)
name|save_loop_tag_valid
expr_stmt|;
name|RESTORE_BINDING
argument_list|(
name|loop_tag_stack
argument_list|,
name|loop_tag
argument_list|,
name|junk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|->
name|flags
operator|&
name|PERM
operator|)
operator|==
literal|0
condition|)
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * r_get_lhs:  * This returns a POINTER to a node pointer. get_lhs(ptr) is the current  * value of the var, or where to store the var's new value   */
end_comment

begin_function
name|NODE
modifier|*
modifier|*
name|r_get_lhs
parameter_list|(
name|ptr
parameter_list|,
name|assign
parameter_list|)
specifier|register
name|NODE
modifier|*
name|ptr
decl_stmt|;
name|Func_ptr
modifier|*
name|assign
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
modifier|*
name|aptr
init|=
name|NULL
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|assign
condition|)
operator|*
name|assign
operator|=
name|NULL
expr_stmt|;
comment|/* for safety */
if|if
condition|(
name|ptr
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|ptr
operator|=
name|stack_ptr
index|[
name|ptr
operator|->
name|param_cnt
index|]
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|,
name|ptr
operator|->
name|vname
argument_list|)
expr_stmt|;
case|case
name|Node_var
case|:
name|aptr
operator|=
operator|&
operator|(
name|ptr
operator|->
name|var_value
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ptr
operator|->
name|var_value
operator|->
name|stref
operator|<=
literal|0
condition|)
name|cant_happen
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|Node_FIELDWIDTHS
case|:
name|aptr
operator|=
operator|&
operator|(
name|FIELDWIDTHS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_FIELDWIDTHS
expr_stmt|;
break|break;
case|case
name|Node_RS
case|:
name|aptr
operator|=
operator|&
operator|(
name|RS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_RS
expr_stmt|;
break|break;
case|case
name|Node_FS
case|:
name|aptr
operator|=
operator|&
operator|(
name|FS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_FS
expr_stmt|;
break|break;
case|case
name|Node_FNR
case|:
name|unref
argument_list|(
name|FNR_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|FNR_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|FNR
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|FNR_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_FNR
expr_stmt|;
break|break;
case|case
name|Node_NR
case|:
name|unref
argument_list|(
name|NR_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|NR_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|NR
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|NR_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_NR
expr_stmt|;
break|break;
case|case
name|Node_NF
case|:
if|if
condition|(
name|NF
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|get_field
argument_list|(
name|HUGE
operator|-
literal|1
argument_list|,
name|assign
argument_list|)
expr_stmt|;
comment|/* parse record */
name|unref
argument_list|(
name|NF_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|NF_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|NF
argument_list|)
expr_stmt|;
name|aptr
operator|=
operator|&
operator|(
name|NF_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_NF
expr_stmt|;
break|break;
case|case
name|Node_IGNORECASE
case|:
name|aptr
operator|=
operator|&
operator|(
name|IGNORECASE_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_IGNORECASE
expr_stmt|;
break|break;
case|case
name|Node_OFMT
case|:
name|aptr
operator|=
operator|&
operator|(
name|OFMT_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_OFMT
expr_stmt|;
break|break;
case|case
name|Node_CONVFMT
case|:
name|aptr
operator|=
operator|&
operator|(
name|CONVFMT_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_CONVFMT
expr_stmt|;
break|break;
case|case
name|Node_ORS
case|:
name|aptr
operator|=
operator|&
operator|(
name|ORS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_ORS
expr_stmt|;
break|break;
case|case
name|Node_OFS
case|:
name|aptr
operator|=
operator|&
operator|(
name|OFS_node
operator|->
name|var_value
operator|)
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|set_OFS
expr_stmt|;
break|break;
case|case
name|Node_param_list
case|:
name|aptr
operator|=
operator|&
operator|(
name|stack_ptr
index|[
name|ptr
operator|->
name|param_cnt
index|]
operator|->
name|var_value
operator|)
expr_stmt|;
break|break;
case|case
name|Node_field_spec
case|:
block|{
name|int
name|field_num
decl_stmt|;
name|n
operator|=
name|tree_eval
argument_list|(
name|ptr
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|field_num
operator|=
operator|(
name|int
operator|)
name|force_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_num
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"attempt to access field %d"
argument_list|,
name|field_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_num
operator|==
literal|0
operator|&&
name|field0_valid
condition|)
block|{
comment|/* short circuit */
name|aptr
operator|=
operator|&
name|fields_arr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|reset_record
expr_stmt|;
break|break;
block|}
name|aptr
operator|=
name|get_field
argument_list|(
name|field_num
argument_list|,
name|assign
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|Node_subscript
case|:
name|n
operator|=
name|ptr
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_param_list
condition|)
block|{
name|int
name|i
init|=
name|n
operator|->
name|param_cnt
operator|+
literal|1
decl_stmt|;
name|n
operator|=
name|stack_ptr
index|[
name|n
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|flags
operator|&
name|SCALAR
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"attempt to use scalar parameter %d as an array"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_func
condition|)
block|{
name|fatal
argument_list|(
literal|"attempt to use function `%s' as array"
argument_list|,
name|n
operator|->
name|lnode
operator|->
name|param
argument_list|)
expr_stmt|;
block|}
name|aptr
operator|=
name|assoc_lookup
argument_list|(
name|n
argument_list|,
name|concat_exp
argument_list|(
name|ptr
operator|->
name|rnode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
literal|"`%s' is a function, assignment is not allowed"
argument_list|,
name|ptr
operator|->
name|lnode
operator|->
name|param
argument_list|)
expr_stmt|;
case|case
name|Node_builtin
case|:
name|fatal
argument_list|(
literal|"assignment is not allowed to result of builtin function"
argument_list|)
expr_stmt|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
return|return
name|aptr
return|;
block|}
end_function

begin_comment
comment|/* match_op --- do ~ and !~ */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|match_op
parameter_list|(
name|tree
parameter_list|)
specifier|register
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|t1
decl_stmt|;
specifier|register
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|match
init|=
name|TRUE
decl_stmt|;
name|int
name|kludge_need_start
init|=
name|FALSE
decl_stmt|;
comment|/* FIXME: --- see below */
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_nomatch
condition|)
name|match
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_regex
condition|)
name|t1
operator|=
operator|*
name|get_field
argument_list|(
literal|0
argument_list|,
operator|(
name|Func_ptr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
block|}
name|rp
operator|=
name|re_update
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* 	 * FIXME: 	 * 	 * Any place where research() is called with a last parameter of 	 * FALSE, we need to use the avoid_dfa test. This is the only place 	 * at the moment. 	 * 	 * A new or improved dfa that distinguishes beginning/end of 	 * string from beginning/end of line will allow us to get rid of 	 * this temporary hack. 	 * 	 * The avoid_dfa() function is in re.c; it is not very smart. 	 */
if|if
condition|(
name|avoid_dfa
argument_list|(
name|tree
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
condition|)
name|kludge_need_start
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|research
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t1
operator|->
name|stlen
argument_list|,
name|kludge_need_start
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|==
operator|-
literal|1
operator|)
operator|^
operator|(
name|match
operator|==
name|TRUE
operator|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* set_IGNORECASE --- update IGNORECASE as appropriate */
end_comment

begin_function
name|void
name|set_IGNORECASE
parameter_list|()
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|do_lint
operator|||
name|do_traditional
operator|)
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|(
literal|"IGNORECASE not supported in compatibility mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_traditional
condition|)
name|IGNORECASE
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|IGNORECASE_node
operator|->
name|var_value
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|IGNORECASE_node
operator|->
name|var_value
operator|->
name|flags
operator|&
name|MAYBE_NUM
operator|)
operator|==
literal|0
condition|)
name|IGNORECASE
operator|=
operator|(
name|force_string
argument_list|(
name|IGNORECASE_node
operator|->
name|var_value
argument_list|)
operator|->
name|stlen
operator|>
literal|0
operator|)
expr_stmt|;
else|else
name|IGNORECASE
operator|=
operator|(
name|force_number
argument_list|(
name|IGNORECASE_node
operator|->
name|var_value
argument_list|)
operator|!=
literal|0.0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|IGNORECASE_node
operator|->
name|var_value
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|!=
literal|0
condition|)
name|IGNORECASE
operator|=
operator|(
name|force_number
argument_list|(
name|IGNORECASE_node
operator|->
name|var_value
argument_list|)
operator|!=
literal|0.0
operator|)
expr_stmt|;
else|else
name|IGNORECASE
operator|=
name|FALSE
expr_stmt|;
comment|/* shouldn't happen */
name|set_FS_if_not_FIELDWIDTHS
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_OFS --- update OFS related variables when OFS assigned to */
end_comment

begin_function
name|void
name|set_OFS
parameter_list|()
block|{
name|OFS
operator|=
name|force_string
argument_list|(
name|OFS_node
operator|->
name|var_value
argument_list|)
operator|->
name|stptr
expr_stmt|;
name|OFSlen
operator|=
name|OFS_node
operator|->
name|var_value
operator|->
name|stlen
expr_stmt|;
name|OFS
index|[
name|OFSlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_ORS --- update ORS related variables when ORS assigned to */
end_comment

begin_function
name|void
name|set_ORS
parameter_list|()
block|{
name|ORS
operator|=
name|force_string
argument_list|(
name|ORS_node
operator|->
name|var_value
argument_list|)
operator|->
name|stptr
expr_stmt|;
name|ORSlen
operator|=
name|ORS_node
operator|->
name|var_value
operator|->
name|stlen
expr_stmt|;
name|ORS
index|[
name|ORSlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fmt_ok --- is the conversion format a valid one? */
end_comment

begin_decl_stmt
name|NODE
modifier|*
modifier|*
name|fmt_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_ok
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_index
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fmt_ok
parameter_list|(
name|n
parameter_list|)
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
init|=
name|force_string
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tmp
operator|->
name|stptr
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'%'
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|p
operator|&&
name|strchr
argument_list|(
literal|" +-#"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* flags */
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* width - %*.*g is NOT allowed */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* precision */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
literal|"efgEG"
argument_list|,
operator|*
name|p
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* fmt_index --- track values of OFMT and CONVFMT to keep semantics correct */
end_comment

begin_function
specifier|static
name|int
name|fmt_index
parameter_list|(
name|n
parameter_list|)
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|ix
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|fmt_num
init|=
literal|4
decl_stmt|;
specifier|static
name|int
name|fmt_hiwater
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fmt_list
operator|==
name|NULL
condition|)
name|emalloc
argument_list|(
name|fmt_list
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|fmt_num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fmt_list
argument_list|)
argument_list|,
literal|"fmt_index"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|ix
operator|<
name|fmt_hiwater
condition|)
block|{
if|if
condition|(
name|cmp_nodes
argument_list|(
name|fmt_list
index|[
name|ix
index|]
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ix
return|;
name|ix
operator|++
expr_stmt|;
block|}
comment|/* not found */
name|n
operator|->
name|stptr
index|[
name|n
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|fmt_ok
argument_list|(
name|n
argument_list|)
condition|)
name|warning
argument_list|(
literal|"bad %sFMT specification"
argument_list|,
name|n
operator|==
name|CONVFMT_node
operator|->
name|var_value
condition|?
literal|"CONV"
else|:
name|n
operator|==
name|OFMT_node
operator|->
name|var_value
condition|?
literal|"O"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_hiwater
operator|>=
name|fmt_num
condition|)
block|{
name|fmt_num
operator|*=
literal|2
expr_stmt|;
name|emalloc
argument_list|(
name|fmt_list
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|fmt_num
argument_list|,
literal|"fmt_index"
argument_list|)
expr_stmt|;
block|}
name|fmt_list
index|[
name|fmt_hiwater
index|]
operator|=
name|dupnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|fmt_hiwater
operator|++
return|;
block|}
end_function

begin_comment
comment|/* set_OFMT --- track OFMT correctly */
end_comment

begin_function
name|void
name|set_OFMT
parameter_list|()
block|{
name|OFMTidx
operator|=
name|fmt_index
argument_list|(
name|OFMT_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|OFMT
operator|=
name|fmt_list
index|[
name|OFMTidx
index|]
operator|->
name|stptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_CONVFMT --- track CONVFMT correctly */
end_comment

begin_function
name|void
name|set_CONVFMT
parameter_list|()
block|{
name|CONVFMTidx
operator|=
name|fmt_index
argument_list|(
name|CONVFMT_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|CONVFMT
operator|=
name|fmt_list
index|[
name|CONVFMTidx
index|]
operator|->
name|stptr
expr_stmt|;
block|}
end_function

end_unit

