begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * profile.c - gawk parse tree pretty-printer with counts  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1999-2001 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_comment
comment|/* where to place redirections for getline, print, printf */
end_comment

begin_enum
enum|enum
name|redir_placement
block|{
name|BEFORE
init|=
literal|0
block|,
name|AFTER
init|=
literal|1
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|tree_eval
end_undef

begin_decl_stmt
specifier|static
name|void
name|tree_eval
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parenthesize
name|P
argument_list|(
operator|(
name|NODETYPE
name|parent_type
operator|,
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eval_condition
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_op_assign
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_func_call
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|name
operator|,
name|NODE
operator|*
name|arg_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_match_op
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_lhs
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_print_stmt
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|command
operator|,
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_delete
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_in_array
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|array
operator|,
name|NODE
operator|*
name|subscript
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_getline
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_builtin
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_list
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pp_string
name|P
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
name|size_t
name|len
operator|,
name|int
name|delim
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_scalar
name|P
argument_list|(
operator|(
name|NODETYPE
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prec_level
name|P
argument_list|(
operator|(
name|NODETYPE
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PROFILING
end_ifdef

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|dump_and_exit
name|P
argument_list|(
operator|(
name|int
name|signum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|just_dump
name|P
argument_list|(
operator|(
name|int
name|signum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pretty printing related functions and variables */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|fparms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function parameter names */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|prof_fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to send the profile */
end_comment

begin_decl_stmt
specifier|static
name|long
name|indent_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_BEGIN_or_END
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_expr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPACEOVER
value|0
end_define

begin_comment
comment|/* init_profiling --- do needed initializations, see also main.c */
end_comment

begin_function
name|void
name|init_profiling
parameter_list|(
name|int
modifier|*
name|flag
parameter_list|,
specifier|const
name|char
modifier|*
name|def_file
parameter_list|)
block|{
comment|/* run time init avoids glibc innovations */
name|prof_fp
operator|=
name|stderr
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILING
if|if
condition|(
operator|*
name|flag
operator|==
name|FALSE
condition|)
block|{
operator|*
name|flag
operator|=
name|TRUE
expr_stmt|;
name|set_prof_file
argument_list|(
name|def_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* set_prof_file --- set the output file for profiling */
end_comment

begin_function
name|void
name|set_prof_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|assert
argument_list|(
name|file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|prof_fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_fp
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"could not open `%s' for writing: %s"
argument_list|)
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"sending profile to standard error"
argument_list|)
argument_list|)
expr_stmt|;
name|prof_fp
operator|=
name|stderr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init_profiling_signals
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PROFILING
ifdef|#
directive|ifdef
name|SIGHUP
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|dump_and_exit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGUSR1
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|just_dump
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* indent --- print out enough tabs */
end_comment

begin_function
specifier|static
name|void
name|indent
parameter_list|(
name|long
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|prof_fp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%6ld  "
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|indent_level
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent_level
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|prof_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* indent_in --- increase the level, with error checking */
end_comment

begin_function
specifier|static
name|void
name|indent_in
parameter_list|()
block|{
name|assert
argument_list|(
name|indent_level
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|indent_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* indent_out --- decrease the level, with error checking */
end_comment

begin_function
specifier|static
name|void
name|indent_out
parameter_list|()
block|{
name|indent_level
operator|--
expr_stmt|;
name|assert
argument_list|(
name|indent_level
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pprint:  * Tree is a bunch of rules to run. Returns zero if it hit an exit()  * statement   */
end_comment

begin_function
specifier|static
name|void
name|pprint
parameter_list|(
specifier|register
name|NODE
modifier|*
specifier|volatile
name|tree
parameter_list|)
block|{
specifier|register
name|NODE
modifier|*
specifier|volatile
name|t
init|=
name|NULL
decl_stmt|;
comment|/* temporary */
name|int
specifier|volatile
name|traverse
init|=
name|TRUE
decl_stmt|;
comment|/* True => loop thru tree (Node_rule_list) */
comment|/* avoid false source indications */
name|source
operator|=
name|NULL
expr_stmt|;
name|sourceline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_rule_node
case|:
name|traverse
operator|=
name|FALSE
expr_stmt|;
comment|/* False => one for-loop iteration only */
comment|/* FALL THROUGH */
case|case
name|Node_rule_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
block|{
if|if
condition|(
name|traverse
condition|)
name|tree
operator|=
name|t
operator|->
name|lnode
expr_stmt|;
name|sourceline
operator|=
name|tree
operator|->
name|source_line
expr_stmt|;
name|source
operator|=
name|tree
operator|->
name|source_file
expr_stmt|;
if|if
condition|(
operator|!
name|in_BEGIN_or_END
condition|)
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
condition|)
block|{
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|rnode
condition|)
block|{
if|if
condition|(
operator|!
name|in_BEGIN_or_END
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
operator|&&
name|tree
operator|->
name|lnode
operator|->
name|exec_count
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" # %ld"
argument_list|,
name|tree
operator|->
name|lnode
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_BEGIN_or_END
condition|)
block|{
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|traverse
condition|)
comment|/* case Node_rule_node */
break|break;
comment|/* don't loop */
if|if
condition|(
name|t
operator|->
name|rnode
operator|&&
operator|!
name|in_BEGIN_or_END
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node_statement_list
case|:
for|for
control|(
name|t
operator|=
name|tree
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|rnode
control|)
block|{
name|pprint
argument_list|(
name|t
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node_K_if
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"if ("
argument_list|)
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|") {"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILING
if|if
condition|(
name|tree
operator|->
name|rnode
operator|->
name|exec_count
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" # %ld"
argument_list|,
name|tree
operator|->
name|rnode
operator|->
name|exec_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|exec_count
operator|-
name|tree
operator|->
name|rnode
operator|->
name|exec_count
operator|>
literal|0
condition|)
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
operator|-
name|tree
operator|->
name|rnode
operator|->
name|exec_count
argument_list|)
expr_stmt|;
else|else
name|indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"} else {\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
block|}
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_while
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"while ("
argument_list|)
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_do
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"do {\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"} while ("
argument_list|)
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_for
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"for ("
argument_list|)
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|forloop
operator|->
name|init
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|forloop
operator|->
name|cond
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|forloop
operator|->
name|incr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_arrayfor
case|:
define|#
directive|define
name|hakvar
value|forloop->init
define|#
directive|define
name|arrvar
value|forloop->incr
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"for ("
argument_list|)
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
name|pp_lhs
argument_list|(
name|tree
operator|->
name|hakvar
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" in "
argument_list|)
expr_stmt|;
name|t
operator|=
name|tree
operator|->
name|arrvar
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|fparms
index|[
name|t
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|t
operator|->
name|vname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|") {\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|indent_out
argument_list|()
expr_stmt|;
name|indent
argument_list|(
name|SPACEOVER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_break
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"break\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_continue
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"continue\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_print
case|:
name|pp_print_stmt
argument_list|(
literal|"print"
argument_list|,
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_printf
case|:
name|pp_print_stmt
argument_list|(
literal|"printf"
argument_list|,
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_delete
case|:
name|pp_delete
argument_list|(
name|tree
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_next
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"next\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_nextfile
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"nextfile\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_exit
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"exit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_K_return
case|:
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Appears to be an expression statement. 		 * Throw away the value.  		 */
if|if
condition|(
name|in_expr
condition|)
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
else|else
block|{
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* tree_eval --- evaluate a subtree */
end_comment

begin_function
specifier|static
name|void
name|tree_eval
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_param_list
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|fparms
index|[
name|tree
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_var
case|:
if|if
condition|(
name|tree
operator|->
name|vname
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: Node_var with null vname"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_val
case|:
if|if
condition|(
operator|(
name|tree
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%g"
argument_list|,
name|tree
operator|->
name|numbr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|tree
operator|->
name|flags
operator|&
name|INTLSTR
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|tree
operator|->
name|stptr
argument_list|,
name|tree
operator|->
name|stlen
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|Node_and
case|:
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"&& "
argument_list|)
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_or
case|:
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" || "
argument_list|)
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_not
case|:
name|parenthesize
argument_list|(
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
return|return;
comment|/* Builtins */
case|case
name|Node_builtin
case|:
name|pp_builtin
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_in_array
case|:
name|in_expr
operator|++
expr_stmt|;
name|pp_in_array
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
return|return;
case|case
name|Node_func_call
case|:
name|pp_func_call
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_K_getline
case|:
name|pp_getline
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
comment|/* unary operations */
case|case
name|Node_NR
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"NR"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_FNR
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FNR"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_NF
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"NF"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_FIELDWIDTHS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FIELDWIDTHS"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_FS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FS"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_RS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"RS"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_IGNORECASE
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"IGNORECASE"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_OFS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"OFS"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_ORS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"ORS"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_OFMT
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"OFMT"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_CONVFMT
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"CONVFMT"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_BINMODE
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"BINMODE"
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_field_spec
case|:
case|case
name|Node_subscript
case|:
name|pp_lhs
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_var_array
case|:
if|if
condition|(
name|tree
operator|->
name|vname
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: Node_var_array with null vname"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_unary_minus
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" -"
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_cond_exp
case|:
name|eval_condition
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" ? "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" : "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_match
case|:
case|case
name|Node_nomatch
case|:
case|case
name|Node_regex
case|:
name|pp_match_op
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"function `%s' called with space between name and `(',\n%s"
argument_list|)
argument_list|,
name|tree
operator|->
name|lnode
operator|->
name|param
argument_list|,
name|_
argument_list|(
literal|"or used in other expression context"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assignments */
case|case
name|Node_assign
case|:
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
return|return;
case|case
name|Node_concat
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
comment|/* other assignment types are easier because they are numeric */
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
case|case
name|Node_assign_exp
case|:
case|case
name|Node_assign_times
case|:
case|case
name|Node_assign_quotient
case|:
case|case
name|Node_assign_mod
case|:
case|case
name|Node_assign_plus
case|:
case|case
name|Node_assign_minus
case|:
name|pp_op_assign
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
comment|/* handled below */
block|}
comment|/* handle binary ops */
name|in_expr
operator|++
expr_stmt|;
name|parenthesize
argument_list|(
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_geq
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|">= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_leq
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"<= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_greater
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_less
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"< "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_notequal
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" != "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_equal
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" == "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_exp
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" ^ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_times
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" * "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_quotient
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" / "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_mod
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" %% "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_plus
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_minus
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|)
argument_list|,
name|tree
operator|->
name|vname
argument_list|)
expr_stmt|;
return|return;
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"illegal type (%s) in tree_eval"
argument_list|)
argument_list|,
name|nodetype2str
argument_list|(
name|tree
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parenthesize
argument_list|(
name|tree
operator|->
name|type
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* eval_condition --- is TREE true or false */
end_comment

begin_function
specifier|static
name|void
name|eval_condition
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
comment|/* Null trees are the easiest kinds */
return|return;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_line_range
condition|)
block|{
comment|/* /.../, /.../ */
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|eval_condition
argument_list|(
name|tree
operator|->
name|condpair
operator|->
name|rnode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Could just be J.random expression. in which case, null and 0 are 	 * false, anything else is true  	 */
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* pp_op_assign --- do +=, -=, etc. */
end_comment

begin_function
specifier|static
name|void
name|pp_op_assign
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|char
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
enum|enum
name|Order
block|{
name|NA
init|=
literal|0
block|,
name|PRE
init|=
literal|1
block|,
name|POST
init|=
literal|2
block|}
name|order
init|=
name|NA
enum|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_preincrement
case|:
name|op
operator|=
literal|"++"
expr_stmt|;
name|order
operator|=
name|PRE
expr_stmt|;
break|break;
case|case
name|Node_predecrement
case|:
name|op
operator|=
literal|"--"
expr_stmt|;
name|order
operator|=
name|PRE
expr_stmt|;
break|break;
case|case
name|Node_postincrement
case|:
name|op
operator|=
literal|"++"
expr_stmt|;
name|order
operator|=
name|POST
expr_stmt|;
break|break;
case|case
name|Node_postdecrement
case|:
name|op
operator|=
literal|"--"
expr_stmt|;
name|order
operator|=
name|POST
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* handled below */
block|}
if|if
condition|(
name|order
operator|==
name|PRE
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|pp_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|order
operator|==
name|POST
condition|)
block|{
name|pp_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* a binary op */
name|pp_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_assign_exp
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" ^= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_times
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" *= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_quotient
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" /= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_mod
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" %%= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_plus
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" += "
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_assign_minus
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" -= "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_lhs --- print the lhs */
end_comment

begin_function
specifier|static
name|void
name|pp_lhs
parameter_list|(
specifier|register
name|NODE
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|type
condition|)
block|{
case|case
name|Node_var_array
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"attempt to use array `%s' in a scalar context"
argument_list|)
argument_list|,
name|ptr
operator|->
name|vname
argument_list|)
expr_stmt|;
case|case
name|Node_var
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|ptr
operator|->
name|vname
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_FIELDWIDTHS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FIELDWIDTHS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_RS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"RS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_FS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_FNR
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"FNR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_NR
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"NR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_NF
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"NF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_IGNORECASE
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"IGNORECASE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_BINMODE
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"BINMODE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_LINT
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"LINT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_OFMT
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"OFMT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_CONVFMT
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"CONVFMT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_ORS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"ORS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_OFS
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"OFS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_param_list
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|fparms
index|[
name|ptr
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_field_spec
case|:
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_scalar
argument_list|(
name|ptr
operator|->
name|lnode
operator|->
name|type
argument_list|)
condition|)
name|tree_eval
argument_list|(
name|ptr
operator|->
name|lnode
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|ptr
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|Node_subscript
case|:
name|n
operator|=
name|ptr
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_func
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"attempt to use function `%s' as array"
argument_list|)
argument_list|,
name|n
operator|->
name|lnode
operator|->
name|param
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|Node_param_list
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s["
argument_list|,
name|fparms
index|[
name|n
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s["
argument_list|,
name|n
operator|->
name|vname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|rnode
operator|->
name|type
operator|==
name|Node_expression_list
condition|)
name|pp_list
argument_list|(
name|ptr
operator|->
name|rnode
argument_list|)
expr_stmt|;
else|else
name|tree_eval
argument_list|(
name|ptr
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_func
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`%s' is a function, assignment is not allowed"
argument_list|)
argument_list|,
name|ptr
operator|->
name|lnode
operator|->
name|param
argument_list|)
expr_stmt|;
case|case
name|Node_builtin
case|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"assignment is not allowed to result of builtin function"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* match_op --- do ~ and !~ */
end_comment

begin_function
specifier|static
name|void
name|pp_match_op
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
specifier|register
name|NODE
modifier|*
name|re
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|restr
decl_stmt|;
name|size_t
name|relen
decl_stmt|;
name|NODE
modifier|*
name|text
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_regex
condition|)
name|re
operator|=
name|tree
operator|->
name|re_exp
expr_stmt|;
else|else
block|{
name|re
operator|=
name|tree
operator|->
name|rnode
operator|->
name|re_exp
expr_stmt|;
name|text
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|re
operator|->
name|re_flags
operator|&
name|CONST
operator|)
operator|!=
literal|0
condition|)
block|{
name|restr
operator|=
name|re
operator|->
name|stptr
expr_stmt|;
name|relen
operator|=
name|re
operator|->
name|stlen
expr_stmt|;
block|}
else|else
block|{
name|restr
operator|=
name|re
operator|->
name|stptr
expr_stmt|;
name|relen
operator|=
name|re
operator|->
name|stlen
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_regex
condition|)
block|{
name|pp_string
argument_list|(
name|restr
argument_list|,
name|relen
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_nomatch
condition|)
name|op
operator|=
literal|"!~"
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_match
condition|)
name|op
operator|=
literal|"~"
expr_stmt|;
else|else
name|op
operator|=
literal|""
expr_stmt|;
name|tree_eval
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" %s "
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"/%.*s/"
argument_list|,
operator|(
name|int
operator|)
name|relen
argument_list|,
name|restr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_redir --- print a redirection */
end_comment

begin_function
specifier|static
name|void
name|pp_redir
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|,
name|enum
name|redir_placement
name|dir
parameter_list|)
block|{
name|char
modifier|*
name|op
init|=
literal|"[BOGUS]"
decl_stmt|;
comment|/* should never be seen */
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_output
case|:
name|op
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|Node_redirect_append
case|:
name|op
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
name|op
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|op
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|op
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|Node_redirect_twoway
case|:
name|op
operator|=
literal|"|&"
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|==
name|BEFORE
condition|)
block|{
if|if
condition|(
operator|!
name|is_scalar
argument_list|(
name|tree
operator|->
name|subnode
operator|->
name|type
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" %s "
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" %s "
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_scalar
argument_list|(
name|tree
operator|->
name|subnode
operator|->
name|type
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* pp_list --- dump a list of arguments, without parens */
end_comment

begin_function
specifier|static
name|void
name|pp_list
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
for|for
control|(
init|;
name|tree
operator|!=
name|NULL
condition|;
name|tree
operator|=
name|tree
operator|->
name|rnode
control|)
block|{
if|if
condition|(
name|tree
operator|->
name|type
operator|!=
name|Node_expression_list
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pp_list: got %s\n"
argument_list|,
name|nodetype2str
argument_list|(
name|tree
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|tree
operator|->
name|type
operator|==
name|Node_expression_list
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* pp_print_stmt --- print a "print" or "printf" statement */
end_comment

begin_function
specifier|static
name|void
name|pp_print_stmt
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|redir
init|=
name|tree
operator|->
name|rnode
decl_stmt|;
name|indent
argument_list|(
name|tree
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|redir
operator|!=
name|NULL
condition|)
block|{
comment|/* parenthesize if have a redirection */
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|pp_redir
argument_list|(
name|redir
argument_list|,
name|AFTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_delete --- print a "delete" statement */
end_comment

begin_function
specifier|static
name|void
name|pp_delete
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|array
decl_stmt|,
modifier|*
name|subscript
decl_stmt|;
name|array
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|subscript
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|indent
argument_list|(
name|array
operator|->
name|exec_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"delete %s"
argument_list|,
name|fparms
index|[
name|array
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"delete %s"
argument_list|,
name|array
operator|->
name|vname
argument_list|)
expr_stmt|;
if|if
condition|(
name|subscript
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_in_array --- pretty print "foo in array" test */
end_comment

begin_function
specifier|static
name|void
name|pp_in_array
parameter_list|(
name|NODE
modifier|*
name|array
parameter_list|,
name|NODE
modifier|*
name|subscript
parameter_list|)
block|{
if|if
condition|(
name|subscript
operator|->
name|type
operator|==
name|Node_expression_list
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|pprint
argument_list|(
name|subscript
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" in %s"
argument_list|,
name|fparms
index|[
name|array
operator|->
name|param_cnt
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" in %s"
argument_list|,
name|array
operator|->
name|vname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_getline --- print a getline statement */
end_comment

begin_function
specifier|static
name|void
name|pp_getline
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|redir
init|=
name|tree
operator|->
name|rnode
decl_stmt|;
name|int
name|before
decl_stmt|,
name|after
decl_stmt|;
comment|/* 	 * command | getline 	 *     or 	 * command |& getline 	 *     or 	 * getline< file 	 */
if|if
condition|(
name|redir
operator|!=
name|NULL
condition|)
block|{
name|before
operator|=
operator|(
name|redir
operator|->
name|type
operator|==
name|Node_redirect_pipein
operator|||
name|redir
operator|->
name|type
operator|==
name|Node_redirect_twoway
operator|)
expr_stmt|;
name|after
operator|=
operator|!
name|before
expr_stmt|;
block|}
else|else
name|before
operator|=
name|after
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|before
condition|)
name|pp_redir
argument_list|(
name|redir
argument_list|,
name|BEFORE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"getline"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
condition|)
block|{
comment|/* optional var */
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|pp_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|after
condition|)
name|pp_redir
argument_list|(
name|redir
argument_list|,
name|AFTER
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_builtin --- print a builtin function */
end_comment

begin_function
specifier|static
name|void
name|pp_builtin
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s("
argument_list|,
name|getfname
argument_list|(
name|tree
operator|->
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_func_call --- print a function call */
end_comment

begin_function
specifier|static
name|void
name|pp_func_call
parameter_list|(
name|NODE
modifier|*
name|name
parameter_list|,
name|NODE
modifier|*
name|arglist
parameter_list|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s("
argument_list|,
name|name
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|pp_list
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dump_prog --- dump the program */
end_comment

begin_comment
comment|/*  * XXX: I am not sure it is right to have the strings in the dump  * be translated, but I'll leave it alone for now.  */
end_comment

begin_function
name|void
name|dump_prog
parameter_list|(
name|NODE
modifier|*
name|begin
parameter_list|,
name|NODE
modifier|*
name|prog
parameter_list|,
name|NODE
modifier|*
name|end
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* \n on purpose, with \n in ctime() output */
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
name|_
argument_list|(
literal|"\t# gawk profile, created %s\n"
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
name|_
argument_list|(
literal|"\t# BEGIN block(s)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\tBEGIN {\n"
argument_list|)
expr_stmt|;
name|in_BEGIN_or_END
operator|=
name|TRUE
expr_stmt|;
name|pprint
argument_list|(
name|begin
argument_list|)
expr_stmt|;
name|in_BEGIN_or_END
operator|=
name|FALSE
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|!=
name|NULL
operator|||
name|end
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
name|_
argument_list|(
literal|"\t# Rule(s)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|pprint
argument_list|(
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
name|_
argument_list|(
literal|"\t# END block(s)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\tEND {\n"
argument_list|)
expr_stmt|;
name|in_BEGIN_or_END
operator|=
name|TRUE
expr_stmt|;
name|pprint
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|in_BEGIN_or_END
operator|=
name|FALSE
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* pp_func --- pretty print a function */
end_comment

begin_function
name|void
name|pp_func
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|,
name|NODE
modifier|*
name|f
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|pnames
decl_stmt|;
specifier|static
name|int
name|first
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
name|_
argument_list|(
literal|"\n\t# Functions, listed alphabetically\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|f
operator|->
name|exec_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"function %.*s("
argument_list|,
operator|(
name|int
operator|)
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pnames
operator|=
name|f
operator|->
name|parmlist
expr_stmt|;
name|fparms
operator|=
name|pnames
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|f
operator|->
name|lnode
operator|->
name|param_cnt
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"%s"
argument_list|,
name|pnames
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|f
operator|->
name|lnode
operator|->
name|param_cnt
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")\n\t{\n"
argument_list|)
expr_stmt|;
name|indent_in
argument_list|()
expr_stmt|;
name|pprint
argument_list|(
name|f
operator|->
name|rnode
argument_list|)
expr_stmt|;
comment|/* body */
name|indent_out
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_string --- pretty print a string or regex constant */
end_comment

begin_function
specifier|static
name|void
name|pp_string
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|delim
parameter_list|)
block|{
name|pp_string_fp
argument_list|(
name|prof_fp
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|delim
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pp_string_fp --- printy print a string to the fp */
end_comment

begin_comment
comment|/*  * This routine concentrates string pretty printing in one place,  * so that it can be called from multiple places within gawk.  */
end_comment

begin_function
name|void
name|pp_string_fp
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|in_str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|delim
parameter_list|,
name|int
name|breaklines
parameter_list|)
block|{
specifier|static
name|char
name|escapes
index|[]
init|=
literal|"\b\f\n\r\t\v\\"
decl_stmt|;
specifier|static
name|char
name|printables
index|[]
init|=
literal|"bfnrtv\\"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
define|#
directive|define
name|BREAKPOINT
value|70
comment|/* arbitrary */
name|unsigned
name|char
modifier|*
name|str
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|in_str
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|delim
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|count
operator|>=
name|BREAKPOINT
operator|&&
name|breaklines
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c\n%c"
argument_list|,
name|delim
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
name|delim
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\%c"
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
name|BELL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\a"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|escapes
argument_list|,
operator|*
name|str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|cp
operator|-
name|escapes
expr_stmt|;
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|putc
argument_list|(
name|printables
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|breaklines
operator|&&
operator|*
name|str
operator|==
literal|'\n'
operator|&&
name|delim
operator|==
literal|'"'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"\n\""
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* NB: Deliberate use of lower-case versions. */
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|str
argument_list|)
operator|&&
name|isprint
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|putc
argument_list|(
operator|*
name|str
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|*
name|str
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|count
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|delim
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* is_scalar --- true or false if we'll get a scalar value */
end_comment

begin_function
specifier|static
name|int
name|is_scalar
parameter_list|(
name|NODETYPE
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node_var
case|:
case|case
name|Node_var_array
case|:
case|case
name|Node_val
case|:
case|case
name|Node_BINMODE
case|:
case|case
name|Node_CONVFMT
case|:
case|case
name|Node_FIELDWIDTHS
case|:
case|case
name|Node_FNR
case|:
case|case
name|Node_FS
case|:
case|case
name|Node_IGNORECASE
case|:
case|case
name|Node_LINT
case|:
case|case
name|Node_NF
case|:
case|case
name|Node_NR
case|:
case|case
name|Node_OFMT
case|:
case|case
name|Node_OFS
case|:
case|case
name|Node_ORS
case|:
case|case
name|Node_RS
case|:
case|case
name|Node_subscript
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* prec_level --- return the precedence of an operator, for paren tests */
end_comment

begin_function
specifier|static
name|int
name|prec_level
parameter_list|(
name|NODETYPE
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Node_var
case|:
case|case
name|Node_var_array
case|:
case|case
name|Node_param_list
case|:
case|case
name|Node_subscript
case|:
case|case
name|Node_func_call
case|:
case|case
name|Node_val
case|:
case|case
name|Node_builtin
case|:
case|case
name|Node_BINMODE
case|:
case|case
name|Node_CONVFMT
case|:
case|case
name|Node_FIELDWIDTHS
case|:
case|case
name|Node_FNR
case|:
case|case
name|Node_FS
case|:
case|case
name|Node_IGNORECASE
case|:
case|case
name|Node_LINT
case|:
case|case
name|Node_NF
case|:
case|case
name|Node_NR
case|:
case|case
name|Node_OFMT
case|:
case|case
name|Node_OFS
case|:
case|case
name|Node_ORS
case|:
case|case
name|Node_RS
case|:
return|return
literal|15
return|;
case|case
name|Node_field_spec
case|:
return|return
literal|14
return|;
case|case
name|Node_exp
case|:
return|return
literal|13
return|;
case|case
name|Node_preincrement
case|:
case|case
name|Node_predecrement
case|:
case|case
name|Node_postincrement
case|:
case|case
name|Node_postdecrement
case|:
return|return
literal|12
return|;
case|case
name|Node_unary_minus
case|:
case|case
name|Node_not
case|:
return|return
literal|11
return|;
case|case
name|Node_times
case|:
case|case
name|Node_quotient
case|:
case|case
name|Node_mod
case|:
return|return
literal|10
return|;
case|case
name|Node_plus
case|:
case|case
name|Node_minus
case|:
return|return
literal|9
return|;
case|case
name|Node_concat
case|:
return|return
literal|8
return|;
case|case
name|Node_equal
case|:
case|case
name|Node_notequal
case|:
case|case
name|Node_greater
case|:
case|case
name|Node_leq
case|:
case|case
name|Node_geq
case|:
case|case
name|Node_match
case|:
case|case
name|Node_nomatch
case|:
return|return
literal|7
return|;
case|case
name|Node_K_getline
case|:
return|return
literal|6
return|;
case|case
name|Node_less
case|:
return|return
literal|5
return|;
case|case
name|Node_in_array
case|:
return|return
literal|5
return|;
case|case
name|Node_and
case|:
return|return
literal|4
return|;
case|case
name|Node_or
case|:
return|return
literal|3
return|;
case|case
name|Node_cond_exp
case|:
return|return
literal|2
return|;
case|case
name|Node_assign
case|:
case|case
name|Node_assign_times
case|:
case|case
name|Node_assign_quotient
case|:
case|case
name|Node_assign_mod
case|:
case|case
name|Node_assign_plus
case|:
case|case
name|Node_assign_minus
case|:
case|case
name|Node_assign_exp
case|:
return|return
literal|1
return|;
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unexpected type %s in prec_level"
argument_list|)
argument_list|,
name|nodetype2str
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* keep the compiler happy */
block|}
block|}
end_function

begin_comment
comment|/* parenthesize --- print a subtree in parentheses if need be */
end_comment

begin_function
specifier|static
name|void
name|parenthesize
parameter_list|(
name|NODETYPE
name|parent_type
parameter_list|,
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODETYPE
name|child_type
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
name|child_type
operator|=
name|tree
operator|->
name|type
expr_stmt|;
name|in_expr
operator|++
expr_stmt|;
comment|/* first the special cases, then the general ones */
if|if
condition|(
name|parent_type
operator|==
name|Node_not
operator|&&
name|child_type
operator|==
name|Node_in_array
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"! ("
argument_list|)
expr_stmt|;
name|pp_in_array
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
name|tree
operator|->
name|rnode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
comment|/* other special cases here, as needed */
block|}
elseif|else
if|if
condition|(
name|prec_level
argument_list|(
name|child_type
argument_list|)
operator|<
name|prec_level
argument_list|(
name|parent_type
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|prof_fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
name|tree_eval
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|in_expr
operator|--
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PROFILING
end_ifdef

begin_comment
comment|/* just_dump --- dump the profile and function stack and keep going */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|just_dump
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
specifier|extern
name|NODE
modifier|*
name|begin_block
decl_stmt|,
modifier|*
name|expression_value
decl_stmt|,
modifier|*
name|end_block
decl_stmt|;
name|dump_prog
argument_list|(
name|begin_block
argument_list|,
name|expression_value
argument_list|,
name|end_block
argument_list|)
expr_stmt|;
name|dump_funcs
argument_list|()
expr_stmt|;
name|dump_fcall_stack
argument_list|(
name|prof_fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|prof_fp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signum
argument_list|,
name|just_dump
argument_list|)
expr_stmt|;
comment|/* for OLD Unix systems ... */
block|}
end_function

begin_comment
comment|/* dump_and_exit --- dump the profile, the function stack, and exit */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|dump_and_exit
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|just_dump
argument_list|(
name|signum
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

