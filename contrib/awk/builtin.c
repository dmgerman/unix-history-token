begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * builtin.c - Builtin functions and various utility procedures   */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991-2001 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|HUGE
end_undef

begin_undef
undef|#
directive|undef
name|CHARBITS
end_undef

begin_undef
undef|#
directive|undef
name|INTBITS
end_undef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_include
include|#
directive|include
file|"random.h"
end_include

begin_comment
comment|/* can declare these, since we always use the random shipped with gawk */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|initstate
name|P
argument_list|(
operator|(
name|unsigned
name|long
name|seed
operator|,
name|char
operator|*
name|state
operator|,
name|long
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|setstate
name|P
argument_list|(
operator|(
name|char
operator|*
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|random
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|srandom
name|P
argument_list|(
operator|(
name|unsigned
name|long
name|seed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|output_is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|sub_common
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|,
name|int
name|how_many
operator|,
name|int
name|backdigs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_CRAY
end_ifdef

begin_comment
comment|/* Work around a problem in conversion of doubles to exact integers. */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_define
define|#
directive|define
name|Floor
parameter_list|(
name|n
parameter_list|)
value|floor((n) * (1.0 + DBL_EPSILON))
end_define

begin_define
define|#
directive|define
name|Ceil
parameter_list|(
name|n
parameter_list|)
value|ceil((n) * (1.0 + DBL_EPSILON))
end_define

begin_comment
comment|/* Force the standard C compiler to use the library math functions. */
end_comment

begin_function_decl
specifier|extern
name|double
name|exp
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
function_decl|(
modifier|*
name|Exp
function_decl|)
parameter_list|()
init|=
name|exp
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|exp
parameter_list|(
name|x
parameter_list|)
value|(*Exp)(x)
end_define

begin_function_decl
specifier|extern
name|double
name|log
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
function_decl|(
modifier|*
name|Log
function_decl|)
parameter_list|()
init|=
name|log
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|log
parameter_list|(
name|x
parameter_list|)
value|(*Log)(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Floor
parameter_list|(
name|n
parameter_list|)
value|floor(n)
end_define

begin_define
define|#
directive|define
name|Ceil
parameter_list|(
name|n
parameter_list|)
value|ceil(n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFAULT_G_PRECISION
value|6
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GFMT_WORKAROUND
end_ifdef

begin_comment
comment|/* semi-temporary hack, mostly to gracefully handle VMS */
end_comment

begin_decl_stmt
specifier|static
name|void
name|sgfmt
name|P
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
specifier|const
name|char
operator|*
name|format
operator|,
name|int
name|alt
operator|,
name|int
name|fwidth
operator|,
name|int
name|precision
operator|,
name|double
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GFMT_WORKAROUND */
end_comment

begin_comment
comment|/*  * Since we supply the version of random(), we know what  * value to use here.  */
end_comment

begin_define
define|#
directive|define
name|GAWK_RANDOM_MAX
value|0x7fffffffL
end_define

begin_decl_stmt
specifier|static
name|void
name|efwrite
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|ptr
operator|,
name|size_t
name|size
operator|,
name|size_t
name|count
operator|,
name|FILE
operator|*
name|fp
operator|,
specifier|const
name|char
operator|*
name|from
operator|,
expr|struct
name|redirect
operator|*
name|rp
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* efwrite --- like fwrite, but with error checking */
end_comment

begin_function
specifier|static
name|void
name|efwrite
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|count
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|struct
name|redirect
modifier|*
name|rp
parameter_list|,
name|int
name|flush
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|fp
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|wrerror
goto|;
if|if
condition|(
name|flush
operator|&&
operator|(
operator|(
name|fp
operator|==
name|stdout
operator|&&
name|output_is_tty
operator|)
operator|||
operator|(
name|rp
operator|!=
name|NULL
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_NOBUF
operator|)
operator|)
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
goto|goto
name|wrerror
goto|;
block|}
return|return;
name|wrerror
label|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s to \"%s\" failed (%s)"
argument_list|)
argument_list|,
name|from
argument_list|,
name|rp
condition|?
name|rp
operator|->
name|value
else|:
name|_
argument_list|(
literal|"standard output"
argument_list|)
argument_list|,
name|errno
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
name|_
argument_list|(
literal|"reason unknown"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_exp --- exponential function */
end_comment

begin_function
name|NODE
modifier|*
name|do_exp
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|,
name|res
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"exp: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|exp
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"exp: argument %g is out of range"
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* stdfile --- return fp for a standard file */
end_comment

begin_comment
comment|/*  * This function allows `fflush("/dev/stdout")' to work.  * The other files will be available via getredirect().  * /dev/stdin is not included, since fflush is only for output.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|stdfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|11
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/stderr"
argument_list|,
literal|11
argument_list|)
condition|)
return|return
name|stderr
return|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/stdout"
argument_list|,
literal|11
argument_list|)
condition|)
return|return
name|stdout
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* do_fflush --- flush output, either named file or pipe or everything */
end_comment

begin_function
name|NODE
modifier|*
name|do_fflush
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
comment|/* fflush() --- flush stdout */
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|status
argument_list|)
return|;
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|file
operator|=
name|tmp
operator|->
name|stptr
expr_stmt|;
comment|/* fflush("") --- flush all */
if|if
condition|(
name|tmp
operator|->
name|stlen
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|flush_io
argument_list|()
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|status
argument_list|)
return|;
block|}
name|rp
operator|=
name|getredirect
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_WRITE
operator||
name|RED_APPEND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"fflush: cannot flush: pipe `%s' opened for reading, not writing"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"fflush: cannot flush: file `%s' opened for reading, not writing"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|status
argument_list|)
return|;
block|}
name|fp
operator|=
name|rp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|status
operator|=
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|stdfile
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"fflush: `%s' is not an open file, pipe or co-process"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|status
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_index --- find index of a string */
end_comment

begin_function
name|NODE
modifier|*
name|do_index
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|size_t
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|long
name|ret
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"index: received non-string first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"index: received non-string second argument"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|force_string
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|force_string
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|p1
operator|=
name|s1
operator|->
name|stptr
expr_stmt|;
name|p2
operator|=
name|s2
operator|->
name|stptr
expr_stmt|;
name|l1
operator|=
name|s1
operator|->
name|stlen
expr_stmt|;
name|l2
operator|=
name|s2
operator|->
name|stlen
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* IGNORECASE will already be false if posix */
if|if
condition|(
name|IGNORECASE
condition|)
block|{
while|while
condition|(
name|l1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l2
operator|>
name|l1
condition|)
break|break;
if|if
condition|(
name|casetable
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p1
index|]
operator|==
name|casetable
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p2
index|]
operator|&&
operator|(
name|l2
operator|==
literal|1
operator|||
name|strncasecmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|l2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
operator|+
name|s1
operator|->
name|stlen
operator|-
name|l1
expr_stmt|;
break|break;
block|}
name|l1
operator|--
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|l1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l2
operator|>
name|l1
condition|)
break|break;
if|if
condition|(
operator|*
name|p1
operator|==
operator|*
name|p2
operator|&&
operator|(
name|l2
operator|==
literal|1
operator|||
name|STREQN
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|l2
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
operator|+
name|s1
operator|->
name|stlen
operator|-
name|l1
expr_stmt|;
break|break;
block|}
name|l1
operator|--
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* double_to_int --- convert double to int, used several places */
end_comment

begin_function
name|double
name|double_to_int
parameter_list|(
name|double
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
name|d
operator|=
name|Floor
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
name|Ceil
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* do_int --- convert double to int for awk */
end_comment

begin_function
name|NODE
modifier|*
name|do_int
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"int: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|d
operator|=
name|double_to_int
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_length --- length of a string or $0 */
end_comment

begin_function
name|NODE
modifier|*
name|do_length
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"length: received non-string argument"
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
operator|->
name|stlen
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_log --- the log function */
end_comment

begin_function
name|NODE
modifier|*
name|do_log
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|,
name|arg
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"log: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0.0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"log: received negative argument %g"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|d
operator|=
name|log
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * format_tree() formats nodes of a tree, starting with a left node,  * and accordingly to a fmt_string providing a format like in  * printf family from C library.  Returns a string node which value  * is a formatted string.  Called by  sprintf function.  *  * It is one of the uglier parts of gawk.  Thanks to Michal Jaegermann  * for taming this beast and making it compatible with ANSI C.  */
end_comment

begin_function
name|NODE
modifier|*
name|format_tree
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt_string
parameter_list|,
name|int
name|n0
parameter_list|,
specifier|register
name|NODE
modifier|*
name|carg
parameter_list|,
name|int
name|num_args
parameter_list|)
block|{
comment|/* copy 'l' bytes from 's' to 'obufout' checking for space in the process */
comment|/* difference of pointers should be of ptrdiff_t type, but let us be kind */
define|#
directive|define
name|bchunk
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
value|if (l) { \ 	while ((l)> ofre) { \ 		long olen = obufout - obuf; \ 		erealloc(obuf, char *, osiz * 2, "format_tree"); \ 		ofre += osiz; \ 		osiz *= 2; \ 		obufout = obuf + olen; \ 	} \ 	memcpy(obufout, s, (size_t) (l)); \ 	obufout += (l); \ 	ofre -= (l); \ }
comment|/* copy one byte from 's' to 'obufout' checking for space in the process */
define|#
directive|define
name|bchunk_one
parameter_list|(
name|s
parameter_list|)
value|{ \ 	if (ofre<= 0) { \ 		long olen = obufout - obuf; \ 		erealloc(obuf, char *, osiz * 2, "format_tree"); \ 		ofre += osiz; \ 		osiz *= 2; \ 		obufout = obuf + olen; \ 	} \ 	*obufout++ = *s; \ 	--ofre; \ }
comment|/* Is there space for something L big in the buffer? */
define|#
directive|define
name|chksize
parameter_list|(
name|l
parameter_list|)
value|if ((l)> ofre) { \ 	long olen = obufout - obuf; \ 	erealloc(obuf, char *, osiz * 2, "format_tree"); \ 	obufout = obuf + olen; \ 	ofre += osiz; \ 	osiz *= 2; \ }
specifier|static
name|NODE
modifier|*
modifier|*
name|the_args
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|args_size
init|=
literal|0
decl_stmt|;
name|size_t
name|cur_arg
init|=
literal|0
decl_stmt|;
specifier|auto
name|NODE
modifier|*
modifier|*
name|save_args
init|=
literal|0
decl_stmt|;
specifier|auto
name|size_t
name|save_args_size
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|call_level
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|toofew
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|,
modifier|*
name|obufout
decl_stmt|;
name|size_t
name|osiz
decl_stmt|,
name|ofre
decl_stmt|;
name|char
modifier|*
name|chbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|s0
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|int
name|cs1
decl_stmt|;
name|NODE
modifier|*
name|arg
decl_stmt|;
name|long
name|fw
decl_stmt|,
name|prec
decl_stmt|,
name|argnum
decl_stmt|;
name|int
name|used_dollar
decl_stmt|;
name|int
name|lj
decl_stmt|,
name|alt
decl_stmt|,
name|big
decl_stmt|,
name|bigbig
decl_stmt|,
name|small
decl_stmt|,
name|have_prec
decl_stmt|,
name|need_format
decl_stmt|;
name|long
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|sun386
comment|/* Can't cast unsigned (int/long) from ptr->value */
name|long
name|tmp_uval
decl_stmt|;
comment|/* on 386i 4.0.1 C compiler -- it just hangs */
endif|#
directive|endif
name|unsigned
name|long
name|uval
decl_stmt|;
name|int
name|sgn
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|char
name|cpbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* if we have numbers bigger than 30 */
name|char
modifier|*
name|cend
init|=
operator|&
name|cpbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* chars, we lose, but seems unlikely */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fill
decl_stmt|;
name|double
name|tmpval
decl_stmt|;
name|char
name|signchar
init|=
name|FALSE
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|zero_flag
init|=
name|FALSE
decl_stmt|;
specifier|static
name|char
name|sp
index|[]
init|=
literal|" "
decl_stmt|;
specifier|static
name|char
name|zero_string
index|[]
init|=
literal|"0"
decl_stmt|;
specifier|static
name|char
name|lchbuf
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
name|char
name|Uchbuf
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
define|#
directive|define
name|INITIAL_OUT_SIZE
value|512
name|emalloc
argument_list|(
name|obuf
argument_list|,
name|char
operator|*
argument_list|,
name|INITIAL_OUT_SIZE
argument_list|,
literal|"format_tree"
argument_list|)
expr_stmt|;
name|obufout
operator|=
name|obuf
expr_stmt|;
name|osiz
operator|=
name|INITIAL_OUT_SIZE
expr_stmt|;
name|ofre
operator|=
name|osiz
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Icky problem.  If the args make a nested call to printf/sprintf, 	 * we end up clobbering the static variable `the_args'.  Not good. 	 * We don't just malloc and free the_args each time, since most of the 	 * time there aren't nested calls.  But if this is a nested call, 	 * save the memory pointed to by the_args and allocate a fresh 	 * array.  Then free it on end. 	 */
if|if
condition|(
operator|++
name|call_level
operator|>
literal|1
condition|)
block|{
comment|/* nested */
name|save_args
operator|=
name|the_args
expr_stmt|;
name|save_args_size
operator|=
name|args_size
expr_stmt|;
name|args_size
operator|=
literal|0
expr_stmt|;
comment|/* force fresh allocation */
block|}
if|if
condition|(
name|args_size
operator|==
literal|0
condition|)
block|{
comment|/* allocate array */
name|emalloc
argument_list|(
name|the_args
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
operator|(
name|num_args
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"format_tree"
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|num_args
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_args
operator|+
literal|1
operator|>
name|args_size
condition|)
block|{
comment|/* grow it */
name|erealloc
argument_list|(
name|the_args
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
operator|(
name|num_args
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"format_tree"
argument_list|)
expr_stmt|;
name|args_size
operator|=
name|num_args
operator|+
literal|1
expr_stmt|;
block|}
comment|/* fill it in */
comment|/* 	 * We ignore the_args[0] since format strings use 	 * 1-based numbers to indicate the arguments.  It's 	 * easiest to just convert to int and index, without 	 * having to remember to subtract 1. 	 */
name|memset
argument_list|(
name|the_args
argument_list|,
literal|'\0'
argument_list|,
name|num_args
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|carg
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|carg
operator|=
name|carg
operator|->
name|rnode
control|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
comment|/* Here lies the wumpus's other brother. R.I.P. */
name|tmp
operator|=
name|tree_eval
argument_list|(
name|carg
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|the_args
index|[
name|i
index|]
operator|=
name|dupnode
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|num_args
argument_list|)
expr_stmt|;
name|cur_arg
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check first for use of `count$'. 	 * If plain argument retrieval was used earlier, choke. 	 *	Otherwise, return the requested argument. 	 * If not `count$' now, but it was used earlier, choke. 	 * If this format is more than total number of args, choke. 	 * Otherwise, return the current argument. 	 */
define|#
directive|define
name|parse_next_arg
parameter_list|()
value|{ \ 	if (argnum> 0) { \ 		if (cur_arg> 1) \ 			fatal(_("must use `count$' on all formats or none")); \ 		arg = the_args[argnum]; \ 	} else if (used_dollar) { \ 		fatal(_("must use `count$' on all formats or none")); \ 		arg = 0;
comment|/* shutup the compiler */
value|\ 	} else if (cur_arg>= num_args) { \ 		arg = 0;
comment|/* shutup the compiler */
value|\ 		toofew = TRUE; \ 		break; \ 	} else { \ 		arg = the_args[cur_arg]; \ 		cur_arg++; \ 	} \ }
name|need_format
operator|=
name|FALSE
expr_stmt|;
name|used_dollar
operator|=
name|FALSE
expr_stmt|;
name|s0
operator|=
name|s1
operator|=
name|fmt_string
expr_stmt|;
while|while
condition|(
name|n0
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|!=
literal|'%'
condition|)
block|{
name|s1
operator|++
expr_stmt|;
continue|continue;
block|}
name|need_format
operator|=
name|TRUE
expr_stmt|;
name|bchunk
argument_list|(
name|s0
argument_list|,
name|s1
operator|-
name|s0
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
name|cur
operator|=
operator|&
name|fw
expr_stmt|;
name|fw
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
literal|0
expr_stmt|;
name|argnum
operator|=
literal|0
expr_stmt|;
name|have_prec
operator|=
name|FALSE
expr_stmt|;
name|signchar
operator|=
name|FALSE
expr_stmt|;
name|zero_flag
operator|=
name|FALSE
expr_stmt|;
name|lj
operator|=
name|alt
operator|=
name|big
operator|=
name|bigbig
operator|=
name|small
operator|=
name|FALSE
expr_stmt|;
name|fill
operator|=
name|sp
expr_stmt|;
name|cp
operator|=
name|cend
expr_stmt|;
name|chbuf
operator|=
name|lchbuf
expr_stmt|;
name|s1
operator|++
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|n0
operator|--
operator|<=
literal|0
condition|)
comment|/* ran out early! */
break|break;
switch|switch
condition|(
name|cs1
operator|=
operator|*
name|s1
operator|++
condition|)
block|{
case|case
operator|(
operator|-
literal|1
operator|)
case|:
comment|/* dummy case to allow for checking */
name|check_pos
label|:
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
break|break;
comment|/* reject as a valid format */
goto|goto
name|retry
goto|;
case|case
literal|'%'
case|:
name|need_format
operator|=
name|FALSE
expr_stmt|;
name|bchunk_one
argument_list|(
literal|"%"
argument_list|)
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* 			 * Only turn on zero_flag if we haven't seen 			 * the field width or precision yet.  Otherwise, 			 * screws up floating point formatting. 			 */
if|if
condition|(
name|cur
operator|==
operator|&
name|fw
condition|)
name|zero_flag
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|lj
condition|)
goto|goto
name|retry
goto|;
comment|/* FALL through */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|prec
operator|>=
literal|0
condition|)
operator|*
name|cur
operator|=
name|cs1
operator|-
literal|'0'
expr_stmt|;
comment|/* 			 * with a negative precision *cur is already set 			 * to -1, so it will remain negative, but we have 			 * to "eat" precision digits in any case 			 */
while|while
condition|(
name|n0
operator|>
literal|0
operator|&&
operator|*
name|s1
operator|>=
literal|'0'
operator|&&
operator|*
name|s1
operator|<=
literal|'9'
condition|)
block|{
operator|--
name|n0
expr_stmt|;
operator|*
name|cur
operator|=
operator|*
name|cur
operator|*
literal|10
operator|+
operator|*
name|s1
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
comment|/* negative precision is discarded */
name|have_prec
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cur
operator|==
operator|&
name|prec
condition|)
name|cur
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n0
operator|==
literal|0
condition|)
comment|/* badly formatted control string */
continue|continue;
goto|goto
name|retry
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|do_traditional
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`$' is not permitted in awk formats"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
operator|&
name|fw
condition|)
block|{
name|argnum
operator|=
name|fw
expr_stmt|;
name|fw
operator|=
literal|0
expr_stmt|;
name|used_dollar
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|argnum
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"arg count with `$' must be> 0"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argnum
operator|>=
name|num_args
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"arg count %d greater than total number of supplied arguments"
argument_list|)
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`$' not permitted after period in format"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'*'
case|:
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|n0
operator|>
literal|0
operator|&&
operator|*
name|s1
operator|&&
name|ISDIGIT
argument_list|(
operator|*
name|s1
argument_list|)
condition|;
name|s1
operator|++
operator|,
name|n0
operator|--
control|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
name|s1
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s1
operator|!=
literal|'$'
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"no `$' supplied for positional field width or precision"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s1
operator|++
expr_stmt|;
name|n0
operator|--
expr_stmt|;
block|}
name|arg
operator|=
name|the_args
index|[
name|val
index|]
expr_stmt|;
block|}
else|else
block|{
name|parse_next_arg
argument_list|()
expr_stmt|;
block|}
operator|*
name|cur
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cur
operator|<
literal|0
operator|&&
name|cur
operator|==
operator|&
name|fw
condition|)
block|{
operator|*
name|cur
operator|=
operator|-
operator|*
name|cur
expr_stmt|;
name|lj
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|==
operator|&
name|prec
condition|)
block|{
if|if
condition|(
operator|*
name|cur
operator|>=
literal|0
condition|)
name|have_prec
operator|=
name|TRUE
expr_stmt|;
else|else
name|have_prec
operator|=
name|FALSE
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|' '
case|:
comment|/* print ' ' or '-' */
comment|/* 'space' flag is ignored */
comment|/* if '+' already present  */
if|if
condition|(
name|signchar
operator|!=
name|FALSE
condition|)
goto|goto
name|check_pos
goto|;
comment|/* FALL THROUGH */
case|case
literal|'+'
case|:
comment|/* print '+' or '-' */
name|signchar
operator|=
name|cs1
expr_stmt|;
goto|goto
name|check_pos
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
operator|&
name|prec
condition|)
block|{
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|fill
operator|=
name|sp
expr_stmt|;
comment|/* if left justified then other */
name|lj
operator|++
expr_stmt|;
comment|/* filling is ignored */
goto|goto
name|check_pos
goto|;
case|case
literal|'.'
case|:
if|if
condition|(
name|cur
operator|!=
operator|&
name|fw
condition|)
break|break;
name|cur
operator|=
operator|&
name|prec
expr_stmt|;
name|have_prec
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'#'
case|:
name|alt
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|check_pos
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|big
condition|)
break|break;
else|else
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"`l' is meaningless in awk formats; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|do_posix
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`l' is not permitted in POSIX awk formats"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|big
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'L'
case|:
if|if
condition|(
name|bigbig
condition|)
break|break;
else|else
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"`L' is meaningless in awk formats; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|do_posix
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`L' is not permitted in POSIX awk formats"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bigbig
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'h'
case|:
if|if
condition|(
name|small
condition|)
break|break;
else|else
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"`h' is meaningless in awk formats; ignored"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|do_posix
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`h' is not permitted in POSIX awk formats"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|small
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'c'
case|:
name|need_format
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zero_flag
operator|&&
operator|!
name|lj
condition|)
name|fill
operator|=
name|zero_string
expr_stmt|;
name|parse_next_arg
argument_list|()
expr_stmt|;
comment|/* user input that looks numeric is numeric */
if|if
condition|(
operator|(
name|arg
operator|->
name|flags
operator|&
operator|(
name|MAYBE_NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
name|MAYBE_NUM
condition|)
operator|(
name|void
operator|)
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|flags
operator|&
name|NUMBER
condition|)
block|{
ifdef|#
directive|ifdef
name|sun386
name|tmp_uval
operator|=
name|arg
operator|->
name|numbr
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|tmp_uval
expr_stmt|;
else|#
directive|else
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|arg
operator|->
name|numbr
expr_stmt|;
endif|#
directive|endif
name|cpbuf
index|[
literal|0
index|]
operator|=
name|uval
expr_stmt|;
name|prec
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|cpbuf
expr_stmt|;
goto|goto
name|pr_tail
goto|;
block|}
if|if
condition|(
name|have_prec
operator|==
name|FALSE
condition|)
name|prec
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|arg
operator|->
name|stlen
condition|)
name|prec
operator|=
name|arg
operator|->
name|stlen
expr_stmt|;
name|cp
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
goto|goto
name|pr_tail
goto|;
case|case
literal|'s'
case|:
name|need_format
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zero_flag
operator|&&
operator|!
name|lj
condition|)
name|fill
operator|=
name|zero_string
expr_stmt|;
name|parse_next_arg
argument_list|()
expr_stmt|;
name|arg
operator|=
name|force_string
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_prec
operator|||
name|prec
operator|>
name|arg
operator|->
name|stlen
condition|)
name|prec
operator|=
name|arg
operator|->
name|stlen
expr_stmt|;
name|cp
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
goto|goto
name|pr_tail
goto|;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|need_format
operator|=
name|FALSE
expr_stmt|;
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 			 * ``The result of converting a zero value with a 			 * precision of zero is no characters.'' 			 */
if|if
condition|(
name|have_prec
operator|&&
name|prec
operator|==
literal|0
operator|&&
name|tmpval
operator|==
literal|0
condition|)
goto|goto
name|pr_tail
goto|;
if|if
condition|(
name|tmpval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tmpval
operator|<
name|LONG_MIN
condition|)
goto|goto
name|out_of_range
goto|;
name|sgn
operator|=
name|TRUE
expr_stmt|;
name|uval
operator|=
operator|-
operator|(
name|unsigned
name|long
operator|)
operator|(
name|long
operator|)
name|tmpval
expr_stmt|;
block|}
else|else
block|{
comment|/* Use !, so that NaNs are out of range. 				   The cast avoids a SunOS 4.1.x cc bug.  */
if|if
condition|(
operator|!
operator|(
name|tmpval
operator|<=
operator|(
name|unsigned
name|long
operator|)
name|ULONG_MAX
operator|)
condition|)
goto|goto
name|out_of_range
goto|;
name|sgn
operator|=
name|FALSE
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|tmpval
expr_stmt|;
block|}
do|do
block|{
operator|*
operator|--
name|cp
operator|=
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
name|uval
operator|%
literal|10
argument_list|)
expr_stmt|;
name|uval
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|uval
operator|>
literal|0
condition|)
do|;
comment|/* add more output digits to match the precision */
if|if
condition|(
name|have_prec
condition|)
block|{
while|while
condition|(
name|cend
operator|-
name|cp
operator|<
name|prec
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|sgn
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|signchar
condition|)
operator|*
operator|--
name|cp
operator|=
name|signchar
expr_stmt|;
comment|/* 			 * When to fill with zeroes is of course not simple. 			 * First: No zero fill if left-justifying. 			 * Next: There seem to be two cases: 			 * 	A '0' without a precision, e.g. %06d 			 * 	A precision with no field width, e.g. %.10d 			 * Any other case, we don't want to fill with zeroes. 			 */
if|if
condition|(
operator|!
name|lj
operator|&&
operator|(
operator|(
name|zero_flag
operator|&&
operator|!
name|have_prec
operator|)
operator|||
operator|(
name|fw
operator|==
literal|0
operator|&&
name|have_prec
operator|)
operator|)
condition|)
name|fill
operator|=
name|zero_string
expr_stmt|;
if|if
condition|(
name|prec
operator|>
name|fw
condition|)
name|fw
operator|=
name|prec
expr_stmt|;
name|prec
operator|=
name|cend
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|fw
operator|>
name|prec
operator|&&
operator|!
name|lj
operator|&&
name|fill
operator|!=
name|sp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|||
name|signchar
operator|)
condition|)
block|{
name|bchunk_one
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|prec
operator|--
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
goto|goto
name|pr_tail
goto|;
case|case
literal|'X'
case|:
name|chbuf
operator|=
name|Uchbuf
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'x'
case|:
name|base
operator|+=
literal|6
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'u'
case|:
name|base
operator|+=
literal|2
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'o'
case|:
name|base
operator|+=
literal|8
expr_stmt|;
name|need_format
operator|=
name|FALSE
expr_stmt|;
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 			 * ``The result of converting a zero value with a 			 * precision of zero is no characters.'' 			 * 			 * If I remember the ANSI C standard, though, 			 * it says that for octal conversions 			 * the precision is artificially increased 			 * to add an extra 0 if # is supplied. 			 * Indeed, in C, 			 * 	printf("%#.0o\n", 0); 			 * prints a single 0. 			 */
if|if
condition|(
operator|!
name|alt
operator|&&
name|have_prec
operator|&&
name|prec
operator|==
literal|0
operator|&&
name|tmpval
operator|==
literal|0
condition|)
goto|goto
name|pr_tail
goto|;
if|if
condition|(
name|tmpval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tmpval
operator|<
name|LONG_MIN
condition|)
goto|goto
name|out_of_range
goto|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|(
name|long
operator|)
name|tmpval
expr_stmt|;
block|}
else|else
block|{
comment|/* Use !, so that NaNs are out of range. 				   The cast avoids a SunOS 4.1.x cc bug.  */
if|if
condition|(
operator|!
operator|(
name|tmpval
operator|<=
operator|(
name|unsigned
name|long
operator|)
name|ULONG_MAX
operator|)
condition|)
goto|goto
name|out_of_range
goto|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|tmpval
expr_stmt|;
block|}
comment|/* 			 * When to fill with zeroes is of course not simple. 			 * First: No zero fill if left-justifying. 			 * Next: There seem to be two cases: 			 * 	A '0' without a precision, e.g. %06d 			 * 	A precision with no field width, e.g. %.10d 			 * Any other case, we don't want to fill with zeroes. 			 */
if|if
condition|(
operator|!
name|lj
operator|&&
operator|(
operator|(
name|zero_flag
operator|&&
operator|!
name|have_prec
operator|)
operator|||
operator|(
name|fw
operator|==
literal|0
operator|&&
name|have_prec
operator|)
operator|)
condition|)
name|fill
operator|=
name|zero_string
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|cp
operator|=
name|chbuf
index|[
name|uval
operator|%
name|base
index|]
expr_stmt|;
name|uval
operator|/=
name|base
expr_stmt|;
block|}
do|while
condition|(
name|uval
operator|>
literal|0
condition|)
do|;
comment|/* add more output digits to match the precision */
if|if
condition|(
name|have_prec
condition|)
block|{
while|while
condition|(
name|cend
operator|-
name|cp
operator|<
name|prec
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|&&
name|tmpval
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
name|cs1
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|sp
condition|)
block|{
name|bchunk
argument_list|(
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
name|fw
operator|-=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|8
condition|)
operator|*
operator|--
name|cp
operator|=
literal|'0'
expr_stmt|;
block|}
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|>
name|fw
condition|)
name|fw
operator|=
name|prec
expr_stmt|;
name|prec
operator|=
name|cend
operator|-
name|cp
expr_stmt|;
name|pr_tail
label|:
if|if
condition|(
operator|!
name|lj
condition|)
block|{
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk_one
argument_list|(
name|fill
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
block|}
name|bchunk
argument_list|(
name|cp
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|)
expr_stmt|;
while|while
condition|(
name|fw
operator|>
name|prec
condition|)
block|{
name|bchunk_one
argument_list|(
name|fill
argument_list|)
expr_stmt|;
name|fw
operator|--
expr_stmt|;
block|}
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
name|out_of_range
label|:
comment|/* out of range - emergency use of %g format */
name|cs1
operator|=
literal|'g'
expr_stmt|;
goto|goto
name|format_float
goto|;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'E'
case|:
name|need_format
operator|=
name|FALSE
expr_stmt|;
name|parse_next_arg
argument_list|()
expr_stmt|;
name|tmpval
operator|=
name|force_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|format_float
label|:
if|if
condition|(
operator|!
name|have_prec
condition|)
name|prec
operator|=
name|DEFAULT_G_PRECISION
expr_stmt|;
name|chksize
argument_list|(
name|fw
operator|+
name|prec
operator|+
literal|9
argument_list|)
expr_stmt|;
comment|/* 9 == slop */
name|cp
operator|=
name|cpbuf
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|lj
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|signchar
condition|)
operator|*
name|cp
operator|++
operator|=
name|signchar
expr_stmt|;
if|if
condition|(
name|alt
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'#'
expr_stmt|;
if|if
condition|(
name|zero_flag
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|"*.*"
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|cs1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|GFMT_WORKAROUND
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obufout
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* GFMT_WORKAROUND */
if|if
condition|(
name|cs1
operator|==
literal|'g'
operator|||
name|cs1
operator|==
literal|'G'
condition|)
name|sgfmt
argument_list|(
name|obufout
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|alt
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obufout
argument_list|,
name|cpbuf
argument_list|,
operator|(
name|int
operator|)
name|fw
argument_list|,
operator|(
name|int
operator|)
name|prec
argument_list|,
operator|(
name|double
operator|)
name|tmpval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GFMT_WORKAROUND */
name|len
operator|=
name|strlen
argument_list|(
name|obufout
argument_list|)
expr_stmt|;
name|ofre
operator|-=
name|len
expr_stmt|;
name|obufout
operator|+=
name|len
expr_stmt|;
name|s0
operator|=
name|s1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|toofew
condition|)
name|fatal
argument_list|(
literal|"%s\n\t`%s'\n\t%*s%s"
argument_list|,
name|_
argument_list|(
literal|"not enough arguments to satisfy format string"
argument_list|)
argument_list|,
name|fmt_string
argument_list|,
name|s1
operator|-
name|fmt_string
operator|-
literal|2
argument_list|,
literal|""
argument_list|,
name|_
argument_list|(
literal|"^ ran out for this one"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
name|need_format
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"[s]printf: format specifier does not have control letter"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|carg
operator|!=
name|NULL
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"too many arguments supplied for format string"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bchunk
argument_list|(
name|s0
argument_list|,
name|s1
operator|-
name|s0
argument_list|)
expr_stmt|;
name|r
operator|=
name|make_str_node
argument_list|(
name|obuf
argument_list|,
name|obufout
operator|-
name|obuf
argument_list|,
name|ALREADY_MALLOCED
argument_list|)
expr_stmt|;
name|r
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|unref
argument_list|(
name|the_args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call_level
operator|--
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|the_args
argument_list|)
expr_stmt|;
name|the_args
operator|=
name|save_args
expr_stmt|;
name|args_size
operator|=
name|save_args_size
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* do_sprintf --- perform sprintf */
end_comment

begin_function
name|NODE
modifier|*
name|do_sprintf
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|r
decl_stmt|;
name|NODE
modifier|*
name|sfmt
init|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
decl_stmt|;
name|r
operator|=
name|format_tree
argument_list|(
name|sfmt
operator|->
name|stptr
argument_list|,
name|sfmt
operator|->
name|stlen
argument_list|,
name|tree
operator|->
name|rnode
argument_list|,
name|tree
operator|->
name|printf_count
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|sfmt
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* do_printf --- perform printf, including redirection */
end_comment

begin_function
name|void
name|do_printf
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|do_traditional
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"printf: no arguments"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* bwk accepts it silently */
block|}
name|fatal
argument_list|(
name|_
argument_list|(
literal|"printf: no arguments"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
name|int
name|errflg
decl_stmt|;
comment|/* not used, sigh */
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|errflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|rp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
block|}
else|else
return|return;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|tree
operator|->
name|lnode
operator|->
name|printf_count
operator|=
name|tree
operator|->
name|printf_count
expr_stmt|;
name|tree
operator|=
name|do_sprintf
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|efwrite
argument_list|(
name|tree
operator|->
name|stptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|tree
operator|->
name|stlen
argument_list|,
name|fp
argument_list|,
literal|"printf"
argument_list|,
name|rp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
operator|)
operator|!=
literal|0
condition|)
name|fflush
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_sqrt --- do the sqrt function */
end_comment

begin_function
name|NODE
modifier|*
name|do_sqrt
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|arg
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"sqrt: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|0.0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"sqrt: called with negative argument %g"
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|sqrt
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_substr --- do the substr function */
end_comment

begin_function
name|NODE
modifier|*
name|do_substr
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|NODE
modifier|*
name|r
decl_stmt|;
specifier|register
name|size_t
name|indx
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|double
name|d_index
decl_stmt|,
name|d_length
decl_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d_index
operator|=
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_index
operator|<
literal|1.0
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: start index %g is invalid, using 1"
argument_list|)
argument_list|,
name|d_index
argument_list|)
expr_stmt|;
name|d_index
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_lint
operator|&&
name|double_to_int
argument_list|(
name|d_index
argument_list|)
operator|!=
name|d_index
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: non-integer start index %g will be truncated"
argument_list|)
argument_list|,
name|d_index
argument_list|)
expr_stmt|;
name|indx
operator|=
name|d_index
operator|-
literal|1
expr_stmt|;
comment|/* awk indices are from 1, C's are from 0 */
if|if
condition|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|==
name|NULL
condition|)
block|{
comment|/* third arg. missing */
comment|/* use remainder of string */
name|length
operator|=
name|t1
operator|->
name|stlen
operator|-
name|indx
expr_stmt|;
block|}
else|else
block|{
name|t3
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d_length
operator|=
name|force_number
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t3
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_length
operator|<=
literal|0.0
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: length %g is<= 0"
argument_list|)
argument_list|,
name|d_length
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|Nnull_string
return|;
block|}
if|if
condition|(
name|do_lint
operator|&&
name|double_to_int
argument_list|(
name|d_length
argument_list|)
operator|!=
name|d_length
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: non-integer length %g will be truncated"
argument_list|)
argument_list|,
name|d_length
argument_list|)
expr_stmt|;
name|length
operator|=
name|d_length
expr_stmt|;
block|}
if|if
condition|(
name|t1
operator|->
name|stlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: source string is zero length"
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|Nnull_string
return|;
block|}
if|if
condition|(
operator|(
name|indx
operator|+
name|length
operator|)
operator|>
name|t1
operator|->
name|stlen
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: length %d at start index %d exceeds length of first argument (%d)"
argument_list|)
argument_list|,
name|length
argument_list|,
name|indx
operator|+
literal|1
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|length
operator|=
name|t1
operator|->
name|stlen
operator|-
name|indx
expr_stmt|;
block|}
if|if
condition|(
name|indx
operator|>=
name|t1
operator|->
name|stlen
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"substr: start index %d is past end of string"
argument_list|)
argument_list|,
name|indx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|Nnull_string
return|;
block|}
name|r
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
operator|+
name|indx
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* do_strftime --- format a time stamp */
end_comment

begin_function
name|NODE
modifier|*
name|do_strftime
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|time_t
name|fclock
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|size_t
name|buflen
decl_stmt|,
name|bufsize
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* FIXME: One day make %d be %e, after C 99 is common. */
specifier|static
name|char
name|def_format
index|[]
init|=
literal|"%a %b %d %H:%M:%S %Z %Y"
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|formatlen
decl_stmt|;
comment|/* set defaults first */
name|format
operator|=
name|def_format
expr_stmt|;
comment|/* traditional date format */
name|formatlen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|fclock
argument_list|)
expr_stmt|;
comment|/* current time of day */
name|t1
operator|=
name|t2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
comment|/* have args */
if|if
condition|(
name|tree
operator|->
name|lnode
operator|!=
name|NULL
condition|)
block|{
name|NODE
modifier|*
name|tmp
init|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"strftime: recieved non-string first argument"
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|format
operator|=
name|t1
operator|->
name|stptr
expr_stmt|;
name|formatlen
operator|=
name|t1
operator|->
name|stlen
expr_stmt|;
if|if
condition|(
name|formatlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"strftime: received empty format string"
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_string
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|t2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"strftime: recieved non-numeric second argument"
argument_list|)
argument_list|)
expr_stmt|;
name|fclock
operator|=
operator|(
name|time_t
operator|)
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|fclock
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|bufp
operator|=
literal|'\0'
expr_stmt|;
name|buflen
operator|=
name|strftime
argument_list|(
name|bufp
argument_list|,
name|bufsize
argument_list|,
name|format
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|/* 		 * buflen can be zero EITHER because there's not enough 		 * room in the string, or because the control command 		 * goes to the empty string. Make a reasonable guess that 		 * if the buffer is 1024 times bigger than the length of the 		 * format string, it's not failing for lack of room. 		 * Thanks to Paul Eggert for pointing out this issue. 		 */
if|if
condition|(
name|buflen
operator|>
literal|0
operator|||
name|bufsize
operator|>=
literal|1024
operator|*
name|formatlen
condition|)
break|break;
name|bufsize
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|bufp
operator|==
name|buf
condition|)
name|emalloc
argument_list|(
name|bufp
argument_list|,
name|char
operator|*
argument_list|,
name|bufsize
argument_list|,
literal|"do_strftime"
argument_list|)
expr_stmt|;
else|else
name|erealloc
argument_list|(
name|bufp
argument_list|,
name|char
operator|*
argument_list|,
name|bufsize
argument_list|,
literal|"do_strftime"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|tmp_string
argument_list|(
name|bufp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* do_systime --- get the time of day */
end_comment

begin_function
name|NODE
modifier|*
name|do_systime
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|time_t
name|lclock
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|lclock
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|lclock
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_mktime --- turn a time string into a timestamp */
end_comment

begin_function
name|NODE
modifier|*
name|do_mktime
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|;
name|struct
name|tm
name|then
decl_stmt|;
name|long
name|year
decl_stmt|;
name|int
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|,
name|count
decl_stmt|;
name|int
name|dst
init|=
operator|-
literal|1
decl_stmt|;
comment|/* default is unknown */
name|time_t
name|then_stamp
decl_stmt|;
name|char
name|save
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|t1
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"mktime: received non-string argument"
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|save
operator|=
name|t1
operator|->
name|stptr
index|[
name|t1
operator|->
name|stlen
index|]
expr_stmt|;
name|t1
operator|->
name|stptr
index|[
name|t1
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|=
name|sscanf
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
literal|"%ld %d %d %d %d %d %d"
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|month
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|t1
operator|->
name|stptr
index|[
name|t1
operator|->
name|stlen
index|]
operator|=
name|save
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|6
operator|||
name|month
operator|<
name|month
operator|-
literal|1
operator|||
name|year
operator|<
name|year
operator|-
literal|1900
operator|||
name|year
operator|-
literal|1900
operator|!=
call|(
name|int
call|)
argument_list|(
name|year
operator|-
literal|1900
argument_list|)
condition|)
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1
argument_list|)
return|;
name|memset
argument_list|(
operator|&
name|then
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|then
argument_list|)
argument_list|)
expr_stmt|;
name|then
operator|.
name|tm_sec
operator|=
name|second
expr_stmt|;
name|then
operator|.
name|tm_min
operator|=
name|minute
expr_stmt|;
name|then
operator|.
name|tm_hour
operator|=
name|hour
expr_stmt|;
name|then
operator|.
name|tm_mday
operator|=
name|day
expr_stmt|;
name|then
operator|.
name|tm_mon
operator|=
name|month
operator|-
literal|1
expr_stmt|;
name|then
operator|.
name|tm_year
operator|=
name|year
operator|-
literal|1900
expr_stmt|;
name|then
operator|.
name|tm_isdst
operator|=
name|dst
expr_stmt|;
name|then_stamp
operator|=
name|mktime
argument_list|(
operator|&
name|then
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|then_stamp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_system --- run an external command */
end_comment

begin_function
name|NODE
modifier|*
name|do_system
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
name|save
decl_stmt|;
operator|(
name|void
operator|)
name|flush_io
argument_list|()
expr_stmt|;
comment|/* so output is synchronous with gawk's */
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"system: recieved non-string argument"
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
operator|*
name|cmd
condition|)
block|{
comment|/* insure arg to system is zero-terminated */
comment|/* 		 * From: David Trueman<david@cs.dal.ca> 		 * To: arnold@cc.gatech.edu (Arnold Robbins) 		 * Date: Wed, 3 Nov 1993 12:49:41 -0400 		 *  		 * It may not be necessary to save the character, but 		 * I'm not sure.  It would normally be the field 		 * separator.  If the parse has not yet gone beyond 		 * that, it could mess up (although I doubt it).  If 		 * FIELDWIDTHS is being used, it might be the first 		 * character of the next field.  Unless someone wants 		 * to check it out exhaustively, I suggest saving it 		 * for now... 		 */
name|save
operator|=
name|cmd
index|[
name|tmp
operator|->
name|stlen
index|]
expr_stmt|;
name|cmd
index|[
name|tmp
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|os_restore_mode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|ret
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|BINMODE
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|os_setbinmode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|cmd
index|[
name|tmp
operator|->
name|stlen
index|]
operator|=
name|save
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fmt_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declared in eval.c */
end_comment

begin_comment
comment|/* do_print --- print items, separated by OFS, terminated with ORS */
end_comment

begin_function
name|void
name|do_print
parameter_list|(
specifier|register
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
specifier|register
name|NODE
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|numnodes
decl_stmt|,
name|i
decl_stmt|;
name|NODE
modifier|*
name|save
decl_stmt|;
name|NODE
modifier|*
name|tval
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
condition|)
block|{
name|int
name|errflg
decl_stmt|;
comment|/* not used, sigh */
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|errflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|=
name|rp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
block|}
else|else
return|return;
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * General idea is to evaluate all the expressions first and 	 * then print them, otherwise you get suprising behavior. 	 * See test/prtoeval.awk for an example program. 	 */
name|save
operator|=
name|tree
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
for|for
control|(
name|numnodes
operator|=
literal|0
init|;
name|tree
operator|!=
name|NULL
condition|;
name|tree
operator|=
name|tree
operator|->
name|rnode
control|)
name|numnodes
operator|++
expr_stmt|;
name|emalloc
argument_list|(
name|t
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
name|numnodes
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"do_print"
argument_list|)
expr_stmt|;
name|tree
operator|=
name|save
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tree
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|tree
operator|=
name|tree
operator|->
name|rnode
control|)
block|{
name|NODE
modifier|*
name|n
decl_stmt|;
comment|/* Here lies the wumpus. R.I.P. */
name|n
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t
index|[
name|i
index|]
operator|=
name|dupnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|NUMBER
operator||
name|STRING
operator|)
operator|)
operator|==
name|NUMBER
condition|)
block|{
if|if
condition|(
name|OFMTidx
operator|==
name|CONVFMTidx
condition|)
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|tval
operator|=
name|tmp_number
argument_list|(
name|t
index|[
name|i
index|]
operator|->
name|numbr
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t
index|[
name|i
index|]
operator|=
name|format_val
argument_list|(
name|OFMT
argument_list|,
name|OFMTidx
argument_list|,
name|tval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numnodes
condition|;
name|i
operator|++
control|)
block|{
name|efwrite
argument_list|(
name|t
index|[
name|i
index|]
operator|->
name|stptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|t
index|[
name|i
index|]
operator|->
name|stlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|numnodes
operator|-
literal|1
operator|&&
name|OFSlen
operator|>
literal|0
condition|)
name|efwrite
argument_list|(
name|OFS
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|OFSlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ORSlen
operator|>
literal|0
condition|)
name|efwrite
argument_list|(
name|ORS
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|ORSlen
argument_list|,
name|fp
argument_list|,
literal|"print"
argument_list|,
name|rp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
operator|)
operator|!=
literal|0
condition|)
name|fflush
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_tolower --- lower case a string */
end_comment

begin_function
name|NODE
modifier|*
name|do_tolower
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|t1
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"tolower: recieved non-string argument"
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t2
operator|->
name|stptr
operator|,
name|cp2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|t2
operator|->
name|stptr
operator|+
name|t2
operator|->
name|stlen
operator|)
init|;
name|cp
operator|<
name|cp2
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|TOLOWER
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_comment
comment|/* do_toupper --- upper case a string */
end_comment

begin_function
name|NODE
modifier|*
name|do_toupper
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|t1
operator|->
name|flags
operator|&
operator|(
name|STRING
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"toupper: recieved non-string argument"
argument_list|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tmp_string
argument_list|(
name|t1
operator|->
name|stptr
argument_list|,
name|t1
operator|->
name|stlen
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|t2
operator|->
name|stptr
operator|,
name|cp2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|t2
operator|->
name|stptr
operator|+
name|t2
operator|->
name|stlen
operator|)
init|;
name|cp
operator|<
name|cp2
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|ISLOWER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|TOUPPER
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|t2
return|;
block|}
end_function

begin_comment
comment|/* do_atan2 --- do the atan2 function */
end_comment

begin_function
name|NODE
modifier|*
name|do_atan2
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|double
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|t1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|t2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|t1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"atan2: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"atan2: received non-numeric second argument"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d1
operator|=
name|force_number
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|d2
operator|=
name|force_number
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|atan2
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_sin --- do the sin function */
end_comment

begin_function
name|NODE
modifier|*
name|do_sin
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"sin: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|sin
argument_list|(
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_cos --- do the cos function */
end_comment

begin_function
name|NODE
modifier|*
name|do_cos
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"cos: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|cos
argument_list|(
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_rand --- do the rand function */
end_comment

begin_decl_stmt
specifier|static
name|int
name|firstrand
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|state
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|NODE
modifier|*
name|do_rand
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|firstrand
condition|)
block|{
operator|(
name|void
operator|)
name|initstate
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
name|state
argument_list|,
sizeof|sizeof
name|state
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|firstrand
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|random
argument_list|()
operator|/
name|GAWK_RANDOM_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_srand --- seed the random number generator */
end_comment

begin_function
name|NODE
modifier|*
name|do_srand
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|static
name|long
name|save_seed
init|=
literal|1
decl_stmt|;
name|long
name|ret
init|=
name|save_seed
decl_stmt|;
comment|/* SVR4 awk srand returns previous seed */
if|if
condition|(
name|firstrand
condition|)
block|{
operator|(
name|void
operator|)
name|initstate
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|,
name|state
argument_list|,
sizeof|sizeof
name|state
argument_list|)
expr_stmt|;
comment|/* don't need to srandom(1), we're changing the seed below */
name|firstrand
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|setstate
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
name|srandom
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|save_seed
operator|=
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|save_seed
operator|=
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"srand: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|save_seed
operator|=
operator|(
name|long
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_match --- match a regexp, set RSTART and RLENGTH,  * 	optional third arg is array filled with text of  * 	subpatterns enclosed in parens.  */
end_comment

begin_function
name|NODE
modifier|*
name|do_match
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|dest
decl_stmt|,
modifier|*
name|it
decl_stmt|;
name|int
name|rstart
decl_stmt|,
name|len
decl_stmt|,
name|ii
decl_stmt|;
name|AWKNUM
name|rlength
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|regoff_t
name|s
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|rp
operator|=
name|re_update
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|dest
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
comment|/* 3rd optional arg for the subpatterns */
name|dest
operator|=
name|tree
operator|->
name|rnode
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|dest
operator|=
name|stack_ptr
index|[
name|dest
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|==
name|Node_array_ref
condition|)
name|dest
operator|=
name|dest
operator|->
name|orig_array
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|type
operator|!=
name|Node_var
operator|&&
name|dest
operator|->
name|type
operator|!=
name|Node_var_array
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"match: third argument is not an array"
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|type
operator|=
name|Node_var_array
expr_stmt|;
name|assoc_clear
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|rstart
operator|=
name|research
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t1
operator|->
name|stlen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstart
operator|>=
literal|0
condition|)
block|{
comment|/* match succeded */
name|rstart
operator|++
expr_stmt|;
comment|/* 1-based indexing */
name|rlength
operator|=
name|REEND
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|)
operator|-
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* Build the array only if the caller wants the optional subpatterns */
if|if
condition|(
name|dest
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|ii
operator|=
literal|0
init|;
operator|(
name|s
operator|=
name|SUBPATSTART
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
name|ii
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|;
name|ii
operator|++
control|)
block|{
name|start
operator|=
name|t1
operator|->
name|stptr
operator|+
name|s
expr_stmt|;
name|len
operator|=
name|SUBPATEND
argument_list|(
name|rp
argument_list|,
name|t1
operator|->
name|stptr
argument_list|,
name|ii
argument_list|)
operator|-
name|s
expr_stmt|;
name|it
operator|=
name|make_string
argument_list|(
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|it
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
operator|*
name|assoc_lookup
argument_list|(
name|dest
argument_list|,
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|ii
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
operator|=
name|it
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* match failed */
name|rstart
operator|=
literal|0
expr_stmt|;
name|rlength
operator|=
operator|-
literal|1.0
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|RSTART_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RSTART_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|rstart
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|RLENGTH_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RLENGTH_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
name|rlength
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|rstart
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* sub_common --- the common code (does the work) for sub, gsub, and gensub */
end_comment

begin_comment
comment|/*  * Gsub can be tricksy; particularly when handling the case of null strings.  * The following awk code was useful in debugging problems.  It is too bad  * that it does not readily translate directly into the C code, below.  *   * #! /usr/local/bin/mawk -f  *   * BEGIN {  * 	TRUE = 1; FALSE = 0  * 	print "--->", mygsub("abc", "b+", "FOO")  * 	print "--->", mygsub("abc", "x*", "X")  * 	print "--->", mygsub("abc", "b*", "X")  * 	print "--->", mygsub("abc", "c", "X")  * 	print "--->", mygsub("abc", "c+", "X")  * 	print "--->", mygsub("abc", "x*$", "X")  * }  *   * function mygsub(str, regex, replace,	origstr, newstr, eosflag, nonzeroflag)  * {  * 	origstr = str;  * 	eosflag = nonzeroflag = FALSE  * 	while (match(str, regex)) {  * 		if (RLENGTH> 0) {	# easy case  * 			nonzeroflag = TRUE  * 			if (RSTART == 1) {	# match at front of string  * 				newstr = newstr replace  * 			} else {  * 				newstr = newstr substr(str, 1, RSTART-1) replace  * 			}  * 			str = substr(str, RSTART+RLENGTH)  * 		} else if (nonzeroflag) {  * 			# last match was non-zero in length, and at the  * 			# current character, we get a zero length match,  * 			# which we don't really want, so skip over it  * 			newstr = newstr substr(str, 1, 1)  * 			str = substr(str, 2)  * 			nonzeroflag = FALSE  * 		} else {  * 			# 0-length match  * 			if (RSTART == 1) {  * 				newstr = newstr replace substr(str, 1, 1)  * 				str = substr(str, 2)  * 			} else {  * 				return newstr str replace  * 			}  * 		}  * 		if (length(str) == 0)  * 			if (eosflag)  * 				break;  * 			else  * 				eosflag = TRUE  * 	}  * 	if (length(str)> 0)  * 		newstr = newstr str	# rest of string  *   * 	return newstr  * }  */
end_comment

begin_comment
comment|/*  * NB: `howmany' conflicts with a SunOS 4.x macro in<sys/param.h>.  */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|sub_common
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|,
name|int
name|how_many
parameter_list|,
name|int
name|backdigs
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
specifier|register
name|char
modifier|*
name|matchend
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|matchstart
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|textlen
decl_stmt|;
name|char
modifier|*
name|repl
decl_stmt|;
name|char
modifier|*
name|replend
decl_stmt|;
name|size_t
name|repllen
decl_stmt|;
name|int
name|sofar
decl_stmt|;
name|int
name|ampersands
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|NODE
modifier|*
name|s
decl_stmt|;
comment|/* subst. pattern */
name|NODE
modifier|*
name|t
decl_stmt|;
comment|/* string to make sub. in; $0 if none given */
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
init|=
operator|&
name|tree
decl_stmt|;
comment|/* value not used -- just different from NULL */
name|int
name|priv
init|=
name|FALSE
decl_stmt|;
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|int
name|global
init|=
operator|(
name|how_many
operator|==
operator|-
literal|1
operator|)
decl_stmt|;
name|long
name|current
decl_stmt|;
name|int
name|lastmatchnonzero
decl_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|rp
operator|=
name|re_update
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|s
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|t
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do the search early to avoid work on non-match */
if|if
condition|(
name|research
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|stlen
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
operator|>
name|t
operator|->
name|stlen
condition|)
block|{
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
if|if
condition|(
name|tmp
operator|->
name|type
operator|==
name|Node_val
condition|)
name|lhs
operator|=
name|NULL
expr_stmt|;
else|else
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tmp
argument_list|,
operator|&
name|after_assign
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|STRING
expr_stmt|;
comment|/* 	 * create a private copy of the string 	 */
if|if
condition|(
name|t
operator|->
name|stref
operator|>
literal|1
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|PERM
operator||
name|FIELD
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|copynode
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|tmp
expr_stmt|;
name|priv
operator|=
name|TRUE
expr_stmt|;
block|}
name|text
operator|=
name|t
operator|->
name|stptr
expr_stmt|;
name|textlen
operator|=
name|t
operator|->
name|stlen
expr_stmt|;
name|buflen
operator|=
name|textlen
operator|+
literal|2
expr_stmt|;
name|s
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|repl
operator|=
name|s
operator|->
name|stptr
expr_stmt|;
name|replend
operator|=
name|repl
operator|+
name|s
operator|->
name|stlen
expr_stmt|;
name|repllen
operator|=
name|replend
operator|-
name|repl
expr_stmt|;
name|emalloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
operator|+
literal|2
argument_list|,
literal|"sub_common"
argument_list|)
expr_stmt|;
name|buf
index|[
name|buflen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
name|buflen
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ampersands
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|repl
init|;
name|scan
operator|<
name|replend
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
literal|'&'
condition|)
block|{
name|repllen
operator|--
expr_stmt|;
name|ampersands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|backdigs
condition|)
block|{
comment|/* gensub, behave sanely */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|scan
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|ampersands
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* \q for any q --> q */
name|repllen
operator|--
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* (proposed) posix '96 mode */
if|if
condition|(
name|strncmp
argument_list|(
name|scan
argument_list|,
literal|"\\\\\\&"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* \\\& --> \& */
name|repllen
operator|-=
literal|2
expr_stmt|;
name|scan
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|scan
argument_list|,
literal|"\\\\&"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* \\& --> \<string> */
name|ampersands
operator|++
expr_stmt|;
name|repllen
operator|--
expr_stmt|;
name|scan
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* \& -->& */
name|repllen
operator|--
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
comment|/* else 					leave alone, it goes into the output */
block|}
block|}
block|}
name|lastmatchnonzero
operator|=
name|FALSE
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|current
operator|=
literal|1
init|;
condition|;
name|current
operator|++
control|)
block|{
name|matches
operator|++
expr_stmt|;
name|matchstart
operator|=
name|t
operator|->
name|stptr
operator|+
name|RESTART
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|matchend
operator|=
name|t
operator|->
name|stptr
operator|+
name|REEND
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* 		 * create the result, copying in parts of the original 		 * string  		 */
name|len
operator|=
name|matchstart
operator|-
name|text
operator|+
name|repllen
operator|+
name|ampersands
operator|*
operator|(
name|matchend
operator|-
name|matchstart
operator|)
expr_stmt|;
name|sofar
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|buflen
operator|<
operator|(
name|sofar
operator|+
name|len
operator|+
literal|1
operator|)
condition|)
block|{
name|buflen
operator|*=
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
argument_list|,
literal|"sub_common"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|sofar
expr_stmt|;
block|}
for|for
control|(
name|scan
operator|=
name|text
init|;
name|scan
operator|<
name|matchstart
condition|;
name|scan
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
if|if
condition|(
name|global
operator|||
name|current
operator|==
name|how_many
condition|)
block|{
comment|/* 			 * If the current match matched the null string, 			 * and the last match didn't and did a replacement, 			 * then skip this one. 			 */
if|if
condition|(
name|lastmatchnonzero
operator|&&
name|matchstart
operator|==
name|matchend
condition|)
block|{
name|lastmatchnonzero
operator|=
name|FALSE
expr_stmt|;
name|matches
operator|--
expr_stmt|;
goto|goto
name|empty
goto|;
block|}
comment|/* 			 * If replacing all occurrences, or this is the 			 * match we want, copy in the replacement text, 			 * making substitutions as we go. 			 */
for|for
control|(
name|scan
operator|=
name|repl
init|;
name|scan
operator|<
name|replend
condition|;
name|scan
operator|++
control|)
if|if
condition|(
operator|*
name|scan
operator|==
literal|'&'
condition|)
for|for
control|(
name|cp
operator|=
name|matchstart
init|;
name|cp
operator|<
name|matchend
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|backdigs
condition|)
block|{
comment|/* gensub, behave sanely */
if|if
condition|(
name|ISDIGIT
argument_list|(
name|scan
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|dig
init|=
name|scan
index|[
literal|1
index|]
operator|-
literal|'0'
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|start
operator|=
name|t
operator|->
name|stptr
operator|+
name|SUBPATSTART
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
name|dig
argument_list|)
expr_stmt|;
name|end
operator|=
name|t
operator|->
name|stptr
operator|+
name|SUBPATEND
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
name|dig
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
else|else
comment|/* \q for any q --> q */
operator|*
name|bp
operator|++
operator|=
operator|*
operator|++
name|scan
expr_stmt|;
block|}
else|else
block|{
comment|/* posix '96 mode, bleah */
if|if
condition|(
name|strncmp
argument_list|(
name|scan
argument_list|,
literal|"\\\\\\&"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* \\\& --> \& */
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'&'
expr_stmt|;
name|scan
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|scan
argument_list|,
literal|"\\\\&"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* \\& --> \<string> */
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|matchstart
init|;
name|cp
operator|<
name|matchend
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
name|scan
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scan
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* \& -->& */
operator|*
name|bp
operator|++
operator|=
literal|'&'
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
block|}
block|}
else|else
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
if|if
condition|(
name|matchstart
operator|!=
name|matchend
condition|)
name|lastmatchnonzero
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * don't want this match, skip over it by copying 			 * in current text. 			 */
for|for
control|(
name|cp
operator|=
name|matchstart
init|;
name|cp
operator|<
name|matchend
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|empty
label|:
comment|/* catch the case of gsub(//, "blah", whatever), i.e. empty regexp */
if|if
condition|(
name|matchstart
operator|==
name|matchend
operator|&&
name|matchend
operator|<
name|text
operator|+
name|textlen
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|matchend
expr_stmt|;
name|matchend
operator|++
expr_stmt|;
block|}
name|textlen
operator|=
name|text
operator|+
name|textlen
operator|-
name|matchend
expr_stmt|;
name|text
operator|=
name|matchend
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|>=
name|how_many
operator|&&
operator|!
name|global
operator|)
operator|||
operator|(
operator|(
name|long
operator|)
name|textlen
operator|<=
literal|0
operator|&&
name|matchstart
operator|==
name|matchend
operator|)
operator|||
name|research
argument_list|(
name|rp
argument_list|,
name|t
operator|->
name|stptr
argument_list|,
name|text
operator|-
name|t
operator|->
name|stptr
argument_list|,
name|textlen
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|sofar
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|buflen
operator|-
name|sofar
operator|-
name|textlen
operator|-
literal|1
condition|)
block|{
name|buflen
operator|=
name|sofar
operator|+
name|textlen
operator|+
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|buflen
argument_list|,
literal|"sub_common"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|sofar
expr_stmt|;
block|}
for|for
control|(
name|scan
operator|=
name|matchend
init|;
name|scan
operator|<
name|text
operator|+
name|textlen
condition|;
name|scan
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|textlen
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|t
operator|->
name|stptr
operator|=
name|buf
expr_stmt|;
name|t
operator|->
name|stlen
operator|=
name|textlen
expr_stmt|;
name|free_temp
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|>
literal|0
operator|&&
name|lhs
condition|)
block|{
if|if
condition|(
name|priv
condition|)
block|{
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|after_assign
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NUM
operator||
name|NUMBER
operator|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|matches
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_gsub --- global substitution */
end_comment

begin_function
name|NODE
modifier|*
name|do_gsub
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
return|return
name|sub_common
argument_list|(
name|tree
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_sub --- single substitution */
end_comment

begin_function
name|NODE
modifier|*
name|do_sub
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
return|return
name|sub_common
argument_list|(
name|tree
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_gensub --- fix up the tree for sub_common for the gensub function */
end_comment

begin_function
name|NODE
modifier|*
name|do_gensub
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|n3
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|target
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|long
name|how_many
init|=
literal|1
decl_stmt|;
comment|/* default is one substitution */
name|double
name|d
decl_stmt|;
comment|/* 	 * We have to pull out the value of the global flag, and 	 * build up a tree without the flag in it, turning it into the 	 * kind of tree that sub_common() expects.  It helps to draw 	 * a picture of this ... 	 */
name|n1
operator|=
operator|*
name|tree
expr_stmt|;
name|n2
operator|=
operator|*
operator|(
name|tree
operator|->
name|rnode
operator|)
expr_stmt|;
name|n1
operator|.
name|rnode
operator|=
operator|&
name|n2
expr_stmt|;
name|t
operator|=
name|tree_eval
argument_list|(
name|n2
operator|.
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
comment|/* value of global flag */
name|tmp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|n2
operator|.
name|rnode
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* target */
comment|/* 	 * We make copy of the original target string, and pass that 	 * in to sub_common() as the target to make the substitution in. 	 * We will then return the result string as the return value of 	 * this function. 	 */
name|target
operator|=
name|make_string
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|n3
operator|=
operator|*
operator|(
name|n2
operator|.
name|rnode
operator|->
name|rnode
operator|)
expr_stmt|;
name|n3
operator|.
name|lnode
operator|=
name|target
expr_stmt|;
name|n2
operator|.
name|rnode
operator|=
operator|&
name|n3
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|STR
operator||
name|STRING
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|stlen
operator|>
literal|0
operator|&&
operator|(
name|t
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|t
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|'G'
operator|)
condition|)
name|how_many
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|how_many
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
name|force_number
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|how_many
operator|=
name|d
expr_stmt|;
else|else
name|how_many
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"gensub: 3rd argument of 0 treated as 1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sub_common
argument_list|(
operator|&
name|n1
argument_list|,
name|how_many
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|ret
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we don't care what sub_common() returns, since the 	 * easiest thing for the programmer is to return the string, even 	 * if no substitutions were done. 	 */
name|target
operator|->
name|flags
operator||=
name|TEMP
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GFMT_WORKAROUND
end_ifdef

begin_comment
comment|/*  * printf's %g format [can't rely on gcvt()]  *	caveat: don't use as argument to *printf()!  * 'format' string HAS to be of "<flags>*.*g" kind, or we bomb!  */
end_comment

begin_function
specifier|static
name|void
name|sgfmt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
comment|/* return buffer; assumed big enough to hold result */
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|alt
parameter_list|,
comment|/* use alternate form flag */
name|int
name|fwidth
parameter_list|,
comment|/* field width in a format */
name|int
name|prec
parameter_list|,
comment|/* indicates desired significant digits, not decimal places */
name|double
name|g
parameter_list|)
comment|/* value to format */
block|{
name|char
name|dform
index|[
literal|40
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|gpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|again
init|=
name|FALSE
decl_stmt|;
name|strncpy
argument_list|(
name|dform
argument_list|,
name|format
argument_list|,
sizeof|sizeof
name|dform
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dform
index|[
sizeof|sizeof
name|dform
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|gpos
operator|=
name|strrchr
argument_list|(
name|dform
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
literal|0.0
operator|&&
operator|!
name|alt
condition|)
block|{
comment|/* easy special case */
operator|*
name|gpos
operator|++
operator|=
literal|'d'
expr_stmt|;
operator|*
name|gpos
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|dform
argument_list|,
name|fwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* advance to location of 'g' in the format */
while|while
condition|(
operator|*
name|gpos
operator|&&
operator|*
name|gpos
operator|!=
literal|'g'
operator|&&
operator|*
name|gpos
operator|!=
literal|'G'
condition|)
name|gpos
operator|++
expr_stmt|;
if|if
condition|(
name|prec
operator|<=
literal|0
condition|)
comment|/* negative precision is ignored */
name|prec
operator|=
operator|(
name|prec
operator|<
literal|0
condition|?
name|DEFAULT_G_PRECISION
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|gpos
operator|==
literal|'G'
condition|)
name|again
operator|=
name|TRUE
expr_stmt|;
comment|/* start with 'e' format (it'll provide nice exponent) */
operator|*
name|gpos
operator|=
literal|'e'
expr_stmt|;
name|prec
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|dform
argument_list|,
name|fwidth
argument_list|,
name|prec
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* find exponent  */
name|int
name|expn
init|=
name|atoi
argument_list|(
name|e
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* fetch exponent */
if|if
condition|(
name|expn
operator|>=
operator|-
literal|4
operator|&&
name|expn
operator|<=
name|prec
condition|)
block|{
comment|/* per K&R2, B1.2 */
comment|/* switch to 'f' format and re-do */
operator|*
name|gpos
operator|=
literal|'f'
expr_stmt|;
name|prec
operator|-=
name|expn
expr_stmt|;
comment|/* decimal precision */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|dform
argument_list|,
name|fwidth
argument_list|,
name|prec
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|e
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|e
operator|==
literal|' '
condition|)
continue|continue;
name|e
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|again
condition|)
operator|*
name|gpos
operator|=
literal|'E'
expr_stmt|;
comment|/* if 'alt' in force, then trailing zeros are not removed */
if|if
condition|(
operator|!
name|alt
operator|&&
operator|(
name|d
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* throw away an excess of precision */
for|for
control|(
name|p
operator|=
name|e
init|;
name|p
operator|>
name|d
operator|&&
operator|*
operator|--
name|p
operator|==
literal|'0'
condition|;
control|)
name|prec
operator|--
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|p
condition|)
name|prec
operator|--
expr_stmt|;
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
literal|0
expr_stmt|;
comment|/* and do that once again */
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|again
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|dform
argument_list|,
name|fwidth
argument_list|,
name|prec
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GFMT_WORKAROUND */
end_comment

begin_define
define|#
directive|define
name|BITS_PER_BYTE
value|8
end_define

begin_comment
comment|/* if not true, you lose. too bad. */
end_comment

begin_comment
comment|/* do_lshift --- perform a<< operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_lshift
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|unsigned
name|long
name|uval
decl_stmt|,
name|ushift
decl_stmt|,
name|res
decl_stmt|;
name|AWKNUM
name|val
decl_stmt|,
name|shift
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_number
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|shift
operator|=
name|force_number
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"lshift: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"lshift: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|shift
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"lshift(%lf, %lf): negative values will give strange results"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|val
argument_list|)
operator|!=
name|val
operator|||
name|double_to_int
argument_list|(
name|shift
argument_list|)
operator|!=
name|shift
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"lshift(%lf, %lf): fractional values will be truncated"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
operator|(
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|BITS_PER_BYTE
operator|)
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"lshift(%lf, %lf): too large shift value will give strange results"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
name|ushift
operator|=
operator|(
name|unsigned
name|long
operator|)
name|shift
expr_stmt|;
name|res
operator|=
name|uval
operator|<<
name|ushift
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_rshift --- perform a>> operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_rshift
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|unsigned
name|long
name|uval
decl_stmt|,
name|ushift
decl_stmt|,
name|res
decl_stmt|;
name|AWKNUM
name|val
decl_stmt|,
name|shift
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_number
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|shift
operator|=
name|force_number
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"rshift: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"rshift: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|shift
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"rshift(%lf, %lf): negative values will give strange results"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|val
argument_list|)
operator|!=
name|val
operator|||
name|double_to_int
argument_list|(
name|shift
argument_list|)
operator|!=
name|shift
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"rshift(%lf, %lf): fractional values will be truncated"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
operator|(
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
name|BITS_PER_BYTE
operator|)
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"rshift(%lf, %lf): too large shift value will give strange results"
argument_list|)
argument_list|,
name|val
argument_list|,
name|shift
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
name|ushift
operator|=
operator|(
name|unsigned
name|long
operator|)
name|shift
expr_stmt|;
name|res
operator|=
name|uval
operator|>>
name|ushift
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_and --- perform an& operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_and
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|unsigned
name|long
name|uleft
decl_stmt|,
name|uright
decl_stmt|,
name|res
decl_stmt|;
name|AWKNUM
name|left
decl_stmt|,
name|right
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|left
operator|=
name|force_number
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|right
operator|=
name|force_number
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"and: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"and: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
operator|||
name|right
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"and(%lf, %lf): negative values will give strange results"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|left
argument_list|)
operator|!=
name|left
operator|||
name|double_to_int
argument_list|(
name|right
argument_list|)
operator|!=
name|right
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"and(%lf, %lf): fractional values will be truncated"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|uleft
operator|=
operator|(
name|unsigned
name|long
operator|)
name|left
expr_stmt|;
name|uright
operator|=
operator|(
name|unsigned
name|long
operator|)
name|right
expr_stmt|;
name|res
operator|=
name|uleft
operator|&
name|uright
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_or --- perform an | operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_or
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|unsigned
name|long
name|uleft
decl_stmt|,
name|uright
decl_stmt|,
name|res
decl_stmt|;
name|AWKNUM
name|left
decl_stmt|,
name|right
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|left
operator|=
name|force_number
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|right
operator|=
name|force_number
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"or: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"or: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
operator|||
name|right
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"or(%lf, %lf): negative values will give strange results"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|left
argument_list|)
operator|!=
name|left
operator|||
name|double_to_int
argument_list|(
name|right
argument_list|)
operator|!=
name|right
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"or(%lf, %lf): fractional values will be truncated"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|uleft
operator|=
operator|(
name|unsigned
name|long
operator|)
name|left
expr_stmt|;
name|uright
operator|=
operator|(
name|unsigned
name|long
operator|)
name|right
expr_stmt|;
name|res
operator|=
name|uleft
operator||
name|uright
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_xor --- perform an ^ operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_xor
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|unsigned
name|long
name|uleft
decl_stmt|,
name|uright
decl_stmt|,
name|res
decl_stmt|;
name|AWKNUM
name|left
decl_stmt|,
name|right
decl_stmt|;
name|s1
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|s2
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|left
operator|=
name|force_number
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|right
operator|=
name|force_number
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|s1
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"xor: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"xor: received non-numeric first argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
operator|||
name|right
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"xor(%lf, %lf): negative values will give strange results"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|left
argument_list|)
operator|!=
name|left
operator|||
name|double_to_int
argument_list|(
name|right
argument_list|)
operator|!=
name|right
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"xor(%lf, %lf): fractional values will be truncated"
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
name|free_temp
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|uleft
operator|=
operator|(
name|unsigned
name|long
operator|)
name|left
expr_stmt|;
name|uright
operator|=
operator|(
name|unsigned
name|long
operator|)
name|right
expr_stmt|;
name|res
operator|=
name|uleft
operator|^
name|uright
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_compl --- perform a ~ operation */
end_comment

begin_function
name|NODE
modifier|*
name|do_compl
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|;
name|unsigned
name|long
name|uval
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|d
operator|=
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"compl: received non-numeric argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"compl(%lf): negative value will give strange results"
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|double_to_int
argument_list|(
name|d
argument_list|)
operator|!=
name|d
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"compl(%lf): fractional value will be truncated"
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|uval
operator|=
operator|(
name|unsigned
name|long
operator|)
name|d
expr_stmt|;
name|uval
operator|=
operator|~
name|uval
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|uval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_strtonum --- the strtonum function */
end_comment

begin_function
name|NODE
modifier|*
name|do_strtonum
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|double
name|d
decl_stmt|;
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|!=
literal|0
condition|)
name|d
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isnondecimal
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|)
condition|)
name|d
operator|=
name|nondec2awknum
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
operator|(
name|double
operator|)
name|force_number
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* nondec2awknum --- convert octal or hex value to double */
end_comment

begin_comment
comment|/*  * Because of awk's concatenation rules and the way awk.y:yylex()  * collects a number, this routine has to be willing to stop on the  * first invalid character.  */
end_comment

begin_function
name|AWKNUM
name|nondec2awknum
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|AWKNUM
name|retval
init|=
literal|0.0
decl_stmt|;
name|char
name|save
decl_stmt|;
name|short
name|val
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|str
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|assert
argument_list|(
name|len
operator|>
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|str
operator|+=
literal|2
operator|,
name|len
operator|-=
literal|2
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|str
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|val
operator|=
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
name|val
operator|=
operator|*
name|str
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
name|val
operator|=
operator|*
name|str
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|retval
operator|=
operator|(
name|retval
operator|*
literal|16
operator|)
operator|+
name|val
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|'8'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|str
argument_list|,
literal|'9'
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|decimal
goto|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'8'
operator|||
operator|*
name|str
operator|==
literal|'9'
condition|)
block|{
name|str
operator|=
name|start
expr_stmt|;
goto|goto
name|decimal
goto|;
block|}
name|retval
operator|=
operator|(
name|retval
operator|*
literal|8
operator|)
operator|+
operator|(
operator|*
name|str
operator|-
literal|'0'
operator|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|decimal
label|:
name|save
operator|=
name|str
index|[
name|len
index|]
expr_stmt|;
name|retval
operator|=
name|strtod
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
name|save
expr_stmt|;
block|}
name|done
label|:
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* do_dcgettext --- handle i18n translations */
end_comment

begin_comment
comment|/*  * awk usage is  *  * 	str = dcgettext(string [, domain [, category]])  *  * Default domain is TEXTDOMAIN, default category is LC_MESSAGES.  */
end_comment

begin_function
name|NODE
modifier|*
name|do_dcgettext
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|the_result
decl_stmt|;
if|#
directive|if
name|ENABLE_NLS
operator|&&
name|HAVE_LC_MESSAGES
operator|&&
name|HAVE_DCGETTEXT
name|int
name|lc_cat
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|category
decl_stmt|,
modifier|*
name|domain
decl_stmt|;
specifier|static
struct|struct
name|category_table
block|{
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|cat_tab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|LC_ALL
block|{
name|LC_ALL
block|,
literal|"LC_ALL"
block|}
block|,
endif|#
directive|endif
comment|/* LC_ALL */
ifdef|#
directive|ifdef
name|LC_COLLATE
block|{
name|LC_COLLATE
block|,
literal|"LC_COLLATE"
block|}
block|,
endif|#
directive|endif
comment|/* LC_COLLATE */
ifdef|#
directive|ifdef
name|LC_CTYPE
block|{
name|LC_CTYPE
block|,
literal|"LC_CTYPE"
block|}
block|,
endif|#
directive|endif
comment|/* LC_CTYPE */
ifdef|#
directive|ifdef
name|LC_MESSAGES
block|{
name|LC_MESSAGES
block|,
literal|"LC_MESSAGES"
block|}
block|,
endif|#
directive|endif
comment|/* LC_MESSAGES */
ifdef|#
directive|ifdef
name|LC_MONETARY
block|{
name|LC_MONETARY
block|,
literal|"LC_MONETARY"
block|}
block|,
endif|#
directive|endif
comment|/* LC_MONETARY */
ifdef|#
directive|ifdef
name|LC_NUMERIC
block|{
name|LC_NUMERIC
block|,
literal|"LC_NUMERIC"
block|}
block|,
endif|#
directive|endif
comment|/* LC_NUMERIC */
ifdef|#
directive|ifdef
name|LC_RESPONSE
block|{
name|LC_RESPONSE
block|,
literal|"LC_RESPONSE"
block|}
block|,
endif|#
directive|endif
comment|/* LC_RESPONSE */
ifdef|#
directive|ifdef
name|LC_TIME
block|{
name|LC_TIME
block|,
literal|"LC_TIME"
block|}
block|,
endif|#
directive|endif
comment|/* LC_TIME */
block|}
struct|;
endif|#
directive|endif
comment|/* ENABLE_NLS */
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
comment|/* first argument */
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|string
operator|=
name|t1
operator|->
name|stptr
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|ENABLE_NLS
operator|&&
name|HAVE_LC_MESSAGES
operator|&&
name|HAVE_DCGETTEXT
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
comment|/* second argument */
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|t2
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|domain
operator|=
name|t2
operator|->
name|stptr
expr_stmt|;
block|}
else|else
name|domain
operator|=
name|TEXTDOMAIN
expr_stmt|;
if|if
condition|(
name|tree
operator|!=
name|NULL
operator|&&
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
comment|/* third argument */
name|int
name|low
decl_stmt|,
name|high
decl_stmt|,
name|i
decl_stmt|,
name|mid
decl_stmt|;
name|NODE
modifier|*
name|t
decl_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|t
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|category
operator|=
name|t
operator|->
name|stptr
expr_stmt|;
comment|/* binary search the table */
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|cat_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cat_tab
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|i
operator|=
name|strcmp
argument_list|(
name|category
argument_list|,
name|cat_tab
index|[
name|mid
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* category< mid */
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* category> mid */
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|lc_cat
operator|=
name|cat_tab
index|[
name|mid
index|]
operator|.
name|val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|lc_cat
operator|==
operator|-
literal|1
condition|)
comment|/* not there */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"dcgettext: `%s' is not a valid locale category"
argument_list|)
argument_list|,
name|category
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|lc_cat
operator|=
name|LC_MESSAGES
expr_stmt|;
name|the_result
operator|=
name|dcgettext
argument_list|(
name|domain
argument_list|,
name|string
argument_list|,
name|lc_cat
argument_list|)
expr_stmt|;
else|#
directive|else
name|the_result
operator|=
name|string
expr_stmt|;
endif|#
directive|endif
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|NULL
condition|)
name|free_temp
argument_list|(
name|t2
argument_list|)
expr_stmt|;
return|return
name|tmp_string
argument_list|(
name|the_result
argument_list|,
name|strlen
argument_list|(
name|the_result
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* do_bindtextdomain --- set the directory for a text domain */
end_comment

begin_comment
comment|/*  * awk usage is  *  * 	binding = bindtextdomain(dir [, domain])  *  * If dir is "", pass NULL to C version.  * Default domain is TEXTDOMAIN.  */
end_comment

begin_function
name|NODE
modifier|*
name|do_bindtextdomain
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|char
modifier|*
name|directory
decl_stmt|,
modifier|*
name|domain
decl_stmt|;
name|char
modifier|*
name|the_result
decl_stmt|;
name|t1
operator|=
name|t2
operator|=
name|NULL
expr_stmt|;
comment|/* set defaults */
name|directory
operator|=
name|NULL
expr_stmt|;
name|domain
operator|=
name|TEXTDOMAIN
expr_stmt|;
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
comment|/* first argument */
name|t1
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|stlen
operator|>
literal|0
condition|)
name|directory
operator|=
name|t1
operator|->
name|stptr
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|rnode
expr_stmt|;
comment|/* second argument */
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|tree
operator|->
name|lnode
expr_stmt|;
name|t2
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|domain
operator|=
name|t2
operator|->
name|stptr
expr_stmt|;
block|}
name|the_result
operator|=
name|bindtextdomain
argument_list|(
name|domain
argument_list|,
name|directory
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
operator|!=
name|NULL
condition|)
name|free_temp
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|tmp_string
argument_list|(
name|the_result
argument_list|,
name|strlen
argument_list|(
name|the_result
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

