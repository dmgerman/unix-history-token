begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * io.c --- routines for dealing with input and output and records  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1976, 1988, 1989, 1991-2000 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_undef
undef|#
directive|undef
name|HAVE_MMAP
end_undef

begin_comment
comment|/* for now, probably forever */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_comment
comment|/* avoid spurious conflict w/regex.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_WAIT_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((caddr_t) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (MAP_FAILED) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MMAP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_ACCMODE
end_ifndef

begin_define
define|#
directive|define
name|O_ACCMODE
value|(O_RDONLY|O_WRONLY|O_RDWR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISREG
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFREG
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ENFILE
end_ifndef

begin_define
define|#
directive|define
name|ENFILE
value|EMFILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|PIPES_SIMULATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|nextfile
name|P
argument_list|(
operator|(
name|int
name|skipping
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inrec
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iop_close
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|redirect
modifier|*
name|redirect
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|,
name|int
operator|*
name|errflg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_one
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|close_redir
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|,
name|int
name|exitwarn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|wait_any
name|P
argument_list|(
operator|(
name|int
name|interesting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
name|P
argument_list|(
operator|(
name|char
operator|*
name|cmd
operator|,
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|iop_open
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|how
operator|,
name|IOBUF
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|iop_alloc
name|P
argument_list|(
operator|(
name|int
name|fd
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
name|IOBUF
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gawk_pclose
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pathopen
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_a_record
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|out
operator|,
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|rs
operator|,
name|Regexp
operator|*
name|RSre
operator|,
name|int
operator|*
name|errcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|mmap_get_record
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|out
operator|,
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|rs
operator|,
name|Regexp
operator|*
name|RSre
operator|,
name|int
operator|*
name|errcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MMAP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|str2mode
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spec_setup
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|len
operator|,
name|int
name|allocate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specfdopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pidopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|useropen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POPEN_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"popen.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|redirect
modifier|*
name|red_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|RS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Regexp
modifier|*
name|RS_regexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|RS_is_null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|output_is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGC_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGV_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGIND_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ERRNO_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|filebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for do_nextfile() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* File pointers have an extra level of indirection, and there are cases where    `stdin' can be null.  That can crash gawk if fileno() is used as-is.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmsrtl_fileno
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vmsrtl_fileno
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|fileno
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_define
define|#
directive|define
name|fileno
parameter_list|(
name|FP
parameter_list|)
value|(((FP)&& *(FP)) ? vmsrtl_fileno(FP) : -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* do_nextfile --- implement gawk "nextfile" extension */
end_comment

begin_function
name|void
name|do_nextfile
parameter_list|()
block|{
operator|(
name|void
operator|)
name|nextfile
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|filebuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nextfile --- move to the next input data file */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|nextfile
parameter_list|(
name|skipping
parameter_list|)
name|int
name|skipping
decl_stmt|;
block|{
specifier|static
name|long
name|i
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|files
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
name|arg
decl_stmt|;
specifier|static
name|IOBUF
modifier|*
name|curfile
init|=
name|NULL
decl_stmt|;
specifier|static
name|IOBUF
name|mybuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|skipping
condition|)
block|{
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curfile
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|curfile
return|;
block|}
for|for
control|(
init|;
name|i
operator|<
call|(
name|long
call|)
argument_list|(
name|ARGC_node
operator|->
name|lnode
operator|->
name|numbr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
operator|*
name|assoc_lookup
argument_list|(
name|ARGV_node
argument_list|,
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|stlen
operator|==
literal|0
condition|)
continue|continue;
name|arg
operator|->
name|stptr
index|[
name|arg
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
name|unref
argument_list|(
name|ARGIND_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ARGIND_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arg_assign
argument_list|(
name|arg
operator|->
name|stptr
argument_list|)
condition|)
block|{
name|files
operator|++
expr_stmt|;
name|fname
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
name|curfile
operator|=
name|iop_open
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|,
operator|&
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
goto|goto
name|give_up
goto|;
name|curfile
operator|->
name|flag
operator||=
name|IOP_NOFREE_OBJ
expr_stmt|;
comment|/* This is a kludge.  */
name|unref
argument_list|(
name|FILENAME_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|FILENAME_node
operator|->
name|var_value
operator|=
name|dupnode
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|FNR
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|files
operator|==
literal|0
condition|)
block|{
name|files
operator|++
expr_stmt|;
comment|/* no args. -- use stdin */
comment|/* FNR is init'ed to 0 */
name|FILENAME_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fname
operator|=
literal|"-"
expr_stmt|;
name|curfile
operator|=
name|iop_open
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|,
operator|&
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
goto|goto
name|give_up
goto|;
name|curfile
operator|->
name|flag
operator||=
name|IOP_NOFREE_OBJ
expr_stmt|;
block|}
return|return
name|curfile
return|;
name|give_up
label|:
name|fatal
argument_list|(
literal|"cannot open file `%s' for reading (%s)"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* set_FNR --- update internal FNR from awk variable */
end_comment

begin_function
name|void
name|set_FNR
parameter_list|()
block|{
name|FNR
operator|=
operator|(
name|long
operator|)
name|FNR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_NR --- update internal NR from awk variable */
end_comment

begin_function
name|void
name|set_NR
parameter_list|()
block|{
name|NR
operator|=
operator|(
name|long
operator|)
name|NR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* inrec --- This reads in a record from the input file */
end_comment

begin_function
specifier|static
name|int
name|inrec
parameter_list|(
name|iop
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
block|{
name|char
modifier|*
name|begin
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|iop
operator|->
name|cnt
operator|)
operator|!=
name|EOF
condition|)
name|cnt
operator|=
operator|(
operator|*
operator|(
name|iop
operator|->
name|getrec
operator|)
operator|)
operator|(
operator|&
name|begin
operator|,
name|iop
operator|,
name|RS
operator|->
name|stptr
index|[
literal|0
index|]
operator|,
name|RS_regexp
operator|,
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|NR
operator|+=
literal|1
expr_stmt|;
name|FNR
operator|+=
literal|1
expr_stmt|;
name|set_record
argument_list|(
name|begin
argument_list|,
name|cnt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* iop_close --- close an open IOP */
end_comment

begin_function
specifier|static
name|int
name|iop_close
parameter_list|(
name|iop
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* Work around bug in UNICOS popen */
if|if
condition|(
name|iop
operator|->
name|fd
operator|<
literal|3
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* save these for re-use; don't free the storage */
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Don't close standard files or else crufty code elsewhere will lose */
if|if
condition|(
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
operator|||
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_MMAPPED
operator|)
operator|!=
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|close
argument_list|(
name|iop
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"close of fd %d (`%s') failed (%s)"
argument_list|,
name|iop
operator|->
name|fd
argument_list|,
name|iop
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_NO_FREE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Be careful -- $0 may still reference the buffer even though 		 * an explicit close is being done; in the future, maybe we 		 * can do this a bit better. 		 */
if|if
condition|(
name|iop
operator|->
name|buf
condition|)
block|{
if|if
condition|(
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|>=
name|iop
operator|->
name|buf
operator|)
operator|&&
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|<
operator|(
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
operator|+
name|iop
operator|->
name|size
operator|)
operator|)
condition|)
block|{
name|NODE
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|make_string
argument_list|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|reset_record
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_MMAPPED
operator|)
operator|==
literal|0
condition|)
name|free
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
else|else
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|iop
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_NOFREE_OBJ
operator|)
operator|==
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iop
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* do_input --- the main input processing loop */
end_comment

begin_function
name|void
name|do_input
parameter_list|()
block|{
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|extern
name|int
name|exiting
decl_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
comment|/* for `nextfile' */
while|while
condition|(
operator|(
name|iop
operator|=
name|nextfile
argument_list|(
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
while|while
condition|(
name|interpret
argument_list|(
name|expression_value
argument_list|)
operator|&&
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|C_ALLOCA
comment|/* recover any space from C based alloca */
operator|(
name|void
operator|)
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exiting
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* redirect --- Redirection for printf and print commands */
end_comment

begin_function
name|struct
name|redirect
modifier|*
name|redirect
parameter_list|(
name|tree
parameter_list|,
name|errflg
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
name|int
modifier|*
name|errflg
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|tflag
init|=
literal|0
decl_stmt|;
name|int
name|outflag
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|direction
init|=
literal|"to"
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_append
case|:
name|tflag
operator|=
name|RED_APPEND
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|Node_redirect_output
case|:
name|outflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|tflag
operator||=
name|outflag
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
condition|)
name|what
operator|=
literal|">"
expr_stmt|;
else|else
name|what
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|tflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"<"
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid tree type %d in redirect()"
argument_list|,
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
name|STR
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"expression in `%s' redirection only has numeric value"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
literal|"expression for `%s' redirection has null string value"
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"0"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|||
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"1"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"filename `%s' for `%s' redirection may be result of logical expression"
argument_list|,
name|str
argument_list|,
name|what
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|str
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|&&
operator|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|~
operator|(
name|RED_NOBUF
operator||
name|RED_EOF
operator|)
operator|)
operator|==
name|tflag
operator|||
operator|(
name|outflag
operator|!=
literal|0
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
name|outflag
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|emalloc
argument_list|(
name|rp
argument_list|,
expr|struct
name|redirect
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|redirect
argument_list|)
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|tmp
operator|->
name|stlen
operator|+
literal|1
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|str
index|[
name|tmp
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|rp
operator|->
name|flag
operator|=
name|tflag
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
comment|/* unlikely that we're worried about init */
name|rp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* maintain list in most-recently-used first order */
if|if
condition|(
name|red_head
operator|!=
name|NULL
condition|)
name|red_head
operator|->
name|prev
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|red_head
expr_stmt|;
name|red_head
operator|=
name|rp
expr_stmt|;
block|}
else|else
name|str
operator|=
name|rp
operator|->
name|value
expr_stmt|;
comment|/* get \0 terminated string */
while|while
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_EOF
condition|)
comment|/* 			 * encountered EOF on file or pipe -- must be cleared 			 * by explicit close() before reading more 			 */
return|return
name|rp
return|;
name|mode
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_output
case|:
name|mode
operator|=
literal|"w"
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_USED
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
literal|"a"
expr_stmt|;
break|break;
case|case
name|Node_redirect_append
case|:
name|mode
operator|=
literal|"a"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
comment|/* synchronize output before new pipe */
operator|(
name|void
operator|)
name|flush_io
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|fp
operator|=
name|popen
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open pipe (\"%s\") for output (%s)"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
if|if
condition|(
name|gawk_popen
argument_list|(
name|str
argument_list|,
name|rp
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open pipe (\"%s\") for input (%s)"
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_open
argument_list|(
name|str
argument_list|,
literal|"r"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stderr
expr_stmt|;
else|else
block|{
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mode
argument_list|)
expr_stmt|;
comment|/* don't leak file descriptors */
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
operator|&&
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
comment|/* Move rp to the head of the list. */
if|if
condition|(
name|red_head
operator|!=
name|rp
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|prev
operator|->
name|next
operator|=
name|rp
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|next
operator|->
name|prev
operator|=
name|rp
operator|->
name|prev
expr_stmt|;
name|red_head
operator|->
name|prev
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|red_head
expr_stmt|;
name|red_head
operator|=
name|rp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
comment|/* too many files open -- close one and try again */
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|close_one
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
name|__MINGW32__
operator|||
name|defined
name|HAVE_MMAP
comment|/* this works for solaris 2.5, not sunos */
comment|/* it is also needed for MINGW32 */
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
comment|/* HACK! */
name|close_one
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
comment|/* Alpha/VMS V7.1's C RTL is returning this instead 			   of EMFILE (haven't tried other post-V6.2 systems) */
define|#
directive|define
name|SS$_EXQUOTA
value|0x001C
elseif|else
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
name|vaxc$errno
operator|==
name|SS$_EXQUOTA
condition|)
name|close_one
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|else
block|{
comment|/* 				 * Some other reason for failure. 				 * 				 * On redirection of input from a file, 				 * just return an error, so e.g. getline 				 * can return -1.  For output to file, 				 * complain. The shell will complain on 				 * a bad command to a pipe. 				 */
if|if
condition|(
name|errflg
operator|!=
name|NULL
condition|)
operator|*
name|errflg
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
operator|||
name|tree
operator|->
name|type
operator|==
name|Node_redirect_append
condition|)
name|fatal
argument_list|(
literal|"can't redirect %s `%s' (%s)"
argument_list|,
name|direction
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_comment
comment|/* getredirect --- find the struct redirect for this file or pipe */
end_comment

begin_function
name|struct
name|redirect
modifier|*
name|getredirect
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|len
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|rp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* close_one --- temporarily close an open file to re-use the fd */
end_comment

begin_function
specifier|static
name|void
name|close_one
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rplast
init|=
name|NULL
decl_stmt|;
comment|/* go to end of list first, to pick up least recently used entry */
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
name|rplast
operator|=
name|rp
expr_stmt|;
comment|/* now work back up through the list */
for|for
control|(
name|rp
operator|=
name|rplast
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|prev
control|)
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_FILE
operator|)
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|flag
operator||=
name|RED_USED
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
comment|/* do_lint&& */
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"close of \"%s\" failed (%s)."
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* surely this is the only reason ??? */
name|fatal
argument_list|(
literal|"too many pipes or input files open"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_close --- completely close an open file or pipe */
end_comment

begin_function
name|NODE
modifier|*
name|do_close
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* no match */
comment|/* icky special case: close(FILENAME) called. */
if|if
condition|(
name|tree
operator|->
name|subnode
operator|==
name|FILENAME_node
operator|||
operator|(
name|tmp
operator|->
name|stlen
operator|==
name|FILENAME_node
operator|->
name|var_value
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|tmp
operator|->
name|stptr
argument_list|,
name|FILENAME_node
operator|->
name|var_value
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|nextfile
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_lint
condition|)
name|warning
argument_list|(
literal|"close: `%.*s' is not an open file or pipe"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* synchronize regular output */
name|tmp
operator|=
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|close_redir
argument_list|(
name|rp
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* close_redir --- close an open file or pipe */
end_comment

begin_function
specifier|static
name|int
name|close_redir
parameter_list|(
name|rp
parameter_list|,
name|exitwarn
parameter_list|)
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|exitwarn
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|stdout
operator|||
name|rp
operator|->
name|fp
operator|==
name|stderr
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
condition|)
name|status
operator|=
name|pclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
name|status
operator|=
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|!=
literal|0
condition|)
name|status
operator|=
name|gawk_pclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|what
operator|=
operator|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"pipe"
else|:
literal|"file"
expr_stmt|;
comment|/* SVR4 awk checks and warns about status of close */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
comment|/* 		 * Too many people have complained about this. 		 * As of 2.15.6, it is now under lint control. 		 */
if|if
condition|(
name|do_lint
condition|)
name|warning
argument_list|(
literal|"failure status (%d) on %s close of \"%s\" (%s)"
argument_list|,
name|status
argument_list|,
name|what
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
comment|/* set ERRNO too so that program can get at it */
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exitwarn
condition|)
name|warning
argument_list|(
literal|"no explicit close of %s `%s' provided"
argument_list|,
name|what
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|next
operator|->
name|prev
operator|=
name|rp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|prev
operator|->
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
else|else
name|red_head
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* flush_io --- flush all open output files */
end_comment

begin_function
name|int
name|flush_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard output (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard error (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
comment|/* flush both files and pipes, what the heck */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_WRITE
operator|)
operator|&&
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%s flush of \"%s\" failed (%s)."
argument_list|,
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
condition|?
literal|"pipe"
else|:
literal|"file"
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* close_io --- close all open files, called when exiting */
end_comment

begin_function
name|int
name|close_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|next
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
comment|/* 		 * close_redir() will print a message if needed 		 * if do_lint, warn about lack of explicit close 		 */
if|if
condition|(
name|close_redir
argument_list|(
name|rp
argument_list|,
name|do_lint
argument_list|)
condition|)
name|status
operator|++
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Some of the non-Unix os's have problems doing an fclose 	 * on stdout and stderr.  Since we don't really need to close 	 * them, we just flush them, and do that across the board. 	 */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard output (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"error writing standard error (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* str2mode --- convert a string mode to an integer mode */
end_comment

begin_function
specifier|static
name|int
name|str2mode
parameter_list|(
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|ret
operator|=
name|O_RDONLY
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* lint */
name|cant_happen
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* devopen --- handle /dev/std{in,out,err}, /dev/fd/N, regular files */
end_comment

begin_comment
comment|/*  * This separate version is still needed for output, since file and pipe  * output is done with stdio. iop_open() handles input with IOBUFs of  * more "special" files.  Those files are not handled here since it makes  * no sense to use them for output.  */
end_comment

begin_function
name|int
name|devopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|int
name|openfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|openfd
operator|=
name|INVALID_HANDLE
expr_stmt|;
if|if
condition|(
name|do_traditional
condition|)
goto|goto
name|strictopen
goto|;
if|if
condition|(
operator|(
name|openfd
operator|=
name|os_devopen
argument_list|(
name|name
argument_list|,
name|flag
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|openfd
return|;
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdin"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdout"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stderr"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"fd/"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|cp
operator|+=
literal|3
expr_stmt|;
name|openfd
operator|=
operator|(
name|int
operator|)
name|strtod
argument_list|(
name|cp
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|<=
name|INVALID_HANDLE
operator|||
name|ptr
operator|==
name|cp
condition|)
name|openfd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
operator|&&
name|fstat
argument_list|(
name|openfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"file `%s' is a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|openfd
return|;
block|}
end_block

begin_comment
comment|/* spec_setup --- setup an IOBUF for a special internal file */
end_comment

begin_function
specifier|static
name|void
name|spec_setup
parameter_list|(
name|iop
parameter_list|,
name|len
parameter_list|,
name|allocate
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|allocate
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|allocate
condition|)
block|{
name|emalloc
argument_list|(
name|cp
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
literal|"spec_setup"
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* get_a_record clobbered it */
name|iop
operator|->
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|len
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|iop
operator|->
name|flag
operator|=
name|IOP_IS_INTERNAL
expr_stmt|;
name|iop
operator|->
name|getrec
operator|=
name|get_a_record
expr_stmt|;
block|}
end_function

begin_comment
comment|/* specfdopen --- open an fd special file */
end_comment

begin_function
specifier|static
name|int
name|specfdopen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|IOBUF
modifier|*
name|tp
decl_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|INVALID_HANDLE
return|;
name|tp
operator|=
name|iop_alloc
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* don't leak fd's */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_HANDLE
return|;
block|}
operator|*
name|iop
operator|=
operator|*
name|tp
expr_stmt|;
name|iop
operator|->
name|flag
operator||=
name|IOP_NO_FREE
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|GETPGRP_VOID
end_ifdef

begin_define
define|#
directive|define
name|getpgrp_arg
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|getpgrp_arg
parameter_list|()
value|getpid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pidopen --- "open" /dev/pid, /dev/ppid, and /dev/pgrpid */
end_comment

begin_function
specifier|static
name|int
name|pidopen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'g'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpgrp
argument_list|(
name|getpgrp_arg
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'i'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* useropen --- "open" /dev/user */
end_comment

begin_comment
comment|/*  * /dev/user creates a record as follows:  *	$1 = getuid()  *	$2 = geteuid()  *	$3 = getgid()  *	$4 = getegid()  * If multiple groups are supported, then $5 through $NF are the  * supplementary group set.  */
end_comment

begin_function
specifier|static
name|int
name|useropen
parameter_list|(
name|iop
parameter_list|,
name|name
parameter_list|,
name|mode
parameter_list|)
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_block
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
name|GETGROUPS_T
name|groupset
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tbuf
operator|+
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|groupset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngroups
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"could not find groups: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|groupset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* iop_open --- handle special and regular files for input */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|iop_open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|iop
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mode
decl_stmt|;
end_function

begin_decl_stmt
name|IOBUF
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|openfd
init|=
name|INVALID_HANDLE
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
specifier|static
struct|struct
name|internal
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|compare
decl_stmt|;
name|int
argument_list|(
argument|*fp
argument_list|)
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|IOBUF
name|iob
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|"/dev/fd/"
block|,
literal|8
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdin"
block|,
literal|10
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdout"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stderr"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/pid"
block|,
literal|8
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/ppid"
block|,
literal|9
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/pgrpid"
block|,
literal|11
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/user"
block|,
literal|9
block|,
name|useropen
block|}
block|, 	}
struct|;
name|int
name|devcount
init|=
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * FIXME: remove the stat call, and always process these files 	 * internally. 	 */
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_traditional
condition|)
goto|goto
name|strictopen
goto|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|&&
name|stat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|compare
argument_list|)
condition|)
block|{
name|iop
operator|=
operator|&
name|table
index|[
name|i
index|]
operator|.
name|iob
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|spec_setup
argument_list|(
name|iop
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|iop
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|table
index|[
name|i
index|]
operator|.
name|fp
operator|)
operator|(
name|iop
operator|,
name|name
operator|,
name|mode
operator|)
operator|==
literal|0
condition|)
return|return
name|iop
return|;
else|else
block|{
name|warning
argument_list|(
literal|"could not open %s, mode `%s'"
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
operator|&&
name|fstat
argument_list|(
name|openfd
argument_list|,
operator|&
name|buf
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"file `%s' is a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|iop_alloc
argument_list|(
name|openfd
argument_list|,
name|name
argument_list|,
name|iop
argument_list|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_comment
comment|/* real pipes */
end_comment

begin_comment
comment|/* wait_any --- wait for a child process, close associated pipe */
end_comment

begin_function
specifier|static
name|int
name|wait_any
parameter_list|(
name|interesting
parameter_list|)
name|int
name|interesting
decl_stmt|;
comment|/* pid of interest, if any */
block|{
name|RETSIGTYPE
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|redirect
modifier|*
name|redp
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
comment|/* Posix compatible sys/wait.h */
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|(
expr|union
name|wait
operator|*
operator|)
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NeXT */
if|if
condition|(
name|interesting
operator|&&
name|pid
operator|==
name|interesting
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|redp
operator|=
name|red_head
init|;
name|redp
operator|!=
name|NULL
condition|;
name|redp
operator|=
name|redp
operator|->
name|next
control|)
if|if
condition|(
name|pid
operator|==
name|redp
operator|->
name|pid
condition|)
block|{
name|redp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|redp
operator|->
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
break|break;
block|}
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
comment|/* 	 * used to wait for any children to synchronize input and output, 	 * but this could cause gawk to hang when it is started in a pipeline 	 * and thus has a child process feeding it input (shell dependant) 	 */
comment|/*(void) wait_any(0);*/
comment|/* wait for outstanding processes */
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot open pipe \"%s\" (%s)"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of stdout in child failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"dup of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"cannot fork for \"%s\" (%s)"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* process previously found, return stored status */
if|if
condition|(
name|rp
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
return|;
name|rp
operator|->
name|status
operator|=
name|wait_any
argument_list|(
name|rp
operator|->
name|pid
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_comment
comment|/*  * use temporary file rather than pipe  * except if popen() provides real pipes too  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
end_if

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|fileno
argument_list|(
name|current
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
block|}
name|rp
operator|->
name|ifp
operator|=
name|current
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|,
name|aval
decl_stmt|,
name|fd
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
name|rp
operator|->
name|iop
operator|->
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* kludge to allow close() + pclose() */
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|aval
operator|=
name|pclose
argument_list|(
name|rp
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rval
operator|<
literal|0
condition|?
name|rval
else|:
name|aval
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (VMS || OS2 || MSDOS) */
end_comment

begin_struct
specifier|static
struct|struct
name|pipeinfo
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|pipes
index|[
name|_NFILE
index|]
struct|;
end_struct

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|cmd
parameter_list|,
name|rp
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|strdup
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|int
name|current
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|cmdbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* get a name to use */
if|if
condition|(
operator|(
name|name
operator|=
name|tempnam
argument_list|(
literal|"."
argument_list|,
literal|"pip"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"%s> %s"
argument_list|,
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|NULL
return|;
name|pipes
index|[
name|current
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|pipes
index|[
name|current
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|current
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|rp
parameter_list|)
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
block|{
name|int
name|cur
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* check for an open file  */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (VMS || OS2 || MSDOS) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_comment
comment|/* do_getline --- read in a line, into var and with redirection, as needed */
end_comment

begin_function
name|NODE
modifier|*
name|do_getline
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|int
name|cnt
init|=
name|EOF
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|errcode
decl_stmt|;
while|while
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|rnode
operator|==
name|NULL
condition|)
block|{
comment|/* no redirection */
name|iop
operator|=
name|nextfile
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|redir_error
init|=
literal|0
decl_stmt|;
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|redir_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
operator|&&
name|redir_error
condition|)
block|{
comment|/* failed redirect */
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
name|s
operator|=
name|strerror
argument_list|(
name|redir_error
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
name|iop
operator|=
name|rp
operator|->
name|iop
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
name|errcode
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
operator|(
operator|*
operator|(
name|iop
operator|->
name|getrec
operator|)
operator|)
operator|(
operator|&
name|s
operator|,
name|iop
operator|,
name|RS
operator|->
name|stptr
index|[
literal|0
index|]
operator|,
name|RS_regexp
operator|,
operator|&
name|errcode
operator|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
name|s
operator|=
name|strerror
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Don't do iop_close() here if we are 				 * reading from a pipe; otherwise 				 * gawk_pclose will not be called. 				 */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
name|rp
operator|->
name|flag
operator||=
name|RED_EOF
expr_stmt|;
comment|/* sticky EOF */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
continue|continue;
comment|/* try another file */
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|NR
operator|++
expr_stmt|;
name|FNR
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
condition|)
comment|/* no optional var. */
name|set_record
argument_list|(
name|s
argument_list|,
name|cnt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* assignment to variable */
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|)
expr_stmt|;
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lhs
operator|)
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
comment|/* we may have to regenerate $0 here! */
if|if
condition|(
name|after_assign
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|1.0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* pathopen --- pathopen with default file extension handling */
end_comment

begin_function
name|int
name|pathopen
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|fd
init|=
name|do_pathopen
argument_list|(
name|file
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_FILETYPE
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|char
modifier|*
name|file_awk
decl_stmt|;
name|int
name|save
init|=
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|vms_save
init|=
name|vaxc$errno
decl_stmt|;
endif|#
directive|endif
comment|/* append ".awk" and try again */
name|emalloc
argument_list|(
name|file_awk
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DEFAULT_FILETYPE
argument_list|)
operator|+
literal|1
argument_list|,
literal|"pathopen"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|file_awk
argument_list|,
literal|"%s%s"
argument_list|,
name|file
argument_list|,
name|DEFAULT_FILETYPE
argument_list|)
expr_stmt|;
name|fd
operator|=
name|do_pathopen
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|errno
operator|=
name|save
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|vaxc$errno
operator|=
name|vms_save
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/*DEFAULT_FILETYPE*/
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* do_pathopen --- search $AWKPATH for source file */
end_comment

begin_function
specifier|static
name|int
name|do_pathopen
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|savepath
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|first
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|awkpath
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|trypath
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|do_traditional
condition|)
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|awkpath
operator|=
name|getenv
argument_list|(
literal|"AWKPATH"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|awkpath
condition|)
name|savepath
operator|=
name|awkpath
expr_stmt|;
comment|/* used for restarting */
else|else
name|savepath
operator|=
name|defpath
expr_stmt|;
block|}
name|awkpath
operator|=
name|savepath
expr_stmt|;
comment|/* some kind of path name, no search */
if|if
condition|(
name|ispath
argument_list|(
name|file
argument_list|)
condition|)
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
do|do
block|{
name|trypath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* this should take into account limits on size of trypath */
for|for
control|(
name|cp
operator|=
name|trypath
init|;
operator|*
name|awkpath
operator|&&
operator|*
name|awkpath
operator|!=
name|envsep
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|awkpath
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|trypath
condition|)
block|{
comment|/* nun-null element in path */
comment|/* add directory punctuation only if needed */
if|if
condition|(
operator|!
name|isdirpunct
argument_list|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* append filename */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|trypath
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|devopen
argument_list|(
name|trypath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|>
name|INVALID_HANDLE
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* no luck, keep going */
if|if
condition|(
operator|*
name|awkpath
operator|==
name|envsep
operator|&&
name|awkpath
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|awkpath
operator|++
expr_stmt|;
comment|/* skip colon */
block|}
do|while
condition|(
operator|*
name|awkpath
operator|!=
literal|'\0'
condition|)
do|;
comment|/* 	 * You might have one of the awk paths defined, WITHOUT the current 	 * working directory in it. Therefore try to open the file in the 	 * current directory. 	 */
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_decl_stmt
name|int
name|bufsize
init|=
literal|8192
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* iop_alloc --- allocate an IOBUF structure for an open fd */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|iop_alloc
parameter_list|(
name|fd
parameter_list|,
name|name
parameter_list|,
name|iop
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|IOBUF
modifier|*
name|iop
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
name|emalloc
argument_list|(
name|iop
argument_list|,
name|IOBUF
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|IOBUF
argument_list|)
argument_list|,
literal|"iop_alloc"
argument_list|)
expr_stmt|;
name|iop
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|iop
operator|->
name|flag
operator||=
name|IOP_IS_TTY
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|optimal_bufsize
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
name|S_ISREG
argument_list|(
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|sbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"data file `%s' is empty"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
operator|-
literal|2
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|iop
operator|->
name|getrec
operator|=
name|get_a_record
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
comment|/* Use mmap only for regular files with positive sizes. 	   The size must fit into size_t, so that mmap works correctly. 	   Also, it must fit into int, so that iop->cnt won't overflow.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|sbuf
operator|.
name|st_size
operator|>
literal|0
operator|&&
name|sbuf
operator|.
name|st_size
operator|==
operator|(
name|size_t
operator|)
name|sbuf
operator|.
name|st_size
operator|&&
name|sbuf
operator|.
name|st_size
operator|==
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_size
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|iop
operator|->
name|buf
operator|=
name|iop
operator|->
name|off
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|/* cast is for buggy compilers (e.g. DEC OSF/1) */
if|if
condition|(
name|iop
operator|->
name|buf
operator|==
operator|(
name|caddr_t
operator|)
name|MAP_FAILED
condition|)
block|{
name|iop
operator|->
name|buf
operator|=
name|iop
operator|->
name|off
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|iop
operator|->
name|flag
operator||=
name|IOP_MMAPPED
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|size
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
name|iop
operator|->
name|getrec
operator|=
name|mmap_get_record
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MADVISE
argument_list|)
operator|&&
name|defined
argument_list|(
name|MADV_SEQUENTIAL
argument_list|)
name|madvise
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|iop
operator|->
name|size
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * The following is a really gross hack. 		 * We want to ensure that we have a copy of the input 		 * data that won't go away, on the off chance that someone 		 * will truncate the data file we've just mmap'ed. 		 * So, we go through and touch each page, forcing the 		 * system to give us a private copy. A page size of 512 		 * guarantees this will work, even on the least common 		 * denominator system (like, oh say, a VAX). 		 */
for|for
control|(
name|cp
operator|=
name|iop
operator|->
name|buf
init|;
name|cp
operator|<
name|iop
operator|->
name|end
condition|;
name|cp
operator|+=
literal|512
control|)
operator|*
name|cp
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|out
label|:
endif|#
directive|endif
comment|/* HAVE_MMAP */
return|return
name|iop
return|;
block|}
end_function

begin_comment
comment|/* These macros used by both record reading routines */
end_comment

begin_define
define|#
directive|define
name|set_RT_to_null
parameter_list|()
define|\
value|(void)(! do_traditional&& (unref(RT_node->var_value), \ 			   RT_node->var_value = Nnull_string))
end_define

begin_define
define|#
directive|define
name|set_RT
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
define|\
value|(void)(! do_traditional&& (unref(RT_node->var_value), \ 			   RT_node->var_value = make_string(str, len)))
end_define

begin_comment
comment|/*  * get_a_record:  * Get the next record.  Uses a "split buffer" where the latter part is  * the normal read buffer and the head part is an "overflow" area that is used  * when a record spans the end of the normal buffer, in which case the first  * part of the record is copied into the overflow area just before the  * normal buffer.  Thus, the eventual full record can be returned as a  * contiguous area of memory with a minimum of copying.  The overflow area  * is expanded as needed, so that records are unlimited in length.  * We also mark both the end of the buffer and the end of the read() with  * a sentinel character (the current record separator) so that the inside  * loop can run as a single test.  *  * Note that since we know or can compute the end of the read and the end  * of the buffer, the sentinel character does not get in the way of regexp  * based searching, since we simply search up to that character, but not  * including it.  */
end_comment

begin_function
specifier|static
name|int
name|get_a_record
parameter_list|(
name|out
parameter_list|,
name|iop
parameter_list|,
name|grRS
parameter_list|,
name|RSre
parameter_list|,
name|errcode
parameter_list|)
name|char
modifier|*
modifier|*
name|out
decl_stmt|;
comment|/* pointer to pointer to data */
name|IOBUF
modifier|*
name|iop
decl_stmt|;
comment|/* input IOP */
specifier|register
name|int
name|grRS
decl_stmt|;
comment|/* first char in RS->stptr */
name|Regexp
modifier|*
name|RSre
decl_stmt|;
comment|/* regexp for RS */
name|int
modifier|*
name|errcode
decl_stmt|;
comment|/* pointer to error variable */
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|iop
operator|->
name|off
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|iop
operator|->
name|off
decl_stmt|;
comment|/* beginning of record */
name|int
name|rs
decl_stmt|;
specifier|static
name|Regexp
modifier|*
name|RS_null_re
init|=
name|NULL
decl_stmt|;
name|Regexp
modifier|*
name|rsre
init|=
name|NULL
decl_stmt|;
name|int
name|continuing
init|=
name|FALSE
decl_stmt|,
name|continued
init|=
name|FALSE
decl_stmt|;
comment|/* used for re matching */
name|int
name|onecase
decl_stmt|;
comment|/* first time through */
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
block|{
name|RS_null_re
operator|=
name|make_regexp
argument_list|(
literal|"\n\n+"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"internal error: file `%s', line %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
comment|/* previous read hit EOF */
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|RS_is_null
condition|)
comment|/* special case:  RS == "" */
name|rs
operator|=
literal|'\n'
expr_stmt|;
else|else
name|rs
operator|=
operator|(
name|char
operator|)
name|grRS
expr_stmt|;
name|onecase
operator|=
operator|(
name|IGNORECASE
operator|&&
name|isalpha
argument_list|(
name|rs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|onecase
condition|)
name|rs
operator|=
name|casetable
index|[
name|rs
index|]
expr_stmt|;
comment|/* set up sentinel */
if|if
condition|(
name|iop
operator|->
name|buf
condition|)
block|{
name|bufend
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
operator|*
name|bufend
operator|=
name|rs
expr_stmt|;
comment|/* add sentinel to buffer */
block|}
else|else
name|bufend
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* break on end of record, read error or EOF */
comment|/* buffer mgmt, chunk #1 */
comment|/* 		 * Following code is entered on the first call of this routine 		 * for a new iop, or when we scan to the end of the buffer. 		 * In the latter case, we copy the current partial record to 		 * the space preceding the normal read buffer.  If necessary, 		 * we expand this space.  This is done so that we can return 		 * the record as a contiguous area of memory. 		 */
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|==
literal|0
operator|&&
name|bp
operator|>=
name|bufend
condition|)
block|{
name|char
modifier|*
name|oldbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldsplit
init|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
decl_stmt|;
name|long
name|len
decl_stmt|;
comment|/* record length so far */
name|len
operator|=
name|bp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|iop
operator|->
name|secsiz
condition|)
block|{
comment|/* expand secondary buffer */
if|if
condition|(
name|iop
operator|->
name|secsiz
operator|==
operator|-
literal|2
condition|)
name|iop
operator|->
name|secsiz
operator|=
literal|256
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|iop
operator|->
name|secsiz
condition|)
name|iop
operator|->
name|secsiz
operator|*=
literal|2
expr_stmt|;
name|oldbuf
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|emalloc
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
operator|+
literal|2
argument_list|,
literal|"get_a_record"
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
operator|*
name|bufend
operator|=
name|rs
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|newsplit
init|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|oldsplit
condition|)
block|{
name|memcpy
argument_list|(
name|newsplit
operator|-
name|len
argument_list|,
name|start
argument_list|,
name|oldsplit
operator|-
name|start
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newsplit
operator|-
operator|(
name|bp
operator|-
name|oldsplit
operator|)
argument_list|,
name|oldsplit
argument_list|,
name|bp
operator|-
name|oldsplit
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|newsplit
operator|-
name|len
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
name|start
operator|=
name|bp
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|oldbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
name|oldbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* buffer mgmt, chunk #2 */
comment|/* 		 * Following code is entered whenever we have no more data to 		 * scan.  In most cases this will read into the beginning of 		 * the main buffer, but in some cases (terminal, pipe etc.) 		 * we may be doing smallish reads into more advanced positions. 		 */
if|if
condition|(
name|bp
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
name|iop
operator|->
name|cnt
operator|=
name|read
argument_list|(
name|iop
operator|->
name|fd
argument_list|,
name|iop
operator|->
name|end
argument_list|,
name|bufend
operator|-
name|iop
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|errcode
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errcode
operator|=
name|errno
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
else|else
name|fatal
argument_list|(
literal|"error reading input file `%s': %s"
argument_list|,
name|iop
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
comment|/* 				 * hit EOF before matching RS, so end 				 * the record and set RT to "" 				 */
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
comment|/* see comments below about this test */
if|if
condition|(
operator|!
name|continuing
condition|)
block|{
name|set_RT_to_null
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|!=
name|EOF
condition|)
block|{
name|iop
operator|->
name|end
operator|+=
name|iop
operator|->
name|cnt
expr_stmt|;
operator|*
name|iop
operator|->
name|end
operator|=
name|rs
expr_stmt|;
comment|/* reset the sentinel */
block|}
block|}
comment|/* buffers are now setup and filled with data */
comment|/* search for RS, #1, regexp based, or RS = "" */
comment|/* 		 * Attempt to simplify the code a bit. The case where 		 * RS = "" can also be described by a regexp, RS = "\n\n+". 		 * The buffer managment and searching code can thus now 		 * use a common case (the one for regexps) both when RS is 		 * a regexp, and when RS = "". This particularly benefits 		 * us for keeping track of how many newlines were matched 		 * in order to set RT. 		 */
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|RSre
operator|!=
name|NULL
condition|)
comment|/* regexp */
name|rsre
operator|=
name|RSre
expr_stmt|;
elseif|else
if|if
condition|(
name|RS_is_null
condition|)
comment|/* RS = "" */
name|rsre
operator|=
name|RS_null_re
expr_stmt|;
else|else
name|rsre
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Look for regexp match of RS.  Non-match conditions are: 		 *	1. No match at all 		 *	2. Match of a null string 		 *	3. Match ends at exact end of buffer 		 * Number 3 is subtle; we have to add more to the buffer 		 * in case the match would have extended further into the 		 * file, since regexp match by definition always matches the 		 * longest possible match. 		 * 		 * It is even more subtle than you might think. Suppose 		 * the re matches at exactly the end of file. We don't know 		 * that until we try to add more to the buffer. Thus, we 		 * set a flag to indicate, that if eof really does happen, 		 * don't break early. 		 */
name|continuing
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rsre
operator|!=
name|NULL
condition|)
block|{
name|again
label|:
comment|/* cases 1 and 2 are simple, just keep going */
if|if
condition|(
name|research
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|iop
operator|->
name|end
operator|-
name|start
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|==
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
condition|)
block|{
comment|/* 				 * Leading newlines at the beginning of the file 				 * should be ignored. Whew! 				 */
if|if
condition|(
name|RS_is_null
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
comment|/* 					 * have to catch the case of a 					 * single newline at the front of 					 * the record, which the regex 					 * doesn't. gurr. 					 */
while|while
condition|(
operator|*
name|start
operator|==
literal|'\n'
operator|&&
name|start
operator|<
name|iop
operator|->
name|end
condition|)
name|start
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|bp
operator|=
name|iop
operator|->
name|end
expr_stmt|;
continue|continue;
block|}
comment|/* case 3, regex match at exact end */
if|if
condition|(
name|start
operator|+
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|iop
operator|->
name|cnt
operator|!=
name|EOF
condition|)
block|{
name|bp
operator|=
name|iop
operator|->
name|end
expr_stmt|;
name|continuing
operator|=
name|continued
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* got a match! */
comment|/* 			 * Leading newlines at the beginning of the file 			 * should be ignored. Whew! 			 * 			 * Is this code ever executed? 			 */
if|if
condition|(
name|RS_is_null
operator|&&
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|+=
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|bp
operator|=
name|start
operator|+
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|set_RT
argument_list|(
name|bp
argument_list|,
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|-
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|start
operator|+
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* search for RS, #2, RS =<single char> */
if|if
condition|(
name|onecase
condition|)
block|{
while|while
condition|(
name|casetable
index|[
operator|(
name|int
operator|)
operator|*
name|bp
operator|++
index|]
operator|!=
name|rs
condition|)
continue|continue;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|bp
operator|++
operator|!=
name|rs
condition|)
continue|continue;
block|}
name|set_RT
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|<=
name|iop
operator|->
name|end
condition|)
break|break;
else|else
name|bp
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
name|iop
operator|->
name|cnt
operator|=
name|bp
operator|-
name|start
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
name|EOF
operator|&&
operator|(
operator|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|start
operator|==
name|bp
operator|&&
operator|!
name|continued
operator|)
operator|)
condition|)
block|{
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|do_traditional
operator|||
name|rsre
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|bstart
decl_stmt|;
name|bstart
operator|=
name|iop
operator|->
name|off
operator|=
name|bp
expr_stmt|;
name|bp
operator|--
expr_stmt|;
if|if
condition|(
name|onecase
condition|?
name|casetable
index|[
operator|(
name|int
operator|)
operator|*
name|bp
index|]
operator|!=
name|rs
else|:
operator|*
name|bp
operator|!=
name|rs
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|bstart
operator|=
name|bp
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RS_is_null
operator|&&
name|iop
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
comment|/* 		 * special case, delete trailing newlines, 		 * should never be more than one. 		 */
while|while
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|--
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|out
operator|=
name|start
expr_stmt|;
return|return
name|bp
operator|-
name|start
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
name|rs
index|[
literal|2
index|]
decl_stmt|;
name|rs
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|bufsize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|rs
index|[
literal|0
index|]
operator|=
operator|*
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|iop
operator|=
name|iop_alloc
argument_list|(
literal|0
argument_list|,
literal|"stdin"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|out
argument_list|,
name|iop
argument_list|,
name|rs
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|cnt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|rs
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP
end_ifdef

begin_comment
comment|/* mmap_get_record --- pull a record out of a memory-mapped file */
end_comment

begin_function
specifier|static
name|int
name|mmap_get_record
parameter_list|(
name|out
parameter_list|,
name|iop
parameter_list|,
name|grRS
parameter_list|,
name|RSre
parameter_list|,
name|errcode
parameter_list|)
name|char
modifier|*
modifier|*
name|out
decl_stmt|;
comment|/* pointer to pointer to data */
name|IOBUF
modifier|*
name|iop
decl_stmt|;
comment|/* input IOP */
specifier|register
name|int
name|grRS
decl_stmt|;
comment|/* first char in RS->stptr */
name|Regexp
modifier|*
name|RSre
decl_stmt|;
comment|/* regexp for RS */
name|int
modifier|*
name|errcode
decl_stmt|;
comment|/* pointer to error variable */
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|iop
operator|->
name|off
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|iop
operator|->
name|off
decl_stmt|;
comment|/* beginning of record */
name|int
name|rs
decl_stmt|;
specifier|static
name|Regexp
modifier|*
name|RS_null_re
init|=
name|NULL
decl_stmt|;
name|Regexp
modifier|*
name|rsre
init|=
name|NULL
decl_stmt|;
name|int
name|onecase
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|iop
operator|->
name|end
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* first time through */
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
block|{
name|RS_null_re
operator|=
name|make_regexp
argument_list|(
literal|"\n\n+"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"internal error: file `%s', line %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|->
name|off
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
comment|/* previous record was last */
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
comment|/* tested by higher level code */
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|RS_is_null
condition|)
comment|/* special case:  RS == "" */
name|rs
operator|=
literal|'\n'
expr_stmt|;
else|else
name|rs
operator|=
operator|(
name|char
operator|)
name|grRS
expr_stmt|;
name|onecase
operator|=
operator|(
name|IGNORECASE
operator|&&
name|isalpha
argument_list|(
name|rs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|onecase
condition|)
name|rs
operator|=
name|casetable
index|[
name|rs
index|]
expr_stmt|;
comment|/* if RS = "", skip leading newlines at the front of the file */
if|if
condition|(
name|RS_is_null
operator|&&
name|iop
operator|->
name|off
operator|==
name|iop
operator|->
name|buf
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|iop
operator|->
name|off
init|;
operator|*
name|bp
operator|==
literal|'\n'
condition|;
name|bp
operator|++
control|)
continue|continue;
if|if
condition|(
name|bp
operator|!=
name|iop
operator|->
name|off
condition|)
name|iop
operator|->
name|off
operator|=
name|start
operator|=
name|bp
expr_stmt|;
block|}
comment|/* 	 * Regexp based searching. Either RS = "" or RS =<regex> 	 * See comments in get_a_record. 	 */
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|RSre
operator|!=
name|NULL
condition|)
comment|/* regexp */
name|rsre
operator|=
name|RSre
expr_stmt|;
elseif|else
if|if
condition|(
name|RS_is_null
condition|)
comment|/* RS = "" */
name|rsre
operator|=
name|RS_null_re
expr_stmt|;
else|else
name|rsre
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Look for regexp match of RS.  Non-match conditions are: 	 *	1. No match at all 	 *	2. Match of a null string 	 *	3. Match ends at exact end of buffer 	 * 	 * #1 means that the record ends the file 	 * and there is no text that actually matched RS. 	 * 	 * #2: is probably like #1. 	 * 	 * #3 is simple; since we have the whole file mapped, it's 	 * the last record in the file. 	 */
if|if
condition|(
name|rsre
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|research
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|iop
operator|->
name|end
operator|-
name|start
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|==
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
condition|)
block|{
comment|/* no matching text, we have the record */
operator|*
name|out
operator|=
name|start
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|end
expr_stmt|;
comment|/* all done with the record */
name|set_RT_to_null
argument_list|()
expr_stmt|;
comment|/* special case, don't allow trailing newlines */
if|if
condition|(
name|RS_is_null
operator|&&
operator|*
operator|(
name|iop
operator|->
name|end
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
return|return
name|iop
operator|->
name|end
operator|-
name|start
operator|-
literal|1
return|;
else|else
return|return
name|iop
operator|->
name|end
operator|-
name|start
return|;
block|}
comment|/* have a match */
operator|*
name|out
operator|=
name|start
expr_stmt|;
name|bp
operator|=
name|start
operator|+
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|set_RT
argument_list|(
name|bp
argument_list|,
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|-
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|start
operator|+
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
name|bp
operator|-
name|start
return|;
block|}
comment|/* 	 * RS = "?", i.e., one character based searching. 	 * 	 * Alas, we can't just plug the sentinel character in at 	 * the end of the mmapp'ed file ( *(iop->end) = rs; ). This 	 * works if we're lucky enough to have a file that does not 	 * take up all of its last disk block. But if we end up with 	 * file whose size is an even multiple of the disk block size, 	 * assigning past the end of it delivers a SIGBUS. So, we have to 	 * add the extra test in the while loop at the front that looks 	 * for going past the end of the mapped object. Sigh. 	 */
comment|/* search for RS, #2, RS =<single char> */
if|if
condition|(
name|onecase
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|end
operator|&&
name|casetable
index|[
operator|*
name|bp
operator|++
index|]
operator|!=
name|rs
condition|)
continue|continue;
block|}
else|else
block|{
while|while
condition|(
name|bp
operator|<
name|end
operator|&&
operator|*
name|bp
operator|++
operator|!=
name|rs
condition|)
continue|continue;
block|}
name|cnt
operator|=
operator|(
name|bp
operator|-
name|start
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
comment|/* at end, may have actually seen rs, or may not */
if|if
condition|(
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
name|rs
condition|)
name|set_RT
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* real RS seen */
else|else
block|{
name|cnt
operator|++
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|set_RT
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|bp
expr_stmt|;
operator|*
name|out
operator|=
name|start
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MMAP */
end_comment

begin_comment
comment|/* set_RS --- update things as appropriate when RS is set */
end_comment

begin_function
name|void
name|set_RS
parameter_list|()
block|{
specifier|static
name|NODE
modifier|*
name|save_rs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|save_rs
operator|&&
name|cmp_nodes
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|,
name|save_rs
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|unref
argument_list|(
name|save_rs
argument_list|)
expr_stmt|;
name|save_rs
operator|=
name|dupnode
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RS_is_null
operator|=
name|FALSE
expr_stmt|;
name|RS
operator|=
name|force_string
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_regexp
operator|!=
name|NULL
condition|)
block|{
name|refree
argument_list|(
name|RS_regexp
argument_list|)
expr_stmt|;
name|RS_regexp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|RS
operator|->
name|stlen
operator|==
literal|0
condition|)
name|RS_is_null
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|RS
operator|->
name|stlen
operator|>
literal|1
condition|)
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
name|RS_regexp
operator|=
name|make_regexp
argument_list|(
name|RS
operator|->
name|stptr
argument_list|,
name|RS
operator|->
name|stlen
argument_list|,
name|IGNORECASE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warning
argument_list|(
literal|"multicharacter value of `RS' is not portable"
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|set_FS_if_not_FIELDWIDTHS
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

