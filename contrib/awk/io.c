begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * io.c --- routines for dealing with input and output and records  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1976, 1988, 1989, 1991-2001 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_undef
undef|#
directive|undef
name|RE_DUP_MAX
end_undef

begin_comment
comment|/* avoid spurious conflict w/regex.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PARAM_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_WAIT_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_ACCMODE
end_ifndef

begin_define
define|#
directive|define
name|O_ACCMODE
value|(O_RDONLY|O_WRONLY|O_RDWR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_SOCKET_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINET_IN_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETDB_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISREG
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFREG
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ENFILE
end_ifndef

begin_define
define|#
directive|define
name|ENFILE
value|EMFILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|MRL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_enum
enum|enum
name|inet_prot
block|{
name|INET_NONE
block|,
name|INET_TCP
block|,
name|INET_UDP
block|,
name|INET_RAW
block|}
enum|;
end_enum

begin_ifndef
ifndef|#
directive|ifndef
name|SHUT_RD
end_ifndef

begin_define
define|#
directive|define
name|SHUT_RD
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHUT_WR
end_ifndef

begin_define
define|#
directive|define
name|SHUT_WR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHUT_RDWR
end_ifndef

begin_define
define|#
directive|define
name|SHUT_RDWR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|TANDEM
argument_list|)
end_if

begin_define
define|#
directive|define
name|PIPES_SIMULATED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|CLOSE_ALL
block|,
name|CLOSE_TO
block|,
name|CLOSE_FROM
block|}
name|two_way_close_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|nextfile
name|P
argument_list|(
operator|(
name|int
name|skipping
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inrec
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iop_close
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|redirect
modifier|*
name|redirect
name|P
argument_list|(
operator|(
name|NODE
operator|*
name|tree
operator|,
name|int
operator|*
name|errflg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_one
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|close_redir
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|,
name|int
name|exitwarn
operator|,
name|two_way_close_type
name|how
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|wait_any
name|P
argument_list|(
operator|(
name|int
name|interesting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
name|P
argument_list|(
operator|(
name|char
operator|*
name|cmd
operator|,
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|iop_open
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|how
operator|,
name|IOBUF
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|IOBUF
modifier|*
name|iop_alloc
name|P
argument_list|(
operator|(
name|int
name|fd
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
name|IOBUF
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gawk_pclose
name|P
argument_list|(
operator|(
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pathopen
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_a_record
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|out
operator|,
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|rs
operator|,
name|Regexp
operator|*
name|RSre
operator|,
name|int
operator|*
name|errcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|str2mode
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|spec_setup
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
name|int
name|len
operator|,
name|int
name|allocate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specfdopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pidopen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|useropen
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
name|iop
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|two_way_open
name|P
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
expr|struct
name|redirect
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POPEN_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"popen.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|redirect
modifier|*
name|red_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|RS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Regexp
modifier|*
name|RS_regexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|RS_is_null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|output_is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGC_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGV_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ARGIND_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
name|ERRNO_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|filebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for do_nextfile() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|binmode
parameter_list|(
name|char
modifier|*
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
operator|(
name|BINMODE
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
literal|"rb"
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
name|BINMODE
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
operator|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'w'
condition|?
literal|"wb"
else|:
literal|"ab"
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|binmode
parameter_list|(
name|mode
parameter_list|)
value|(mode)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* File pointers have an extra level of indirection, and there are cases where    `stdin' can be null.  That can crash gawk if fileno() is used as-is.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vmsrtl_fileno
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vmsrtl_fileno
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|fileno
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|fileno
end_undef

begin_define
define|#
directive|define
name|fileno
parameter_list|(
name|FP
parameter_list|)
value|(((FP)&& *(FP)) ? vmsrtl_fileno(FP) : -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/* do_nextfile --- implement gawk "nextfile" extension */
end_comment

begin_function
name|void
name|do_nextfile
parameter_list|()
block|{
operator|(
name|void
operator|)
name|nextfile
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|filebuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nextfile --- move to the next input data file */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|nextfile
parameter_list|(
name|int
name|skipping
parameter_list|)
block|{
specifier|static
name|long
name|i
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|files
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
name|arg
decl_stmt|;
specifier|static
name|IOBUF
modifier|*
name|curfile
init|=
name|NULL
decl_stmt|;
specifier|static
name|IOBUF
name|mybuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|skipping
condition|)
block|{
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|curfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curfile
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|curfile
return|;
block|}
for|for
control|(
init|;
name|i
operator|<
call|(
name|long
call|)
argument_list|(
name|ARGC_node
operator|->
name|lnode
operator|->
name|numbr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
operator|*
name|assoc_lookup
argument_list|(
name|ARGV_node
argument_list|,
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|stlen
operator|==
literal|0
condition|)
continue|continue;
name|arg
operator|->
name|stptr
index|[
name|arg
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
name|unref
argument_list|(
name|ARGIND_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ARGIND_node
operator|->
name|var_value
operator|=
name|make_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arg_assign
argument_list|(
name|arg
operator|->
name|stptr
argument_list|)
condition|)
block|{
name|files
operator|++
expr_stmt|;
name|fname
operator|=
name|arg
operator|->
name|stptr
expr_stmt|;
name|curfile
operator|=
name|iop_open
argument_list|(
name|fname
argument_list|,
name|binmode
argument_list|(
literal|"r"
argument_list|)
argument_list|,
operator|&
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
goto|goto
name|give_up
goto|;
name|curfile
operator|->
name|flag
operator||=
name|IOP_NOFREE_OBJ
expr_stmt|;
comment|/* This is a kludge.  */
name|unref
argument_list|(
name|FILENAME_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|FILENAME_node
operator|->
name|var_value
operator|=
name|dupnode
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|FNR
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|files
operator|==
literal|0
condition|)
block|{
name|files
operator|++
expr_stmt|;
comment|/* no args. -- use stdin */
comment|/* FNR is init'ed to 0 */
name|FILENAME_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fname
operator|=
literal|"-"
expr_stmt|;
name|curfile
operator|=
name|iop_open
argument_list|(
name|fname
argument_list|,
name|binmode
argument_list|(
literal|"r"
argument_list|)
argument_list|,
operator|&
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfile
operator|==
name|NULL
condition|)
goto|goto
name|give_up
goto|;
name|curfile
operator|->
name|flag
operator||=
name|IOP_NOFREE_OBJ
expr_stmt|;
block|}
return|return
name|curfile
return|;
name|give_up
label|:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open file `%s' for reading (%s)"
argument_list|)
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* set_FNR --- update internal FNR from awk variable */
end_comment

begin_function
name|void
name|set_FNR
parameter_list|()
block|{
name|FNR
operator|=
operator|(
name|long
operator|)
name|FNR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_NR --- update internal NR from awk variable */
end_comment

begin_function
name|void
name|set_NR
parameter_list|()
block|{
name|NR
operator|=
operator|(
name|long
operator|)
name|NR_node
operator|->
name|var_value
operator|->
name|numbr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* inrec --- This reads in a record from the input file */
end_comment

begin_function
specifier|static
name|int
name|inrec
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|)
block|{
name|char
modifier|*
name|begin
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|=
name|iop
operator|->
name|cnt
operator|)
operator|!=
name|EOF
condition|)
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|begin
argument_list|,
name|iop
argument_list|,
name|RS
operator|->
name|stptr
index|[
literal|0
index|]
argument_list|,
name|RS_regexp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|NR
operator|+=
literal|1
expr_stmt|;
name|FNR
operator|+=
literal|1
expr_stmt|;
name|set_record
argument_list|(
name|begin
argument_list|,
name|cnt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* iop_close --- close an open IOP */
end_comment

begin_function
specifier|static
name|int
name|iop_close
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_CRAY
comment|/* Work around bug in UNICOS popen */
if|if
condition|(
name|iop
operator|->
name|fd
operator|<
literal|3
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* save these for re-use; don't free the storage */
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Don't close standard files or else crufty code elsewhere will lose */
if|if
condition|(
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
operator|||
name|iop
operator|->
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
name|close
argument_list|(
name|iop
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"close of fd %d (`%s') failed (%s)"
argument_list|)
argument_list|,
name|iop
operator|->
name|fd
argument_list|,
name|iop
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_NO_FREE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Be careful -- $0 may still reference the buffer even though 		 * an explicit close is being done; in the future, maybe we 		 * can do this a bit better. 		 */
if|if
condition|(
name|iop
operator|->
name|buf
condition|)
block|{
if|if
condition|(
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|>=
name|iop
operator|->
name|buf
operator|)
operator|&&
operator|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|<
operator|(
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
operator|+
name|iop
operator|->
name|size
operator|)
operator|)
condition|)
block|{
name|NODE
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|make_string
argument_list|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|reset_record
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_NOFREE_OBJ
operator|)
operator|==
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iop
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* do_input --- the main input processing loop */
end_comment

begin_function
name|void
name|do_input
parameter_list|()
block|{
name|IOBUF
modifier|*
name|iop
decl_stmt|;
specifier|extern
name|int
name|exiting
decl_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
comment|/* for `nextfile' */
while|while
condition|(
operator|(
name|iop
operator|=
name|nextfile
argument_list|(
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
while|while
condition|(
name|interpret
argument_list|(
name|expression_value
argument_list|)
operator|&&
name|inrec
argument_list|(
name|iop
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|exiting
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* redflags2str --- turn redirection flags into a string, for debugging */
end_comment

begin_function
name|char
modifier|*
name|redflags2str
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|struct
name|flagtab
name|redtab
index|[]
init|=
block|{
block|{
name|RED_FILE
block|,
literal|"RED_FILE"
block|}
block|,
block|{
name|RED_PIPE
block|,
literal|"RED_PIPE"
block|}
block|,
block|{
name|RED_READ
block|,
literal|"RED_READ"
block|}
block|,
block|{
name|RED_WRITE
block|,
literal|"RED_WRITE"
block|}
block|,
block|{
name|RED_APPEND
block|,
literal|"RED_APPEND"
block|}
block|,
block|{
name|RED_NOBUF
block|,
literal|"RED_NOBUF"
block|}
block|,
block|{
name|RED_EOF
block|,
literal|"RED_EOF"
block|}
block|,
block|{
name|RED_TWOWAY
block|,
literal|"RED_TWOWAY"
block|}
block|,
block|{
name|RED_SOCKET
block|,
literal|"RED_SOCKET"
block|}
block|,
block|{
name|RED_TCP
block|,
literal|"RED_TCP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
return|return
name|genflags2str
argument_list|(
name|flags
argument_list|,
name|redtab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* redirect --- Redirection for printf and print commands */
end_comment

begin_function
name|struct
name|redirect
modifier|*
name|redirect
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|,
name|int
modifier|*
name|errflg
parameter_list|)
block|{
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|tflag
init|=
literal|0
decl_stmt|;
name|int
name|outflag
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|direction
init|=
literal|"to"
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_append
case|:
name|tflag
operator|=
name|RED_APPEND
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|Node_redirect_output
case|:
name|outflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|tflag
operator||=
name|outflag
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
condition|)
name|what
operator|=
literal|">"
expr_stmt|;
else|else
name|what
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|tflag
operator|=
operator|(
name|RED_PIPE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|tflag
operator|=
operator|(
name|RED_FILE
operator||
name|RED_READ
operator|)
expr_stmt|;
name|what
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|Node_redirect_twoway
case|:
name|tflag
operator|=
operator|(
name|RED_READ
operator||
name|RED_WRITE
operator||
name|RED_TWOWAY
operator|)
expr_stmt|;
name|what
operator|=
literal|"|&"
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid tree type %s in redirect()"
argument_list|)
argument_list|,
name|nodetype2str
argument_list|(
name|tree
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|subnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
name|STR
operator|)
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"expression in `%s' redirection only has numeric value"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|str
operator|=
name|tmp
operator|->
name|stptr
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"expression for `%s' redirection has null string value"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"0"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|||
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"1"
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|)
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"filename `%s' for `%s' redirection may be result of logical expression"
argument_list|)
argument_list|,
name|str
argument_list|,
name|what
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
if|if
condition|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"/inet/"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|tflag
operator||=
name|RED_SOCKET
expr_stmt|;
if|if
condition|(
name|STREQN
argument_list|(
name|str
operator|+
literal|6
argument_list|,
literal|"tcp/"
argument_list|,
literal|4
argument_list|)
condition|)
name|tflag
operator||=
name|RED_TCP
expr_stmt|;
comment|/* use shutdown when closing */
block|}
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|str
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
operator|&&
operator|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|~
operator|(
name|RED_NOBUF
operator||
name|RED_EOF
operator|)
operator|)
operator|==
name|tflag
operator|||
operator|(
name|outflag
operator|!=
literal|0
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_FILE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
name|outflag
operator|)
operator|)
condition|)
block|{
name|int
name|rpflag
init|=
operator|(
name|rp
operator|->
name|flag
operator|&
operator|~
operator|(
name|RED_NOBUF
operator||
name|RED_EOF
operator|)
operator|)
decl_stmt|;
name|int
name|newflag
init|=
operator|(
name|tflag
operator|&
operator|~
operator|(
name|RED_NOBUF
operator||
name|RED_EOF
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
name|rpflag
operator|!=
name|newflag
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"unnecessary mixing of `>' and `>>' for file `%.*s'"
argument_list|)
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|emalloc
argument_list|(
name|rp
argument_list|,
expr|struct
name|redirect
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|redirect
argument_list|)
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|emalloc
argument_list|(
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|tmp
operator|->
name|stlen
operator|+
literal|1
argument_list|,
literal|"redirect"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|str
index|[
name|tmp
operator|->
name|stlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|rp
operator|->
name|flag
operator|=
name|tflag
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
comment|/* unlikely that we're worried about init */
name|rp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* maintain list in most-recently-used first order */
if|if
condition|(
name|red_head
operator|!=
name|NULL
condition|)
name|red_head
operator|->
name|prev
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|red_head
expr_stmt|;
name|red_head
operator|=
name|rp
expr_stmt|;
block|}
else|else
name|str
operator|=
name|rp
operator|->
name|value
expr_stmt|;
comment|/* get \0 terminated string */
while|while
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_EOF
condition|)
comment|/* 			 * encountered EOF on file or pipe -- must be cleared 			 * by explicit close() before reading more 			 */
return|return
name|rp
return|;
name|mode
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
condition|)
block|{
case|case
name|Node_redirect_output
case|:
name|mode
operator|=
name|binmode
argument_list|(
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_USED
operator|)
operator|!=
literal|0
condition|)
name|mode
operator|=
operator|(
name|rp
operator|->
name|mode
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
condition|?
literal|"ab"
else|:
literal|"a"
expr_stmt|;
break|break;
case|case
name|Node_redirect_append
case|:
name|mode
operator|=
name|binmode
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipe
case|:
comment|/* synchronize output before new pipe */
operator|(
name|void
operator|)
name|flush_io
argument_list|()
expr_stmt|;
name|os_restore_mode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|fp
operator|=
name|popen
argument_list|(
name|str
argument_list|,
name|binmode
argument_list|(
literal|"w"
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't open pipe `%s' for output (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set close-on-exec */
name|os_close_on_exec
argument_list|(
name|fileno
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
argument_list|,
name|str
argument_list|,
literal|"pipe"
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
break|break;
case|case
name|Node_redirect_pipein
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
if|if
condition|(
name|gawk_popen
argument_list|(
name|str
argument_list|,
name|rp
argument_list|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't open pipe `%s' for input (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_redirect_input
case|:
name|direction
operator|=
literal|"from"
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_open
argument_list|(
name|str
argument_list|,
name|binmode
argument_list|(
literal|"r"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|Node_redirect_twoway
case|:
name|direction
operator|=
literal|"to/from"
expr_stmt|;
if|if
condition|(
operator|!
name|two_way_open
argument_list|(
name|str
argument_list|,
name|rp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
comment|/* multiple messages make life easier for translators */
if|if
condition|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"/inet/"
argument_list|,
literal|6
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't open two way socket `%s' for input/output (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't open two way pipe `%s' for input/output (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|str
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
name|INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|==
name|fileno
argument_list|(
name|stderr
argument_list|)
condition|)
name|rp
operator|->
name|fp
operator|=
name|stderr
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|F_GETFL
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_APPEND
argument_list|)
name|int
name|fd_flags
decl_stmt|;
name|fd_flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_flags
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|fd_flags
operator|&
name|O_APPEND
operator|)
operator|==
name|O_APPEND
condition|)
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|binmode
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mode
argument_list|)
expr_stmt|;
name|rp
operator|->
name|mode
operator|=
operator|(
name|char
operator|*
operator|)
name|mode
expr_stmt|;
comment|/* don't leak file descriptors */
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
operator|&&
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|rp
operator|->
name|flag
operator||=
name|RED_NOBUF
expr_stmt|;
comment|/* Move rp to the head of the list. */
if|if
condition|(
name|red_head
operator|!=
name|rp
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|prev
operator|->
name|next
operator|=
name|rp
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|next
operator|->
name|prev
operator|=
name|rp
operator|->
name|prev
expr_stmt|;
name|red_head
operator|->
name|prev
operator|=
name|rp
expr_stmt|;
name|rp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|next
operator|=
name|red_head
expr_stmt|;
name|red_head
operator|=
name|rp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
comment|/* too many files open -- close one and try again */
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|close_one
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
name|__MINGW32__
operator|||
name|defined
name|solaris
elseif|else
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
comment|/* HACK! */
name|close_one
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
comment|/* Alpha/VMS V7.1's C RTL is returning this instead 			   of EMFILE (haven't tried other post-V6.2 systems) */
define|#
directive|define
name|SS$_EXQUOTA
value|0x001C
elseif|else
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
name|vaxc$errno
operator|==
name|SS$_EXQUOTA
condition|)
name|close_one
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|else
block|{
comment|/* 				 * Some other reason for failure. 				 * 				 * On redirection of input from a file, 				 * just return an error, so e.g. getline 				 * can return -1.  For output to file, 				 * complain. The shell will complain on 				 * a bad command to a pipe. 				 */
if|if
condition|(
name|errflg
operator|!=
name|NULL
condition|)
operator|*
name|errflg
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|Node_redirect_output
operator|||
name|tree
operator|->
name|type
operator|==
name|Node_redirect_append
condition|)
block|{
comment|/* multiple messages make life easier for translators */
if|if
condition|(
operator|*
name|direction
operator|==
literal|'f'
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't redirect from `%s' (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"can't redirect to `%s' (%s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_comment
comment|/* getredirect --- find the struct redirect for this file or pipe */
end_comment

begin_function
name|struct
name|redirect
modifier|*
name|getredirect
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|len
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|rp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* close_one --- temporarily close an open file to re-use the fd */
end_comment

begin_function
specifier|static
name|void
name|close_one
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rplast
init|=
name|NULL
decl_stmt|;
specifier|static
name|short
name|warned
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
name|TRUE
expr_stmt|;
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"reached system limit for open files: starting to multiplex file descriptors"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* go to end of list first, to pick up least recently used entry */
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
name|rplast
operator|=
name|rp
expr_stmt|;
comment|/* now work back up through the list */
for|for
control|(
name|rp
operator|=
name|rplast
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|prev
control|)
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_FILE
operator|)
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|flag
operator||=
name|RED_USED
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
comment|/* do_lint&& */
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"close of `%s' failed (%s)."
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* surely this is the only reason ??? */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"too many pipes or input files open"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_close --- completely close an open file or pipe */
end_comment

begin_function
name|NODE
modifier|*
name|do_close
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|NODE
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|two_way_close_type
name|how
init|=
name|CLOSE_ALL
decl_stmt|;
comment|/* default */
name|tmp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1st arg: redir to close */
if|if
condition|(
name|tree
operator|->
name|rnode
operator|!=
name|NULL
condition|)
block|{
comment|/* 2nd arg if present: "to" or "from" for two-way pipe */
comment|/* DO NOT use _() on the strings here! */
name|tmp2
operator|=
name|force_string
argument_list|(
name|tree
operator|->
name|rnode
operator|->
name|lnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|tmp2
operator|->
name|stptr
argument_list|,
literal|"to"
argument_list|)
operator|==
literal|0
condition|)
name|how
operator|=
name|CLOSE_TO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tmp2
operator|->
name|stptr
argument_list|,
literal|"from"
argument_list|)
operator|==
literal|0
condition|)
name|how
operator|=
name|CLOSE_FROM
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close: second argument must be `to' or `from'"
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rp
operator|->
name|value
argument_list|)
operator|==
name|tmp
operator|->
name|stlen
operator|&&
name|STREQN
argument_list|(
name|rp
operator|->
name|value
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* no match, return -1 */
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|do_lint
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"close: `%.*s' is not an open file, pipe or co-process"
argument_list|)
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|)
expr_stmt|;
comment|/* update ERRNO manually, using errno = ENOENT is a stretch. */
name|cp
operator|=
name|_
argument_list|(
literal|"close of redirection that was never opened"
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|ERRNO_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ERRNO_node
operator|->
name|var_value
operator|=
name|make_string
argument_list|(
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* synchronize regular output */
name|tmp
operator|=
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
name|close_redir
argument_list|(
name|rp
argument_list|,
name|FALSE
argument_list|,
name|how
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* close_redir --- close an open file or pipe */
end_comment

begin_function
specifier|static
name|int
name|close_redir
parameter_list|(
specifier|register
name|struct
name|redirect
modifier|*
name|rp
parameter_list|,
name|int
name|exitwarn
parameter_list|,
name|two_way_close_type
name|how
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|stdout
operator|||
name|rp
operator|->
name|fp
operator|==
name|stderr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|do_lint
operator|&&
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
operator|)
operator|==
literal|0
operator|&&
name|how
operator|!=
name|CLOSE_ALL
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"close: redirection `%s' not opened with `|&', second argument ignored"
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* two-way pipe */
comment|/* write end: */
if|if
condition|(
operator|(
name|how
operator|==
name|CLOSE_ALL
operator|||
name|how
operator|==
name|CLOSE_TO
operator|)
operator|&&
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TCP
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
name|status
operator|=
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* read end: */
if|if
condition|(
name|how
operator|==
name|CLOSE_ALL
operator|||
name|how
operator|==
name|CLOSE_FROM
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_SOCKET
operator|)
operator|!=
literal|0
operator|&&
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TCP
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|rp
operator|->
name|iop
operator|->
name|fd
argument_list|,
name|SHUT_RD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|gawk_pclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
operator|)
operator|==
operator|(
name|RED_PIPE
operator||
name|RED_WRITE
operator|)
condition|)
block|{
comment|/* write to pipe */
name|status
operator|=
name|pclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BINMODE
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|os_setbinmode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
comment|/* write to file */
name|status
operator|=
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
block|{
comment|/* read from pipe/file */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|!=
literal|0
condition|)
comment|/* read from pipe */
name|status
operator|=
name|gawk_pclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
comment|/* gawk_pclose sets rp->iop to null */
else|else
block|{
comment|/* read from file */
name|status
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* SVR4 awk checks and warns about status of close */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
comment|/* 		 * Too many people have complained about this. 		 * As of 2.15.6, it is now under lint control. 		 */
if|if
condition|(
name|do_lint
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|!=
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"failure status (%d) on pipe close of `%s' (%s)"
argument_list|)
argument_list|,
name|status
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"failure status (%d) on file close of `%s' (%s)"
argument_list|)
argument_list|,
name|status
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_traditional
condition|)
block|{
comment|/* set ERRNO too so that program can get at it */
name|update_ERRNO
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exitwarn
condition|)
block|{
comment|/* 		 * Don't use lintwarn() here.  If lint warnings are fatal, 		 * doing so prevents us from closing other open redirections. 		 * 		 * Using multiple full messages instead of string parameters 		 * for the types makes message translation easier. 		 */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_SOCKET
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"no explicit close of socket `%s' provided"
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"no explicit close of co-process `%s' provided"
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
operator|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"no explicit close of pipe `%s' provided"
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"no explicit close of file `%s' provided"
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* remove it from the list if closing both or both ends have been closed */
if|if
condition|(
name|how
operator|==
name|CLOSE_ALL
operator|||
operator|(
name|rp
operator|->
name|iop
operator|==
name|NULL
operator|&&
name|rp
operator|->
name|fp
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|next
operator|->
name|prev
operator|=
name|rp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|rp
operator|->
name|prev
operator|->
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
else|else
name|red_head
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* flush_io --- flush all open output files */
end_comment

begin_function
name|int
name|flush_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"error writing standard output (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"error writing standard error (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|rp
operator|->
name|next
control|)
comment|/* flush both files and pipes, what the heck */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
name|RED_WRITE
operator|)
operator|&&
name|rp
operator|->
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_PIPE
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"pipe flush of `%s' failed (%s)."
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|flag
operator|&
name|RED_TWOWAY
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"co-process flush of pipe to `%s' failed (%s)."
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|_
argument_list|(
literal|"file flush of `%s' failed (%s)."
argument_list|)
argument_list|,
name|rp
operator|->
name|value
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* canonicalize it */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* close_io --- close all open files, called when exiting */
end_comment

begin_function
name|int
name|close_io
parameter_list|()
block|{
specifier|register
name|struct
name|redirect
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|redirect
modifier|*
name|next
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|red_head
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|rp
operator|->
name|next
expr_stmt|;
comment|/* 		 * close_redir() will print a message if needed 		 * if do_lint, warn about lack of explicit close 		 */
if|if
condition|(
name|close_redir
argument_list|(
name|rp
argument_list|,
name|do_lint
argument_list|,
name|CLOSE_ALL
argument_list|)
condition|)
name|status
operator|++
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Some of the non-Unix os's have problems doing an fclose 	 * on stdout and stderr.  Since we don't really need to close 	 * them, we just flush them, and do that across the board. 	 */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"error writing standard output (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|stderr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"error writing standard error (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|++
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* str2mode --- convert a string mode to an integer mode */
end_comment

begin_function
specifier|static
name|int
name|str2mode
parameter_list|(
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|second
init|=
operator|&
name|mode
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'b'
condition|)
name|second
operator|++
expr_stmt|;
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'r'
case|:
name|ret
operator|=
name|O_RDONLY
expr_stmt|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'+'
operator|||
operator|*
name|second
operator|==
literal|'w'
condition|)
name|ret
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'+'
operator|||
operator|*
name|second
operator|==
literal|'r'
condition|)
name|ret
operator|=
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ret
operator|=
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
expr_stmt|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'+'
condition|)
name|ret
operator|=
name|O_RDWR
operator||
name|O_APPEND
operator||
name|O_CREAT
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* lint */
name|cant_happen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|mode
argument_list|,
literal|'b'
argument_list|)
operator|!=
name|NULL
condition|)
name|ret
operator||=
name|O_BINARY
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
end_ifdef

begin_comment
comment|/* socketopen --- open a socket and set it into connected state */
end_comment

begin_function
name|int
name|socketopen
parameter_list|(
name|enum
name|inet_prot
name|type
parameter_list|,
name|int
name|localport
parameter_list|,
name|int
name|remoteport
parameter_list|,
name|char
modifier|*
name|remotehostname
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|gethostbyname
argument_list|(
name|remotehostname
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
name|local_addr
decl_stmt|,
name|remote_addr
decl_stmt|;
name|int
name|socket_fd
decl_stmt|;
name|int
name|any_remote_host
init|=
name|strcmp
argument_list|(
name|remotehostname
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
name|socket_fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INET_TCP
case|:
if|if
condition|(
name|localport
operator|!=
literal|0
operator|||
name|remoteport
operator|!=
literal|0
condition|)
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_LINGER
name|struct
name|linger
name|linger
decl_stmt|;
name|memset
argument_list|(
operator|&
name|linger
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|socket_fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|setsockopt
argument_list|(
name|socket_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_LINGER
name|linger
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|linger
operator|.
name|l_linger
operator|=
literal|30
expr_stmt|;
comment|/* linger for 30/100 second */
name|setsockopt
argument_list|(
name|socket_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|linger
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|INET_UDP
case|:
if|if
condition|(
name|localport
operator|!=
literal|0
operator|||
name|remoteport
operator|!=
literal|0
condition|)
name|socket_fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
break|break;
case|case
name|INET_RAW
case|:
ifdef|#
directive|ifdef
name|SOCK_RAW
if|if
condition|(
name|localport
operator|==
literal|0
operator|&&
name|remoteport
operator|==
literal|0
condition|)
name|socket_fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_RAW
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|INET_NONE
case|:
comment|/* fall through */
default|default:
name|cant_happen
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|socket_fd
operator|<
literal|0
operator|||
name|socket_fd
operator|==
name|INVALID_HANDLE
operator|||
operator|(
name|hp
operator|==
name|NULL
operator|&&
name|any_remote_host
operator|!=
literal|0
operator|)
condition|)
return|return
name|INVALID_HANDLE
return|;
name|local_addr
operator|.
name|sin_family
operator|=
name|remote_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|remote_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|local_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|localport
argument_list|)
expr_stmt|;
name|remote_addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|remoteport
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|socket_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|local_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|local_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|any_remote_host
operator|!=
literal|0
condition|)
block|{
comment|/* not ANY => create a client */
if|if
condition|(
name|type
operator|==
name|INET_TCP
operator|||
name|type
operator|==
name|INET_UDP
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|remote_addr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|socket_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_addr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|socket_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|localport
operator|==
literal|0
condition|)
name|socket_fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
else|else
name|socket_fd
operator|=
name|socketopen
argument_list|(
name|type
argument_list|,
name|localport
argument_list|,
literal|0
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* /inet/raw client not ready yet */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"/inet/raw client not ready yet, sorry"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"only root may use `/inet/raw'."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* remote host is ANY => create a server */
if|if
condition|(
name|type
operator|==
name|INET_TCP
condition|)
block|{
name|int
name|clientsocket_fd
init|=
name|INVALID_HANDLE
decl_stmt|;
name|int
name|namelen
init|=
sizeof|sizeof
argument_list|(
name|remote_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|socket_fd
argument_list|,
literal|1
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|clientsocket_fd
operator|=
name|accept
argument_list|(
name|socket_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
operator|&
name|namelen
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|socket_fd
argument_list|)
expr_stmt|;
name|socket_fd
operator|=
name|clientsocket_fd
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|socket_fd
argument_list|)
expr_stmt|;
name|socket_fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|INET_UDP
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|readle
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_PEEK
if|if
condition|(
name|recvfrom
argument_list|(
name|socket_fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
name|MSG_PEEK
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
operator|&
name|readle
argument_list|)
operator|<
literal|1
operator|||
name|readle
operator|!=
sizeof|sizeof
argument_list|(
name|remote_addr
argument_list|)
operator|||
name|connect
argument_list|(
name|socket_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_addr
argument_list|,
name|readle
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|socket_fd
argument_list|)
expr_stmt|;
name|socket_fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* /inet/raw server not ready yet */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"/inet/raw server not ready yet, sorry"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"only root may use `/inet/raw'."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|close
argument_list|(
name|socket_fd
argument_list|)
expr_stmt|;
name|socket_fd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
return|return
name|socket_fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SOCKETS */
end_comment

begin_comment
comment|/* devopen --- handle /dev/std{in,out,err}, /dev/fd/N, regular files */
end_comment

begin_comment
comment|/*  * This separate version is still needed for output, since file and pipe  * output is done with stdio. iop_open() handles input with IOBUFs of  * more "special" files.  Those files are not handled here since it makes  * no sense to use them for output.  */
end_comment

begin_comment
comment|/*  * Strictly speaking, "name" is not a "const char *" because we temporarily  * change the string.  */
end_comment

begin_function
name|int
name|devopen
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|openfd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
name|fileno
argument_list|(
name|stdin
argument_list|)
return|;
name|openfd
operator|=
name|INVALID_HANDLE
expr_stmt|;
if|if
condition|(
name|do_traditional
condition|)
goto|goto
name|strictopen
goto|;
if|if
condition|(
operator|(
name|openfd
operator|=
name|os_devopen
argument_list|(
name|name
argument_list|,
name|flag
argument_list|)
operator|)
operator|!=
name|INVALID_HANDLE
condition|)
block|{
name|os_close_on_exec
argument_list|(
name|openfd
argument_list|,
name|name
argument_list|,
literal|"file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|openfd
return|;
block|}
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdin"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stdout"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|cp
argument_list|,
literal|"stderr"
argument_list|)
operator|&&
operator|(
name|flag
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"fd/"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|cp
operator|+=
literal|3
expr_stmt|;
name|openfd
operator|=
operator|(
name|int
operator|)
name|strtod
argument_list|(
name|cp
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|<=
name|INVALID_HANDLE
operator|||
name|ptr
operator|==
name|cp
condition|)
name|openfd
operator|=
name|INVALID_HANDLE
expr_stmt|;
block|}
comment|/* do not set close-on-exec for inherited fd's */
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
condition|)
return|return
name|openfd
return|;
block|}
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/inet/"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
comment|/* /inet/protocol/localport/hostname/remoteport */
name|enum
name|inet_prot
name|protocol
init|=
name|INET_NONE
decl_stmt|;
name|int
name|localport
decl_stmt|,
name|remoteport
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|char
modifier|*
name|hostnameslastcharp
decl_stmt|;
name|char
modifier|*
name|localpname
decl_stmt|;
name|char
name|proto
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|servent
modifier|*
name|service
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|name
operator|+
literal|6
expr_stmt|;
comment|/* which protocol? */
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"tcp/"
argument_list|,
literal|4
argument_list|)
condition|)
name|protocol
operator|=
name|INET_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"udp/"
argument_list|,
literal|4
argument_list|)
condition|)
name|protocol
operator|=
name|INET_UDP
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|cp
argument_list|,
literal|"raw/"
argument_list|,
literal|4
argument_list|)
condition|)
name|protocol
operator|=
name|INET_RAW
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"no (known) protocol supplied in special filename `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|proto
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|proto
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|proto
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|2
index|]
expr_stmt|;
name|proto
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
comment|/* which localport? */
name|localpname
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/*                     		 * Require a port, let them explicitly put 0 if 		 * they don't care.   		 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|||
name|cp
operator|==
name|localpname
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"special file name `%s' is incomplete"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* We change the special file name temporarily because we 		 * need a 0-terminated string here for conversion with atoi(). 		 * By using atoi() the use of decimal numbers is enforced. 		 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|localport
operator|=
name|atoi
argument_list|(
name|localpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|localpname
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|localport
operator|<=
literal|0
operator|||
name|localport
operator|>
literal|65535
operator|)
condition|)
block|{
name|service
operator|=
name|getservbyname
argument_list|(
name|localpname
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"local port invalid in `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|localport
operator|=
name|ntohs
argument_list|(
name|service
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
comment|/* which hostname? */
name|cp
operator|++
expr_stmt|;
name|hostname
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|||
name|cp
operator|==
name|hostname
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"must supply a remote hostname to `/inet'"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|hostnameslastcharp
operator|=
name|cp
expr_stmt|;
comment|/* which remoteport? */
name|cp
operator|++
expr_stmt|;
comment|/* 		 * The remote port ends the special file name. 		 * This means there already is a 0 at the end of the string.                  * Therefore no need to patch any string ending. 		 * 		 * Here too, require a port, let them explicitly put 0 if 		 * they don't care. 		 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"must supply a remote port to `/inet'"
argument_list|)
argument_list|)
expr_stmt|;
name|remoteport
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|remoteport
operator|<=
literal|0
operator|||
name|remoteport
operator|>
literal|65535
operator|)
condition|)
block|{
name|service
operator|=
name|getservbyname
argument_list|(
name|cp
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|service
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"remote port invalid in `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|remoteport
operator|=
name|ntohs
argument_list|(
name|service
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
comment|/* Open Sesame! */
name|openfd
operator|=
name|socketopen
argument_list|(
name|protocol
argument_list|,
name|localport
argument_list|,
name|remoteport
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
operator|*
name|hostnameslastcharp
operator|=
literal|'/'
expr_stmt|;
else|#
directive|else
comment|/* ! HAVE_SOCKETS */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"TCP/IP communications are not supported"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|os_isdir
argument_list|(
name|openfd
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"file `%s' is a directory"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|os_close_on_exec
argument_list|(
name|openfd
argument_list|,
name|name
argument_list|,
literal|"file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|openfd
return|;
block|}
end_function

begin_comment
comment|/* spec_setup --- setup an IOBUF for a special internal file */
end_comment

begin_function
specifier|static
name|void
name|spec_setup
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|allocate
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|allocate
condition|)
block|{
name|emalloc
argument_list|(
name|cp
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|2
argument_list|,
literal|"spec_setup"
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|iop
operator|->
name|buf
argument_list|)
expr_stmt|;
name|iop
operator|->
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* get_a_record clobbered it */
name|iop
operator|->
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|buf
operator|+
name|len
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|iop
operator|->
name|flag
operator|=
name|IOP_IS_INTERNAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* specfdopen --- open an fd special file */
end_comment

begin_function
specifier|static
name|int
name|specfdopen
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|IOBUF
modifier|*
name|tp
decl_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|INVALID_HANDLE
return|;
name|tp
operator|=
name|iop_alloc
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* don't leak fd's */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|INVALID_HANDLE
return|;
block|}
operator|*
name|iop
operator|=
operator|*
name|tp
expr_stmt|;
name|iop
operator|->
name|flag
operator||=
name|IOP_NO_FREE
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GETPGRP_VOID
end_ifdef

begin_define
define|#
directive|define
name|getpgrp_arg
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|getpgrp_arg
parameter_list|()
value|getpid()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pidopen --- "open" /dev/pid, /dev/ppid, and /dev/pgrpid */
end_comment

begin_function
specifier|static
name|int
name|pidopen
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
init|=
name|name
operator|+
literal|5
decl_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"use `PROCINFO[\"%s\"]' instead of `%s'"
argument_list|)
argument_list|,
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'g'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpgrp
argument_list|(
name|getpgrp_arg
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|6
index|]
operator|==
literal|'i'
condition|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getppid
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* useropen --- "open" /dev/user */
end_comment

begin_comment
comment|/*  * /dev/user creates a record as follows:  *	$1 = getuid()  *	$2 = geteuid()  *	$3 = getgid()  *	$4 = getegid()  * If multiple groups are supported, then $5 through $NF are the  * supplementary group set.  */
end_comment

begin_function
specifier|static
name|int
name|useropen
parameter_list|(
name|IOBUF
modifier|*
name|iop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|char
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
name|GETGROUPS_T
name|groupset
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
endif|#
directive|endif
name|warning
argument_list|(
name|_
argument_list|(
literal|"use `PROCINFO[...]' instead of `/dev/user'"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tbuf
operator|+
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NGROUPS_MAX
argument_list|)
operator|&&
name|NGROUPS_MAX
operator|>
literal|0
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|groupset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngroups
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"could not find groups: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|groupset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|spec_setup
argument_list|(
name|iop
argument_list|,
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* iop_open --- handle special and regular files for input */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|iop_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
name|IOBUF
modifier|*
name|iop
parameter_list|)
block|{
name|int
name|openfd
init|=
name|INVALID_HANDLE
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
specifier|static
struct|struct
name|internal
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|compare
decl_stmt|;
name|int
argument_list|(
argument|*fp
argument_list|)
name|P
argument_list|(
operator|(
name|IOBUF
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|IOBUF
name|iob
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
literal|"/dev/fd/"
block|,
literal|8
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdin"
block|,
literal|10
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stdout"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/stderr"
block|,
literal|11
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/inet/"
block|,
literal|6
block|,
name|specfdopen
block|}
block|,
block|{
literal|"/dev/pid"
block|,
literal|8
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/ppid"
block|,
literal|9
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/pgrpid"
block|,
literal|11
block|,
name|pidopen
block|}
block|,
block|{
literal|"/dev/user"
block|,
literal|9
block|,
name|useropen
block|}
block|, 	}
struct|;
name|int
name|devcount
init|=
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|flag
operator|=
name|str2mode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
name|openfd
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_traditional
condition|)
goto|goto
name|strictopen
goto|;
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|||
name|STREQN
argument_list|(
name|name
argument_list|,
literal|"/inet/"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|compare
argument_list|)
condition|)
block|{
name|iop
operator|=
operator|&
name|table
index|[
name|i
index|]
operator|.
name|iob
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|spec_setup
argument_list|(
name|iop
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|iop
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|table
index|[
name|i
index|]
operator|.
name|fp
operator|)
operator|(
name|iop
operator|,
name|name
operator|,
name|mode
operator|)
operator|==
literal|0
condition|)
return|return
name|iop
return|;
else|else
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"could not open `%s', mode `%s'"
argument_list|)
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/* not in table, fall through to regular code */
block|}
name|strictopen
label|:
if|if
condition|(
name|openfd
operator|==
name|INVALID_HANDLE
condition|)
name|openfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfd
operator|!=
name|INVALID_HANDLE
condition|)
block|{
if|if
condition|(
name|os_isdir
argument_list|(
name|openfd
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"file `%s' is a directory"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|os_close_on_exec
argument_list|(
name|openfd
argument_list|,
name|name
argument_list|,
literal|"file"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|iop_alloc
argument_list|(
name|openfd
argument_list|,
name|name
argument_list|,
name|iop
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* two_way_open --- open a two way communications channel */
end_comment

begin_function
specifier|static
name|int
name|two_way_open
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SOCKETS
comment|/* case 1: socket */
if|if
condition|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"/inet/"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|int
name|fd
decl_stmt|,
name|newfd
decl_stmt|;
name|fd
operator|=
name|devopen
argument_list|(
name|str
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|FALSE
return|;
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|newfd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|os_close_on_exec
argument_list|(
name|newfd
argument_list|,
name|str
argument_list|,
literal|"socket"
argument_list|,
literal|"to/from"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|newfd
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rp
operator|->
name|flag
operator||=
name|RED_SOCKET
expr_stmt|;
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_SOCKETS */
ifdef|#
directive|ifdef
name|HAVE_PORTALS
comment|/* case 1.5: portal */
if|if
condition|(
name|STREQN
argument_list|(
name|str
argument_list|,
literal|"/p/"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|int
name|fd
decl_stmt|,
name|newfd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|str
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|FALSE
return|;
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|newfd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|os_close_on_exec
argument_list|(
name|newfd
argument_list|,
name|str
argument_list|,
literal|"portal"
argument_list|,
literal|"to/from"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|newfd
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|rp
operator|->
name|fp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rp
operator|->
name|flag
operator||=
name|RED_SOCKET
expr_stmt|;
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_PORTALS */
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
comment|/* real pipes */
comment|/* case 2: two way pipe to a child process */
block|{
name|int
name|ptoc
index|[
literal|2
index|]
decl_stmt|,
name|ctop
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|ptoc
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* errno set, diagnostic from caller */
if|if
condition|(
name|pipe
argument_list|(
name|ctop
argument_list|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child */
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of stdout in child failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"moving pipe to stdout in child failed (dup: %s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of stdin in child failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"moving pipe to stdin in child failed (dup: %s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* stderr does NOT get dup'ed onto child's stdout */
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
name|rp
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|,
name|str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
comment|/* overkill? (pardon pun) */
return|return
name|FALSE
return|;
block|}
name|rp
operator|->
name|fp
operator|=
name|fdopen
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
comment|/* overkill? (pardon pun) */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|ctop
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"pipe from `%s': could not set close-on-exec (fcntl: %s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|ptoc
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"pipe to `%s': could not set close-on-exec (fcntl: %s)"
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|ptoc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ctop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|#
directive|else
comment|/*PIPES_SIMULATED*/
name|fatal
argument_list|(
name|_
argument_list|(
literal|"`|&' not supported"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PIPES_SIMULATED
end_ifndef

begin_comment
comment|/* real pipes */
end_comment

begin_comment
comment|/* wait_any --- wait for a child process, close associated pipe */
end_comment

begin_function
specifier|static
name|int
name|wait_any
parameter_list|(
name|int
name|interesting
parameter_list|)
comment|/* pid of interest, if any */
block|{
name|RETSIGTYPE
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|redirect
modifier|*
name|redp
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
comment|/* Posix compatible sys/wait.h */
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait
argument_list|(
operator|(
expr|union
name|wait
operator|*
operator|)
operator|&
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NeXT */
if|if
condition|(
name|interesting
operator|&&
name|pid
operator|==
name|interesting
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|redp
operator|=
name|red_head
init|;
name|redp
operator|!=
name|NULL
condition|;
name|redp
operator|=
name|redp
operator|->
name|next
control|)
if|if
condition|(
name|pid
operator|==
name|redp
operator|->
name|pid
condition|)
block|{
name|redp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|redp
operator|->
name|status
operator|=
name|status
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ECHILD
condition|)
break|break;
block|}
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
comment|/* 	 * used to wait for any children to synchronize input and output, 	 * but this could cause gawk to hang when it is started in a pipeline 	 * and thus has a child process feeding it input (shell dependant) 	 */
comment|/*(void) wait_any(0);*/
comment|/* wait for outstanding processes */
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot open pipe `%s' (%s)"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of stdout in child failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"moving pipe to stdout in child failed (dup: %s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"cannot create child process for `%s' (fork: %s)"
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"close of pipe failed (%s)"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|os_close_on_exec
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|cmd
argument_list|,
literal|"pipe"
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* process previously found, return stored status */
if|if
condition|(
name|rp
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|+
operator|(
operator|(
name|rp
operator|->
name|status
operator|&
literal|0xFF
operator|)
condition|?
literal|128
operator|+
operator|(
name|rp
operator|->
name|status
operator|&
literal|0xF
operator|)
else|:
literal|0
operator|)
return|;
name|rp
operator|->
name|status
operator|=
name|wait_any
argument_list|(
name|rp
operator|->
name|pid
argument_list|)
expr_stmt|;
name|rp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|status
operator|>>
literal|8
operator|)
operator|+
operator|(
operator|(
name|rp
operator|->
name|status
operator|&
literal|0xFF
operator|)
condition|?
literal|128
operator|+
operator|(
name|rp
operator|->
name|status
operator|&
literal|0xF
operator|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_comment
comment|/*  * use temporary file rather than pipe  * except if popen() provides real pipes too  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|OS2
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|TANDEM
argument_list|)
end_if

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
name|os_restore_mode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
name|binmode
argument_list|(
literal|"r"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BINMODE
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|os_setbinmode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|os_close_on_exec
argument_list|(
name|fileno
argument_list|(
name|current
argument_list|)
argument_list|,
name|cmd
argument_list|,
literal|"pipe"
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|fileno
argument_list|(
name|current
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
block|}
name|rp
operator|->
name|ifp
operator|=
name|current
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|rval
decl_stmt|,
name|aval
decl_stmt|,
name|fd
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|iop
operator|->
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* kludge to allow close() + pclose() */
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
name|aval
operator|=
name|pclose
argument_list|(
name|rp
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rval
operator|<
literal|0
condition|?
name|rval
else|:
name|aval
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not (VMS || OS2 || MSDOS || TANDEM) */
end_comment

begin_struct
specifier|static
struct|struct
name|pipeinfo
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|pipes
index|[
name|_NFILE
index|]
struct|;
end_struct

begin_comment
comment|/* gawk_popen --- open an IOBUF on a child process */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|gawk_popen
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|strdup
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|int
name|current
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|cmdbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* get a name to use */
if|if
condition|(
operator|(
name|name
operator|=
name|tempnam
argument_list|(
literal|"."
argument_list|,
literal|"pip"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|cmdbuf
argument_list|,
literal|"%s> %s"
argument_list|,
name|cmd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|NULL
return|;
name|pipes
index|[
name|current
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|pipes
index|[
name|current
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|os_close_on_exec
argument_list|(
name|current
argument_list|,
name|cmd
argument_list|,
literal|"pipe"
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|iop_alloc
argument_list|(
name|current
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|current
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|->
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/* gawk_pclose --- close an open child pipe */
end_comment

begin_function
specifier|static
name|int
name|gawk_pclose
parameter_list|(
name|struct
name|redirect
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|cur
init|=
name|rp
operator|->
name|iop
operator|->
name|fd
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|iop
operator|!=
name|NULL
condition|)
name|rval
operator|=
name|iop_close
argument_list|(
name|rp
operator|->
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
comment|/* check for an open file  */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not (VMS || OS2 || MSDOS || TANDEM) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIPES_SIMULATED */
end_comment

begin_comment
comment|/* do_getline --- read in a line, into var and with redirection, as needed */
end_comment

begin_function
name|NODE
modifier|*
name|do_getline
parameter_list|(
name|NODE
modifier|*
name|tree
parameter_list|)
block|{
name|struct
name|redirect
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|int
name|cnt
init|=
name|EOF
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|errcode
decl_stmt|;
while|while
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|rnode
operator|==
name|NULL
condition|)
block|{
comment|/* no redirection */
name|iop
operator|=
name|nextfile
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|redir_error
init|=
literal|0
decl_stmt|;
name|rp
operator|=
name|redirect
argument_list|(
name|tree
operator|->
name|rnode
argument_list|,
operator|&
name|redir_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
operator|&&
name|redir_error
condition|)
block|{
comment|/* failed redirect */
if|if
condition|(
operator|!
name|do_traditional
condition|)
name|update_ERRNO
argument_list|()
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
name|iop
operator|=
name|rp
operator|->
name|iop
expr_stmt|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
comment|/* end of input */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
name|errcode
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|s
argument_list|,
name|iop
argument_list|,
name|RS
operator|->
name|stptr
index|[
literal|0
index|]
argument_list|,
name|RS_regexp
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|do_traditional
condition|)
name|update_ERRNO
argument_list|()
expr_stmt|;
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
operator|-
literal|1.0
argument_list|)
return|;
block|}
if|if
condition|(
name|cnt
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Don't do iop_close() here if we are 				 * reading from a pipe; otherwise 				 * gawk_pclose will not be called. 				 */
if|if
condition|(
operator|(
name|rp
operator|->
name|flag
operator|&
operator|(
name|RED_PIPE
operator||
name|RED_TWOWAY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|iop_close
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|rp
operator|->
name|iop
operator|=
name|NULL
expr_stmt|;
block|}
name|rp
operator|->
name|flag
operator||=
name|RED_EOF
expr_stmt|;
comment|/* sticky EOF */
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|0.0
argument_list|)
return|;
block|}
else|else
continue|continue;
comment|/* try another file */
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|NR
operator|++
expr_stmt|;
name|FNR
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|lnode
operator|==
name|NULL
condition|)
comment|/* no optional var. */
name|set_record
argument_list|(
name|s
argument_list|,
name|cnt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* assignment to variable */
name|Func_ptr
name|after_assign
init|=
name|NULL
decl_stmt|;
name|NODE
modifier|*
modifier|*
name|lhs
decl_stmt|;
name|lhs
operator|=
name|get_lhs
argument_list|(
name|tree
operator|->
name|lnode
argument_list|,
operator|&
name|after_assign
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|unref
argument_list|(
operator|*
name|lhs
argument_list|)
expr_stmt|;
operator|*
name|lhs
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lhs
operator|)
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
comment|/* we may have to regenerate $0 here! */
if|if
condition|(
name|after_assign
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|after_assign
call|)
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|tmp_number
argument_list|(
operator|(
name|AWKNUM
operator|)
literal|1.0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* pathopen --- pathopen with default file extension handling */
end_comment

begin_function
name|int
name|pathopen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|int
name|fd
init|=
name|do_pathopen
argument_list|(
name|file
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_FILETYPE
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|char
modifier|*
name|file_awk
decl_stmt|;
name|int
name|save
init|=
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|int
name|vms_save
init|=
name|vaxc$errno
decl_stmt|;
endif|#
directive|endif
comment|/* append ".awk" and try again */
name|emalloc
argument_list|(
name|file_awk
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DEFAULT_FILETYPE
argument_list|)
operator|+
literal|1
argument_list|,
literal|"pathopen"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|file_awk
argument_list|,
literal|"%s%s"
argument_list|,
name|file
argument_list|,
name|DEFAULT_FILETYPE
argument_list|)
expr_stmt|;
name|fd
operator|=
name|do_pathopen
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_awk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
name|INVALID_HANDLE
condition|)
block|{
name|errno
operator|=
name|save
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|vaxc$errno
operator|=
name|vms_save
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/*DEFAULT_FILETYPE*/
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* do_pathopen --- search $AWKPATH for source file */
end_comment

begin_function
specifier|static
name|int
name|do_pathopen
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|savepath
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|first
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|awkpath
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|trypath
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|do_traditional
condition|)
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|awkpath
operator|=
name|getenv
argument_list|(
literal|"AWKPATH"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|awkpath
condition|)
name|savepath
operator|=
name|awkpath
expr_stmt|;
comment|/* used for restarting */
else|else
name|savepath
operator|=
name|defpath
expr_stmt|;
block|}
name|awkpath
operator|=
name|savepath
expr_stmt|;
comment|/* some kind of path name, no search */
if|if
condition|(
name|ispath
argument_list|(
name|file
argument_list|)
condition|)
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
do|do
block|{
name|trypath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* this should take into account limits on size of trypath */
for|for
control|(
name|cp
operator|=
name|trypath
init|;
operator|*
name|awkpath
operator|&&
operator|*
name|awkpath
operator|!=
name|envsep
condition|;
control|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|awkpath
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|trypath
condition|)
block|{
comment|/* nun-null element in path */
comment|/* add directory punctuation only if needed */
if|if
condition|(
operator|!
name|isdirpunct
argument_list|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* append filename */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|trypath
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|devopen
argument_list|(
name|trypath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|>
name|INVALID_HANDLE
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* no luck, keep going */
if|if
condition|(
operator|*
name|awkpath
operator|==
name|envsep
operator|&&
name|awkpath
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|awkpath
operator|++
expr_stmt|;
comment|/* skip colon */
block|}
do|while
condition|(
operator|*
name|awkpath
operator|!=
literal|'\0'
condition|)
do|;
comment|/* 	 * You might have one of the awk paths defined, WITHOUT the current 	 * working directory in it. Therefore try to open the file in the 	 * current directory. 	 */
return|return
operator|(
name|devopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_decl_stmt
name|int
name|bufsize
init|=
literal|8192
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fatal
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* iop_alloc --- allocate an IOBUF structure for an open fd */
end_comment

begin_function
specifier|static
name|IOBUF
modifier|*
name|iop_alloc
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|IOBUF
modifier|*
name|iop
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|INVALID_HANDLE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|iop
operator|==
name|NULL
condition|)
name|emalloc
argument_list|(
name|iop
argument_list|,
name|IOBUF
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|IOBUF
argument_list|)
argument_list|,
literal|"iop_alloc"
argument_list|)
expr_stmt|;
name|iop
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fd
argument_list|)
condition|)
name|iop
operator|->
name|flag
operator||=
name|IOP_IS_TTY
expr_stmt|;
name|iop
operator|->
name|size
operator|=
name|optimal_bufsize
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
name|S_ISREG
argument_list|(
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|sbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"data file `%s' is empty"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|iop
operator|->
name|secsiz
operator|=
operator|-
literal|2
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|iop
operator|->
name|name
operator|=
name|name
expr_stmt|;
return|return
name|iop
return|;
block|}
end_function

begin_define
define|#
directive|define
name|set_RT_to_null
parameter_list|()
define|\
value|(void)(! do_traditional&& (unref(RT_node->var_value), \ 			   RT_node->var_value = Nnull_string))
end_define

begin_define
define|#
directive|define
name|set_RT
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
define|\
value|(void)(! do_traditional&& (unref(RT_node->var_value), \ 			   RT_node->var_value = make_string(str, len)))
end_define

begin_comment
comment|/*  * get_a_record:  * Get the next record.  Uses a "split buffer" where the latter part is  * the normal read buffer and the head part is an "overflow" area that is used  * when a record spans the end of the normal buffer, in which case the first  * part of the record is copied into the overflow area just before the  * normal buffer.  Thus, the eventual full record can be returned as a  * contiguous area of memory with a minimum of copying.  The overflow area  * is expanded as needed, so that records are unlimited in length.  * We also mark both the end of the buffer and the end of the read() with  * a sentinel character (the current record separator) so that the inside  * loop can run as a single test.  *  * Note that since we know or can compute the end of the read and the end  * of the buffer, the sentinel character does not get in the way of regexp  * based searching, since we simply search up to that character, but not  * including it.  */
end_comment

begin_function
specifier|static
name|int
name|get_a_record
parameter_list|(
name|char
modifier|*
modifier|*
name|out
parameter_list|,
comment|/* pointer to pointer to data */
name|IOBUF
modifier|*
name|iop
parameter_list|,
comment|/* input IOP */
specifier|register
name|int
name|grRS
parameter_list|,
comment|/* first char in RS->stptr */
name|Regexp
modifier|*
name|RSre
parameter_list|,
comment|/* regexp for RS */
name|int
modifier|*
name|errcode
parameter_list|)
comment|/* pointer to error variable */
block|{
specifier|register
name|char
modifier|*
name|bp
init|=
name|iop
operator|->
name|off
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|iop
operator|->
name|off
decl_stmt|;
comment|/* beginning of record */
name|int
name|rs
decl_stmt|;
specifier|static
name|Regexp
modifier|*
name|RS_null_re
init|=
name|NULL
decl_stmt|;
name|Regexp
modifier|*
name|rsre
init|=
name|NULL
decl_stmt|;
name|int
name|continuing
init|=
name|FALSE
decl_stmt|,
name|continued
init|=
name|FALSE
decl_stmt|;
comment|/* used for re matching */
name|int
name|onecase
decl_stmt|;
ifdef|#
directive|ifdef
name|TANDEM
name|char
modifier|*
name|mend
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TANDEM
define|#
directive|define
name|not_past_end
parameter_list|()
value|(bp< mend)
else|#
directive|else
define|#
directive|define
name|not_past_end
parameter_list|()
value|(1)
endif|#
directive|endif
comment|/* first time through */
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
block|{
name|RS_null_re
operator|=
name|make_regexp
argument_list|(
literal|"\n\n+"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_null_re
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"internal error: file `%s', line %d\n"
argument_list|)
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
comment|/* previous read hit EOF */
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
ifdef|#
directive|ifdef
name|TANDEM
if|if
condition|(
name|MRL
condition|)
name|mend
operator|=
name|start
operator|+
name|MRL
expr_stmt|;
else|else
name|mend
operator|=
operator|(
name|char
operator|*
operator|)
name|LONG_MAX
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|RS_is_null
condition|)
comment|/* special case:  RS == "" */
name|rs
operator|=
literal|'\n'
expr_stmt|;
else|else
name|rs
operator|=
operator|(
name|char
operator|)
name|grRS
expr_stmt|;
name|onecase
operator|=
operator|(
name|IGNORECASE
operator|&&
name|ISALPHA
argument_list|(
name|rs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|onecase
condition|)
name|rs
operator|=
name|casetable
index|[
operator|(
name|unsigned
name|char
operator|)
name|rs
index|]
expr_stmt|;
comment|/* set up sentinel */
if|if
condition|(
name|iop
operator|->
name|buf
condition|)
block|{
name|bufend
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
operator|*
name|bufend
operator|=
name|rs
expr_stmt|;
comment|/* add sentinel to buffer */
block|}
else|else
name|bufend
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* break on end of record, read error or EOF */
comment|/* buffer mgmt, chunk #1 */
comment|/* 		 * Following code is entered on the first call of this routine 		 * for a new iop, or when we scan to the end of the buffer. 		 * In the latter case, we copy the current partial record to 		 * the space preceding the normal read buffer.  If necessary, 		 * we expand this space.  This is done so that we can return 		 * the record as a contiguous area of memory. 		 */
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|==
literal|0
operator|&&
name|bp
operator|>=
name|bufend
condition|)
block|{
name|char
modifier|*
name|oldbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldsplit
init|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
decl_stmt|;
name|long
name|len
decl_stmt|;
comment|/* record length so far */
name|len
operator|=
name|bp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|iop
operator|->
name|secsiz
condition|)
block|{
comment|/* expand secondary buffer */
if|if
condition|(
name|iop
operator|->
name|secsiz
operator|==
operator|-
literal|2
condition|)
name|iop
operator|->
name|secsiz
operator|=
literal|256
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|iop
operator|->
name|secsiz
condition|)
name|iop
operator|->
name|secsiz
operator|*=
literal|2
expr_stmt|;
name|oldbuf
operator|=
name|iop
operator|->
name|buf
expr_stmt|;
name|emalloc
argument_list|(
name|iop
operator|->
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
operator|+
literal|2
argument_list|,
literal|"get_a_record"
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|size
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
operator|*
name|bufend
operator|=
name|rs
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|newsplit
init|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
decl_stmt|;
if|if
condition|(
name|start
operator|<
name|oldsplit
condition|)
block|{
name|memcpy
argument_list|(
name|newsplit
operator|-
name|len
argument_list|,
name|start
argument_list|,
name|oldsplit
operator|-
name|start
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newsplit
operator|-
operator|(
name|bp
operator|-
name|oldsplit
operator|)
argument_list|,
name|oldsplit
argument_list|,
name|bp
operator|-
name|oldsplit
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|newsplit
operator|-
name|len
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|iop
operator|->
name|end
operator|=
name|iop
operator|->
name|off
operator|=
name|iop
operator|->
name|buf
operator|+
name|iop
operator|->
name|secsiz
expr_stmt|;
name|start
operator|=
name|bp
operator|-
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|TANDEM
if|if
condition|(
name|MRL
condition|)
name|mend
operator|=
name|start
operator|+
name|MRL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oldbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
name|oldbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* buffer mgmt, chunk #2 */
comment|/* 		 * Following code is entered whenever we have no more data to 		 * scan.  In most cases this will read into the beginning of 		 * the main buffer, but in some cases (terminal, pipe etc.) 		 * we may be doing smallish reads into more advanced positions. 		 */
if|if
condition|(
name|bp
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
name|iop
operator|->
name|cnt
operator|=
name|read
argument_list|(
name|iop
operator|->
name|fd
argument_list|,
name|iop
operator|->
name|end
argument_list|,
name|bufend
operator|-
name|iop
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|errcode
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errcode
operator|=
name|errno
expr_stmt|;
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
break|break;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"error reading input file `%s': %s"
argument_list|)
argument_list|,
name|iop
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
comment|/* 				 * hit EOF before matching RS, so end 				 * the record and set RT to "" 				 */
name|iop
operator|->
name|cnt
operator|=
name|EOF
expr_stmt|;
comment|/* see comments below about this test */
if|if
condition|(
operator|!
name|continuing
condition|)
block|{
name|set_RT_to_null
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|!=
name|EOF
condition|)
block|{
name|iop
operator|->
name|end
operator|+=
name|iop
operator|->
name|cnt
expr_stmt|;
operator|*
name|iop
operator|->
name|end
operator|=
name|rs
expr_stmt|;
comment|/* reset the sentinel */
block|}
block|}
comment|/* buffers are now setup and filled with data */
comment|/* search for RS, #1, regexp based, or RS = "" */
comment|/* 		 * Attempt to simplify the code a bit. The case where 		 * RS = "" can also be described by a regexp, RS = "\n\n+". 		 * The buffer managment and searching code can thus now 		 * use a common case (the one for regexps) both when RS is 		 * a regexp, and when RS = "". This particularly benefits 		 * us for keeping track of how many newlines were matched 		 * in order to set RT. 		 */
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|RSre
operator|!=
name|NULL
condition|)
comment|/* regexp */
name|rsre
operator|=
name|RSre
expr_stmt|;
elseif|else
if|if
condition|(
name|RS_is_null
condition|)
comment|/* RS = "" */
name|rsre
operator|=
name|RS_null_re
expr_stmt|;
else|else
name|rsre
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Look for regexp match of RS.  Non-match conditions are: 		 *	1. No match at all 		 *	2. Match of a null string 		 *	3. Match ends at exact end of buffer 		 * Number 3 is subtle; we have to add more to the buffer 		 * in case the match would have extended further into the 		 * file, since regexp match by definition always matches the 		 * longest possible match. 		 * 		 * It is even more subtle than you might think. Suppose 		 * the re matches at exactly the end of file. We don't know 		 * that until we try to add more to the buffer. Thus, we 		 * set a flag to indicate, that if eof really does happen, 		 * don't break early. 		 * 		 * Still more subtlety. Suppose RS is a multi-character regexp, 		 * but it doesn't have the metacharacters that would let it 		 * match an arbitrary number of characters.  So it's an exact 		 * string match.  We need to check for this, in the case where 		 * there is an exact match at the end, and NOT read more 		 * data.  Otherwise, this might bite us for an interactive 		 * networking program that uses CR-LF as the line terminator. 		 */
name|continuing
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rsre
operator|!=
name|NULL
condition|)
block|{
name|again
label|:
comment|/* cases 1 and 2 are simple, just keep going */
if|if
condition|(
name|research
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|iop
operator|->
name|end
operator|-
name|start
argument_list|,
name|TRUE
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|==
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
condition|)
block|{
comment|/* 				 * Leading newlines at the beginning of the file 				 * should be ignored. Whew! 				 */
if|if
condition|(
name|RS_is_null
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
comment|/* 					 * have to catch the case of a 					 * single newline at the front of 					 * the record, which the regex 					 * doesn't. gurr. 					 */
while|while
condition|(
operator|*
name|start
operator|==
literal|'\n'
operator|&&
name|start
operator|<
name|iop
operator|->
name|end
condition|)
name|start
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|bp
operator|=
name|iop
operator|->
name|end
expr_stmt|;
continue|continue;
block|}
comment|/* case 3, regex match at exact end */
if|if
condition|(
name|start
operator|+
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|>=
name|iop
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|iop
operator|->
name|cnt
operator|!=
name|EOF
condition|)
block|{
comment|/* 					 * Only do the test if not at EOF 					 */
name|int
name|isstring
decl_stmt|;
name|isstring
operator|=
name|reisstring
argument_list|(
name|RS
operator|->
name|stptr
argument_list|,
name|RS
operator|->
name|stlen
argument_list|,
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|isstring
operator|==
name|FALSE
condition|)
block|{
name|bp
operator|=
name|iop
operator|->
name|end
expr_stmt|;
name|continuing
operator|=
name|continued
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* got a match! */
comment|/* 			 * Leading newlines at the beginning of the file 			 * should be ignored. Whew! 			 */
if|if
condition|(
name|RS_is_null
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
comment|/* 				 * have to catch the case of a 				 * single newline at the front of 				 * the record, which the regex 				 * doesn't. gurr. 				 */
while|while
condition|(
operator|*
name|start
operator|==
literal|'\n'
operator|&&
name|start
operator|<
name|iop
operator|->
name|end
condition|)
name|start
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|bp
operator|=
name|start
operator|+
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|set_RT
argument_list|(
name|bp
argument_list|,
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
operator|-
name|RESTART
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|iop
operator|->
name|off
operator|=
name|start
operator|+
name|REEND
argument_list|(
name|rsre
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* search for RS, #2, RS =<single char> */
if|if
condition|(
name|onecase
condition|)
block|{
while|while
condition|(
name|casetable
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|bp
operator|++
index|]
operator|!=
name|rs
operator|&&
name|not_past_end
argument_list|()
condition|)
continue|continue;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|bp
operator|++
operator|!=
name|rs
operator|&&
name|not_past_end
argument_list|()
condition|)
continue|continue;
block|}
name|set_RT
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|<=
name|iop
operator|->
name|end
condition|)
break|break;
else|else
name|bp
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
condition|)
name|iop
operator|->
name|cnt
operator|=
name|bp
operator|-
name|start
expr_stmt|;
block|}
if|if
condition|(
name|iop
operator|->
name|cnt
operator|==
name|EOF
operator|&&
operator|(
operator|(
operator|(
name|iop
operator|->
name|flag
operator|&
name|IOP_IS_INTERNAL
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|start
operator|==
name|bp
operator|&&
operator|!
name|continued
operator|)
operator|)
condition|)
block|{
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
name|set_RT_to_null
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|do_traditional
operator|||
name|rsre
operator|==
name|NULL
condition|)
block|{
name|iop
operator|->
name|off
operator|=
name|bp
expr_stmt|;
name|bp
operator|--
expr_stmt|;
if|if
condition|(
name|onecase
condition|?
name|casetable
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|bp
index|]
operator|!=
name|rs
else|:
operator|*
name|bp
operator|!=
name|rs
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|MRL
operator|==
literal|0
condition|)
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RS_is_null
operator|&&
name|iop
operator|->
name|cnt
operator|==
name|EOF
condition|)
block|{
comment|/* 		 * special case, delete trailing newlines, 		 * should never be more than one. 		 */
while|while
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|--
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|out
operator|=
name|start
expr_stmt|;
return|return
name|bp
operator|-
name|start
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|IOBUF
modifier|*
name|iop
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
name|rs
index|[
literal|2
index|]
decl_stmt|;
name|rs
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|bufsize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|rs
index|[
literal|0
index|]
operator|=
operator|*
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|iop
operator|=
name|iop_alloc
argument_list|(
literal|0
argument_list|,
literal|"stdin"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cnt
operator|=
name|get_a_record
argument_list|(
operator|&
name|out
argument_list|,
name|iop
argument_list|,
name|rs
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|cnt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|rs
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* set_RS --- update things as appropriate when RS is set */
end_comment

begin_function
name|void
name|set_RS
parameter_list|()
block|{
specifier|static
name|NODE
modifier|*
name|save_rs
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|save_rs
operator|&&
name|cmp_nodes
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|,
name|save_rs
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|unref
argument_list|(
name|save_rs
argument_list|)
expr_stmt|;
name|save_rs
operator|=
name|dupnode
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|RS_is_null
operator|=
name|FALSE
expr_stmt|;
name|RS
operator|=
name|force_string
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|RS_regexp
operator|!=
name|NULL
condition|)
block|{
name|refree
argument_list|(
name|RS_regexp
argument_list|)
expr_stmt|;
name|RS_regexp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|RS
operator|->
name|stlen
operator|==
literal|0
condition|)
name|RS_is_null
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|RS
operator|->
name|stlen
operator|>
literal|1
condition|)
block|{
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
name|RS_regexp
operator|=
name|make_regexp
argument_list|(
name|RS
operator|->
name|stptr
argument_list|,
name|RS
operator|->
name|stlen
argument_list|,
name|IGNORECASE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|lintwarn
argument_list|(
name|_
argument_list|(
literal|"multicharacter value of `RS' is a gawk extension"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|set_FS_if_not_FIELDWIDTHS
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

