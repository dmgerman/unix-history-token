begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * field.c - routines for dealing with fields and record parsing  */
end_comment

begin_comment
comment|/*   * Copyright (C) 1986, 1988, 1989, 1991-2000 the Free Software Foundation, Inc.  *   * This file is part of GAWK, the GNU implementation of the  * AWK Programming Language.  *   * GAWK is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * GAWK is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|* Setfunc
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|,
name|long
operator|,
name|NODE
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_expr_stmt
specifier|static
name|long
argument_list|(
argument|*parse_field
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|rebuild_record
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|re_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|def_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|posix_def_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|null_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sc_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|fw_parse_field
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_element
name|P
argument_list|(
operator|(
name|long
name|num
operator|,
name|char
operator|*
name|str
operator|,
name|long
name|len
operator|,
name|NODE
operator|*
name|arr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_fields_arr
name|P
argument_list|(
operator|(
name|long
name|num
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_field
name|P
argument_list|(
operator|(
name|long
name|num
operator|,
name|char
operator|*
name|str
operator|,
name|long
name|len
operator|,
name|NODE
operator|*
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_extent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* marks where to restart parse of record */
end_comment

begin_decl_stmt
specifier|static
name|long
name|parse_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* field number that we have parsed so far */
end_comment

begin_decl_stmt
specifier|static
name|long
name|nf_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of fields_arr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|resave_fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|save_FS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save current value of FS when line is read, 				 * to be used in deferred parsing 				 */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|FIELDWIDTHS
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
modifier|*
name|fields_arr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of pointers to the field nodes */
end_comment

begin_decl_stmt
name|int
name|field0_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* $(>0) has not been changed yet */
end_comment

begin_decl_stmt
name|int
name|default_FS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE when FS == " " */
end_comment

begin_decl_stmt
name|Regexp
modifier|*
name|FS_regexp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|Null_field
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* using_FIELDWIDTHS --- static function, macro to avoid overhead */
end_comment

begin_define
define|#
directive|define
name|using_FIELDWIDTHS
parameter_list|()
value|(parse_field == fw_parse_field)
end_define

begin_comment
comment|/* init_fields --- set up the fields array to start with */
end_comment

begin_function
name|void
name|init_fields
parameter_list|()
block|{
name|NODE
modifier|*
name|n
decl_stmt|;
name|emalloc
argument_list|(
name|fields_arr
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"init_fields"
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|Nnull_string
expr_stmt|;
name|n
operator|->
name|flags
operator||=
operator|(
name|SCALAR
operator||
name|FIELD
operator|)
expr_stmt|;
name|n
operator|->
name|flags
operator|&=
operator|~
name|PERM
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|parse_extent
operator|=
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
expr_stmt|;
name|save_FS
operator|=
name|dupnode
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|Null_field
argument_list|)
expr_stmt|;
operator|*
name|Null_field
operator|=
operator|*
name|Nnull_string
expr_stmt|;
name|Null_field
operator|->
name|flags
operator||=
operator|(
name|SCALAR
operator||
name|FIELD
operator|)
expr_stmt|;
name|Null_field
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NUM
operator||
name|NUMBER
operator||
name|MAYBE_NUM
operator||
name|PERM
operator|)
expr_stmt|;
name|field0_valid
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* grow_fields --- acquire new fields as needed */
end_comment

begin_function
specifier|static
name|void
name|grow_fields_arr
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
name|erealloc
argument_list|(
name|fields_arr
argument_list|,
name|NODE
operator|*
operator|*
argument_list|,
operator|(
name|num
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|,
literal|"grow_fields_arr"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|nf_high_water
operator|+
literal|1
init|;
name|t
operator|<=
name|num
condition|;
name|t
operator|++
control|)
block|{
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|Null_field
expr_stmt|;
name|fields_arr
index|[
name|t
index|]
operator|=
name|n
expr_stmt|;
block|}
name|nf_high_water
operator|=
name|num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_field --- set the value of a particular field */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|set_field
parameter_list|(
name|num
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|dummy
parameter_list|)
name|long
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|len
decl_stmt|;
name|NODE
modifier|*
name|dummy
decl_stmt|;
comment|/* not used -- just to make interface same as set_element */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|nf_high_water
condition|)
name|grow_fields_arr
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|n
operator|=
name|fields_arr
index|[
name|num
index|]
expr_stmt|;
name|n
operator|->
name|stptr
operator|=
name|str
expr_stmt|;
name|n
operator|->
name|stlen
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|flags
operator|=
operator|(
name|STR
operator||
name|STRING
operator||
name|MAYBE_NUM
operator||
name|SCALAR
operator||
name|FIELD
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* rebuild_record --- Someone assigned a value to $(something). 			Fix up $0 to be right */
end_comment

begin_function
specifier|static
name|void
name|rebuild_record
parameter_list|()
block|{
comment|/* 	 * use explicit unsigned longs for lengths, in case 	 * a size_t isn't big enough. 	 */
specifier|register
name|unsigned
name|long
name|tlen
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ofslen
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
name|NODE
modifier|*
name|ofs
decl_stmt|;
name|char
modifier|*
name|ops
decl_stmt|;
specifier|register
name|char
modifier|*
name|cops
decl_stmt|;
name|long
name|i
decl_stmt|;
name|assert
argument_list|(
name|NF
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
name|ofs
operator|=
name|force_string
argument_list|(
name|OFS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|ofslen
operator|=
name|ofs
operator|->
name|stlen
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NF
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|fields_arr
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|force_string
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tlen
operator|+=
name|tmp
operator|->
name|stlen
expr_stmt|;
block|}
name|tlen
operator|+=
operator|(
name|NF
operator|-
literal|1
operator|)
operator|*
name|ofslen
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|tlen
operator|<
literal|0
condition|)
name|tlen
operator|=
literal|0
expr_stmt|;
name|emalloc
argument_list|(
name|ops
argument_list|,
name|char
operator|*
argument_list|,
name|tlen
operator|+
literal|2
argument_list|,
literal|"rebuild_record"
argument_list|)
expr_stmt|;
name|cops
operator|=
name|ops
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NF
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|fields_arr
index|[
name|i
index|]
expr_stmt|;
comment|/* copy field */
if|if
condition|(
name|tmp
operator|->
name|stlen
operator|==
literal|1
condition|)
operator|*
name|cops
operator|++
operator|=
name|tmp
operator|->
name|stptr
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|->
name|stlen
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|cops
argument_list|,
name|tmp
operator|->
name|stptr
argument_list|,
name|tmp
operator|->
name|stlen
argument_list|)
expr_stmt|;
name|cops
operator|+=
name|tmp
operator|->
name|stlen
expr_stmt|;
block|}
comment|/* copy OFS */
if|if
condition|(
name|i
operator|!=
name|NF
condition|)
block|{
if|if
condition|(
name|ofslen
operator|==
literal|1
condition|)
operator|*
name|cops
operator|++
operator|=
name|ofs
operator|->
name|stptr
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ofslen
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|cops
argument_list|,
name|ofs
operator|->
name|stptr
argument_list|,
name|ofslen
argument_list|)
expr_stmt|;
name|cops
operator|+=
name|ofslen
expr_stmt|;
block|}
block|}
block|}
name|tmp
operator|=
name|make_str_node
argument_list|(
name|ops
argument_list|,
name|tlen
argument_list|,
name|ALREADY_MALLOCED
argument_list|)
expr_stmt|;
comment|/* 	 * Since we are about to unref fields_arr[0], we want to find 	 * any fields that still point into it, and have them point 	 * into the new field zero. 	 */
for|for
control|(
name|cops
operator|=
name|ops
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NF
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields_arr
index|[
name|i
index|]
operator|->
name|stlen
operator|>
literal|0
condition|)
block|{
name|NODE
modifier|*
name|n
decl_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fields_arr
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|FIELD
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|n
operator|=
operator|*
name|Null_field
expr_stmt|;
name|n
operator|->
name|stlen
operator|=
name|fields_arr
index|[
name|i
index|]
operator|->
name|stlen
expr_stmt|;
if|if
condition|(
operator|(
name|fields_arr
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|->
name|flags
operator||=
operator|(
name|fields_arr
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|NUM
operator||
name|NUMBER
operator|)
operator|)
expr_stmt|;
name|n
operator|->
name|numbr
operator|=
name|fields_arr
index|[
name|i
index|]
operator|->
name|numbr
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|n
operator|=
operator|*
operator|(
name|fields_arr
index|[
name|i
index|]
operator|)
expr_stmt|;
name|n
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MALLOC
operator||
name|TEMP
operator||
name|PERM
operator||
name|STRING
operator|)
expr_stmt|;
block|}
name|n
operator|->
name|stptr
operator|=
name|cops
expr_stmt|;
name|unref
argument_list|(
name|fields_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fields_arr
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
name|cops
operator|+=
name|fields_arr
index|[
name|i
index|]
operator|->
name|stlen
operator|+
name|ofslen
expr_stmt|;
block|}
name|unref
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|field0_valid
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set_record:  * setup $0, but defer parsing rest of line until reference is made to $(>0)  * or to NF.  At that point, parse only as much as necessary.  *  * Manage a private buffer for the contents of $0.  Doing so keeps us safe  * if `getline var' decides to rearrange the contents of the IOBUF that  * $0 might have been pointing into.  The cost is the copying of the buffer;  * but better correct than fast.  */
end_comment

begin_function
name|void
name|set_record
parameter_list|(
name|buf
parameter_list|,
name|cnt
parameter_list|,
name|freeold
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* ignored if ! freeold */
name|int
name|cnt
decl_stmt|;
comment|/* ignored if ! freeold */
name|int
name|freeold
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|static
name|char
modifier|*
name|databuf
decl_stmt|;
specifier|static
name|unsigned
name|long
name|databuf_size
decl_stmt|;
define|#
directive|define
name|INITIAL_SIZE
value|512
define|#
directive|define
name|MAX_SIZE
value|((unsigned long) ~0)
comment|/* maximally portable ... */
name|NF
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|parse_high_water
condition|;
name|i
operator|++
control|)
block|{
name|unref
argument_list|(
name|fields_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|Null_field
expr_stmt|;
name|fields_arr
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
name|parse_high_water
operator|=
literal|0
expr_stmt|;
comment|/* 	 * $0 = $0 should resplit using the current value of FS, thus, 	 * this is executed orthogonally to the value of freeold. 	 */
if|if
condition|(
name|resave_fs
condition|)
block|{
name|resave_fs
operator|=
name|FALSE
expr_stmt|;
name|unref
argument_list|(
name|save_FS
argument_list|)
expr_stmt|;
name|save_FS
operator|=
name|dupnode
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freeold
condition|)
block|{
comment|/* buffer management: */
if|if
condition|(
name|databuf_size
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|emalloc
argument_list|(
name|databuf
argument_list|,
name|char
operator|*
argument_list|,
name|INITIAL_SIZE
argument_list|,
literal|"set_record"
argument_list|)
expr_stmt|;
name|databuf_size
operator|=
name|INITIAL_SIZE
expr_stmt|;
block|}
comment|/* make sure there's enough room */
if|if
condition|(
name|cnt
operator|>
name|databuf_size
condition|)
block|{
while|while
condition|(
name|cnt
operator|>
name|databuf_size
operator|&&
name|databuf_size
operator|<=
name|MAX_SIZE
condition|)
name|databuf_size
operator|*=
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|databuf
argument_list|,
name|char
operator|*
argument_list|,
name|databuf_size
argument_list|,
literal|"set_record"
argument_list|)
expr_stmt|;
block|}
comment|/* copy the data */
name|memcpy
argument_list|(
name|databuf
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* manage field 0: */
name|unref
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|stptr
operator|=
name|databuf
expr_stmt|;
name|n
operator|->
name|stlen
operator|=
name|cnt
expr_stmt|;
name|n
operator|->
name|stref
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|Node_val
expr_stmt|;
name|n
operator|->
name|stfmt
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|->
name|flags
operator|=
operator|(
name|STRING
operator||
name|STR
operator||
name|MAYBE_NUM
operator||
name|SCALAR
operator||
name|FIELD
operator|)
expr_stmt|;
name|fields_arr
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
block|}
name|fields_arr
index|[
literal|0
index|]
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
name|field0_valid
operator|=
name|TRUE
expr_stmt|;
undef|#
directive|undef
name|INITIAL_SIZE
undef|#
directive|undef
name|MAX_SIZE
block|}
end_function

begin_comment
comment|/* reset_record --- start over again with current $0 */
end_comment

begin_function
name|void
name|reset_record
parameter_list|()
block|{
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|fields_arr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_record
argument_list|(
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_NF --- handle what happens to $0 and fields when NF is changed */
end_comment

begin_function
name|void
name|set_NF
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|n
decl_stmt|;
name|assert
argument_list|(
name|NF
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NF
operator|=
operator|(
name|long
operator|)
name|force_number
argument_list|(
name|NF_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|NF
operator|>
name|nf_high_water
condition|)
name|grow_fields_arr
argument_list|(
name|NF
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_high_water
operator|<
name|NF
condition|)
block|{
for|for
control|(
name|i
operator|=
name|parse_high_water
operator|+
literal|1
init|;
name|i
operator|<=
name|NF
condition|;
name|i
operator|++
control|)
block|{
name|unref
argument_list|(
name|fields_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|Null_field
expr_stmt|;
name|fields_arr
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|parse_high_water
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|NF
operator|+
literal|1
init|;
name|i
operator|<=
name|parse_high_water
condition|;
name|i
operator|++
control|)
block|{
name|unref
argument_list|(
name|fields_arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|getnode
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
operator|*
name|Null_field
expr_stmt|;
name|fields_arr
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
name|parse_high_water
operator|=
name|NF
expr_stmt|;
block|}
name|field0_valid
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * re_parse_field --- parse fields using a regexp.  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for when FS is a regular  * expression -- either user-defined or because RS=="" and FS==" "  */
end_comment

begin_function
specifier|static
name|long
name|re_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
if|if
condition|(
name|RS_is_null
operator|&&
name|default_FS
condition|)
while|while
condition|(
name|scan
operator|<
name|end
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
operator|||
operator|*
name|scan
operator|==
literal|'\n'
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
name|field
operator|=
name|scan
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|end
operator|&&
name|research
argument_list|(
name|rp
argument_list|,
name|scan
argument_list|,
literal|0
argument_list|,
operator|(
name|end
operator|-
name|scan
operator|)
argument_list|,
name|TRUE
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|nf
operator|<
name|up_to
condition|)
block|{
if|if
condition|(
name|REEND
argument_list|(
name|rp
argument_list|,
name|scan
argument_list|)
operator|==
name|RESTART
argument_list|(
name|rp
argument_list|,
name|scan
argument_list|)
condition|)
block|{
comment|/* null match */
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
block|{
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
call|(
name|long
call|)
argument_list|(
name|scan
operator|-
name|field
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|up_to
operator|=
name|nf
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
call|(
name|long
call|)
argument_list|(
name|scan
operator|+
name|RESTART
argument_list|(
name|rp
argument_list|,
name|scan
argument_list|)
operator|-
name|field
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|REEND
argument_list|(
name|rp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|field
operator|=
name|scan
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
comment|/* FS at end of record */
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
literal|0L
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nf
operator|!=
name|up_to
operator|&&
name|scan
operator|<
name|end
condition|)
block|{
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|scan
argument_list|,
call|(
name|long
call|)
argument_list|(
name|end
operator|-
name|scan
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|scan
operator|=
name|end
expr_stmt|;
block|}
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
operator|(
name|nf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * def_parse_field --- default field parsing.  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for when FS is a single space  * character.  */
end_comment

begin_function
specifier|static
name|long
name|def_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
name|char
name|sav
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
comment|/* 	 * Nasty special case. If FS set to "", return whole record 	 * as first field. This is not worth a separate function. 	 */
if|if
condition|(
name|fs
operator|->
name|stlen
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
operator|*
name|buf
argument_list|,
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|+=
name|len
expr_stmt|;
return|return
name|nf
return|;
block|}
comment|/* before doing anything save the char at *end */
name|sav
operator|=
operator|*
name|end
expr_stmt|;
comment|/* because it will be destroyed now: */
operator|*
name|end
operator|=
literal|' '
expr_stmt|;
comment|/* sentinel character */
for|for
control|(
init|;
name|nf
operator|<
name|up_to
condition|;
name|scan
operator|++
control|)
block|{
comment|/* 		 * special case:  fs is single space, strip leading whitespace  		 */
while|while
condition|(
name|scan
operator|<
name|end
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
operator|||
operator|*
name|scan
operator|==
literal|'\n'
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|>=
name|end
condition|)
break|break;
name|field
operator|=
name|scan
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
name|scan
operator|++
expr_stmt|;
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
call|(
name|long
call|)
argument_list|(
name|scan
operator|-
name|field
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
break|break;
block|}
comment|/* everything done, restore original char at *end */
operator|*
name|end
operator|=
name|sav
expr_stmt|;
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*  * posix_def_parse_field --- default field parsing.  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for when FS is a single space  * character.  The only difference between this and def_parse_field()  * is that this one does not allow newlines to separate fields.  */
end_comment

begin_function
specifier|static
name|long
name|posix_def_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
name|char
name|sav
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
comment|/* 	 * Nasty special case. If FS set to "", return whole record 	 * as first field. This is not worth a separate function. 	 */
if|if
condition|(
name|fs
operator|->
name|stlen
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
operator|*
name|buf
argument_list|,
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|+=
name|len
expr_stmt|;
return|return
name|nf
return|;
block|}
comment|/* before doing anything save the char at *end */
name|sav
operator|=
operator|*
name|end
expr_stmt|;
comment|/* because it will be destroyed now: */
operator|*
name|end
operator|=
literal|' '
expr_stmt|;
comment|/* sentinel character */
for|for
control|(
init|;
name|nf
operator|<
name|up_to
condition|;
name|scan
operator|++
control|)
block|{
comment|/* 		 * special case:  fs is single space, strip leading whitespace  		 */
while|while
condition|(
name|scan
operator|<
name|end
operator|&&
operator|(
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|>=
name|end
condition|)
break|break;
name|field
operator|=
name|scan
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
condition|)
name|scan
operator|++
expr_stmt|;
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
call|(
name|long
call|)
argument_list|(
name|scan
operator|-
name|field
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
break|break;
block|}
comment|/* everything done, restore original char at *end */
operator|*
name|end
operator|=
name|sav
expr_stmt|;
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*  * null_parse_field --- each character is a separate field  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for when FS is the null string.  */
end_comment

begin_function
specifier|static
name|long
name|null_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
for|for
control|(
init|;
name|nf
operator|<
name|up_to
operator|&&
name|scan
operator|<
name|end
condition|;
name|scan
operator|++
control|)
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|scan
argument_list|,
literal|1L
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*  * sc_parse_field --- single character field separator  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for when FS is a single character  * other than space.  */
end_comment

begin_function
specifier|static
name|long
name|sc_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|char
name|fschar
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
name|int
name|onecase
decl_stmt|;
name|char
name|sav
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
if|if
condition|(
name|RS_is_null
operator|&&
name|fs
operator|->
name|stlen
operator|==
literal|0
condition|)
name|fschar
operator|=
literal|'\n'
expr_stmt|;
else|else
name|fschar
operator|=
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
expr_stmt|;
name|onecase
operator|=
operator|(
name|IGNORECASE
operator|&&
name|isalpha
argument_list|(
name|fschar
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|onecase
condition|)
name|fschar
operator|=
name|casetable
index|[
operator|(
name|int
operator|)
name|fschar
index|]
expr_stmt|;
comment|/* before doing anything save the char at *end */
name|sav
operator|=
operator|*
name|end
expr_stmt|;
comment|/* because it will be destroyed now: */
operator|*
name|end
operator|=
name|fschar
expr_stmt|;
comment|/* sentinel character */
for|for
control|(
init|;
name|nf
operator|<
name|up_to
condition|;
control|)
block|{
name|field
operator|=
name|scan
expr_stmt|;
if|if
condition|(
name|onecase
condition|)
block|{
while|while
condition|(
name|casetable
index|[
operator|(
name|int
operator|)
operator|*
name|scan
index|]
operator|!=
name|fschar
condition|)
name|scan
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|scan
operator|!=
name|fschar
condition|)
name|scan
operator|++
expr_stmt|;
block|}
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
call|(
name|long
call|)
argument_list|(
name|scan
operator|-
name|field
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
break|break;
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|end
condition|)
block|{
comment|/* FS at end of record */
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|field
argument_list|,
literal|0L
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* everything done, restore original char at *end */
operator|*
name|end
operator|=
name|sav
expr_stmt|;
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/*  * fw_parse_field --- field parsing using FIELDWIDTHS spec  *  * This is called both from get_field() and from do_split()  * via (*parse_field)().  This variation is for fields are fixed widths.  */
end_comment

begin_function
specifier|static
name|long
name|fw_parse_field
parameter_list|(
name|up_to
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|fs
parameter_list|,
name|rp
parameter_list|,
name|set
parameter_list|,
name|n
parameter_list|)
name|long
name|up_to
decl_stmt|;
comment|/* parse only up to this field number */
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
comment|/* on input: string to parse; on output: point to start next */
name|int
name|len
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|Regexp
modifier|*
name|rp
decl_stmt|;
name|Setfunc
name|set
decl_stmt|;
comment|/* routine to set the value of the parsed field */
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
init|=
operator|*
name|buf
decl_stmt|;
specifier|register
name|long
name|nf
init|=
name|parse_high_water
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
init|=
name|scan
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|up_to
operator|==
name|HUGE
condition|)
name|nf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|nf
return|;
for|for
control|(
init|;
name|nf
operator|<
name|up_to
operator|&&
operator|(
name|len
operator|=
name|FIELDWIDTHS
index|[
name|nf
operator|+
literal|1
index|]
operator|)
operator|!=
operator|-
literal|1
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|>
name|end
operator|-
name|scan
condition|)
name|len
operator|=
name|end
operator|-
name|scan
expr_stmt|;
call|(
modifier|*
name|set
call|)
argument_list|(
operator|++
name|nf
argument_list|,
name|scan
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
operator|*
name|buf
operator|=
name|end
expr_stmt|;
else|else
operator|*
name|buf
operator|=
name|scan
expr_stmt|;
return|return
name|nf
return|;
block|}
end_function

begin_comment
comment|/* get_field --- return a particular $n */
end_comment

begin_function
name|NODE
modifier|*
modifier|*
name|get_field
parameter_list|(
name|requested
parameter_list|,
name|assign
parameter_list|)
specifier|register
name|long
name|requested
decl_stmt|;
name|Func_ptr
modifier|*
name|assign
decl_stmt|;
comment|/* this field is on the LHS of an assign */
block|{
comment|/* 	 * if requesting whole line but some other field has been altered, 	 * then the whole line must be rebuilt 	 */
if|if
condition|(
name|requested
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|field0_valid
condition|)
block|{
comment|/* first, parse remainder of input record */
if|if
condition|(
name|NF
operator|==
operator|-
literal|1
condition|)
block|{
name|NF
operator|=
call|(
modifier|*
name|parse_field
call|)
argument_list|(
name|HUGE
operator|-
literal|1
argument_list|,
operator|&
name|parse_extent
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
operator|-
operator|(
name|parse_extent
operator|-
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|)
argument_list|,
name|save_FS
argument_list|,
name|FS_regexp
argument_list|,
name|set_field
argument_list|,
operator|(
name|NODE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|parse_high_water
operator|=
name|NF
expr_stmt|;
block|}
name|rebuild_record
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
operator|*
name|assign
operator|=
name|reset_record
expr_stmt|;
return|return
operator|&
name|fields_arr
index|[
literal|0
index|]
return|;
block|}
comment|/* assert(requested> 0); */
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
name|field0_valid
operator|=
name|FALSE
expr_stmt|;
comment|/* $0 needs reconstruction */
if|if
condition|(
name|requested
operator|<=
name|parse_high_water
condition|)
comment|/* already parsed this field */
return|return
operator|&
name|fields_arr
index|[
name|requested
index|]
return|;
if|if
condition|(
name|NF
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* have not yet parsed to end of record */
comment|/* 		 * parse up to requested fields, calling set_field() for each, 		 * saving in parse_extent the point where the parse left off 		 */
if|if
condition|(
name|parse_high_water
operator|==
literal|0
condition|)
comment|/* starting at the beginning */
name|parse_extent
operator|=
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
expr_stmt|;
name|parse_high_water
operator|=
call|(
modifier|*
name|parse_field
call|)
argument_list|(
name|requested
argument_list|,
operator|&
name|parse_extent
argument_list|,
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
operator|-
operator|(
name|parse_extent
operator|-
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|)
argument_list|,
name|save_FS
argument_list|,
name|FS_regexp
argument_list|,
name|set_field
argument_list|,
operator|(
name|NODE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * if we reached the end of the record, set NF to the number of 		 * fields so far.  Note that requested might actually refer to 		 * a field that is beyond the end of the record, but we won't 		 * set NF to that value at this point, since this is only a 		 * reference to the field and NF only gets set if the field 		 * is assigned to -- this case is handled below 		 */
if|if
condition|(
name|parse_extent
operator|==
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stptr
operator|+
name|fields_arr
index|[
literal|0
index|]
operator|->
name|stlen
condition|)
name|NF
operator|=
name|parse_high_water
expr_stmt|;
if|if
condition|(
name|requested
operator|==
name|HUGE
operator|-
literal|1
condition|)
comment|/* HUGE-1 means set NF */
name|requested
operator|=
name|parse_high_water
expr_stmt|;
block|}
if|if
condition|(
name|parse_high_water
operator|<
name|requested
condition|)
block|{
comment|/* requested beyond end of record */
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
block|{
comment|/* expand record */
if|if
condition|(
name|requested
operator|>
name|nf_high_water
condition|)
name|grow_fields_arr
argument_list|(
name|requested
argument_list|)
expr_stmt|;
name|NF
operator|=
name|requested
expr_stmt|;
name|parse_high_water
operator|=
name|requested
expr_stmt|;
block|}
else|else
return|return
operator|&
name|Null_field
return|;
block|}
return|return
operator|&
name|fields_arr
index|[
name|requested
index|]
return|;
block|}
end_function

begin_comment
comment|/* set_element --- set an array element, used by do_split() */
end_comment

begin_function
specifier|static
name|void
name|set_element
parameter_list|(
name|num
parameter_list|,
name|s
parameter_list|,
name|len
parameter_list|,
name|n
parameter_list|)
name|long
name|num
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|len
decl_stmt|;
name|NODE
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|it
decl_stmt|;
name|it
operator|=
name|make_string
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|it
operator|->
name|flags
operator||=
name|MAYBE_NUM
expr_stmt|;
operator|*
name|assoc_lookup
argument_list|(
name|n
argument_list|,
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
name|num
argument_list|)
argument_list|)
argument_list|)
operator|=
name|it
expr_stmt|;
block|}
end_function

begin_comment
comment|/* do_split --- implement split(), semantics are same as for field splitting */
end_comment

begin_function
name|NODE
modifier|*
name|do_split
parameter_list|(
name|tree
parameter_list|)
name|NODE
modifier|*
name|tree
decl_stmt|;
block|{
name|NODE
modifier|*
name|src
decl_stmt|,
modifier|*
name|arr
decl_stmt|,
modifier|*
name|sep
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
argument_list|(
argument|*parseit
argument_list|)
name|P
argument_list|(
operator|(
name|long
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|NODE
operator|*
operator|,
name|Regexp
operator|*
operator|,
name|Setfunc
operator|,
name|NODE
operator|*
operator|)
argument_list|)
expr_stmt|;
name|Regexp
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
comment|/* 	 * do dupnode(), to avoid problems like 	 *	x = split(a[1], a, "blah") 	 * since we assoc_clear the array. gack. 	 * this also gives us complete call by value semantics. 	 */
name|tmp
operator|=
name|tree_eval
argument_list|(
name|tree
operator|->
name|lnode
argument_list|)
expr_stmt|;
name|src
operator|=
name|dupnode
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|arr
operator|=
name|tree
operator|->
name|rnode
operator|->
name|lnode
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|!=
name|NULL
condition|)
name|sep
operator|=
name|tree
operator|->
name|rnode
operator|->
name|rnode
operator|->
name|lnode
expr_stmt|;
comment|/* 3rd arg */
else|else
name|sep
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|force_string
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|arr
operator|->
name|type
operator|==
name|Node_param_list
condition|)
name|arr
operator|=
name|stack_ptr
index|[
name|arr
operator|->
name|param_cnt
index|]
expr_stmt|;
if|if
condition|(
name|arr
operator|->
name|type
operator|==
name|Node_array_ref
condition|)
name|arr
operator|=
name|arr
operator|->
name|orig_array
expr_stmt|;
if|if
condition|(
name|arr
operator|->
name|type
operator|!=
name|Node_var
operator|&&
name|arr
operator|->
name|type
operator|!=
name|Node_var_array
condition|)
name|fatal
argument_list|(
literal|"second argument of split is not an array"
argument_list|)
expr_stmt|;
name|arr
operator|->
name|type
operator|=
name|Node_var_array
expr_stmt|;
name|assoc_clear
argument_list|(
name|arr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sep
operator|->
name|re_flags
operator|&
name|FS_DFLT
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|using_FIELDWIDTHS
argument_list|()
condition|)
block|{
name|parseit
operator|=
name|parse_field
expr_stmt|;
name|fs
operator|=
name|force_string
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|rp
operator|=
name|FS_regexp
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|force_string
argument_list|(
name|tree_eval
argument_list|(
name|sep
operator|->
name|re_exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|stlen
operator|==
literal|0
condition|)
name|parseit
operator|=
name|null_parse_field
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|->
name|stlen
operator|==
literal|1
operator|&&
operator|(
name|sep
operator|->
name|re_flags
operator|&
name|CONST
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|do_posix
condition|)
name|parseit
operator|=
name|posix_def_parse_field
expr_stmt|;
else|else
name|parseit
operator|=
name|def_parse_field
expr_stmt|;
block|}
else|else
name|parseit
operator|=
name|sc_parse_field
expr_stmt|;
block|}
else|else
block|{
name|parseit
operator|=
name|re_parse_field
expr_stmt|;
name|rp
operator|=
name|re_update
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
name|tmp
expr_stmt|;
block|}
name|s
operator|=
name|src
operator|->
name|stptr
expr_stmt|;
name|tmp
operator|=
name|tmp_number
argument_list|(
call|(
name|AWKNUM
call|)
argument_list|(
operator|*
name|parseit
argument_list|)
argument_list|(
name|HUGE
argument_list|,
operator|&
name|s
argument_list|,
operator|(
name|int
operator|)
name|src
operator|->
name|stlen
argument_list|,
name|fs
argument_list|,
name|rp
argument_list|,
name|set_element
argument_list|,
name|arr
argument_list|)
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|free_temp
argument_list|(
name|sep
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* set_FIELDWIDTHS --- handle an assignment to FIELDWIDTHS */
end_comment

begin_function
name|void
name|set_FIELDWIDTHS
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|fw_alloc
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
if|if
condition|(
name|do_lint
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|(
literal|"use of FIELDWIDTHS is a gawk extension"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_traditional
condition|)
comment|/* quick and dirty, does the trick */
return|return;
comment|/* 	 * If changing the way fields are split, obey least-suprise 	 * semantics, and force $0 to be split totally. 	 */
if|if
condition|(
name|fields_arr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|get_field
argument_list|(
name|HUGE
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parse_field
operator|=
name|fw_parse_field
expr_stmt|;
name|scan
operator|=
name|force_string
argument_list|(
name|FIELDWIDTHS_node
operator|->
name|var_value
argument_list|)
operator|->
name|stptr
expr_stmt|;
name|end
operator|=
name|scan
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|FIELDWIDTHS
operator|==
name|NULL
condition|)
name|emalloc
argument_list|(
name|FIELDWIDTHS
argument_list|,
name|int
operator|*
argument_list|,
name|fw_alloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|"set_FIELDWIDTHS"
argument_list|)
expr_stmt|;
name|FIELDWIDTHS
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|fw_alloc
condition|)
block|{
name|fw_alloc
operator|*=
literal|2
expr_stmt|;
name|erealloc
argument_list|(
name|FIELDWIDTHS
argument_list|,
name|int
operator|*
argument_list|,
name|fw_alloc
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|"set_FIELDWIDTHS"
argument_list|)
expr_stmt|;
block|}
name|FIELDWIDTHS
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|strtod
argument_list|(
name|scan
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|scan
condition|)
break|break;
name|scan
operator|=
name|end
expr_stmt|;
block|}
name|FIELDWIDTHS
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_FS_if_not_FIELDWIDTHS
parameter_list|()
block|{
if|if
condition|(
name|parse_field
operator|!=
name|fw_parse_field
condition|)
name|set_FS
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_FS --- handle things when FS is assigned to */
end_comment

begin_function
name|void
name|set_FS
parameter_list|()
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|NODE
modifier|*
name|fs
decl_stmt|;
specifier|static
name|NODE
modifier|*
name|save_fs
init|=
name|NULL
decl_stmt|;
specifier|static
name|NODE
modifier|*
name|save_rs
init|=
name|NULL
decl_stmt|;
comment|/* 	 * If changing the way fields are split, obey least-suprise 	 * semantics, and force $0 to be split totally. 	 */
if|if
condition|(
name|fields_arr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|get_field
argument_list|(
name|HUGE
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|save_fs
operator|&&
name|cmp_nodes
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|,
name|save_fs
argument_list|)
operator|==
literal|0
operator|&&
name|save_rs
operator|&&
name|cmp_nodes
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|,
name|save_rs
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|unref
argument_list|(
name|save_fs
argument_list|)
expr_stmt|;
name|save_fs
operator|=
name|dupnode
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|unref
argument_list|(
name|save_rs
argument_list|)
expr_stmt|;
name|save_rs
operator|=
name|dupnode
argument_list|(
name|RS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
name|resave_fs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|FS_regexp
condition|)
block|{
name|refree
argument_list|(
name|FS_regexp
argument_list|)
expr_stmt|;
name|FS_regexp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|default_FS
operator|=
name|FALSE
expr_stmt|;
name|fs
operator|=
name|force_string
argument_list|(
name|FS_node
operator|->
name|var_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_traditional
operator|&&
name|fs
operator|->
name|stlen
operator|==
literal|0
condition|)
name|parse_field
operator|=
name|null_parse_field
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|stlen
operator|>
literal|1
condition|)
name|parse_field
operator|=
name|re_parse_field
expr_stmt|;
elseif|else
if|if
condition|(
name|RS_is_null
condition|)
block|{
name|parse_field
operator|=
name|sc_parse_field
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|stlen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|default_FS
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"[ \t\n]+"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%c\n]"
argument_list|,
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|do_posix
condition|)
name|parse_field
operator|=
name|posix_def_parse_field
expr_stmt|;
else|else
name|parse_field
operator|=
name|def_parse_field
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
name|fs
operator|->
name|stlen
operator|==
literal|1
condition|)
name|default_FS
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
operator|!=
literal|' '
operator|&&
name|fs
operator|->
name|stlen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|IGNORECASE
operator|||
operator|!
name|isalpha
argument_list|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
argument_list|)
condition|)
name|parse_field
operator|=
name|sc_parse_field
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
comment|/* yet another special case */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"[\\\\]"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"[%c]"
argument_list|,
name|fs
operator|->
name|stptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|FS_regexp
operator|=
name|make_regexp
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|IGNORECASE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|parse_field
operator|=
name|re_parse_field
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parse_field
operator|==
name|re_parse_field
condition|)
block|{
name|FS_regexp
operator|=
name|make_regexp
argument_list|(
name|fs
operator|->
name|stptr
argument_list|,
name|fs
operator|->
name|stlen
argument_list|,
name|IGNORECASE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|FS_regexp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* using_fieldwidths --- is FS or FIELDWIDTHS in use? */
end_comment

begin_function
name|int
name|using_fieldwidths
parameter_list|()
block|{
return|return
name|using_FIELDWIDTHS
argument_list|()
return|;
block|}
end_function

end_unit

