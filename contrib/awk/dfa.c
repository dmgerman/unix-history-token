begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dfa.c - deterministic extended regexp routines for GNU    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA */
end_comment

begin_comment
comment|/* Written June, 1988 by Mike Haertel    Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_undef
undef|#
directive|undef
name|index
end_undef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_comment
comment|/* use the same approach as regex.c */
end_comment

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|C
parameter_list|)
value|(isprint(C)&& !isspace(C))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|isascii
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ISASCII
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|C
parameter_list|)
value|isalpha(C)
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|C
parameter_list|)
value|isupper(C)
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|C
parameter_list|)
value|islower(C)
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|C
parameter_list|)
value|isdigit(C)
end_define

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|C
parameter_list|)
value|isxdigit(C)
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|C
parameter_list|)
value|isspace(C)
end_define

begin_define
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|C
parameter_list|)
value|ispunct(C)
end_define

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|C
parameter_list|)
value|isalnum(C)
end_define

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|C
parameter_list|)
value|isprint(C)
end_define

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|C
parameter_list|)
value|isgraph(C)
end_define

begin_define
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|C
parameter_list|)
value|iscntrl(C)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isalpha(C))
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isupper(C))
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& islower(C))
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isdigit(C))
end_define

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isxdigit(C))
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isspace(C))
end_define

begin_define
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& ispunct(C))
end_define

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isalnum(C))
end_define

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isprint(C))
end_define

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isgraph(C))
end_define

begin_define
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& iscntrl(C))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dfamust
name|_RE_ARGS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
name|dfa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ptr_t
name|xcalloc
name|_RE_ARGS
argument_list|(
operator|(
name|size_t
name|n
operator|,
name|size_t
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ptr_t
name|xmalloc
name|_RE_ARGS
argument_list|(
operator|(
name|size_t
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ptr_t
name|xrealloc
name|_RE_ARGS
argument_list|(
operator|(
name|ptr_t
name|p
operator|,
name|size_t
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|prtok
name|_RE_ARGS
argument_list|(
operator|(
name|token
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|tstbit
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|b
operator|,
name|charclass
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setbit
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|b
operator|,
name|charclass
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clrbit
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|b
operator|,
name|charclass
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copyset
name|_RE_ARGS
argument_list|(
operator|(
name|charclass
name|src
operator|,
name|charclass
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zeroset
name|_RE_ARGS
argument_list|(
operator|(
name|charclass
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notset
name|_RE_ARGS
argument_list|(
operator|(
name|charclass
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|equal
name|_RE_ARGS
argument_list|(
operator|(
name|charclass
name|s1
operator|,
name|charclass
name|s2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|charclass_index
name|_RE_ARGS
argument_list|(
operator|(
name|charclass
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|looking_at
name|_RE_ARGS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|token
name|lex
name|_RE_ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addtok
name|_RE_ARGS
argument_list|(
operator|(
name|token
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|atom
name|_RE_ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsubtoks
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|tindex
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copytoks
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|tindex
operator|,
name|int
name|ntokens
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|closure
name|_RE_ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|branch
name|_RE_ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regexp
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|toplevel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy
name|_RE_ARGS
argument_list|(
operator|(
name|position_set
operator|*
name|src
operator|,
name|position_set
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert
name|_RE_ARGS
argument_list|(
operator|(
name|position
name|p
operator|,
name|position_set
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge
name|_RE_ARGS
argument_list|(
operator|(
name|position_set
operator|*
name|s1
operator|,
name|position_set
operator|*
name|s2
operator|,
name|position_set
operator|*
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete
name|_RE_ARGS
argument_list|(
operator|(
name|position
name|p
operator|,
name|position_set
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state_index
name|_RE_ARGS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
name|d
operator|,
name|position_set
operator|*
name|s
operator|,
name|int
name|newline
operator|,
name|int
name|letter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_state
name|_RE_ARGS
argument_list|(
operator|(
name|int
name|s
operator|,
expr|struct
name|dfa
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_state_zero
name|_RE_ARGS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|icatalloc
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
name|old
operator|,
name|char
operator|*
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|icpyalloc
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|istrstr
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
name|lookin
operator|,
name|char
operator|*
name|lookfor
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ifree
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
name|cp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|freelist
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|cpp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|enlist
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|cpp
operator|,
name|char
operator|*
name|new
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|comsubs
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
name|left
operator|,
name|char
operator|*
name|right
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|addlists
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|old
operator|,
name|char
operator|*
operator|*
name|new
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|inboth
name|_RE_ARGS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|left
operator|,
name|char
operator|*
operator|*
name|right
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ptr_t
name|xcalloc
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|size_t
name|n
decl_stmt|;
name|size_t
name|s
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|calloc
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|ptr_t
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|size_t
name|n
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|ptr_t
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|ptr_t
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xcalloc((size_t)(n), sizeof (t)))
end_define

begin_define
define|#
directive|define
name|MALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xmalloc((n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xrealloc((ptr_t) (p), (n) * sizeof (t)))
end_define

begin_comment
comment|/* Reallocate an array of type t if nalloc is too small for index. */
end_comment

begin_define
define|#
directive|define
name|REALLOC_IF_NECESSARY
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|nalloc
parameter_list|,
name|index
parameter_list|)
define|\
value|if ((index)>= (nalloc))			  \     {						  \       while ((index)>= (nalloc))		  \ 	(nalloc) *= 2;				  \       REALLOC(p, t, nalloc);			  \     }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|prtok
parameter_list|(
name|t
parameter_list|)
name|token
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"END"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<
name|NOTCHAR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|EMPTY
case|:
name|s
operator|=
literal|"EMPTY"
expr_stmt|;
break|break;
case|case
name|BACKREF
case|:
name|s
operator|=
literal|"BACKREF"
expr_stmt|;
break|break;
case|case
name|BEGLINE
case|:
name|s
operator|=
literal|"BEGLINE"
expr_stmt|;
break|break;
case|case
name|ENDLINE
case|:
name|s
operator|=
literal|"ENDLINE"
expr_stmt|;
break|break;
case|case
name|BEGWORD
case|:
name|s
operator|=
literal|"BEGWORD"
expr_stmt|;
break|break;
case|case
name|ENDWORD
case|:
name|s
operator|=
literal|"ENDWORD"
expr_stmt|;
break|break;
case|case
name|LIMWORD
case|:
name|s
operator|=
literal|"LIMWORD"
expr_stmt|;
break|break;
case|case
name|NOTLIMWORD
case|:
name|s
operator|=
literal|"NOTLIMWORD"
expr_stmt|;
break|break;
case|case
name|QMARK
case|:
name|s
operator|=
literal|"QMARK"
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|s
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|s
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
case|case
name|CAT
case|:
name|s
operator|=
literal|"CAT"
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|s
operator|=
literal|"OR"
expr_stmt|;
break|break;
case|case
name|ORTOP
case|:
name|s
operator|=
literal|"ORTOP"
expr_stmt|;
break|break;
case|case
name|LPAREN
case|:
name|s
operator|=
literal|"LPAREN"
expr_stmt|;
break|break;
case|case
name|RPAREN
case|:
name|s
operator|=
literal|"RPAREN"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"CSET"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Stuff pertaining to charclasses. */
end_comment

begin_function
specifier|static
name|int
name|tstbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|charclass
name|c
decl_stmt|;
block|{
return|return
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&
literal|1
operator|<<
name|b
operator|%
name|INTBITS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|charclass
name|c
decl_stmt|;
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator||=
literal|1
operator|<<
name|b
operator|%
name|INTBITS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clrbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|charclass
name|c
decl_stmt|;
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|b
operator|%
name|INTBITS
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copyset
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|charclass
name|src
decl_stmt|;
name|charclass
name|dst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|i
control|)
name|dst
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroset
parameter_list|(
name|s
parameter_list|)
name|charclass
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notset
parameter_list|(
name|s
parameter_list|)
name|charclass
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
operator|~
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|equal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|charclass
name|s1
decl_stmt|;
name|charclass
name|s2
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|s1
index|[
name|i
index|]
operator|!=
name|s2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A pointer to the current dfa is kept here during parsing. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dfa
modifier|*
name|dfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
end_comment

begin_function
specifier|static
name|int
name|charclass_index
parameter_list|(
name|s
parameter_list|)
name|charclass
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|cindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|equal
argument_list|(
name|s
argument_list|,
name|dfa
operator|->
name|charclasses
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|charclasses
argument_list|,
name|charclass
argument_list|,
name|dfa
operator|->
name|calloc
argument_list|,
name|dfa
operator|->
name|cindex
argument_list|)
expr_stmt|;
operator|++
name|dfa
operator|->
name|cindex
expr_stmt|;
name|copyset
argument_list|(
name|s
argument_list|,
name|dfa
operator|->
name|charclasses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Syntax bits controlling the behavior of the lexical analyzer. */
end_comment

begin_decl_stmt
specifier|static
name|reg_syntax_t
name|syntax_bits
decl_stmt|,
name|syntax_bits_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for case-folding letters into sets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|case_fold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point to set syntax options. */
end_comment

begin_function
name|void
name|dfasyntax
parameter_list|(
name|bits
parameter_list|,
name|fold
parameter_list|)
name|reg_syntax_t
name|bits
decl_stmt|;
name|int
name|fold
decl_stmt|;
block|{
name|syntax_bits_set
operator|=
literal|1
expr_stmt|;
name|syntax_bits
operator|=
name|bits
expr_stmt|;
name|case_fold
operator|=
name|fold
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lexical analyzer.  All the dross that deals with the obnoxious    GNU Regex syntax bits is located here.  The poor, suffering    reader is referred to the GNU Regex documentation for the    meaning of the @#%!@#%^!@ syntax bits. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lexstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to beginning of input string. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to next input character. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lexleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters remaining. */
end_comment

begin_decl_stmt
specifier|static
name|token
name|lasttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous token returned; initially END. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|laststart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we're separated from beginning or (, | 				   only by zero-width characters. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of outstanding left parens. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|minrep
decl_stmt|,
name|maxrep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repeat counts for {m,n}. */
end_comment

begin_comment
comment|/* Note that characters become unsigned here. */
end_comment

begin_define
define|#
directive|define
name|FETCH
parameter_list|(
name|c
parameter_list|,
name|eoferr
parameter_list|)
define|\
value|{			   	      \     if (! lexleft)	   	      \       if (eoferr != 0)	   	      \ 	dfaerror(eoferr);  	      \       else		   	      \ 	return lasttok = END;	      \     (c) = (unsigned char) *lexptr++;  \     --lexleft;		   	      \   }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|FUNC
parameter_list|(
name|F
parameter_list|,
name|P
parameter_list|)
value|static int F(int c) { return P(c); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC
parameter_list|(
name|F
parameter_list|,
name|P
parameter_list|)
value|static int F(c) int c; { return P(c); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|FUNC
argument_list|(
argument|is_alpha
argument_list|,
argument|ISALPHA
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_upper
argument_list|,
argument|ISUPPER
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_lower
argument_list|,
argument|ISLOWER
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_digit
argument_list|,
argument|ISDIGIT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_xdigit
argument_list|,
argument|ISXDIGIT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_space
argument_list|,
argument|ISSPACE
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_punct
argument_list|,
argument|ISPUNCT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_alnum
argument_list|,
argument|ISALNUM
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_print
argument_list|,
argument|ISPRINT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_graph
argument_list|,
argument|ISGRAPH
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_cntrl
argument_list|,
argument|ISCNTRL
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|is_blank
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following list maps the names of the Posix named character classes    to predicate functions that determine whether a given character is in    the class.  The leading [ has already been eaten by the lexical analyzer. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|*pred
argument_list|)
name|_RE_ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
name|prednames
index|[]
init|=
block|{
block|{
literal|":alpha:]"
block|,
name|is_alpha
block|}
block|,
block|{
literal|":upper:]"
block|,
name|is_upper
block|}
block|,
block|{
literal|":lower:]"
block|,
name|is_lower
block|}
block|,
block|{
literal|":digit:]"
block|,
name|is_digit
block|}
block|,
block|{
literal|":xdigit:]"
block|,
name|is_xdigit
block|}
block|,
block|{
literal|":space:]"
block|,
name|is_space
block|}
block|,
block|{
literal|":punct:]"
block|,
name|is_punct
block|}
block|,
block|{
literal|":alnum:]"
block|,
name|is_alnum
block|}
block|,
block|{
literal|":print:]"
block|,
name|is_print
block|}
block|,
block|{
literal|":graph:]"
block|,
name|is_graph
block|}
block|,
block|{
literal|":cntrl:]"
block|,
name|is_cntrl
block|}
block|,
block|{
literal|":blank:]"
block|,
name|is_blank
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|looking_at
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexleft
operator|<
name|len
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|s
argument_list|,
name|lexptr
argument_list|,
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|token
name|lex
parameter_list|()
block|{
name|token
name|c
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|backslash
init|=
literal|0
decl_stmt|,
name|invert
decl_stmt|;
name|charclass
name|ccl
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Basic plan: We fetch a character.  If it's a backslash,      we set the backslash flag and go through the loop again.      On the plus side, this avoids having a duplicate of the      main switch inside the backslash case.  On the minus side,      it means that just about every case begins with      "if (backslash) ...".  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|lexleft
operator|==
literal|0
condition|)
name|dfaerror
argument_list|(
literal|"Unfinished \\ escape"
argument_list|)
expr_stmt|;
name|backslash
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
operator|||
name|lasttok
operator|==
name|END
operator|||
name|lasttok
operator|==
name|LPAREN
operator|||
name|lasttok
operator|==
name|OR
condition|)
return|return
name|lasttok
operator|=
name|BEGLINE
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
operator|||
name|lexleft
operator|==
literal|0
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|')'
else|:
name|lexleft
operator|>
literal|1
operator|&&
name|lexptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|'|'
else|:
name|lexleft
operator|>
literal|1
operator|&&
name|lexptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|'|'
operator|)
operator|||
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NEWLINE_ALT
operator|)
operator|&&
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|'\n'
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDLINE
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_REFS
operator|)
condition|)
block|{
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|BACKREF
return|;
block|}
goto|goto
name|normal_char
goto|;
case|case
literal|'`'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|BEGLINE
return|;
comment|/* FIXME: should be beginning of string */
goto|goto
name|normal_char
goto|;
case|case
literal|'\''
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDLINE
return|;
comment|/* FIXME: should be end of string */
goto|goto
name|normal_char
goto|;
case|case
literal|'<'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|BEGWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'>'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'b'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|LIMWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'B'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|NOTLIMWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|QMARK
return|;
case|case
literal|'*'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|STAR
return|;
case|case
literal|'+'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|PLUS
return|;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_INTERVALS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|minrep
operator|=
name|maxrep
operator|=
literal|0
expr_stmt|;
comment|/* Cases: 	     {M} - exact count 	     {M,} - minimum count, maximum is infinity 	     {,M} - 0 through M 	     {M,N} - M through N */
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"unfinished repeat count"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|minrep
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"unfinished repeat count"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|minrep
operator|=
literal|10
operator|*
name|minrep
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
name|dfaerror
argument_list|(
literal|"malformed repeat count"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"unfinished repeat count"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|maxrep
operator|=
literal|10
operator|*
name|maxrep
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
name|maxrep
operator|=
name|minrep
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|dfaerror
argument_list|(
literal|"malformed repeat count"
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"unfinished repeat count"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
name|dfaerror
argument_list|(
literal|"malformed repeat count"
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|REPMN
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|OR
return|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
operator|||
name|backslash
operator|||
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NEWLINE_ALT
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|OR
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
operator|++
name|parens
expr_stmt|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|LPAREN
return|;
case|case
literal|')'
case|:
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|parens
operator|==
literal|0
operator|&&
name|syntax_bits
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_char
goto|;
operator|--
name|parens
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|RPAREN
return|;
case|case
literal|'.'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|clrbit
argument_list|(
literal|'\n'
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_DOT_NOT_NULL
condition|)
name|clrbit
argument_list|(
literal|'\0'
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|backslash
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|NOTCHAR
condition|;
operator|++
name|c2
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
name|c2
argument_list|)
condition|)
name|setbit
argument_list|(
name|c2
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
literal|'_'
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'W'
condition|)
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
name|invert
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|invert
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Nobody ever said this had to be fast. :-) 		 Note that if we're looking at some other [:...:] 		 construct, we just treat it as a bunch of ordinary 		 characters.  We can do this because we assume 		 regex has checked for syntax errors before 		 dfa is ever called. */
if|if
condition|(
name|c
operator|==
literal|'['
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_CHAR_CLASSES
operator|)
condition|)
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|prednames
index|[
name|c1
index|]
operator|.
name|name
condition|;
operator|++
name|c1
control|)
if|if
condition|(
name|looking_at
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|int
function_decl|(
modifier|*
name|pred
function_decl|)
parameter_list|()
init|=
name|prednames
index|[
name|c1
index|]
operator|.
name|pred
function_decl|;
if|if
condition|(
name|case_fold
operator|&&
operator|(
name|pred
operator|==
name|is_upper
operator|||
name|pred
operator|==
name|is_lower
operator|)
condition|)
name|pred
operator|=
name|is_alpha
expr_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|NOTCHAR
condition|;
operator|++
name|c2
control|)
if|if
condition|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|c2
argument_list|)
condition|)
name|setbit
argument_list|(
name|c2
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|lexptr
operator|+=
name|strlen
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|lexleft
operator|-=
name|strlen
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'-'
condition|)
block|{
name|FETCH
argument_list|(
name|c2
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|']'
condition|)
block|{
comment|/* In the case [x-], the - is an ordinary hyphen, 			 which is left in c1, the lookahead character. */
operator|--
name|lexptr
expr_stmt|;
operator|++
name|lexleft
expr_stmt|;
name|c2
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c2
operator|==
literal|'\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|FETCH
argument_list|(
name|c2
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|c2
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|<=
name|c2
condition|)
block|{
name|setbit
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_fold
condition|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|skip
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c1
operator|)
operator|!=
literal|']'
condition|)
do|;
if|if
condition|(
name|invert
condition|)
block|{
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
condition|)
name|clrbit
argument_list|(
literal|'\n'
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
block|}
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
default|default:
name|normal_char
label|:
name|laststart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|case_fold
operator|&&
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
else|else
name|setbit
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
block|}
return|return
name|c
return|;
block|}
block|}
comment|/* The above loop should consume at most a backslash      and some other character. */
name|abort
argument_list|()
expr_stmt|;
return|return
name|END
return|;
comment|/* keeps pedantic compilers happy. */
block|}
end_function

begin_comment
comment|/* Recursive descent parser for regular expressions. */
end_comment

begin_decl_stmt
specifier|static
name|token
name|tok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookahead token. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current depth of a hypothetical stack 				   holding deferred productions.  This is 				   used to determine the depth that will be 				   required of the real stack later on in 				   dfaanalyze(). */
end_comment

begin_comment
comment|/* Add the given token to the parse tree, maintaining the depth count and    updating the maximum depth if necessary. */
end_comment

begin_function
specifier|static
name|void
name|addtok
parameter_list|(
name|t
parameter_list|)
name|token
name|t
decl_stmt|;
block|{
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|dfa
operator|->
name|talloc
argument_list|,
name|dfa
operator|->
name|tindex
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|tokens
index|[
name|dfa
operator|->
name|tindex
operator|++
index|]
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|QMARK
case|:
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
operator|--
name|depth
expr_stmt|;
break|break;
default|default:
operator|++
name|dfa
operator|->
name|nleaves
expr_stmt|;
case|case
name|EMPTY
case|:
operator|++
name|depth
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|depth
operator|>
name|dfa
operator|->
name|depth
condition|)
name|dfa
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The grammar understood by the parser is as follows.     regexp:      regexp OR branch      branch     branch:      branch closure      closure     closure:      closure QMARK      closure STAR      closure PLUS      atom     atom:<normal character>      CSET      BACKREF      BEGLINE      ENDLINE      BEGWORD      ENDWORD      LIMWORD      NOTLIMWORD<empty>     The parser builds a parse tree in postfix form in an array of tokens. */
end_comment

begin_function
specifier|static
name|void
name|atom
parameter_list|()
block|{
if|if
condition|(
operator|(
name|tok
operator|>=
literal|0
operator|&&
name|tok
operator|<
name|NOTCHAR
operator|)
operator|||
name|tok
operator|>=
name|CSET
operator|||
name|tok
operator|==
name|BACKREF
operator|||
name|tok
operator|==
name|BEGLINE
operator|||
name|tok
operator|==
name|ENDLINE
operator|||
name|tok
operator|==
name|BEGWORD
operator|||
name|tok
operator|==
name|ENDWORD
operator|||
name|tok
operator|==
name|LIMWORD
operator|||
name|tok
operator|==
name|NOTLIMWORD
condition|)
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|LPAREN
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|regexp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|RPAREN
condition|)
name|dfaerror
argument_list|(
literal|"Unbalanced ("
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
else|else
name|addtok
argument_list|(
name|EMPTY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of tokens in the given subexpression. */
end_comment

begin_function
specifier|static
name|int
name|nsubtoks
parameter_list|(
name|tindex
parameter_list|)
name|int
name|tindex
decl_stmt|;
block|{
name|int
name|ntoks1
decl_stmt|;
switch|switch
condition|(
name|dfa
operator|->
name|tokens
index|[
name|tindex
operator|-
literal|1
index|]
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|QMARK
case|:
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
return|return
literal|1
operator|+
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
argument_list|)
return|;
case|case
name|CAT
case|:
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
name|ntoks1
operator|=
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
operator|+
name|ntoks1
operator|+
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
operator|-
name|ntoks1
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the given subexpression to the top of the tree. */
end_comment

begin_function
specifier|static
name|void
name|copytoks
parameter_list|(
name|tindex
parameter_list|,
name|ntokens
parameter_list|)
name|int
name|tindex
decl_stmt|,
name|ntokens
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
name|addtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|tindex
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|closure
parameter_list|()
block|{
name|int
name|tindex
decl_stmt|,
name|ntokens
decl_stmt|,
name|i
decl_stmt|;
name|atom
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|QMARK
operator|||
name|tok
operator|==
name|STAR
operator|||
name|tok
operator|==
name|PLUS
operator|||
name|tok
operator|==
name|REPMN
condition|)
if|if
condition|(
name|tok
operator|==
name|REPMN
condition|)
block|{
name|ntokens
operator|=
name|nsubtoks
argument_list|(
name|dfa
operator|->
name|tindex
argument_list|)
expr_stmt|;
name|tindex
operator|=
name|dfa
operator|->
name|tindex
operator|-
name|ntokens
expr_stmt|;
if|if
condition|(
name|maxrep
operator|==
literal|0
condition|)
name|addtok
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|minrep
operator|==
literal|0
condition|)
name|addtok
argument_list|(
name|QMARK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|minrep
condition|;
operator|++
name|i
control|)
block|{
name|copytoks
argument_list|(
name|tindex
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|maxrep
condition|;
operator|++
name|i
control|)
block|{
name|copytoks
argument_list|(
name|tindex
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|QMARK
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|branch
parameter_list|()
block|{
name|closure
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|RPAREN
operator|&&
name|tok
operator|!=
name|OR
operator|&&
name|tok
operator|>=
literal|0
condition|)
block|{
name|closure
argument_list|()
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|regexp
parameter_list|(
name|toplevel
parameter_list|)
name|int
name|toplevel
decl_stmt|;
block|{
name|branch
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|OR
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|branch
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplevel
condition|)
name|addtok
argument_list|(
name|ORTOP
argument_list|)
expr_stmt|;
else|else
name|addtok
argument_list|(
name|OR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for the parser.  S is a string to be parsed, len is the    length of the string, so s can include NUL characters.  D is a pointer to    the struct dfa to parse into. */
end_comment

begin_function
name|void
name|dfaparse
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|dfa
operator|=
name|d
expr_stmt|;
name|lexstart
operator|=
name|lexptr
operator|=
name|s
expr_stmt|;
name|lexleft
operator|=
name|len
expr_stmt|;
name|lasttok
operator|=
name|END
expr_stmt|;
name|laststart
operator|=
literal|1
expr_stmt|;
name|parens
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|syntax_bits_set
condition|)
name|dfaerror
argument_list|(
literal|"No syntax specified"
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|depth
operator|=
name|d
operator|->
name|depth
expr_stmt|;
name|regexp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|END
condition|)
name|dfaerror
argument_list|(
literal|"Unbalanced )"
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|END
operator|-
name|d
operator|->
name|nregexps
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|nregexps
condition|)
name|addtok
argument_list|(
name|ORTOP
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|nregexps
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some primitives for operating on sets of positions. */
end_comment

begin_comment
comment|/* Copy one set to another; the destination must be large enough. */
end_comment

begin_function
specifier|static
name|void
name|copy
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|position_set
modifier|*
name|src
decl_stmt|;
name|position_set
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|dst
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|src
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|dst
operator|->
name|nelem
operator|=
name|src
operator|->
name|nelem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a position in a set.  Position sets are maintained in sorted    order according to index.  If position already exists in the set with    the same index then their constraints are logically or'd together.    S->elems must point to an array large enough to hold the resulting set. */
end_comment

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|position
name|p
decl_stmt|;
name|position_set
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|position
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|<
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|;
operator|++
name|i
control|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|p
operator|.
name|constraint
expr_stmt|;
else|else
block|{
name|t1
operator|=
name|p
expr_stmt|;
operator|++
name|s
operator|->
name|nelem
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
block|{
name|t2
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|elems
index|[
name|i
operator|++
index|]
operator|=
name|t1
expr_stmt|;
name|t1
operator|=
name|t2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge two sets of positions into a third.  The result is exactly as if    the positions of both sets were inserted into an initially empty set. */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|m
parameter_list|)
name|position_set
modifier|*
name|s1
decl_stmt|;
name|position_set
modifier|*
name|s2
decl_stmt|;
name|position_set
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|m
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
operator|&&
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|>
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|<
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
else|else
block|{
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|.
name|constraint
operator||=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
operator|.
name|constraint
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a position from a set. */
end_comment

begin_function
specifier|static
name|void
name|delete
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|position
name|p
decl_stmt|;
name|position_set
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
for|for
control|(
operator|--
name|s
operator|->
name|nelem
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|s
operator|->
name|elems
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the index of the state corresponding to the given position set with    the given preceding context, or create a new state if there is no such    state.  Newline and letter tell whether we got here on a newline or    letter, respectively. */
end_comment

begin_function
specifier|static
name|int
name|state_index
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|newline
parameter_list|,
name|letter
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
name|position_set
modifier|*
name|s
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|constraint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|newline
operator|=
name|newline
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|letter
operator|=
name|letter
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|hash
operator|^=
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|+
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
expr_stmt|;
comment|/* Try to find a state that exactly matches the proposed one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|hash
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|||
name|s
operator|->
name|nelem
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|nelem
operator|||
name|newline
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|||
name|letter
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|||
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|s
operator|->
name|nelem
condition|)
return|return
name|i
return|;
block|}
comment|/* We'll have to create a new state. */
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|states
argument_list|,
name|dfa_state
argument_list|,
name|d
operator|->
name|salloc
argument_list|,
name|d
operator|->
name|sindex
argument_list|)
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|s
operator|->
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|s
argument_list|,
operator|&
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|=
name|newline
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
operator|=
name|letter
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|<
literal|0
condition|)
block|{
name|constraint
operator|=
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
expr_stmt|;
if|if
condition|(
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
condition|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|==
name|BACKREF
condition|)
block|{
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
name|NO_CONSTRAINT
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|sindex
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Find the epsilon closure of a set of positions.  If any position of the set    contains a symbol that matches the empty string in some context, replace    that position with the elements of its follow labeled with an appropriate    constraint.  Repeat exhaustively until no funny positions are left.    S->elems must be large enough to hold the result. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epsclosure
name|_RE_ARGS
argument_list|(
operator|(
name|position_set
operator|*
name|s
operator|,
expr|struct
name|dfa
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|epsclosure
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
name|position_set
modifier|*
name|s
decl_stmt|;
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
name|visited
decl_stmt|;
name|position
name|p
decl_stmt|,
name|old
decl_stmt|;
name|MALLOC
argument_list|(
name|visited
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|visited
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|>=
name|NOTCHAR
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|!=
name|BACKREF
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|<
name|CSET
condition|)
block|{
name|old
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|p
operator|.
name|constraint
operator|=
name|old
operator|.
name|constraint
expr_stmt|;
name|delete
argument_list|(
name|s
operator|->
name|elems
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|visited
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|visited
index|[
name|old
operator|.
name|index
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|tokens
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
case|case
name|BEGLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|BEGLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|ENDLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|ENDLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|BEGWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|BEGWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|ENDWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|ENDWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|LIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|LIMWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|NOTLIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|NOTLIMWORD_CONSTRAINT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
block|{
name|p
operator|.
name|index
operator|=
name|d
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
expr_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Force rescan to start at the beginning. */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform bottom-up analysis on the parse tree, computing various functions.    Note that at this point, we're pretending constructs like \< are real    characters rather than constraints on what can follow them.     Nullable:  A node is nullable if it is at the root of a regexp that can    match the empty string.    *  EMPTY leaves are nullable.    * No other leaf is nullable.    * A QMARK or STAR node is nullable.    * A PLUS node is nullable if its argument is nullable.    * A CAT node is nullable if both its arguments are nullable.    * An OR node is nullable if either argument is nullable.     Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)    that could correspond to the first character of a string matching the    regexp rooted at the given node.    * EMPTY leaves have empty firstpos.    * The firstpos of a nonempty leaf is that leaf itself.    * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its      argument.    * The firstpos of a CAT node is the firstpos of the left argument, union      the firstpos of the right if the left argument is nullable.    * The firstpos of an OR node is the union of firstpos of each argument.     Lastpos:  The lastpos of a node is the set of positions that could    correspond to the last character of a string matching the regexp at    the given node.    * EMPTY leaves have empty lastpos.    * The lastpos of a nonempty leaf is that leaf itself.    * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its      argument.    * The lastpos of a CAT node is the lastpos of its right argument, union      the lastpos of the left if the right argument is nullable.    * The lastpos of an OR node is the union of the lastpos of each argument.     Follow:  The follow of a position is the set of positions that could    correspond to the character following a character matching the node in    a string matching the regexp.  At this point we consider special symbols    that match the empty string in some context to be just normal characters.    Later, if we find that a special symbol is in a follow set, we will    replace it with the elements of its follow, labeled with an appropriate    constraint.    * Every node in the firstpos of the argument of a STAR or PLUS node is in      the follow of every node in the lastpos.    * Every node in the firstpos of the second argument of a CAT node is in      the follow of every node in the lastpos of the first argument.     Because of the postfix representation of the parse tree, the depth-first    analysis is conveniently done by a linear scan with the aid of a stack.    Sets are stored as arrays of the elements, obeying a stack-like allocation    scheme; the number of elements in each set deeper in the stack can be    used to determine the address of a particular set's array. */
end_comment

begin_function
name|void
name|dfaanalyze
parameter_list|(
name|d
parameter_list|,
name|searchflag
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
name|int
name|searchflag
decl_stmt|;
block|{
name|int
modifier|*
name|nullable
decl_stmt|;
comment|/* Nullable stack. */
name|int
modifier|*
name|nfirstpos
decl_stmt|;
comment|/* Element count stack for firstpos sets. */
name|position
modifier|*
name|firstpos
decl_stmt|;
comment|/* Array where firstpos elements are stored. */
name|int
modifier|*
name|nlastpos
decl_stmt|;
comment|/* Element count stack for lastpos sets. */
name|position
modifier|*
name|lastpos
decl_stmt|;
comment|/* Array where lastpos elements are stored. */
name|int
modifier|*
name|nalloc
decl_stmt|;
comment|/* Sizes of arrays allocated to follow sets. */
name|position_set
name|tmp
decl_stmt|;
comment|/* Temporary set for merging sets. */
name|position_set
name|merged
decl_stmt|;
comment|/* Result of merging sets. */
name|int
name|wants_newline
decl_stmt|;
comment|/* True if some position wants newline info. */
name|int
modifier|*
name|o_nullable
decl_stmt|;
name|int
modifier|*
name|o_nfirst
decl_stmt|,
modifier|*
name|o_nlast
decl_stmt|;
name|position
modifier|*
name|o_firstpos
decl_stmt|,
modifier|*
name|o_lastpos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|position
modifier|*
name|pos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dfaanalyze:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|searchflag
operator|=
name|searchflag
expr_stmt|;
name|MALLOC
argument_list|(
name|nullable
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nullable
operator|=
name|nullable
expr_stmt|;
name|MALLOC
argument_list|(
name|nfirstpos
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nfirst
operator|=
name|nfirstpos
expr_stmt|;
name|MALLOC
argument_list|(
name|firstpos
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_firstpos
operator|=
name|firstpos
operator|,
name|firstpos
operator|+=
name|d
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nlastpos
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nlast
operator|=
name|nlastpos
expr_stmt|;
name|MALLOC
argument_list|(
name|lastpos
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_lastpos
operator|=
name|lastpos
operator|,
name|lastpos
operator|+=
name|d
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nalloc
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|nalloc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|merged
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|follows
argument_list|,
name|position_set
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
ifdef|#
directive|ifdef
name|DEBUG
block|{
comment|/* Nonsyntactic #ifdef goo... */
endif|#
directive|endif
switch|switch
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
condition|)
block|{
case|case
name|EMPTY
case|:
comment|/* The empty set is nullable. */
operator|*
name|nullable
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* The firstpos and lastpos of the empty leaf are both empty. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
comment|/* Every element in the firstpos of the argument is in the follow 	   of every element in the lastpos. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
case|case
name|QMARK
case|:
comment|/* A QMARK or STAR node is automatically nullable. */
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
name|PLUS
condition|)
name|nullable
index|[
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CAT
case|:
comment|/* Every element in the firstpos of the second argument is in the 	   follow of every element in the lastpos of the first argument. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|2
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* The firstpos of a CAT node is the firstpos of the first argument, 	   union that of the second argument if the first is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|2
index|]
condition|)
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|firstpos
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos of a CAT node is the lastpos of the second argument, 	   union that of the first argument if the second is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|1
index|]
condition|)
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|pos
index|[
name|j
index|]
operator|=
name|lastpos
index|[
name|j
index|]
expr_stmt|;
name|lastpos
operator|+=
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|nlastpos
expr_stmt|;
comment|/* A CAT node is nullable if both arguments are nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|&&
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
comment|/* The firstpos is the union of the firstpos of each argument. */
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos is the union of the lastpos of each argument. */
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nlastpos
expr_stmt|;
comment|/* An OR node is nullable if either argument is nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|||
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
default|default:
comment|/* Anything else is a nonempty position.  (Note that special 	   constructs like \< are treated as nonempty strings here; 	   an "epsilon closure" effectively makes them nullable later. 	   Backreferences have to get a real position so we can detect 	   transitions on them later.  But they are nullable. */
operator|*
name|nullable
operator|++
operator|=
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|BACKREF
expr_stmt|;
comment|/* This position is in its own firstpos and lastpos. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|1
expr_stmt|;
operator|--
name|firstpos
operator|,
operator|--
name|lastpos
expr_stmt|;
name|firstpos
operator|->
name|index
operator|=
name|lastpos
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|firstpos
operator|->
name|constraint
operator|=
name|lastpos
operator|->
name|constraint
operator|=
name|NO_CONSTRAINT
expr_stmt|;
comment|/* Allocate the follow set for this position. */
name|nalloc
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* ... balance the above nonsyntactic #ifdef goo... */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"node %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|nullable
index|[
operator|-
literal|1
index|]
condition|?
literal|" nullable: yes\n"
else|:
literal|" nullable: no\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" firstpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|firstpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|firstpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n lastpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|lastpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|lastpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each follow set that is the follow set of a real position, replace      it with its epsilon closure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|<
name|NOTCHAR
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|BACKREF
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|>=
name|CSET
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"follows(%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"):"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy
argument_list|(
operator|&
name|d
operator|->
name|follows
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|<
name|merged
operator|.
name|nelem
condition|)
name|REALLOC
argument_list|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|merged
operator|.
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Get the epsilon closure of the firstpos of the regexp.  The result will      be the set of positions of state 0. */
name|merged
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfirstpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|i
control|)
name|insert
argument_list|(
name|firstpos
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Check if any of the positions of state 0 will want newline context. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merged
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|merged
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
comment|/* Build the initial state. */
name|d
operator|->
name|salloc
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|sindex
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|states
argument_list|,
name|dfa_state
argument_list|,
name|d
operator|->
name|salloc
argument_list|)
expr_stmt|;
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|merged
argument_list|,
name|wants_newline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nullable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nfirst
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_firstpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nlast
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_lastpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nalloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|merged
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find, for each character, the transition out of state s of d, and store    it in the appropriate slot of trans.     We divide the positions of s into groups (positions can appear in more    than one group).  Each group is labeled with a set of characters that    every position in the group matches (taking into account, if necessary,    preceding context information of s).  For each group, find the union    of the its elements' follows.  This set is the set of positions of the    new state.  For each character in the group's label, set the transition    on this character to be to a state corresponding to the set's positions,    and its associated backward context information, if necessary.     If we are building a searching matcher, we include the positions of state    0 in every state.     The collection of groups is constructed by building an equivalence-class    partition of the positions of s.     For each position, find the set of characters C that it matches.  Eliminate    any characters from C that fail on grounds of backward context.     Search through the groups, looking for a group whose label L has nonempty    intersection with C.  If L - C is nonempty, create a new group labeled    L - C and having the same positions as the current group, and set L to    the intersection of L and C.  Insert the position in this group, set    C = C - L, and resume scanning.     If after comparing with every group there are characters remaining in C,    create a new group labeled with the characters of C and insert this    position in that group. */
end_comment

begin_function
name|void
name|dfastate
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|trans
parameter_list|)
name|int
name|s
decl_stmt|;
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
name|int
name|trans
index|[]
decl_stmt|;
block|{
name|position_set
name|grps
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* As many as will ever be needed. */
name|charclass
name|labels
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* Labels corresponding to the groups. */
name|int
name|ngrps
init|=
literal|0
decl_stmt|;
comment|/* Number of groups actually used. */
name|position
name|pos
decl_stmt|;
comment|/* Current position being considered. */
name|charclass
name|matches
decl_stmt|;
comment|/* Set of matching characters. */
name|int
name|matchesf
decl_stmt|;
comment|/* True if matches is nonempty. */
name|charclass
name|intersect
decl_stmt|;
comment|/* Intersection with some label set. */
name|int
name|intersectf
decl_stmt|;
comment|/* True if intersect is nonempty. */
name|charclass
name|leftovers
decl_stmt|;
comment|/* Stuff in the label that didn't match. */
name|int
name|leftoversf
decl_stmt|;
comment|/* True if leftovers is nonempty. */
specifier|static
name|charclass
name|letters
decl_stmt|;
comment|/* Set of characters considered letters. */
specifier|static
name|charclass
name|newline
decl_stmt|;
comment|/* Set of characters that aren't newline. */
name|position_set
name|follows
decl_stmt|;
comment|/* Union of the follows of some group. */
name|position_set
name|tmp
decl_stmt|;
comment|/* Temporary space for merging sets. */
name|int
name|state
decl_stmt|;
comment|/* New state. */
name|int
name|wants_newline
decl_stmt|;
comment|/* New state wants to know newline context. */
name|int
name|state_newline
decl_stmt|;
comment|/* New state on a newline transition. */
name|int
name|wants_letter
decl_stmt|;
comment|/* New state wants to know letter context. */
name|int
name|state_letter
decl_stmt|;
comment|/* New state on a letter transition. */
specifier|static
name|int
name|initialized
decl_stmt|;
comment|/* Flag for static initialization. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Initialize the set of letters, if necessary. */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|setbit
argument_list|(
name|i
argument_list|,
name|letters
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
literal|'\n'
argument_list|,
name|newline
argument_list|)
expr_stmt|;
block|}
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|pos
operator|=
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|NOTCHAR
condition|)
name|setbit
argument_list|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
name|CSET
condition|)
name|copyset
argument_list|(
name|d
operator|->
name|charclasses
index|[
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|-
name|CSET
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
else|else
continue|continue;
comment|/* Some characters may need to be eliminated from matches because 	 they fail in the current context. */
if|if
condition|(
name|pos
operator|.
name|constraint
operator|!=
literal|0xFF
condition|)
block|{
if|if
condition|(
operator|!
name|MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|)
condition|)
name|clrbit
argument_list|(
literal|'\n'
argument_list|,
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|newline
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
operator|~
name|letters
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|letters
index|[
name|j
index|]
expr_stmt|;
comment|/* If there are no characters left, there's no point in going on. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
operator|&&
operator|!
name|matches
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
continue|continue;
if|if
condition|(
name|j
operator|==
name|CHARCLASS_INTS
condition|)
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ngrps
condition|;
operator|++
name|j
control|)
block|{
comment|/* If matches contains a single character only, and the current 	     group's label doesn't contain that character, go on to the 	     next group. */
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|NOTCHAR
operator|&&
operator|!
name|tstbit
argument_list|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Check if this group's label has a nonempty intersection with 	     matches. */
name|intersectf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|k
control|)
operator|(
name|intersect
index|[
name|k
index|]
operator|=
name|matches
index|[
name|k
index|]
operator|&
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
operator|)
condition|?
operator|(
name|intersectf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|intersectf
condition|)
continue|continue;
comment|/* It does; now find the set differences both ways. */
name|leftoversf
operator|=
name|matchesf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|k
control|)
block|{
comment|/* Even an optimizing compiler can't know this for sure. */
name|int
name|match
init|=
name|matches
index|[
name|k
index|]
decl_stmt|,
name|label
init|=
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
decl_stmt|;
operator|(
name|leftovers
index|[
name|k
index|]
operator|=
operator|~
name|match
operator|&
name|label
operator|)
condition|?
operator|(
name|leftoversf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
operator|(
name|matches
index|[
name|k
index|]
operator|=
name|match
operator|&
operator|~
name|label
operator|)
condition|?
operator|(
name|matchesf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
block|}
comment|/* If there were leftovers, create a new group labeled with them. */
if|if
condition|(
name|leftoversf
condition|)
block|{
name|copyset
argument_list|(
name|leftovers
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|copyset
argument_list|(
name|intersect
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|grps
index|[
name|j
index|]
argument_list|,
operator|&
name|grps
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
comment|/* Put the position in the current group.  Note that there is no 	     reason to call insert() here. */
name|grps
index|[
name|j
index|]
operator|.
name|elems
index|[
name|grps
index|[
name|j
index|]
operator|.
name|nelem
operator|++
index|]
operator|=
name|pos
expr_stmt|;
comment|/* If every character matching the current position has been 	     accounted for, we're done. */
if|if
condition|(
operator|!
name|matchesf
condition|)
break|break;
block|}
comment|/* If we've passed the last group, and there are still characters 	 unaccounted for, then we'll have to create a new group. */
if|if
condition|(
name|j
operator|==
name|ngrps
condition|)
block|{
name|copyset
argument_list|(
name|matches
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|nelem
operator|=
literal|1
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
block|}
name|MALLOC
argument_list|(
name|follows
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
comment|/* If we are a searching matcher, the default transition is to a state      containing the positions of state 0, otherwise the default transition      is to fail miserably. */
if|if
condition|(
name|d
operator|->
name|searchflag
condition|)
block|{
name|wants_newline
operator|=
literal|0
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PREV_LETTER_DEPENDENT
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
block|}
name|copy
argument_list|(
operator|&
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
name|trans
index|[
name|i
index|]
operator|=
name|state_newline
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|trans
index|[
name|i
index|]
operator|=
name|state_letter
expr_stmt|;
else|else
name|trans
index|[
name|i
index|]
operator|=
name|state
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
block|{
name|follows
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
comment|/* Find the union of the follows of the positions of the group. 	 This is a hideously inefficient loop.  Fix it someday. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|grps
index|[
name|i
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|d
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|k
control|)
name|insert
argument_list|(
name|d
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|k
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* If we are building a searching matcher, throw in the positions 	 of state 0 as well. */
if|if
condition|(
name|d
operator|->
name|searchflag
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
name|insert
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* Find out if the new state will want any context information. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstbit
argument_list|(
literal|'\n'
argument_list|,
name|labels
index|[
name|i
index|]
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|letters
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|CHARCLASS_INTS
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|PREV_LETTER_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
comment|/* Find the state(s) corresponding to the union of the follows. */
name|state
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
comment|/* Set the transitions for each character in the current label. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|INTBITS
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
literal|1
operator|<<
name|k
condition|)
block|{
name|int
name|c
init|=
name|j
operator|*
name|INTBITS
operator|+
name|k
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_newline
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_letter
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|NOTCHAR
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|grps
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|follows
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some routines for manipulating a compiled dfa's transition tables.    Each state may or may not have a transition table; if it does, and it    is a non-accepting state, then d->trans[state] points to its table.    If it is an accepting state then d->fails[state] points to its table.    If it has no table at all, then d->trans[state] is NULL.    TODO: Improve this comment, get rid of the unnecessary redundancy. */
end_comment

begin_function
specifier|static
name|void
name|build_state
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
name|int
name|s
decl_stmt|;
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|int
modifier|*
name|trans
decl_stmt|;
comment|/* The new transition table. */
name|int
name|i
decl_stmt|;
comment|/* Set an upper limit on the number of transition tables that will ever      exist at once.  1024 is arbitrary.  The idea is that the frequently      used transition tables will be quickly rebuilt, whereas the ones that      were only needed once or twice will be cleared away. */
if|if
condition|(
name|d
operator|->
name|trcount
operator|>=
literal|1024
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|trans
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|fails
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|fails
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|d
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|trcount
expr_stmt|;
comment|/* Set up the success bits for this state. */
name|d
operator|->
name|success
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|trans
argument_list|,
name|int
argument_list|,
name|NOTCHAR
argument_list|)
expr_stmt|;
name|dfastate
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|trans
argument_list|)
expr_stmt|;
comment|/* Now go through the new transition table, and make sure that the trans      and fail arrays are allocated large enough to hold a pointer for the      largest state mentioned in the table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|d
operator|->
name|tralloc
condition|)
block|{
name|int
name|oldalloc
init|=
name|d
operator|->
name|tralloc
decl_stmt|;
while|while
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|d
operator|->
name|tralloc
condition|)
name|d
operator|->
name|tralloc
operator|*=
literal|2
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
operator|=
name|d
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|newlines
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldalloc
operator|<
name|d
operator|->
name|tralloc
condition|)
block|{
name|d
operator|->
name|trans
index|[
name|oldalloc
index|]
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|fails
index|[
name|oldalloc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Keep the newline transition in a special place so we can use it as      a sentinel. */
name|d
operator|->
name|newlines
index|[
name|s
index|]
operator|=
name|trans
index|[
literal|'\n'
index|]
expr_stmt|;
name|trans
index|[
literal|'\n'
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ACCEPTING
argument_list|(
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|fails
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
else|else
name|d
operator|->
name|trans
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_state_zero
parameter_list|(
name|d
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|d
operator|->
name|tralloc
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
operator|=
name|d
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|newlines
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|build_state
argument_list|(
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search through a buffer looking for a match to the given struct dfa.    Find the first occurrence of a string matching the regexp in the buffer,    and the shortest possible version thereof.  Return a pointer to the first    character after the match, or NULL if none is found.  Begin points to    the beginning of the buffer, and end points to the first character after    its end.  We store a newline in *end to act as a sentinel, so end had    better point somewhere valid.  Newline is a flag indicating whether to    allow newlines to be in the matching string.  If count is non-    NULL it points to a place we're supposed to increment every time we    see a newline.  Finally, if backref is non-NULL it points to a place    where we're supposed to store a 1 if backreferencing happened and the    match needs to be verified by a backtracking matcher.  Otherwise    we store a 0 in *backref. */
end_comment

begin_function
name|char
modifier|*
name|dfaexec
parameter_list|(
name|d
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|newline
parameter_list|,
name|count
parameter_list|,
name|backref
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|int
modifier|*
name|backref
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|s1
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Current state. */
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Current input character. */
specifier|register
name|int
modifier|*
modifier|*
name|trans
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Copy of d->trans so it can be optimized 				   into a register. */
specifier|static
name|int
name|sbit
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* Table for anding with d->success. */
specifier|static
name|int
name|sbit_init
decl_stmt|;
if|if
condition|(
operator|!
name|sbit_init
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sbit_init
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
name|sbit
index|[
name|i
index|]
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|sbit
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
else|else
name|sbit
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|tralloc
condition|)
name|build_state_zero
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
name|s1
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|begin
expr_stmt|;
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
operator|*
name|end
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The dreaded inner loop. */
if|if
condition|(
operator|(
name|t
operator|=
name|trans
index|[
name|s
index|]
operator|)
operator|!=
literal|0
condition|)
do|do
block|{
name|s1
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|trans
index|[
name|s1
index|]
operator|)
condition|)
goto|goto
name|last_was_s
goto|;
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|t
operator|=
name|trans
index|[
name|s
index|]
operator|)
operator|!=
literal|0
condition|)
do|;
goto|goto
name|last_was_s1
goto|;
name|last_was_s
label|:
name|tmp
operator|=
name|s
operator|,
name|s
operator|=
name|s1
operator|,
name|s1
operator|=
name|tmp
expr_stmt|;
name|last_was_s1
label|:
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|p
operator|<=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|end
operator|&&
name|d
operator|->
name|fails
index|[
name|s
index|]
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|success
index|[
name|s
index|]
operator|&
name|sbit
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
name|backref
condition|)
if|if
condition|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|backref
condition|)
operator|*
name|backref
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|backref
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|p
return|;
block|}
name|s1
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|d
operator|->
name|fails
index|[
name|s
index|]
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* If the previous character was a newline, count it. */
if|if
condition|(
name|count
operator|&&
operator|(
name|char
operator|*
operator|)
name|p
operator|<=
name|end
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|count
expr_stmt|;
comment|/* Check if we've run off the end of the buffer. */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|p
operator|>
name|end
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
name|build_state
argument_list|(
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|newline
condition|)
block|{
name|s
operator|=
name|d
operator|->
name|newlines
index|[
name|s1
index|]
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the components of a dfa that the other routines don't    initialize for themselves. */
end_comment

begin_function
name|void
name|dfainit
parameter_list|(
name|d
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|d
operator|->
name|calloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|charclasses
argument_list|,
name|charclass
argument_list|,
name|d
operator|->
name|calloc
argument_list|)
expr_stmt|;
name|d
operator|->
name|cindex
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|talloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|d
operator|->
name|talloc
argument_list|)
expr_stmt|;
name|d
operator|->
name|tindex
operator|=
name|d
operator|->
name|depth
operator|=
name|d
operator|->
name|nleaves
operator|=
name|d
operator|->
name|nregexps
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|searchflag
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|tralloc
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|musts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse and analyze a single string of the given length. */
end_comment

begin_function
name|void
name|dfacomp
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|d
parameter_list|,
name|searchflag
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
name|int
name|searchflag
decl_stmt|;
block|{
if|if
condition|(
name|case_fold
condition|)
comment|/* dummy folding in service of dfamust() */
block|{
name|char
modifier|*
name|lcopy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lcopy
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lcopy
condition|)
name|dfaerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* This is a kludge. */
name|case_fold
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
name|lcopy
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|lcopy
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|dfainit
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaparse
argument_list|(
name|lcopy
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lcopy
argument_list|)
expr_stmt|;
name|dfamust
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|cindex
operator|=
name|d
operator|->
name|tindex
operator|=
name|d
operator|->
name|depth
operator|=
name|d
operator|->
name|nleaves
operator|=
name|d
operator|->
name|nregexps
operator|=
literal|0
expr_stmt|;
name|case_fold
operator|=
literal|1
expr_stmt|;
name|dfaparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dfaanalyze
argument_list|(
name|d
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dfainit
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dfamust
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaanalyze
argument_list|(
name|d
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the storage held by the components of a dfa. */
end_comment

begin_function
name|void
name|dfafree
parameter_list|(
name|d
parameter_list|)
name|struct
name|dfa
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dfamust
modifier|*
name|dm
decl_stmt|,
modifier|*
name|ndm
decl_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|charclasses
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|tokens
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|states
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|trans
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|fails
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|realtrans
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|realtrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fails
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|newlines
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|newlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|success
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|success
argument_list|)
expr_stmt|;
for|for
control|(
name|dm
operator|=
name|d
operator|->
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|ndm
control|)
block|{
name|ndm
operator|=
name|dm
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dm
operator|->
name|must
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|dm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Having found the postfix representation of the regular expression,    try to find a long sequence of characters that must appear in any line    containing the r.e.    Finding a "longest" sequence is beyond the scope here;    we take an easy way out and hope for the best.    (Take "(ab|a)b"--please.)     We do a bottom-up calculation of sequences of characters that must appear    in matches of r.e.'s represented by trees rooted at the nodes of the postfix    representation: 	sequences that must appear at the left of the match ("left") 	sequences that must appear at the right of the match ("right") 	lists of sequences that must appear somewhere in the match ("in") 	sequences that must constitute the match ("is")     When we get to the root of the tree, we use one of the longest of its    calculated "in" sequences as our answer.  The sequence we find is returned in    d->must (where "d" is the single argument passed to "dfamust");    the length of the sequence is returned in d->mustn.     The sequences calculated for the various types of node (in pseudo ANSI c)    are shown below.  "p" is the operand of unary operators (and the left-hand    operand of binary operators); "q" is the right-hand operand of binary    operators.     "ZERO" means "a zero-length sequence" below.  	Type	left		right		is		in 	----	----		-----		--		-- 	char c	# c		# c		# c		# c 	 	CSET	ZERO		ZERO		ZERO		ZERO 	 	STAR	ZERO		ZERO		ZERO		ZERO  	QMARK	ZERO		ZERO		ZERO		ZERO  	PLUS	p->left		p->right	ZERO		p->in  	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO&&	p->in plus 		p->left :	q->right :	q->is!=ZERO) ?	q->in plus 		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left 						ZERO 					 	OR	longest common	longest common	(do p->is and	substrings common to 		leading		trailing	q->is have same	p->in and q->in 		(sub)sequence	(sub)sequence	length and	 		of p->left	of p->right	content) ?	 		and q->left	and q->right	p->is : NULL	     If there's anything else we recognize in the tree, all four sequences get set    to zero-length sequences.  If there's something we don't recognize in the tree,    we just return a zero-length sequence.     Break ties in favor of infrequent letters (choosing 'zzz' in preference to    'aaa')?     And. . .is it here or someplace that we might ponder "optimizations" such as 	egrep 'psi|epsilon'	->	egrep 'psi' 	egrep 'pepsi|epsilon'	->	egrep 'epsi' 					(Yes, we now find "epsi" as a "string 					that must occur", but we might also 					simplify the *entire* r.e. being sought) 	grep '[c]'		->	grep 'c' 	grep '(ab|a)b'		->	grep 'ab' 	grep 'ab*'		->	grep 'a' 	grep 'a*b'		->	grep 'b'     There are several issues:     Is optimization easy (enough)?     Does optimization actually accomplish anything,    or is the automaton you get from "psi|epsilon" (for example)    the same as the one you get from "psi" (for example)?       Are optimizable r.e.'s likely to be used in real-life situations    (something like 'ab*' is probably unlikely; something like is    'psi|epsilon' is likelier)? */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|icatalloc
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|newsize
operator|=
operator|(
name|new
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|oldsize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
return|return
name|old
return|;
else|else
name|oldsize
operator|=
name|strlen
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|old
argument_list|,
name|oldsize
operator|+
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
name|new
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|oldsize
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|icpyalloc
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
name|icatalloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|istrstr
parameter_list|(
name|lookin
parameter_list|,
name|lookfor
parameter_list|)
name|char
modifier|*
name|lookin
decl_stmt|;
name|char
modifier|*
name|lookfor
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|lookfor
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|lookin
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|lookfor
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifree
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freelist
parameter_list|(
name|cpp
parameter_list|)
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|enlist
parameter_list|(
name|cpp
parameter_list|,
name|new
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|icpyalloc
argument_list|(
name|new
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Is there already something in the list that's new (or longer)? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|istrstr
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|cpp
return|;
block|}
comment|/* Eliminate any obsoleted strings. */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cpp
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|istrstr
argument_list|(
name|new
argument_list|,
name|cpp
index|[
name|j
index|]
argument_list|)
operator|==
name|NULL
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|cpp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|==
name|j
condition|)
break|break;
name|cpp
index|[
name|j
index|]
operator|=
name|cpp
index|[
name|i
index|]
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Add the new string. */
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpp
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
name|cpp
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|cpp
return|;
block|}
end_function

begin_comment
comment|/* Given pointers to two strings, return a pointer to an allocated    list of their distinct common substrings. Return NULL if something    seems wild. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|comsubs
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|char
modifier|*
name|lcp
decl_stmt|;
name|char
modifier|*
name|rcp
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lcp
operator|=
name|left
init|;
operator|*
name|lcp
operator|!=
literal|'\0'
condition|;
operator|++
name|lcp
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|rcp
operator|=
name|index
argument_list|(
name|right
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
while|while
condition|(
name|rcp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lcp
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lcp
index|[
name|i
index|]
operator|==
name|rcp
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
continue|continue;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|len
operator|=
name|i
expr_stmt|;
name|rcp
operator|=
name|index
argument_list|(
name|rcp
operator|+
literal|1
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cpp
operator|=
name|enlist
argument_list|(
name|cpp
argument_list|,
name|lcp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|cpp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|addlists
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|||
name|new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|new
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|old
operator|=
name|enlist
argument_list|(
name|old
argument_list|,
name|new
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of substrings, return a new list giving substrings    common to both. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|inboth
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|char
modifier|*
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
modifier|*
name|right
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|both
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp
decl_stmt|;
name|int
name|lnum
decl_stmt|,
name|rnum
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|both
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|left
index|[
name|lnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|lnum
control|)
block|{
for|for
control|(
name|rnum
operator|=
literal|0
init|;
name|right
index|[
name|rnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|rnum
control|)
block|{
name|temp
operator|=
name|comsubs
argument_list|(
name|left
index|[
name|lnum
index|]
argument_list|,
name|right
index|[
name|rnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|both
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|both
operator|=
name|addlists
argument_list|(
name|both
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
block|}
return|return
name|both
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
name|char
modifier|*
name|is
decl_stmt|;
block|}
name|must
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|resetmust
parameter_list|(
name|mp
parameter_list|)
name|must
modifier|*
name|mp
decl_stmt|;
block|{
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|freelist
argument_list|(
name|mp
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfamust
parameter_list|(
name|dfa
parameter_list|)
name|struct
name|dfa
modifier|*
name|dfa
decl_stmt|;
block|{
name|must
modifier|*
name|musts
decl_stmt|;
name|must
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|ri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|exact
decl_stmt|;
name|token
name|t
decl_stmt|;
specifier|static
name|must
name|must0
decl_stmt|;
name|struct
name|dfamust
modifier|*
name|dm
decl_stmt|;
specifier|static
name|char
name|empty_string
index|[]
init|=
literal|""
decl_stmt|;
name|result
operator|=
name|empty_string
expr_stmt|;
name|exact
operator|=
literal|0
expr_stmt|;
name|musts
operator|=
operator|(
name|must
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|dfa
operator|->
name|tindex
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|musts
argument_list|)
expr_stmt|;
if|if
condition|(
name|musts
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|mp
index|[
name|i
index|]
operator|=
name|must0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|mp
index|[
name|i
index|]
operator|.
name|left
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|right
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|in
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dfamust:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|ri
control|)
block|{
switch|switch
condition|(
name|t
operator|=
name|dfa
operator|->
name|tokens
index|[
name|ri
index|]
condition|)
block|{
case|case
name|LPAREN
case|:
case|case
name|RPAREN
case|:
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
case|case
name|EMPTY
case|:
case|case
name|BEGLINE
case|:
case|case
name|ENDLINE
case|:
case|case
name|BEGWORD
case|:
case|case
name|ENDWORD
case|:
case|case
name|LIMWORD
case|:
case|case
name|NOTLIMWORD
case|:
case|case
name|BACKREF
case|:
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|QMARK
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
name|must
modifier|*
name|lmp
decl_stmt|;
name|must
modifier|*
name|rmp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|ln
decl_stmt|,
name|rn
decl_stmt|,
name|n
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* Guaranteed to be.  Unlikely, but. . . */
if|if
condition|(
name|strcmp
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
operator|!=
literal|0
condition|)
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Left side--easy */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|==
name|rmp
operator|->
name|left
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Right side */
name|ln
operator|=
name|strlen
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|rn
operator|=
name|strlen
argument_list|(
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|n
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|rn
condition|)
name|n
operator|=
name|rn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lmp
operator|->
name|right
index|[
name|ln
operator|-
name|i
operator|-
literal|1
index|]
operator|!=
name|rmp
operator|->
name|right
index|[
name|rn
operator|-
name|i
operator|-
literal|1
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
name|lmp
operator|->
name|right
index|[
operator|(
name|ln
operator|-
name|i
operator|)
operator|+
name|j
index|]
expr_stmt|;
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|=
name|inboth
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|freelist
argument_list|(
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|in
operator|=
name|new
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|END
case|:
if|if
condition|(
name|mp
operator|!=
operator|&
name|musts
index|[
literal|1
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strlen
argument_list|(
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
argument_list|)
operator|>
name|strlen
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|=
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|result
argument_list|,
name|musts
index|[
literal|0
index|]
operator|.
name|is
argument_list|)
operator|==
literal|0
condition|)
name|exact
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAT
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
name|must
modifier|*
name|lmp
decl_stmt|;
name|must
modifier|*
name|rmp
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* In.  Everything in left, plus everything in 	       right, plus catenation of 	       left's right and right's left. */
name|lmp
operator|->
name|in
operator|=
name|addlists
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|left
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|icpyalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|tp
operator|=
name|icatalloc
argument_list|(
name|tp
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|lmp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|tp
argument_list|,
name|strlen
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Left-hand */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|left
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|left
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|left
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Right-hand */
if|if
condition|(
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lmp
operator|->
name|right
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|,
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|right
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* Guaranteed to be */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|is
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
else|else
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|t
operator|<
name|END
condition|)
block|{
comment|/* "cannot happen" */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|'\0'
condition|)
block|{
comment|/* not on *my* shift */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|>=
name|CSET
condition|)
block|{
comment|/* easy enough */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* plain character */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|mp
operator|->
name|in
argument_list|,
name|mp
operator|->
name|is
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" node: %d:"
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|ri
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  in:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|->
name|in
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" \"%s\""
argument_list|,
name|mp
operator|->
name|in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  is: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|is
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  left: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|left
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  right: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|right
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|mp
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|strlen
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|dm
operator|=
operator|(
expr|struct
name|dfamust
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dfamust
argument_list|)
argument_list|)
expr_stmt|;
name|dm
operator|->
name|exact
operator|=
name|exact
expr_stmt|;
name|dm
operator|->
name|must
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|result
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dm
operator|->
name|must
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|dm
operator|->
name|next
operator|=
name|dfa
operator|->
name|musts
expr_stmt|;
name|dfa
operator|->
name|musts
operator|=
name|dm
expr_stmt|;
block|}
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|freelist
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|is
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

