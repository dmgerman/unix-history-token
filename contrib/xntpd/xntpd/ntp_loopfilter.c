begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntp_loopfilter.c - implements the NTP loop filter algorithm  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || PPSCLK || PPSPPS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/clkdefs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSCLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSCLK || PPSPPS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSPPS */
end_comment

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL_PLL
end_ifdef

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NTP_SYSCALLS_LIBC
end_ifndef

begin_define
define|#
directive|define
name|ntp_gettime
parameter_list|(
name|t
parameter_list|)
value|syscall(SYS_ntp_gettime, (t))
end_define

begin_define
define|#
directive|define
name|ntp_adjtime
parameter_list|(
name|t
parameter_list|)
value|syscall(SYS_ntp_adjtime, (t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * The loop filter is implemented in slavish adherence to the  * specification (Section 5), except that for consistency we  * mostly carry the quantities in the same units as appendix G.  *  * Note that the long values below are the fractional portion of  * a long fixed-point value.  This limits these values to +-0.5  * seconds.  When adjustments are capped inside this range (see  * CLOCK_MAX_{I,F}) both the clock_adjust and the compliance  * registers should be fine. (When the compliance is above 16, it  * will at most accumulate 2**CLOCK_MULT times the maximum offset,  * which means it fits in a s_fp.)  *  * The skew compensation is a special case. In version 2, it was  * kept in ms/4s (i.e., CLOCK_FREQ was 10). In version 3 (Section 5)  * it seems to be 2**-16ms/4s in a s_fp for a maximum of +-125ppm  * (stated maximum 100ppm). Since this seems about to change to a  * larger range, it will be kept in units of 2**-20 (CLOCK_DSCALE)  * in an s_fp (mainly because that's nearly the same as parts per  * million). Note that this is ``seconds per second'', whereas a  * clock adjustment is a 32-bit fraction of a second to be applied  * every 2**CLOCK_ADJ seconds; to find it, shift the drift right by  * (CLOCK_DSCALE-16-CLOCK_ADJ). When updating the drift, on the other  * hand, the CLOCK_FREQ factor from the spec assumes the value to be  * in ``seconds per 4 seconds''; to get our units, CLOCK_ADJ must be  * added to the shift.  */
end_comment

begin_comment
comment|/*  * Macro to compute log2(). We don't want to to this very often, but  * needs what must.  */
end_comment

begin_define
define|#
directive|define
name|LOG2
parameter_list|(
name|r
parameter_list|,
name|t
parameter_list|)
define|\
value|do {			\ 		LONG x = t;	\ 		r = 0;		\ 		while(x>> 1)	\ 		r++;		\ 	}
end_define

begin_define
define|#
directive|define
name|RSH_DRIFT_TO_FRAC
value|(CLOCK_DSCALE - 16)
end_define

begin_define
define|#
directive|define
name|RSH_DRIFT_TO_ADJ
value|(RSH_DRIFT_TO_FRAC - CLOCK_ADJ)
end_define

begin_define
define|#
directive|define
name|RSH_FRAC_TO_FREQ
value|(CLOCK_FREQ + CLOCK_ADJ - RSH_DRIFT_TO_FRAC)
end_define

begin_define
define|#
directive|define
name|PPS_MAXAGE
value|120
end_define

begin_comment
comment|/* pps signal timeout (s) */
end_comment

begin_define
define|#
directive|define
name|PPS_MAXUPDATE
value|600
end_define

begin_comment
comment|/* pps update timeout (s) */
end_comment

begin_comment
comment|/*  * Program variables  */
end_comment

begin_decl_stmt
name|l_fp
name|last_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last adjustment done */
end_comment

begin_decl_stmt
specifier|static
name|LONG
name|clock_adjust
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock adjust (fraction only) */
end_comment

begin_decl_stmt
name|s_fp
name|drift_comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* drift compensation register */
end_comment

begin_decl_stmt
specifier|static
name|s_fp
name|max_comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* drift limit imposed by max host clock slew */
end_comment

begin_decl_stmt
name|int
name|time_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of time constant (0 .. 4) */
end_comment

begin_decl_stmt
specifier|static
name|U_LONG
name|tcadj_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last time-constant adjust time */
end_comment

begin_decl_stmt
name|U_LONG
name|watchdog_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* watchdog timer, in seconds */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_adjustment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if waiting for first adjustment */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tc_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time-constant hold counter */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|pps_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filtered pps offset */
end_comment

begin_decl_stmt
specifier|static
name|u_fp
name|pps_dispersion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps dispersion */
end_comment

begin_decl_stmt
specifier|static
name|U_LONG
name|pps_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last pps sample time */
end_comment

begin_decl_stmt
name|int
name|pps_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if working pps signal */
end_comment

begin_decl_stmt
name|int
name|pll_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if working kernel pll */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|pps_delay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps tuning offset */
end_comment

begin_decl_stmt
name|U_LONG
name|pps_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last pps update time */
end_comment

begin_decl_stmt
name|int
name|fdpps
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_comment
comment|/*  * This module has support for a 1-pps signal to fine-tune the local  * clock. The signal is optional; when present and operating within  * given tolerances in frequency and jitter, it is used to discipline  * the local clock. In order for this to work, the local clock must be  * set to within +-500 ms by another means, such as a radio clock or  * NTP itself. The 1-pps signal is connected via a serial port and  * gadget box consisting of a one-shot and EIA level-converter. When  * operated at 38.4 kbps with a SPARCstation IPC, this arrangement has a  * worst-case jitter less than 26 us. The pps delay configuration  * declaration can be used to compensate for miscellaneous uart and  * os delays. Allow about 247 us for uart delays at 38400 bps and  * -1 ms for SunOS streams nonsense.  */
end_comment

begin_comment
comment|/*  * A really messy way to map an integer baud rate to the system baud rate.  * There should be a better way.  */
end_comment

begin_define
define|#
directive|define
name|SYS_BAUD
parameter_list|(
name|i
parameter_list|)
define|\
value|( i == 38400 ? B38400 : \ 	( i == 19200 ? B19200 : \ 	( i == 9600 ? B9600 : \ 	( i == 4800 ? B4800 : \ 	( i == 2400 ? B2400 : \ 	( i == 1200 ? B1200 : \ 	( i == 600 ? B600 : \ 	( i == 300 ? B300 : 0 ))))))))
end_define

begin_define
define|#
directive|define
name|PPS_BAUD
value|B38400
end_define

begin_comment
comment|/* default serial port speed */
end_comment

begin_expr_stmt
name|timecode
operator|*
operator|/
define|#
directive|define
name|PPS_DEV
value|"/dev/pps"
comment|/* pps port */
define|#
directive|define
name|PPS_FAC
value|3
comment|/* pps shift (log2 trimmed samples) */
define|#
directive|define
name|PPS_TRIM
value|6
comment|/* samples trimmed from median filter */
define|#
directive|define
name|NPPS
value|((1<< PPS_FAC) + 2 * PPS_TRIM)
comment|/* pps filter size */
define|#
directive|define
name|PPS_XCPT
value|"\377"
comment|/* intercept character */
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
specifier|static
expr|struct
name|refclockio
name|io
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* given to the I/O handler */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_baud
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* baud rate of PPS line */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSCLK */
end_comment

begin_decl_stmt
specifier|static
name|U_LONG
name|nsamples
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pps samples collected */
end_comment

begin_decl_stmt
specifier|static
name|LONG
name|samples
index|[
name|NPPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* median filter for pps samples */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || PPSCLK || PPSPPS */
end_comment

begin_comment
comment|/*  * Imported from the ntp_proto module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_stratum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_fp
name|sys_rootdelay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_fp
name|sys_rootdispersion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_io.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|interface
modifier|*
name|loopback_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Imported from timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* like it says, in seconds */
end_comment

begin_comment
comment|/*  * sys_poll and sys_refskew are set here  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_poll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2 of system poll interval */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|sys_leap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system leap bits */
end_comment

begin_decl_stmt
specifier|extern
name|l_fp
name|sys_refskew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated skew since last update */
end_comment

begin_decl_stmt
specifier|extern
name|u_fp
name|sys_maxd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max dispersion of survivor list */
end_comment

begin_comment
comment|/*  * Imported from leap module  */
end_comment

begin_decl_stmt
specifier|extern
name|u_char
name|leapbits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sanitized leap bits */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_decl_stmt
name|int
name|pps_sample
name|P
argument_list|(
operator|(
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|pps_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSCLK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || PPSCLK || PPSPPS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
end_if

begin_define
define|#
directive|define
name|MOD_BITS
value|(MOD_OFFSET | MOD_MAXERROR | MOD_ESTERROR | \     MOD_STATUS | MOD_TIMECONST)
end_define

begin_decl_stmt
specifier|extern
name|int
name|sigvec
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|sigvec
operator|*
operator|,
expr|struct
name|sigvec
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|syscall
name|P
argument_list|(
operator|(
name|int
operator|,
name|void
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pll_trap
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pll_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status bits for kernel pll */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigvec
name|sigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current sigvec status */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigvec
name|newsigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new sigvec status */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_comment
comment|/*  * init_loopfilter - initialize loop filter data  */
end_comment

begin_function
name|void
name|init_loopfilter
parameter_list|()
block|{
specifier|extern
name|U_LONG
name|tsf_maxslew
decl_stmt|;
name|U_LONG
name|tsf_limit
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
name|int
name|fd232
decl_stmt|;
endif|#
directive|endif
comment|/* PPSCLK */
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|drift_comp
operator|=
literal|0
expr_stmt|;
name|time_constant
operator|=
literal|0
expr_stmt|;
name|tcadj_time
operator|=
literal|0
expr_stmt|;
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
name|tc_counter
operator|=
literal|0
expr_stmt|;
name|last_offset
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|last_offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|first_adjustment
operator|=
literal|1
expr_stmt|;
comment|/*  * Limit for drift_comp, minimum of two values. The first is to avoid  * signed overflow, the second to keep within 75% of the maximum  * adjustment possible in adj_systime().  */
name|max_comp
operator|=
literal|0x7fff0000
expr_stmt|;
name|tsf_limit
operator|=
operator|(
operator|(
name|tsf_maxslew
operator|>>
literal|1
operator|)
operator|+
operator|(
name|tsf_maxslew
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|max_comp
operator|>>
name|RSH_DRIFT_TO_ADJ
operator|)
operator|>
name|tsf_limit
condition|)
name|max_comp
operator|=
name|tsf_limit
operator|<<
name|RSH_DRIFT_TO_ADJ
expr_stmt|;
name|pps_control
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
name|pps_baud
operator|=
name|PPS_BAUD
expr_stmt|;
endif|#
directive|endif
comment|/* PPSCLK */
name|pps_delay
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|pps_delay
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|pps_time
operator|=
name|pps_update
operator|=
literal|0
expr_stmt|;
name|nsamples
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
comment|/* 	 * Open pps serial port. We don't care if the serial port comes 	 * up; if not, we  just use the timecode. Therefore, if anything 	 * goes wrong, just reclaim the resources and continue. 	 */
name|fd232
operator|=
name|open
argument_list|(
name|PPS_DEV
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: open of %s: %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HPUXGADGET
argument_list|)
comment|/* dedicated to Ken Stone */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
comment|/* 	 * System V serial line parameters (termio interface) 	 */
name|PPSCLK
name|SUPPORT
name|NOT
name|AVAILABLE
name|IN
name|TERMIO
name|INTERFACE
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 	 * POSIX serial line parameters (termios interface) 	 * 	 * The PPSCLK option provides timestamping at the driver level.  	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the tty_clk streams module and SunOS 4.1.1 or 	 * later. 	 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: tcgetattr(%s): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
operator||
name|ICRNL
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|PPS_BAUD
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
name|ICANON
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: tcsetattr(%s): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: tcflush(%s): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
while|while
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"clk"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: ioctl(%s, I_PUSH, clk): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|CLK_SETSTR
argument_list|,
name|PPS_XCPT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: ioctl(%s, CLK_SETSTR, PPS_XCPT): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
endif|#
directive|endif
comment|/* STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 * 	 * The PPSCLK option provides timestamping at the driver level.  	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the tty_clk line discipline and 4.3bsd or later. 	 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
name|int
name|ldisc
init|=
name|CLKLDISC
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: ioctl(%s, TIOCGETP): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|PPS_BAUD
expr_stmt|;
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: ioctl(%s, TIOCSETP): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loopfilter: ioctl(%s, TIOCSETD): %m"
argument_list|,
name|PPS_DEV
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
endif|#
directive|endif
comment|/* HPUXGADGET */
name|fdpps
operator|=
name|fd232
expr_stmt|;
comment|/* 	 * Insert in device list. 	 */
name|io
operator|.
name|clock_recv
operator|=
name|pps_receive
expr_stmt|;
name|io
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|io
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|io
operator|.
name|fd
operator|=
name|fdpps
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HPUXGADGET
argument_list|)
if|if
condition|(
operator|!
name|io_addclock_simple
argument_list|(
operator|&
name|io
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|io
argument_list|)
condition|)
endif|#
directive|endif
comment|/* HPUXGADGET */
goto|goto
name|screwed
goto|;
return|return;
comment|/* 	 * Something broke. Reclaim resources. 	 */
name|screwed
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdpps
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* PPSCLK */
endif|#
directive|endif
comment|/* PPS || PPSCLK || PPSPPS */
block|}
end_function

begin_comment
comment|/*  * local_clock - the NTP logical clock loop filter.  Returns 1 if the  *		 clock was stepped, 0 if it was slewed and -1 if it is  *		 hopeless.  */
end_comment

begin_function
name|int
name|local_clock
parameter_list|(
name|fp_offset
parameter_list|,
name|peer
parameter_list|)
name|l_fp
modifier|*
name|fp_offset
decl_stmt|;
comment|/* best offset estimate */
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* from peer - for messages */
block|{
specifier|register
name|LONG
name|offset
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp_uf
decl_stmt|;
specifier|register
name|LONG
name|tmp
decl_stmt|;
name|int
name|isneg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|struct
name|timex
name|ntv
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"local_clock(%s, %s)\n"
argument_list|,
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peer
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Take the absolute value of the offset 	 */
name|tmp_ui
operator|=
name|fp_offset
operator|->
name|l_ui
expr_stmt|;
name|tmp_uf
operator|=
name|fp_offset
operator|->
name|l_uf
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
condition|)
block|{
name|M_NEG
argument_list|(
name|tmp_ui
argument_list|,
name|tmp_uf
argument_list|)
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the clock is way off, don't tempt fate by correcting it. 	 */
if|if
condition|(
name|tmp_ui
operator|>=
name|CLOCK_WAYTOOBIG
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Clock appears to be %u seconds %s, something may be wrong"
argument_list|,
name|tmp_ui
argument_list|,
name|isneg
operator|>
literal|0
condition|?
literal|"fast"
else|:
literal|"slow"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BIGTIMESTEP
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* BIGTIMESTEP */
block|}
comment|/* 	 * Save this offset for later perusal 	 */
name|last_offset
operator|=
operator|*
name|fp_offset
expr_stmt|;
comment|/* 	 * If the magnitude of the offset is greater than CLOCK.MAX, 	 * step the time and reset the registers. 	 */
if|if
condition|(
name|tmp_ui
operator|>
name|CLOCK_MAX_I
operator|||
operator|(
name|tmp_ui
operator|==
name|CLOCK_MAX_I
operator|&&
operator|(
name|U_LONG
operator|)
name|tmp_uf
operator|>=
operator|(
name|U_LONG
operator|)
name|CLOCK_MAX_F
operator|)
condition|)
block|{
if|if
condition|(
name|watchdog_timer
operator|<
name|CLOCK_MINSTEP
condition|)
block|{
comment|/* Mustn't step yet, pretend we adjusted. */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"clock correction %s too large (ignored)\n"
argument_list|,
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"clock reset (%s) %s\n"
argument_list|,
ifdef|#
directive|ifdef
name|SLEWALWAYS
literal|"slew"
argument_list|,
else|#
directive|else
literal|"step"
argument_list|,
endif|#
directive|endif
name|lfptoa
argument_list|(
name|fp_offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|step_systime
argument_list|(
name|fp_offset
argument_list|)
expr_stmt|;
name|clock_adjust
operator|=
literal|0
expr_stmt|;
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
name|first_adjustment
operator|=
literal|1
expr_stmt|;
name|pps_update
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Here we've got an offset small enough to slew.  Note that 	 * since the offset is small we don't have to carry the damned 	 * high order longword in our calculations. 	 * 	 * The time constant and sample interval are approximated with 	 * shifts, as in Section 5 of the v3 spec. The spec procedure 	 * looks strange, as an interval of 64 to 127 seconds seems to 	 * cause multiplication with 128 (and so on). This code lowers 	 * the multiplier by one bit. 	 * 	 * The time constant update goes after adjust and skew updates, 	 * as in appendix G. 	 */
comment|/* 	 * If pps samples are valid, update offset, root delay and 	 * root dispersion. Also, set the system stratum to 1, even if 	 * the source of approximate time runs at a higher stratum. This 	 * may be a dramatic surprise to high-stratum clients, since all 	 * of a sudden this server looks like a stratum-1 clock. 	 */
if|if
condition|(
name|pps_control
condition|)
block|{
name|last_offset
operator|=
name|pps_offset
expr_stmt|;
name|sys_maxd
operator|=
name|pps_dispersion
expr_stmt|;
name|sys_stratum
operator|=
literal|1
expr_stmt|;
name|sys_rootdelay
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|sys_rootdispersion
operator|=
name|offset
operator|+
name|pps_dispersion
expr_stmt|;
block|}
name|offset
operator|=
name|last_offset
operator|.
name|l_f
expr_stmt|;
comment|/* 	 * The pll_control is active when the phase-lock code is 	 * implemented in the kernel, which at present is only in the 	 * (modified) SunOS 4.1.x, Ultrix 4.3 and OSF/1 kernels. In the 	 * case of the DECstation 5000/240 and Alpha AXP, additional 	 * kernal modifications provide a true microsecond clock. We 	 * know the scaling of the frequency variable (s_fp) is the 	 * same as the kernel variable (1<< SHIFT_USEC = 16). 	 * 	 * For kernels with the PPS discipline, the current offset and 	 * dispersion are set from kernel variables to maintain 	 * beauteous displays, but don't do much of anything. 	 * 	 * In the case of stock kernels the phase-lock loop is 	 * implemented the hard way and the clock_adjust and drift_comp 	 * computed as required. 	 */
if|if
condition|(
name|pll_control
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ntv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ntv
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|modes
operator|=
name|MOD_BITS
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
name|TSFTOTVU
argument_list|(
name|offset
argument_list|,
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TSFTOTVU
argument_list|(
operator|-
name|offset
argument_list|,
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|offset
operator|=
operator|-
name|ntv
operator|.
name|offset
expr_stmt|;
block|}
name|TSFTOTVU
argument_list|(
name|sys_rootdispersion
operator|+
name|sys_rootdelay
operator|/
literal|2
argument_list|,
name|ntv
operator|.
name|maxerror
argument_list|)
expr_stmt|;
name|TSFTOTVU
argument_list|(
name|sys_rootdispersion
argument_list|,
name|ntv
operator|.
name|esterror
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|pll_status
expr_stmt|;
if|if
condition|(
name|pps_update
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_PPSTIME
expr_stmt|;
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_ADDSECOND
operator|&&
name|sys_leap
operator|&
name|LEAP_DELSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_UNSYNC
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_ADDSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_INS
expr_stmt|;
elseif|else
if|if
condition|(
name|sys_leap
operator|&
name|LEAP_DELSECOND
condition|)
name|ntv
operator|.
name|status
operator||=
name|STA_DEL
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|time_constant
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
name|drift_comp
operator|=
name|ntv
operator|.
name|freq
expr_stmt|;
if|if
condition|(
name|ntv
operator|.
name|status
operator|&
name|STA_PPSTIME
operator|&&
name|ntv
operator|.
name|status
operator|&
name|STA_PPSSIGNAL
operator|&&
name|ntv
operator|.
name|shift
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|offset
operator|>=
literal|0
condition|)
block|{
name|TVUTOTSF
argument_list|(
name|ntv
operator|.
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TVUTOTSF
argument_list|(
operator|-
name|ntv
operator|.
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|pps_offset
operator|.
name|l_i
operator|=
name|pps_offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|M_ADDF
argument_list|(
name|pps_offset
operator|.
name|l_i
argument_list|,
name|pps_offset
operator|.
name|l_f
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|ntv
operator|.
name|jitter
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pps_dispersion
operator|=
operator|(
name|tmp
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|pps_time
operator|=
name|current_time
expr_stmt|;
name|record_peer_stats
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|,
operator|&
name|pps_offset
argument_list|,
literal|0
argument_list|,
name|pps_dispersion
argument_list|)
expr_stmt|;
block|}
else|else
name|pps_time
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|clock_adjust
operator|=
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|>>
name|time_constant
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clock_adjust
operator|=
name|offset
operator|>>
name|time_constant
expr_stmt|;
block|}
comment|/* 		 * Calculate the new frequency error. The factor given 		 * in the spec gives the adjustment per 2**CLOCK_ADJ 		 * seconds, but we want it as a (scaled) pure ratio, so 		 * we include that factor now and remove it later. 		 */
if|if
condition|(
name|first_adjustment
condition|)
block|{
name|first_adjustment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|peer
operator|->
name|maxpoll
expr_stmt|;
name|tmp_uf
operator|=
name|watchdog_timer
expr_stmt|;
if|if
condition|(
name|tmp_uf
operator|==
literal|0
condition|)
name|tmp_uf
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|tmp_uf
operator|<
operator|(
literal|1
operator|<<
name|peer
operator|->
name|maxpoll
operator|)
condition|)
block|{
name|tmp
operator|--
expr_stmt|;
name|tmp_uf
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* 			 * We apply the frequency scaling at the same 			 * time as the sample interval; this ensures a 			 * safe right-shift. (as long as it keeps below 			 * 31 bits, which current parameters should 			 * ensure. 			 */
name|tmp
operator|=
operator|(
name|RSH_FRAC_TO_FREQ
operator|-
name|tmp
operator|)
operator|+
name|time_constant
operator|+
name|time_constant
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|>>
name|tmp
operator|)
expr_stmt|;
else|else
name|tmp
operator|=
name|offset
operator|>>
name|tmp
expr_stmt|;
name|drift_comp
operator|+=
name|tmp
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|>
name|max_comp
condition|)
name|drift_comp
operator|=
name|max_comp
expr_stmt|;
elseif|else
if|if
condition|(
name|drift_comp
operator|<
operator|-
name|max_comp
condition|)
name|drift_comp
operator|=
operator|-
name|max_comp
expr_stmt|;
block|}
block|}
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Determine when to adjust the time constant and poll interval. 	 */
if|if
condition|(
name|pps_control
condition|)
name|time_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|current_time
operator|-
name|tcadj_time
operator|>=
operator|(
literal|1
operator|<<
name|sys_poll
operator|)
operator|&&
operator|!
name|pps_control
condition|)
block|{
name|tcadj_time
operator|=
name|current_time
expr_stmt|;
name|tmp
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|tmp
operator|=
operator|-
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|>>
operator|(
literal|16
operator|+
name|CLOCK_WEIGHTTC
operator|-
name|time_constant
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|sys_maxd
condition|)
block|{
name|tc_counter
operator|=
literal|0
expr_stmt|;
name|time_constant
operator|--
expr_stmt|;
block|}
else|else
block|{
name|tc_counter
operator|++
expr_stmt|;
if|if
condition|(
name|tc_counter
operator|>
name|CLOCK_HOLDTC
condition|)
block|{
name|tc_counter
operator|=
literal|0
expr_stmt|;
name|time_constant
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|time_constant
operator|<
call|(
name|int
call|)
argument_list|(
name|peer
operator|->
name|minpoll
operator|-
name|NTP_MINPOLL
argument_list|)
condition|)
name|time_constant
operator|=
name|peer
operator|->
name|minpoll
operator|-
name|NTP_MINPOLL
expr_stmt|;
if|if
condition|(
name|time_constant
operator|>
call|(
name|int
call|)
argument_list|(
name|peer
operator|->
name|maxpoll
operator|-
name|NTP_MINPOLL
argument_list|)
condition|)
name|time_constant
operator|=
name|peer
operator|->
name|maxpoll
operator|-
name|NTP_MINPOLL
expr_stmt|;
block|}
name|sys_poll
operator|=
call|(
name|u_char
call|)
argument_list|(
name|NTP_MINPOLL
operator|+
name|time_constant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"adj %s, drft %s, tau %3i\n"
argument_list|,
name|mfptoa
argument_list|(
operator|(
name|clock_adjust
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|,
name|clock_adjust
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|drift_comp
argument_list|,
literal|6
argument_list|)
argument_list|,
name|time_constant
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
operator|(
name|void
operator|)
name|record_loop_stats
argument_list|(
operator|&
name|last_offset
argument_list|,
operator|&
name|drift_comp
argument_list|,
name|time_constant
argument_list|)
expr_stmt|;
comment|/* 	 * Whew.  I've had enough. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * adj_host_clock - Called every 2**CLOCK_ADJ seconds to update host clock  */
end_comment

begin_function
name|void
name|adj_host_clock
parameter_list|()
block|{
specifier|register
name|LONG
name|adjustment
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPSPPS
argument_list|)
name|struct
name|ppsclockev
name|ev
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
endif|#
directive|endif
comment|/* PPSPPS */
name|watchdog_timer
operator|+=
operator|(
literal|1
operator|<<
name|CLOCK_ADJ
operator|)
expr_stmt|;
if|if
condition|(
name|watchdog_timer
operator|>=
name|NTP_MAXAGE
condition|)
block|{
name|first_adjustment
operator|=
literal|1
expr_stmt|;
comment|/* don't use next offset for freq */
block|}
if|if
condition|(
name|sys_refskew
operator|.
name|l_i
operator|>=
name|NTP_MAXSKEW
condition|)
name|sys_refskew
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
comment|/* clamp it */
else|else
name|L_ADDUF
argument_list|(
operator|&
name|sys_refskew
argument_list|,
name|NTP_SKEWINC
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|PPSPPS
argument_list|)
comment|/* 	 * Note that nothing ugly happens even if the CIOGETEV ioctl is 	 * not configured. Correct for signal delays (!) for ultimate 	 * finick. 	 */
if|if
condition|(
name|fdpps
operator|!=
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|CIOGETEV
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ev
argument_list|)
operator|>=
literal|0
condition|)
block|{
specifier|static
name|int
name|last_serial
init|=
literal|0
decl_stmt|;
comment|/* avoid stale events */
if|if
condition|(
name|last_serial
operator|!=
name|ev
operator|.
name|serial
condition|)
block|{
name|TVUTOTSF
argument_list|(
name|ev
operator|.
name|tv
operator|.
name|tv_usec
argument_list|,
name|ts
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
comment|/* seconds don't matter here */
name|L_SUB
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|pps_delay
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
operator|~
name|ts
operator|.
name|l_uf
expr_stmt|;
comment|/* map [0.5..1[ into [-0.5..0[ */
name|ts
operator|.
name|l_ui
operator|=
operator|(
name|ts
operator|.
name|l_f
operator|<
literal|0
operator|)
condition|?
operator|~
literal|0
else|:
literal|0
expr_stmt|;
comment|/* sign extension */
operator|(
name|void
operator|)
name|pps_sample
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|last_serial
operator|=
name|ev
operator|.
name|serial
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PPSPPS */
endif|#
directive|endif
comment|/* PPS || PPSCLK || PPSPPS */
if|if
condition|(
name|pps_time
operator|&&
name|current_time
operator|-
name|pps_time
operator|>
name|PPS_MAXAGE
condition|)
name|pps_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pps_update
operator|&&
name|current_time
operator|-
name|pps_update
operator|>
name|PPS_MAXUPDATE
condition|)
name|pps_update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pps_time
operator|&&
name|pps_update
condition|)
block|{
if|if
condition|(
operator|!
name|pps_control
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PPS synch"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pps_control
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"PPS synch lost"
argument_list|)
expr_stmt|;
name|pps_control
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Resist the following code if the phase-lock loop has been 	 * implemented in the kernel. 	 */
if|if
condition|(
name|pll_control
condition|)
return|return;
name|adjustment
operator|=
name|clock_adjust
expr_stmt|;
if|if
condition|(
name|adjustment
operator|<
literal|0
condition|)
name|adjustment
operator|=
operator|-
operator|(
operator|(
operator|-
name|adjustment
operator|)
operator|>>
name|CLOCK_PHASE
operator|)
expr_stmt|;
else|else
name|adjustment
operator|>>=
name|CLOCK_PHASE
expr_stmt|;
name|clock_adjust
operator|-=
name|adjustment
expr_stmt|;
if|if
condition|(
name|drift_comp
operator|<
literal|0
condition|)
name|adjustment
operator|-=
operator|(
operator|(
operator|-
name|drift_comp
operator|)
operator|>>
name|RSH_DRIFT_TO_ADJ
operator|)
expr_stmt|;
else|else
name|adjustment
operator|+=
name|drift_comp
operator|>>
name|RSH_DRIFT_TO_ADJ
expr_stmt|;
block|{
name|l_fp
name|offset
decl_stmt|;
name|offset
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|offset
operator|.
name|l_f
operator|=
name|adjustment
expr_stmt|;
name|adj_systime
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * loop_config - configure the loop filter  */
end_comment

begin_function
name|void
name|loop_config
parameter_list|(
name|item
parameter_list|,
name|lfp_value
parameter_list|,
name|int_value
parameter_list|)
name|int
name|item
decl_stmt|;
name|l_fp
modifier|*
name|lfp_value
decl_stmt|;
name|int
name|int_value
decl_stmt|;
block|{
name|s_fp
name|tmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
name|struct
name|timex
name|ntv
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|LOOP_DRIFTCOMP
case|:
name|tmp
operator|=
name|LFPTOFP
argument_list|(
name|lfp_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|max_comp
operator|||
name|tmp
operator|<=
operator|-
name|max_comp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"loop_config: frequency offset %s in ntp.conf file is too large"
argument_list|,
name|fptoa
argument_list|(
name|tmp
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drift_comp
operator|=
name|tmp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
comment|/* 			 * If the phase-lock code is implemented in the 			 * kernel, give the time_constant and saved 			 * frequency offset to the kernel. If not, no 			 * harm is done. 	 		 */
name|pll_control
operator|=
literal|1
expr_stmt|;
name|pll_status
operator|=
name|STA_PLL
operator||
name|STA_PPSFREQ
expr_stmt|;
name|ntv
operator|.
name|modes
operator|=
name|MOD_BITS
operator||
name|MOD_FREQUENCY
expr_stmt|;
name|ntv
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|ntv
operator|.
name|freq
operator|=
name|drift_comp
expr_stmt|;
name|ntv
operator|.
name|maxerror
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|ntv
operator|.
name|esterror
operator|=
name|NTP_MAXDISPERSE
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|pll_status
operator||
name|STA_UNSYNC
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|time_constant
expr_stmt|;
name|newsigsys
operator|.
name|sv_handler
operator|=
name|pll_trap
expr_stmt|;
name|newsigsys
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|newsigsys
operator|.
name|sv_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sigvec
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|newsigsys
argument_list|,
operator|&
name|sigsys
argument_list|)
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec() fails to save SIGSYS trap: %m\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ntp_adjtime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigvec
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|sigsys
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigvec() fails to restore SIGSYS trap: %m\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll_control
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"using kernel phase-lock loop %04x"
argument_list|,
name|ntv
operator|.
name|status
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"using xntpd phase-lock loop"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_PLL */
block|}
break|break;
case|case
name|LOOP_PPSDELAY
case|:
name|pps_delay
operator|=
operator|*
name|lfp_value
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
case|case
name|LOOP_PPSBAUD
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 		 * System V TERMIOS serial line parameters 		 * (termios interface) 		 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
if|if
condition|(
name|fdpps
operator|==
operator|-
literal|1
condition|)
return|return;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fdpps
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ttyp
operator|->
name|c_cflag
operator|=
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
operator||
name|int_value
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fdpps
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 		 * 4.3bsd serial line parameters (sgttyb interface) 		 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
if|if
condition|(
name|fdpps
operator|==
operator|-
literal|1
operator|||
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|SYS_BAUD
argument_list|(
name|int_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fdpps
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
name|pps_baud
operator|=
name|int_value
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PPSCLK */
default|default:
comment|/* sigh */
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL_PLL
argument_list|)
end_if

begin_comment
comment|/*  * _trap - trap processor for undefined syscalls  *  * This nugget is called by the kernel when the SYS_ntp_adjtime()  * syscall bombs because the silly thing has not been implemented in  * the kernel. In this case the phase-lock loop is emulated by  * the stock adjtime() syscall and a lot of indelicate abuse.  */
end_comment

begin_function
name|RETSIGTYPE
name|pll_trap
parameter_list|()
block|{
name|pll_control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL_PLL */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPSCLK
argument_list|)
end_if

begin_comment
comment|/*  * pps_receive - compute and store 1-pps signal offset  *   * This routine is called once per second when the 1-pps signal is   * present. It calculates the offset of the local clock relative to the  * 1-pps signal and saves in a circular buffer for later use. If the  * clock line discipline is active, its timestamp is used; otherwise,  * the buffer timestamp is used.  */
end_comment

begin_function
specifier|static
name|void
name|pps_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
name|u_char
modifier|*
name|dpt
decl_stmt|;
comment|/* buffer pointer */
name|l_fp
name|ts
decl_stmt|;
comment|/* l_fp temps */
name|int
name|dpend
decl_stmt|;
comment|/* buffer length */
comment|/* 	 * Set up pointers, check the buffer length, discard intercept 	 * character and convert unix timeval to timestamp format. 	 */
name|dpt
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|dpend
operator|=
name|rbufp
operator|->
name|recv_length
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HPUXGADGET
argument_list|)
name|dpt
operator|++
expr_stmt|;
name|dpend
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* HPUXGADGET */
if|if
condition|(
name|dpend
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
operator|||
operator|!
name|buftvtots
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dpt
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
name|ts
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
comment|/* 	 * Correct for uart and os delay and process sample offset. 	 */
name|L_SUB
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|pps_delay
argument_list|)
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pps_sample
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPSCLK */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PPS
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|PPSPPS
argument_list|)
end_if

begin_comment
comment|/*  * pps_sample - process pps sample offset  */
end_comment

begin_function
name|int
name|pps_sample
parameter_list|(
name|tsr
parameter_list|)
name|l_fp
modifier|*
name|tsr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* temp ints */
name|LONG
name|sort
index|[
name|NPPS
index|]
decl_stmt|;
comment|/* temp array for sorting */
name|l_fp
name|lftemp
decl_stmt|,
name|ts
decl_stmt|;
comment|/* l_fp temps */
name|u_fp
name|utemp
decl_stmt|;
comment|/* u_fp temp */
name|LONG
name|ltemp
decl_stmt|;
comment|/* long temp */
comment|/* 	 * Note the seconds offset is already in the low-order timestamp 	 * doubleword, so all we have to do is sign-extend and invert 	 * it. The resulting offset is believed only if within 	 * CLOCK_MAX. 	 */
name|ts
operator|=
operator|*
name|tsr
expr_stmt|;
name|lftemp
operator|.
name|l_i
operator|=
name|lftemp
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
name|M_ADDF
argument_list|(
name|lftemp
operator|.
name|l_i
argument_list|,
name|lftemp
operator|.
name|l_f
argument_list|,
name|ts
operator|.
name|l_f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|l_f
operator|<=
operator|-
name|CLOCK_MAX_F
operator|||
name|ts
operator|.
name|l_f
operator|>=
name|CLOCK_MAX_F
condition|)
block|{
name|pps_time
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Save the sample in a circular buffer for later processing. 	 */
name|nsamples
operator|++
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|nsamples
argument_list|)
operator|)
operator|%
name|NPPS
expr_stmt|;
name|samples
index|[
name|i
index|]
operator|=
name|lftemp
operator|.
name|l_f
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NPPS
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * When the buffer fills up, construct an array of sorted 	 * samples. 	 */
name|pps_time
operator|=
name|current_time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPPS
condition|;
name|i
operator|++
control|)
block|{
name|sort
index|[
name|i
index|]
operator|=
name|samples
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sort
index|[
name|j
index|]
operator|>
name|sort
index|[
name|i
index|]
condition|)
block|{
name|ltemp
operator|=
name|sort
index|[
name|j
index|]
expr_stmt|;
name|sort
index|[
name|j
index|]
operator|=
name|sort
index|[
name|i
index|]
expr_stmt|;
name|sort
index|[
name|i
index|]
operator|=
name|ltemp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Compute offset as the average of all samples in the filter 	 * less PPS_TRIM samples trimmed from the beginning and end, 	 * dispersion as the difference between max and min of samples 	 * retained. The system stratum, root delay and root dispersion 	 * are also set here. 	 */
name|pps_offset
operator|.
name|l_i
operator|=
name|pps_offset
operator|.
name|l_f
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PPS_TRIM
init|;
name|i
operator|<
name|NPPS
operator|-
name|PPS_TRIM
condition|;
name|i
operator|++
control|)
name|M_ADDF
argument_list|(
name|pps_offset
operator|.
name|l_i
argument_list|,
name|pps_offset
operator|.
name|l_f
argument_list|,
name|sort
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|pps_offset
argument_list|)
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PPS_FAC
condition|;
name|i
operator|++
control|)
name|L_RSHIFT
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PPS_FAC
condition|;
name|i
operator|++
control|)
name|L_RSHIFT
argument_list|(
operator|&
name|pps_offset
argument_list|)
expr_stmt|;
block|}
name|lftemp
operator|.
name|l_i
operator|=
literal|0
expr_stmt|;
name|lftemp
operator|.
name|l_f
operator|=
name|sort
index|[
name|NPPS
operator|-
literal|1
operator|-
name|PPS_TRIM
index|]
operator|-
name|sort
index|[
name|PPS_TRIM
index|]
expr_stmt|;
name|pps_dispersion
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|lftemp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"pps_filter: %s %s %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pps_delay
argument_list|,
literal|6
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pps_offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|lftemp
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|record_peer_stats
argument_list|(
operator|&
name|loopback_interface
operator|->
name|sin
argument_list|,
name|ctlsysstatus
argument_list|()
argument_list|,
operator|&
name|pps_offset
argument_list|,
literal|0
argument_list|,
name|pps_dispersion
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS || PPSCLK || PPSPPS */
end_comment

end_unit

