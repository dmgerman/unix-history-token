begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_chu - clock driver for the CHU time code  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|CHU
argument_list|)
operator|||
name|defined
argument_list|(
name|CHUCLK
argument_list|)
operator|||
name|defined
argument_list|(
name|CHUPPS
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BSD_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSV_TTYS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STREAM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAM */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHUPPS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ppsclock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHUPPS */
end_comment

begin_include
include|#
directive|include
file|<sys/chudefs.h>
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * The CHU time signal includes a time code which is modulated at the  * standard Bell 103 frequencies (i.e. mark=2225Hz, space=2025Hz).  * and formatted into 8 bit characters with one start bit and two  * stop bits. The time code is composed of 10 8-bit characters.  * The second 5 bytes of the timecode are a redundancy check, and  * are a copy of the first 5 bytes.  *  * It is assumed that you have built or modified a Bell 103 standard  * modem, attached the input to the output of a radio and cabled the  * output to a serial port on your computer, i.e. what you are receiving  * is essentially the output of your radio.  It is also assumed you have  * installed a special CHU line discipline to condition the output from  * the terminal driver and take accurate time stamps.  *  * There are two types of timecodes. One is sent in the 32nd  * through 39th second of the minute.  *  *     6dddhhmmss6dddhhmmss  *  * where ddd is the day of the year, hh is the hour (in UTC), mm is  * the minute and ss the second.  The 6 is a constant.  Note that  * the code is sent twice.  *  * The second sort of timecode is sent only during the 31st second  * past the minute.  *  *     xdyyyyttabXDYYYYTTAB  *  * In this case, the second part of the code is the one's complement  * of the code. This differentiates it from the other timecode  * format.  *  * d is the absolute value of DUT (in tenths of a second). yyyy  * is the year. tt is the difference between UTC and TAI. a is  * a canadian daylight time flag and b is a serial number.  * x is a bitwise field. The least significant bit of x is  * one if DUT is negative. The 2nd bit is set if a leap second  * will be added at the next opportunity. The 3rd bit is set if  * a leap second will be deleted at the next opportunity.  * The 4th bit is an even parity bit for the other three bits  * in this nibble.  *  * The start bit in each character has a precise relationship to  * the on-time second.  Most often UART's synchronize themselves to the  * start bit and will post an interrupt at the center of the first stop  * bit.  Thus each character's interrupt should occur at a fixed offset  * from the on-time second.  This means that a timestamp taken at the  * arrival of each character in the code will provide an independent  * estimate of the offset.  Since there are 10 characters in the time  * code and the code is sent 9 times per minute, this means you potentially  * get 90 offset samples per minute.  Much of the code in here is dedicated  * to producing a single offset estimate from these samples.  *  * A note about the line discipline.  It is possible to receive the  * CHU time code in raw mode, but this has disadvantages.  In particular,  * this puts a lot of code between the interrupt and the time you freeze  * a time stamp, decreasing precision.  It is also expensive in terms of  * context switches, and made even more expensive by the way I do I/O.  * Worse, since you are listening directly to the output of your radio,  * CHU is noisy and will make you spend a lot of time receiving noise.  *  * The line discipline fixes a lot of this.  It knows that the CHU time  * code consists of 10 bytes which arrive with an intercharacter  * spacing of about 37 ms, and that the data is BCD, and filters on this  * basis.  It delivers block of ten characters plus their associated time  * stamps all at once.  The time stamps are hence about as accurate as  * a Unix machine can get them, and much of the noise disappears in the  * kernel with no context switching cost.  *  * The kernel module also will insure that the packets that are  * delivered have the correct redundancy bytes, and will return  * a flag in chutype to differentiate one sort of packet from  * the other.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|MAXUNITS
value|4
end_define

begin_comment
comment|/* maximum number of CHU units permitted */
end_comment

begin_define
define|#
directive|define
name|CHUDEV
value|"/dev/chu%d"
end_define

begin_comment
comment|/* device we open.  %d is unit number */
end_comment

begin_define
define|#
directive|define
name|SPEED232
value|B300
end_define

begin_comment
comment|/* uart speed (300 baud) */
end_comment

begin_define
define|#
directive|define
name|NCHUCODES
value|8
end_define

begin_comment
comment|/* expect 8 CHU codes per minute */
end_comment

begin_define
define|#
directive|define
name|CHULDISC
value|10
end_define

begin_comment
comment|/* XXX temp CHU line discipline */
end_comment

begin_comment
comment|/*  * To compute a quality for the estimate (a pseudo dispersion) we add a  * fixed 10 ms for each missing code in the minute and add to this  * the sum of the differences between the remaining offsets and the  * estimated sample offset.  */
end_comment

begin_define
define|#
directive|define
name|CHUDELAYPENALTY
value|0x0000028f
end_define

begin_comment
comment|/*  * Other constant stuff  */
end_comment

begin_define
define|#
directive|define
name|CHUPRECISION
value|(-9)
end_define

begin_comment
comment|/* what the heck */
end_comment

begin_define
define|#
directive|define
name|CHUREFID
value|"CHU\0"
end_define

begin_define
define|#
directive|define
name|CHUDESCRIPTION
value|"Direct synchronized to CHU timecode"
end_define

begin_define
define|#
directive|define
name|CHUHSREFID
value|0x7f7f070a
end_define

begin_comment
comment|/* 127.127.7.10 refid for hi strata */
end_comment

begin_comment
comment|/*  * Default fudge factors  */
end_comment

begin_define
define|#
directive|define
name|DEFPROPDELAY
value|0x00624dd3
end_define

begin_comment
comment|/* 0.0015 seconds, 1.5 ms */
end_comment

begin_define
define|#
directive|define
name|DEFFILTFUDGE
value|0x000d1b71
end_define

begin_comment
comment|/* 0.0002 seconds, 200 us */
end_comment

begin_comment
comment|/*  * Hacks to avoid excercising the multiplier.  I have no pride.  */
end_comment

begin_define
define|#
directive|define
name|MULBY10
parameter_list|(
name|x
parameter_list|)
value|(((x)<<3) + ((x)<<1))
end_define

begin_define
define|#
directive|define
name|MULBY60
parameter_list|(
name|x
parameter_list|)
value|(((x)<<6) - ((x)<<2))
end_define

begin_comment
comment|/* watch overflow */
end_comment

begin_define
define|#
directive|define
name|MULBY24
parameter_list|(
name|x
parameter_list|)
value|(((x)<<4) + ((x)<<3))
end_define

begin_comment
comment|/*  * Constants for use when multiplying by 0.1.  ZEROPTONE is 0.1  * as an l_fp fraction, NZPOBITS is the number of significant bits  * in ZEROPTONE.  */
end_comment

begin_define
define|#
directive|define
name|ZEROPTONE
value|0x1999999a
end_define

begin_define
define|#
directive|define
name|NZPOBITS
value|29
end_define

begin_decl_stmt
specifier|static
name|char
name|hexstring
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CHU unit control structure.  */
end_comment

begin_struct
struct|struct
name|chuunit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* associated peer structure */
name|struct
name|event
name|chutimer
decl_stmt|;
comment|/* timeout timer structure */
name|struct
name|refclockio
name|chuio
decl_stmt|;
comment|/* given to the I/O handler */
name|l_fp
name|offsets
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* offsets computed from each code */
name|l_fp
name|rectimes
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* times we received this stuff */
name|U_LONG
name|reftimes
index|[
name|NCHUCODES
index|]
decl_stmt|;
comment|/* time of last code received */
name|u_char
name|lastcode
index|[
name|NCHUCHARS
operator|*
literal|4
index|]
decl_stmt|;
comment|/* last code we received */
name|u_char
name|asciicode
index|[
name|NCHUCHARS
operator|*
literal|4
operator|+
literal|1
index|]
decl_stmt|;
comment|/* last code translated to ascii */
name|u_char
name|expect
decl_stmt|;
comment|/* the next offset expected */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number for this guy */
name|u_short
name|haveoffset
decl_stmt|;
comment|/* flag word indicating valid offsets */
name|u_short
name|flags
decl_stmt|;
comment|/* operational flags */
name|u_char
name|status
decl_stmt|;
comment|/* clock status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last clock event */
name|u_char
name|unused
index|[
literal|2
index|]
decl_stmt|;
name|U_LONG
name|lastupdate
decl_stmt|;
comment|/* last time data received */
name|U_LONG
name|responses
decl_stmt|;
comment|/* number of responses */
name|U_LONG
name|badformat
decl_stmt|;
comment|/* number of bad format responses */
name|U_LONG
name|baddata
decl_stmt|;
comment|/* number of invalid time codes */
name|U_LONG
name|timestarted
decl_stmt|;
comment|/* time we started this */
name|u_char
name|leap
decl_stmt|;
comment|/* leap status */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CHUTIMERSET
value|0x1
end_define

begin_comment
comment|/* timer is set to fire */
end_comment

begin_comment
comment|/*  * The CHU table.  This gives the expected time of arrival of each  * character after the on-time second and is computed as follows:  * The CHU time code is sent at 300 bps.  Your average UART will  * synchronize at the edge of the start bit and will consider the  * character complete at the middle of the first stop bit, i.e.  * 0.031667 ms later (some UARTS may complete the character at the  * end of the stop bit instead of the middle, but you can fudge this).  * Thus the expected time of each interrupt is the start bit time plus  * 0.031667 seconds.  These times are in chutable[].  To this we add  * such things as propagation delay and delay fudge factor.  */
end_comment

begin_define
define|#
directive|define
name|CHARDELAY
value|0x081b4e82
end_define

begin_decl_stmt
specifier|static
name|U_LONG
name|chutable
index|[
name|NCHUCHARS
index|]
init|=
block|{
literal|0x22222222
operator|+
name|CHARDELAY
block|,
comment|/* 0.1333333333 */
literal|0x2b851eb8
operator|+
name|CHARDELAY
block|,
comment|/* 0.170 (exactly) */
literal|0x34e81b4e
operator|+
name|CHARDELAY
block|,
comment|/* 0.2066666667 */
literal|0x3f92c5f9
operator|+
name|CHARDELAY
block|,
comment|/* 0.2483333333 */
literal|0x47ae147b
operator|+
name|CHARDELAY
block|,
comment|/* 0.280 (exactly) */
literal|0x51111111
operator|+
name|CHARDELAY
block|,
comment|/* 0.3166666667 */
literal|0x5a740da7
operator|+
name|CHARDELAY
block|,
comment|/* 0.3533333333 */
literal|0x63d70a3d
operator|+
name|CHARDELAY
block|,
comment|/* 0.390 (exactly) */
literal|0x6d3a06d4
operator|+
name|CHARDELAY
block|,
comment|/* 0.4266666667 */
literal|0x769d0370
operator|+
name|CHARDELAY
block|,
comment|/* 0.4633333333 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data space for the unit structures.  Note that we allocate these on  * the fly, but never give them back.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|chuunit
modifier|*
name|chuunits
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Keep the fudge factors separately so they can be set even  * when no clock is configured.  */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|propagation_delay
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|fudgefactor
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|l_fp
name|offset_fudge
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|stratumtouse
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sloppyclockflag
index|[
name|MAXUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We keep track of the start of the year, watching for changes.  * We also keep track of whether the year is a leap year or not.  * All because stupid CHU doesn't include the year in the time code.  */
end_comment

begin_decl_stmt
specifier|static
name|U_LONG
name|yearstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|event
name|timerqueue
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from ntp_loopfilter module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps file descriptor */
end_comment

begin_comment
comment|/*  * Imported from ntpd module  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global debug flag */
end_comment

begin_comment
comment|/*  * Event reporting.  This optimizes things a little.  */
end_comment

begin_define
define|#
directive|define
name|chu_event
parameter_list|(
name|chu
parameter_list|,
name|evcode
parameter_list|)
define|\
value|do { \ 		if ((chu)->status != (u_char)(evcode)) \ 			chu_report_event((chu), (evcode)); \ 	} while (0)
end_define

begin_decl_stmt
specifier|static
name|void
name|chu_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chu_start
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_shutdown
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_report_event
name|P
argument_list|(
operator|(
expr|struct
name|chuunit
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_process
name|P
argument_list|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_control
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chu_timeout
name|P
argument_list|(
operator|(
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transfer vector  */
end_comment

begin_decl_stmt
name|struct
name|refclock
name|refclock_chu
init|=
block|{
name|chu_start
block|,
name|chu_shutdown
block|,
name|chu_poll
block|,
name|chu_control
block|,
name|chu_init
block|,
name|noentry
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * chu_init - initialize internal chu driver data  */
end_comment

begin_function
specifier|static
name|void
name|chu_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Just zero the data arrays 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chuunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|chuunits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|unitinuse
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize fudge factors to default. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
name|propagation_delay
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|propagation_delay
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFPROPDELAY
expr_stmt|;
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|fudgefactor
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|DEFFILTFUDGE
expr_stmt|;
name|offset_fudge
index|[
name|i
index|]
operator|=
name|propagation_delay
index|[
name|i
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|i
index|]
argument_list|,
operator|&
name|fudgefactor
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stratumtouse
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sloppyclockflag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_start - open the CHU device and initialize data for processing  */
end_comment

begin_function
specifier|static
name|int
name|chu_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd232
decl_stmt|;
name|char
name|chudev
index|[
literal|20
index|]
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* 	 * Check configuration info 	 */
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: unit %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Open serial port 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|chudev
argument_list|,
name|CHUDEV
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fd232
operator|=
name|open
argument_list|(
name|chudev
argument_list|,
name|O_RDONLY
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd232
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: open of %s: %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSV_TTYS
argument_list|)
comment|/* 	 * System V serial line parameters (termio interface) 	 */
name|CHU
name|SUPPORT
name|NOT
name|AVAILABLE
name|IN
name|TERMIO
name|INTERFACE
endif|#
directive|endif
comment|/* HAVE_SYSV_TTYS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS
argument_list|)
comment|/* 	 * POSIX serial line parameters (termios interface) 	 * 	 * The CHUCLK support uses a 300-baud modem and level converter 	 * (gadget box). It requires the chu_clk streams module and 	 * SunOS 4.1.1 or later. 	 * 	 * The CHUPPS option provides timestamping at the driver level. 	 * It uses a 1-pps signal and level converter (gadget box) and 	 * requires the ppsclock streams module and SunOS 4.1.1 or 	 * later. 	 */
block|{
name|struct
name|termios
name|ttyb
decl_stmt|,
modifier|*
name|ttyp
decl_stmt|;
name|ttyp
operator|=
operator|&
name|ttyb
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd232
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: tcgetattr(%s): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyp
operator|->
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|ttyp
operator|->
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cflag
operator|=
name|SPEED232
operator||
name|CS8
operator||
name|CLOCAL
operator||
name|CREAD
expr_stmt|;
name|ttyp
operator|->
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|ttyp
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ttyp
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd232
argument_list|,
name|TCSANOW
argument_list|,
name|ttyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: tcsetattr(%s): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|tcflush
argument_list|(
name|fd232
argument_list|,
name|TCIOFLUSH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: tcflush(%s): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_TERMIOS */
ifdef|#
directive|ifdef
name|STREAM
while|while
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_POP
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"chu"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: ioctl(%s, I_PUSH, chu): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|CHUPPS
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|I_PUSH
argument_list|,
literal|"ppsclock"
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: ioctl(%s, I_PUSH, ppsclock): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
else|else
name|fdpps
operator|=
name|fd232
expr_stmt|;
endif|#
directive|endif
comment|/* CHUPPS */
endif|#
directive|endif
comment|/* STREAM */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_TTYS
argument_list|)
comment|/* 	 * 4.3bsd serial line parameters (sgttyb interface) 	 * 	 * The CHUCLK support uses a 300-baud modem and level converter 	 * (gadget box). It requires the chu_clk streams module and 	 * 4.3bsd or later. 	 */
block|{
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
name|int
name|ldisc
init|=
name|CHULDISC
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: ioctl(%s, TIOCGETP): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
name|ttyb
operator|.
name|sg_ispeed
operator|=
name|ttyb
operator|.
name|sg_ospeed
operator|=
name|SPEED232
expr_stmt|;
name|ttyb
operator|.
name|sg_erase
operator|=
name|ttyb
operator|.
name|sg_kill
operator|=
literal|'\r'
expr_stmt|;
name|ttyb
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: ioctl(%s, TIOCSETP): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd232
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_start: ioctl(%s, TIOCSETD): %m"
argument_list|,
name|chudev
argument_list|)
expr_stmt|;
goto|goto
name|screwed
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_BSD_TTYS */
comment|/* 	 * Allocate unit structure 	 */
if|if
condition|(
name|chuunits
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
block|{
name|chu
operator|=
name|chuunits
index|[
name|unit
index|]
expr_stmt|;
comment|/* The one we want is okay */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unitinuse
index|[
name|i
index|]
operator|&&
name|chuunits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|MAXUNITS
condition|)
block|{
comment|/* 			 * Reclaim this one 			 */
name|chu
operator|=
name|chuunits
index|[
name|i
index|]
expr_stmt|;
name|chuunits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chu
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chu
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chuunit
argument_list|)
argument_list|)
expr_stmt|;
name|chuunits
index|[
name|unit
index|]
operator|=
name|chu
expr_stmt|;
comment|/* 	 * Set up the structure 	 */
name|chu
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|chu
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|chu
operator|->
name|timestarted
operator|=
name|current_time
expr_stmt|;
name|chu
operator|->
name|chutimer
operator|.
name|peer
operator|=
operator|(
expr|struct
name|peer
operator|*
operator|)
name|chu
expr_stmt|;
name|chu
operator|->
name|chutimer
operator|.
name|event_handler
operator|=
name|chu_timeout
expr_stmt|;
name|chu
operator|->
name|chuio
operator|.
name|clock_recv
operator|=
name|chu_receive
expr_stmt|;
name|chu
operator|->
name|chuio
operator|.
name|srcclock
operator|=
operator|(
name|caddr_t
operator|)
name|chu
expr_stmt|;
name|chu
operator|->
name|chuio
operator|.
name|datalen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|chucode
argument_list|)
expr_stmt|;
name|chu
operator|->
name|chuio
operator|.
name|fd
operator|=
name|fd232
expr_stmt|;
comment|/* 	 * Initialize the year from the system time in case this is the 	 * first open. 	 */
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|yearstart
operator|=
name|calyearstart
argument_list|(
name|ts
operator|.
name|l_ui
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io_addclock
argument_list|(
operator|&
name|chu
operator|->
name|chuio
argument_list|)
condition|)
block|{
goto|goto
name|screwed
goto|;
block|}
comment|/* 	 * All done.  Initialize a few random peer variables, then 	 * return success. 	 */
name|peer
operator|->
name|precision
operator|=
name|CHUPRECISION
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stratumtouse
index|[
name|unit
index|]
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|CHUREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|CHUHSREFID
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Something broke; abandon ship. 	 */
name|screwed
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd232
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chu_shutdown - shut down a CHU clock  */
end_comment

begin_function
specifier|static
name|void
name|chu_shutdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_shutdown: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_shutdown: unit %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tell the I/O module to turn us off, and dequeue timer 	 * if any.  We're history. 	 */
name|chu
operator|=
name|chuunits
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|chu
operator|->
name|flags
operator|&
name|CHUTIMERSET
condition|)
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|chu
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|io_closeclock
argument_list|(
operator|&
name|chu
operator|->
name|chuio
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_report_event - record an event and report it  */
end_comment

begin_function
specifier|static
name|void
name|chu_report_event
parameter_list|(
name|chu
parameter_list|,
name|code
parameter_list|)
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
comment|/* 	 * Trap support isn't up to handling this, so just 	 * record it. 	 */
if|if
condition|(
name|chu
operator|->
name|status
operator|!=
operator|(
name|u_char
operator|)
name|code
condition|)
block|{
name|chu
operator|->
name|status
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|CEVNT_NOMINAL
condition|)
name|chu
operator|->
name|lastevent
operator|=
operator|(
name|u_char
operator|)
name|code
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_receive - receive data from a CHU clock, do format checks and compute  *		 an estimate from the sample data  */
end_comment

begin_function
specifier|static
name|void
name|chu_receive
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|U_LONG
name|date_ui
decl_stmt|;
specifier|register
name|U_LONG
name|tmp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|code
decl_stmt|;
specifier|register
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
specifier|register
name|struct
name|chucode
modifier|*
name|chuc
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|U_LONG
name|reftime
decl_stmt|;
name|l_fp
name|off
index|[
name|NCHUCHARS
index|]
decl_stmt|;
name|int
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
comment|/* 	 * Do a length check on the data.  Should be what we asked for. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|chucode
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_receive: received %d bytes, expected %d"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|chucode
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the clock this applies to and a pointer to the data 	 */
name|chu
operator|=
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|rbufp
operator|->
name|recv_srcclock
expr_stmt|;
name|chuc
operator|=
operator|(
expr|struct
name|chucode
operator|*
operator|)
operator|&
name|rbufp
operator|->
name|recv_space
expr_stmt|;
name|chu
operator|->
name|responses
operator|++
expr_stmt|;
name|chu
operator|->
name|lastupdate
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * At this point we're assured that both halves of the 	 * data match because of what the kernel has done. 	 * But there's more than one data format. We need to 	 * check chutype to see what to do now. If it's a 	 * year packet, then we fiddle with it specially. 	 */
if|if
condition|(
name|chuc
operator|->
name|chutype
operator|==
name|CHU_YEAR
condition|)
block|{
name|u_char
name|leapbits
decl_stmt|,
name|parity
decl_stmt|;
comment|/* 	 	 * Break out the code into the BCD nibbles. 		 * Put it in the half of lastcode. 		 */
name|code
operator|=
name|chu
operator|->
name|lastcode
expr_stmt|;
name|code
operator|+=
literal|2
operator|*
name|NCHUCHARS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
name|leapbits
operator|=
name|chuc
operator|->
name|codechars
index|[
literal|0
index|]
operator|&
literal|0xf
expr_stmt|;
comment|/* 		 * Now make sure that the leap nibble 		 * is even parity. 		 */
name|parity
operator|=
operator|(
name|leapbits
operator|^
operator|(
name|leapbits
operator|>>
literal|2
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|parity
operator|=
operator|(
name|parity
operator|^
operator|(
name|parity
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|parity
condition|)
block|{
name|chu
operator|->
name|badformat
operator|++
expr_stmt|;
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * This just happens to work. :-) 		 */
name|chu
operator|->
name|leap
operator|=
operator|(
name|leapbits
operator|>>
literal|1
operator|)
operator|&
literal|0x3
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chuc
operator|->
name|chutype
operator|!=
name|CHU_TIME
condition|)
block|{
name|chu
operator|->
name|badformat
operator|++
expr_stmt|;
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Break out the code into the BCD nibbles.  Only need to fiddle 	 * with the first half since both are identical.  Note the first 	 * BCD character is the low order nibble, the second the high order. 	 */
name|code
operator|=
name|chu
operator|->
name|lastcode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|code
operator|++
operator|=
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|code
operator|++
operator|=
operator|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/* 	 * Format check.  Make sure the two halves match. 	 * There's really no need for this, but it can't hurt. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
operator|/
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chuc
operator|->
name|codechars
index|[
name|i
index|]
operator|!=
name|chuc
operator|->
name|codechars
index|[
name|i
operator|+
operator|(
name|NCHUCHARS
operator|/
literal|2
operator|)
index|]
condition|)
block|{
name|chu
operator|->
name|badformat
operator|++
expr_stmt|;
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the first nibble isn't a 6, we're up the creek 	 */
name|code
operator|=
name|chu
operator|->
name|lastcode
expr_stmt|;
if|if
condition|(
operator|*
name|code
operator|++
operator|!=
literal|6
condition|)
block|{
name|chu
operator|->
name|badformat
operator|++
expr_stmt|;
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADREPLY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Collect the day, the hour, the minute and the second. 	 */
name|day
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|day
operator|=
name|MULBY10
argument_list|(
name|day
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|hour
operator|=
name|MULBY10
argument_list|(
name|hour
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|minute
operator|=
name|MULBY10
argument_list|(
name|minute
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
operator|*
name|code
operator|++
expr_stmt|;
name|second
operator|=
name|MULBY10
argument_list|(
name|second
argument_list|)
operator|+
operator|*
name|code
operator|++
expr_stmt|;
comment|/* 	 * Sanity check the day and time.  Note that this 	 * only occurs on the 32st through the 39th second 	 * of the minute. 	 */
if|if
condition|(
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|366
operator|||
name|hour
operator|>
literal|23
operator|||
name|minute
operator|>
literal|59
operator|||
name|second
operator|<
literal|32
operator|||
name|second
operator|>
literal|39
condition|)
block|{
name|chu
operator|->
name|baddata
operator|++
expr_stmt|;
if|if
condition|(
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|366
condition|)
block|{
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADTIME
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Compute the NTP date from the input data and the 	 * receive timestamp.  If this doesn't work, mark the 	 * date as bad and forget it. 	 */
if|if
condition|(
operator|!
name|clocktime
argument_list|(
name|day
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|,
literal|0
argument_list|,
name|rbufp
operator|->
name|recv_time
operator|.
name|l_ui
argument_list|,
operator|&
name|yearstart
argument_list|,
operator|&
name|reftime
argument_list|)
condition|)
block|{
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_BADDATE
argument_list|)
expr_stmt|;
return|return;
block|}
name|date_ui
operator|=
name|reftime
expr_stmt|;
empty_stmt|;
comment|/* 	 * We've now got the integral seconds part of the time code (we hope). 	 * The fractional part comes from the table.  We next compute 	 * the offsets for each character. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|U_LONG
name|tmp2
decl_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|off
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|chutable
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|TVUTOTSF
argument_list|(
name|chuc
operator|->
name|codetimes
index|[
name|i
index|]
operator|.
name|tv_usec
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|M_SUB
argument_list|(
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sloppyclockflag
index|[
name|chu
operator|->
name|unit
index|]
condition|)
block|{
name|u_short
name|ord
index|[
name|NCHUCHARS
index|]
decl_stmt|;
comment|/* 		 * In here we assume the clock has adequate bits 		 * to take timestamps with reasonable accuracy. 		 * Note that the time stamps may contain errors 		 * for a couple of reasons.  Timing is actually 		 * referenced to the start bit in each character 		 * in the time code.  If this is obscured by static 		 * you can still get a valid character but have the 		 * timestamp offset by +-1.5 ms.  Also, we may suffer 		 * from interrupt delays if the interrupt is being 		 * held off when the character arrives.  Note the 		 * latter error is always in the form of a delay. 		 * 		 * After fiddling I arrived at the following scheme. 		 * We sort the times into order by offset.  We then 		 * drop the most positive 2 offset values (which may 		 * correspond to a character arriving early due to 		 * static) and the most negative 4 (which may correspond 		 * to delayed characters, either from static or from 		 * interrupt latency).  We then take the mean of the 		 * remaining 4 offsets as our estimate. 		 */
comment|/* 		 * Set up the order array. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|ord
index|[
name|i
index|]
operator|=
operator|(
name|u_short
operator|)
name|i
expr_stmt|;
comment|/* 		 * Sort them into order.  Reuse variables with abandon. 		 */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
operator|(
name|NCHUCHARS
operator|-
literal|1
operator|)
condition|;
name|tmp
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|tmp
operator|+
literal|1
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|L_ISGEQ
argument_list|(
operator|&
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|off
index|[
name|ord
index|[
name|tmp
index|]
index|]
argument_list|)
condition|)
block|{
name|date_ui
operator|=
operator|(
name|U_LONG
operator|)
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|tmp
index|]
expr_stmt|;
name|ord
index|[
name|tmp
index|]
operator|=
operator|(
name|u_short
operator|)
name|date_ui
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Done the sort.  We drop 0, 1, 2 and 3 at the negative 		 * end, and 8 and 9 at the positive.  Take the sum of 		 * 4, 5, 6 and 7. 		 */
name|date_ui
operator|=
name|off
index|[
name|ord
index|[
literal|4
index|]
index|]
operator|.
name|l_ui
expr_stmt|;
name|tmp
operator|=
name|off
index|[
name|ord
index|[
literal|4
index|]
index|]
operator|.
name|l_uf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|ord
index|[
name|i
index|]
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
comment|/* 		 * Round properly, then right shift two bits for the 		 * divide by four. 		 */
if|if
condition|(
name|tmp
operator|&
literal|0x2
condition|)
name|M_ADDUF
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|M_RSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Here is a *big* problem.  On a machine where the 		 * low order bit in the clock is on the order of half 		 * a millisecond or more we don't really have enough 		 * precision to make intelligent choices about which 		 * samples might be in error and which aren't.  More 		 * than this, in the case of error free data we can 		 * pick up a few bits of precision by taking the mean 		 * of the whole bunch.  This is what we do.  The problem 		 * comes when it comes time to divide the 64 bit sum of 		 * the 10 samples by 10, a procedure which really sucks. 		 * Oh, well, grin and bear it.  Compute the sum first. 		 */
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
condition|;
name|i
operator|++
control|)
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_ui
argument_list|,
name|off
index|[
name|i
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_ISNEG
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
condition|)
name|isneg
operator|=
literal|1
expr_stmt|;
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Here is a multiply-by-0.1 optimization that should apply 		 * just about everywhere.  If the magnitude of the sum 		 * is less than 9 we don't have to worry about overflow 		 * out of a 64 bit product, even after rounding. 		 */
if|if
condition|(
name|date_ui
operator|<
literal|9
operator|||
name|date_ui
operator|>
literal|0xfffffff7
condition|)
block|{
specifier|register
name|U_LONG
name|prod_ui
decl_stmt|;
specifier|register
name|U_LONG
name|prod_uf
decl_stmt|;
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
comment|/* 			 * This code knows the low order bit in 0.1 is zero 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD
argument_list|(
name|prod_ui
argument_list|,
name|prod_uf
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Done, round it correctly.  Prod_ui contains the 			 * fraction. 			 */
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|prod_ui
operator|++
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|date_ui
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|date_ui
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
comment|/* 			 * date_ui is integral part, tmp is fraction. 			 */
block|}
else|else
block|{
specifier|register
name|U_LONG
name|prod_ovr
decl_stmt|;
specifier|register
name|U_LONG
name|prod_ui
decl_stmt|;
specifier|register
name|U_LONG
name|prod_uf
decl_stmt|;
specifier|register
name|U_LONG
name|highbits
decl_stmt|;
name|prod_ovr
operator|=
name|prod_ui
operator|=
name|prod_uf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
name|highbits
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* sign extend */
else|else
name|highbits
operator|=
literal|0
expr_stmt|;
comment|/* 			 * This code knows the low order bit in 0.1 is zero 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NZPOBITS
condition|;
name|i
operator|++
control|)
block|{
name|M_LSHIFT3
argument_list|(
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZEROPTONE
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|M_ADD3
argument_list|(
name|prod_ovr
argument_list|,
name|prod_uf
argument_list|,
name|prod_ui
argument_list|,
name|highbits
argument_list|,
name|date_ui
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prod_uf
operator|&
literal|0x80000000
condition|)
name|M_ADDUF
argument_list|(
name|prod_ovr
argument_list|,
name|prod_ui
argument_list|,
operator|(
name|U_LONG
operator|)
literal|1
argument_list|)
expr_stmt|;
name|date_ui
operator|=
name|prod_ovr
expr_stmt|;
name|tmp
operator|=
name|prod_ui
expr_stmt|;
block|}
block|}
comment|/* 	 * At this point we have the mean offset, with the integral 	 * part in date_ui and the fractional part in tmp.  Store 	 * it in the structure. 	 */
name|i
operator|=
name|second
operator|-
literal|32
expr_stmt|;
comment|/* gives a value 0 through 8 */
if|if
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|chu
operator|->
name|expect
condition|)
block|{
comment|/* 		 * This shouldn't actually happen, but might if a single 		 * bit error occurred in the code which fooled us. 		 * Throw away all previous data. 		 */
name|chu
operator|->
name|expect
operator|=
literal|0
expr_stmt|;
name|chu
operator|->
name|haveoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chu
operator|->
name|flags
operator|&
name|CHUTIMERSET
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|chu
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|chu
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
block|}
block|}
comment|/* 	 * Add in fudge factor. 	 */
name|M_ADD
argument_list|(
name|date_ui
argument_list|,
name|tmp
argument_list|,
name|offset_fudge
index|[
name|chu
operator|->
name|unit
index|]
operator|.
name|l_ui
argument_list|,
name|offset_fudge
index|[
name|chu
operator|->
name|unit
index|]
operator|.
name|l_uf
argument_list|)
expr_stmt|;
name|chu
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|l_ui
operator|=
name|date_ui
expr_stmt|;
name|chu
operator|->
name|offsets
index|[
name|i
index|]
operator|.
name|l_uf
operator|=
name|tmp
expr_stmt|;
name|chu
operator|->
name|rectimes
index|[
name|i
index|]
operator|=
name|rbufp
operator|->
name|recv_time
expr_stmt|;
name|chu
operator|->
name|reftimes
index|[
name|i
index|]
operator|=
name|reftime
expr_stmt|;
name|chu
operator|->
name|expect
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|chu
operator|->
name|haveoffset
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|chu
operator|->
name|expect
operator|>=
name|NCHUCODES
condition|)
block|{
comment|/* 		 * Got a full second's worth.  Dequeue timer and 		 * process this. 		 */
if|if
condition|(
name|chu
operator|->
name|flags
operator|&
name|CHUTIMERSET
condition|)
block|{
name|TIMER_DEQUEUE
argument_list|(
operator|&
name|chu
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|chu
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
block|}
name|chu_process
argument_list|(
name|chu
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|chu
operator|->
name|flags
operator|&
name|CHUTIMERSET
operator|)
condition|)
block|{
comment|/* 		 * Try to take an interrupt sometime after the 		 * 42 second mark (leaves an extra 2 seconds for 		 * slop).  Round it up to an even multiple of 		 * 4 seconds. 		 */
name|chu
operator|->
name|chutimer
operator|.
name|event_time
operator|=
name|current_time
operator|+
call|(
name|U_LONG
call|)
argument_list|(
literal|10
operator|-
name|i
argument_list|)
operator|+
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
expr_stmt|;
name|chu
operator|->
name|chutimer
operator|.
name|event_time
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|EVENT_TIMEOUT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|TIMER_INSERT
argument_list|(
name|timerqueue
argument_list|,
operator|&
name|chu
operator|->
name|chutimer
argument_list|)
expr_stmt|;
name|chu
operator|->
name|flags
operator||=
name|CHUTIMERSET
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_timeout - process a timeout event  */
end_comment

begin_function
specifier|static
name|void
name|chu_timeout
parameter_list|(
name|fakepeer
parameter_list|)
name|struct
name|peer
modifier|*
name|fakepeer
decl_stmt|;
block|{
comment|/* 	 * If we got here it means we received some time codes 	 * but didn't get the one which should have arrived on 	 * the 39th second.  Process what we have. 	 */
operator|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|fakepeer
operator|)
operator|->
name|flags
operator|&=
operator|~
name|CHUTIMERSET
expr_stmt|;
name|chu_process
argument_list|(
operator|(
expr|struct
name|chuunit
operator|*
operator|)
name|fakepeer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_process - process the raw offset estimates we have and pass  *		 the results on to the NTP clock filters.  */
end_comment

begin_function
specifier|static
name|void
name|chu_process
parameter_list|(
name|chu
parameter_list|)
specifier|register
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|s_fp
name|bestoff
decl_stmt|;
specifier|register
name|s_fp
name|tmpoff
decl_stmt|;
name|u_fp
name|dispersion
decl_stmt|;
name|int
name|imax
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
comment|/* 	 * The most positive offset. 	 */
name|imax
operator|=
name|NCHUCODES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|chu
operator|->
name|haveoffset
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|i
operator|<
name|imax
operator|||
name|L_ISGEQ
argument_list|(
operator|&
name|chu
operator|->
name|offsets
index|[
name|i
index|]
argument_list|,
operator|&
name|chu
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|)
condition|)
name|imax
operator|=
name|i
expr_stmt|;
comment|/* 	 * The most positive estimate is our best bet.  Go through 	 * the list again computing the dispersion. 	 */
name|bestoff
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|chu
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|)
expr_stmt|;
name|dispersion
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCODES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chu
operator|->
name|haveoffset
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|tmpoff
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|chu
operator|->
name|offsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dispersion
operator|+=
operator|(
name|bestoff
operator|-
name|tmpoff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dispersion
operator|+=
name|CHUDELAYPENALTY
expr_stmt|;
block|}
block|}
comment|/* 	 * Make up a reference time stamp, then give it to the 	 * reference clock support code for further processing. 	 */
name|ts
operator|.
name|l_ui
operator|=
name|chu
operator|->
name|reftimes
index|[
name|imax
index|]
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|=
name|chutable
index|[
name|NCHUCHARS
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHUCHARS
operator|*
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|chu
operator|->
name|asciicode
index|[
name|i
index|]
operator|=
name|hexstring
index|[
name|chu
operator|->
name|lastcode
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
name|chu
operator|->
name|asciicode
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|record_clock_stats
argument_list|(
operator|&
operator|(
name|chu
operator|->
name|peer
operator|->
name|srcadr
operator|)
argument_list|,
name|chu
operator|->
name|asciicode
argument_list|)
expr_stmt|;
name|refclock_receive
argument_list|(
name|chu
operator|->
name|peer
argument_list|,
operator|&
name|chu
operator|->
name|offsets
index|[
name|imax
index|]
argument_list|,
literal|0
argument_list|,
name|dispersion
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|chu
operator|->
name|rectimes
index|[
name|imax
index|]
argument_list|,
name|chu
operator|->
name|leap
argument_list|)
expr_stmt|;
comment|/* 	 * Zero out unit for next code series 	 */
name|chu
operator|->
name|haveoffset
operator|=
literal|0
expr_stmt|;
name|chu
operator|->
name|expect
operator|=
literal|0
expr_stmt|;
name|chu_event
argument_list|(
name|chu
argument_list|,
name|CEVNT_NOMINAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * chu_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|chu_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_poll: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_poll: unit %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|current_time
operator|-
name|chuunits
index|[
name|unit
index|]
operator|->
name|lastupdate
operator|)
operator|>
literal|150
condition|)
block|{
name|chu_event
argument_list|(
name|chuunits
index|[
name|unit
index|]
argument_list|,
name|CEVNT_PROP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chu_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|chu_control
parameter_list|(
name|unit
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|struct
name|chuunit
modifier|*
name|chu
decl_stmt|;
name|U_LONG
name|npolls
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAXUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chu_control: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|propagation_delay
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgetime1
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
name|fudgefactor
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|fudgetime2
expr_stmt|;
name|offset_fudge
index|[
name|unit
index|]
operator|=
name|propagation_delay
index|[
name|unit
index|]
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|offset_fudge
index|[
name|unit
index|]
argument_list|,
operator|&
name|fudgefactor
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEVAL1
condition|)
block|{
name|stratumtouse
index|[
name|unit
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|in
operator|->
name|fudgeval1
operator|&
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* 				 * Should actually reselect clock, but 				 * will wait for the next timecode 				 */
name|peer
operator|=
name|chuunits
index|[
name|unit
index|]
operator|->
name|peer
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|stratumtouse
index|[
name|unit
index|]
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|CHUREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|CHUHSREFID
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVEFLAG1
condition|)
block|{
name|sloppyclockflag
index|[
name|unit
index|]
operator|=
name|in
operator|->
name|flags
operator|&
name|CLK_FLAG1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|out
operator|->
name|type
operator|=
name|REFCLK_CHU
expr_stmt|;
name|out
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
operator||
name|CLK_HAVETIME2
operator||
name|CLK_HAVEVAL1
operator||
name|CLK_HAVEVAL2
operator||
name|CLK_HAVEFLAG1
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|CHUDESCRIPTION
expr_stmt|;
name|out
operator|->
name|fudgetime1
operator|=
name|propagation_delay
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|=
name|fudgefactor
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
operator|(
name|long
operator|)
name|stratumtouse
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|sloppyclockflag
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|chu
operator|=
name|chuunits
index|[
name|unit
index|]
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
name|NCHUCHARS
operator|*
literal|4
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|=
name|chu
operator|->
name|lastcode
index|[
literal|2
operator|*
name|NCHUCHARS
operator|+
literal|1
index|]
expr_stmt|;
name|out
operator|->
name|fudgeval2
operator|*=
operator|(
name|chu
operator|->
name|lastcode
index|[
literal|2
operator|*
name|NCHUCHARS
index|]
operator|&
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
name|chu
operator|->
name|asciicode
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|chu
operator|->
name|timestarted
expr_stmt|;
name|npolls
operator|=
name|out
operator|->
name|timereset
operator|/
literal|6
expr_stmt|;
comment|/* **divide** */
name|out
operator|->
name|polls
operator|=
name|npolls
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
operator|(
name|npolls
operator|-
name|chu
operator|->
name|responses
operator|)
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|chu
operator|->
name|badformat
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
name|chu
operator|->
name|baddata
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|chu
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|chu
operator|->
name|status
expr_stmt|;
block|}
else|else
block|{
name|out
operator|->
name|fudgeval2
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
literal|""
expr_stmt|;
name|out
operator|->
name|polls
operator|=
name|out
operator|->
name|noresponse
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
name|out
operator|->
name|baddata
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|out
operator|->
name|lastevent
operator|=
name|CEVNT_NOMINAL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

