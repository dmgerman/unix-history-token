begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * refclock_local - local pseudo-clock driver  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOCAL_CLOCK
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_refclock.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|local_init
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_start
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_shutdown
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_poll
name|P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|peer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|local_control
name|P
argument_list|(
operator|(
name|u_int
operator|,
expr|struct
name|refclockstat
operator|*
operator|,
expr|struct
name|refclockstat
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|local_buginfo
value|noentry
end_define

begin_decl_stmt
name|struct
name|refclock
name|refclock_local
init|=
block|{
name|local_start
block|,
name|local_shutdown
block|,
name|local_poll
block|,
name|local_control
block|,
name|local_init
block|,
name|local_buginfo
block|,
name|NOFLAGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is a hack to allow a machine to use its own system clock as  * a "reference clock", i.e. to free run against its own clock at  * a non-infinity stratum.  This is certainly useful if you want to  * use NTP in an isolated environment with no radio clock (not that  * this is a good idea) to synchronize the machines together.  Pick  * a machine that you figure has a good clock and configure it with  * a local reference clock running at stratum 0 (i.e. 127.127.1.0).  * Then point all the other machines at the one you're using as the  * reference.  *  * The other thing this is good for is if you want to use a particular  * server's clock as the last resort, when all radio time has gone  * away.  This is especially good if that server has an ovenized  * oscillator or something which will keep the time stable for extended  * periods, since then all the other machines can benefit from this.  * For this you would configure a local clock at a higher stratum (say  * 3 or 4) to prevent the server's stratum from falling below here.  */
end_comment

begin_comment
comment|/*  * Definitions  */
end_comment

begin_define
define|#
directive|define
name|NUMUNITS
value|16
end_define

begin_comment
comment|/* 127.127.1.[0-15] */
end_comment

begin_comment
comment|/*  * Some constant values we stick in the peer structure  */
end_comment

begin_define
define|#
directive|define
name|LCLDISPERSION
value|(FP_SECOND/5)
end_define

begin_comment
comment|/* 200 ms dispersion */
end_comment

begin_define
define|#
directive|define
name|LCLROOTDISPERSION
value|(FP_SECOND/5)
end_define

begin_comment
comment|/* 200 ms root dispersion */
end_comment

begin_define
define|#
directive|define
name|LCLPRECISION
value|(-5)
end_define

begin_comment
comment|/* what the heck */
end_comment

begin_define
define|#
directive|define
name|LCLREFID
value|"LCL\0"
end_define

begin_define
define|#
directive|define
name|LCLREFOFFSET
value|20
end_define

begin_comment
comment|/* reftime is 20s behind */
end_comment

begin_define
define|#
directive|define
name|LCLHSREFID
value|0x7f7f0101
end_define

begin_comment
comment|/* 127.127.1.1 refid for hi stratum */
end_comment

begin_comment
comment|/*  * Description of clock  */
end_comment

begin_define
define|#
directive|define
name|LCLDESCRIPTION
value|"Free running against local system clock"
end_define

begin_comment
comment|/*  * Local clock unit control structure.  */
end_comment

begin_struct
struct|struct
name|lclunit
block|{
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
comment|/* associated peer structure */
name|u_char
name|status
decl_stmt|;
comment|/* clock status */
name|u_char
name|lastevent
decl_stmt|;
comment|/* last clock event */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number */
name|u_char
name|unused
decl_stmt|;
name|U_LONG
name|lastupdate
decl_stmt|;
comment|/* last time data received */
name|U_LONG
name|polls
decl_stmt|;
comment|/* number of polls */
name|U_LONG
name|timestarted
decl_stmt|;
comment|/* time we started this */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data space for the unit structures.  Note that we allocate these on  * the fly, but never give them back.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lclunit
modifier|*
name|lclunits
index|[
name|NUMUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|unitinuse
index|[
name|NUMUNITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|l_fp
name|sys_clock_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * local_init - initialize internal local clock driver data  */
end_comment

begin_function
specifier|static
name|void
name|local_init
parameter_list|()
block|{
comment|/* 	 * Just zero the data arrays 	 */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lclunits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|lclunits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|unitinuse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|unitinuse
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * local_start - start up a local reference clock  */
end_comment

begin_function
specifier|static
name|int
name|local_start
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|lclunit
modifier|*
name|lcl
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NUMUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock: unit number %d invalid (max 15)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock: unit number %d in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Looks like this might succeed.  Find memory for the structure. 	 * Look to see if there are any unused ones, if not we malloc() 	 * one. 	 */
if|if
condition|(
name|lclunits
index|[
name|unit
index|]
operator|!=
literal|0
condition|)
block|{
name|lcl
operator|=
name|lclunits
index|[
name|unit
index|]
expr_stmt|;
comment|/* The one we want is okay */
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMUNITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|unitinuse
index|[
name|i
index|]
operator|&&
name|lclunits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|NUMUNITS
condition|)
block|{
comment|/* 			 * Reclaim this one 			 */
name|lcl
operator|=
name|lclunits
index|[
name|i
index|]
expr_stmt|;
name|lclunits
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lcl
operator|=
operator|(
expr|struct
name|lclunit
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lclunit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lcl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lclunit
argument_list|)
argument_list|)
expr_stmt|;
name|lclunits
index|[
name|unit
index|]
operator|=
name|lcl
expr_stmt|;
comment|/* 	 * Set up the structure 	 */
name|lcl
operator|->
name|peer
operator|=
name|peer
expr_stmt|;
name|lcl
operator|->
name|unit
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|lcl
operator|->
name|timestarted
operator|=
name|lcl
operator|->
name|lastupdate
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * That was easy.  Diddle the peer variables and return success. 	 */
name|peer
operator|->
name|precision
operator|=
name|LCLPRECISION
expr_stmt|;
name|peer
operator|->
name|rootdelay
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|rootdispersion
operator|=
name|LCLROOTDISPERSION
expr_stmt|;
name|peer
operator|->
name|stratum
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
if|if
condition|(
name|unit
operator|<=
literal|1
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|peer
operator|->
name|refid
argument_list|,
name|LCLREFID
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|peer
operator|->
name|refid
operator|=
name|htonl
argument_list|(
name|LCLHSREFID
argument_list|)
expr_stmt|;
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * local_shutdown - shut down a local clock  */
end_comment

begin_function
specifier|static
name|void
name|local_shutdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
if|if
condition|(
name|unit
operator|>=
name|NUMUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock: INTERNAL ERROR, unit number %d invalid (max 15)"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock: INTERNAL ERROR, unit number %d not in use"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|unitinuse
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * local_poll - called by the transmit procedure  */
end_comment

begin_function
specifier|static
name|void
name|local_poll
parameter_list|(
name|unit
parameter_list|,
name|peer
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|peer
modifier|*
name|peer
decl_stmt|;
block|{
name|l_fp
name|off
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NUMUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock poll: INTERNAL: unit %d invalid"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock poll: INTERNAL: unit %d unused"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|peer
operator|!=
name|lclunits
index|[
name|unit
index|]
operator|->
name|peer
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock poll: INTERNAL: peer incorrect for unit %d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Update clock stat counters 	 */
name|lclunits
index|[
name|unit
index|]
operator|->
name|polls
operator|++
expr_stmt|;
name|lclunits
index|[
name|unit
index|]
operator|->
name|lastupdate
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * This is pretty easy.  Give the reference clock support 	 * a zero offset and our fixed dispersion.  Use peer->xmt for 	 * our receive time.  Use peer->xmt - 20 seconds for our 	 * reference time. 	 */
name|off
operator|.
name|l_ui
operator|=
name|off
operator|.
name|l_uf
operator|=
literal|0
expr_stmt|;
name|ts
operator|=
name|peer
operator|->
name|xmt
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|-=
name|LCLREFOFFSET
expr_stmt|;
name|refclock_receive
argument_list|(
name|peer
argument_list|,
operator|&
name|off
argument_list|,
literal|0
argument_list|,
name|LCLDISPERSION
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|peer
operator|->
name|xmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * local_control - set fudge factors, return statistics  */
end_comment

begin_function
specifier|static
name|void
name|local_control
parameter_list|(
name|unit
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|u_int
name|unit
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|in
decl_stmt|;
name|struct
name|refclockstat
modifier|*
name|out
decl_stmt|;
block|{
specifier|extern
name|s_fp
name|drift_comp
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NUMUNITS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local clock: unit %d invalid (max %d)"
argument_list|,
name|unit
argument_list|,
name|NUMUNITS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The time1 fudge factor is the drift compensation register. 	 * The time2 fudge factor is the offset of the system clock from 	 * what the protocol has set it to be. Most useful when SLEWALWAYS 	 * is defined. 	 */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME1
condition|)
name|drift_comp
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|in
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|haveflags
operator|&
name|CLK_HAVETIME2
condition|)
block|{
name|sys_clock_offset
operator|.
name|l_ui
operator|=
name|in
operator|->
name|fudgetime2
operator|.
name|l_ui
expr_stmt|;
name|sys_clock_offset
operator|.
name|l_uf
operator|=
name|in
operator|->
name|fudgetime2
operator|.
name|l_uf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|out
operator|->
name|type
operator|=
name|REFCLK_LOCALCLOCK
expr_stmt|;
name|out
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|haveflags
operator|=
name|CLK_HAVETIME1
expr_stmt|;
name|out
operator|->
name|clockdesc
operator|=
name|LCLDESCRIPTION
expr_stmt|;
name|FPTOLFP
argument_list|(
name|drift_comp
argument_list|,
operator|&
name|out
operator|->
name|fudgetime1
argument_list|)
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|.
name|l_ui
operator|=
name|sys_clock_offset
operator|.
name|l_ui
expr_stmt|;
name|out
operator|->
name|fudgetime2
operator|.
name|l_uf
operator|=
name|sys_clock_offset
operator|.
name|l_uf
expr_stmt|;
name|out
operator|->
name|fudgeval1
operator|=
name|out
operator|->
name|fudgeval2
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lencode
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|lastcode
operator|=
literal|""
expr_stmt|;
name|out
operator|->
name|badformat
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|baddata
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|noresponse
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unitinuse
index|[
name|unit
index|]
condition|)
block|{
name|out
operator|->
name|polls
operator|=
name|lclunits
index|[
name|unit
index|]
operator|->
name|polls
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
name|current_time
operator|-
name|lclunits
index|[
name|unit
index|]
operator|->
name|timestarted
expr_stmt|;
name|out
operator|->
name|lastevent
operator|=
name|lclunits
index|[
name|unit
index|]
operator|->
name|lastevent
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|lclunits
index|[
name|unit
index|]
operator|->
name|status
expr_stmt|;
block|}
else|else
block|{
name|out
operator|->
name|polls
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|timereset
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|currentstatus
operator|=
name|out
operator|->
name|lastevent
operator|=
name|CEVNT_NOMINAL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REFCLOCK */
end_comment

end_unit

