begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ntp_monitor.c,v 3.1 1993/07/06 01:11:21 jbj Exp  * ntp_monitor.c - monitor who is using the xntpd server  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_if.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * I'm still not sure I like what I've done here.  It certainly consumes  * memory like it is going out of style, and also may not be as low  * overhead as I'd imagined.  *  * Anyway, we record statistics based on source address, mode and version  * (for now, anyway.  Check the code).  The receive procedure calls us with  * the incoming rbufp before it does anything else.  *  * Each entry is doubly linked into two lists, a hash table and a  * most-recently-used list.  When a packet arrives it is looked up  * in the hash table.  If found, the statistics are updated and the  * entry relinked at the head of the MRU list.  If not found, a new  * entry is allocated, initialized and linked into both the hash  * table and at the head of the MRU list.  *  * Memory is usually allocated by grabbing a big chunk of new memory  * and cutting it up into littler pieces.  The exception to this when we  * hit the memory limit.  Then we free memory by grabbing entries off  * the tail for the MRU list, unlinking from the hash table, and  * reinitializing.  */
end_comment

begin_comment
comment|/*  * Limits on the number of structures allocated.  This limit is picked  * with the illicit knowlege that we can only return somewhat less  * than 8K bytes in a mode 7 response packet, and that each structure  * will require about 20 bytes of space in the response.  */
end_comment

begin_define
define|#
directive|define
name|MAXMONMEM
value|400
end_define

begin_comment
comment|/* we allocate up to 400 structures */
end_comment

begin_define
define|#
directive|define
name|MONMEMINC
value|40
end_define

begin_comment
comment|/* allocate them 40 at a time */
end_comment

begin_comment
comment|/*  * Hashing stuff  */
end_comment

begin_define
define|#
directive|define
name|MON_HASH_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|MON_HASH_MASK
value|(MON_HASH_SIZE-1)
end_define

begin_define
define|#
directive|define
name|MON_HASH
parameter_list|(
name|addr
parameter_list|)
value|((int)(ntohl((addr))& MON_HASH_MASK))
end_define

begin_comment
comment|/*  * Pointers to the hash table, the MRU list and the count table.  Memory  * for the hash and count tables is only allocated if monitoring is turned on.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to array of hash buckets */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|mon_hash_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Point to hash count stats keeper */
end_comment

begin_decl_stmt
name|struct
name|mon_data
name|mon_mru_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of free structures structures, and counters of free and total  * structures.  The free structures are linked with the hash_next field.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mon_data
modifier|*
name|mon_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mon_free_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of structures on free list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_total_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of structures allocated */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mon_mem_increments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times we've called malloc() */
end_comment

begin_comment
comment|/*  * Initialization state.  We may be monitoring, we may not.  If  * we aren't, we may not even have allocated any memory yet.  */
end_comment

begin_decl_stmt
name|int
name|mon_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mon_have_memory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Imported from the timer module  */
end_comment

begin_decl_stmt
specifier|extern
name|U_LONG
name|current_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mon_getmoremem
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * init_mon - initialize monitoring global data  */
end_comment

begin_function
name|void
name|init_mon
parameter_list|()
block|{
comment|/* 	 * Don't do much of anything here.  We don't allocate memory 	 * until someone explicitly starts us. 	 */
name|mon_enabled
operator|=
literal|0
expr_stmt|;
name|mon_have_memory
operator|=
literal|0
expr_stmt|;
name|mon_free_mem
operator|=
literal|0
expr_stmt|;
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
literal|0
expr_stmt|;
name|mon_hash
operator|=
literal|0
expr_stmt|;
name|mon_hash_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mon_mru_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mon_mru_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_start - start up the monitoring software  */
end_comment

begin_function
name|void
name|mon_start
parameter_list|()
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mon_enabled
condition|)
return|return;
if|if
condition|(
operator|!
name|mon_have_memory
condition|)
block|{
name|mon_hash
operator|=
operator|(
expr|struct
name|mon_data
operator|*
operator|)
name|emalloc
argument_list|(
name|MON_HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mon_data
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mon_hash
argument_list|,
literal|0
argument_list|,
name|MON_HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mon_data
argument_list|)
argument_list|)
expr_stmt|;
name|mon_hash_count
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
name|MON_HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|mon_free_mem
operator|=
literal|0
expr_stmt|;
name|mon_total_mem
operator|=
literal|0
expr_stmt|;
name|mon_mem_increments
operator|=
literal|0
expr_stmt|;
name|mon_free
operator|=
literal|0
expr_stmt|;
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|mon_have_memory
operator|=
literal|1
expr_stmt|;
block|}
name|md
operator|=
name|mon_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MON_HASH_SIZE
condition|;
name|i
operator|++
operator|,
name|md
operator|++
control|)
block|{
name|md
operator|->
name|hash_next
operator|=
name|md
expr_stmt|;
name|md
operator|->
name|hash_prev
operator|=
name|md
expr_stmt|;
operator|*
operator|(
name|mon_hash_count
operator|+
name|i
operator|)
operator|=
literal|0
expr_stmt|;
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_stop - stop the monitoring software  */
end_comment

begin_function
name|void
name|mon_stop
parameter_list|()
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mon_enabled
condition|)
return|return;
comment|/* 	 * Put everything back on the free list 	 */
name|md
operator|=
name|mon_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MON_HASH_SIZE
condition|;
name|i
operator|++
operator|,
name|md
operator|++
control|)
block|{
if|if
condition|(
name|md
operator|->
name|hash_next
operator|!=
name|md
condition|)
block|{
name|md
operator|->
name|hash_prev
operator|->
name|hash_next
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
name|mon_free_mem
operator|+=
operator|*
operator|(
name|mon_hash_count
operator|+
name|i
operator|)
expr_stmt|;
name|md
operator|->
name|hash_next
operator|=
name|md
expr_stmt|;
name|md
operator|->
name|hash_prev
operator|=
name|md
expr_stmt|;
operator|*
operator|(
name|mon_hash_count
operator|+
name|i
operator|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mon_mru_list
operator|.
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * monitor - record stats about this packet  */
end_comment

begin_function
name|void
name|monitor
parameter_list|(
name|rbufp
parameter_list|)
name|struct
name|recvbuf
modifier|*
name|rbufp
decl_stmt|;
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|U_LONG
name|netnum
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|int
name|mode
decl_stmt|;
specifier|register
name|struct
name|mon_data
modifier|*
name|mdhash
decl_stmt|;
if|if
condition|(
operator|!
name|mon_enabled
condition|)
return|return;
name|pkt
operator|=
operator|&
name|rbufp
operator|->
name|recv_pkt
expr_stmt|;
name|netnum
operator|=
name|NSRCADR
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|hash
operator|=
name|MON_HASH
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
name|mode
operator|=
name|PKT_MODE
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|=
operator|(
name|mon_hash
operator|+
name|hash
operator|)
operator|->
name|hash_next
expr_stmt|;
while|while
condition|(
name|md
operator|!=
operator|(
name|mon_hash
operator|+
name|hash
operator|)
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|rmtadr
operator|==
name|netnum
operator|&&
name|md
operator|->
name|mode
operator|==
operator|(
name|u_char
operator|)
name|mode
condition|)
block|{
name|md
operator|->
name|lasttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|++
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
comment|/* 			 * Shuffle him to the head of the 			 * mru list.  What a crock. 			 */
name|md
operator|->
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
name|md
operator|->
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
return|return;
block|}
name|md
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
block|}
comment|/* 	 * If we got here, this is the first we've heard of this 	 * guy.  Get him some memory, either from the free list 	 * or from the tail of the MRU list. 	 */
if|if
condition|(
name|mon_free_mem
operator|==
literal|0
operator|&&
name|mon_total_mem
operator|>=
name|MAXMONMEM
condition|)
block|{
comment|/* 		 * Get it from MRU list 		 */
name|md
operator|=
name|mon_mru_list
operator|.
name|mru_prev
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|->
name|mru_next
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_prev
operator|=
name|md
operator|->
name|mru_prev
expr_stmt|;
name|md
operator|->
name|hash_next
operator|->
name|hash_prev
operator|=
name|md
operator|->
name|hash_prev
expr_stmt|;
name|md
operator|->
name|hash_prev
operator|->
name|hash_next
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
operator|*
operator|(
name|mon_hash_count
operator|+
name|MON_HASH
argument_list|(
name|md
operator|->
name|rmtadr
argument_list|)
operator|)
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mon_free_mem
operator|==
literal|0
condition|)
name|mon_getmoremem
argument_list|()
expr_stmt|;
name|md
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
operator|->
name|hash_next
expr_stmt|;
name|mon_free_mem
operator|--
expr_stmt|;
block|}
comment|/* 	 * Got one, initialize it 	 */
name|md
operator|->
name|lasttime
operator|=
name|md
operator|->
name|firsttime
operator|=
name|current_time
expr_stmt|;
name|md
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|rmtadr
operator|=
name|netnum
expr_stmt|;
name|md
operator|->
name|rmtport
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|md
operator|->
name|mode
operator|=
operator|(
name|u_char
operator|)
name|mode
expr_stmt|;
name|md
operator|->
name|version
operator|=
name|PKT_VERSION
argument_list|(
name|pkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Shuffle him into the hash table, inserting him at the 	 * end.  Also put him on top of the MRU list. 	 */
name|mdhash
operator|=
name|mon_hash
operator|+
name|MON_HASH
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
name|md
operator|->
name|hash_next
operator|=
name|mdhash
expr_stmt|;
name|md
operator|->
name|hash_prev
operator|=
name|mdhash
operator|->
name|hash_prev
expr_stmt|;
name|mdhash
operator|->
name|hash_prev
operator|->
name|hash_next
operator|=
name|md
expr_stmt|;
name|mdhash
operator|->
name|hash_prev
operator|=
name|md
expr_stmt|;
operator|*
operator|(
name|mon_hash_count
operator|+
name|MON_HASH
argument_list|(
name|netnum
argument_list|)
operator|)
operator|+=
literal|1
expr_stmt|;
name|md
operator|->
name|mru_next
operator|=
name|mon_mru_list
operator|.
name|mru_next
expr_stmt|;
name|md
operator|->
name|mru_prev
operator|=
operator|&
name|mon_mru_list
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|->
name|mru_prev
operator|=
name|md
expr_stmt|;
name|mon_mru_list
operator|.
name|mru_next
operator|=
name|md
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mon_getmoremem - get more memory and put it on the free list  */
end_comment

begin_function
specifier|static
name|void
name|mon_getmoremem
parameter_list|()
block|{
specifier|register
name|struct
name|mon_data
modifier|*
name|md
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|mon_data
modifier|*
name|freedata
decl_stmt|;
name|md
operator|=
operator|(
expr|struct
name|mon_data
operator|*
operator|)
name|emalloc
argument_list|(
name|MONMEMINC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mon_data
argument_list|)
argument_list|)
expr_stmt|;
name|freedata
operator|=
name|mon_free
expr_stmt|;
name|mon_free
operator|=
name|md
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MONMEMINC
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|md
operator|->
name|hash_next
operator|=
operator|(
name|md
operator|+
literal|1
operator|)
expr_stmt|;
name|md
operator|++
expr_stmt|;
block|}
comment|/* 	 * md now points at the last.  Link in the rest of the chain. 	 */
name|md
operator|->
name|hash_next
operator|=
name|freedata
expr_stmt|;
name|mon_free_mem
operator|+=
name|MONMEMINC
expr_stmt|;
name|mon_total_mem
operator|+=
name|MONMEMINC
expr_stmt|;
name|mon_mem_increments
operator|++
expr_stmt|;
block|}
end_function

end_unit

