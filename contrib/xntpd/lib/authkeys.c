begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* authkeys.c,v 3.1 1993/07/06 01:07:51 jbj Exp  * authkeys.c - routines to manage the storage of authentication keys  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_malloc.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/*  * Structure to store keys in in the hash table.  */
end_comment

begin_struct
struct|struct
name|savekey
block|{
name|struct
name|savekey
modifier|*
name|next
decl_stmt|;
union|union
block|{
ifdef|#
directive|ifdef
name|DES
name|U_LONG
name|DES_key
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
name|char
name|MD5_key
index|[
literal|32
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|k
union|;
name|U_LONG
name|keyid
decl_stmt|;
name|u_short
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|MD5
name|int
name|keylen
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEY_TRUSTED
value|0x1
end_define

begin_comment
comment|/* this key is trusted */
end_comment

begin_define
define|#
directive|define
name|KEY_KNOWN
value|0x2
end_define

begin_comment
comment|/* this key is known */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DES
end_ifdef

begin_define
define|#
directive|define
name|KEY_DES
value|0x100
end_define

begin_comment
comment|/* this is a DES type key */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_define
define|#
directive|define
name|KEY_MD5
value|0x200
end_define

begin_comment
comment|/* this is a MD5 type key */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The hash table.  This is indexed by the low order bits of the  * keyid.  We make this fairly big for potentially busy servers.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|64
end_define

begin_define
define|#
directive|define
name|HASHMASK
value|((HASHSIZE)-1)
end_define

begin_define
define|#
directive|define
name|KEYHASH
parameter_list|(
name|keyid
parameter_list|)
value|((keyid)& HASHMASK)
end_define

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|key_hash
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authkeynotfound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authkeylookups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authnumkeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authuncached
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authkeyuncached
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authnokey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calls to encrypt with no key */
end_comment

begin_decl_stmt
name|U_LONG
name|authencryptions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authdecryptions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_LONG
name|authdecryptok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Storage for free key structures.  We malloc() such things but  * never free them.  */
end_comment

begin_decl_stmt
name|struct
name|savekey
modifier|*
name|authfreekeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|authnumfreekeys
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MEMINC
value|12
end_define

begin_comment
comment|/* number of new free ones to get at once */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DES
end_ifdef

begin_comment
comment|/*  * Size of the key schedule  */
end_comment

begin_define
define|#
directive|define
name|KEY_SCHED_SIZE
value|128
end_define

begin_comment
comment|/* number of octets to store key schedule */
end_comment

begin_comment
comment|/*  * The zero key, which we always have.  Store the permutted key  * zero in here.  */
end_comment

begin_define
define|#
directive|define
name|ZEROKEY_L
value|0x01010101
end_define

begin_comment
comment|/* odd parity zero key */
end_comment

begin_define
define|#
directive|define
name|ZEROKEY_R
value|0x01010101
end_define

begin_comment
comment|/* right half of same */
end_comment

begin_decl_stmt
name|u_char
name|DESzeroekeys
index|[
name|KEY_SCHED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|DESzerodkeys
index|[
name|KEY_SCHED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|DEScache_ekeys
index|[
name|KEY_SCHED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|DEScache_dkeys
index|[
name|KEY_SCHED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The key cache.  We cache the last key we looked at here.  */
end_comment

begin_decl_stmt
name|U_LONG
name|cache_keyid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|cache_flags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_decl_stmt
name|int
name|cache_keylen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cache_key
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * init_auth - initialize internal data  */
end_comment

begin_function
name|void
name|init_auth
parameter_list|()
block|{
name|U_LONG
name|zerokey
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * Initialize hash table and free list 	 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_hash
argument_list|,
sizeof|sizeof
name|key_hash
argument_list|)
expr_stmt|;
name|cache_flags
operator|=
name|cache_keyid
operator|=
literal|0
expr_stmt|;
name|authnumfreekeys
operator|=
name|authkeynotfound
operator|=
name|authkeylookups
operator|=
literal|0
expr_stmt|;
name|authnumkeys
operator|=
name|authuncached
operator|=
name|authkeyuncached
operator|=
name|authnokey
operator|=
literal|0
expr_stmt|;
name|authencryptions
operator|=
name|authdecryptions
operator|=
name|authdecryptok
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DES
comment|/* 	 * Initialize the zero key 	 */
name|zerokey
index|[
literal|0
index|]
operator|=
name|ZEROKEY_L
expr_stmt|;
name|zerokey
index|[
literal|1
index|]
operator|=
name|ZEROKEY_R
expr_stmt|;
comment|/* could just zero all */
name|DESauth_subkeys
argument_list|(
name|zerokey
argument_list|,
name|DESzeroekeys
argument_list|,
name|DESzerodkeys
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * auth_findkey - find a key in the hash table  */
end_comment

begin_function
name|struct
name|savekey
modifier|*
name|auth_findkey
parameter_list|(
name|keyno
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
return|return
name|sk
return|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * auth_havekey - return whether a key is known  */
end_comment

begin_function
name|int
name|auth_havekey
parameter_list|(
name|keyno
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
operator|(
name|keyno
operator|==
name|cache_keyid
operator|)
condition|)
return|return
literal|1
return|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_KNOWN
condition|)
return|return
literal|1
return|;
else|else
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
name|authkeynotfound
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * authhavekey - return whether a key is known.  Permute and cache  *		 the key as a side effect.  */
end_comment

begin_function
name|int
name|authhavekey
parameter_list|(
name|keyno
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|authkeylookups
operator|++
expr_stmt|;
if|if
condition|(
name|keyno
operator|==
literal|0
operator|||
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
literal|1
return|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
operator|||
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_KNOWN
operator|)
condition|)
block|{
name|authkeynotfound
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cache_keyid
operator|=
name|sk
operator|->
name|keyid
expr_stmt|;
name|cache_flags
operator|=
name|sk
operator|->
name|flags
expr_stmt|;
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_MD5
condition|)
block|{
name|cache_keylen
operator|=
name|sk
operator|->
name|keylen
expr_stmt|;
name|cache_key
operator|=
operator|(
name|char
operator|*
operator|)
name|sk
operator|->
name|k
operator|.
name|MD5_key
expr_stmt|;
comment|/* XXX */
return|return
literal|1
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
name|sk
operator|->
name|flags
operator|&
name|KEY_DES
condition|)
block|{
name|DESauth_subkeys
argument_list|(
name|sk
operator|->
name|k
operator|.
name|DES_key
argument_list|,
name|DEScache_ekeys
argument_list|,
name|DEScache_dkeys
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * auth_moremem - get some more free key structures  */
end_comment

begin_function
name|int
name|auth_moremem
parameter_list|()
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sk
operator|=
operator|(
expr|struct
name|savekey
operator|*
operator|)
name|malloc
argument_list|(
name|MEMINC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|savekey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|MEMINC
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|++
expr_stmt|;
block|}
name|authnumfreekeys
operator|+=
name|MEMINC
expr_stmt|;
return|return
name|authnumfreekeys
return|;
block|}
end_function

begin_comment
comment|/*  * authtrust - declare a key to be trusted/untrusted  */
end_comment

begin_function
name|void
name|authtrust
parameter_list|(
name|keyno
parameter_list|,
name|trust
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
name|int
name|trust
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
operator|&&
operator|!
name|trust
condition|)
return|return;
if|if
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
name|cache_flags
operator|=
name|cache_keyid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trust
condition|)
block|{
name|sk
operator|->
name|flags
operator||=
name|KEY_TRUSTED
expr_stmt|;
return|return;
block|}
name|sk
operator|->
name|flags
operator|&=
operator|~
name|KEY_TRUSTED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_KNOWN
operator|)
condition|)
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|skp
decl_stmt|;
name|skp
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|skp
operator|==
name|sk
condition|)
block|{
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|skp
operator|->
name|next
operator|!=
name|sk
condition|)
name|skp
operator|=
name|skp
operator|->
name|next
expr_stmt|;
name|skp
operator|->
name|next
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_TRUSTED
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * authistrusted - determine whether a key is trusted  */
end_comment

begin_function
name|int
name|authistrusted
parameter_list|(
name|keyno
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
if|if
condition|(
name|keyno
operator|==
name|cache_keyid
condition|)
return|return
operator|(
operator|(
name|cache_flags
operator|&
name|KEY_TRUSTED
operator|)
operator|!=
literal|0
operator|)
return|;
name|authkeyuncached
operator|++
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
break|break;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sk
operator|==
literal|0
operator|||
operator|!
operator|(
name|sk
operator|->
name|flags
operator|&
name|KEY_TRUSTED
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DES
end_ifdef

begin_comment
comment|/*  * DESauth_setkey - set a key into the key array  */
end_comment

begin_function
name|void
name|DESauth_setkey
parameter_list|(
name|keyno
parameter_list|,
name|key
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
specifier|const
name|U_LONG
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|0
index|]
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|1
index|]
expr_stmt|;
name|sk
operator|->
name|flags
operator||=
name|KEY_KNOWN
operator||
name|KEY_DES
expr_stmt|;
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
name|cache_flags
operator|=
name|cache_keyid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|0
index|]
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|sk
operator|->
name|k
operator|.
name|DES_key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|1
index|]
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_KNOWN
operator||
name|KEY_DES
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MD5
end_ifdef

begin_function
name|void
name|MD5auth_setkey
parameter_list|(
name|keyno
parameter_list|,
name|key
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
specifier|const
name|U_LONG
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
comment|/* 	 * See if we already have the key.  If so just stick in the 	 * new value. 	 */
name|sk
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|keyno
operator|==
name|sk
operator|->
name|keyid
condition|)
block|{
name|strncpy
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|->
name|keylen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
condition|)
name|sk
operator|->
name|keylen
operator|=
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
expr_stmt|;
name|sk
operator|->
name|flags
operator||=
name|KEY_KNOWN
operator||
name|KEY_MD5
expr_stmt|;
if|if
condition|(
name|cache_keyid
operator|==
name|keyno
condition|)
name|cache_flags
operator|=
name|cache_keyid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
comment|/* 	 * Need to allocate new structure.  Do it. 	 */
if|if
condition|(
name|authnumfreekeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|auth_moremem
argument_list|()
operator|==
literal|0
condition|)
return|return;
block|}
name|sk
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumfreekeys
operator|--
expr_stmt|;
name|strncpy
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sk
operator|->
name|keylen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|)
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
condition|)
name|sk
operator|->
name|keylen
operator|=
sizeof|sizeof
argument_list|(
name|sk
operator|->
name|k
operator|.
name|MD5_key
argument_list|)
expr_stmt|;
name|sk
operator|->
name|keyid
operator|=
name|keyno
expr_stmt|;
name|sk
operator|->
name|flags
operator|=
name|KEY_KNOWN
operator||
name|KEY_MD5
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
expr_stmt|;
name|key_hash
index|[
name|KEYHASH
argument_list|(
name|keyno
argument_list|)
index|]
operator|=
name|sk
expr_stmt|;
name|authnumkeys
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * auth_delkeys - delete all known keys, in preparation for rereading  *		  the keys file (presumably)  */
end_comment

begin_function
name|void
name|auth_delkeys
parameter_list|()
block|{
specifier|register
name|struct
name|savekey
modifier|*
name|sk
decl_stmt|;
specifier|register
name|struct
name|savekey
modifier|*
modifier|*
name|skp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|skp
operator|=
operator|&
operator|(
name|key_hash
index|[
name|i
index|]
operator|)
expr_stmt|;
name|sk
operator|=
name|key_hash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|sk
operator|!=
literal|0
condition|)
block|{
name|sk
operator|->
name|flags
operator|&=
operator|~
operator|(
name|KEY_KNOWN
ifdef|#
directive|ifdef
name|MD5
operator||
name|KEY_MD5
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DES
operator||
name|KEY_DES
endif|#
directive|endif
operator|)
expr_stmt|;
if|if
condition|(
name|sk
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
operator|*
name|skp
operator|=
name|sk
operator|->
name|next
expr_stmt|;
name|authnumkeys
operator|--
expr_stmt|;
name|sk
operator|->
name|next
operator|=
name|authfreekeys
expr_stmt|;
name|authfreekeys
operator|=
name|sk
expr_stmt|;
name|authnumfreekeys
operator|++
expr_stmt|;
name|sk
operator|=
operator|*
name|skp
expr_stmt|;
block|}
else|else
block|{
name|skp
operator|=
operator|&
operator|(
name|sk
operator|->
name|next
operator|)
expr_stmt|;
name|sk
operator|=
name|sk
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  auth1crypt - support for two stage encryption, part 1.  */
end_comment

begin_function
name|void
name|auth1crypt
parameter_list|(
name|keyno
parameter_list|,
name|pkt
parameter_list|,
name|length
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
name|U_LONG
modifier|*
name|pkt
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of all encrypted data */
block|{
if|if
condition|(
name|keyno
operator|&&
name|keyno
operator|!=
name|cache_keyid
condition|)
block|{
name|authkeyuncached
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
operator|!
name|keyno
operator|||
operator|(
name|cache_flags
operator|&
name|KEY_DES
operator|)
condition|)
block|{
name|DESauth1crypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
block|{
name|MD5auth1crypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  auth1crypt - support for two stage encryption, part 1.  */
end_comment

begin_function
name|int
name|auth2crypt
parameter_list|(
name|keyno
parameter_list|,
name|pkt
parameter_list|,
name|length
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
name|U_LONG
modifier|*
name|pkt
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* total length of encrypted area */
block|{
if|if
condition|(
name|keyno
operator|&&
name|keyno
operator|!=
name|cache_keyid
condition|)
block|{
name|authkeyuncached
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
operator|!
name|keyno
operator|||
operator|(
name|cache_flags
operator|&
name|KEY_DES
operator|)
condition|)
return|return
name|DESauth2crypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
return|return
name|MD5auth2crypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|authencrypt
parameter_list|(
name|keyno
parameter_list|,
name|pkt
parameter_list|,
name|length
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
name|U_LONG
modifier|*
name|pkt
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of encrypted portion of packet */
block|{
name|int
name|sendlength
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|keyno
operator|&&
name|keyno
operator|!=
name|cache_keyid
condition|)
block|{
name|authkeyuncached
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
operator|!
name|keyno
operator|||
operator|(
name|cache_flags
operator|&
name|KEY_DES
operator|)
condition|)
return|return
name|sendlength
operator|=
name|DESauthencrypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
return|return
name|MD5authencrypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|authdecrypt
parameter_list|(
name|keyno
parameter_list|,
name|pkt
parameter_list|,
name|length
parameter_list|)
name|U_LONG
name|keyno
decl_stmt|;
name|U_LONG
modifier|*
name|pkt
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of variable data in octets */
block|{
if|if
condition|(
name|keyno
operator|&&
operator|(
name|keyno
operator|!=
name|cache_keyid
operator|)
condition|)
block|{
name|authkeyuncached
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|authhavekey
argument_list|(
name|keyno
argument_list|)
condition|)
block|{
name|authnokey
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|DES
if|if
condition|(
operator|!
name|keyno
operator|||
operator|(
name|cache_flags
operator|&
name|KEY_DES
operator|)
condition|)
return|return
name|DESauthdecrypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MD5
if|if
condition|(
name|cache_flags
operator|&
name|KEY_MD5
condition|)
return|return
name|MD5authdecrypt
argument_list|(
name|keyno
argument_list|,
name|pkt
argument_list|,
name|length
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

