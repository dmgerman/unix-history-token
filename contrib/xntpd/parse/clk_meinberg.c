begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
name|defined
argument_list|(
name|REFCLOCK
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|PARSE
argument_list|)
operator|||
name|defined
argument_list|(
name|PARSEPPS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CLOCK_MEINBERG
argument_list|)
end_if

begin_comment
comment|/*  * /src/NTP/REPOSITORY/v3/parse/clk_meinberg.c,v 3.11 1994/01/25 19:05:10 kardel Exp  *    * clk_meinberg.c,v 3.11 1994/01/25 19:05:10 kardel Exp  *  * Meinberg clock support  *  * Copyright (c) 1992,1993,1994  * Frank Kardel Friedrich-Alexander Universitaet Erlangen-Nuernberg  *                                      * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"sys/errno.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_comment
comment|/*  * The Meinberg receiver every second sends a datagram of the following form  * (Standard Format)  *   *<STX>D:<dd>.<mm>.<yy>;T:<w>;U:<hh>:<mm>:<ss>;<S><F><D><A><ETX>  * pos:  0  00 00 0 00 0 11 111 1 111 12 2 22 2 22 2 2  2  3  3   3  *       1  23 45 6 78 9 01 234 5 678 90 1 23 4 56 7 8  9  0  1   2  *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<S>             = '#' if never synced since powerup else ' ' for DCF U/A 31  *                   '#' if not PZF sychronisation available else ' ' for PZF 535  *<F>             = '*' if time comes from internal quartz else ' '  *<D>             = 'S' if daylight saving time is active else ' '  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *  * For the university of Erlangen a special format was implemented to support  * LEAP announcement and anouncement of alternate antenna.  *  * Version for UNI-ERLANGEN Software is: PZFUERL V4.6 (Meinberg)  *  * The use of this software release (or higher) is *ABSOLUTELY*  * recommended (ask for PZFUERL version as some minor HW fixes have  * been introduced) due to the LEAP second support and UTC indication.  * The standard timecode does not indicate when the timecode is in  * UTC (by front panel configuration) thus we have no chance to find  * the correct utc offset. For the standard format do not ever use  * UTC display as this is not detectable in the time code !!!  *  *<STX><dd>.<mm>.<yy>;<w>;<hh>:<mm>:<ss>;<U><S><F><D><A><L><R><ETX>  * pos:  0   00 0 00 0 00 11 1 11 11 1 11 2 22 22 2  2  2  2  2  3  3   3  *       1   23 4 56 7 89 01 2 34 56 7 89 0 12 34 5  6  7  8  9  0  1   2  *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<U>             = 'U' UTC time display  *<S>             = '#' if never synced since powerup else ' ' for DCF U/A 31  *                   '#' if not PZF sychronisation available else ' ' for PZF 535  *<F>             = '*' if time comes from internal quartz else ' '  *<D>             = 'S' if daylight saving time is active else ' '  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *<L>             = 'A' LEAP second announcement  *<R>             = 'R' alternate antenna  *  * Meinberg GPS166 receiver  *  * You must get the Uni-Erlangen firmware for the GPS receiver support  * to work to full satisfaction !  *  *<STX><dd>.<mm>.<yy>;<w>;<hh>:<mm>:<ss>;<+/-><00:00>;<U><S><F><D><A><L><R><L>;<position...><ETX>  *  *        000000000111111111122222222223333333333444444444455555555556666666  *        123456789012345678901234567890123456789012345678901234567890123456  *     \x0209.07.93; 5; 08:48:26; +00:00;        ; 49.5736N  11.0280E  373m\x03  *  *   *<STX>           = '\002' ASCII start of text  *<ETX>           = '\003' ASCII end of text  *<dd>,<mm>,<yy>  = day, month, year(2 digits!!)  *<w>             = day of week (sunday= 0)  *<hh>,<mm>,<ss>  = hour, minute, second  *<+/->,<00:00>   = offset to UTC  *<S>             = '#' if never synced since powerup else ' ' for DCF U/A 31  *                   '#' if not PZF sychronisation available else ' ' for PZF 535  *<U>             = 'U' UTC time display  *<F>             = '*' if time comes from internal quartz else ' '  *<D>             = 'S' if daylight saving time is active else ' '  *<A>             = '!' during the hour preceeding an daylight saving time  *                       start/end change  *<L>             = 'A' LEAP second announcement  *<R>             = 'R' alternate antenna (reminiscent of PZF535) usually ' '  *<L>		   = 'L' on 23:59:60  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|format
name|meinberg_fmt
index|[]
init|=
block|{
block|{
block|{
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|2
block|}
block|,
block|{
literal|9
block|,
literal|2
block|}
block|,
block|{
literal|18
block|,
literal|2
block|}
block|,
block|{
literal|21
block|,
literal|2
block|}
block|,
block|{
literal|24
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|1
block|}
block|,
block|{
literal|27
block|,
literal|4
block|}
block|,
block|{
literal|29
block|,
literal|1
block|}
block|,     }
block|,
literal|"\2D:  .  .  ;T: ;U:  .  .  ;    \3"
block|,
literal|0
block|}
block|,
block|{
comment|/* special extended FAU Erlangen extended format */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|2
block|}
block|,
block|{
literal|17
block|,
literal|2
block|}
block|,
block|{
literal|20
block|,
literal|2
block|}
block|,
block|{
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|25
block|,
literal|4
block|}
block|,
block|{
literal|27
block|,
literal|1
block|}
block|,     }
block|,
literal|"\2  .  .  ;  ;   :  :  ;        \3"
block|,
name|MBG_EXTENDED
block|}
block|,
block|{
comment|/* special extended FAU Erlangen GPS format */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|2
block|}
block|,
block|{
literal|14
block|,
literal|2
block|}
block|,
block|{
literal|17
block|,
literal|2
block|}
block|,
block|{
literal|20
block|,
literal|2
block|}
block|,
block|{
literal|11
block|,
literal|1
block|}
block|,
block|{
literal|32
block|,
literal|8
block|}
block|,
block|{
literal|35
block|,
literal|1
block|}
block|,
block|{
literal|25
block|,
literal|2
block|}
block|,
block|{
literal|28
block|,
literal|2
block|}
block|,
block|{
literal|24
block|,
literal|1
block|}
block|}
block|,
literal|"\2  .  .  ;  ;   :  :  ;    :  ;        ;   .         .       "
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|cvt_meinberg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|LONG
name|cvt_mgps
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|clockformat_t
name|clock_meinberg
index|[]
init|=
block|{
block|{
name|cvt_meinberg
block|,
comment|/* Meinberg conversion */
name|syn_simple
block|,
comment|/* easy time stamps for RS232 (fallback) */
name|pps_simple
block|,
comment|/* easy PPS monitoring */
operator|(
name|unsigned
name|LONG
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
comment|/* no time code synthesizer monitoring */
operator|(
name|void
operator|*
operator|)
operator|&
name|meinberg_fmt
index|[
literal|0
index|]
block|,
comment|/* conversion configuration */
literal|"Meinberg Standard"
block|,
comment|/* Meinberg simple format - beware */
literal|32
block|,
comment|/* string buffer */
name|F_START
operator||
name|F_END
operator||
name|SYNC_START
operator||
name|SYNC_ONE
block|,
comment|/* paket START/END delimiter, START synchronisation, PPS ONE sampling */
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|'\2'
block|,
literal|'\3'
block|,
literal|'\0'
block|}
block|,
block|{
name|cvt_meinberg
block|,
comment|/* Meinberg conversion */
name|syn_simple
block|,
comment|/* easy time stamps for RS232 (fallback) */
name|pps_simple
block|,
comment|/* easy PPS monitoring */
operator|(
name|unsigned
name|LONG
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
comment|/* no time code synthesizer monitoring */
operator|(
name|void
operator|*
operator|)
operator|&
name|meinberg_fmt
index|[
literal|1
index|]
block|,
comment|/* conversion configuration */
literal|"Meinberg Extended"
block|,
comment|/* Meinberg enhanced format */
literal|32
block|,
comment|/* string buffer */
name|F_START
operator||
name|F_END
operator||
name|SYNC_START
operator||
name|SYNC_ONE
block|,
comment|/* paket START/END delimiter, START synchronisation, PPS ONE sampling  */
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|'\2'
block|,
literal|'\3'
block|,
literal|'\0'
block|}
block|,
block|{
name|cvt_mgps
block|,
comment|/* Meinberg GPS166 conversion */
name|syn_simple
block|,
comment|/* easy time stamps for RS232 (fallback) */
name|pps_simple
block|,
comment|/* easy PPS monitoring */
operator|(
name|unsigned
name|LONG
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
block|,
comment|/* no time code synthesizer monitoring */
operator|(
name|void
operator|*
operator|)
operator|&
name|meinberg_fmt
index|[
literal|2
index|]
block|,
comment|/* conversion configuration */
literal|"Meinberg GPS Extended"
block|,
comment|/* Meinberg FAU GPS format */
literal|70
block|,
comment|/* string buffer */
name|F_START
operator||
name|F_END
operator||
name|SYNC_START
operator||
name|SYNC_ONE
block|,
comment|/* paket START/END delimiter, START synchronisation, PPS ONE sampling  */
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|'\2'
block|,
literal|'\3'
block|,
literal|'\0'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cvt_meinberg  *  * convert simple type format  */
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|cvt_meinberg
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|format
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|format
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Strok
argument_list|(
name|buffer
argument_list|,
name|format
operator|->
name|fixed_string
argument_list|)
condition|)
block|{
return|return
name|CVT_NONE
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|day
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|month
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|year
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|hour
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|minute
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|second
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
name|char
modifier|*
name|f
init|=
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_FLAGS
index|]
operator|.
name|offset
index|]
decl_stmt|;
name|clock
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|clock
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
comment|/* 	   * in the extended timecode format we have also the 	   * indication that the timecode is in UTC 	   * for compatibilty reasons we start at the USUAL 	   * offset (POWERUP flag) and know that the UTC indication 	   * is the character before the powerup flag 	   */
if|if
condition|(
operator|(
name|format
operator|->
name|flags
operator|&
name|MBG_EXTENDED
operator|)
operator|&&
operator|(
name|f
index|[
operator|-
literal|1
index|]
operator|==
literal|'U'
operator|)
condition|)
block|{
comment|/* 	       * timecode is in UTC 	       */
name|clock
operator|->
name|utcoffset
operator|=
literal|0
expr_stmt|;
comment|/* UTC */
name|clock
operator|->
name|flags
operator||=
name|PARSEB_UTC
expr_stmt|;
block|}
else|else
block|{
comment|/* 	       * only calculate UTC offset if MET/MED is in time code 	       * or we have the old time code format, where we do not 	       * know whether it is UTC time or MET/MED 	       * pray that nobody switches to UTC in the standard time code 	       * ROMS !!!! 	       */
switch|switch
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
condition|)
block|{
case|case
literal|' '
case|:
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|1
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* MET */
break|break;
case|case
literal|'S'
case|:
name|clock
operator|->
name|utcoffset
operator|=
operator|-
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* MED */
break|break;
default|default:
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
block|}
comment|/* 	   * gather status flags 	   */
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
operator|==
literal|'S'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_POWERUP
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|3
index|]
operator|==
literal|'!'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
if|if
condition|(
name|format
operator|->
name|flags
operator|&
name|MBG_EXTENDED
condition|)
block|{
name|clock
operator|->
name|flags
operator||=
name|PARSEB_S_LEAP
expr_stmt|;
name|clock
operator|->
name|flags
operator||=
name|PARSEB_S_ANTENNA
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|4
index|]
operator|==
literal|'A'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAP
expr_stmt|;
if|if
condition|(
name|f
index|[
literal|5
index|]
operator|==
literal|'R'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_ALTERNATE
expr_stmt|;
block|}
return|return
name|CVT_OK
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * cvt_mgps  *  * convert Meinberg GPS format  */
end_comment

begin_function
specifier|static
name|unsigned
name|LONG
name|cvt_mgps
parameter_list|(
name|buffer
parameter_list|,
name|size
parameter_list|,
name|format
parameter_list|,
name|clock
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|format
decl_stmt|;
specifier|register
name|clocktime_t
modifier|*
name|clock
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Strok
argument_list|(
name|buffer
argument_list|,
name|format
operator|->
name|fixed_string
argument_list|)
condition|)
block|{
return|return
name|CVT_NONE
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|day
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_DAY
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|month
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MONTH
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|year
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_YEAR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|hour
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_HOUR
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|minute
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_MIN
index|]
operator|.
name|length
argument_list|)
operator|||
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|second
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_SEC
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
name|LONG
name|h
decl_stmt|;
name|char
modifier|*
name|f
init|=
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_FLAGS
index|]
operator|.
name|offset
index|]
decl_stmt|;
name|clock
operator|->
name|flags
operator|=
name|PARSEB_S_LEAP
operator||
name|PARSEB_S_POSITION
expr_stmt|;
name|clock
operator|->
name|usecond
operator|=
literal|0
expr_stmt|;
comment|/* 	   * calculate UTC offset 	   */
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCHOFFSET
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|h
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_UTCHOFFSET
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
else|else
block|{
if|if
condition|(
name|Stoi
argument_list|(
operator|&
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCMOFFSET
index|]
operator|.
name|offset
index|]
argument_list|,
operator|&
name|clock
operator|->
name|utcoffset
argument_list|,
name|format
operator|->
name|field_offsets
index|[
name|O_UTCMOFFSET
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
return|return
name|CVT_FAIL
operator||
name|CVT_BADFMT
return|;
block|}
name|clock
operator|->
name|utcoffset
operator|+=
name|TIMES60
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_UTCSOFFSET
index|]
operator|.
name|offset
index|]
operator|!=
literal|'-'
condition|)
block|{
name|clock
operator|->
name|utcoffset
operator|=
operator|-
name|clock
operator|->
name|utcoffset
expr_stmt|;
block|}
block|}
comment|/* 	   * gather status flags 	   */
if|if
condition|(
name|buffer
index|[
name|format
operator|->
name|field_offsets
index|[
name|O_ZONE
index|]
operator|.
name|offset
index|]
operator|==
literal|'S'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_DST
expr_stmt|;
if|if
condition|(
operator|(
name|f
index|[
literal|0
index|]
operator|==
literal|'U'
operator|)
operator|||
operator|(
name|clock
operator|->
name|utcoffset
operator|==
literal|0
operator|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_UTC
expr_stmt|;
comment|/* 	   * no sv's seen - no time& position 	   */
if|if
condition|(
name|f
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_POWERUP
expr_stmt|;
comment|/* 	   * at least one sv seen - time (for last position) 	   */
if|if
condition|(
name|f
index|[
literal|2
index|]
operator|==
literal|'*'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_NOSYNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|clock
operator|->
name|flags
operator|&
name|PARSEB_POWERUP
operator|)
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_POSITION
expr_stmt|;
comment|/* 	   * oncoming zone switch 	   */
if|if
condition|(
name|f
index|[
literal|4
index|]
operator|==
literal|'!'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_ANNOUNCE
expr_stmt|;
comment|/* 	   * oncoming leap second 	   */
if|if
condition|(
name|f
index|[
literal|5
index|]
operator|==
literal|'A'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAP
expr_stmt|;
comment|/* 	   * this is the leap second 	   */
if|if
condition|(
name|f
index|[
literal|7
index|]
operator|==
literal|'L'
condition|)
name|clock
operator|->
name|flags
operator||=
name|PARSEB_LEAPSECOND
expr_stmt|;
return|return
name|CVT_OK
return|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(PARSE)&& defined(CLOCK_MEINBERG) */
end_comment

begin_comment
comment|/*  * History:  *  * clk_meinberg.c,v  * Revision 3.11  1994/01/25  19:05:10  kardel  * 94/01/23 reconcilation  *  * Revision 3.10  1994/01/23  17:21:54  kardel  * 1994 reconcilation  *  * Revision 3.9  1993/10/30  09:44:38  kardel  * conditional compilation flag cleanup  *  * Revision 3.8  1993/10/22  14:27:48  kardel  * Oct. 22nd 1993 reconcilation  *  * Revision 3.7  1993/10/09  15:01:30  kardel  * file structure unified  *  * Revision 3.6  1993/10/03  19:10:43  kardel  * restructured I/O handling  *  * Revision 3.5  1993/09/27  21:08:04  kardel  * utcoffset now in seconds  *  * Revision 3.4  1993/09/26  23:40:22  kardel  * new parse driver logic  *  * Revision 3.3  1993/08/18  09:29:32  kardel  * GPS format is somewhat variable length - variable length part holds position  *  * Revision 3.2  1993/07/09  11:37:16  kardel  * Initial restructured version + GPS support  *  * Revision 3.1  1993/07/06  10:00:17  kardel  * DCF77 driver goes generic...  *  */
end_comment

end_unit

