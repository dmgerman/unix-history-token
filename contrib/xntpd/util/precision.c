begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|DEFAULT_SYS_PRECISION
value|-99
end_define

begin_function_decl
name|int
name|default_get_precision
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"log2(precision) = %d\n"
argument_list|,
name|default_get_precision
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the precision of the system clock by watching how the current time  * changes as we read it repeatedly.  *  * struct timeval is only good to 1us, which may cause problems as machines  * get faster, but until then the logic goes:  *  * If a machine has precision (i.e. accurate timing info)> 1us, then it will  * probably use the "unused" low order bits as a counter (to force time to be  * a strictly increaing variable), incrementing it each time any process  * requests the time [[ or maybe time will stand still ? ]].  *  * SO: the logic goes:  *  *      IF      the difference from the last time is "small" (< MINSTEP)  *      THEN    this machine is "counting" with the low order bits  *      ELIF    this is not the first time round the loop  *      THEN    this machine *WAS* counting, and has now stepped  *      ELSE    this machine has precision< time to read clock  *  * SO: if it exits on the first loop, assume "full accuracy" (1us)  *     otherwise, take the log2(observered difference, rounded UP)  *  * MINLOOPS> 1 ensures that even if there is a STEP between the initial call  * and the first loop, it doesn't stop too early.  * Making it even greater allows MINSTEP to be reduced, assuming that the  * chance of MINSTEP-1 other processes getting in and calling gettimeofday  * between this processes's calls.  * Reducing MINSTEP may be necessary as this sets an upper bound for the time  * to actually call gettimeofday.  */
end_comment

begin_define
define|#
directive|define
name|DUSECS
value|1000000
end_define

begin_define
define|#
directive|define
name|HUSECS
value|(1024 * 1024)
end_define

begin_define
define|#
directive|define
name|MINSTEP
value|5
end_define

begin_comment
comment|/* some systems increment uS on each call */
end_comment

begin_comment
comment|/* Don't use "1" as some *other* process may read too*/
end_comment

begin_comment
comment|/*We assume no system actually *ANSWERS* in this time*/
end_comment

begin_define
define|#
directive|define
name|MAXLOOPS
value|HUSECS
end_define

begin_comment
comment|/* Assume precision< .1s ! */
end_comment

begin_function
name|int
name|default_get_precision
parameter_list|()
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|timezone
name|tzp
decl_stmt|;
name|long
name|last
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|diff
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|minsteps
init|=
literal|2
decl_stmt|;
comment|/* need at least this many steps */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
operator|--
name|minsteps
init|;
name|i
operator|<
name|MAXLOOPS
condition|;
name|i
operator|++
control|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|tzp
argument_list|)
expr_stmt|;
name|diff
operator|=
name|tp
operator|.
name|tv_usec
operator|-
name|last
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|+=
name|DUSECS
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|MINSTEP
condition|)
if|if
condition|(
name|minsteps
operator|--
operator|<=
literal|0
condition|)
break|break;
name|last
operator|=
name|tp
operator|.
name|tv_usec
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"precision calculation given %dus after %d loop%s\n"
argument_list|,
name|diff
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|diff
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXLOOPS
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* No STEP, so FAST machine */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|diff
operator|=
literal|1
expr_stmt|;
comment|/* time to read clock>= precision */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|val
operator|=
name|HUSECS
init|;
name|val
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|val
operator|>>=
literal|1
control|)
if|if
condition|(
name|diff
operator|>=
name|val
condition|)
return|return
name|i
return|;
return|return
name|DEFAULT_SYS_PRECISION
comment|/* Something's BUST, so lie ! */
return|;
block|}
end_function

end_unit

