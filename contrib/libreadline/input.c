begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input.c -- character input functions for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1994 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|M_UNIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SELECT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD_IN_SYS_IOCTL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_comment
comment|/* What kind of non-blocking I/O do we have? */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|O_NDELAY
value|O_NONBLOCK
end_define

begin_comment
comment|/* Posix style */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions imported from other files in the library. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables and functions from macro.c. */
end_comment

begin_function_decl
specifier|extern
name|void
name|_rl_add_macro_char
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_with_macro_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_rl_next_macro_key
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|_rl_defining_kbd_macro
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
name|_rl_vi_set_last
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_rl_vi_textmod_command
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|,
modifier|*
name|rl_outstream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Function
modifier|*
name|rl_last_func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_key_sequence_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_pending_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_editing_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Keymap
name|_rl_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_rl_convert_meta_chars_to_ascii
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GO32__ */
end_comment

begin_comment
comment|/* Non-null means it is a pointer to a function to run while waiting for    character input. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_event_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|rl_getc_function
init|=
name|rl_getc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Input Buffering       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pop_index
decl_stmt|,
name|push_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ibuffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ibuffer_len
init|=
sizeof|sizeof
argument_list|(
name|ibuffer
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|any_typein
value|(push_index != pop_index)
end_define

begin_function
name|int
name|_rl_any_typein
parameter_list|()
block|{
return|return
name|any_typein
return|;
block|}
end_function

begin_comment
comment|/* Add KEY to the buffer of characters to be read. */
end_comment

begin_function
name|int
name|rl_stuff_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|==
name|EOF
condition|)
block|{
name|key
operator|=
name|NEWLINE
expr_stmt|;
name|rl_pending_input
operator|=
name|EOF
expr_stmt|;
block|}
name|ibuffer
index|[
name|push_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|push_index
operator|>=
name|ibuffer_len
condition|)
name|push_index
operator|=
literal|0
expr_stmt|;
return|return
name|push_index
return|;
block|}
end_function

begin_comment
comment|/* Make C be the next command to be executed. */
end_comment

begin_function
name|int
name|rl_execute_next
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|rl_pending_input
operator|=
name|c
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of space available in the    buffer for stuffing characters. */
end_comment

begin_function
specifier|static
name|int
name|ibuffer_space
parameter_list|()
block|{
if|if
condition|(
name|pop_index
operator|>
name|push_index
condition|)
return|return
operator|(
name|pop_index
operator|-
name|push_index
operator|)
return|;
else|else
return|return
operator|(
name|ibuffer_len
operator|-
operator|(
name|push_index
operator|-
name|pop_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a key from the buffer of characters to be read.    Return the key in KEY.    Result is KEY if there was a key, or 0 if there wasn't. */
end_comment

begin_function
specifier|static
name|int
name|rl_get_char
parameter_list|(
name|key
parameter_list|)
name|int
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|push_index
operator|==
name|pop_index
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|key
operator|=
name|ibuffer
index|[
name|pop_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pop_index
operator|>=
name|ibuffer_len
condition|)
name|pop_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stuff KEY into the *front* of the input buffer.    Returns non-zero if successful, zero if there is    no space left in the buffer. */
end_comment

begin_function
specifier|static
name|int
name|rl_unget_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|ibuffer_space
argument_list|()
condition|)
block|{
name|pop_index
operator|--
expr_stmt|;
if|if
condition|(
name|pop_index
operator|<
literal|0
condition|)
name|pop_index
operator|=
name|ibuffer_len
operator|-
literal|1
expr_stmt|;
name|ibuffer
index|[
name|pop_index
index|]
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If a character is available to be read, then read it    and stuff it into IBUFFER.  Otherwise, just return. */
end_comment

begin_function
specifier|static
name|void
name|rl_gather_tyi
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
name|char
name|input
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|&&
name|kbhit
argument_list|()
operator|&&
name|ibuffer_space
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !__GO32__ */
name|int
name|tty
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|,
name|result
decl_stmt|;
name|int
name|chars_avail
decl_stmt|;
name|char
name|input
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|fd_set
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
endif|#
directive|endif
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
comment|/* 0.1 seconds */
if|if
condition|(
name|select
argument_list|(
name|tty
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<=
literal|0
condition|)
return|return;
comment|/* Nothing to read. */
endif|#
directive|endif
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|result
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|tem
operator|=
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
operator|(
name|tem
operator||
name|O_NDELAY
operator|)
argument_list|)
expr_stmt|;
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* O_NDELAY */
comment|/* If there's nothing available, don't waste time trying to read      something. */
if|if
condition|(
name|chars_avail
operator|<=
literal|0
condition|)
return|return;
name|tem
operator|=
name|ibuffer_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|>
name|tem
condition|)
name|chars_avail
operator|=
name|tem
expr_stmt|;
comment|/* One cannot read all of the available input.  I can only read a single      character at a time, or else programs which require input can be      thwarted.  If the buffer is larger than one character, I lose.      Damn! */
if|if
condition|(
name|tem
operator|<
name|ibuffer_len
condition|)
name|chars_avail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|chars_avail
operator|--
condition|)
name|rl_stuff_char
argument_list|(
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chars_avail
condition|)
name|rl_stuff_char
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
end_function

begin_comment
comment|/* Is there input available to be read on the readline input file    descriptor?  Only works if the system has select(2) or FIONREAD. */
end_comment

begin_function
name|int
name|_rl_input_available
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|fd_set
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|int
name|chars_avail
decl_stmt|;
endif|#
directive|endif
name|int
name|tty
decl_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|100000
expr_stmt|;
comment|/* 0.1 seconds */
return|return
operator|(
name|select
argument_list|(
name|tty
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|chars_avail
operator|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|_rl_insert_typein
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|key
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|i
operator|=
name|key
operator|=
literal|0
expr_stmt|;
name|string
operator|=
name|xmalloc
argument_list|(
name|ibuffer_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|rl_get_char
argument_list|(
operator|&
name|key
argument_list|)
operator|)
operator|&&
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|function
operator|==
name|rl_insert
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|rl_unget_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			     Character Input			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Read a key, including pending input. */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
if|if
condition|(
name|rl_pending_input
condition|)
block|{
name|c
operator|=
name|rl_pending_input
expr_stmt|;
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* If input is coming from a macro, then use that. */
if|if
condition|(
name|c
operator|=
name|_rl_next_macro_key
argument_list|()
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If the user has an event function, then call it periodically. */
if|if
condition|(
name|rl_event_hook
condition|)
block|{
while|while
condition|(
name|rl_event_hook
operator|&&
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|rl_event_hook
call|)
argument_list|()
expr_stmt|;
name|rl_gather_tyi
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_getc
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|result
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GO32__
argument_list|)
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
name|getkey
argument_list|()
operator|&
literal|0x7F
operator|)
return|;
endif|#
directive|endif
comment|/* __GO32__ */
while|while
condition|(
literal|1
condition|)
block|{
name|result
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If zero characters are returned, then the file that we are 	 reading from is empty!  Return EOF in that case. */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|O_NDELAY
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NDELAY
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* EWOULDBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|EAGAIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|O_NONBLOCK
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* _POSIX_VERSION&& EAGAIN&& O_NONBLOCK */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
comment|/* If the error that we received was SIGINT, then try again, 	 this is simply an interrupted system call to read (). 	 Otherwise, some error ocurred, also signifying EOF. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
endif|#
directive|endif
comment|/* !__GO32__ */
block|}
block|}
end_function

end_unit

