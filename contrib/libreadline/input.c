begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input.c -- character input functions for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1994-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__TANDEM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<floss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|M_UNIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SELECT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_SELECT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD_IN_SYS_IOCTL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* What kind of non-blocking I/O do we have? */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|O_NDELAY
value|O_NONBLOCK
end_define

begin_comment
comment|/* Posix style */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-null means it is a pointer to a function to run while waiting for    character input. */
end_comment

begin_decl_stmt
name|rl_hook_func_t
modifier|*
name|rl_event_hook
init|=
operator|(
name|rl_hook_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rl_getc_func_t
modifier|*
name|rl_getc_function
init|=
name|rl_getc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_keyboard_input_timeout
init|=
literal|100000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0.1 seconds; it's in usec */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ibuffer_space
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_get_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_gather_tyi
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Input Buffering       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pop_index
decl_stmt|,
name|push_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ibuffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ibuffer_len
init|=
sizeof|sizeof
argument_list|(
name|ibuffer
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|any_typein
value|(push_index != pop_index)
end_define

begin_function
name|int
name|_rl_any_typein
parameter_list|()
block|{
return|return
name|any_typein
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of space available in the buffer for stuffing    characters. */
end_comment

begin_function
specifier|static
name|int
name|ibuffer_space
parameter_list|()
block|{
if|if
condition|(
name|pop_index
operator|>
name|push_index
condition|)
return|return
operator|(
name|pop_index
operator|-
name|push_index
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|ibuffer_len
operator|-
operator|(
name|push_index
operator|-
name|pop_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a key from the buffer of characters to be read.    Return the key in KEY.    Result is KEY if there was a key, or 0 if there wasn't. */
end_comment

begin_function
specifier|static
name|int
name|rl_get_char
parameter_list|(
name|key
parameter_list|)
name|int
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|push_index
operator|==
name|pop_index
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|key
operator|=
name|ibuffer
index|[
name|pop_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pop_index
operator|>=
name|ibuffer_len
condition|)
name|pop_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stuff KEY into the *front* of the input buffer.    Returns non-zero if successful, zero if there is    no space left in the buffer. */
end_comment

begin_function
name|int
name|_rl_unget_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|ibuffer_space
argument_list|()
condition|)
block|{
name|pop_index
operator|--
expr_stmt|;
if|if
condition|(
name|pop_index
operator|<
literal|0
condition|)
name|pop_index
operator|=
name|ibuffer_len
operator|-
literal|1
expr_stmt|;
name|ibuffer
index|[
name|pop_index
index|]
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_rl_pushed_input_available
parameter_list|()
block|{
return|return
operator|(
name|push_index
operator|!=
name|pop_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If a character is available to be read, then read it and stuff it into    IBUFFER.  Otherwise, just return.  Returns number of characters read    (0 if none available) and -1 on error (EIO). */
end_comment

begin_function
specifier|static
name|int
name|rl_gather_tyi
parameter_list|()
block|{
name|int
name|tty
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|,
name|result
decl_stmt|;
name|int
name|chars_avail
decl_stmt|,
name|k
decl_stmt|;
name|char
name|input
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|fd_set
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
endif|#
directive|endif
name|chars_avail
operator|=
literal|0
expr_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|_keyboard_input_timeout
expr_stmt|;
name|result
operator|=
name|select
argument_list|(
name|tty
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Nothing to read. */
endif|#
directive|endif
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|errno
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EIO
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
name|tem
operator|=
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
operator|(
name|tem
operator||
name|O_NDELAY
operator|)
argument_list|)
expr_stmt|;
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|chars_avail
operator|==
literal|0
condition|)
comment|/* EOF */
block|{
name|rl_stuff_char
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* O_NDELAY */
if|#
directive|if
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
comment|/* Use getch/_kbhit to check for available console input, in the same way      that we read it normally. */
name|chars_avail
operator|=
name|isatty
argument_list|(
name|tty
argument_list|)
condition|?
name|_kbhit
argument_list|()
else|:
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* If there's nothing available, don't waste time trying to read      something. */
if|if
condition|(
name|chars_avail
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|tem
operator|=
name|ibuffer_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|>
name|tem
condition|)
name|chars_avail
operator|=
name|tem
expr_stmt|;
comment|/* One cannot read all of the available input.  I can only read a single      character at a time, or else programs which require input can be      thwarted.  If the buffer is larger than one character, I lose.      Damn! */
if|if
condition|(
name|tem
operator|<
name|ibuffer_len
condition|)
name|chars_avail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|chars_avail
operator|--
condition|)
block|{
name|k
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NEWLINE
operator|||
name|k
operator|==
name|RETURN
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chars_avail
condition|)
name|rl_stuff_char
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|rl_set_keyboard_input_timeout
parameter_list|(
name|u
parameter_list|)
name|int
name|u
decl_stmt|;
block|{
name|int
name|o
decl_stmt|;
name|o
operator|=
name|_keyboard_input_timeout
expr_stmt|;
if|if
condition|(
name|u
operator|>=
literal|0
condition|)
name|_keyboard_input_timeout
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|o
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Is there input available to be read on the readline input file    descriptor?  Only works if the system has select(2) or FIONREAD.    Uses the value of _keyboard_input_timeout as the timeout; if another    readline function wants to specify a timeout and not leave it up to    the user, it should use _rl_input_queued(timeout_value_in_microseconds)    instead. */
end_comment

begin_function
name|int
name|_rl_input_available
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|fd_set
name|readfds
decl_stmt|,
name|exceptfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
operator|&&
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|int
name|chars_avail
decl_stmt|;
endif|#
directive|endif
name|int
name|tty
decl_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SELECT
argument_list|)
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|tty
argument_list|,
operator|&
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|_keyboard_input_timeout
expr_stmt|;
return|return
operator|(
name|select
argument_list|(
name|tty
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|exceptfds
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|)
return|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|chars_avail
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
if|if
condition|(
name|isatty
argument_list|(
name|tty
argument_list|)
condition|)
return|return
operator|(
name|_kbhit
argument_list|()
operator|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_rl_input_queued
parameter_list|(
name|t
parameter_list|)
name|int
name|t
decl_stmt|;
block|{
name|int
name|old_timeout
decl_stmt|,
name|r
decl_stmt|;
name|old_timeout
operator|=
name|rl_set_keyboard_input_timeout
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|_rl_input_available
argument_list|()
expr_stmt|;
name|rl_set_keyboard_input_timeout
argument_list|(
name|old_timeout
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|_rl_insert_typein
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|key
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|i
operator|=
name|key
operator|=
literal|0
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ibuffer_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|rl_get_char
argument_list|(
operator|&
name|key
argument_list|)
operator|)
operator|&&
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|function
operator|==
name|rl_insert
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|_rl_unget_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add KEY to the buffer of characters to be read.  Returns 1 if the    character was stuffed correctly; 0 otherwise. */
end_comment

begin_function
name|int
name|rl_stuff_char
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|ibuffer_space
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key
operator|==
name|EOF
condition|)
block|{
name|key
operator|=
name|NEWLINE
expr_stmt|;
name|rl_pending_input
operator|=
name|EOF
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_INPUTPENDING
argument_list|)
expr_stmt|;
block|}
name|ibuffer
index|[
name|push_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|push_index
operator|>=
name|ibuffer_len
condition|)
name|push_index
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make C be the next command to be executed. */
end_comment

begin_function
name|int
name|rl_execute_next
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|rl_pending_input
operator|=
name|c
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_INPUTPENDING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear any pending input pushed with rl_execute_next() */
end_comment

begin_function
name|int
name|rl_clear_pending_input
parameter_list|()
block|{
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_INPUTPENDING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			     Character Input			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Read a key, including pending input. */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|rl_key_sequence_length
operator|++
expr_stmt|;
if|if
condition|(
name|rl_pending_input
condition|)
block|{
name|c
operator|=
name|rl_pending_input
expr_stmt|;
name|rl_clear_pending_input
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If input is coming from a macro, then use that. */
if|if
condition|(
name|c
operator|=
name|_rl_next_macro_key
argument_list|()
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If the user has an event function, then call it periodically. */
if|if
condition|(
name|rl_event_hook
condition|)
block|{
while|while
condition|(
name|rl_event_hook
operator|&&
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|rl_event_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_done
condition|)
comment|/* XXX - experimental */
return|return
operator|(
literal|'\n'
operator|)
return|;
if|if
condition|(
name|rl_gather_tyi
argument_list|()
operator|<
literal|0
condition|)
comment|/* XXX - EIO */
block|{
name|rl_done
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|'\n'
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|rl_get_char
argument_list|(
operator|&
name|c
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_getc
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|getch
argument_list|()
operator|)
return|;
endif|#
directive|endif
name|result
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* If zero characters are returned, then the file that we are 	 reading from is empty!  Return EOF in that case. */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__BEOS__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
define|#
directive|define
name|X_EWOULDBLOCK
value|EWOULDBLOCK
else|#
directive|else
define|#
directive|define
name|X_EWOULDBLOCK
value|-99
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EAGAIN
argument_list|)
define|#
directive|define
name|X_EAGAIN
value|EAGAIN
else|#
directive|else
define|#
directive|define
name|X_EAGAIN
value|-99
endif|#
directive|endif
if|if
condition|(
name|errno
operator|==
name|X_EWOULDBLOCK
operator|||
name|errno
operator|==
name|X_EAGAIN
condition|)
block|{
if|if
condition|(
name|sh_unset_nodelay_mode
argument_list|(
name|fileno
argument_list|(
name|stream
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
continue|continue;
block|}
undef|#
directive|undef
name|X_EWOULDBLOCK
undef|#
directive|undef
name|X_EAGAIN
comment|/* If the error that we received was SIGINT, then try again, 	 this is simply an interrupted system call to read (). 	 Otherwise, some error ocurred, also signifying EOF. */
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
return|return
operator|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_READCMD
argument_list|)
condition|?
name|READERR
else|:
name|EOF
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_comment
comment|/* read multibyte char */
end_comment

begin_function
name|int
name|_rl_read_mbchar
parameter_list|(
name|mbchar
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|mbchar
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|mb_len
init|=
literal|0
decl_stmt|;
name|size_t
name|mbchar_bytes_length
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|,
name|ps_back
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps_back
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|mb_len
operator|<
name|size
condition|)
block|{
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|mbchar
index|[
name|mb_len
operator|++
index|]
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|mbchar_bytes_length
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|mbchar
argument_list|,
name|mb_len
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbchar_bytes_length
operator|==
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
break|break;
comment|/* invalid byte sequence for the current locale */
elseif|else
if|if
condition|(
name|mbchar_bytes_length
operator|==
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|2
argument_list|)
condition|)
block|{
comment|/* shorted bytes */
name|ps
operator|=
name|ps_back
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|mbchar_bytes_length
operator|==
literal|0
condition|)
block|{
name|mbchar
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null wide character */
name|mb_len
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|mbchar_bytes_length
operator|>
call|(
name|size_t
call|)
argument_list|(
literal|0
argument_list|)
condition|)
break|break;
block|}
return|return
name|mb_len
return|;
block|}
end_function

begin_comment
comment|/* Read a multibyte-character string whose first character is FIRST into    the buffer MB of length MLEN.  Returns the last character read, which    may be FIRST.  Used by the search functions, among others.  Very similar    to _rl_read_mbchar. */
end_comment

begin_function
name|int
name|_rl_read_mbstring
parameter_list|(
name|first
parameter_list|,
name|mb
parameter_list|,
name|mlen
parameter_list|)
name|int
name|first
decl_stmt|;
name|char
modifier|*
name|mb
decl_stmt|;
name|int
name|mlen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
name|c
operator|=
name|first
expr_stmt|;
name|memset
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlen
condition|;
name|i
operator|++
control|)
block|{
name|mb
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_get_char_len
argument_list|(
name|mb
argument_list|,
operator|&
name|ps
argument_list|)
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Read more for multibyte character */
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
name|c
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MULTIBYTE */
end_comment

end_unit

