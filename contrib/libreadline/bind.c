begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bind.c -- key binding and startup file support for the readline library. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2006 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__TANDEM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<floss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_comment
comment|/* Variables exported by this file. */
end_comment

begin_decl_stmt
name|Keymap
name|rl_binding_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_read_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_rl_init_file_error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_read_init_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|glean_key_from_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_boolean_var
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_get_string_variable_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|substring_member_of_array
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|currently_reading_init_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used only in this file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_rl_prefer_visible_bell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Binding keys				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* rl_add_defun (char *name, rl_command_func_t *function, int key)    Add NAME to the list of named functions.  Make FUNCTION be the function    that gets called.  If KEY is not -1, then bind it. */
end_comment

begin_function
name|int
name|rl_add_defun
parameter_list|(
name|name
parameter_list|,
name|function
parameter_list|,
name|key
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|!=
operator|-
literal|1
condition|)
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|rl_add_funmap_entry
argument_list|(
name|name
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */
end_comment

begin_function
name|int
name|rl_bind_key
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|)
name|int
name|key
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
block|{
if|if
condition|(
name|key
operator|<
literal|0
condition|)
return|return
operator|(
name|key
operator|)
return|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|key
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|_rl_keymap
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|Keymap
name|escmap
decl_stmt|;
name|escmap
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|_rl_keymap
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|key
operator|=
name|UNMETA
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|escmap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|key
operator|)
return|;
block|}
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|type
operator|=
name|ISFUNC
expr_stmt|;
name|_rl_keymap
index|[
name|key
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|rl_binding_keymap
operator|=
name|_rl_keymap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid    KEY. */
end_comment

begin_function
name|int
name|rl_bind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|function
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|Keymap
name|oldmap
decl_stmt|;
name|oldmap
operator|=
name|_rl_keymap
expr_stmt|;
name|_rl_keymap
operator|=
name|map
expr_stmt|;
name|result
operator|=
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|_rl_keymap
operator|=
name|oldmap
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right    now, this is always used to attempt to bind the arrow keys, hence the    check for rl_vi_movement_mode. */
end_comment

begin_function
name|int
name|rl_bind_key_if_unbound_in_map
parameter_list|(
name|key
parameter_list|,
name|default_func
parameter_list|,
name|kmap
parameter_list|)
name|int
name|key
decl_stmt|;
name|rl_command_func_t
modifier|*
name|default_func
decl_stmt|;
name|Keymap
name|kmap
decl_stmt|;
block|{
name|char
name|keyseq
index|[
literal|2
index|]
decl_stmt|;
name|keyseq
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|key
expr_stmt|;
name|keyseq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|rl_bind_keyseq_if_unbound_in_map
argument_list|(
name|keyseq
argument_list|,
name|default_func
argument_list|,
name|kmap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_bind_key_if_unbound
parameter_list|(
name|key
parameter_list|,
name|default_func
parameter_list|)
name|int
name|key
decl_stmt|;
name|rl_command_func_t
modifier|*
name|default_func
decl_stmt|;
block|{
name|char
name|keyseq
index|[
literal|2
index|]
decl_stmt|;
name|keyseq
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|key
expr_stmt|;
name|keyseq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|rl_bind_keyseq_if_unbound_in_map
argument_list|(
name|keyseq
argument_list|,
name|default_func
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in the currently selected keymap.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key
argument_list|(
name|key
argument_list|,
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make KEY do nothing in MAP.    Returns non-zero in case of error. */
end_comment

begin_function
name|int
name|rl_unbind_key_in_map
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|int
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_key_in_map
argument_list|(
name|key
argument_list|,
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Unbind all keys bound to FUNCTION in MAP. */
end_comment

begin_function
name|int
name|rl_unbind_function_in_map
parameter_list|(
name|func
parameter_list|,
name|map
parameter_list|)
name|rl_command_func_t
modifier|*
name|func
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rval
operator|=
literal|0
init|;
name|i
operator|<
name|KEYMAP_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|map
index|[
name|i
index|]
operator|.
name|function
operator|==
name|func
condition|)
block|{
name|map
index|[
name|i
index|]
operator|.
name|function
operator|=
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_function
name|int
name|rl_unbind_command_in_map
parameter_list|(
name|command
parameter_list|,
name|map
parameter_list|)
specifier|const
name|char
modifier|*
name|command
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|rl_command_func_t
modifier|*
name|func
decl_stmt|;
name|func
operator|=
name|rl_named_function
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|rl_unbind_function_in_map
argument_list|(
name|func
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    FUNCTION, starting in the current keymap.  This makes new    keymaps as necessary. */
end_comment

begin_function
name|int
name|rl_bind_keyseq
parameter_list|(
name|keyseq
parameter_list|,
name|function
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
block|{
return|return
operator|(
name|rl_generic_bind
argument_list|(
name|ISFUNC
argument_list|,
name|keyseq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|function
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    FUNCTION.  This makes new keymaps as necessary.  The initial    place to do bindings is in MAP. */
end_comment

begin_function
name|int
name|rl_bind_keyseq_in_map
parameter_list|(
name|keyseq
parameter_list|,
name|function
parameter_list|,
name|map
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
return|return
operator|(
name|rl_generic_bind
argument_list|(
name|ISFUNC
argument_list|,
name|keyseq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|function
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Backwards compatibility; equivalent to rl_bind_keyseq_in_map() */
end_comment

begin_function
name|int
name|rl_set_key
parameter_list|(
name|keyseq
parameter_list|,
name|function
parameter_list|,
name|map
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
return|return
operator|(
name|rl_generic_bind
argument_list|(
name|ISFUNC
argument_list|,
name|keyseq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|function
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right    now, this is always used to attempt to bind the arrow keys, hence the    check for rl_vi_movement_mode. */
end_comment

begin_function
name|int
name|rl_bind_keyseq_if_unbound_in_map
parameter_list|(
name|keyseq
parameter_list|,
name|default_func
parameter_list|,
name|kmap
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|rl_command_func_t
modifier|*
name|default_func
decl_stmt|;
name|Keymap
name|kmap
decl_stmt|;
block|{
name|rl_command_func_t
modifier|*
name|func
decl_stmt|;
if|if
condition|(
name|keyseq
condition|)
block|{
name|func
operator|=
name|rl_function_of_keyseq
argument_list|(
name|keyseq
argument_list|,
name|kmap
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
operator|!
name|func
operator|||
name|func
operator|==
name|rl_do_lowercase_version
operator|||
name|func
operator|==
name|rl_vi_movement_mode
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|func
operator|||
name|func
operator|==
name|rl_do_lowercase_version
condition|)
endif|#
directive|endif
return|return
operator|(
name|rl_bind_keyseq_in_map
argument_list|(
name|keyseq
argument_list|,
name|default_func
argument_list|,
name|kmap
argument_list|)
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_bind_keyseq_if_unbound
parameter_list|(
name|keyseq
parameter_list|,
name|default_func
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|rl_command_func_t
modifier|*
name|default_func
decl_stmt|;
block|{
return|return
operator|(
name|rl_bind_keyseq_if_unbound_in_map
argument_list|(
name|keyseq
argument_list|,
name|default_func
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the string of characters MACRO.  This makes new keymaps as    necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_function
name|int
name|rl_macro_bind
parameter_list|(
name|keyseq
parameter_list|,
name|macro
parameter_list|,
name|map
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|,
decl|*
name|macro
decl_stmt|;
end_function

begin_decl_stmt
name|Keymap
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|macro_keys
decl_stmt|;
name|int
name|macro_keys_len
decl_stmt|;
name|macro_keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|macro
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|macro
argument_list|,
name|macro_keys
argument_list|,
operator|&
name|macro_keys_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|macro_keys
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_generic_bind
argument_list|(
name|ISMACR
argument_list|,
name|keyseq
argument_list|,
name|macro_keys
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Bind the key sequence represented by the string KEYSEQ to    the arbitrary pointer DATA.  TYPE says what kind of data is    pointed to by DATA, right now this can be a function (ISFUNC),    a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps    as necessary.  The initial place to do bindings is in MAP. */
end_comment

begin_function
name|int
name|rl_generic_bind
parameter_list|(
name|type
parameter_list|,
name|keyseq
parameter_list|,
name|data
parameter_list|,
name|map
parameter_list|)
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|int
name|keys_len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|KEYMAP_ENTRY
name|k
decl_stmt|;
name|k
operator|.
name|function
operator|=
literal|0
expr_stmt|;
comment|/* If no keys to bind to, exit right away. */
if|if
condition|(
name|keyseq
operator|==
literal|0
operator|||
operator|*
name|keyseq
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|strlen
argument_list|(
name|keyseq
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Translate the ASCII representation of KEYSEQ into an array of      characters.  Stuff the characters into KEYS, and the length of      KEYS into KEYS_LEN. */
if|if
condition|(
name|rl_translate_keyseq
argument_list|(
name|keyseq
argument_list|,
name|keys
argument_list|,
operator|&
name|keys_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Bind keys, making new keymaps as necessary. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keys_len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|uc
init|=
name|keys
index|[
name|i
index|]
decl_stmt|;
name|int
name|ic
decl_stmt|;
name|ic
operator|=
name|uc
expr_stmt|;
if|if
condition|(
name|ic
operator|<
literal|0
operator|||
name|ic
operator|>=
name|KEYMAP_SIZE
condition|)
block|{
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|META_CHAR
argument_list|(
name|ic
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
name|ic
operator|=
name|UNMETA
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|keys_len
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
comment|/* We allow subsequences of keys.  If a keymap is being 		 created that will `shadow' an existing function or macro 		 key binding, we save that keybinding into the ANYOTHERKEY 		 index in the new map.  The dispatch code will look there 		 to find the function to execute if the subsequence is not 		 matched.  ANYOTHERKEY was chosen to be greater than 		 UCHAR_MAX. */
name|k
operator|=
name|map
index|[
name|ic
index|]
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|=
name|ISKMAP
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|=
name|KEYMAP_TO_FUNCTION
argument_list|(
name|rl_make_bare_keymap
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ic
argument_list|)
expr_stmt|;
comment|/* The dispatch code will return this function if no matching 	     key sequence is found in the keymap.  This (with a little 	     help from the dispatch code in readline.c) allows `a' to be 	     mapped to something, `abc' to be mapped to something else, 	     and the function bound  to `a' to be executed when the user 	     types `abx', leaving `bx' in the input queue. */
if|if
condition|(
name|k
operator|.
name|function
operator|&&
operator|(
operator|(
name|k
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|k
operator|.
name|function
operator|!=
name|rl_do_lowercase_version
operator|)
operator|||
name|k
operator|.
name|type
operator|==
name|ISMACR
operator|)
condition|)
block|{
name|map
index|[
name|ANYOTHERKEY
index|]
operator|=
name|k
expr_stmt|;
name|k
operator|.
name|function
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISMACR
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|ic
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|=
name|ANYOTHERKEY
expr_stmt|;
block|}
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|=
name|KEYMAP_TO_FUNCTION
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
name|rl_binding_keymap
operator|=
name|map
expr_stmt|;
block|}
name|free
argument_list|(
name|keys
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate the ASCII representation of SEQ, stuffing the values into ARRAY,    an array of characters.  LEN gets the final length of ARRAY.  Return    non-zero if there was an error parsing SEQ. */
end_comment

begin_function
name|int
name|rl_translate_keyseq
parameter_list|(
name|seq
parameter_list|,
name|array
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|seq
decl_stmt|;
name|char
modifier|*
name|array
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|l
decl_stmt|,
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|l
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|seq
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|seq
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
comment|/* Handle \C- and \M- prefixes. */
if|if
condition|(
operator|(
name|c
operator|==
literal|'C'
operator|||
name|c
operator|==
literal|'M'
operator|)
operator|&&
name|seq
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Handle special case of backwards define. */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|seq
index|[
name|i
index|]
argument_list|,
literal|"C-\\M-"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
comment|/* ESC is meta-prefix */
name|i
operator|+=
literal|5
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|CTRL
argument_list|(
name|_rl_to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|i
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'M'
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* seq[i] == '-' */
comment|/* XXX - obey convert-meta setting */
if|if
condition|(
name|_rl_convert_meta_chars_to_ascii
operator|&&
name|_rl_keymap
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
comment|/* ESC is meta-prefix */
elseif|else
if|if
condition|(
name|seq
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|seq
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'C'
operator|&&
name|seq
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|'-'
condition|)
block|{
name|i
operator|+=
literal|4
expr_stmt|;
name|temp
operator|=
operator|(
name|seq
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
condition|?
name|RUBOUT
else|:
name|CTRL
argument_list|(
name|_rl_to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|META
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This doesn't yet handle things like \M-\a, which may 			 or may not have any reasonable meaning.  You're 			 probably better off using straight octal or hex. */
name|i
operator|++
expr_stmt|;
name|array
index|[
name|l
operator|++
index|]
operator|=
name|META
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'C'
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Special hack for C-?... */
name|array
index|[
name|l
operator|++
index|]
operator|=
operator|(
name|seq
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
condition|?
name|RUBOUT
else|:
name|CTRL
argument_list|(
name|_rl_to_upper
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Translate other backslash-escaped characters.  These are the 	     same escape sequences that bash's `echo' and `printf' builtins 	     handle, with the addition of \d -> RUBOUT.  A backslash 	     preceding a character that is not special is stripped. */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
literal|'\007'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|RUBOUT
expr_stmt|;
comment|/* readline-specific */
break|break;
case|case
literal|'e'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|ESC
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|NEWLINE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|RETURN
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
name|TAB
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
literal|0x0B
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|array
index|[
name|l
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|i
operator|++
expr_stmt|;
for|for
control|(
name|temp
operator|=
literal|2
operator|,
name|c
operator|-=
literal|'0'
init|;
name|ISOCTAL
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
operator|&&
name|temp
operator|--
condition|;
name|i
operator|++
control|)
name|c
operator|=
operator|(
name|c
operator|*
literal|8
operator|)
operator|+
name|OCTVALUE
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|/* auto-increment in for loop */
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
operator|&
name|largest_char
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|i
operator|++
expr_stmt|;
for|for
control|(
name|temp
operator|=
literal|2
operator|,
name|c
operator|=
literal|0
init|;
name|ISXDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|seq
index|[
name|i
index|]
argument_list|)
operator|&&
name|temp
operator|--
condition|;
name|i
operator|++
control|)
name|c
operator|=
operator|(
name|c
operator|*
literal|16
operator|)
operator|+
name|HEXVALUE
argument_list|(
name|seq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|2
condition|)
name|c
operator|=
literal|'x'
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|/* auto-increment in for loop */
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
operator|&
name|largest_char
expr_stmt|;
break|break;
default|default:
comment|/* backslashes before non-special chars just add the char */
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
comment|/* the backslash is stripped */
block|}
continue|continue;
block|}
name|array
index|[
name|l
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|l
expr_stmt|;
name|array
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_untranslate_keyseq
parameter_list|(
name|seq
parameter_list|)
name|int
name|seq
decl_stmt|;
block|{
specifier|static
name|char
name|kseq
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|seq
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'M'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|c
operator|=
literal|'e'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'C'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
name|_rl_to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|RUBOUT
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'C'
expr_stmt|;
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|c
operator|=
literal|'e'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'"'
condition|)
block|{
name|kseq
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
name|kseq
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
name|kseq
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|kseq
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|_rl_untranslate_macro_value
parameter_list|(
name|seq
parameter_list|)
name|char
modifier|*
name|seq
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|r
operator|=
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|7
operator|*
name|strlen
argument_list|(
name|seq
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|seq
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|c
operator|=
literal|'e'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
name|_rl_to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|RUBOUT
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|c
operator|=
literal|'e'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'"'
condition|)
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the function that STRING represents.    If STRING doesn't have a matching function, then a NULL pointer    is returned. */
end_comment

begin_function
name|rl_command_func_t
modifier|*
name|rl_named_function
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|funmap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|funmap
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|funmap
index|[
name|i
index|]
operator|->
name|function
operator|)
return|;
return|return
operator|(
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the function (or macro) definition which would be invoked via    KEYSEQ if executed in MAP.  If MAP is NULL, then the current keymap is    used.  TYPE, if non-NULL, is a pointer to an int which will receive the    type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),    or ISMACR (macro). */
end_comment

begin_function
name|rl_command_func_t
modifier|*
name|rl_function_of_keyseq
parameter_list|(
name|keyseq
parameter_list|,
name|map
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|keyseq
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
name|int
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|0
condition|)
name|map
operator|=
name|_rl_keymap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keyseq
operator|&&
name|keyseq
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|ic
init|=
name|keyseq
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|ic
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|ic
operator|=
name|UNMETA
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - should we just return NULL here, since this obviously 	     doesn't match? */
else|else
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|map
index|[
name|ESC
index|]
operator|.
name|type
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ESC
index|]
operator|.
name|function
operator|)
return|;
block|}
block|}
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
comment|/* If this is the last key in the key sequence, return the 	     map. */
if|if
condition|(
name|keyseq
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|ISKMAP
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|)
return|;
block|}
else|else
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* If we're not at the end of the key sequence, and the current key 	 is bound to something other than a keymap, then the entire key 	 sequence is not bound. */
elseif|else
if|if
condition|(
name|map
index|[
name|ic
index|]
operator|.
name|type
operator|!=
name|ISKMAP
operator|&&
name|keyseq
index|[
name|i
operator|+
literal|1
index|]
condition|)
return|return
operator|(
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
comment|/* map[ic].type != ISKMAP&& keyseq[i+1] == 0 */
block|{
if|if
condition|(
name|type
condition|)
operator|*
name|type
operator|=
name|map
index|[
name|ic
index|]
operator|.
name|type
expr_stmt|;
return|return
operator|(
name|map
index|[
name|ic
index|]
operator|.
name|function
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|(
name|rl_command_func_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The last key bindings file read. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_readline_init_file
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file we're currently reading key bindings from. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_readline_init_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_readline_init_include_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_readline_init_lineno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read FILENAME into a locally-allocated buffer and return the buffer.    The size of the buffer is returned in *SIZEP.  Returns NULL if any    errors were encountered. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_rl_read_file
parameter_list|(
name|filename
parameter_list|,
name|sizep
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|size_t
modifier|*
name|sizep
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|,
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|file_size
operator|=
operator|(
name|size_t
operator|)
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* check for overflow on very large files */
if|if
condition|(
name|file_size
operator|!=
name|finfo
operator|.
name|st_size
operator|||
name|file_size
operator|+
literal|1
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|errno
operator|=
name|EFBIG
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Read the file into BUFFER. */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|file_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-read the current keybindings file. */
end_comment

begin_function
name|int
name|rl_re_read_init_file
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|rl_read_init_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|rl_set_keymap_from_edit_mode
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Do key bindings from a file.  If FILENAME is NULL it defaults    to the first non-null filename from this list:      1. the filename used for the previous call      2. the value of the shell variable `INPUTRC'      3. ~/.inputrc      4. /etc/inputrc    If the file existed and could be opened and read, 0 is returned,    otherwise errno is returned. */
end_comment

begin_function
name|int
name|rl_read_init_file
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
comment|/* Default the filename. */
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
name|filename
operator|=
name|last_readline_init_file
expr_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
name|filename
operator|=
name|sh_get_env_value
argument_list|(
literal|"INPUTRC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
operator|||
operator|*
name|filename
operator|==
literal|0
condition|)
block|{
name|filename
operator|=
name|DEFAULT_INPUTRC
expr_stmt|;
comment|/* Try to read DEFAULT_INPUTRC; fall back to SYS_INPUTRC on failure */
if|if
condition|(
name|_rl_read_init_file
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|filename
operator|=
name|SYS_INPUTRC
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
if|if
condition|(
name|_rl_read_init_file
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|filename
operator|=
literal|"~/_inputrc"
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|_rl_read_init_file
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_read_init_file
parameter_list|(
name|filename
parameter_list|,
name|include_level
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|include_level
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|openname
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
name|current_readline_init_file
operator|=
name|filename
expr_stmt|;
name|current_readline_init_include_level
operator|=
name|include_level
expr_stmt|;
name|openname
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|_rl_read_file
argument_list|(
name|openname
argument_list|,
operator|&
name|file_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|openname
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|include_level
operator|==
literal|0
operator|&&
name|filename
operator|!=
name|last_readline_init_file
condition|)
block|{
name|FREE
argument_list|(
name|last_readline_init_file
argument_list|)
expr_stmt|;
name|last_readline_init_file
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|currently_reading_init_file
operator|=
literal|1
expr_stmt|;
comment|/* Loop over the lines in the file.  Lines that start with `#' are      comments; all other lines are commands for readline initialization. */
name|current_readline_init_lineno
operator|=
literal|1
expr_stmt|;
name|line
operator|=
name|buffer
expr_stmt|;
name|end
operator|=
name|buffer
operator|+
name|file_size
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|end
condition|)
block|{
comment|/* Find the end of this line. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
operator|+
name|i
operator|!=
name|end
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
comment|/* ``Be liberal in what you accept.'' */
if|if
condition|(
name|line
index|[
name|i
index|]
operator|==
literal|'\n'
operator|&&
name|line
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|line
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* Mark end of line. */
name|line
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip leading whitespace. */
while|while
condition|(
operator|*
name|line
operator|&&
name|whitespace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* If the line is not a comment, then parse it. */
if|if
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'#'
condition|)
name|rl_parse_and_bind
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Move to the next line. */
name|line
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|current_readline_init_lineno
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|currently_reading_init_file
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_init_file_error
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|currently_reading_init_file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: %s: line %d: %s\n"
argument_list|,
name|current_readline_init_file
argument_list|,
name|current_readline_init_lineno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Parser Directives       		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_typedef
typedef|typedef
name|int
name|_rl_parser_func_t
name|PARAMS
typedef|((
name|char
modifier|*
typedef|));
end_typedef

begin_comment
comment|/* Things that mean `Control'. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_rl_possible_control_prefixes
index|[]
init|=
block|{
literal|"Control-"
block|,
literal|"C-"
block|,
literal|"CTRL-"
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_rl_possible_meta_prefixes
index|[]
init|=
block|{
literal|"Meta"
block|,
literal|"M-"
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conditionals. */
end_comment

begin_comment
comment|/* Calling programs set this to have their argv[0]. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_readline_name
init|=
literal|"other"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of previous values of parsing_conditionalized_out. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|if_stack
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_stack_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push _rl_parsing_conditionalized_out, and set parser state based    on ARGS. */
end_comment

begin_function
specifier|static
name|int
name|parser_if
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Push parser state. */
if|if
condition|(
name|if_stack_depth
operator|+
literal|1
operator|>=
name|if_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|if_stack
condition|)
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|if_stack_size
operator|=
literal|20
argument_list|)
expr_stmt|;
else|else
name|if_stack
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_size
operator|+=
literal|20
argument_list|)
expr_stmt|;
block|}
name|if_stack
index|[
name|if_stack_depth
operator|++
index|]
operator|=
name|_rl_parsing_conditionalized_out
expr_stmt|;
comment|/* If parsing is turned off, then nothing can turn it back on except      for finding the matching endif.  In that case, return right now. */
if|if
condition|(
name|_rl_parsing_conditionalized_out
condition|)
return|return
literal|0
return|;
comment|/* Isolate first argument. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
condition|)
name|args
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle "$if term=foo" and "$if mode=emacs" constructs.  If this      isn't term=foo, or mode=emacs, then check to see if the first      word in ARGS is the same as the value stored in rl_readline_name. */
if|if
condition|(
name|rl_terminal_name
operator|&&
name|_rl_strnicmp
argument_list|(
name|args
argument_list|,
literal|"term="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tem
decl_stmt|,
modifier|*
name|tname
decl_stmt|;
comment|/* Terminals like "aaa-60" are equivalent to "aaa". */
name|tname
operator|=
name|savestring
argument_list|(
name|rl_terminal_name
argument_list|)
expr_stmt|;
name|tem
operator|=
name|strchr
argument_list|(
name|tname
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
operator|*
name|tem
operator|=
literal|'\0'
expr_stmt|;
comment|/* Test the `long' and `short' forms of the terminal name so that 	 if someone has a `sun-cmd' and does not want to have bindings 	 that will be executed if the terminal is a `sun', they can put 	 `$if term=sun-cmd' into their .inputrc. */
name|_rl_parsing_conditionalized_out
operator|=
name|_rl_stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
name|tname
argument_list|)
operator|&&
name|_rl_stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
name|rl_terminal_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
elseif|else
if|if
condition|(
name|_rl_strnicmp
argument_list|(
name|args
argument_list|,
literal|"mode="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
literal|"emacs"
argument_list|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|emacs_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|args
operator|+
literal|5
argument_list|,
literal|"vi"
argument_list|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|vi_mode
expr_stmt|;
else|else
name|mode
operator|=
name|no_mode
expr_stmt|;
name|_rl_parsing_conditionalized_out
operator|=
name|mode
operator|!=
name|rl_editing_mode
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
comment|/* Check to see if the first word in ARGS is the same as the      value stored in rl_readline_name. */
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|args
argument_list|,
name|rl_readline_name
argument_list|)
operator|==
literal|0
condition|)
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
else|else
name|_rl_parsing_conditionalized_out
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invert the current parser state if there is anything on the stack. */
end_comment

begin_function
specifier|static
name|int
name|parser_else
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|if_stack_depth
operator|==
literal|0
condition|)
block|{
name|_rl_init_file_error
argument_list|(
literal|"$else found without matching $if"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* Check the previous (n - 1) levels of the stack to make sure that      we haven't previously turned off parsing. */
block|for (i = 0; i< if_stack_depth - 1; i++)
else|#
directive|else
comment|/* Check the previous (n) levels of the stack to make sure that      we haven't previously turned off parsing. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|if_stack_depth
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
if|if
condition|(
name|if_stack
index|[
name|i
index|]
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Invert the state of parsing if at top level. */
name|_rl_parsing_conditionalized_out
operator|=
operator|!
name|_rl_parsing_conditionalized_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Terminate a conditional, popping the value of    _rl_parsing_conditionalized_out from the stack. */
end_comment

begin_function
specifier|static
name|int
name|parser_endif
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
if|if
condition|(
name|if_stack_depth
condition|)
name|_rl_parsing_conditionalized_out
operator|=
name|if_stack
index|[
operator|--
name|if_stack_depth
index|]
expr_stmt|;
else|else
name|_rl_init_file_error
argument_list|(
literal|"$endif without matching $if"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parser_include
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|old_init_file
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|old_line_number
decl_stmt|,
name|old_include_level
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|_rl_parsing_conditionalized_out
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|old_init_file
operator|=
name|current_readline_init_file
expr_stmt|;
name|old_line_number
operator|=
name|current_readline_init_lineno
expr_stmt|;
name|old_include_level
operator|=
name|current_readline_init_include_level
expr_stmt|;
name|e
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|_rl_read_init_file
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|args
argument_list|,
name|old_include_level
operator|+
literal|1
argument_list|)
expr_stmt|;
name|current_readline_init_file
operator|=
name|old_init_file
expr_stmt|;
name|current_readline_init_lineno
operator|=
name|old_line_number
expr_stmt|;
name|current_readline_init_include_level
operator|=
name|old_include_level
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Associate textual names with actual functions. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|_rl_parser_func_t
modifier|*
name|function
decl_stmt|;
block|}
name|parser_directives
index|[]
init|=
block|{
block|{
literal|"if"
block|,
name|parser_if
block|}
block|,
block|{
literal|"endif"
block|,
name|parser_endif
block|}
block|,
block|{
literal|"else"
block|,
name|parser_else
block|}
block|,
block|{
literal|"include"
block|,
name|parser_include
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
operator|(
name|_rl_parser_func_t
operator|*
operator|)
literal|0x0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Handle a parser directive.  STATEMENT is the line of the directive    without any leading `$'. */
end_comment

begin_function
specifier|static
name|int
name|handle_parser_directive
parameter_list|(
name|statement
parameter_list|)
name|char
modifier|*
name|statement
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|,
modifier|*
name|args
decl_stmt|;
comment|/* Isolate the actual directive. */
comment|/* Skip whitespace. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|directive
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|statement
index|[
name|i
index|]
condition|)
name|statement
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|statement
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|statement
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|args
operator|=
operator|&
name|statement
index|[
name|i
index|]
expr_stmt|;
comment|/* Lookup the command, and act on it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|directive
argument_list|,
name|parser_directives
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|parser_directives
index|[
name|i
index|]
operator|.
name|function
operator|)
operator|(
name|args
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* display an error message about the unknown parser directive */
name|_rl_init_file_error
argument_list|(
literal|"unknown parser directive"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the binding command from STRING and perform it.    A key binding command looks like: Keyname: function-name\0,    a variable binding command looks like: set variable value.    A new-style keybinding looks like "\C-x\C-x": exchange-point-and-mark. */
end_comment

begin_function
name|int
name|rl_parse_and_bind
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|funname
decl_stmt|,
modifier|*
name|kname
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|key
decl_stmt|,
name|equivalency
decl_stmt|;
while|while
condition|(
name|string
operator|&&
name|whitespace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
operator|||
operator|*
name|string
operator|==
literal|'#'
condition|)
return|return
literal|0
return|;
comment|/* If this is a parser directive, act on it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'$'
condition|)
block|{
name|handle_parser_directive
argument_list|(
operator|&
name|string
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we aren't supposed to be parsing right now, then we're done. */
if|if
condition|(
name|_rl_parsing_conditionalized_out
condition|)
return|return
literal|0
return|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* If this keyname is a complex key expression surrounded by quotes,      advance to after the matching close quote.  This code allows the      backslash to quote characters in the key expression. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
name|int
name|passc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|passc
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
block|}
comment|/* If we didn't find a closing quote, abort the line. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|_rl_init_file_error
argument_list|(
literal|"no closing `\"' in key binding"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Advance to the colon (:) or whitespace which separates the two objects. */
for|for
control|(
init|;
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
operator|&&
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|equivalency
operator|=
operator|(
name|c
operator|==
literal|':'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'='
operator|)
expr_stmt|;
comment|/* Mark the end of the command (or keyname). */
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If doing assignment, skip the '=' sign as well. */
if|if
condition|(
name|equivalency
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If this is a command to set a variable, then do that. */
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|string
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|var
operator|=
name|string
operator|+
name|i
expr_stmt|;
comment|/* Make VAR point to start of variable name. */
while|while
condition|(
operator|*
name|var
operator|&&
name|whitespace
argument_list|(
operator|*
name|var
argument_list|)
condition|)
name|var
operator|++
expr_stmt|;
comment|/* Make VALUE point to start of value string. */
name|value
operator|=
name|var
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
name|whitespace
argument_list|(
operator|*
name|value
argument_list|)
condition|)
name|value
operator|++
expr_stmt|;
comment|/* Strip trailing whitespace from values to boolean variables.  Temp 	 fix until I get a real quoted-string parser here. */
name|i
operator|=
name|find_boolean_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
comment|/* remove trailing whitespace */
name|e
operator|=
name|value
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|e
operator|>=
name|value
operator|&&
name|whitespace
argument_list|(
operator|*
name|e
argument_list|)
condition|)
name|e
operator|--
expr_stmt|;
name|e
operator|++
expr_stmt|;
comment|/* skip back to whitespace or EOS */
if|if
condition|(
operator|*
name|e
operator|&&
name|e
operator|>=
name|value
condition|)
operator|*
name|e
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_variable_bind
argument_list|(
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Skip any whitespace between keyname and funname. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|funname
operator|=
operator|&
name|string
index|[
name|i
index|]
expr_stmt|;
comment|/* Now isolate funname.      For straight function names just look for whitespace, since      that will signify the end of the string.  But this could be a      macro definition.  In that case, the string is quoted, so skip      to the matching delimiter.  We allow the backslash to quote the      delimiter characters in the macro body. */
comment|/* This code exists to allow whitespace in macro expansions, which      would otherwise be gobbled up by the next `for' loop.*/
comment|/* XXX - it may be desirable to allow backslash quoting only if " is      the quoted string delimiter, like the shell. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|int
name|delimiter
decl_stmt|,
name|passc
decl_stmt|;
name|delimiter
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
for|for
control|(
name|passc
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|passc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|delimiter
condition|)
break|break;
block|}
if|if
condition|(
name|c
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* Advance to the end of the string.  */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* No extra whitespace at the end of the string. */
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle equivalency bindings here.  Make the left-hand side be exactly      whatever the right-hand evaluates to, including keymaps. */
if|if
condition|(
name|equivalency
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If this is a new-style key-binding, then do the binding with      rl_bind_keyseq ().  Otherwise, let the older code deal with it. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
block|{
name|char
modifier|*
name|seq
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|passc
decl_stmt|;
name|seq
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|k
operator|=
name|passc
operator|=
literal|0
init|;
name|string
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
comment|/* Allow backslash to quote characters, but leave them in place. 	     This allows a string to end with a backslash quoting another 	     backslash, or with a backslash quoting a double quote.  The 	     backslashes are left in place for rl_translate_keyseq (). */
if|if
condition|(
name|passc
operator|||
operator|(
name|string
index|[
name|j
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|seq
index|[
name|k
operator|++
index|]
operator|=
name|string
index|[
name|j
index|]
expr_stmt|;
name|passc
operator|=
operator|!
name|passc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|j
index|]
operator|==
literal|'"'
condition|)
break|break;
name|seq
index|[
name|k
operator|++
index|]
operator|=
name|string
index|[
name|j
index|]
expr_stmt|;
block|}
name|seq
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Binding macro? */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|j
operator|=
name|strlen
argument_list|(
name|funname
argument_list|)
expr_stmt|;
comment|/* Remove the delimiting quotes from each end of FUNNAME. */
if|if
condition|(
name|j
operator|&&
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|j
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|seq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_bind_keyseq
argument_list|(
name|seq
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Get the actual character we want to deal with. */
name|kname
operator|=
name|strrchr
argument_list|(
name|string
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kname
condition|)
name|kname
operator|=
name|string
expr_stmt|;
else|else
name|kname
operator|++
expr_stmt|;
name|key
operator|=
name|glean_key_from_name
argument_list|(
name|kname
argument_list|)
expr_stmt|;
comment|/* Add in control and meta bits. */
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|_rl_possible_control_prefixes
argument_list|)
condition|)
name|key
operator|=
name|CTRL
argument_list|(
name|_rl_to_upper
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|substring_member_of_array
argument_list|(
name|string
argument_list|,
name|_rl_possible_meta_prefixes
argument_list|)
condition|)
name|key
operator|=
name|META
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Temporary.  Handle old-style keyname with macro-binding. */
if|if
condition|(
operator|*
name|funname
operator|==
literal|'\''
operator|||
operator|*
name|funname
operator|==
literal|'"'
condition|)
block|{
name|char
name|useq
index|[
literal|2
index|]
decl_stmt|;
name|int
name|fl
init|=
name|strlen
argument_list|(
name|funname
argument_list|)
decl_stmt|;
name|useq
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|useq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fl
operator|&&
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|==
operator|*
name|funname
condition|)
name|funname
index|[
name|fl
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_macro_bind
argument_list|(
name|useq
argument_list|,
operator|&
name|funname
index|[
literal|1
index|]
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PREFIX_META_HACK
argument_list|)
comment|/* Ugly, but working hack to keep prefix-meta around. */
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|funname
argument_list|,
literal|"prefix-meta"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|seq
index|[
literal|2
index|]
decl_stmt|;
name|seq
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|seq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_generic_bind
argument_list|(
name|ISKMAP
argument_list|,
name|seq
argument_list|,
operator|(
name|char
operator|*
operator|)
name|emacs_meta_keymap
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PREFIX_META_HACK */
else|else
name|rl_bind_key
argument_list|(
name|key
argument_list|,
name|rl_named_function
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simple structure for boolean readline variables (i.e., those that can    have one of two values; either "On" or 1 for truth, or "Off" or 0 for    false. */
end_comment

begin_define
define|#
directive|define
name|V_SPECIAL
value|0x1
end_define

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|boolean_varlist
index|[]
init|=
block|{
block|{
literal|"bind-tty-special-chars"
block|,
operator|&
name|_rl_bind_stty_chars
block|,
literal|0
block|}
block|,
block|{
literal|"blink-matching-paren"
block|,
operator|&
name|rl_blink_matching_paren
block|,
name|V_SPECIAL
block|}
block|,
block|{
literal|"byte-oriented"
block|,
operator|&
name|rl_byte_oriented
block|,
literal|0
block|}
block|,
block|{
literal|"completion-ignore-case"
block|,
operator|&
name|_rl_completion_case_fold
block|,
literal|0
block|}
block|,
block|{
literal|"convert-meta"
block|,
operator|&
name|_rl_convert_meta_chars_to_ascii
block|,
literal|0
block|}
block|,
block|{
literal|"disable-completion"
block|,
operator|&
name|rl_inhibit_completion
block|,
literal|0
block|}
block|,
block|{
literal|"enable-keypad"
block|,
operator|&
name|_rl_enable_keypad
block|,
literal|0
block|}
block|,
block|{
literal|"expand-tilde"
block|,
operator|&
name|rl_complete_with_tilde_expansion
block|,
literal|0
block|}
block|,
block|{
literal|"history-preserve-point"
block|,
operator|&
name|_rl_history_preserve_point
block|,
literal|0
block|}
block|,
block|{
literal|"horizontal-scroll-mode"
block|,
operator|&
name|_rl_horizontal_scroll_mode
block|,
literal|0
block|}
block|,
block|{
literal|"input-meta"
block|,
operator|&
name|_rl_meta_flag
block|,
literal|0
block|}
block|,
block|{
literal|"mark-directories"
block|,
operator|&
name|_rl_complete_mark_directories
block|,
literal|0
block|}
block|,
block|{
literal|"mark-modified-lines"
block|,
operator|&
name|_rl_mark_modified_lines
block|,
literal|0
block|}
block|,
block|{
literal|"mark-symlinked-directories"
block|,
operator|&
name|_rl_complete_mark_symlink_dirs
block|,
literal|0
block|}
block|,
block|{
literal|"match-hidden-files"
block|,
operator|&
name|_rl_match_hidden_files
block|,
literal|0
block|}
block|,
block|{
literal|"meta-flag"
block|,
operator|&
name|_rl_meta_flag
block|,
literal|0
block|}
block|,
block|{
literal|"output-meta"
block|,
operator|&
name|_rl_output_meta_chars
block|,
literal|0
block|}
block|,
block|{
literal|"page-completions"
block|,
operator|&
name|_rl_page_completions
block|,
literal|0
block|}
block|,
block|{
literal|"prefer-visible-bell"
block|,
operator|&
name|_rl_prefer_visible_bell
block|,
name|V_SPECIAL
block|}
block|,
block|{
literal|"print-completions-horizontally"
block|,
operator|&
name|_rl_print_completions_horizontally
block|,
literal|0
block|}
block|,
block|{
literal|"show-all-if-ambiguous"
block|,
operator|&
name|_rl_complete_show_all
block|,
literal|0
block|}
block|,
block|{
literal|"show-all-if-unmodified"
block|,
operator|&
name|_rl_complete_show_unmodified
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
block|{
literal|"visible-stats"
block|,
operator|&
name|rl_visible_stats
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* VISIBLE_STATS */
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|find_boolean_var
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hooks for handling special boolean variables, where a    function needs to be called or another variable needs    to be changed when they're changed. */
end_comment

begin_function
specifier|static
name|void
name|hack_special_boolean_var
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"blink-matching-paren"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_enable_paren_matching
argument_list|(
name|rl_blink_matching_paren
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"prefer-visible-bell"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_rl_prefer_visible_bell
condition|)
name|_rl_bell_preference
operator|=
name|VISIBLE_BELL
expr_stmt|;
else|else
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|int
name|_rl_sv_func_t
name|PARAMS
typedef|((const
name|char
modifier|*
typedef|));
end_typedef

begin_comment
comment|/* These *must* correspond to the array indices for the appropriate    string variable.  (Though they're not used right now.) */
end_comment

begin_define
define|#
directive|define
name|V_BELLSTYLE
value|0
end_define

begin_define
define|#
directive|define
name|V_COMBEGIN
value|1
end_define

begin_define
define|#
directive|define
name|V_EDITMODE
value|2
end_define

begin_define
define|#
directive|define
name|V_ISRCHTERM
value|3
end_define

begin_define
define|#
directive|define
name|V_KEYMAP
value|4
end_define

begin_define
define|#
directive|define
name|V_STRING
value|1
end_define

begin_define
define|#
directive|define
name|V_INT
value|2
end_define

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sv_bell_style
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sv_combegin
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sv_compquery
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sv_editmode
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sv_isrchterm
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sv_keymap
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|_rl_sv_func_t
modifier|*
name|set_func
decl_stmt|;
block|}
name|string_varlist
index|[]
init|=
block|{
block|{
literal|"bell-style"
block|,
name|V_STRING
block|,
name|sv_bell_style
block|}
block|,
block|{
literal|"comment-begin"
block|,
name|V_STRING
block|,
name|sv_combegin
block|}
block|,
block|{
literal|"completion-query-items"
block|,
name|V_INT
block|,
name|sv_compquery
block|}
block|,
block|{
literal|"editing-mode"
block|,
name|V_STRING
block|,
name|sv_editmode
block|}
block|,
block|{
literal|"isearch-terminators"
block|,
name|V_STRING
block|,
name|sv_isrchterm
block|}
block|,
block|{
literal|"keymap"
block|,
name|V_STRING
block|,
name|sv_keymap
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|find_string_var
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A boolean value that can appear in a `set variable' command is true if    the value is null or empty, `on' (case-insenstive), or "1".  Any other    values result in 0 (false). */
end_comment

begin_function
specifier|static
name|int
name|bool_to_int
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
return|return
operator|(
name|value
operator|==
literal|0
operator|||
operator|*
name|value
operator|==
literal|'\0'
operator|||
operator|(
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|value
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|value
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_variable_value
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Check for simple variables first. */
name|i
operator|=
name|find_boolean_var
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
condition|?
literal|"on"
else|:
literal|"off"
operator|)
return|;
name|i
operator|=
name|find_string_var
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
name|_rl_get_string_variable_value
argument_list|(
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
return|;
comment|/* Unknown variable names return NULL. */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_variable_bind
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|v
decl_stmt|;
comment|/* Check for simple variables first. */
name|i
operator|=
name|find_boolean_var
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
operator|=
name|bool_to_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|V_SPECIAL
condition|)
name|hack_special_boolean_var
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|find_string_var
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* For the time being, unknown variable names or string names without a      handler function are simply ignored. */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|string_varlist
index|[
name|i
index|]
operator|.
name|set_func
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|v
operator|=
operator|(
operator|*
name|string_varlist
index|[
name|i
index|]
operator|.
name|set_func
operator|)
operator|(
name|value
operator|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|sv_editmode
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|_rl_strnicmp
argument_list|(
name|value
argument_list|,
literal|"vi"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|_rl_strnicmp
argument_list|(
name|value
argument_list|,
literal|"emacs"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_combegin
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|FREE
argument_list|(
name|_rl_comment_begin
argument_list|)
expr_stmt|;
name|_rl_comment_begin
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_compquery
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|nval
init|=
literal|100
decl_stmt|;
if|if
condition|(
name|value
operator|&&
operator|*
name|value
condition|)
block|{
name|nval
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nval
operator|<
literal|0
condition|)
name|nval
operator|=
literal|0
expr_stmt|;
block|}
name|rl_completion_query_items
operator|=
name|nval
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_keymap
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|Keymap
name|kmap
decl_stmt|;
name|kmap
operator|=
name|rl_get_keymap_by_name
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmap
condition|)
block|{
name|rl_set_keymap
argument_list|(
name|kmap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_bell_style
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
literal|0
operator|||
operator|*
name|value
operator|==
literal|'\0'
condition|)
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|NO_BELL
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"audible"
argument_list|)
operator|==
literal|0
operator|||
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|AUDIBLE_BELL
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|value
argument_list|,
literal|"visible"
argument_list|)
operator|==
literal|0
condition|)
name|_rl_bell_preference
operator|=
name|VISIBLE_BELL
expr_stmt|;
else|else
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sv_isrchterm
parameter_list|(
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|delim
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Isolate the value and translate it into a character string. */
name|v
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|_rl_isearch_terminators
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
index|[
literal|0
index|]
operator|==
literal|'"'
operator|||
name|v
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
block|{
name|delim
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|end
operator|=
literal|1
init|;
name|v
index|[
name|end
index|]
operator|&&
name|v
index|[
name|end
index|]
operator|!=
name|delim
condition|;
name|end
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
for|for
control|(
name|beg
operator|=
name|end
operator|=
literal|0
init|;
name|whitespace
argument_list|(
name|v
index|[
name|end
index|]
argument_list|)
operator|==
literal|0
condition|;
name|end
operator|++
control|)
empty_stmt|;
block|}
name|v
index|[
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* The value starts at v + beg.  Translate it into a character string. */
name|_rl_isearch_terminators
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|v
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_translate_keyseq
argument_list|(
name|v
operator|+
name|beg
argument_list|,
name|_rl_isearch_terminators
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|_rl_isearch_terminators
index|[
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the character which matches NAME.    For example, `Space' returns ' '. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|assoc_list
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|assoc_list
name|name_key_alist
index|[]
init|=
block|{
block|{
literal|"DEL"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"ESC"
block|,
literal|'\033'
block|}
block|,
block|{
literal|"Escape"
block|,
literal|'\033'
block|}
block|,
block|{
literal|"LFD"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"Newline"
block|,
literal|'\n'
block|}
block|,
block|{
literal|"RET"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"Return"
block|,
literal|'\r'
block|}
block|,
block|{
literal|"Rubout"
block|,
literal|0x7f
block|}
block|,
block|{
literal|"SPC"
block|,
literal|' '
block|}
block|,
block|{
literal|"Space"
block|,
literal|' '
block|}
block|,
block|{
literal|"Tab"
block|,
literal|0x09
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|glean_key_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
name|name_key_alist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_key_alist
index|[
name|i
index|]
operator|.
name|value
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|name
operator|)
return|;
comment|/* XXX was return (*name) */
block|}
end_function

begin_comment
comment|/* Auxiliary functions to manage keymaps. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|}
name|keymap_names
index|[]
init|=
block|{
block|{
literal|"emacs"
block|,
name|emacs_standard_keymap
block|}
block|,
block|{
literal|"emacs-standard"
block|,
name|emacs_standard_keymap
block|}
block|,
block|{
literal|"emacs-meta"
block|,
name|emacs_meta_keymap
block|}
block|,
block|{
literal|"emacs-ctlx"
block|,
name|emacs_ctlx_keymap
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
block|{
literal|"vi"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-move"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-command"
block|,
name|vi_movement_keymap
block|}
block|,
block|{
literal|"vi-insert"
block|,
name|vi_insertion_keymap
block|}
block|,
endif|#
directive|endif
comment|/* VI_MODE */
block|{
operator|(
name|char
operator|*
operator|)
literal|0x0
block|,
operator|(
name|Keymap
operator|)
literal|0x0
block|}
block|}
struct|;
end_struct

begin_function
name|Keymap
name|rl_get_keymap_by_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|keymap_names
index|[
name|i
index|]
operator|.
name|map
operator|)
return|;
return|return
operator|(
operator|(
name|Keymap
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_get_keymap_name
parameter_list|(
name|map
parameter_list|)
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|map
operator|==
name|keymap_names
index|[
name|i
index|]
operator|.
name|map
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|keymap_names
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rl_set_keymap
parameter_list|(
name|map
parameter_list|)
name|Keymap
name|map
decl_stmt|;
block|{
if|if
condition|(
name|map
condition|)
name|_rl_keymap
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_function
name|Keymap
name|rl_get_keymap
parameter_list|()
block|{
return|return
operator|(
name|_rl_keymap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rl_set_keymap_from_edit_mode
parameter_list|()
block|{
if|if
condition|(
name|rl_editing_mode
operator|==
name|emacs_mode
condition|)
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
end_function

begin_function
name|char
modifier|*
name|rl_get_keymap_name_from_edit_mode
parameter_list|()
block|{
if|if
condition|(
name|rl_editing_mode
operator|==
name|emacs_mode
condition|)
return|return
literal|"emacs"
return|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
return|return
literal|"vi"
return|;
endif|#
directive|endif
comment|/* VI_MODE */
else|else
return|return
literal|"none"
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		  Key Binding and Function Information		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Each of the following functions produces information about the    state of keybindings and functions known to Readline.  The info    is always printed to rl_outstream, and in such a way that it can    be read back in (i.e., passed to rl_parse_and_bind ()). */
end_comment

begin_comment
comment|/* Print the names of functions known to Readline. */
end_comment

begin_function
name|void
name|rl_list_funmap_names
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|funmap_names
decl_stmt|;
name|funmap_names
operator|=
name|rl_funmap_names
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|funmap_names
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|funmap_names
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s\n"
argument_list|,
name|funmap_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|funmap_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|_rl_get_keyname
parameter_list|(
name|key
parameter_list|)
name|int
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|keyname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|keyname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|c
operator|=
name|key
expr_stmt|;
comment|/* Since this is going to be used to write out keysequence-function      pairs for possible inclusion in an inputrc file, we don't want to      do any special meta processing on KEY. */
if|#
directive|if
literal|1
comment|/* XXX - Experimental */
comment|/* We might want to do this, but the old version of the code did not. */
comment|/* If this is an escape character, we don't want to do any more processing.      Just add the special ESC key sequence and return. */
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
literal|'e'
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|keyname
return|;
block|}
endif|#
directive|endif
comment|/* RUBOUT is translated directly into \C-? */
if|if
condition|(
name|key
operator|==
name|RUBOUT
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'-'
expr_stmt|;
name|keyname
index|[
literal|3
index|]
operator|=
literal|'?'
expr_stmt|;
name|keyname
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|keyname
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now add special prefixes needed for control characters.  This can      potentially change C. */
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'C'
expr_stmt|;
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|c
operator|=
name|_rl_to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* XXX experimental code.  Turn the characters that are not ASCII or      ISO Latin 1 (128 - 159) into octal escape sequences (\200 - \237).      This changes C. */
if|if
condition|(
name|c
operator|>=
literal|128
operator|&&
name|c
operator|<=
literal|159
condition|)
block|{
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'2'
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
name|keyname
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|c
operator|/
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
name|c
operator|=
operator|(
name|c
operator|%
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
comment|/* Now, if the character needs to be quoted with a backslash, do that. */
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'"'
condition|)
name|keyname
index|[
name|i
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
comment|/* Now add the key, terminate the string, and return it. */
name|keyname
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|keyname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|keyname
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of strings which represent the key    sequences that are used to invoke FUNCTION in MAP. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs_in_map
parameter_list|(
name|function
parameter_list|,
name|map
parameter_list|)
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|key
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|result_index
decl_stmt|,
name|result_size
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|result_index
operator|=
name|result_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|KEYMAP_SIZE
condition|;
name|key
operator|++
control|)
block|{
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISMACR
case|:
comment|/* Macros match, if, and only if, the pointers are identical. 	     Thus, they are treated exactly like functions in here. */
case|case
name|ISFUNC
case|:
comment|/* If the function in the keymap is the one we are looking for, 	     then add the current KEY to the list of invoking keys. */
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|==
name|function
condition|)
block|{
name|char
modifier|*
name|keyname
decl_stmt|;
name|keyname
operator|=
name|_rl_get_keyname
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>
name|result_size
condition|)
block|{
name|result_size
operator|+=
literal|10
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
operator|++
index|]
operator|=
name|keyname
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|ISKMAP
case|:
block|{
name|char
modifier|*
modifier|*
name|seqs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Find the list of keyseqs in this map which have FUNCTION as 	       their target.  Add the key sequences found to RESULT. */
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
condition|)
name|seqs
operator|=
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|seqs
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|seqs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|keyname
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|6
operator|+
name|strlen
argument_list|(
name|seqs
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|ESC
condition|)
block|{
comment|/* If ESC is the meta prefix and we're converting chars 		       with the eighth bit set to ESC-prefixed sequences, then 		       we can use \M-.  Otherwise we need to use the sequence 		       for ESC. */
if|if
condition|(
name|_rl_convert_meta_chars_to_ascii
operator|&&
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\M-"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\e"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|key
argument_list|)
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-%c"
argument_list|,
name|_rl_to_lower
argument_list|(
name|UNCTRL
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
name|RUBOUT
condition|)
name|sprintf
argument_list|(
name|keyname
argument_list|,
literal|"\\C-?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
operator|||
name|key
operator|==
literal|'"'
condition|)
block|{
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|keyname
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|keyname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|keyname
argument_list|,
name|seqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>
name|result_size
condition|)
block|{
name|result_size
operator|+=
literal|10
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
operator|++
index|]
operator|=
name|keyname
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|seqs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of strings which represent the key    sequences that can be used to invoke FUNCTION using the current keymap. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs
parameter_list|(
name|function
parameter_list|)
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
block|{
return|return
operator|(
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print all of the functions and their bindings to rl_outstream.  If    PRINT_READABLY is non-zero, then print the output in such a way    that it can be read back in. */
end_comment

begin_function
name|void
name|rl_function_dumper
parameter_list|(
name|print_readably
parameter_list|)
name|int
name|print_readably
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|names
operator|=
name|rl_funmap_names
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|name
operator|=
name|names
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
name|char
modifier|*
modifier|*
name|invokers
decl_stmt|;
name|function
operator|=
name|rl_named_function
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|invokers
operator|=
name|rl_invoking_keyseqs_in_map
argument_list|(
name|function
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_readably
condition|)
block|{
if|if
condition|(
operator|!
name|invokers
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"# %s (not bound)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\"%s\": %s\n"
argument_list|,
name|invokers
index|[
name|j
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|invokers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|invokers
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|invokers
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s is not bound to any keys\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s can be found on "
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
operator|&&
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\"%s\"%s"
argument_list|,
name|invokers
index|[
name|j
index|]
argument_list|,
name|invokers
index|[
name|j
operator|+
literal|1
index|]
condition|?
literal|", "
else|:
literal|".\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|5
operator|&&
name|invokers
index|[
name|j
index|]
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|invokers
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|invokers
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|invokers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print all of the current functions and their bindings to    rl_outstream.  If an explicit argument is given, then print    the output in such a way that it can be read back in. */
end_comment

begin_function
name|int
name|rl_dump_functions
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_dispatching
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|rl_function_dumper
argument_list|(
name|rl_explicit_arg
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_macro_dumper_internal
parameter_list|(
name|print_readably
parameter_list|,
name|map
parameter_list|,
name|prefix
parameter_list|)
name|int
name|print_readably
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|register
name|int
name|key
decl_stmt|;
name|char
modifier|*
name|keyname
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|int
name|prefix_len
decl_stmt|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|KEYMAP_SIZE
condition|;
name|key
operator|++
control|)
block|{
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISMACR
case|:
name|keyname
operator|=
name|_rl_get_keyname
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|out
operator|=
name|_rl_untranslate_macro_value
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_readably
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\"%s%s\": \"%s\"\n"
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|""
argument_list|,
name|keyname
argument_list|,
name|out
condition|?
name|out
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s%s outputs %s\n"
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|""
argument_list|,
name|keyname
argument_list|,
name|out
condition|?
name|out
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISFUNC
case|:
break|break;
case|case
name|ISKMAP
case|:
name|prefix_len
operator|=
name|prefix
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|ESC
condition|)
block|{
name|keyname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|prefix_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|strcpy
argument_list|(
name|keyname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|keyname
index|[
name|prefix_len
index|]
operator|=
literal|'\\'
expr_stmt|;
name|keyname
index|[
name|prefix_len
operator|+
literal|1
index|]
operator|=
literal|'e'
expr_stmt|;
name|keyname
index|[
name|prefix_len
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|keyname
operator|=
name|_rl_get_keyname
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|keyname
argument_list|)
operator|+
name|prefix_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|out
operator|+
name|prefix_len
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
name|keyname
operator|=
name|out
expr_stmt|;
block|}
block|}
name|_rl_macro_dumper_internal
argument_list|(
name|print_readably
argument_list|,
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|rl_macro_dumper
parameter_list|(
name|print_readably
parameter_list|)
name|int
name|print_readably
decl_stmt|;
block|{
name|_rl_macro_dumper_internal
argument_list|(
name|print_readably
argument_list|,
name|_rl_keymap
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rl_dump_macros
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_dispatching
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|rl_macro_dumper
argument_list|(
name|rl_explicit_arg
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|_rl_get_string_variable_value
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|numbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"bell-style"
argument_list|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|_rl_bell_preference
condition|)
block|{
case|case
name|NO_BELL
case|:
return|return
literal|"none"
return|;
case|case
name|VISIBLE_BELL
case|:
return|return
literal|"visible"
return|;
case|case
name|AUDIBLE_BELL
case|:
default|default:
return|return
literal|"audible"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"comment-begin"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|_rl_comment_begin
condition|?
name|_rl_comment_begin
else|:
name|RL_COMMENT_BEGIN_DEFAULT
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"completion-query-items"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|numbuf
argument_list|,
literal|"%d"
argument_list|,
name|rl_completion_query_items
argument_list|)
expr_stmt|;
return|return
operator|(
name|numbuf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"editing-mode"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rl_get_keymap_name_from_edit_mode
argument_list|()
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"isearch-terminators"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_rl_isearch_terminators
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|_rl_untranslate_macro_value
argument_list|(
name|_rl_isearch_terminators
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strncpy
argument_list|(
name|numbuf
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|numbuf
index|[
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|numbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|numbuf
return|;
block|}
elseif|else
if|if
condition|(
name|_rl_stricmp
argument_list|(
name|name
argument_list|,
literal|"keymap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|rl_get_keymap_name
argument_list|(
name|_rl_keymap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|ret
operator|=
name|rl_get_keymap_name_from_edit_mode
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
condition|?
name|ret
else|:
literal|"none"
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rl_variable_dumper
parameter_list|(
name|print_readably
parameter_list|)
name|int
name|print_readably
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|print_readably
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"set %s %s\n"
argument_list|,
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s is set to `%s'\n"
argument_list|,
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|boolean_varlist
index|[
name|i
index|]
operator|.
name|value
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|_rl_get_string_variable_value
argument_list|(
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
comment|/* _rl_isearch_terminators can be NULL */
continue|continue;
if|if
condition|(
name|print_readably
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"set %s %s\n"
argument_list|,
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s is set to `%s'\n"
argument_list|,
name|string_varlist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print all of the current variables and their values to    rl_outstream.  If an explicit argument is given, then print    the output in such a way that it can be read back in. */
end_comment

begin_function
name|int
name|rl_dump_variables
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_dispatching
condition|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|rl_variable_dumper
argument_list|(
name|rl_explicit_arg
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if any members of ARRAY are a substring in STRING. */
end_comment

begin_function
specifier|static
name|int
name|substring_member_of_array
parameter_list|(
name|string
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|array
condition|)
block|{
if|if
condition|(
name|_rl_strindex
argument_list|(
name|string
argument_list|,
operator|*
name|array
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|array
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

