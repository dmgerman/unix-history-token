begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* histsearch.c -- searching the history list. */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_comment
comment|/* Variables imported from other history library files. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|history_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of alternate characters that can delimit a history search    string. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_search_delimiter_chars
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search the history for STRING, starting at history_offset.    If DIRECTION< 0, then the search is through previous entries, else    through subsequent.  If ANCHORED is non-zero, the string must    appear at the beginning of a history line, otherwise, the string    may appear anywhere in the line.  If the string is found, then    current_history () is the history entry, and the value of this    function is the offset in the line of that history entry that the    string was found in.  Otherwise, nothing is changed, and a -1 is    returned. */
end_comment

begin_function
specifier|static
name|int
name|history_search_internal
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|,
name|anchored
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|,
name|anchored
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|reverse
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|line_index
decl_stmt|;
name|int
name|string_len
decl_stmt|;
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
decl_stmt|;
comment|/* local */
name|i
operator|=
name|history_offset
expr_stmt|;
name|reverse
operator|=
operator|(
name|direction
operator|<
literal|0
operator|)
expr_stmt|;
comment|/* Take care of trivial cases first. */
if|if
condition|(
name|string
operator|==
literal|0
operator|||
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|history_length
operator|||
operator|(
operator|(
name|i
operator|==
name|history_length
operator|)
operator|&&
operator|!
name|reverse
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|reverse
operator|&&
operator|(
name|i
operator|==
name|history_length
operator|)
condition|)
name|i
operator|--
expr_stmt|;
define|#
directive|define
name|NEXT_LINE
parameter_list|()
value|do { if (reverse) i--; else i++; } while (0)
name|the_history
operator|=
name|history_list
argument_list|()
expr_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Search each line in the history list for STRING. */
comment|/* At limit for direction? */
if|if
condition|(
operator|(
name|reverse
operator|&&
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|reverse
operator|&&
name|i
operator|==
name|history_length
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|line
operator|=
name|the_history
index|[
name|i
index|]
operator|->
name|line
expr_stmt|;
name|line_index
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If STRING is longer than line, no match. */
if|if
condition|(
name|string_len
operator|>
name|line_index
condition|)
block|{
name|NEXT_LINE
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Handle anchored searches first. */
if|if
condition|(
name|anchored
operator|==
name|ANCHORED_SEARCH
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NEXT_LINE
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Do substring search. */
if|if
condition|(
name|reverse
condition|)
block|{
name|line_index
operator|-=
name|string_len
expr_stmt|;
while|while
condition|(
name|line_index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|line_index
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|line_index
operator|)
return|;
block|}
name|line_index
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|int
name|limit
decl_stmt|;
name|limit
operator|=
name|line_index
operator|-
name|string_len
operator|+
literal|1
expr_stmt|;
name|line_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|line_index
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|string
argument_list|,
name|line
operator|+
name|line_index
argument_list|,
name|string_len
argument_list|)
condition|)
block|{
name|history_offset
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|line_index
operator|)
return|;
block|}
name|line_index
operator|++
expr_stmt|;
block|}
block|}
name|NEXT_LINE
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a non-anchored search for STRING through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|NON_ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do an anchored search for string through the history in DIRECTION. */
end_comment

begin_function
name|int
name|history_search_prefix
parameter_list|(
name|string
parameter_list|,
name|direction
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|direction
decl_stmt|;
block|{
return|return
operator|(
name|history_search_internal
argument_list|(
name|string
argument_list|,
name|direction
argument_list|,
name|ANCHORED_SEARCH
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING in the history list.  DIR is< 0 for searching    backwards.  POS is an absolute index into the history list at    which point to begin searching. */
end_comment

begin_function
name|int
name|history_search_pos
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
decl_stmt|;
name|old
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

