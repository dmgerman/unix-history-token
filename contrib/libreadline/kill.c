begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* kill.c -- kill ring management. */
end_comment

begin_comment
comment|/* Copyright (C) 1994 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 1, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* for _POSIX_VERSION */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|_rl_last_command_was_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_editing_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_explicit_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Function
modifier|*
name|rl_last_func
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|_rl_init_argument
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|_rl_set_mark_at_pos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_fix_point
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_rl_abort_internal
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Mechanism			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* What we assume for a max number of kills. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_KILLS
value|10
end_define

begin_comment
comment|/* The real variable to look at to find out when to flush kills. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_max_kills
init|=
name|DEFAULT_MAX_KILLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to store killed text. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|rl_kill_ring
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where we are in the kill ring. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_kill_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many slots we have in the kill ring. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_kill_ring_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to say that you only want to save a certain amount    of kill material. */
end_comment

begin_function
name|int
name|rl_set_retained_kills
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add TEXT to the kill ring, allocating a new kill ring slot as necessary.    This uses TEXT directly, so the caller must not free it.  If APPEND is    non-zero, and the last command was a kill, the text is appended to the    current kill ring slot, otherwise prepended. */
end_comment

begin_function
specifier|static
name|int
name|_rl_copy_to_kill_ring
parameter_list|(
name|text
parameter_list|,
name|append
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|append
decl_stmt|;
block|{
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|int
name|slot
decl_stmt|;
comment|/* First, find the slot to work with. */
if|if
condition|(
name|_rl_last_command_was_kill
operator|==
literal|0
condition|)
block|{
comment|/* Get a new slot.  */
if|if
condition|(
name|rl_kill_ring
operator|==
literal|0
condition|)
block|{
comment|/* If we don't have any defined, then make one. */
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|rl_kill_ring_length
operator|=
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rl_kill_ring
index|[
name|slot
operator|=
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We have to add a new slot on the end, unless we have 	     exceeded the max limit for remembering kills. */
name|slot
operator|=
name|rl_kill_ring_length
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|rl_max_kills
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|rl_kill_ring
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slot
condition|;
name|i
operator|++
control|)
name|rl_kill_ring
index|[
name|i
index|]
operator|=
name|rl_kill_ring
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|=
name|rl_kill_ring_length
operator|+=
literal|1
expr_stmt|;
name|rl_kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|rl_kill_ring
argument_list|,
name|slot
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rl_kill_ring
index|[
operator|--
name|slot
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|slot
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
comment|/* If the last command was a kill, prepend or append. */
if|if
condition|(
name|_rl_last_command_was_kill
operator|&&
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
block|{
name|old
operator|=
name|rl_kill_ring
index|[
name|slot
index|]
expr_stmt|;
name|new
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|append
condition|)
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|new
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
name|rl_kill_ring
index|[
name|slot
index|]
operator|=
name|text
expr_stmt|;
name|rl_kill_index
operator|=
name|slot
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The way to kill something.  This appends or prepends to the last    kill, if the last command was a kill command.  if FROM is less    than TO, then the text is appended, otherwise prepended.  If the    last command was not a kill command, then a new slot is made for    this kill. */
end_comment

begin_function
name|int
name|rl_kill_text
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Is there anything to kill? */
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
name|_rl_last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|text
operator|=
name|rl_copy_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Delete the copied text from the line. */
name|rl_delete_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|_rl_copy_to_kill_ring
argument_list|(
name|text
argument_list|,
name|from
operator|<
name|to
argument_list|)
expr_stmt|;
name|_rl_last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Now REMEMBER!  In order to do prepending or appending correctly, kill    commands always make rl_point's original position be the FROM argument,    and rl_point's extent be the TO argument. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Killing Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Delete the word at point, saving the text in the kill ring. */
end_comment

begin_function
name|int
name|rl_kill_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_kill_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_forward_word
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Rubout the word before point, placing it on the kill ring. */
end_comment

begin_function
name|int
name|rl_backward_kill_word
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_kill_word
argument_list|(
operator|-
name|count
argument_list|,
name|ignore
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_backward_word
argument_list|(
name|count
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|!=
name|orig_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Kill from here to the end of the line.  If DIRECTION is negative, kill    back to the line start instead. */
end_comment

begin_function
name|int
name|rl_kill_line
parameter_list|(
name|direction
parameter_list|,
name|ignore
parameter_list|)
name|int
name|direction
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_backward_kill_line
argument_list|(
literal|1
argument_list|,
name|ignore
argument_list|)
operator|)
return|;
else|else
block|{
name|rl_end_of_line
argument_list|(
literal|1
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_point
operator|!=
name|rl_point
condition|)
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Kill backwards to the start of the line.  If DIRECTION is negative, kill    forwards to the line end instead. */
end_comment

begin_function
name|int
name|rl_backward_kill_line
parameter_list|(
name|direction
parameter_list|,
name|ignore
parameter_list|)
name|int
name|direction
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_kill_line
argument_list|(
literal|1
argument_list|,
name|ignore
argument_list|)
operator|)
return|;
else|else
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Kill the whole line, no matter where point is. */
end_comment

begin_function
name|int
name|rl_kill_full_line
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_end
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The next two functions mimic unix line editing behaviour, except they    save the deleted text on the kill ring.  This is safer than not saving    it, and since we have a ring, nobody should get screwed. */
end_comment

begin_comment
comment|/* This does what C-w does in Unix.  We can't prevent people from    using behaviour that they expect. */
end_comment

begin_function
name|int
name|rl_unix_word_rubout
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|orig_point
decl_stmt|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|orig_point
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|&&
operator|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|rl_point
operator|--
expr_stmt|;
block|}
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Here is C-u doing what Unix does.  You don't *have* to use these    key-bindings.  We have a choice of killing the entire line, or    killing from where we are to the start of the line.  We choose the    latter, because if you are a Unix weenie, then you haven't backspaced    into the line at all, and if you aren't, then you know what you are    doing. */
end_comment

begin_function
name|int
name|rl_unix_line_discard
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy the text in the `region' to the kill ring.  If DELETE is non-zero,    delete the text from the line as well. */
end_comment

begin_function
specifier|static
name|int
name|region_kill_internal
parameter_list|(
name|delete
parameter_list|)
name|int
name|delete
decl_stmt|;
block|{
name|char
modifier|*
name|text
decl_stmt|;
if|if
condition|(
name|rl_mark
operator|==
name|rl_point
condition|)
block|{
name|_rl_last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|text
operator|=
name|rl_copy_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|_rl_copy_to_kill_ring
argument_list|(
name|text
argument_list|,
name|rl_point
operator|<
name|rl_mark
argument_list|)
expr_stmt|;
name|_rl_last_command_was_kill
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy the text in the region to the kill ring. */
end_comment

begin_function
name|int
name|rl_copy_region_to_kill
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
return|return
operator|(
name|region_kill_internal
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Kill the text between the point and mark. */
end_comment

begin_function
name|int
name|rl_kill_region
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|region_kill_internal
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|_rl_fix_point
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Copy COUNT words to the kill ring.  DIR says which direction we look    to find the words. */
end_comment

begin_function
specifier|static
name|int
name|_rl_copy_word_as_kill
parameter_list|(
name|count
parameter_list|,
name|dir
parameter_list|)
name|int
name|count
decl_stmt|,
name|dir
decl_stmt|;
block|{
name|int
name|om
decl_stmt|,
name|op
decl_stmt|,
name|r
decl_stmt|;
name|om
operator|=
name|rl_mark
expr_stmt|;
name|op
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|rl_forward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_backward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_mark
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|rl_backward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_forward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|region_kill_internal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_mark
operator|=
name|om
expr_stmt|;
name|rl_point
operator|=
name|op
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|rl_copy_forward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_copy_backward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
return|return
operator|(
name|_rl_copy_word_as_kill
argument_list|(
name|count
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_copy_backward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_copy_forward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
return|return
operator|(
name|_rl_copy_word_as_kill
argument_list|(
name|count
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Yank back the last killed text.  This ignores arguments. */
end_comment

begin_function
name|int
name|rl_yank
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|rl_kill_ring
operator|==
literal|0
condition|)
block|{
name|_rl_abort_internal
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|_rl_set_mark_at_pos
argument_list|(
name|rl_point
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the last command was yank, or yank_pop, and the text just    before point is identical to the current kill item, then    delete that text from the line, rotate the index down, and    yank back some other text. */
end_comment

begin_function
name|int
name|rl_yank_pop
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|l
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|rl_last_func
operator|!=
name|rl_yank_pop
operator|)
operator|&&
operator|(
name|rl_last_func
operator|!=
name|rl_yank
operator|)
operator|)
operator|||
operator|!
name|rl_kill_ring
condition|)
block|{
name|_rl_abort_internal
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|rl_point
operator|-
name|l
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|STREQN
argument_list|(
name|rl_line_buffer
operator|+
name|n
argument_list|,
name|rl_kill_ring
index|[
name|rl_kill_index
index|]
argument_list|,
name|l
argument_list|)
condition|)
block|{
name|rl_delete_text
argument_list|(
name|n
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|n
expr_stmt|;
name|rl_kill_index
operator|--
expr_stmt|;
if|if
condition|(
name|rl_kill_index
operator|<
literal|0
condition|)
name|rl_kill_index
operator|=
name|rl_kill_ring_length
operator|-
literal|1
expr_stmt|;
name|rl_yank
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|_rl_abort_internal
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Yank the COUNTh argument from the previous history line, skipping    HISTORY_SKIP lines before looking for the `previous line'. */
end_comment

begin_function
specifier|static
name|int
name|rl_yank_nth_arg_internal
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|,
name|history_skip
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|,
name|history_skip
decl_stmt|;
block|{
specifier|register
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|history_skip
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_skip
condition|;
name|i
operator|++
control|)
name|entry
operator|=
name|previous_history
argument_list|()
expr_stmt|;
block|}
name|entry
operator|=
name|previous_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|history_skip
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_skip
condition|;
name|i
operator|++
control|)
name|next_history
argument_list|()
expr_stmt|;
block|}
name|next_history
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg
operator|=
name|history_arg_extract
argument_list|(
name|count
argument_list|,
name|count
argument_list|,
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
comment|/* Vi mode always inserts a space before yanking the argument, and it      inserts it right *after* rl_point. */
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
block|{
name|rl_vi_append_mode
argument_list|(
literal|1
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
name|rl_insert_text
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Yank the COUNTth argument from the previous history line. */
end_comment

begin_function
name|int
name|rl_yank_nth_arg
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
return|return
operator|(
name|rl_yank_nth_arg_internal
argument_list|(
name|count
argument_list|,
name|ignore
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Yank the last argument from the previous history line.  This `knows'    how rl_yank_nth_arg treats a count of `$'.  With an argument, this    behaves the same as rl_yank_nth_arg. */
end_comment

begin_function
name|int
name|rl_yank_last_arg
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
specifier|static
name|int
name|history_skip
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|explicit_arg_p
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|count_passed
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|direction
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|undo_needed
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|rl_last_func
operator|!=
name|rl_yank_last_arg
condition|)
block|{
name|history_skip
operator|=
literal|0
expr_stmt|;
name|explicit_arg_p
operator|=
name|rl_explicit_arg
expr_stmt|;
name|count_passed
operator|=
name|count
expr_stmt|;
name|direction
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|undo_needed
condition|)
name|rl_do_undo
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
condition|)
name|direction
operator|=
operator|-
name|direction
expr_stmt|;
name|history_skip
operator|+=
name|direction
expr_stmt|;
if|if
condition|(
name|history_skip
operator|<
literal|0
condition|)
name|history_skip
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|explicit_arg_p
condition|)
name|retval
operator|=
name|rl_yank_nth_arg_internal
argument_list|(
name|count_passed
argument_list|,
name|key
argument_list|,
name|history_skip
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|rl_yank_nth_arg_internal
argument_list|(
literal|'$'
argument_list|,
name|key
argument_list|,
name|history_skip
argument_list|)
expr_stmt|;
name|undo_needed
operator|=
name|retval
operator|==
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* A special paste command for users of Cygnus's cygwin32. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_function
name|int
name|rl_paste_from_clipboard
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|OpenClipboard
argument_list|(
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|GetClipboardData
argument_list|(
name|CF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|data
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|len
operator|=
name|ptr
operator|-
name|data
expr_stmt|;
name|ptr
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|ptr
operator|=
name|data
expr_stmt|;
name|rl_insert_text
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|data
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|CloseClipboard
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CYGWIN32__ */
end_comment

end_unit

