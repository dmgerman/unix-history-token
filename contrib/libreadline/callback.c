begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* callback.c -- functions to use readline as an X `callback' mechanism. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"rlconf.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_comment
comment|/* Private data for callback registration functions.  See comments in    rl_callback_read_char for more details. */
end_comment

begin_decl_stmt
name|_rl_callback_func_t
modifier|*
name|_rl_callback_func
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_rl_callback_generic_arg
modifier|*
name|_rl_callback_data
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Callback Readline Functions		 */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Allow using readline in situations where a program may have multiple    things to handle at once, and dispatches them via select().  Call    rl_callback_handler_install() with the prompt and a function to call    whenever a complete line of input is ready.  The user must then    call rl_callback_read_char() every time some input is available, and     rl_callback_read_char() will call the user's function with the complete    text read in at each end of line.  The terminal is kept prepped and    signals handled all the time, except during calls to the user's function. */
end_comment

begin_decl_stmt
name|rl_vcpfunc_t
modifier|*
name|rl_linefunc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user callback function */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_handler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal_prepped and signals set? */
end_comment

begin_comment
comment|/* Make sure the terminal is set up, initialize readline, and prompt. */
end_comment

begin_function
specifier|static
name|void
name|_rl_callback_newline
parameter_list|()
block|{
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_handler
operator|==
literal|0
condition|)
block|{
name|in_handler
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rl_prep_term_function
condition|)
call|(
modifier|*
name|rl_prep_term_function
call|)
argument_list|(
name|_rl_meta_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_set_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|readline_internal_setup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install a readline handler, set up the terminal, and issue the prompt. */
end_comment

begin_function
name|void
name|rl_callback_handler_install
parameter_list|(
name|prompt
parameter_list|,
name|linefunc
parameter_list|)
specifier|const
name|char
modifier|*
name|prompt
decl_stmt|;
name|rl_vcpfunc_t
modifier|*
name|linefunc
decl_stmt|;
block|{
name|rl_set_prompt
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
expr_stmt|;
name|rl_linefunc
operator|=
name|linefunc
expr_stmt|;
name|_rl_callback_newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read one character, and dispatch to the handler if it ends the line. */
end_comment

begin_function
name|void
name|rl_callback_read_char
parameter_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|eof
decl_stmt|,
name|jcode
decl_stmt|;
specifier|static
name|procenv_t
name|olevel
decl_stmt|;
if|if
condition|(
name|rl_linefunc
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: readline_callback_read_char() called with no handler!\r\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|olevel
argument_list|,
operator|(
name|void
operator|*
operator|)
name|readline_top_level
argument_list|,
sizeof|sizeof
argument_list|(
name|procenv_t
argument_list|)
argument_list|)
expr_stmt|;
name|jcode
operator|=
name|setjmp
argument_list|(
name|readline_top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|jcode
condition|)
block|{
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|readline_top_level
argument_list|,
operator|(
name|void
operator|*
operator|)
name|olevel
argument_list|,
sizeof|sizeof
argument_list|(
name|procenv_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_ISEARCH
argument_list|)
condition|)
block|{
name|eof
operator|=
name|_rl_isearch_callback
argument_list|(
name|_rl_iscxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
operator|==
literal|0
operator|&&
operator|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_ISEARCH
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|RL_ISSTATE
argument_list|(
name|RL_STATE_INPUTPENDING
argument_list|)
condition|)
name|rl_callback_read_char
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_NSEARCH
argument_list|)
condition|)
block|{
name|eof
operator|=
name|_rl_nsearch_callback
argument_list|(
name|_rl_nscxt
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_NUMERICARG
argument_list|)
condition|)
block|{
name|eof
operator|=
name|_rl_arg_callback
argument_list|(
name|_rl_argcxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
operator|==
literal|0
operator|&&
operator|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_NUMERICARG
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|RL_ISSTATE
argument_list|(
name|RL_STATE_INPUTPENDING
argument_list|)
condition|)
name|rl_callback_read_char
argument_list|()
expr_stmt|;
comment|/* XXX - this should handle _rl_last_command_was_kill better */
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_NUMERICARG
argument_list|)
operator|==
literal|0
condition|)
name|_rl_internal_char_cleanup
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_MULTIKEY
argument_list|)
condition|)
block|{
name|eof
operator|=
name|_rl_dispatch_callback
argument_list|(
name|_rl_kscxt
argument_list|)
expr_stmt|;
comment|/* For now */
while|while
condition|(
operator|(
name|eof
operator|==
operator|-
literal|1
operator|||
name|eof
operator|==
operator|-
literal|2
operator|)
operator|&&
name|RL_ISSTATE
argument_list|(
name|RL_STATE_MULTIKEY
argument_list|)
operator|&&
name|_rl_kscxt
operator|&&
operator|(
name|_rl_kscxt
operator|->
name|flags
operator|&
name|KSEQ_DISPATCHED
operator|)
condition|)
name|eof
operator|=
name|_rl_dispatch_callback
argument_list|(
name|_rl_kscxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_MULTIKEY
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_rl_internal_char_cleanup
argument_list|()
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|_rl_callback_func
condition|)
block|{
comment|/* This allows functions that simply need to read an additional character 	 (like quoted-insert) to register a function to be called when input is 	 available.  _rl_callback_data is simply a pointer to a struct that has 	 the argument count originally passed to the registering function and 	 space for any additional parameters.  */
name|eof
operator|=
call|(
modifier|*
name|_rl_callback_func
call|)
argument_list|(
name|_rl_callback_data
argument_list|)
expr_stmt|;
comment|/* If the function `deregisters' itself, make sure the data is cleaned 	 up. */
if|if
condition|(
name|_rl_callback_func
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_rl_callback_data
condition|)
block|{
name|_rl_callback_data_dispose
argument_list|(
name|_rl_callback_data
argument_list|)
expr_stmt|;
name|_rl_callback_data
operator|=
literal|0
expr_stmt|;
block|}
name|_rl_internal_char_cleanup
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|eof
operator|=
name|readline_internal_char
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_done
operator|==
literal|0
operator|&&
name|_rl_want_redisplay
condition|)
block|{
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We loop in case some function has pushed input back with rl_execute_next. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rl_done
condition|)
block|{
name|line
operator|=
name|readline_internal_teardown
argument_list|(
name|eof
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_deprep_term_function
condition|)
call|(
modifier|*
name|rl_deprep_term_function
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_clear_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|in_handler
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|rl_linefunc
call|)
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If the user did not clear out the line, do it for him. */
if|if
condition|(
name|rl_line_buffer
index|[
literal|0
index|]
condition|)
name|_rl_init_line_state
argument_list|()
expr_stmt|;
comment|/* Redisplay the prompt if readline_handler_{install,remove} 	     not called. */
if|if
condition|(
name|in_handler
operator|==
literal|0
operator|&&
name|rl_linefunc
condition|)
name|_rl_callback_newline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rl_pending_input
operator|||
name|_rl_pushed_input_available
argument_list|()
operator|||
name|RL_ISSTATE
argument_list|(
name|RL_STATE_MACROINPUT
argument_list|)
condition|)
name|eof
operator|=
name|readline_internal_char
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Remove the handler, and make sure the terminal is in its normal state. */
end_comment

begin_function
name|void
name|rl_callback_handler_remove
parameter_list|()
block|{
name|rl_linefunc
operator|=
name|NULL
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_handler
condition|)
block|{
name|in_handler
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rl_deprep_term_function
condition|)
call|(
modifier|*
name|rl_deprep_term_function
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_clear_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|_rl_callback_generic_arg
modifier|*
name|_rl_callback_data_alloc
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|_rl_callback_generic_arg
modifier|*
name|arg
decl_stmt|;
name|arg
operator|=
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|_rl_callback_generic_arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|arg
operator|->
name|i1
operator|=
name|arg
operator|->
name|i2
operator|=
literal|0
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|void
name|_rl_callback_data_dispose
parameter_list|(
name|arg
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
condition|)
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

