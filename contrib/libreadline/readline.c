begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readline.c -- a general facility for reading lines of input    with emacs style editing and completion. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LOCALE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"posixjmp.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
end_if

begin_define
define|#
directive|define
name|INCL_DOSPROCESS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __EMX__ */
end_comment

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|RL_LIBRARY_VERSION
end_ifndef

begin_define
define|#
directive|define
name|RL_LIBRARY_VERSION
value|"4.1"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Evaluates its arguments multiple times. */
end_comment

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
value|do { int t; t = s; s = e; e = t; } while (0)
end_define

begin_comment
comment|/* Forward declarations used in this file. */
end_comment

begin_decl_stmt
name|void
name|_rl_free_history_entry
name|__P
argument_list|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|readline_internal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readline_initialize_everything
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_using_history
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bind_arrow_keys
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_change_case
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readline_default_bindings
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Line editing input utility		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_library_version
init|=
name|RL_LIBRARY_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_gnu_readline_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the keymap that is currently in use.    By default, it is the standard emacs keymap. */
end_comment

begin_decl_stmt
name|Keymap
name|_rl_keymap
init|=
name|emacs_standard_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current style of editing. */
end_comment

begin_decl_stmt
name|int
name|rl_editing_mode
init|=
name|emacs_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we called this function from _rl_dispatch().  It's present    so functions can find out whether they were called from a key binding    or directly from an application. */
end_comment

begin_decl_stmt
name|int
name|rl_dispatching
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the previous command was a kill command. */
end_comment

begin_decl_stmt
name|int
name|_rl_last_command_was_kill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current value of the numeric argument specified by the user. */
end_comment

begin_decl_stmt
name|int
name|rl_numeric_arg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if an argument was typed. */
end_comment

begin_decl_stmt
name|int
name|rl_explicit_arg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary value used while generating the argument. */
end_comment

begin_decl_stmt
name|int
name|rl_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means we have been called at least once before. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rl_initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this program is running in an EMACS buffer. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|running_in_emacs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current offset in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark in the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_mark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the current input line. */
end_comment

begin_decl_stmt
name|int
name|rl_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make this non-zero to return the current input_line. */
end_comment

begin_decl_stmt
name|int
name|rl_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last function executed by readline. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_last_func
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top level environment for readline_internal (). */
end_comment

begin_decl_stmt
name|procenv_t
name|readline_top_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The streams we interact with. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|_rl_in_stream
decl_stmt|,
modifier|*
name|_rl_out_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The names of the streams that we do input and output to. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|rl_instream
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_outstream
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means echo characters as they are read. */
end_comment

begin_decl_stmt
name|int
name|readline_echoing_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_visible_prompt_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero by calling application if it has already printed rl_prompt    and does not want readline to do it the first time. */
end_comment

begin_decl_stmt
name|int
name|rl_already_prompted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters read in order to type this complete command. */
end_comment

begin_decl_stmt
name|int
name|rl_key_sequence_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then this is the address of a function to call just    before readline_internal_setup () prints the first prompt. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_startup_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is the address of a function to call just before    readline_internal_setup () returns and readline_internal starts    reading input characters. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_pre_input_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we use internally.  You should always refer to RL_LINE_BUFFER. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that can generate an EOF.  Really read from    the terminal driver... just defaulted here. */
end_comment

begin_decl_stmt
name|int
name|_rl_eof_char
init|=
name|CTRL
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero makes this the next keystroke to read. */
end_comment

begin_decl_stmt
name|int
name|rl_pending_input
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a useful terminal name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_terminal_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to always use horizontal scrolling in line display. */
end_comment

begin_decl_stmt
name|int
name|_rl_horizontal_scroll_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to display an asterisk at the starts of history lines    which have been modified. */
end_comment

begin_decl_stmt
name|int
name|_rl_mark_modified_lines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The style of `bell' notification preferred.  This can be set to NO_BELL,    AUDIBLE_BELL, or VISIBLE_BELL. */
end_comment

begin_decl_stmt
name|int
name|_rl_bell_preference
init|=
name|AUDIBLE_BELL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String inserted into the line by rl_insert_comment (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_rl_comment_begin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap holding the function currently being executed. */
end_comment

begin_decl_stmt
name|Keymap
name|rl_executing_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to erase entire line, including prompt, on empty input lines. */
end_comment

begin_decl_stmt
name|int
name|rl_erase_empty_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to read only this many characters rather than up to a    character bound to accept-line. */
end_comment

begin_decl_stmt
name|int
name|rl_num_chars_to_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line buffer and maintenence. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_line_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_line_buffer_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations used by the display and termcap code. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			`Forward' declarations  		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means do not parse any lines other than comments and    parser directives. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|_rl_parsing_conditionalized_out
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to convert characters with the meta bit set to    escape-prefixed characters so we can indirect through    emacs_meta_keymap or vi_escape_keymap. */
end_comment

begin_decl_stmt
name|int
name|_rl_convert_meta_chars_to_ascii
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to output characters with the meta bit set directly    rather than as a meta-prefixed escape sequence. */
end_comment

begin_decl_stmt
name|int
name|_rl_output_meta_chars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Top Level Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means treat 0200 bit in terminal input as Meta bit. */
end_comment

begin_decl_stmt
name|int
name|_rl_meta_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means    none.  A return value of NULL means that EOF was encountered. */
end_comment

begin_function
name|char
modifier|*
name|readline
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|rl_prompt
operator|=
name|prompt
expr_stmt|;
comment|/* If we are at EOF return a NULL string. */
if|if
condition|(
name|rl_pending_input
operator|==
name|EOF
condition|)
block|{
name|rl_pending_input
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|rl_visible_prompt_length
operator|=
name|rl_expand_prompt
argument_list|(
name|rl_prompt
argument_list|)
expr_stmt|;
name|rl_initialize
argument_list|()
expr_stmt|;
call|(
modifier|*
name|rl_prep_term_function
call|)
argument_list|(
name|_rl_meta_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_set_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|readline_internal
argument_list|()
expr_stmt|;
call|(
modifier|*
name|rl_deprep_term_function
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|rl_clear_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_define
define|#
directive|define
name|STATIC_CALLBACK
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STATIC_CALLBACK
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC_CALLBACK
name|void
name|readline_internal_setup
parameter_list|()
block|{
name|char
modifier|*
name|nprompt
decl_stmt|;
name|_rl_in_stream
operator|=
name|rl_instream
expr_stmt|;
name|_rl_out_stream
operator|=
name|rl_outstream
expr_stmt|;
if|if
condition|(
name|rl_startup_hook
condition|)
call|(
modifier|*
name|rl_startup_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|readline_echoing_p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rl_prompt
operator|&&
name|rl_already_prompted
operator|==
literal|0
condition|)
block|{
name|nprompt
operator|=
name|_rl_strip_prompt
argument_list|(
name|rl_prompt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|_rl_out_stream
argument_list|,
literal|"%s"
argument_list|,
name|nprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|_rl_out_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nprompt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rl_prompt
operator|&&
name|rl_already_prompted
condition|)
name|rl_on_new_line_with_prompt
argument_list|()
expr_stmt|;
else|else
name|rl_on_new_line
argument_list|()
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
if|if
condition|(
name|rl_pre_input_hook
condition|)
call|(
modifier|*
name|rl_pre_input_hook
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|STATIC_CALLBACK
name|char
modifier|*
name|readline_internal_teardown
parameter_list|(
name|eof
parameter_list|)
name|int
name|eof
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
comment|/* Restore the original of this history line, iff the line that we      are editing was originally in the history, AND the line has changed. */
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|rl_undo_list
condition|)
block|{
name|temp
operator|=
name|savestring
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|rl_revert_line
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
operator|(
name|histdata_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_rl_free_history_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* At any rate, it is highly likely that this line has an undo list.  Get      rid of it now. */
if|if
condition|(
name|rl_undo_list
condition|)
name|free_undo_list
argument_list|()
expr_stmt|;
return|return
operator|(
name|eof
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|savestring
argument_list|(
name|the_line
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC_CALLBACK
name|int
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
name|readline_internal_char
parameter_list|()
else|#
directive|else
function|readline_internal_charloop
parameter_list|()
endif|#
directive|endif
block|{
specifier|static
name|int
name|lastc
decl_stmt|,
name|eof_found
decl_stmt|;
name|int
name|c
decl_stmt|,
name|code
decl_stmt|,
name|lk
decl_stmt|;
name|lastc
operator|=
operator|-
literal|1
expr_stmt|;
name|eof_found
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
while|while
condition|(
name|rl_done
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|lk
operator|=
name|_rl_last_command_was_kill
expr_stmt|;
name|code
operator|=
name|setjmp
argument_list|(
name|readline_top_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
condition|)
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_pending_input
operator|==
literal|0
condition|)
block|{
comment|/* Then initialize the argument and number of keys read. */
name|_rl_init_argument
argument_list|()
expr_stmt|;
name|rl_key_sequence_length
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* EOF typed to a non-blank line is a<NL>. */
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|rl_end
condition|)
name|c
operator|=
name|NEWLINE
expr_stmt|;
comment|/* The character _rl_eof_char typed to blank line, and not as the 	 previous character is interpreted as EOF. */
if|if
condition|(
operator|(
operator|(
name|c
operator|==
name|_rl_eof_char
operator|&&
name|lastc
operator|!=
name|c
operator|)
operator|||
name|c
operator|==
name|EOF
operator|)
operator|&&
operator|!
name|rl_end
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
return|return
operator|(
name|rl_done
operator|=
literal|1
operator|)
return|;
else|#
directive|else
name|eof_found
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|lastc
operator|=
name|c
expr_stmt|;
name|_rl_dispatch
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
comment|/* If there was no change in _rl_last_command_was_kill, then no kill 	 has taken place.  Note that if input is pending we are reading 	 a prefix command, so nothing has changed yet. */
if|if
condition|(
name|rl_pending_input
operator|==
literal|0
operator|&&
name|lk
operator|==
name|_rl_last_command_was_kill
condition|)
name|_rl_last_command_was_kill
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
comment|/* In vi mode, when you exit insert mode, the cursor moves back 	 over the previous character.  We explicitly check for that here. */
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|&&
name|_rl_keymap
operator|==
name|vi_movement_keymap
condition|)
name|rl_vi_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
if|if
condition|(
name|rl_num_chars_to_read
operator|&&
name|rl_end
operator|>=
name|rl_num_chars_to_read
condition|)
block|{
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rl_done
operator|==
literal|0
condition|)
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
comment|/* If the application writer has told us to erase the entire line if 	  the only character typed was something bound to rl_newline, do so. */
if|if
condition|(
name|rl_erase_empty_line
operator|&&
name|rl_done
operator|&&
name|rl_last_func
operator|==
name|rl_newline
operator|&&
name|rl_point
operator|==
literal|0
operator|&&
name|rl_end
operator|==
literal|0
condition|)
name|_rl_erase_entire_line
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
return|return
literal|0
return|;
else|#
directive|else
block|}
return|return
operator|(
name|eof_found
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|readline_internal_charloop
parameter_list|()
block|{
name|int
name|eof
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|rl_done
operator|==
literal|0
condition|)
name|eof
operator|=
name|readline_internal_char
argument_list|()
expr_stmt|;
return|return
operator|(
name|eof
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READLINE_CALLBACKS */
end_comment

begin_comment
comment|/* Read a line of input from the global rl_instream, doing output on    the global rl_outstream.    If rl_prompt is non-null, then that is our prompt. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readline_internal
parameter_list|()
block|{
name|int
name|eof
decl_stmt|;
name|readline_internal_setup
argument_list|()
expr_stmt|;
name|eof
operator|=
name|readline_internal_charloop
argument_list|()
expr_stmt|;
return|return
operator|(
name|readline_internal_teardown
argument_list|(
name|eof
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_rl_init_line_state
parameter_list|()
block|{
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
name|the_line
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_set_the_line
parameter_list|()
block|{
name|the_line
operator|=
name|rl_line_buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the command associated with KEY in MAP.    If the associated command is really a keymap, then read    another key, and dispatch into that map. */
end_comment

begin_function
name|int
name|_rl_dispatch
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
specifier|register
name|int
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|int
name|r
decl_stmt|,
name|newkey
decl_stmt|;
name|char
modifier|*
name|macro
decl_stmt|;
name|Function
modifier|*
name|func
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|key
argument_list|)
operator|&&
name|_rl_convert_meta_chars_to_ascii
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
if|if
condition|(
name|_rl_defining_kbd_macro
condition|)
name|_rl_add_macro_char
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
name|map
operator|=
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
name|key
operator|=
name|UNMETA
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|rl_key_sequence_length
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|key
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
else|else
name|ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|_rl_defining_kbd_macro
condition|)
name|_rl_add_macro_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISFUNC
case|:
name|func
operator|=
name|map
index|[
name|key
index|]
operator|.
name|function
expr_stmt|;
if|if
condition|(
name|func
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Special case rl_do_lowercase_version (). */
if|if
condition|(
name|func
operator|==
name|rl_do_lowercase_version
condition|)
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|_rl_to_lower
argument_list|(
name|key
argument_list|)
argument_list|,
name|map
argument_list|)
operator|)
return|;
name|rl_executing_keymap
operator|=
name|map
expr_stmt|;
if|#
directive|if
literal|0
block|_rl_suppress_redisplay = (map[key].function == rl_insert)&& _rl_input_available ();
endif|#
directive|endif
name|rl_dispatching
operator|=
literal|1
expr_stmt|;
name|r
operator|=
operator|(
operator|*
name|map
index|[
name|key
index|]
operator|.
name|function
operator|)
operator|(
name|rl_numeric_arg
operator|*
name|rl_arg_sign
operator|,
name|key
operator|)
expr_stmt|;
name|rl_dispatching
operator|=
literal|0
expr_stmt|;
comment|/* If we have input pending, then the last command was a prefix 	     command.  Don't change the state of rl_last_func.  Otherwise, 	     remember the last command executed in this variable. */
if|if
condition|(
operator|!
name|rl_pending_input
operator|&&
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
name|rl_digit_argument
condition|)
name|rl_last_func
operator|=
name|map
index|[
name|key
index|]
operator|.
name|function
expr_stmt|;
block|}
else|else
block|{
name|_rl_abort_internal
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|ISKMAP
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
name|rl_key_sequence_length
operator|++
expr_stmt|;
name|newkey
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|r
operator|=
name|_rl_dispatch
argument_list|(
name|newkey
argument_list|,
name|FUNCTION_TO_KEYMAP
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_rl_abort_internal
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|ISMACR
case|:
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|Function
operator|*
operator|)
name|NULL
condition|)
block|{
name|macro
operator|=
name|savestring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|_rl_with_macro_input
argument_list|(
name|macro
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|&&
name|_rl_keymap
operator|==
name|vi_movement_keymap
operator|&&
name|_rl_vi_textmod_command
argument_list|(
name|key
argument_list|)
condition|)
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
name|rl_numeric_arg
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Initializations 			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Initialize readline (and terminal if not already). */
end_comment

begin_function
name|int
name|rl_initialize
parameter_list|()
block|{
comment|/* If we have never been called before, initialize the      terminal and data structures. */
if|if
condition|(
operator|!
name|rl_initialized
condition|)
block|{
name|readline_initialize_everything
argument_list|()
expr_stmt|;
name|rl_initialized
operator|++
expr_stmt|;
block|}
comment|/* Initalize the current line information. */
name|_rl_init_line_state
argument_list|()
expr_stmt|;
comment|/* We aren't done yet.  We haven't even gotten started yet! */
name|rl_done
operator|=
literal|0
expr_stmt|;
comment|/* Tell the history routines what is going on. */
name|start_using_history
argument_list|()
expr_stmt|;
comment|/* Make the display buffer match the state of the line. */
name|rl_reset_line_state
argument_list|()
expr_stmt|;
comment|/* No such function typed yet. */
name|rl_last_func
operator|=
operator|(
name|Function
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Parsing of key-bindings begins in an enabled state. */
name|_rl_parsing_conditionalized_out
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|_rl_vi_initialize_line
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
end_if

begin_endif
unit|static void _emx_build_environ () {   TIB *tibp;   PIB *pibp;   char *t, **tp;   int c;    DosGetInfoBlocks (&tibp,&pibp);   t = pibp->pib_pchenv;   for (c = 1; *t; c++)     t += strlen (t) + 1;   tp = environ = (char **)xmalloc ((c + 1) * sizeof (char *));   t = pibp->pib_pchenv;   while (*t)     {       *tp++ = t;       t += strlen (t) + 1;     }   *tp = 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* __EMX__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize the entire state of the world. */
end_comment

begin_function
specifier|static
name|void
name|readline_initialize_everything
parameter_list|()
block|{
if|#
directive|if
literal|0
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
block|if (environ == 0)     _emx_build_environ ();
endif|#
directive|endif
endif|#
directive|endif
comment|/* Find out if we are running in Emacs. */
name|running_in_emacs
operator|=
name|get_env_value
argument_list|(
literal|"EMACS"
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Set up input and output if they are not already set up. */
if|if
condition|(
operator|!
name|rl_instream
condition|)
name|rl_instream
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|rl_outstream
condition|)
name|rl_outstream
operator|=
name|stdout
expr_stmt|;
comment|/* Bind _rl_in_stream and _rl_out_stream immediately.  These values      may change, but they may also be used before readline_internal ()      is called. */
name|_rl_in_stream
operator|=
name|rl_instream
expr_stmt|;
name|_rl_out_stream
operator|=
name|rl_outstream
expr_stmt|;
comment|/* Allocate data structures. */
if|if
condition|(
name|rl_line_buffer
operator|==
literal|0
condition|)
name|rl_line_buffer
operator|=
name|xmalloc
argument_list|(
name|rl_line_buffer_len
operator|=
name|DEFAULT_BUFFER_SIZE
argument_list|)
expr_stmt|;
comment|/* Initialize the terminal interface. */
name|_rl_init_terminal_io
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Bind tty characters to readline functions. */
name|readline_default_bindings
argument_list|()
expr_stmt|;
comment|/* Initialize the function names. */
name|rl_initialize_funmap
argument_list|()
expr_stmt|;
comment|/* Decide whether we should automatically go into eight-bit mode. */
name|_rl_init_eightbit
argument_list|()
expr_stmt|;
comment|/* Read in the init file. */
name|rl_read_init_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_term_autowrap
condition|)
block|{
name|screenwidth
operator|--
expr_stmt|;
name|screenchars
operator|-=
name|screenheight
expr_stmt|;
block|}
comment|/* Override the effect of any `set keymap' assignments in the      inputrc file. */
name|rl_set_keymap_from_edit_mode
argument_list|()
expr_stmt|;
comment|/* Try to bind a common arrow key prefix, if not already bound. */
name|bind_arrow_keys
argument_list|()
expr_stmt|;
comment|/* Enable the meta key, if this terminal has one. */
if|if
condition|(
name|_rl_enable_meta
condition|)
name|_rl_enable_meta_key
argument_list|()
expr_stmt|;
comment|/* If the completion parser's default word break characters haven't      been set yet, then do so now. */
if|if
condition|(
name|rl_completer_word_break_characters
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|rl_completer_word_break_characters
operator|=
name|rl_basic_word_break_characters
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If this system allows us to look at the values of the regular    input editing characters, then bind them to their readline    equivalents, iff the characters are not bound to keymaps. */
end_comment

begin_function
specifier|static
name|void
name|readline_default_bindings
parameter_list|()
block|{
name|rltty_set_default_bindings
argument_list|(
name|_rl_keymap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bind_arrow_keys_internal
parameter_list|()
block|{
name|Function
modifier|*
name|f
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|f
operator|=
name|rl_function_of_keyseq
argument_list|(
literal|"\033[0A"
argument_list|,
name|_rl_keymap
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|||
name|f
operator|==
name|rl_do_lowercase_version
condition|)
block|{
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[0A"
argument_list|,
name|rl_get_previous_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[0B"
argument_list|,
name|rl_backward
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[0C"
argument_list|,
name|rl_forward
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[0D"
argument_list|,
name|rl_get_next_history
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|f
operator|=
name|rl_function_of_keyseq
argument_list|(
literal|"\033[A"
argument_list|,
name|_rl_keymap
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|||
name|f
operator|==
name|rl_do_lowercase_version
condition|)
block|{
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[A"
argument_list|,
name|rl_get_previous_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[B"
argument_list|,
name|rl_get_next_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[C"
argument_list|,
name|rl_forward
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033[D"
argument_list|,
name|rl_backward
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|rl_function_of_keyseq
argument_list|(
literal|"\033OA"
argument_list|,
name|_rl_keymap
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|||
name|f
operator|==
name|rl_do_lowercase_version
condition|)
block|{
name|_rl_bind_if_unbound
argument_list|(
literal|"\033OA"
argument_list|,
name|rl_get_previous_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033OB"
argument_list|,
name|rl_get_next_history
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033OC"
argument_list|,
name|rl_forward
argument_list|)
expr_stmt|;
name|_rl_bind_if_unbound
argument_list|(
literal|"\033OD"
argument_list|,
name|rl_backward
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try and bind the common arrow key prefix after giving termcap and    the inputrc file a chance to bind them and create `real' keymaps    for the arrow key prefix. */
end_comment

begin_function
specifier|static
name|void
name|bind_arrow_keys
parameter_list|()
block|{
name|Keymap
name|xkeymap
decl_stmt|;
name|xkeymap
operator|=
name|_rl_keymap
expr_stmt|;
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
name|bind_arrow_keys_internal
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|_rl_keymap
operator|=
name|vi_movement_keymap
expr_stmt|;
name|bind_arrow_keys_internal
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_rl_keymap
operator|=
name|xkeymap
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Numeric Arguments			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Handle C-u style numeric args, as well as M--, and M-digits. */
end_comment

begin_function
specifier|static
name|int
name|rl_digit_loop
parameter_list|()
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|,
name|sawminus
decl_stmt|,
name|sawdigits
decl_stmt|;
name|rl_save_prompt
argument_list|()
expr_stmt|;
name|sawminus
operator|=
name|sawdigits
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|rl_numeric_arg
operator|>
literal|1000000
condition|)
block|{
name|sawdigits
operator|=
name|rl_explicit_arg
operator|=
name|rl_numeric_arg
operator|=
literal|0
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|rl_arg_sign
operator|*
name|rl_numeric_arg
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* If we see a key bound to `universal-argument' after seeing digits, 	 it ends the argument but is otherwise ignored. */
if|if
condition|(
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
if|if
condition|(
name|sawdigits
operator|==
literal|0
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|key
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|key
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|rl_numeric_arg
operator|=
name|rl_explicit_arg
condition|?
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
name|c
operator|-
literal|'0'
else|:
name|c
operator|-
literal|'0'
expr_stmt|;
name|sawdigits
operator|=
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|rl_explicit_arg
operator|==
literal|0
condition|)
block|{
name|rl_numeric_arg
operator|=
name|sawminus
operator|=
literal|1
expr_stmt|;
name|rl_arg_sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make M-- command equivalent to M--1 command. */
if|if
condition|(
name|sawminus
operator|&&
name|rl_numeric_arg
operator|==
literal|1
operator|&&
name|rl_explicit_arg
operator|==
literal|0
condition|)
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return
operator|(
name|_rl_dispatch
argument_list|(
name|key
argument_list|,
name|_rl_keymap
argument_list|)
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add the current digit to the argument in progress. */
end_comment

begin_function
name|int
name|rl_digit_argument
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_pending_input
operator|=
name|key
expr_stmt|;
return|return
operator|(
name|rl_digit_loop
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to do when you abort reading an argument. */
end_comment

begin_function
name|int
name|rl_discard_argument
parameter_list|()
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|_rl_init_argument
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create a default argument. */
end_comment

begin_function
name|int
name|_rl_init_argument
parameter_list|()
block|{
name|rl_numeric_arg
operator|=
name|rl_arg_sign
operator|=
literal|1
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C-u, universal argument.  Multiply the current argument by 4.    Read a key.  If the key has nothing to do with arguments, then    dispatch on it.  If the key is the abort character then abort. */
end_comment

begin_function
name|int
name|rl_universal_argument
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
return|return
operator|(
name|rl_digit_loop
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insert and Delete			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert a string of text into the line at point.  This is the only    way that you should do insertion.  rl_insert () calls this    function. */
end_comment

begin_function
name|int
name|rl_insert_text
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|rl_end
operator|+
name|l
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|rl_end
operator|+
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rl_end
init|;
name|i
operator|>=
name|rl_point
condition|;
name|i
operator|--
control|)
name|the_line
index|[
name|i
operator|+
name|l
index|]
operator|=
name|the_line
index|[
name|i
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|the_line
operator|+
name|rl_point
argument_list|,
name|string
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Remember how to undo this if we aren't undoing something. */
if|if
condition|(
operator|!
name|_rl_doing_an_undo
condition|)
block|{
comment|/* If possible and desirable, concatenate the undos. */
if|if
condition|(
operator|(
name|l
operator|==
literal|1
operator|)
operator|&&
name|rl_undo_list
operator|&&
operator|(
name|rl_undo_list
operator|->
name|what
operator|==
name|UNDO_INSERT
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|==
name|rl_point
operator|)
operator|&&
operator|(
name|rl_undo_list
operator|->
name|end
operator|-
name|rl_undo_list
operator|->
name|start
operator|<
literal|20
operator|)
condition|)
name|rl_undo_list
operator|->
name|end
operator|++
expr_stmt|;
else|else
name|rl_add_undo
argument_list|(
name|UNDO_INSERT
argument_list|,
name|rl_point
argument_list|,
name|rl_point
operator|+
name|l
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rl_point
operator|+=
name|l
expr_stmt|;
name|rl_end
operator|+=
name|l
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Delete the string between FROM and TO.  FROM is    inclusive, TO is not. */
end_comment

begin_function
name|int
name|rl_delete_text
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
specifier|register
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|;
comment|/* Fix it if the caller is confused. */
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|SWAP
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* fix boundaries */
if|if
condition|(
name|to
operator|>
name|rl_end
condition|)
block|{
name|to
operator|=
name|rl_end
expr_stmt|;
if|if
condition|(
name|from
operator|>
name|to
condition|)
name|from
operator|=
name|to
expr_stmt|;
block|}
name|text
operator|=
name|rl_copy_text
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Some versions of strncpy() can't handle overlapping arguments. */
name|diff
operator|=
name|to
operator|-
name|from
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|rl_end
operator|-
name|diff
condition|;
name|i
operator|++
control|)
name|the_line
index|[
name|i
index|]
operator|=
name|the_line
index|[
name|i
operator|+
name|diff
index|]
expr_stmt|;
comment|/* Remember how to undo this delete. */
if|if
condition|(
name|_rl_doing_an_undo
operator|==
literal|0
condition|)
name|rl_add_undo
argument_list|(
name|UNDO_DELETE
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end
operator|-=
name|diff
expr_stmt|;
name|the_line
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fix up point so that it is within the line boundaries after killing    text.  If FIX_MARK_TOO is non-zero, the mark is forced within line    boundaries also. */
end_comment

begin_define
define|#
directive|define
name|_RL_FIX_POINT
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 	if (x> rl_end) \ 	  x = rl_end; \ 	else if (x< 0) \ 	  x = 0; \ 	} while (0)
end_define

begin_function
name|void
name|_rl_fix_point
parameter_list|(
name|fix_mark_too
parameter_list|)
name|int
name|fix_mark_too
decl_stmt|;
block|{
name|_RL_FIX_POINT
argument_list|(
name|rl_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix_mark_too
condition|)
name|_RL_FIX_POINT
argument_list|(
name|rl_mark
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|_RL_FIX_POINT
end_undef

begin_function
name|void
name|_rl_replace_text
parameter_list|(
name|text
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
name|rl_insert_text
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Readline character functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is not a gap editor, just a stupid line input routine.  No hair    is involved in writing any of the functions, and none should be. */
end_comment

begin_comment
comment|/* Note that:     rl_end is the place in the string that we would place '\0';    i.e., it is always safe to place '\0' there.     rl_point is the place in the string where the cursor is.  Sometimes    this is the same as rl_end.     Any command that is called interactively receives two arguments.    The first is a count: the numeric arg pased to this command.    The second is the key which invoked this command. */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Movement Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Note that if you `optimize' the display for these functions, you cannot    use said functions in other functions which do not do optimizing display.    I.e., you will have to update the data base for rl_redisplay, and you    might as well let rl_redisplay do that job. */
end_comment

begin_comment
comment|/* Move forward COUNT characters. */
end_comment

begin_function
name|int
name|rl_forward
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_backward
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|end
init|=
name|rl_point
operator|+
name|count
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|int
name|lend
init|=
name|rl_end
operator|-
operator|(
name|rl_editing_mode
operator|==
name|vi_mode
operator|)
decl_stmt|;
else|#
directive|else
name|int
name|lend
init|=
name|rl_end
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|end
operator|>
name|lend
condition|)
block|{
name|rl_point
operator|=
name|lend
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
if|if
condition|(
name|rl_end
operator|<
literal|0
condition|)
name|rl_end
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move backward COUNT characters. */
end_comment

begin_function
name|int
name|rl_backward
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|rl_forward
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rl_point
operator|<
name|count
condition|)
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_point
operator|-=
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move to the beginning of the line. */
end_comment

begin_function
name|int
name|rl_beg_of_line
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_point
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move to the end of the line. */
end_comment

begin_function
name|int
name|rl_end_of_line
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_point
operator|=
name|rl_end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move forward a word.  We do what Emacs does. */
end_comment

begin_function
name|int
name|rl_forward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_backward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
comment|/* If we are not in a word, move forward until we are in one. 	 Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move backward a word.  We do what Emacs does. */
end_comment

begin_function
name|int
name|rl_backward_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_forward_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|!
name|rl_point
condition|)
return|return
literal|0
return|;
comment|/* Like rl_forward_word (), except that we look at the characters 	 just before point. */
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|rl_point
condition|)
block|{
name|c
operator|=
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
break|break;
else|else
operator|--
name|rl_point
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Clear the current line.  Numeric argument to C-l does this. */
end_comment

begin_function
name|int
name|rl_refresh_line
parameter_list|(
name|ignore1
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
name|int
name|curr_line
decl_stmt|;
name|curr_line
operator|=
name|_rl_current_display_line
argument_list|()
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|curr_line
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|the_line
argument_list|)
expr_stmt|;
comment|/* XXX is this right */
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* arg of 0 means to not use spaces */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C-l typed to a line without quoting clears the screen, and then reprints    the prompt and the current input line.  Given a numeric arg, redraw only    the current line. */
end_comment

begin_function
name|int
name|rl_clear_screen
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|rl_refresh_line
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|_rl_clear_screen
argument_list|()
expr_stmt|;
comment|/* calls termcap function to clear screen */
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_arrow_keys
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|_rl_to_upper
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
name|rl_get_previous_history
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|rl_get_next_history
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|rl_forward
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|rl_backward
argument_list|(
name|count
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Text commands				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Insert the character C at the current location, moving point forward. */
end_comment

begin_function
name|int
name|rl_insert
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we can optimize, then do it.  But don't let people crash      readline because of extra large arguments. */
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|count
operator|<=
literal|1024
condition|)
block|{
name|string
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1024
condition|)
block|{
name|int
name|decreaser
decl_stmt|;
name|char
name|str
index|[
literal|1024
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
name|str
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|decreaser
operator|=
operator|(
name|count
operator|>
literal|1024
condition|?
literal|1024
else|:
name|count
operator|)
expr_stmt|;
name|str
index|[
name|decreaser
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|count
operator|-=
name|decreaser
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* We are inserting a single character.      If there is pending input, then make a string of all of the      pending characters that are bound to rl_insert, and insert      them all. */
if|if
condition|(
name|_rl_any_typein
argument_list|()
condition|)
name|_rl_insert_typein
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Inserting a single character. */
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|rl_insert_text
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert the next typed character verbatim. */
end_comment

begin_function
name|int
name|rl_quoted_insert
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|_rl_disable_tty_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_SIGNALS
argument_list|)
name|_rl_restore_tty_signals
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rl_insert
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insert a tab character. */
end_comment

begin_function
name|int
name|rl_tab_insert
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_insert
argument_list|(
name|count
argument_list|,
literal|'\t'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to do when a NEWLINE is pressed.  We accept the whole line.    KEY is the key that invoked this command.  I guess it could have    meaning in the future. */
end_comment

begin_function
name|int
name|rl_newline
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_done
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
block|{
name|_rl_vi_done_inserting
argument_list|()
expr_stmt|;
name|_rl_vi_reset_last
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VI_MODE */
comment|/* If we've been asked to erase empty lines, suppress the final update,      since _rl_update_final calls crlf(). */
if|if
condition|(
name|rl_erase_empty_line
operator|&&
name|rl_point
operator|==
literal|0
operator|&&
name|rl_end
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|readline_echoing_p
condition|)
name|_rl_update_final
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* What to do for some uppercase characters, like meta characters,    and some characters appearing in emacs_ctlx_keymap.  This function    is just a stub, you bind keys to it and the code in _rl_dispatch ()    is special cased. */
end_comment

begin_function
name|int
name|rl_do_lowercase_version
parameter_list|(
name|ignore1
parameter_list|,
name|ignore2
parameter_list|)
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Rubout the character behind point. */
end_comment

begin_function
name|int
name|rl_rubout
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_delete
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|rl_point
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|rl_backward
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|the_line
index|[
operator|--
name|rl_point
index|]
decl_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
name|_rl_last_c_pos
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|rl_character_len
argument_list|(
name|c
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|_rl_erase_at_end_of_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Delete the character under the cursor.  Given a numeric argument,    kill that many characters instead. */
end_comment

begin_function
name|int
name|rl_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_rubout
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|||
name|rl_explicit_arg
condition|)
block|{
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
name|rl_forward
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_kill_text
argument_list|(
name|orig_point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|(
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the character under the cursor, unless the insertion    point is at the end of the line, in which case the character    behind the cursor is deleted.  COUNT is obeyed and may be used    to delete forward or backward that many characters. */
end_comment

begin_function
name|int
name|rl_rubout_or_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_end
operator|!=
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
return|return
operator|(
name|rl_rubout
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all spaces and tabs around point. */
end_comment

begin_function
name|int
name|rl_delete_horizontal_space
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|start
init|=
name|rl_point
decl_stmt|;
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|the_line
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|rl_point
condition|)
block|{
name|rl_delete_text
argument_list|(
name|start
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|start
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like the tcsh editing function delete-char-or-list.  The eof character    is caught before this is invoked, so this really does the same thing as    delete-char-or-list-or-eof, as long as it's bound to the eof character. */
end_comment

begin_function
name|int
name|rl_delete_or_show_completions
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_end
operator|!=
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
return|return
operator|(
name|rl_possible_completions
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|RL_COMMENT_BEGIN_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|RL_COMMENT_BEGIN_DEFAULT
value|"#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Turn the current line into a comment in shell history.    A K*rn shell style function. */
end_comment

begin_function
name|int
name|rl_insert_comment
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|_rl_comment_begin
condition|?
name|_rl_comment_begin
else|:
name|RL_COMMENT_BEGIN_DEFAULT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Changing Case				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The three kinds of things that we know how to do. */
end_comment

begin_define
define|#
directive|define
name|UpCase
value|1
end_define

begin_define
define|#
directive|define
name|DownCase
value|2
end_define

begin_define
define|#
directive|define
name|CapCase
value|3
end_define

begin_comment
comment|/* Uppercase the word at point. */
end_comment

begin_function
name|int
name|rl_upcase_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|UpCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lowercase the word at point. */
end_comment

begin_function
name|int
name|rl_downcase_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|DownCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Upcase the first letter, downcase the rest. */
end_comment

begin_function
name|int
name|rl_capitalize_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_change_case
argument_list|(
name|count
argument_list|,
name|CapCase
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The meaty function.    Change the case of COUNT words, performing OP on them.    OP is one of UpCase, DownCase, or CapCase.    If a negative argument is given, leave point where it started,    otherwise, leave it where it moves to. */
end_comment

begin_function
specifier|static
name|int
name|rl_change_case
parameter_list|(
name|count
parameter_list|,
name|op
parameter_list|)
name|int
name|count
decl_stmt|,
name|op
decl_stmt|;
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|inword
decl_stmt|,
name|c
decl_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|SWAP
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* We are going to modify some text, so let's prepare to undo it. */
name|rl_modifying
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|inword
operator|=
literal|0
init|;
name|start
operator|<
name|end
condition|;
name|start
operator|++
control|)
block|{
name|c
operator|=
name|the_line
index|[
name|start
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UpCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|DownCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
name|_rl_to_lower
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|CapCase
case|:
name|the_line
index|[
name|start
index|]
operator|=
operator|(
name|inword
operator|==
literal|0
operator|)
condition|?
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
else|:
name|_rl_to_lower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|inword
operator|=
name|alphabetic
argument_list|(
name|the_line
index|[
name|start
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|rl_point
operator|=
name|end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Transposition				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Transpose the words at point. */
end_comment

begin_function
name|int
name|rl_transpose_words
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|word1
decl_stmt|,
modifier|*
name|word2
decl_stmt|;
name|int
name|w1_beg
decl_stmt|,
name|w1_end
decl_stmt|,
name|w2_beg
decl_stmt|,
name|w2_end
decl_stmt|;
name|int
name|orig_point
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
comment|/* Find the two words. */
name|rl_forward_word
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w2_end
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w2_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_backward_word
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w1_beg
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_word
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|w1_end
operator|=
name|rl_point
expr_stmt|;
comment|/* Do some check to make sure that there really are two words. */
if|if
condition|(
operator|(
name|w1_beg
operator|==
name|w2_beg
operator|)
operator|||
operator|(
name|w2_beg
operator|<
name|w1_end
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|orig_point
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the text of the words. */
name|word1
operator|=
name|rl_copy_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|word2
operator|=
name|rl_copy_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
comment|/* We are about to do many insertions and deletions.  Remember them      as one operation. */
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* Do the stuff at word2 first, so that we don't have to worry      about word1 moving. */
name|rl_point
operator|=
name|w2_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w2_beg
argument_list|,
name|w2_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|w1_beg
expr_stmt|;
name|rl_delete_text
argument_list|(
name|w1_beg
argument_list|,
name|w1_end
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|word2
argument_list|)
expr_stmt|;
comment|/* This is exactly correct since the text before this point has not      changed in length. */
name|rl_point
operator|=
name|w2_end
expr_stmt|;
comment|/* I think that does it. */
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|word1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|word2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Transpose the characters at point.  If point is at the end of the line,    then transpose the characters before point. */
end_comment

begin_function
name|int
name|rl_transpose_chars
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|char
name|dummy
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rl_point
operator|||
name|rl_end
operator|<
literal|2
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
block|{
operator|--
name|rl_point
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
name|dummy
index|[
literal|0
index|]
operator|=
name|the_line
index|[
name|rl_point
index|]
expr_stmt|;
name|dummy
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rl_point
operator|+=
name|count
expr_stmt|;
name|_rl_fix_point
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Character Searching			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|_rl_char_search_internal
parameter_list|(
name|count
parameter_list|,
name|dir
parameter_list|,
name|schar
parameter_list|)
name|int
name|count
decl_stmt|,
name|dir
decl_stmt|,
name|schar
decl_stmt|;
block|{
name|int
name|pos
decl_stmt|,
name|inc
decl_stmt|;
name|pos
operator|=
name|rl_point
expr_stmt|;
name|inc
operator|=
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|(
name|dir
operator|<
literal|0
operator|&&
name|pos
operator|<=
literal|0
operator|)
operator|||
operator|(
name|dir
operator|>
literal|0
operator|&&
name|pos
operator|>=
name|rl_end
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pos
operator|+=
name|inc
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|schar
condition|)
block|{
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|rl_point
operator|=
operator|(
name|dir
operator|==
name|BTO
operator|)
condition|?
name|pos
operator|+
literal|1
else|:
name|pos
expr_stmt|;
else|else
name|rl_point
operator|=
operator|(
name|dir
operator|==
name|FTO
operator|)
condition|?
name|pos
operator|-
literal|1
else|:
name|pos
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
name|pos
operator|--
else|:
operator|++
name|pos
operator|<
name|rl_end
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search COUNT times for a character read from the current input stream.    FDIR is the direction to search if COUNT is non-negative; otherwise    the search goes in BDIR. */
end_comment

begin_function
specifier|static
name|int
name|_rl_char_search
parameter_list|(
name|count
parameter_list|,
name|fdir
parameter_list|,
name|bdir
parameter_list|)
name|int
name|count
decl_stmt|,
name|fdir
decl_stmt|,
name|bdir
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
operator|-
name|count
argument_list|,
name|bdir
argument_list|,
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|fdir
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|_rl_char_search
argument_list|(
name|count
argument_list|,
name|FFIND
argument_list|,
name|BFIND
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_backward_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|_rl_char_search
argument_list|(
name|count
argument_list|,
name|BFIND
argument_list|,
name|FFIND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* We already have a history library, and that is what we use to control    the history features of readline.  This is our local interface to    the history mechanism. */
end_comment

begin_comment
comment|/* While we are editing the history, this is the saved    version of the original line. */
end_comment

begin_decl_stmt
name|HIST_ENTRY
modifier|*
name|saved_line_for_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the history pointer back to the last entry in the history. */
end_comment

begin_function
specifier|static
name|void
name|start_using_history
parameter_list|()
block|{
name|using_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_line_for_history
condition|)
name|_rl_free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the contents (and containing structure) of a HIST_ENTRY. */
end_comment

begin_function
name|void
name|_rl_free_history_entry
parameter_list|(
name|entry
parameter_list|)
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|entry
operator|->
name|line
condition|)
name|free
argument_list|(
name|entry
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perhaps put back the current line if it has changed. */
end_comment

begin_function
name|int
name|maybe_replace_line
parameter_list|()
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|current_history
argument_list|()
expr_stmt|;
comment|/* If the current line has changed, save the changes. */
if|if
condition|(
name|temp
operator|&&
operator|(
operator|(
name|UNDO_LIST
operator|*
operator|)
operator|(
name|temp
operator|->
name|data
operator|)
operator|!=
name|rl_undo_list
operator|)
condition|)
block|{
name|temp
operator|=
name|replace_history_entry
argument_list|(
name|where_history
argument_list|()
argument_list|,
name|the_line
argument_list|,
operator|(
name|histdata_t
operator|)
name|rl_undo_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Put back the saved_line_for_history if there is one. */
end_comment

begin_function
name|int
name|maybe_unsave_line
parameter_list|()
block|{
name|int
name|line_len
decl_stmt|;
if|if
condition|(
name|saved_line_for_history
condition|)
block|{
name|line_len
operator|=
name|strlen
argument_list|(
name|saved_line_for_history
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|saved_line_for_history
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|saved_line_for_history
operator|->
name|data
expr_stmt|;
name|_rl_free_history_entry
argument_list|(
name|saved_line_for_history
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
block|}
else|else
name|ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Save the current line in saved_line_for_history. */
end_comment

begin_function
name|int
name|maybe_save_line
parameter_list|()
block|{
if|if
condition|(
name|saved_line_for_history
operator|==
literal|0
condition|)
block|{
name|saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
name|saved_line_for_history
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|rl_undo_list
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Commands			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Meta-< goes to the start of the history. */
end_comment

begin_function
name|int
name|rl_beginning_of_history
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_get_previous_history
argument_list|(
literal|1
operator|+
name|where_history
argument_list|()
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Meta-> goes to the end of the history.  (The current line). */
end_comment

begin_function
name|int
name|rl_end_of_history
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|maybe_replace_line
argument_list|()
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|maybe_unsave_line
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move down to the next history line. */
end_comment

begin_function
name|int
name|rl_get_next_history
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
name|int
name|line_len
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_get_previous_history
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|maybe_replace_line
argument_list|()
expr_stmt|;
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|next_history
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
break|break;
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|maybe_unsave_line
argument_list|()
expr_stmt|;
else|else
block|{
name|line_len
operator|=
name|strlen
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|strlen
argument_list|(
name|the_line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the previous item out of our interactive history, making it the current    line.  If there is no previous history, just ding. */
end_comment

begin_function
name|int
name|rl_get_previous_history
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|old_temp
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|line_len
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_get_next_history
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we don't have a line saved, then save this one. */
name|maybe_save_line
argument_list|()
expr_stmt|;
comment|/* If the current line has changed, save the changes. */
name|maybe_replace_line
argument_list|()
expr_stmt|;
name|temp
operator|=
name|old_temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|temp
operator|=
name|previous_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
break|break;
name|old_temp
operator|=
name|temp
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
comment|/* If there was a large argument, and we moved back to the start of the      history, that is not an error.  So use the last value found. */
if|if
condition|(
operator|!
name|temp
operator|&&
name|old_temp
condition|)
name|temp
operator|=
name|old_temp
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|ding
argument_list|()
expr_stmt|;
else|else
block|{
name|line_len
operator|=
name|strlen
argument_list|(
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|the_line
argument_list|,
name|temp
operator|->
name|line
argument_list|)
expr_stmt|;
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|temp
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
name|line_len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   The Mark and the Region.			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Set the mark at POSITION. */
end_comment

begin_function
name|int
name|_rl_set_mark_at_pos
parameter_list|(
name|position
parameter_list|)
name|int
name|position
decl_stmt|;
block|{
if|if
condition|(
name|position
operator|>
name|rl_end
condition|)
return|return
operator|-
literal|1
return|;
name|rl_mark
operator|=
name|position
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A bindable command to set the mark. */
end_comment

begin_function
name|int
name|rl_set_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|_rl_set_mark_at_pos
argument_list|(
name|rl_explicit_arg
condition|?
name|count
else|:
name|rl_point
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Exchange the position of mark and point. */
end_comment

begin_function
name|int
name|rl_exchange_point_and_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_mark
operator|>
name|rl_end
condition|)
name|rl_mark
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rl_mark
operator|==
operator|-
literal|1
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|SWAP
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			    Editing Modes			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* How to toggle back and forth between editing modes. */
end_comment

begin_function
name|int
name|rl_vi_editing_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|rl_editing_mode
operator|=
name|vi_mode
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_emacs_editing_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_editing_mode
operator|=
name|emacs_mode
expr_stmt|;
name|_rl_keymap
operator|=
name|emacs_standard_keymap
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

