begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* histexpand.c -- history expansion. */
end_comment

begin_comment
comment|/* Copyright (C) 1989-2004 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_MINIX
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_define
define|#
directive|define
name|HISTORY_WORD_DELIMITERS
value|" \t\n;&()|<>"
end_define

begin_define
define|#
directive|define
name|HISTORY_QUOTE_CHARACTERS
value|"\"'`"
end_define

begin_define
define|#
directive|define
name|slashify_in_quotes
value|"\\`\"$"
end_define

begin_typedef
typedef|typedef
name|int
name|_hist_search_func_t
name|PARAMS
typedef|((const
name|char
modifier|*
typedef|,
name|int
typedef|));
end_typedef

begin_decl_stmt
specifier|static
name|char
name|error_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subst_lhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|subst_rhs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subst_lhs_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|subst_rhs_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_history_word_specifier
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_find_word
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_tokenize_word
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_substring
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|quote_breaks
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables exported by this file. */
end_comment

begin_comment
comment|/* The character that represents the start of a history expansion    request.  This is usually `!'. */
end_comment

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The character that invokes word substitution if found at the start of    a line.  This is usually `^'. */
end_comment

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During tokenization, if this character is seen as the first character    of a word, then it, and all subsequent characters upto a newline are    ignored.  For a Bourne shell, this should be '#'.  Bash special cases    the interactive comment character to not be a comment delimiter. */
end_comment

begin_decl_stmt
name|char
name|history_comment_char
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters which inhibit the expansion of text if found    immediately following history_expansion_char. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
literal|" \t\n\r="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set to a non-zero value, single quotes inhibit history expansion.    The default is 0. */
end_comment

begin_decl_stmt
name|int
name|history_quotes_inhibit_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to split words by history_tokenize_internal. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|history_word_delimiters
init|=
name|HISTORY_WORD_DELIMITERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set, this points to a function that is called to verify that a    particular history expansion should be performed. */
end_comment

begin_decl_stmt
name|rl_linebuf_func_t
modifier|*
name|history_inhibit_expansion_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Expansion			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Hairy history expansion on text, not tokens.  This is of general    use, and thus belongs in this library. */
end_comment

begin_comment
comment|/* The last string searched for by a !?string? search. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last string matched by a !?string? search. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the event specified at TEXT + OFFSET modifying OFFSET to    point to after the event specifier.  Just a pointer to the history    line is returned; NULL is returned in the event of a bad specifier.    You pass STRING with *INDEX equal to the history_expansion_char that    begins this specification.    DELIMITING_QUOTE is a character that is allowed to end the string    specification for what to search for in addition to the normal    characters `:', ` ', `\t', `\n', and sometimes `?'.    So you might call this function like:    line = get_history_event ("!echo:p",&index, 0);  */
end_comment

begin_function
name|char
modifier|*
name|get_history_event
parameter_list|(
name|string
parameter_list|,
name|caller_index
parameter_list|,
name|delimiting_quote
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|caller_index
decl_stmt|;
name|int
name|delimiting_quote
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
name|int
name|which
decl_stmt|,
name|sign
decl_stmt|,
name|local_index
decl_stmt|,
name|substring_okay
decl_stmt|;
name|_hist_search_func_t
modifier|*
name|search_func
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* The event can be specified in a number of ways.       !!   the previous command      !n   command line N      !-n  current command-line minus N      !str the most recent command starting with STR      !?str[?] 	  the most recent command containing STR       All values N are determined via HISTORY_BASE. */
name|i
operator|=
operator|*
name|caller_index
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Move on to the specification. */
name|i
operator|++
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|substring_okay
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|RETURN_ENTRY
parameter_list|(
name|e
parameter_list|,
name|w
parameter_list|)
define|\
value|return ((e = history_get (w)) ? e->line : (char *)NULL)
comment|/* Handle !! case. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|which
operator|=
name|history_base
operator|+
operator|(
name|history_length
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
name|RETURN_ENTRY
argument_list|(
name|entry
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
comment|/* Hack case of numeric line specification. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Get the extent of the digits and compute the value. */
for|for
control|(
name|which
operator|=
literal|0
init|;
name|_rl_digit_p
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|which
operator|=
operator|(
name|which
operator|*
literal|10
operator|)
operator|+
name|_rl_digit_value
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|which
operator|=
operator|(
name|history_length
operator|+
name|history_base
operator|)
operator|-
name|which
expr_stmt|;
name|RETURN_ENTRY
argument_list|(
name|entry
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
comment|/* This must be something to search for.  If the spec begins with      a '?', then the string may be anywhere on the line.  Otherwise,      the string must be found at the start of a line. */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
block|{
name|substring_okay
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Only a closing `?' or a newline delimit a substring search string. */
for|for
control|(
name|local_index
operator|=
name|i
init|;
name|c
operator|=
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|int
name|v
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These produce warnings because we're passing a const string to a 	     function that takes a non-const string. */
name|_rl_adjust_point
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string
argument_list|,
name|i
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|_rl_get_char_len
argument_list|(
operator|(
name|char
operator|*
operator|)
name|string
operator|+
name|i
argument_list|,
operator|&
name|ps
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|i
operator|+=
name|v
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
if|if
condition|(
operator|(
operator|!
name|substring_okay
operator|&&
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|':'
operator|||
operator|(
name|history_search_delimiter_chars
operator|&&
name|member
argument_list|(
name|c
argument_list|,
name|history_search_delimiter_chars
argument_list|)
operator|)
operator|||
name|string
index|[
name|i
index|]
operator|==
name|delimiting_quote
operator|)
operator|)
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
operator|)
condition|)
break|break;
block|}
name|which
operator|=
name|i
operator|-
name|local_index
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
condition|)
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|local_index
argument_list|,
name|which
argument_list|)
expr_stmt|;
name|temp
index|[
name|which
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|substring_okay
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
define|#
directive|define
name|FAIL_SEARCH
parameter_list|()
define|\
value|do { \     history_offset = history_length; free (temp) ; return (char *)NULL; \   } while (0)
comment|/* If there is no search string, try to use the previous search string,      if one exists.  If not, fail immediately. */
if|if
condition|(
operator|*
name|temp
operator|==
literal|'\0'
operator|&&
name|substring_okay
condition|)
block|{
if|if
condition|(
name|search_string
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|savestring
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL_SEARCH
argument_list|()
expr_stmt|;
block|}
name|search_func
operator|=
name|substring_okay
condition|?
name|history_search
else|:
name|history_search_prefix
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|local_index
operator|=
call|(
modifier|*
name|search_func
call|)
argument_list|(
name|temp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_index
operator|<
literal|0
condition|)
name|FAIL_SEARCH
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_index
operator|==
literal|0
operator|||
name|substring_okay
condition|)
block|{
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_offset
operator|=
name|history_length
expr_stmt|;
comment|/* If this was a substring search, then remember the 	     string that we matched for word substitution. */
if|if
condition|(
name|substring_okay
condition|)
block|{
name|FREE
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|search_string
operator|=
name|temp
expr_stmt|;
name|FREE
argument_list|(
name|search_match
argument_list|)
expr_stmt|;
name|search_match
operator|=
name|history_find_word
argument_list|(
name|entry
operator|->
name|line
argument_list|,
name|local_index
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|->
name|line
operator|)
return|;
block|}
if|if
condition|(
name|history_offset
condition|)
name|history_offset
operator|--
expr_stmt|;
else|else
name|FAIL_SEARCH
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|FAIL_SEARCH
undef|#
directive|undef
name|RETURN_ENTRY
block|}
end_function

begin_comment
comment|/* Function for extracting single-quoted strings.  Used for inhibiting    history expansion within single quotes. */
end_comment

begin_comment
comment|/* Extract the contents of STRING as if it is enclosed in single quotes.    SINDEX, when passed in, is the offset of the character immediately    following the opening single quote; on exit, SINDEX is left pointing    to the closing single quote. */
end_comment

begin_function
specifier|static
name|void
name|hist_string_extract_single_quoted
parameter_list|(
name|string
parameter_list|,
name|sindex
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|sindex
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|sindex
init|;
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'\''
condition|;
name|i
operator|++
control|)
empty_stmt|;
operator|*
name|sindex
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|quote_breaks
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|len
init|=
literal|3
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|len
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|len
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
block|}
name|r
operator|=
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|&&
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
else|else
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|r
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hist_error
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|current
parameter_list|,
name|errtype
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|start
decl_stmt|,
name|current
decl_stmt|,
name|errtype
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
specifier|const
name|char
modifier|*
name|emsg
decl_stmt|;
name|int
name|ll
decl_stmt|,
name|elen
decl_stmt|;
name|ll
operator|=
name|current
operator|-
name|start
expr_stmt|;
switch|switch
condition|(
name|errtype
condition|)
block|{
case|case
name|EVENT_NOT_FOUND
case|:
name|emsg
operator|=
literal|"event not found"
expr_stmt|;
name|elen
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|BAD_WORD_SPEC
case|:
name|emsg
operator|=
literal|"bad word specifier"
expr_stmt|;
name|elen
operator|=
literal|18
expr_stmt|;
break|break;
case|case
name|SUBST_FAILED
case|:
name|emsg
operator|=
literal|"substitution failed"
expr_stmt|;
name|elen
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|BAD_MODIFIER
case|:
name|emsg
operator|=
literal|"unrecognized history modifier"
expr_stmt|;
name|elen
operator|=
literal|29
expr_stmt|;
break|break;
case|case
name|NO_PREV_SUBST
case|:
name|emsg
operator|=
literal|"no previous substitution"
expr_stmt|;
name|elen
operator|=
literal|24
expr_stmt|;
break|break;
default|default:
name|emsg
operator|=
literal|"unknown expansion error"
expr_stmt|;
name|elen
operator|=
literal|23
expr_stmt|;
break|break;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ll
operator|+
name|elen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|s
operator|+
name|start
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|temp
index|[
name|ll
index|]
operator|=
literal|':'
expr_stmt|;
name|temp
index|[
name|ll
operator|+
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|temp
operator|+
name|ll
operator|+
literal|2
argument_list|,
name|emsg
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a history substitution string from STR starting at *IPTR    and return it.  The length is returned in LENPTR.     A backslash can quote the delimiter.  If the string is the    empty string, the previous pattern is used.  If there is    no previous pattern for the lhs, the last history search    string is used.     If IS_RHS is 1, we ignore empty strings and set the pattern    to "" anyway.  subst_lhs is not changed if the lhs is empty;    subst_rhs is allowed to be set to the empty string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_subst_pattern
parameter_list|(
name|str
parameter_list|,
name|iptr
parameter_list|,
name|delimiter
parameter_list|,
name|is_rhs
parameter_list|,
name|lenptr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|iptr
decl_stmt|,
name|delimiter
decl_stmt|,
name|is_rhs
decl_stmt|,
decl|*
name|lenptr
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|si
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|mbstate_t
name|ps
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|i
operator|=
operator|*
name|iptr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|_rl_adjust_point
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|si
operator|=
name|i
init|;
name|str
index|[
name|si
index|]
operator|&&
name|str
index|[
name|si
index|]
operator|!=
name|delimiter
condition|;
name|si
operator|++
control|)
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|_rl_get_char_len
argument_list|(
name|str
operator|+
name|si
argument_list|,
operator|&
name|ps
argument_list|)
operator|)
operator|>
literal|1
condition|)
name|si
operator|+=
name|v
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|str
index|[
name|si
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|si
operator|+
literal|1
index|]
operator|==
name|delimiter
condition|)
name|si
operator|++
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
if|if
condition|(
name|str
index|[
name|si
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|si
operator|+
literal|1
index|]
operator|==
name|delimiter
condition|)
name|si
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|>
name|i
operator|||
name|is_rhs
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|si
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|i
init|;
name|k
operator|<
name|si
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
comment|/* Remove a backslash quoting the search string delimiter. */
if|if
condition|(
name|str
index|[
name|k
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|k
operator|+
literal|1
index|]
operator|==
name|delimiter
condition|)
name|k
operator|++
expr_stmt|;
name|s
index|[
name|j
index|]
operator|=
name|str
index|[
name|k
index|]
expr_stmt|;
block|}
name|s
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lenptr
condition|)
operator|*
name|lenptr
operator|=
name|j
expr_stmt|;
block|}
name|i
operator|=
name|si
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|iptr
operator|=
name|i
expr_stmt|;
return|return
name|s
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|postproc_subst_rhs
parameter_list|()
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|new_size
decl_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|new_size
operator|=
name|subst_rhs_len
operator|+
name|subst_lhs_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|subst_rhs_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subst_rhs
index|[
name|i
index|]
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|j
operator|+
name|subst_lhs_len
operator|>=
name|new_size
condition|)
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|new
argument_list|,
operator|(
name|new_size
operator|=
name|new_size
operator|*
literal|2
operator|+
name|subst_lhs_len
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|+
name|j
argument_list|,
name|subst_lhs
argument_list|)
expr_stmt|;
name|j
operator|+=
name|subst_lhs_len
expr_stmt|;
block|}
else|else
block|{
comment|/* a single backslash protects the `&' from lhs interpolation */
if|if
condition|(
name|subst_rhs
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|subst_rhs
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'&'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|new_size
condition|)
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|new
argument_list|,
name|new_size
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|new
index|[
name|j
operator|++
index|]
operator|=
name|subst_rhs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|new
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|subst_rhs
argument_list|)
expr_stmt|;
name|subst_rhs
operator|=
name|new
expr_stmt|;
name|subst_rhs_len
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the bulk of a history specifier starting at STRING[START].    Returns 0 if everything is OK, -1 if an error occurred, and 1    if the `p' modifier was supplied and the caller should just print    the returned string.  Returns the new index into string in    *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */
end_comment

begin_function
specifier|static
name|int
name|history_expand_internal
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end_index_ptr
parameter_list|,
name|ret_string
parameter_list|,
name|current_line
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
decl|*
name|end_index_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ret_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|current_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for !# */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|starting_index
decl_stmt|;
name|int
name|substitute_globally
decl_stmt|,
name|subst_bywords
decl_stmt|,
name|want_quotes
decl_stmt|,
name|print_only
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|tstr
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|word_spec
decl_stmt|;
name|int
name|result_len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|mbstate_t
name|ps
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_len
operator|=
literal|128
argument_list|)
expr_stmt|;
name|i
operator|=
name|start
expr_stmt|;
comment|/* If it is followed by something that starts a word specifier,      then !! is implied as the event specifier. */
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|":$*%^"
argument_list|)
condition|)
block|{
name|char
name|fake_s
index|[
literal|3
index|]
decl_stmt|;
name|int
name|fake_i
init|=
literal|0
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|fake_s
index|[
literal|0
index|]
operator|=
name|fake_s
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|fake_s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|fake_s
argument_list|,
operator|&
name|fake_i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
name|event
operator|=
name|current_line
expr_stmt|;
block|}
else|else
block|{
name|int
name|quoted_search_delimiter
init|=
literal|0
decl_stmt|;
comment|/* If the character before this `!' is a double or single 	 quote, then this expansion takes place inside of the 	 quoted string.  If we have to search for some text ("!foo"), 	 allow the delimiter to end the search string. */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
name|ch
operator|=
name|string
index|[
name|l
index|]
expr_stmt|;
comment|/* XXX - original patch had i - 1 ???  If i == 0 it would fail. */
if|if
condition|(
name|i
operator|&&
operator|(
name|ch
operator|==
literal|'\''
operator|||
name|ch
operator|==
literal|'"'
operator|)
condition|)
name|quoted_search_delimiter
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
if|if
condition|(
name|i
operator|&&
operator|(
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\''
operator|||
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|quoted_search_delimiter
operator|=
name|string
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|event
operator|=
name|get_history_event
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|quoted_search_delimiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|==
literal|0
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|i
argument_list|,
name|EVENT_NOT_FOUND
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If a word specifier is found, then do what that requires. */
name|starting_index
operator|=
name|i
expr_stmt|;
name|word_spec
operator|=
name|get_history_word_specifier
argument_list|(
name|string
argument_list|,
name|event
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* There is no such thing as a `malformed word specifier'.  However,      it is possible for a specifier that has no match.  In that case,      we complain. */
if|if
condition|(
name|word_spec
operator|==
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|BAD_WORD_SPEC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* If no word specifier, than the thing of interest was the event. */
name|temp
operator|=
name|word_spec
condition|?
name|savestring
argument_list|(
name|word_spec
argument_list|)
else|:
name|savestring
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|word_spec
argument_list|)
expr_stmt|;
comment|/* Perhaps there are other modifiers involved.  Do what they say. */
name|want_quotes
operator|=
name|substitute_globally
operator|=
name|subst_bywords
operator|=
name|print_only
operator|=
literal|0
expr_stmt|;
name|starting_index
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|c
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'g'
operator|||
name|c
operator|==
literal|'a'
condition|)
block|{
name|substitute_globally
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|c
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'G'
condition|)
block|{
name|subst_bywords
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|c
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|BAD_MODIFIER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'q'
case|:
name|want_quotes
operator|=
literal|'q'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|want_quotes
operator|=
literal|'x'
expr_stmt|;
break|break;
comment|/* :p means make this the last executed line.  So we 	     return an error state after adding this line to the 	     history. */
case|case
literal|'p'
case|:
name|print_only
operator|++
expr_stmt|;
break|break;
comment|/* :t discards all but the last part of the pathname. */
case|case
literal|'t'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
block|{
name|tstr
operator|++
expr_stmt|;
name|t
operator|=
name|savestring
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
block|}
break|break;
comment|/* :h discards the last part of a pathname. */
case|case
literal|'h'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* :r discards the suffix. */
case|case
literal|'r'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
operator|*
name|tstr
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* :e discards everything but the suffix. */
case|case
literal|'e'
case|:
name|tstr
operator|=
name|strrchr
argument_list|(
name|temp
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tstr
condition|)
block|{
name|t
operator|=
name|savestring
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
block|}
break|break;
comment|/* :s/this/that substitutes `that' for the first 	   occurrence of `this'.  :gs/this/that substitutes `that' 	   for each occurrence of `this'.  :& repeats the last 	   substitution.  :g& repeats the last substitution 	   globally. */
case|case
literal|'&'
case|:
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|new_event
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|failed
decl_stmt|,
name|si
decl_stmt|,
name|l_temp
decl_stmt|,
name|ws
decl_stmt|,
name|we
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|2
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|_rl_adjust_point
argument_list|(
name|string
argument_list|,
name|i
operator|+
literal|2
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_get_char_len
argument_list|(
name|string
operator|+
name|i
operator|+
literal|2
argument_list|,
operator|&
name|ps
argument_list|)
operator|>
literal|1
condition|)
name|delimiter
operator|=
literal|0
expr_stmt|;
else|else
name|delimiter
operator|=
name|string
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
name|delimiter
operator|=
name|string
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
block|}
else|else
break|break;
comment|/* no search delimiter */
name|i
operator|+=
literal|3
expr_stmt|;
name|t
operator|=
name|get_subst_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|delimiter
argument_list|,
literal|0
argument_list|,
operator|&
name|subst_lhs_len
argument_list|)
expr_stmt|;
comment|/* An empty substitution lhs with no previous substitution 		   uses the last search string as the lhs. */
if|if
condition|(
name|t
condition|)
block|{
name|FREE
argument_list|(
name|subst_lhs
argument_list|)
expr_stmt|;
name|subst_lhs
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|subst_lhs
condition|)
block|{
if|if
condition|(
name|search_string
operator|&&
operator|*
name|search_string
condition|)
block|{
name|subst_lhs
operator|=
name|savestring
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
name|subst_lhs_len
operator|=
name|strlen
argument_list|(
name|subst_lhs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subst_lhs
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|subst_lhs_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|FREE
argument_list|(
name|subst_rhs
argument_list|)
expr_stmt|;
name|subst_rhs
operator|=
name|get_subst_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|,
name|delimiter
argument_list|,
literal|1
argument_list|,
operator|&
name|subst_rhs_len
argument_list|)
expr_stmt|;
comment|/* If `&' appears in the rhs, it's supposed to be replaced 		   with the lhs. */
if|if
condition|(
name|member
argument_list|(
literal|'&'
argument_list|,
name|subst_rhs
argument_list|)
condition|)
name|postproc_subst_rhs
argument_list|()
expr_stmt|;
block|}
else|else
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* If there is no lhs, the substitution can't succeed. */
if|if
condition|(
name|subst_lhs_len
operator|==
literal|0
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|NO_PREV_SUBST
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Ignore impossible cases. */
if|if
condition|(
name|subst_lhs_len
operator|>
name|l_temp
condition|)
block|{
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|SUBST_FAILED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Find the first occurrence of THIS in TEMP. */
comment|/* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three 	       cases to consider:  		 1.  substitute_globally == subst_bywords == 0 		 2.  substitute_globally == 1&& subst_bywords == 0 		 3.  substitute_globally == 0&& subst_bywords == 1  	       In the first case, we substitute for the first occurrence only. 	       In the second case, we substitute for every occurrence. 	       In the third case, we tokenize into words and substitute the 	       first occurrence of each word. */
name|si
operator|=
name|we
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|failed
operator|=
literal|1
init|;
operator|(
name|si
operator|+
name|subst_lhs_len
operator|)
operator|<=
name|l_temp
condition|;
name|si
operator|++
control|)
block|{
comment|/* First skip whitespace and find word boundaries if 		   we're past the end of the word boundary we found 		   the last time. */
if|if
condition|(
name|subst_bywords
operator|&&
name|si
operator|>
name|we
condition|)
block|{
for|for
control|(
init|;
name|temp
index|[
name|si
index|]
operator|&&
name|whitespace
argument_list|(
name|temp
index|[
name|si
index|]
argument_list|)
condition|;
name|si
operator|++
control|)
empty_stmt|;
name|ws
operator|=
name|si
expr_stmt|;
name|we
operator|=
name|history_tokenize_word
argument_list|(
name|temp
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|STREQN
argument_list|(
name|temp
operator|+
name|si
argument_list|,
name|subst_lhs
argument_list|,
name|subst_lhs_len
argument_list|)
condition|)
block|{
name|int
name|len
init|=
name|subst_rhs_len
operator|-
name|subst_lhs_len
operator|+
name|l_temp
decl_stmt|;
name|new_event
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
argument_list|,
name|temp
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
argument_list|,
name|subst_rhs
argument_list|,
name|subst_rhs_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_event
operator|+
name|si
operator|+
name|subst_rhs_len
argument_list|,
name|temp
operator|+
name|si
operator|+
name|subst_lhs_len
argument_list|,
name|l_temp
operator|-
operator|(
name|si
operator|+
name|subst_lhs_len
operator|)
argument_list|)
expr_stmt|;
name|new_event
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|new_event
expr_stmt|;
name|failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|substitute_globally
condition|)
block|{
comment|/* Reported to fix a bug that causes it to skip every 			   other match when matching a single character.  Was 			   si += subst_rhs_len previously. */
name|si
operator|+=
name|subst_rhs_len
operator|-
literal|1
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|substitute_globally
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|subst_bywords
condition|)
block|{
name|si
operator|=
name|we
expr_stmt|;
name|l_temp
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
block|}
if|if
condition|(
name|substitute_globally
operator|>
literal|1
condition|)
block|{
name|substitute_globally
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* don't want to increment i */
block|}
if|if
condition|(
name|failed
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't want to increment i */
operator|*
name|ret_string
operator|=
name|hist_error
argument_list|(
name|string
argument_list|,
name|starting_index
argument_list|,
name|i
argument_list|,
name|SUBST_FAILED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|i
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Done with modfiers. */
comment|/* Believe it or not, we have to back the pointer up by one. */
operator|--
name|i
expr_stmt|;
if|if
condition|(
name|want_quotes
condition|)
block|{
name|char
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|want_quotes
operator|==
literal|'q'
condition|)
name|x
operator|=
name|sh_single_quote
argument_list|(
name|temp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|want_quotes
operator|==
literal|'x'
condition|)
name|x
operator|=
name|quote_breaks
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|x
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|result_len
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|end_index_ptr
operator|=
name|i
expr_stmt|;
operator|*
name|ret_string
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|print_only
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Expand the string STRING, placing the result into OUTPUT, a pointer    to a string.  Returns:    -1) If there was an error in expansion.    0) If no expansions took place (or, if the only change in       the text was the de-slashifying of the history expansion       character)    1) If expansions did take place    2) If the `p' modifier was given and the caller should print the result    If an error ocurred in expansion, then OUTPUT contains a descriptive   error message. */
end_comment

begin_define
define|#
directive|define
name|ADD_STRING
parameter_list|(
name|s
parameter_list|)
define|\
value|do \ 	  { \ 	    int sl = strlen (s); \ 	    j += sl; \ 	    if (j>= result_len) \ 	      { \ 		while (j>= result_len) \ 		  result_len += 128; \ 		result = (char *)xrealloc (result, result_len); \ 	      } \ 	    strcpy (result + j - sl, s); \ 	  } \ 	while (0)
end_define

begin_define
define|#
directive|define
name|ADD_CHAR
parameter_list|(
name|c
parameter_list|)
define|\
value|do \ 	  { \ 	    if (j>= result_len - 1) \ 	      result = (char *)xrealloc (result, result_len += 64); \ 	    result[j++] = c; \ 	    result[j] = '\0'; \ 	  } \ 	while (0)
end_define

begin_function
name|int
name|history_expand
parameter_list|(
name|hstring
parameter_list|,
name|output
parameter_list|)
name|char
modifier|*
name|hstring
decl_stmt|;
name|char
modifier|*
modifier|*
name|output
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|l
decl_stmt|,
name|passc
decl_stmt|,
name|cc
decl_stmt|,
name|modified
decl_stmt|,
name|eindex
decl_stmt|,
name|only_printing
decl_stmt|,
name|dquote
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The output string, and its length. */
name|int
name|result_len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|char
name|mb
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
endif|#
directive|endif
comment|/* Used when adding the string. */
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Setting the history expansion character to 0 inhibits all      history expansion. */
if|if
condition|(
name|history_expansion_char
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|hstring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Prepare the buffer for printing error messages. */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_len
operator|=
literal|256
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|only_printing
operator|=
name|modified
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|hstring
argument_list|)
expr_stmt|;
comment|/* Grovel the string.  Only backslash and single quotes can quote the      history escape character.  We also handle arg specifiers. */
comment|/* Before we grovel forever, see if the history_expansion_char appears      anywhere within the text. */
comment|/* The quick substitution character is a history expansion all right.  That      is to say, "^this^that^" is equivalent to "!!:s^this^that^", and in fact,      that is the substitution that we do. */
if|if
condition|(
name|hstring
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
operator|+
literal|5
argument_list|)
expr_stmt|;
name|string
index|[
literal|0
index|]
operator|=
name|string
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|string
index|[
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
name|string
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
name|strcpy
argument_list|(
name|string
operator|+
literal|4
argument_list|,
name|hstring
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|string
operator|=
name|hstring
expr_stmt|;
comment|/* If not quick substitution, still maybe have to do expansion. */
comment|/* `!' followed by one of the characters in history_no_expand_chars 	 is NOT an expansion. */
for|for
control|(
name|i
operator|=
name|dquote
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
name|_rl_get_char_len
argument_list|(
name|string
operator|+
name|i
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|>
literal|1
condition|)
block|{
name|i
operator|+=
name|v
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* The history_comment_char, if set, appearing at the beginning 	     of a word signifies that the rest of the line should not have 	     history expansion performed on it. 	     Skip the rest of the line and break out of the loop. */
if|if
condition|(
name|history_comment_char
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|history_comment_char
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|member
argument_list|(
name|string
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|history_word_delimiters
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|string
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|history_expansion_char
condition|)
block|{
if|if
condition|(
operator|!
name|cc
operator|||
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
continue|continue;
comment|/* If the calling application has set 		 history_inhibit_expansion_function to a function that checks 		 for special cases that should not be history expanded, 		 call the function and skip the expansion if it returns a 		 non-zero value. */
elseif|else
if|if
condition|(
name|history_inhibit_expansion_function
operator|&&
call|(
modifier|*
name|history_inhibit_expansion_function
call|)
argument_list|(
name|string
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
else|else
break|break;
block|}
comment|/* Shell-like quoting: allow backslashes to quote double quotes 	     inside a double-quoted string. */
elseif|else
if|if
condition|(
name|dquote
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|cc
operator|==
literal|'"'
condition|)
name|i
operator|++
expr_stmt|;
comment|/* More shell-like quoting:  if we're paying attention to single 	     quotes and letting them quote the history expansion character, 	     then we need to pay attention to double quotes, because single 	     quotes are not special inside double-quoted strings. */
elseif|else
if|if
condition|(
name|history_quotes_inhibit_expansion
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'"'
condition|)
block|{
name|dquote
operator|=
literal|1
operator|-
name|dquote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dquote
operator|==
literal|0
operator|&&
name|history_quotes_inhibit_expansion
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'\''
condition|)
block|{
comment|/* If this is bash, single quotes inhibit history expansion. */
name|i
operator|++
expr_stmt|;
name|hist_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|history_quotes_inhibit_expansion
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* If this is bash, allow backslashes to quote single 		 quotes and the history expansion character. */
if|if
condition|(
name|cc
operator|==
literal|'\''
operator|||
name|cc
operator|==
name|history_expansion_char
condition|)
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Extract and perform the substitution. */
for|for
control|(
name|passc
operator|=
name|dquote
operator|=
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tchar
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|passc
condition|)
block|{
name|passc
operator|=
literal|0
expr_stmt|;
name|ADD_CHAR
argument_list|(
name|tchar
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|tchar
expr_stmt|;
name|memset
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MB_LEN_MAX
condition|;
name|k
operator|++
control|)
block|{
name|mb
index|[
name|k
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_get_char_len
argument_list|(
name|mb
argument_list|,
operator|&
name|ps
argument_list|)
operator|==
operator|-
literal|2
condition|)
name|c
operator|=
name|string
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|mb
argument_list|)
operator|>
literal|1
condition|)
block|{
name|ADD_STRING
argument_list|(
name|mb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
if|if
condition|(
name|tchar
operator|==
name|history_expansion_char
condition|)
name|tchar
operator|=
operator|-
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|tchar
operator|==
name|history_comment_char
condition|)
name|tchar
operator|=
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|tchar
condition|)
block|{
default|default:
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|passc
operator|++
expr_stmt|;
name|ADD_CHAR
argument_list|(
name|tchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|dquote
operator|=
literal|1
operator|-
name|dquote
expr_stmt|;
name|ADD_CHAR
argument_list|(
name|tchar
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
block|{
comment|/* If history_quotes_inhibit_expansion is set, single quotes 	       inhibit history expansion. */
if|if
condition|(
name|dquote
operator|==
literal|0
operator|&&
name|history_quotes_inhibit_expansion
condition|)
block|{
name|int
name|quote
decl_stmt|,
name|slen
decl_stmt|;
name|quote
operator|=
name|i
operator|++
expr_stmt|;
name|hist_string_extract_single_quoted
argument_list|(
name|string
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|slen
operator|=
name|i
operator|-
name|quote
operator|+
literal|2
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|slen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|quote
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|temp
index|[
name|slen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
operator|-
literal|2
case|:
comment|/* history_comment_char */
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|member
argument_list|(
name|string
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|history_word_delimiters
argument_list|)
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|string
operator|+
name|i
argument_list|)
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|i
operator|=
name|l
expr_stmt|;
block|}
else|else
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
comment|/* history_expansion_char */
name|cc
operator|=
name|string
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If the history_expansion_char is followed by one of the 	     characters in history_no_expand_chars, then it is not a 	     candidate for expansion of any kind. */
if|if
condition|(
name|member
argument_list|(
name|cc
argument_list|,
name|history_no_expand_chars
argument_list|)
condition|)
block|{
name|ADD_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|NO_BANG_HASH_MODIFIERS
argument_list|)
comment|/* There is something that is listed as a `word specifier' in csh 	     documentation which means `the expanded text to this point'. 	     That is not a word specifier, it is an event specifier.  If we 	     don't want to allow modifiers with `!#', just stick the current 	     output line in again. */
if|if
condition|(
name|cc
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|result
condition|)
block|{
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|r
operator|=
name|history_expand_internal
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
operator|&
name|eindex
argument_list|,
operator|&
name|temp
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|temp
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|hstring
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|temp
condition|)
block|{
name|modified
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|temp
condition|)
name|ADD_STRING
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|only_printing
operator|=
name|r
operator|==
literal|1
expr_stmt|;
name|i
operator|=
name|eindex
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|*
name|output
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|hstring
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_printing
condition|)
block|{
if|#
directive|if
literal|0
block|add_history (result);
endif|#
directive|endif
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|modified
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a consed string which is the word specified in SPEC, and found    in FROM.  NULL is returned if there is no spec.  The address of    ERROR_POINTER is returned if the word specified cannot be found.    CALLER_INDEX is the offset in SPEC to start looking; it is updated    to point to just after the last character parsed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_history_word_specifier
parameter_list|(
name|spec
parameter_list|,
name|from
parameter_list|,
name|caller_index
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|caller_index
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
operator|*
name|caller_index
decl_stmt|;
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
name|int
name|expecting_word_spec
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* The range of words to return doesn't exist yet. */
name|first
operator|=
name|last
operator|=
literal|0
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* If we found a colon, then this *must* be a word specification.  If      it isn't, then it is an error. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|expecting_word_spec
operator|++
expr_stmt|;
block|}
comment|/* Handle special cases first. */
comment|/* `%' is the word last searched for. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'%'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|search_match
condition|?
name|savestring
argument_list|(
name|search_match
argument_list|)
else|:
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `*' matches all of the arguments, but not the command. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|history_arg_extract
argument_list|(
literal|1
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
condition|?
name|result
else|:
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
comment|/* `$' is last arg. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
operator|*
name|caller_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|history_arg_extract
argument_list|(
literal|'$'
argument_list|,
literal|'$'
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
comment|/* Try to get FIRST and LAST figured out. */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
name|first
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
operator|&&
name|expecting_word_spec
condition|)
block|{
for|for
control|(
name|first
operator|=
literal|0
init|;
name|_rl_digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|first
operator|=
operator|(
name|first
operator|*
literal|10
operator|)
operator|+
name|_rl_digit_value
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* no valid `first' for word specifier */
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
operator|||
name|spec
index|[
name|i
index|]
operator|==
literal|'*'
condition|)
block|{
name|last
operator|=
operator|(
name|spec
index|[
name|i
index|]
operator|==
literal|'^'
operator|)
condition|?
literal|1
else|:
literal|'$'
expr_stmt|;
comment|/* x* abbreviates x-$ */
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|!=
literal|'-'
condition|)
name|last
operator|=
name|first
expr_stmt|;
else|else
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|last
operator|=
literal|0
init|;
name|_rl_digit_p
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|last
operator|=
operator|(
name|last
operator|*
literal|10
operator|)
operator|+
name|_rl_digit_value
argument_list|(
name|spec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spec
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|last
operator|=
literal|'$'
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if (!spec[i] || spec[i] == ':')
comment|/* check against `:' because there could be a modifier separator */
else|#
directive|else
else|else
comment|/* csh seems to allow anything to terminate the word spec here, 	   leaving it as an abbreviation. */
endif|#
directive|endif
name|last
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* x- abbreviates x-$ omitting word `$' */
block|}
operator|*
name|caller_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|first
operator|||
name|last
operator|==
literal|'$'
operator|||
name|last
operator|<
literal|0
condition|)
name|result
operator|=
name|history_arg_extract
argument_list|(
name|first
argument_list|,
name|last
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
condition|?
name|result
else|:
operator|(
name|char
operator|*
operator|)
operator|&
name|error_pointer
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Extract the args specified, starting at FIRST, and ending at LAST.    The args are taken from STRING.  If either FIRST or LAST is< 0,    then make that arg count from the right (subtract from the number of    tokens, so that FIRST = -1 means the next to last token on the line).    If LAST is `$' the last arg from STRING is used. */
end_comment

begin_function
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|,
name|string
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/* XXX - think about making history_tokenize return a struct array,      each struct in array being a string and a length to avoid the      calls to strlen below. */
if|if
condition|(
operator|(
name|list
operator|=
name|history_tokenize
argument_list|(
name|string
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|list
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
name|last
operator|=
name|len
operator|+
name|last
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
name|first
operator|=
name|len
operator|+
name|first
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|==
literal|'$'
condition|)
name|last
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|'$'
condition|)
name|first
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|last
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|>=
name|len
operator|||
name|last
operator|>
name|len
operator|||
name|first
operator|<
literal|0
operator|||
name|last
operator|<
literal|0
operator|||
name|first
operator|>
name|last
condition|)
name|result
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
name|size
operator|+=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
operator|,
name|offset
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|result
operator|+
name|offset
argument_list|,
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|last
condition|)
block|{
name|result
index|[
name|offset
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|result
index|[
name|offset
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_tokenize_word
parameter_list|(
name|string
parameter_list|,
name|ind
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|ind
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
name|i
operator|=
name|ind
expr_stmt|;
name|delimiter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"()\n"
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
literal|"<>;&|$"
argument_list|)
condition|)
block|{
name|int
name|peek
init|=
name|string
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|peek
operator|==
name|string
index|[
name|i
index|]
operator|&&
name|peek
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|peek
operator|==
literal|'<'
operator|&&
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'-'
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'<'
operator|&&
name|string
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'<'
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|peek
operator|==
literal|'&'
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'>'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'<'
operator|)
operator|)
operator|||
operator|(
name|peek
operator|==
literal|'>'
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'&'
operator|)
operator|||
operator|(
name|peek
operator|==
literal|'('
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|==
literal|'>'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'<'
operator|)
operator|)
operator|||
comment|/* ) */
operator|(
name|peek
operator|==
literal|'('
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|'$'
operator|)
condition|)
comment|/* ) */
block|{
name|i
operator|+=
literal|2
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|!=
literal|'$'
condition|)
block|{
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
comment|/* Get word from string + i; */
if|if
condition|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|HISTORY_QUOTE_CHARACTERS
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
for|for
control|(
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|delimiter
operator|!=
literal|'\''
operator|&&
operator|(
name|delimiter
operator|!=
literal|'"'
operator|||
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|slashify_in_quotes
argument_list|)
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|delimiter
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|delimiter
condition|)
block|{
name|delimiter
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|delimiter
operator|&&
operator|(
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|history_word_delimiters
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|delimiter
operator|&&
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|HISTORY_QUOTE_CHARACTERS
argument_list|)
condition|)
name|delimiter
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|history_substring
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
decl_stmt|;
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Parse STRING into tokens and return an array of strings.  If WIND is    not -1 and INDP is not null, we also want the word surrounding index    WIND.  The position in the returned array of strings is returned in    *INDP. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|history_tokenize_internal
parameter_list|(
name|string
parameter_list|,
name|wind
parameter_list|,
name|indp
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|wind
decl_stmt|,
decl|*
name|indp
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|result_index
decl_stmt|,
name|size
decl_stmt|;
comment|/* If we're searching for a string that's not part of a word (e.g., " "),      make sure we set *INDP to a reasonable value. */
if|if
condition|(
name|indp
operator|&&
name|wind
operator|!=
operator|-
literal|1
condition|)
operator|*
name|indp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Get a token, and stuff it into RESULT.  The tokens are split      exactly where the shell would split them. */
for|for
control|(
name|i
operator|=
name|result_index
operator|=
name|size
operator|=
literal|0
operator|,
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
init|;
name|string
index|[
name|i
index|]
condition|;
control|)
block|{
comment|/* Skip leading whitespace. */
for|for
control|(
init|;
name|string
index|[
name|i
index|]
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|string
index|[
name|i
index|]
operator|==
name|history_comment_char
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|start
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|history_tokenize_word
argument_list|(
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* If we have a non-whitespace delimiter character (which would not be 	 skipped by the loop above), use it and any adjacent delimiters to 	 make a separate field.  Any adjacent white space will be skipped the 	 next time through the loop. */
if|if
condition|(
name|i
operator|==
name|start
operator|&&
name|history_word_delimiters
condition|)
block|{
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|member
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|history_word_delimiters
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we are looking for the word in which the character at a 	 particular index falls, remember it. */
if|if
condition|(
name|indp
operator|&&
name|wind
operator|!=
operator|-
literal|1
operator|&&
name|wind
operator|>=
name|start
operator|&&
name|wind
operator|<
name|i
condition|)
operator|*
name|indp
operator|=
name|result_index
expr_stmt|;
if|if
condition|(
name|result_index
operator|+
literal|2
operator|>=
name|size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
operator|(
operator|(
name|size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
operator|++
index|]
operator|=
name|history_substring
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|result_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return an array of tokens, much as the shell might.  The tokens are    parsed out of STRING. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
name|history_tokenize_internal
argument_list|(
name|string
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find and return the word which contains the character at index IND    in the history line LINE.  Used to save the word matched by the    last history !?string? search. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_find_word
parameter_list|(
name|line
parameter_list|,
name|ind
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|ind
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|words
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|wind
decl_stmt|;
name|words
operator|=
name|history_tokenize_internal
argument_list|(
name|line
argument_list|,
name|ind
argument_list|,
operator|&
name|wind
argument_list|)
expr_stmt|;
if|if
condition|(
name|wind
operator|==
operator|-
literal|1
operator|||
name|words
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|s
operator|=
name|words
index|[
name|wind
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wind
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wind
operator|+
literal|1
init|;
name|words
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|words
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

end_unit

