begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* complete.c -- filename completion for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PWD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"posixdir.h"
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|int
name|QSFUNC
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|QSFUNC
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LSTAT
end_ifdef

begin_define
define|#
directive|define
name|LSTAT
value|lstat
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LSTAT
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Unix version of a hidden file.  Could be different on other systems. */
end_comment

begin_define
define|#
directive|define
name|HIDDEN_FILE
parameter_list|(
name|fname
parameter_list|)
value|((fname)[0] == '.')
end_define

begin_comment
comment|/* Most systems don't declare getpwent in<pwd.h> if _POSIX_SOURCE is    defined. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWENT
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|HAVE_GETPW_DECLS
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
operator|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETPWENT&& (!HAVE_GETPW_DECLS || _POSIX_SOURCE) */
end_comment

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing a word would normally display the list of possible matches.    This function is called instead of actually doing the display.    It takes three arguments: (char **matches, int num_matches, int max_length)    where MATCHES is the array of strings that matched, NUM_MATCHES is the    number of strings in that array, and MAX_LENGTH is the length of the    longest string in that array. */
end_comment

begin_decl_stmt
name|rl_compdisp_func_t
modifier|*
name|rl_completion_display_matches_hook
init|=
operator|(
name|rl_compdisp_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|X_OK
argument_list|)
end_if

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|stat_char
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|path_isdir
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rl_quote_filename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_completion_defaults
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_y_or_n
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_internal_pager
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printable_part
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fnwidth
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fnprint
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_filename
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|gen_completion_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|rl_compentry_func_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|remove_duplicate_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_match
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|append_to_match
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_all_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_lcd_of_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|postprocess_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|make_quoted_replacement
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	Completion matching, from readline's point of view.	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Variables known only to the readline library. */
end_comment

begin_comment
comment|/* If non-zero, non-unique completions always show the list of matches. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_show_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, non-unique completions show the list of matches, unless it    is not possible to do partial completion and modify the line. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_show_unmodified
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, completed directory names have a slash appended. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_mark_directories
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, the symlinked directory completion behavior introduced in    readline-4.2a is disabled, and symlinks that point to directories have    a slash appended (subject to the value of _rl_complete_mark_directories).    This is user-settable via the mark-symlinked-directories variable. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_mark_symlink_dirs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, completions are printed horizontally in alphabetical order,    like `ls -x'. */
end_comment

begin_decl_stmt
name|int
name|_rl_print_completions_horizontally
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that case is not significant in filename completion. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
end_if

begin_decl_stmt
name|int
name|_rl_completion_case_fold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|_rl_completion_case_fold
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-zero, don't match hidden files (filenames beginning with a `.' on    Unix) when doing filename completion. */
end_comment

begin_decl_stmt
name|int
name|_rl_match_hidden_files
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables available to applications using readline. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_comment
comment|/* Non-zero means add an additional character to each filename displayed    during listing completion iff rl_filename_completion_desired which helps    to indicate the type of file being listed. */
end_comment

begin_decl_stmt
name|int
name|rl_visible_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing on a directory name.  The function is called with    the address of a string (the current directory name) as an arg. */
end_comment

begin_decl_stmt
name|rl_icppfunc_t
modifier|*
name|rl_directory_completion_hook
init|=
operator|(
name|rl_icppfunc_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rl_icppfunc_t
modifier|*
name|rl_directory_rewrite_hook
init|=
operator|(
name|rl_icppfunc_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means readline completion functions perform tilde expansion. */
end_comment

begin_decl_stmt
name|int
name|rl_complete_with_tilde_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use rl_filename_completion_function (), the default filename    completer. */
end_comment

begin_decl_stmt
name|rl_compentry_func_t
modifier|*
name|rl_completion_entry_function
init|=
operator|(
name|rl_compentry_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
end_comment

begin_decl_stmt
name|rl_completion_func_t
modifier|*
name|rl_attempted_completion_function
init|=
operator|(
name|rl_completion_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to suppress normal filename completion after the    user-specified completion function has been called. */
end_comment

begin_decl_stmt
name|int
name|rl_attempted_completion_over
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a character indicating the type of completion being performed    by rl_complete_internal, available for use by application completion    functions. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if    she is sure she wants to see them all.  A negative value means    don't ask. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_page_completions
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The contents of this variable is what breaks words    in the shell, i.e. " \t\n\"\\'`@$><=" */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
literal|" \t\n\"\\'`@$><=;|&{("
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* }) */
end_comment

begin_comment
comment|/* List of basic quoting characters. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_basic_quote_characters
init|=
literal|"\"'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
end_comment

begin_comment
comment|/*const*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
operator|(
comment|/*const*/
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook function to allow an application to set the completion word    break characters before readline breaks up the line.  Allows    position-dependent word break characters. */
end_comment

begin_decl_stmt
name|rl_cpvfunc_t
modifier|*
name|rl_completion_word_break_hook
init|=
operator|(
name|rl_cpvfunc_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters which can be used to quote a substring of the line.    Completion occurs on the entire substring, and within the substring    rl_completer_word_break_characters are treated as any other character,    unless they also appear within this list. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_completer_quote_characters
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that should be quoted in filenames by the completer. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_filename_quote_characters
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_special_prefixes
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then disallow duplicates in the matches. */
end_comment

begin_decl_stmt
name|int
name|rl_ignore_completion_duplicates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_completion_desired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be quoted using    double quotes (or an application-specific quoting mechanism) if the    filename contains any characters in rl_filename_quote_chars.  This is    ALWAYS non-zero on entry, and can only be changed within a completion    entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_quoting_desired
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function, if defined, is called by the completer when real    filename completion is done, after all the matching names have been    generated. It is passed a (char**) known as matches in the code below.    It consists of a NULL-terminated array of pointers to potential    matching strings.  The 1st element (matches[0]) is the maximal    substring that is common to all matches. This function can re-arrange    the list of matches as required, but all elements of the array must be    free()'d if they are deleted. The main intent of this function is    to implement FIGNORE a la SunOS csh. */
end_comment

begin_decl_stmt
name|rl_compignore_func_t
modifier|*
name|rl_ignore_some_completions_function
init|=
operator|(
name|rl_compignore_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a function to quote a filename in an application-specific fashion.    Called with the text to quote, the type of match found (single or multiple)    and a pointer to the quoting character to be used, which the function can    reset if desired. */
end_comment

begin_decl_stmt
name|rl_quote_func_t
modifier|*
name|rl_filename_quoting_function
init|=
name|rl_quote_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to remove quoting characters from a filename.  Called    before completion is attempted, so the embedded quotes do not interfere    with matching names in the file system.  Readline doesn't do anything    with this; it's set only by applications. */
end_comment

begin_decl_stmt
name|rl_dequote_func_t
modifier|*
name|rl_filename_dequoting_function
init|=
operator|(
name|rl_dequote_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to decide whether or not a word break character is    quoted.  If a character is quoted, it does not break words for the    completer. */
end_comment

begin_decl_stmt
name|rl_linebuf_func_t
modifier|*
name|rl_char_is_quoted_p
init|=
operator|(
name|rl_linebuf_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, the completion functions don't append anything except a    possible closing quote.  This is set to 0 by rl_complete_internal and    may be changed by an application-specific completion function. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_suppress_append
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character appended to completed words when at the end of the line.  The    default is a space. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_append_character
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, the completion functions don't append any closing quote.    This is set to 0 by rl_complete_internal and may be changed by an    application-specific completion function. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_suppress_quote
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to any quote character readline thinks it finds before any application    completion function is called. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_quote_character
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a non-zero value if readline found quoting anywhere in the word to    be completed; set before any application completion function is called. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_found_quote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, a slash will be appended to completed filenames that are    symbolic links to directory names, subject to the value of the    mark-directories variable (which is user-settable).  This exists so    that application completion functions can override the user's preference    (set via the mark-symlinked-directories variable) if appropriate.    It's set to the value of _rl_complete_mark_symlink_dirs in    rl_complete_internal before any application-specific completion    function is called, so without that function doing anything, the user's    preferences are honored. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_mark_symlink_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, inhibit completion (temporarily). */
end_comment

begin_decl_stmt
name|int
name|rl_inhibit_completion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables local to this file. */
end_comment

begin_comment
comment|/* Local variable states what happened during the last completion attempt. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|completion_changed_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/*				     */
end_comment

begin_comment
comment|/*    Bindable completion functions  */
end_comment

begin_comment
comment|/*				     */
end_comment

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/* Complete the word at or before point.  You have supplied the function    that does the initial simple matching selection algorithm (see    rl_completion_matches ()).  The default is to do filename completion. */
end_comment

begin_function
name|int
name|rl_complete
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
if|if
condition|(
name|rl_inhibit_completion
condition|)
return|return
operator|(
name|_rl_insert_char
argument_list|(
name|ignore
argument_list|,
name|invoking_key
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|rl_last_func
operator|==
name|rl_complete
operator|&&
operator|!
name|completion_changed_buffer
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_all
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'!'
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_unmodified
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'@'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* List the possible completions.  See description of rl_complete (). */
end_comment

begin_function
name|int
name|rl_possible_completions
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_insert_completions
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the correct value to pass to rl_complete_internal performing    the same tests as rl_complete.  This allows consecutive calls to an    application's completion function to list possible completions and for    an application-specific completion function to honor the    show-all-if-ambiguous readline variable. */
end_comment

begin_function
name|int
name|rl_completion_mode
parameter_list|(
name|cfunc
parameter_list|)
name|rl_command_func_t
modifier|*
name|cfunc
decl_stmt|;
block|{
if|if
condition|(
name|rl_last_func
operator|==
name|cfunc
operator|&&
operator|!
name|completion_changed_buffer
condition|)
return|return
literal|'?'
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_all
condition|)
return|return
literal|'!'
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_unmodified
condition|)
return|return
literal|'@'
return|;
else|else
return|return
name|TAB
return|;
block|}
end_function

begin_comment
comment|/************************************/
end_comment

begin_comment
comment|/*				    */
end_comment

begin_comment
comment|/*    Completion utility functions  */
end_comment

begin_comment
comment|/*				    */
end_comment

begin_comment
comment|/************************************/
end_comment

begin_comment
comment|/* Set default values for readline word completion.  These are the variables    that application completion functions can change or inspect. */
end_comment

begin_function
specifier|static
name|void
name|set_completion_defaults
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
comment|/* Only the completion entry function can change these. */
name|rl_filename_completion_desired
operator|=
literal|0
expr_stmt|;
name|rl_filename_quoting_desired
operator|=
literal|1
expr_stmt|;
name|rl_completion_type
operator|=
name|what_to_do
expr_stmt|;
name|rl_completion_suppress_append
operator|=
name|rl_completion_suppress_quote
operator|=
literal|0
expr_stmt|;
comment|/* The completion entry function may optionally change this. */
name|rl_completion_mark_symlink_dirs
operator|=
name|_rl_complete_mark_symlink_dirs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The user must press "y" or "n". Non-zero return means "y" pressed. */
end_comment

begin_function
specifier|static
name|int
name|get_y_or_n
parameter_list|(
name|for_pager
parameter_list|)
name|int
name|for_pager
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'N'
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|ABORT_CHAR
condition|)
name|_rl_abort_internal
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_pager
operator|&&
operator|(
name|c
operator|==
name|NEWLINE
operator|||
name|c
operator|==
name|RETURN
operator|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|for_pager
operator|&&
operator|(
name|c
operator|==
literal|'q'
operator|||
name|c
operator|==
literal|'Q'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rl_ding
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_internal_pager
parameter_list|(
name|lines
parameter_list|)
name|int
name|lines
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"--More--"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|i
operator|=
name|get_y_or_n
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|_rl_erase_entire_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|2
condition|)
return|return
operator|(
name|lines
operator|-
literal|1
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|path_isdir
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_comment
comment|/* Return the character which best describes FILENAME.      `@' for symbolic links      `/' for directories      `*' for executables      `=' for sockets      `|' for FIFOs      `%' for character special devices      `#' for block special devices */
end_comment

begin_function
specifier|static
name|int
name|stat_char
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|character
decl_stmt|,
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LSTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
name|r
operator|=
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|character
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'/'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|S_ISCHR
argument_list|)
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'%'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISCHR */
if|#
directive|if
name|defined
argument_list|(
name|S_ISBLK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'#'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISBLK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISLNK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISSOCK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'='
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISSOCK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISFIFO
argument_list|)
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'|'
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|character
operator|=
literal|'*'
expr_stmt|;
block|}
return|return
operator|(
name|character
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* Return the portion of PATHNAME that should be output when listing    possible completions.  If we are hacking filename completion, we    are only interested in the basename, the portion following the    final slash.  Otherwise, we return what we were passed.  Since    printing empty strings is not very informative, if we're doing    filename completion, and the basename is the empty string, we look    for the previous slash and return the portion following that.  If    there's no previous slash, we just return what we were passed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_part
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
operator|==
literal|0
condition|)
comment|/* don't need to do anything */
return|return
operator|(
name|pathname
operator|)
return|;
name|temp
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|pathname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|pathname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|temp
operator|=
name|pathname
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
operator|*
name|temp
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|pathname
operator|)
return|;
comment|/* If the basename is NULL, we might have a pathname like '/usr/src/'.      Look for a previous slash and, if one is found, return the portion      following that slash.  If there's no previous slash, just return the      pathname we were passed. */
elseif|else
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|x
operator|=
name|temp
operator|-
literal|1
init|;
name|x
operator|>
name|pathname
condition|;
name|x
operator|--
control|)
if|if
condition|(
operator|*
name|x
operator|==
literal|'/'
condition|)
break|break;
return|return
operator|(
operator|(
operator|*
name|x
operator|==
literal|'/'
operator|)
condition|?
name|x
operator|+
literal|1
else|:
name|pathname
operator|)
return|;
block|}
else|else
return|return
operator|++
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Compute width of STRING when displayed on screen by print_filename */
end_comment

begin_function
specifier|static
name|int
name|fnwidth
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|width
decl_stmt|,
name|pos
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|mbstate_t
name|ps
decl_stmt|;
name|int
name|left
decl_stmt|,
name|w
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|left
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|width
operator|=
name|pos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|string
index|[
name|pos
index|]
condition|)
block|{
if|if
condition|(
name|CTRL_CHAR
argument_list|(
operator|*
name|string
argument_list|)
operator|||
operator|*
name|string
operator|==
name|RUBOUT
condition|)
block|{
name|width
operator|+=
literal|2
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|clen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|string
operator|+
name|pos
argument_list|,
name|left
operator|-
name|pos
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
name|clen
argument_list|)
condition|)
block|{
name|width
operator|++
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|clen
argument_list|)
condition|)
break|break;
else|else
block|{
name|pos
operator|+=
name|clen
expr_stmt|;
name|w
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|width
operator|+=
operator|(
name|w
operator|>=
literal|0
operator|)
condition|?
name|w
else|:
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|width
operator|++
expr_stmt|;
name|pos
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|width
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fnprint
parameter_list|(
name|to_print
parameter_list|)
specifier|const
name|char
modifier|*
name|to_print
decl_stmt|;
block|{
name|int
name|printed_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|mbstate_t
name|ps
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|size_t
name|tlen
decl_stmt|;
name|int
name|width
decl_stmt|,
name|w
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|end
operator|=
name|to_print
operator|+
name|strlen
argument_list|(
name|to_print
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printed_len
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|to_print
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|CTRL_CHAR
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|UNCTRL
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|printed_len
operator|+=
literal|2
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|RUBOUT
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'?'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|printed_len
operator|+=
literal|2
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|tlen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|s
argument_list|,
name|end
operator|-
name|s
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
name|tlen
argument_list|)
condition|)
block|{
name|tlen
operator|=
literal|1
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|tlen
argument_list|)
condition|)
break|break;
else|else
block|{
name|w
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|w
operator|>=
literal|0
operator|)
condition|?
name|w
else|:
literal|1
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
name|tlen
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|s
operator|+=
name|tlen
expr_stmt|;
name|printed_len
operator|+=
name|width
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|printed_len
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|printed_len
return|;
block|}
end_function

begin_comment
comment|/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we    are using it, check for and output a single character for `special'    filenames.  Return the number of characters we output. */
end_comment

begin_function
specifier|static
name|int
name|print_filename
parameter_list|(
name|to_print
parameter_list|,
name|full_pathname
parameter_list|)
name|char
modifier|*
name|to_print
decl_stmt|,
decl|*
name|full_pathname
decl_stmt|;
end_function

begin_block
block|{
name|int
name|printed_len
decl_stmt|,
name|extension_char
decl_stmt|,
name|slen
decl_stmt|,
name|tlen
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|new_full_pathname
decl_stmt|,
modifier|*
name|dn
decl_stmt|;
name|extension_char
operator|=
literal|0
expr_stmt|;
name|printed_len
operator|=
name|fnprint
argument_list|(
name|to_print
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
operator|(
name|rl_visible_stats
operator|||
name|_rl_complete_mark_directories
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|_rl_complete_mark_directories
condition|)
endif|#
directive|endif
block|{
comment|/* If to_print != full_pathname, to_print is the basename of the 	 path passed.  In this case, we try to expand the directory 	 name before checking for the stat character. */
if|if
condition|(
name|to_print
operator|!=
name|full_pathname
condition|)
block|{
comment|/* Terminate the directory name. */
name|c
operator|=
name|to_print
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If setting the last slash in full_pathname to a NUL results in 	     full_pathname being the empty string, we are trying to complete 	     files in the root directory.  If we pass a null string to the 	     bash directory completion hook, for example, it will expand it 	     to the current directory.  We just want the `/'. */
if|if
condition|(
name|full_pathname
operator|==
literal|0
operator|||
operator|*
name|full_pathname
operator|==
literal|0
condition|)
name|dn
operator|=
literal|"/"
expr_stmt|;
elseif|else
if|if
condition|(
name|full_pathname
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|dn
operator|=
name|full_pathname
expr_stmt|;
elseif|else
if|if
condition|(
name|full_pathname
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|dn
operator|=
literal|"//"
expr_stmt|;
comment|/* restore trailing slash to `//' */
elseif|else
if|if
condition|(
name|full_pathname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|full_pathname
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|dn
operator|=
literal|"/"
expr_stmt|;
comment|/* don't turn /// into // */
else|else
name|dn
operator|=
name|full_pathname
expr_stmt|;
name|s
operator|=
name|tilde_expand
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_directory_completion_hook
condition|)
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|strlen
argument_list|(
name|to_print
argument_list|)
expr_stmt|;
name|new_full_pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|slen
operator|+
name|tlen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|slen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|slen
operator|--
expr_stmt|;
else|else
name|new_full_pathname
index|[
name|slen
index|]
operator|=
literal|'/'
expr_stmt|;
name|new_full_pathname
index|[
name|slen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
operator|+
name|slen
operator|+
literal|1
argument_list|,
name|to_print
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
if|if
condition|(
name|rl_visible_stats
condition|)
name|extension_char
operator|=
name|stat_char
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|path_isdir
argument_list|(
name|new_full_pathname
argument_list|)
condition|)
name|extension_char
operator|=
literal|'/'
expr_stmt|;
name|free
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|tilde_expand
argument_list|(
name|full_pathname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
if|if
condition|(
name|rl_visible_stats
condition|)
name|extension_char
operator|=
name|stat_char
argument_list|(
name|s
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|path_isdir
argument_list|(
name|s
argument_list|)
condition|)
name|extension_char
operator|=
literal|'/'
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_char
condition|)
block|{
name|putc
argument_list|(
name|extension_char
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|printed_len
operator|++
expr_stmt|;
block|}
block|}
return|return
name|printed_len
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|rl_quote_filename
parameter_list|(
name|s
parameter_list|,
name|rtype
parameter_list|,
name|qcp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|rtype
decl_stmt|;
name|char
modifier|*
name|qcp
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|rl_completer_quote_characters
expr_stmt|;
name|strcpy
argument_list|(
name|r
operator|+
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcp
condition|)
operator|*
name|qcp
operator|=
operator|*
name|rl_completer_quote_characters
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Find the bounds of the current word for completion purposes, and leave    rl_point set to the end of the word.  This function skips quoted    substrings (characters between matched pairs of characters in    rl_completer_quote_characters).  First we try to find an unclosed    quoted substring on which to do matching.  If one is not found, we use    the word break characters to find the boundaries of the current word.    We call an application-specific function to decide whether or not a    particular word break character is quoted; if that function returns a    non-zero result, the character does not break a word.  This function    returns the opening quote character if we found an unclosed quoted    substring, '\0' otherwise.  FP, if non-null, is set to a value saying    which (shell-like) quote characters we found (single quote, double    quote, or backslash) anywhere in the string.  DP, if non-null, is set to    the value of the delimiter character that caused a word break. */
end_comment

begin_function
name|char
name|_rl_find_completion_word
parameter_list|(
name|fp
parameter_list|,
name|dp
parameter_list|)
name|int
modifier|*
name|fp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|scan
decl_stmt|,
name|end
decl_stmt|,
name|found_quote
decl_stmt|,
name|delimiter
decl_stmt|,
name|pass_next
decl_stmt|,
name|isbrk
decl_stmt|;
name|char
name|quote_char
decl_stmt|,
modifier|*
name|brkchars
decl_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
name|brkchars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rl_completion_word_break_hook
condition|)
name|brkchars
operator|=
call|(
modifier|*
name|rl_completion_word_break_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|brkchars
operator|==
literal|0
condition|)
name|brkchars
operator|=
name|rl_completer_word_break_characters
expr_stmt|;
if|if
condition|(
name|rl_completer_quote_characters
condition|)
block|{
comment|/* We have a list of characters which can be used in pairs to 	 quote substrings for the completer.  Try to find the start 	 of an unclosed quoted substring. */
comment|/* FOUND_QUOTE is set so we know what kind of quotes we found. */
for|for
control|(
name|scan
operator|=
name|pass_next
operator|=
literal|0
init|;
name|scan
operator|<
name|end
condition|;
name|scan
operator|=
name|MB_NEXTCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|scan
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
control|)
block|{
if|if
condition|(
name|pass_next
condition|)
block|{
name|pass_next
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Shell-like semantics for single quotes -- don't allow backslash 	     to quote anything in single quotes, especially not the closing 	     quote.  If you don't like this, take out the check on the value 	     of quote_char. */
if|if
condition|(
name|quote_char
operator|!=
literal|'\''
operator|&&
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
literal|'\\'
condition|)
block|{
name|pass_next
operator|=
literal|1
expr_stmt|;
name|found_quote
operator||=
name|RL_QF_BACKSLASH
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char. */
if|if
condition|(
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close.  Abandon this substring. */
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_quote_characters
argument_list|,
name|rl_line_buffer
index|[
name|scan
index|]
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted substring. */
name|quote_char
operator|=
name|rl_line_buffer
index|[
name|scan
index|]
expr_stmt|;
name|rl_point
operator|=
name|scan
operator|+
literal|1
expr_stmt|;
comment|/* Shell-like quoting conventions. */
if|if
condition|(
name|quote_char
operator|==
literal|'\''
condition|)
name|found_quote
operator||=
name|RL_QF_SINGLE_QUOTE
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_char
operator|==
literal|'"'
condition|)
name|found_quote
operator||=
name|RL_QF_DOUBLE_QUOTE
expr_stmt|;
else|else
name|found_quote
operator||=
name|RL_QF_OTHER_QUOTE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|end
operator|&&
name|quote_char
operator|==
literal|'\0'
condition|)
block|{
comment|/* We didn't find an unclosed quoted substring upon which to do          completion, so use the word break characters to find the          substring on which to complete. */
while|while
condition|(
name|rl_point
operator|=
name|MB_PREVCHAR
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_ANY
argument_list|)
condition|)
block|{
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|brkchars
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Call the application-specific function to tell us whether 	     this word break character is quoted and should be skipped. */
if|if
condition|(
name|rl_char_is_quoted_p
operator|&&
name|found_quote
operator|&&
call|(
modifier|*
name|rl_char_is_quoted_p
call|)
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
condition|)
continue|continue;
comment|/* Convoluted code, but it avoids an n^2 algorithm with calls 	     to char_is_quoted. */
break|break;
block|}
block|}
comment|/* If we are at an unquoted word break, then advance past it. */
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
comment|/* If there is an application-specific function to say whether or not      a character is quoted and we found a quote character, let that      function decide whether or not a character is a word break, even      if it is found in rl_completer_word_break_characters.  Don't bother      if we're at the end of the line, though. */
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|rl_char_is_quoted_p
condition|)
name|isbrk
operator|=
operator|(
name|found_quote
operator|==
literal|0
operator|||
call|(
modifier|*
name|rl_char_is_quoted_p
call|)
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|brkchars
argument_list|,
name|scan
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
name|isbrk
operator|=
name|strchr
argument_list|(
name|brkchars
argument_list|,
name|scan
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|isbrk
condition|)
block|{
comment|/* If the character that caused the word break was a quoting 	     character, then remember it as the delimiter. */
if|if
condition|(
name|rl_basic_quote_characters
operator|&&
name|strchr
argument_list|(
name|rl_basic_quote_characters
argument_list|,
name|scan
argument_list|)
operator|&&
operator|(
name|end
operator|-
name|rl_point
operator|)
operator|>
literal|1
condition|)
name|delimiter
operator|=
name|scan
expr_stmt|;
comment|/* If the character isn't needed to determine something special 	     about what kind of completion to perform, then advance past it. */
if|if
condition|(
name|rl_special_prefixes
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|rl_special_prefixes
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
condition|)
operator|*
name|fp
operator|=
name|found_quote
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|*
name|dp
operator|=
name|delimiter
expr_stmt|;
return|return
operator|(
name|quote_char
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|gen_completion_matches
parameter_list|(
name|text
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|our_func
parameter_list|,
name|found_quote
parameter_list|,
name|quote_char
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|rl_compentry_func_t
modifier|*
name|our_func
decl_stmt|;
name|int
name|found_quote
decl_stmt|,
name|quote_char
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|rl_completion_found_quote
operator|=
name|found_quote
expr_stmt|;
name|rl_completion_quote_character
operator|=
name|quote_char
expr_stmt|;
comment|/* If the user wants to TRY to complete, but then wants to give      up and use the default completion function, they set the      variable rl_attempted_completion_function. */
if|if
condition|(
name|rl_attempted_completion_function
condition|)
block|{
name|matches
operator|=
call|(
modifier|*
name|rl_attempted_completion_function
call|)
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|||
name|rl_attempted_completion_over
condition|)
block|{
name|rl_attempted_completion_over
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
block|}
comment|/* XXX -- filename dequoting moved into rl_filename_completion_function */
name|matches
operator|=
name|rl_completion_matches
argument_list|(
name|text
argument_list|,
name|our_func
argument_list|)
expr_stmt|;
return|return
name|matches
return|;
block|}
end_function

begin_comment
comment|/* Filter out duplicates in MATCHES.  This frees up the strings in    MATCHES. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|remove_duplicate_matches
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
name|char
modifier|*
name|lowest_common
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|newlen
decl_stmt|;
name|char
name|dead_slot
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp_array
decl_stmt|;
comment|/* Sort the items. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Sort the array without matches[0], since we need it to      stay in place no matter what. */
if|if
condition|(
name|i
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
comment|/* Remember the lowest common denominator for it may be unique. */
name|lowest_common
operator|=
name|savestring
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newlen
operator|=
literal|0
init|;
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|matches
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
expr_stmt|;
block|}
else|else
name|newlen
operator|++
expr_stmt|;
block|}
comment|/* We have marked all the dead slots with (char *)&dead_slot.      Copy all the non-dead entries into a new array. */
name|temp_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|3
operator|+
name|newlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|temp_array
index|[
name|j
operator|++
index|]
operator|=
name|matches
index|[
name|i
index|]
expr_stmt|;
block|}
name|temp_array
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|free
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Place the lowest common denominator back in [0]. */
name|temp_array
index|[
literal|0
index|]
operator|=
name|lowest_common
expr_stmt|;
comment|/* If there is one string left, and it is identical to the      lowest common denominator, then the LCD is the string to      insert. */
if|if
condition|(
name|j
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|temp_array
index|[
literal|0
index|]
argument_list|,
name|temp_array
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temp_array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|temp_array
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|temp_array
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the common prefix of the list of matches, and put it into    matches[0]. */
end_comment

begin_function
specifier|static
name|int
name|compute_lcd_of_matches
parameter_list|(
name|match_list
parameter_list|,
name|matches
parameter_list|,
name|text
parameter_list|)
name|char
modifier|*
modifier|*
name|match_list
decl_stmt|;
name|int
name|matches
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|si
decl_stmt|;
name|int
name|low
decl_stmt|;
comment|/* Count of max-matched characters. */
name|char
modifier|*
name|dtext
decl_stmt|;
comment|/* dequoted TEXT, if needed */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|int
name|v
decl_stmt|;
name|mbstate_t
name|ps1
decl_stmt|,
name|ps2
decl_stmt|;
name|wchar_t
name|wc1
decl_stmt|,
name|wc2
decl_stmt|;
endif|#
directive|endif
comment|/* If only one match, just use that.  Otherwise, compare each      member of the list with the next, finding out where they      stop matching. */
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|match_list
index|[
literal|1
index|]
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|low
operator|=
literal|100000
init|;
name|i
operator|<
name|matches
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ps1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|_rl_completion_case_fold
condition|)
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|_rl_to_lower
argument_list|(
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|c2
operator|=
name|_rl_to_lower
argument_list|(
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
argument_list|)
operator|)
condition|;
name|si
operator|++
control|)
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|v
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc1
argument_list|,
name|match_list
index|[
name|i
index|]
operator|+
name|si
argument_list|,
name|strlen
argument_list|(
name|match_list
index|[
name|i
index|]
operator|+
name|si
argument_list|)
argument_list|,
operator|&
name|ps1
argument_list|)
expr_stmt|;
name|mbrtowc
argument_list|(
operator|&
name|wc2
argument_list|,
name|match_list
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|si
argument_list|,
name|strlen
argument_list|(
name|match_list
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|si
argument_list|)
argument_list|,
operator|&
name|ps2
argument_list|)
expr_stmt|;
name|wc1
operator|=
name|towlower
argument_list|(
name|wc1
argument_list|)
expr_stmt|;
name|wc2
operator|=
name|towlower
argument_list|(
name|wc2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc1
operator|!=
name|wc2
condition|)
break|break;
elseif|else
if|if
condition|(
name|v
operator|>
literal|1
condition|)
name|si
operator|+=
name|v
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
else|else
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
operator|)
operator|&&
operator|(
name|c2
operator|=
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
operator|)
condition|;
name|si
operator|++
control|)
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|mbstate_t
name|ps_back
decl_stmt|;
name|ps_back
operator|=
name|ps1
expr_stmt|;
if|if
condition|(
operator|!
name|_rl_compare_chars
argument_list|(
name|match_list
index|[
name|i
index|]
argument_list|,
name|si
argument_list|,
operator|&
name|ps1
argument_list|,
name|match_list
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|si
argument_list|,
operator|&
name|ps2
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|v
operator|=
name|_rl_get_char_len
argument_list|(
operator|&
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
argument_list|,
operator|&
name|ps_back
argument_list|)
operator|)
operator|>
literal|1
condition|)
name|si
operator|+=
name|v
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|low
operator|>
name|si
condition|)
name|low
operator|=
name|si
expr_stmt|;
block|}
comment|/* If there were multiple matches, but none matched up to even the      first character, and the user typed something, use that as the      value of matches[0]. */
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|text
operator|&&
operator|*
name|text
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|match_list
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|low
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX - this might need changes in the presence of multibyte chars */
comment|/* If we are ignoring case, try to preserve the case of the string 	 the user typed in the face of multiple matches differing in case. */
if|if
condition|(
name|_rl_completion_case_fold
condition|)
block|{
comment|/* We're making an assumption here: 		IF we're completing filenames AND 		   the application has defined a filename dequoting function AND 		   we found a quote character AND 		   the application has requested filename quoting 		THEN 		   we assume that TEXT was dequoted before checking against 		   the file system and needs to be dequoted here before we 		   check against the list of matches 		FI */
name|dtext
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|rl_filename_dequoting_function
operator|&&
name|rl_completion_found_quote
operator|&&
name|rl_filename_quoting_desired
condition|)
block|{
name|dtext
operator|=
call|(
modifier|*
name|rl_filename_dequoting_function
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|text
argument_list|,
name|rl_completion_quote_character
argument_list|)
expr_stmt|;
name|text
operator|=
name|dtext
expr_stmt|;
block|}
comment|/* sort the list to get consistent answers. */
name|qsort
argument_list|(
name|match_list
operator|+
literal|1
argument_list|,
name|matches
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
name|si
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|<=
name|low
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|matches
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|match_list
index|[
name|i
index|]
argument_list|,
name|text
argument_list|,
name|si
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
name|i
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* no casematch, use first entry */
if|if
condition|(
name|i
operator|>
name|matches
condition|)
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* otherwise, just use the text the user typed. */
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|text
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|dtext
argument_list|)
expr_stmt|;
block|}
else|else
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|0
index|]
index|[
name|low
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|matches
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|postprocess_matches
parameter_list|(
name|matchesp
parameter_list|,
name|matching_filenames
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|matchesp
decl_stmt|;
name|int
name|matching_filenames
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|matches
decl_stmt|,
modifier|*
modifier|*
name|temp_matches
decl_stmt|;
name|int
name|nmatch
decl_stmt|,
name|i
decl_stmt|;
name|matches
operator|=
operator|*
name|matchesp
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* It seems to me that in all the cases we handle we would like      to ignore duplicate possiblilities.  Scan for the text to      insert being identical to the other completions. */
if|if
condition|(
name|rl_ignore_completion_duplicates
condition|)
block|{
name|temp_matches
operator|=
name|remove_duplicate_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|temp_matches
expr_stmt|;
block|}
comment|/* If we are matching filenames, then here is our chance to      do clever processing by re-examining the list.  Call the      ignore function with the array as a parameter.  It can      munge the array, deleting matches as it desires. */
if|if
condition|(
name|rl_ignore_some_completions_function
operator|&&
name|matching_filenames
condition|)
block|{
for|for
control|(
name|nmatch
operator|=
literal|1
init|;
name|matches
index|[
name|nmatch
index|]
condition|;
name|nmatch
operator|++
control|)
empty_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|rl_ignore_some_completions_function
argument_list|)
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|matches
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
operator|*
name|matchesp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If we removed some matches, recompute the common prefix. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|i
operator|<
name|nmatch
condition|)
block|{
name|t
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
name|compute_lcd_of_matches
argument_list|(
name|matches
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|matchesp
operator|=
name|matches
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A convenience function for displaying a list of strings in    columnar format on readline's output stream.  MATCHES is the list    of strings, in argv format, LEN is the number of strings in MATCHES,    and MAX is the length of the longest string in MATCHES. */
end_comment

begin_function
name|void
name|rl_display_match_list
parameter_list|(
name|matches
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|int
name|len
decl_stmt|,
name|max
decl_stmt|;
block|{
name|int
name|count
decl_stmt|,
name|limit
decl_stmt|,
name|printed_len
decl_stmt|,
name|lines
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* How many items of MAX length can we fit in the screen window? */
name|max
operator|+=
literal|2
expr_stmt|;
name|limit
operator|=
name|_rl_screenwidth
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max
operator|==
name|_rl_screenwidth
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Avoid a possible floating exception.  If max> _rl_screenwidth,      limit will be 0 and a divide-by-zero fault will result. */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|len
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If LEN is less than LIMIT, then      just do the inner printing loop. 	   0< len<= limit  implies  count = 1. */
comment|/* Sort the items if they are not already sorted. */
if|if
condition|(
name|rl_ignore_completion_duplicates
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
name|rl_crlf
argument_list|()
expr_stmt|;
name|lines
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_print_completions_horizontally
operator|==
literal|0
condition|)
block|{
comment|/* Print the sorted items, up-and-down alphabetically, like ls. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>
name|len
operator|||
name|matches
index|[
name|l
index|]
operator|==
literal|0
condition|)
break|break;
else|else
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|limit
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|rl_crlf
argument_list|()
expr_stmt|;
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|_rl_page_completions
operator|&&
name|lines
operator|>=
operator|(
name|_rl_screenheight
operator|-
literal|1
operator|)
operator|&&
name|i
operator|<
name|count
condition|)
block|{
name|lines
operator|=
name|_rl_internal_pager
argument_list|(
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|<
literal|0
condition|)
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* Print the sorted items, across alphabetically, like ls -x. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Have we reached the end of this line? */
if|if
condition|(
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|limit
operator|>
literal|1
operator|)
operator|&&
operator|(
name|i
operator|%
name|limit
operator|)
operator|==
literal|0
condition|)
block|{
name|rl_crlf
argument_list|()
expr_stmt|;
name|lines
operator|++
expr_stmt|;
if|if
condition|(
name|_rl_page_completions
operator|&&
name|lines
operator|>=
name|_rl_screenheight
operator|-
literal|1
condition|)
block|{
name|lines
operator|=
name|_rl_internal_pager
argument_list|(
name|lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|lines
operator|<
literal|0
condition|)
return|return;
block|}
block|}
else|else
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
block|}
name|rl_crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Display MATCHES, a list of matching filenames in argv format.  This    handles the simple case -- a single match -- first.  If there is more    than one match, we compute the number of strings in the list and the    length of the longest string, which will be needed by the display    function.  If the application wants to handle displaying the list of    matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the    address of a function, and we just call it.  If we're handling the    display ourselves, we just call rl_display_match_list.  We also check    that the list of matches doesn't exceed the user-settable threshold,    and ask the user if he wants to see the list if there are more matches    than RL_COMPLETION_QUERY_ITEMS. */
end_comment

begin_function
specifier|static
name|void
name|display_matches
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|max
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Move to the last visible line of a possibly-multiple-line command. */
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
comment|/* Handle simple case first.  What if there is only one answer? */
if|if
condition|(
name|matches
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rl_crlf
argument_list|()
expr_stmt|;
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rl_crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* There is more than one answer.  Find out how many there are,      and find the maximum printed length of a single entry. */
for|for
control|(
name|max
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|fnwidth
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max
condition|)
name|max
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* If the caller has defined a display hook, then call that now. */
if|if
condition|(
name|rl_completion_display_matches_hook
condition|)
block|{
call|(
modifier|*
name|rl_completion_display_matches_hook
call|)
argument_list|(
name|matches
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there are many items, then ask the user if she really wants to      see them all. */
if|if
condition|(
name|rl_completion_query_items
operator|>
literal|0
operator|&&
name|len
operator|>=
name|rl_completion_query_items
condition|)
block|{
name|rl_crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"Display all %d possibilities? (y or n)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_y_or_n
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl_crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|rl_display_match_list
argument_list|(
name|matches
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|make_quoted_replacement
parameter_list|(
name|match
parameter_list|,
name|mtype
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|mtype
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
comment|/* Pointer to quoting character, if any */
block|{
name|int
name|should_quote
decl_stmt|,
name|do_replace
decl_stmt|;
name|char
modifier|*
name|replacement
decl_stmt|;
comment|/* If we are doing completion on quoted substrings, and any matches      contain any of the completer_word_break_characters, then auto-      matically prepend the substring with a quote character (just pick      the first one from the list of such) if it does not already begin      with a quote string.  FIXME: Need to remove any such automatically      inserted quote character when it no longer is necessary, such as      if we change the string we are completing on and the new set of      matches don't require a quoted substring. */
name|replacement
operator|=
name|match
expr_stmt|;
name|should_quote
operator|=
name|match
operator|&&
name|rl_completer_quote_characters
operator|&&
name|rl_filename_completion_desired
operator|&&
name|rl_filename_quoting_desired
expr_stmt|;
if|if
condition|(
name|should_quote
condition|)
name|should_quote
operator|=
name|should_quote
operator|&&
operator|(
operator|!
name|qc
operator|||
operator|!
operator|*
name|qc
operator|||
operator|(
name|rl_completer_quote_characters
operator|&&
name|strchr
argument_list|(
name|rl_completer_quote_characters
argument_list|,
operator|*
name|qc
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|should_quote
condition|)
block|{
comment|/* If there is a single match, see if we need to quote it.          This also checks whether the common prefix of several 	 matches needs to be quoted. */
name|should_quote
operator|=
name|rl_filename_quote_characters
condition|?
operator|(
name|_rl_strpbrk
argument_list|(
name|match
argument_list|,
name|rl_filename_quote_characters
argument_list|)
operator|!=
literal|0
operator|)
else|:
literal|0
expr_stmt|;
name|do_replace
operator|=
name|should_quote
condition|?
name|mtype
else|:
name|NO_MATCH
expr_stmt|;
comment|/* Quote the replacement, since we found an embedded 	 word break character in a potential match. */
if|if
condition|(
name|do_replace
operator|!=
name|NO_MATCH
operator|&&
name|rl_filename_quoting_function
condition|)
name|replacement
operator|=
call|(
modifier|*
name|rl_filename_quoting_function
call|)
argument_list|(
name|match
argument_list|,
name|do_replace
argument_list|,
name|qc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|replacement
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_match
parameter_list|(
name|match
parameter_list|,
name|start
parameter_list|,
name|mtype
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|start
decl_stmt|,
name|mtype
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
block|{
name|char
modifier|*
name|replacement
decl_stmt|;
name|char
name|oqc
decl_stmt|;
name|oqc
operator|=
name|qc
condition|?
operator|*
name|qc
else|:
literal|'\0'
expr_stmt|;
name|replacement
operator|=
name|make_quoted_replacement
argument_list|(
name|match
argument_list|,
name|mtype
argument_list|,
name|qc
argument_list|)
expr_stmt|;
comment|/* Now insert the match. */
if|if
condition|(
name|replacement
condition|)
block|{
comment|/* Don't double an opening quote character. */
if|if
condition|(
name|qc
operator|&&
operator|*
name|qc
operator|&&
name|start
operator|&&
name|rl_line_buffer
index|[
name|start
operator|-
literal|1
index|]
operator|==
operator|*
name|qc
operator|&&
name|replacement
index|[
literal|0
index|]
operator|==
operator|*
name|qc
condition|)
name|start
operator|--
expr_stmt|;
comment|/* If make_quoted_replacement changed the quoting character, remove 	 the opening quote and insert the (fully-quoted) replacement. */
elseif|else
if|if
condition|(
name|qc
operator|&&
operator|(
operator|*
name|qc
operator|!=
name|oqc
operator|)
operator|&&
name|start
operator|&&
name|rl_line_buffer
index|[
name|start
operator|-
literal|1
index|]
operator|==
name|oqc
operator|&&
name|replacement
index|[
literal|0
index|]
operator|!=
name|oqc
condition|)
name|start
operator|--
expr_stmt|;
name|_rl_replace_text
argument_list|(
name|replacement
argument_list|,
name|start
argument_list|,
name|rl_point
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|match
condition|)
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append any necessary closing quote and a separator character to the    just-inserted match.  If the user has specified that directories    should be marked by a trailing `/', append one of those instead.  The    default trailing character is a space.  Returns the number of characters    appended.  If NONTRIVIAL_MATCH is set, we test for a symlink (if the OS    has them) and don't add a suffix for a symlink to a directory.  A    nontrivial match is one that actually adds to the word being completed.    The variable rl_completion_mark_symlink_dirs controls this behavior    (it's initially set to the what the user has chosen, indicated by the    value of _rl_complete_mark_symlink_dirs, but may be modified by an    application's completion function). */
end_comment

begin_function
specifier|static
name|int
name|append_to_match
parameter_list|(
name|text
parameter_list|,
name|delimiter
parameter_list|,
name|quote_char
parameter_list|,
name|nontrivial_match
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|quote_char
decl_stmt|,
name|nontrivial_match
decl_stmt|;
block|{
name|char
name|temp_string
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|int
name|temp_string_index
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|temp_string_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quote_char
operator|&&
name|rl_point
operator|&&
name|rl_completion_suppress_quote
operator|==
literal|0
operator|&&
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
operator|!=
name|quote_char
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|quote_char
expr_stmt|;
if|if
condition|(
name|delimiter
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|delimiter
expr_stmt|;
elseif|else
if|if
condition|(
name|rl_completion_suppress_append
operator|==
literal|0
operator|&&
name|rl_completion_append_character
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|rl_completion_append_character
expr_stmt|;
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|nontrivial_match
operator|&&
name|rl_completion_mark_symlink_dirs
operator|==
literal|0
operator|)
condition|?
name|LSTAT
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
else|:
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_complete_mark_directories
comment|/*&& rl_completion_suppress_append == 0 */
condition|)
block|{
comment|/* This is clumsy.  Avoid putting in a double slash if point 		 is at the end of the line and the previous character is a 		 slash. */
if|if
condition|(
name|rl_point
operator|&&
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|==
literal|'\0'
operator|&&
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|'/'
condition|)
name|rl_insert_text
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|S_ISLNK
comment|/* Don't add anything if the filename is a symlink and resolves to a 	 directory. */
elseif|else
if|if
condition|(
name|s
operator|==
literal|0
operator|&&
name|S_ISLNK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|&&
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
empty_stmt|;
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|temp_string_index
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
operator|&&
name|temp_string_index
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp_string_index
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_all_matches
parameter_list|(
name|matches
parameter_list|,
name|point
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|int
name|point
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* remove any opening quote character; make_quoted_replacement will add      it back. */
if|if
condition|(
name|qc
operator|&&
operator|*
name|qc
operator|&&
name|point
operator|&&
name|rl_line_buffer
index|[
name|point
operator|-
literal|1
index|]
operator|==
operator|*
name|qc
condition|)
name|point
operator|--
expr_stmt|;
name|rl_delete_text
argument_list|(
name|point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|make_quoted_replacement
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|SINGLE_MATCH
argument_list|,
name|qc
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|matches
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rp
operator|=
name|make_quoted_replacement
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|SINGLE_MATCH
argument_list|,
name|qc
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|matches
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_free_match_list
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complete the word at or before point.    WHAT_TO_DO says what to do with the completion.    `?' means list the possible completions.    TAB means do standard completion.    `*' means insert all of the possible completions.    `!' means to do standard completion, and list all possible completions if    there is more than one.    `@' means to do standard completion, and list all possible completions if    there is more than one and partial completion is not possible. */
end_comment

begin_function
name|int
name|rl_complete_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|rl_compentry_func_t
modifier|*
name|our_func
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|delimiter
decl_stmt|,
name|found_quote
decl_stmt|,
name|i
decl_stmt|,
name|nontrivial_lcd
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|,
modifier|*
name|saved_line_buffer
decl_stmt|;
name|char
name|quote_char
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_COMPLETING
argument_list|)
expr_stmt|;
name|set_completion_defaults
argument_list|(
name|what_to_do
argument_list|)
expr_stmt|;
name|saved_line_buffer
operator|=
name|rl_line_buffer
condition|?
name|savestring
argument_list|(
name|rl_line_buffer
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|our_func
operator|=
name|rl_completion_entry_function
condition|?
name|rl_completion_entry_function
else|:
name|rl_filename_completion_function
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
comment|/* This (possibly) changes rl_point.  If it returns a non-zero char,        we know we have an open quote. */
name|quote_char
operator|=
name|_rl_find_completion_word
argument_list|(
operator|&
name|found_quote
argument_list|,
operator|&
name|delimiter
argument_list|)
expr_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
name|text
operator|=
name|rl_copy_text
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|matches
operator|=
name|gen_completion_matches
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|our_func
argument_list|,
name|found_quote
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
comment|/* nontrivial_lcd is set if the common prefix adds something to the word      being completed. */
name|nontrivial_lcd
operator|=
name|matches
operator|&&
name|strcmp
argument_list|(
name|text
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_COMPLETING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If we are matching filenames, the attempted completion function will      have set rl_filename_completion_desired to a non-zero value.  The basic      rl_filename_completion_function does this. */
name|i
operator|=
name|rl_filename_completion_desired
expr_stmt|;
if|if
condition|(
name|postprocess_matches
argument_list|(
operator|&
name|matches
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_COMPLETING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|what_to_do
condition|)
block|{
case|case
name|TAB
case|:
case|case
literal|'!'
case|:
case|case
literal|'@'
case|:
comment|/* Insert the first match with proper quoting. */
if|if
condition|(
operator|*
name|matches
index|[
literal|0
index|]
condition|)
name|insert_match
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|start
argument_list|,
name|matches
index|[
literal|1
index|]
condition|?
name|MULT_MATCH
else|:
name|SINGLE_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
comment|/* If there are more matches, ring the bell to indicate. 	 If we are in vi mode, Posix.2 says to not ring the bell. 	 If the `show-all-if-ambiguous' variable is set, display 	 all the matches immediately.  Otherwise, if this was the 	 only match, and we are hacking files, check the file to 	 see if it was a directory.  If so, and the `mark-directories' 	 variable is set, add a '/' to the name.  If not, and we 	 are at the end of the line, then add a space.  */
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|what_to_do
operator|==
literal|'!'
condition|)
block|{
name|display_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|what_to_do
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|nontrivial_lcd
operator|==
literal|0
condition|)
name|display_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
name|rl_ding
argument_list|()
expr_stmt|;
comment|/* There are other matches remaining. */
block|}
else|else
name|append_to_match
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|delimiter
argument_list|,
name|quote_char
argument_list|,
name|nontrivial_lcd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|insert_all_matches
argument_list|(
name|matches
argument_list|,
name|start
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|display_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nreadline: bad value %d for what_to_do in rl_complete\n"
argument_list|,
name|what_to_do
argument_list|)
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_COMPLETING
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|_rl_free_match_list
argument_list|(
name|matches
argument_list|)
expr_stmt|;
comment|/* Check to see if the line has changed through all of this manipulation. */
if|if
condition|(
name|saved_line_buffer
condition|)
block|{
name|completion_changed_buffer
operator|=
name|strcmp
argument_list|(
name|rl_line_buffer
argument_list|,
name|saved_line_buffer
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|free
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
block|}
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_COMPLETING
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************************/
end_comment

begin_comment
comment|/*							       */
end_comment

begin_comment
comment|/*  Application-callable completion match generator functions  */
end_comment

begin_comment
comment|/*							       */
end_comment

begin_comment
comment|/***************************************************************/
end_comment

begin_comment
comment|/* Return an array of (char *) which is a list of completions for TEXT.    If there are no completions, return a NULL pointer.    The first entry in the returned array is the substitution for TEXT.    The remaining entries are the possible completions.    The array is terminated with a NULL pointer.     ENTRY_FUNCTION is a function of two args, and returns a (char *).      The first argument is TEXT.      The second is a state argument; it should be zero on the first call, and      non-zero on subsequent calls.  It returns a NULL pointer to the caller      when there are no more matches.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|rl_completion_matches
parameter_list|(
name|text
parameter_list|,
name|entry_function
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|rl_compentry_func_t
modifier|*
name|entry_function
decl_stmt|;
block|{
comment|/* Number of slots in match_list. */
name|int
name|match_list_size
decl_stmt|;
comment|/* The list of matches. */
name|char
modifier|*
modifier|*
name|match_list
decl_stmt|;
comment|/* Number of matches actually found. */
name|int
name|matches
decl_stmt|;
comment|/* Temporary string binder. */
name|char
modifier|*
name|string
decl_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
name|match_list_size
operator|=
literal|10
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|match_list_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|string
operator|=
call|(
modifier|*
name|entry_function
call|)
argument_list|(
name|text
argument_list|,
name|matches
argument_list|)
condition|)
block|{
if|if
condition|(
name|matches
operator|+
literal|1
operator|==
name|match_list_size
condition|)
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|match_list
argument_list|,
operator|(
operator|(
name|match_list_size
operator|+=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
operator|++
name|matches
index|]
operator|=
name|string
expr_stmt|;
name|match_list
index|[
name|matches
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were any matches, then look through them finding out the      lowest common denominator.  That then becomes match_list[0]. */
if|if
condition|(
name|matches
condition|)
name|compute_lcd_of_matches
argument_list|(
name|match_list
argument_list|,
name|matches
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
comment|/* There were no matches. */
block|{
name|free
argument_list|(
name|match_list
argument_list|)
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|match_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A completion function for usernames.    TEXT contains a partial username preceded by a random    character (usually `~').  */
end_comment

begin_function
name|char
modifier|*
name|rl_username_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OPENNT
argument_list|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|#
directive|else
comment|/* !__WIN32__&& !__OPENNT) */
specifier|static
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|struct
name|passwd
modifier|*
name|entry
decl_stmt|;
specifier|static
name|int
name|namelen
decl_stmt|,
name|first_char
decl_stmt|,
name|first_char_loc
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|first_char
operator|=
operator|*
name|text
expr_stmt|;
name|first_char_loc
operator|=
name|first_char
operator|==
literal|'~'
expr_stmt|;
name|username
operator|=
name|savestring
argument_list|(
operator|&
name|text
index|[
name|first_char_loc
index|]
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWENT
argument_list|)
while|while
condition|(
name|entry
operator|=
name|getpwent
argument_list|()
condition|)
block|{
comment|/* Null usernames should result in all users as possible completions. */
if|if
condition|(
name|namelen
operator|==
literal|0
operator|||
operator|(
name|STREQN
argument_list|(
name|username
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|,
name|namelen
argument_list|)
operator|)
condition|)
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWENT
argument_list|)
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
operator|*
name|text
expr_stmt|;
name|strcpy
argument_list|(
name|value
operator|+
name|first_char_loc
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'~'
condition|)
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !__WIN32__&& !__OPENNT */
block|}
end_function

begin_comment
comment|/* Okay, now we write the entry_function for filename completion.  In the    general case.  Note that completion in the shell is a little different    because of all the pathnames that must be followed when looking up the    completion for a command. */
end_comment

begin_function
name|char
modifier|*
name|rl_filename_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
specifier|static
name|DIR
modifier|*
name|directory
init|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|users_dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|filename_len
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|dirlen
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
decl_stmt|;
comment|/* If we don't have any state, then do some initialization. */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
comment|/* If we were interrupted before closing the directory or reading 	 all of its contents, close it. */
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|FREE
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|==
literal|0
condition|)
name|text
operator|=
literal|"."
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|dirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
comment|/* special hack for //X/... */
if|if
condition|(
name|dirname
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dirname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|dirname
index|[
literal|2
index|]
argument_list|)
operator|&&
name|dirname
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
name|temp
operator|=
name|strrchr
argument_list|(
name|dirname
operator|+
literal|3
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
operator|++
name|temp
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
comment|/* searches from current directory on the drive */
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|dirname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|dirname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dirname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|dirname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dirname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* We aren't done yet.  We also support the "~user" syntax. */
comment|/* Save the version of the directory that the user typed. */
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
operator|==
literal|'~'
condition|)
block|{
name|temp
operator|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|rl_directory_rewrite_hook
condition|)
call|(
modifier|*
name|rl_directory_rewrite_hook
call|)
argument_list|(
operator|&
name|dirname
argument_list|)
expr_stmt|;
comment|/* The directory completion hook should perform any necessary 	 dequoting. */
if|if
condition|(
name|rl_directory_completion_hook
operator|&&
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|dirname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_completion_found_quote
operator|&&
name|rl_filename_dequoting_function
condition|)
block|{
comment|/* delete single and double quotes */
name|temp
operator|=
call|(
modifier|*
name|rl_filename_dequoting_function
call|)
argument_list|(
name|users_dirname
argument_list|,
name|rl_completion_quote_character
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
name|temp
expr_stmt|;
block|}
name|directory
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
comment|/* Now dequote a non-null filename. */
if|if
condition|(
name|filename
operator|&&
operator|*
name|filename
operator|&&
name|rl_completion_found_quote
operator|&&
name|rl_filename_dequoting_function
condition|)
block|{
comment|/* delete single and double quotes */
name|temp
operator|=
call|(
modifier|*
name|rl_filename_dequoting_function
call|)
argument_list|(
name|filename
argument_list|,
name|rl_completion_quote_character
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|temp
expr_stmt|;
block|}
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At this point we should entertain the possibility of hacking wildcarded      filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name      contains globbing characters, then build an array of directories, and      then map over that list while completing. */
comment|/* *** UNIMPLEMENTED *** */
comment|/* Now that we have some state, we can read the directory. */
name|entry
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|directory
operator|&&
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|directory
argument_list|)
operator|)
condition|)
block|{
comment|/* Special case for no filename.  If the user has disabled the          `match-hidden-files' variable, skip filenames beginning with `.'. 	 All other entries except "." and ".." match. */
if|if
condition|(
name|filename_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|_rl_match_hidden_files
operator|==
literal|0
operator|&&
name|HIDDEN_FILE
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|entry
operator|->
name|d_name
index|[
literal|1
index|]
operator|&&
operator|(
name|entry
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|entry
operator|->
name|d_name
index|[
literal|2
index|]
operator|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Otherwise, if these match up to the length of filename, then 	     it is a match. */
if|if
condition|(
name|_rl_completion_case_fold
condition|)
block|{
if|if
condition|(
operator|(
name|_rl_to_lower
argument_list|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
operator|==
name|_rl_to_lower
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
operator|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|_rl_strnicmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|filename
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
operator|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dirname
condition|)
block|{
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|users_dirname
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
comment|/* dirname&& (strcmp (dirname, ".") != 0) */
if|if
condition|(
name|dirname
operator|&&
operator|(
name|dirname
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dirname
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|rl_complete_with_tilde_expansion
operator|&&
operator|*
name|users_dirname
operator|==
literal|'~'
condition|)
block|{
name|dirlen
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|dirlen
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
comment|/* Canonicalization cuts off any final slash present.  We 		 may need to add it back. */
if|if
condition|(
name|dirname
index|[
name|dirlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
index|[
name|dirlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|dirlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|dirlen
operator|=
name|strlen
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|dirlen
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|users_dirname
argument_list|)
expr_stmt|;
comment|/* Make sure that temp has a trailing slash here. */
if|if
condition|(
name|users_dirname
index|[
name|dirlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp
index|[
name|dirlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|temp
operator|+
name|dirlen
argument_list|,
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|savestring
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* An initial implementation of a menu completion function a la tcsh.  The    first time (if the last readline command was not rl_menu_complete), we    generate the list of matches.  This code is very similar to the code in    rl_complete_internal -- there should be a way to combine the two.  Then,    for each item in the list of matches, we insert the match in an undoable    fashion, with the appropriate character appended (this happens on the    second and subsequent consecutive calls to rl_menu_complete).  When we    hit the end of the match list, we restore the original unmatched text,    ring the bell, and reset the counter to zero. */
end_comment

begin_function
name|int
name|rl_menu_complete
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|rl_compentry_func_t
modifier|*
name|our_func
decl_stmt|;
name|int
name|matching_filenames
decl_stmt|,
name|found_quote
decl_stmt|;
specifier|static
name|char
modifier|*
name|orig_text
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|matches
init|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|int
name|match_list_index
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|match_list_size
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|orig_start
decl_stmt|,
name|orig_end
decl_stmt|;
specifier|static
name|char
name|quote_char
decl_stmt|;
specifier|static
name|int
name|delimiter
decl_stmt|;
comment|/* The first time through, we generate the list of matches and set things      up to insert them. */
if|if
condition|(
name|rl_last_func
operator|!=
name|rl_menu_complete
condition|)
block|{
comment|/* Clean up from previous call, if any. */
name|FREE
argument_list|(
name|orig_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
condition|)
name|_rl_free_match_list
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|match_list_index
operator|=
name|match_list_size
operator|=
literal|0
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Only the completion entry function can change these. */
name|set_completion_defaults
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
name|our_func
operator|=
name|rl_completion_entry_function
condition|?
name|rl_completion_entry_function
else|:
name|rl_filename_completion_function
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|orig_end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
comment|/* This (possibly) changes rl_point.  If it returns a non-zero char, 	   we know we have an open quote. */
name|quote_char
operator|=
name|_rl_find_completion_word
argument_list|(
operator|&
name|found_quote
argument_list|,
operator|&
name|delimiter
argument_list|)
expr_stmt|;
name|orig_start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|orig_end
expr_stmt|;
name|orig_text
operator|=
name|rl_copy_text
argument_list|(
name|orig_start
argument_list|,
name|orig_end
argument_list|)
expr_stmt|;
name|matches
operator|=
name|gen_completion_matches
argument_list|(
name|orig_text
argument_list|,
name|orig_start
argument_list|,
name|orig_end
argument_list|,
name|our_func
argument_list|,
name|found_quote
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
comment|/* If we are matching filenames, the attempted completion function will 	 have set rl_filename_completion_desired to a non-zero value.  The basic 	 rl_filename_completion_function does this. */
name|matching_filenames
operator|=
name|rl_filename_completion_desired
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|postprocess_matches
argument_list|(
operator|&
name|matches
argument_list|,
name|matching_filenames
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|orig_text
argument_list|)
expr_stmt|;
name|orig_text
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|match_list_size
operator|=
literal|0
init|;
name|matches
index|[
name|match_list_size
index|]
condition|;
name|match_list_size
operator|++
control|)
empty_stmt|;
comment|/* matches[0] is lcd if match_list_size> 1, but the circular buffer 	 code below should take care of it. */
block|}
comment|/* Now we have the list of matches.  Replace the text between      rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with      matches[match_list_index], and add any necessary closing char. */
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|match_list_size
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|match_list_index
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|match_list_index
operator|<
literal|0
condition|)
name|match_list_index
operator|+=
name|match_list_size
expr_stmt|;
else|else
name|match_list_index
operator|%=
name|match_list_size
expr_stmt|;
if|if
condition|(
name|match_list_index
operator|==
literal|0
operator|&&
name|match_list_size
operator|>
literal|1
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|insert_match
argument_list|(
name|orig_text
argument_list|,
name|orig_start
argument_list|,
name|MULT_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert_match
argument_list|(
name|matches
index|[
name|match_list_index
index|]
argument_list|,
name|orig_start
argument_list|,
name|SINGLE_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
name|append_to_match
argument_list|(
name|matches
index|[
name|match_list_index
index|]
argument_list|,
name|delimiter
argument_list|,
name|quote_char
argument_list|,
name|strcmp
argument_list|(
name|orig_text
argument_list|,
name|matches
index|[
name|match_list_index
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|completion_changed_buffer
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

