begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* complete.c -- filename completion for readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_GETPW_DECLS
argument_list|)
end_if

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !HAVE_GETPW_DECLS */
end_comment

begin_comment
comment|/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|isc386
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* isc386&& _POSIX_SOURCE */
end_comment

begin_include
include|#
directive|include
file|"posixdir.h"
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|int
name|QSFUNC
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|QSFUNC
parameter_list|()
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing a word would normally display the list of possible matches.    This function is called instead of actually doing the display.    It takes three arguments: (char **matches, int num_matches, int max_length)    where MATCHES is the array of strings that matched, NUM_MATCHES is the    number of strings in that array, and MAX_LENGTH is the length of the    longest string in that array. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|rl_completion_display_matches_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined and used in this file. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|filename_completion_function
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|completion_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CPFunction
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|X_OK
argument_list|)
end_if

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|stat_char
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rl_quote_filename
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rl_strpbrk
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|remove_duplicate_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_match
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|append_to_match
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_all_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_lcd_of_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	Completion matching, from readline's point of view.	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Variables known only to the readline library. */
end_comment

begin_comment
comment|/* If non-zero, non-unique completions always show the list of matches. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_show_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, completed directory names have a slash appended. */
end_comment

begin_decl_stmt
name|int
name|_rl_complete_mark_directories
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, completions are printed horizontally in alphabetical order,    like `ls -x'. */
end_comment

begin_decl_stmt
name|int
name|_rl_print_completions_horizontally
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that case is not significant in filename completion. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
end_if

begin_decl_stmt
name|int
name|_rl_completion_case_fold
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|_rl_completion_case_fold
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variables available to applications using readline. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_comment
comment|/* Non-zero means add an additional character to each filename displayed    during listing completion iff rl_filename_completion_desired which helps    to indicate the type of file being listed. */
end_comment

begin_decl_stmt
name|int
name|rl_visible_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing on a directory name.  The function is called with    the address of a string (the current directory name) as an arg. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_directory_completion_hook
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means readline completion functions perform tilde expansion. */
end_comment

begin_decl_stmt
name|int
name|rl_complete_with_tilde_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use filename_completion_function (), the default filename    completer. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_completion_entry_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
end_comment

begin_decl_stmt
name|CPPFunction
modifier|*
name|rl_attempted_completion_function
init|=
operator|(
name|CPPFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to suppress normal filename completion after the    user-specified completion function has been called. */
end_comment

begin_decl_stmt
name|int
name|rl_attempted_completion_over
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a character indicating the type of completion being performed    by rl_complete_internal, available for use by application completion    functions. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if    she is sure she wants to see them all. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The contents of this variable is what breaks words    in the shell, i.e. " \t\n\"\\'`@$><=" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
literal|" \t\n\"\\'`@$><=;|&{("
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of basic quoting characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_basic_quote_characters
init|=
literal|"\"'"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters which can be used to quote a substring of the line.    Completion occurs on the entire substring, and within the substring    rl_completer_word_break_characters are treated as any other character,    unless they also appear within this list. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_completer_quote_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that should be quoted in filenames by the completer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_filename_quote_characters
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_special_prefixes
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then disallow duplicates in the matches. */
end_comment

begin_decl_stmt
name|int
name|rl_ignore_completion_duplicates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_completion_desired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be quoted using    double quotes (or an application-specific quoting mechanism) if the    filename contains any characters in rl_filename_quote_chars.  This is    ALWAYS non-zero on entry, and can only be changed within a completion    entry finder function. */
end_comment

begin_decl_stmt
name|int
name|rl_filename_quoting_desired
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function, if defined, is called by the completer when real    filename completion is done, after all the matching names have been    generated. It is passed a (char**) known as matches in the code below.    It consists of a NULL-terminated array of pointers to potential    matching strings.  The 1st element (matches[0]) is the maximal    substring that is common to all matches. This function can re-arrange    the list of matches as required, but all elements of the array must be    free()'d if they are deleted. The main intent of this function is    to implement FIGNORE a la SunOS csh. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_ignore_some_completions_function
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a function to quote a filename in an application-specific fashion.    Called with the text to quote, the type of match found (single or multiple)    and a pointer to the quoting character to be used, which the function can    reset if desired. */
end_comment

begin_decl_stmt
name|CPFunction
modifier|*
name|rl_filename_quoting_function
init|=
name|rl_quote_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to remove quoting characters from a filename.  Called    before completion is attempted, so the embedded quotes do not interfere    with matching names in the file system.  Readline doesn't do anything    with this; it's set only by applications. */
end_comment

begin_decl_stmt
name|CPFunction
modifier|*
name|rl_filename_dequoting_function
init|=
operator|(
name|CPFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to decide whether or not a word break character is    quoted.  If a character is quoted, it does not break words for the    completer. */
end_comment

begin_decl_stmt
name|Function
modifier|*
name|rl_char_is_quoted_p
init|=
operator|(
name|Function
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character appended to completed words when at the end of the line.  The    default is a space. */
end_comment

begin_decl_stmt
name|int
name|rl_completion_append_character
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, inhibit completion (temporarily). */
end_comment

begin_decl_stmt
name|int
name|rl_inhibit_completion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables local to this file. */
end_comment

begin_comment
comment|/* Local variable states what happened during the last completion attempt. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|completion_changed_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/*				     */
end_comment

begin_comment
comment|/*    Bindable completion functions  */
end_comment

begin_comment
comment|/*				     */
end_comment

begin_comment
comment|/*************************************/
end_comment

begin_comment
comment|/* Complete the word at or before point.  You have supplied the function    that does the initial simple matching selection algorithm (see    completion_matches ()).  The default is to do filename completion. */
end_comment

begin_function
name|int
name|rl_complete
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
if|if
condition|(
name|rl_inhibit_completion
condition|)
return|return
operator|(
name|rl_insert
argument_list|(
name|ignore
argument_list|,
name|invoking_key
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|rl_last_func
operator|==
name|rl_complete
operator|&&
operator|!
name|completion_changed_buffer
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_all
condition|)
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'!'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* List the possible completions.  See description of rl_complete (). */
end_comment

begin_function
name|int
name|rl_possible_completions
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_insert_completions
parameter_list|(
name|ignore
parameter_list|,
name|invoking_key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|invoking_key
decl_stmt|;
block|{
return|return
operator|(
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************/
end_comment

begin_comment
comment|/*				    */
end_comment

begin_comment
comment|/*    Completion utility functions  */
end_comment

begin_comment
comment|/*				    */
end_comment

begin_comment
comment|/************************************/
end_comment

begin_comment
comment|/* Find the first occurrence in STRING1 of any character from STRING2.    Return a pointer to the character in STRING1. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|rl_strpbrk
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
init|;
operator|*
name|string1
condition|;
name|string1
operator|++
control|)
block|{
for|for
control|(
name|scan
operator|=
name|string2
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|string1
operator|==
operator|*
name|scan
condition|)
block|{
return|return
operator|(
name|string1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* The user must press "y" or "n". Non-zero return means "y" pressed. */
end_comment

begin_function
specifier|static
name|int
name|get_y_or_n
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
literal|'N'
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|ABORT_CHAR
condition|)
name|_rl_abort_internal
argument_list|()
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
end_if

begin_comment
comment|/* Return the character which best describes FILENAME.      `@' for symbolic links      `/' for directories      `*' for executables      `=' for sockets      `|' for FIFOs      `%' for character special devices      `#' for block special devices */
end_comment

begin_function
specifier|static
name|int
name|stat_char
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|character
decl_stmt|,
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LSTAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
name|r
operator|=
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|character
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'/'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|S_ISCHR
argument_list|)
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'%'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISCHR */
if|#
directive|if
name|defined
argument_list|(
name|S_ISBLK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'#'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISBLK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'@'
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISLNK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISSOCK
argument_list|)
elseif|else
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'='
expr_stmt|;
endif|#
directive|endif
comment|/* S_ISSOCK */
if|#
directive|if
name|defined
argument_list|(
name|S_ISFIFO
argument_list|)
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
name|character
operator|=
literal|'|'
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|character
operator|=
literal|'*'
expr_stmt|;
block|}
return|return
operator|(
name|character
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISIBLE_STATS */
end_comment

begin_comment
comment|/* Return the portion of PATHNAME that should be output when listing    possible completions.  If we are hacking filename completion, we    are only interested in the basename, the portion following the    final slash.  Otherwise, we return what we were passed. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|printable_part
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|rl_filename_completion_desired
condition|?
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|temp
operator|==
literal|0
operator|&&
name|isalpha
argument_list|(
name|pathname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|pathname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|temp
operator|=
name|pathname
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|temp
condition|?
operator|++
name|temp
else|:
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output TO_PRINT to rl_outstream.  If VISIBLE_STATS is defined and we    are using it, check for and output a single character for `special'    filenames.  Return the number of characters we output. */
end_comment

begin_define
define|#
directive|define
name|PUTX
parameter_list|(
name|c
parameter_list|)
define|\
value|do { \       if (CTRL_CHAR (c)) \         { \           putc ('^', rl_outstream); \           putc (UNCTRL (c), rl_outstream); \           printed_len += 2; \         } \       else if (c == RUBOUT) \ 	{ \ 	  putc ('^', rl_outstream); \ 	  putc ('?', rl_outstream); \ 	  printed_len += 2; \ 	} \       else \ 	{ \ 	  putc (c, rl_outstream); \ 	  printed_len++; \ 	} \     } while (0)
end_define

begin_function
specifier|static
name|int
name|print_filename
parameter_list|(
name|to_print
parameter_list|,
name|full_pathname
parameter_list|)
name|char
modifier|*
name|to_print
decl_stmt|,
decl|*
name|full_pathname
decl_stmt|;
end_function

begin_block
block|{
name|int
name|printed_len
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VISIBLE_STATS
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|to_print
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|PUTX
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|,
modifier|*
name|new_full_pathname
decl_stmt|;
name|int
name|extension_char
decl_stmt|,
name|slen
decl_stmt|,
name|tlen
decl_stmt|;
for|for
control|(
name|s
operator|=
name|to_print
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|PUTX
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rl_filename_completion_desired
operator|&&
name|rl_visible_stats
condition|)
block|{
comment|/* If to_print != full_pathname, to_print is the basename of the 	 path passed.  In this case, we try to expand the directory 	 name before checking for the stat character. */
if|if
condition|(
name|to_print
operator|!=
name|full_pathname
condition|)
block|{
comment|/* Terminate the directory name. */
name|c
operator|=
name|to_print
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If setting the last slash in full_pathname to a NUL results in 	     full_pathname being the empty string, we are trying to complete 	     files in the root directory.  If we pass a null string to the 	     bash directory completion hook, for example, it will expand it 	     to the current directory.  We just want the `/'. */
name|s
operator|=
name|tilde_expand
argument_list|(
name|full_pathname
operator|&&
operator|*
name|full_pathname
condition|?
name|full_pathname
else|:
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_directory_completion_hook
condition|)
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|strlen
argument_list|(
name|to_print
argument_list|)
expr_stmt|;
name|new_full_pathname
operator|=
name|xmalloc
argument_list|(
name|slen
operator|+
name|tlen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|new_full_pathname
index|[
name|slen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|new_full_pathname
operator|+
name|slen
operator|+
literal|1
argument_list|,
name|to_print
argument_list|)
expr_stmt|;
name|extension_char
operator|=
name|stat_char
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_full_pathname
argument_list|)
expr_stmt|;
name|to_print
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|tilde_expand
argument_list|(
name|full_pathname
argument_list|)
expr_stmt|;
name|extension_char
operator|=
name|stat_char
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_char
condition|)
block|{
name|putc
argument_list|(
name|extension_char
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|printed_len
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* VISIBLE_STATS */
return|return
name|printed_len
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|rl_quote_filename
parameter_list|(
name|s
parameter_list|,
name|rtype
parameter_list|,
name|qcp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|rtype
decl_stmt|;
name|char
modifier|*
name|qcp
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|rl_completer_quote_characters
expr_stmt|;
name|strcpy
argument_list|(
name|r
operator|+
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcp
condition|)
operator|*
name|qcp
operator|=
operator|*
name|rl_completer_quote_characters
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Find the bounds of the current word for completion purposes, and leave    rl_point set to the end of the word.  This function skips quoted    substrings (characters between matched pairs of characters in    rl_completer_quote_characters.  First we try to find an unclosed    quoted substring on which to do matching.  If one is not found, we use    the word break characters to find the boundaries of the current word.    We call an application-specific function to decide whether or not a    particular word break character is quoted; if that function returns a    non-zero result, the character does not break a word.  This function    returns the opening quote character if we found an unclosed quoted    substring, '\0' otherwise.  FP, if non-null, is set to a value saying    which (shell-like) quote characters we found (single quote, double    quote, or backslash) anywhere in the string.  DP, if non-null, is set to    the value of the delimiter character that caused a word break. */
end_comment

begin_function
specifier|static
name|char
name|find_completion_word
parameter_list|(
name|fp
parameter_list|,
name|dp
parameter_list|)
name|int
modifier|*
name|fp
decl_stmt|,
decl|*
name|dp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|scan
decl_stmt|,
name|end
decl_stmt|,
name|found_quote
decl_stmt|,
name|delimiter
decl_stmt|,
name|pass_next
decl_stmt|,
name|isbrk
decl_stmt|;
name|char
name|quote_char
decl_stmt|;
name|end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_completer_quote_characters
condition|)
block|{
comment|/* We have a list of characters which can be used in pairs to 	 quote substrings for the completer.  Try to find the start 	 of an unclosed quoted substring. */
comment|/* FOUND_QUOTE is set so we know what kind of quotes we found. */
for|for
control|(
name|scan
operator|=
name|pass_next
operator|=
literal|0
init|;
name|scan
operator|<
name|end
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|pass_next
condition|)
block|{
name|pass_next
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
literal|'\\'
condition|)
block|{
name|pass_next
operator|=
literal|1
expr_stmt|;
name|found_quote
operator||=
name|RL_QF_BACKSLASH
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char. */
if|if
condition|(
name|rl_line_buffer
index|[
name|scan
index|]
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close.  Abandon this substring. */
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_quote_characters
argument_list|,
name|rl_line_buffer
index|[
name|scan
index|]
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted substring. */
name|quote_char
operator|=
name|rl_line_buffer
index|[
name|scan
index|]
expr_stmt|;
name|rl_point
operator|=
name|scan
operator|+
literal|1
expr_stmt|;
comment|/* Shell-like quoting conventions. */
if|if
condition|(
name|quote_char
operator|==
literal|'\''
condition|)
name|found_quote
operator||=
name|RL_QF_SINGLE_QUOTE
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_char
operator|==
literal|'"'
condition|)
name|found_quote
operator||=
name|RL_QF_DOUBLE_QUOTE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rl_point
operator|==
name|end
operator|&&
name|quote_char
operator|==
literal|'\0'
condition|)
block|{
comment|/* We didn't find an unclosed quoted substring upon which to do          completion, so use the word break characters to find the          substring on which to complete. */
while|while
condition|(
operator|--
name|rl_point
condition|)
block|{
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Call the application-specific function to tell us whether 	     this word break character is quoted and should be skipped. */
if|if
condition|(
name|rl_char_is_quoted_p
operator|&&
name|found_quote
operator|&&
call|(
modifier|*
name|rl_char_is_quoted_p
call|)
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
condition|)
continue|continue;
comment|/* Convoluted code, but it avoids an n^2 algorithm with calls 	     to char_is_quoted. */
break|break;
block|}
block|}
comment|/* If we are at an unquoted word break, then advance past it. */
name|scan
operator|=
name|rl_line_buffer
index|[
name|rl_point
index|]
expr_stmt|;
comment|/* If there is an application-specific function to say whether or not      a character is quoted and we found a quote character, let that      function decide whether or not a character is a word break, even      if it is found in rl_completer_word_break_characters.  Don't bother      if we're at the end of the line, though. */
if|if
condition|(
name|scan
condition|)
block|{
if|if
condition|(
name|rl_char_is_quoted_p
condition|)
name|isbrk
operator|=
operator|(
name|found_quote
operator|==
literal|0
operator|||
call|(
modifier|*
name|rl_char_is_quoted_p
call|)
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
name|isbrk
operator|=
name|strchr
argument_list|(
name|rl_completer_word_break_characters
argument_list|,
name|scan
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|isbrk
condition|)
block|{
comment|/* If the character that caused the word break was a quoting 	     character, then remember it as the delimiter. */
if|if
condition|(
name|rl_basic_quote_characters
operator|&&
name|strchr
argument_list|(
name|rl_basic_quote_characters
argument_list|,
name|scan
argument_list|)
operator|&&
operator|(
name|end
operator|-
name|rl_point
operator|)
operator|>
literal|1
condition|)
name|delimiter
operator|=
name|scan
expr_stmt|;
comment|/* If the character isn't needed to determine something special 	     about what kind of completion to perform, then advance past it. */
if|if
condition|(
name|rl_special_prefixes
operator|==
literal|0
operator|||
name|strchr
argument_list|(
name|rl_special_prefixes
argument_list|,
name|scan
argument_list|)
operator|==
literal|0
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
condition|)
operator|*
name|fp
operator|=
name|found_quote
expr_stmt|;
if|if
condition|(
name|dp
condition|)
operator|*
name|dp
operator|=
name|delimiter
expr_stmt|;
return|return
operator|(
name|quote_char
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|gen_completion_matches
parameter_list|(
name|text
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|our_func
parameter_list|,
name|found_quote
parameter_list|,
name|quote_char
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|Function
modifier|*
name|our_func
decl_stmt|;
name|int
name|found_quote
decl_stmt|,
name|quote_char
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* If the user wants to TRY to complete, but then wants to give      up and use the default completion function, they set the      variable rl_attempted_completion_function. */
if|if
condition|(
name|rl_attempted_completion_function
condition|)
block|{
name|matches
operator|=
call|(
modifier|*
name|rl_attempted_completion_function
call|)
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|||
name|rl_attempted_completion_over
condition|)
block|{
name|rl_attempted_completion_over
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
block|}
comment|/* Beware -- we're stripping the quotes here.  Do this only if we know      we are doing filename completion and the application has defined a      filename dequoting function. */
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|found_quote
operator|&&
name|our_func
operator|==
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
operator|&&
name|rl_filename_dequoting_function
condition|)
block|{
comment|/* delete single and double quotes */
name|temp
operator|=
call|(
modifier|*
name|rl_filename_dequoting_function
call|)
argument_list|(
name|text
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
name|text
operator|=
name|temp
expr_stmt|;
comment|/* not freeing text is not a memory leak */
block|}
name|matches
operator|=
name|completion_matches
argument_list|(
name|text
argument_list|,
operator|(
name|CPFunction
operator|*
operator|)
name|our_func
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|matches
return|;
block|}
end_function

begin_comment
comment|/* Filter out duplicates in MATCHES.  This frees up the strings in    MATCHES. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|remove_duplicate_matches
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
name|char
modifier|*
name|lowest_common
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|newlen
decl_stmt|;
name|char
name|dead_slot
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp_array
decl_stmt|;
comment|/* Sort the items. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Sort the array without matches[0], since we need it to      stay in place no matter what. */
if|if
condition|(
name|i
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
comment|/* Remember the lowest common denominator for it may be unique. */
name|lowest_common
operator|=
name|savestring
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newlen
operator|=
literal|0
init|;
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|matches
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|matches
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
expr_stmt|;
block|}
else|else
name|newlen
operator|++
expr_stmt|;
block|}
comment|/* We have marked all the dead slots with (char *)&dead_slot.      Copy all the non-dead entries into a new array. */
name|temp_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|3
operator|+
name|newlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matches
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|temp_array
index|[
name|j
operator|++
index|]
operator|=
name|matches
index|[
name|i
index|]
expr_stmt|;
block|}
name|temp_array
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
operator|&
name|dead_slot
condition|)
name|free
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Place the lowest common denominator back in [0]. */
name|temp_array
index|[
literal|0
index|]
operator|=
name|lowest_common
expr_stmt|;
comment|/* If there is one string left, and it is identical to the      lowest common denominator, then the LCD is the string to      insert. */
if|if
condition|(
name|j
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|temp_array
index|[
literal|0
index|]
argument_list|,
name|temp_array
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temp_array
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|temp_array
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|temp_array
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the common prefix of the list of matches, and put it into    matches[0]. */
end_comment

begin_function
specifier|static
name|int
name|compute_lcd_of_matches
parameter_list|(
name|match_list
parameter_list|,
name|matches
parameter_list|,
name|text
parameter_list|)
name|char
modifier|*
modifier|*
name|match_list
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|si
decl_stmt|;
name|int
name|low
decl_stmt|;
comment|/* Count of max-matched characters. */
comment|/* If only one match, just use that.  Otherwise, compare each      member of the list with the next, finding out where they      stop matching. */
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|match_list
index|[
literal|1
index|]
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|low
operator|=
literal|100000
init|;
name|i
operator|<
name|matches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_rl_completion_case_fold
condition|)
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|_rl_to_lower
argument_list|(
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|c2
operator|=
name|_rl_to_lower
argument_list|(
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
argument_list|)
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
else|else
block|{
for|for
control|(
name|si
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|match_list
index|[
name|i
index|]
index|[
name|si
index|]
operator|)
operator|&&
operator|(
name|c2
operator|=
name|match_list
index|[
name|i
operator|+
literal|1
index|]
index|[
name|si
index|]
operator|)
condition|;
name|si
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|low
operator|>
name|si
condition|)
name|low
operator|=
name|si
expr_stmt|;
block|}
comment|/* If there were multiple matches, but none matched up to even the      first character, and the user typed something, use that as the      value of matches[0]. */
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
name|text
operator|&&
operator|*
name|text
condition|)
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|match_list
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
name|low
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|match_list
index|[
literal|0
index|]
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|0
index|]
index|[
name|low
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|matches
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|postprocess_matches
parameter_list|(
name|matchesp
parameter_list|,
name|matching_filenames
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|matchesp
decl_stmt|;
name|int
name|matching_filenames
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|matches
decl_stmt|,
modifier|*
modifier|*
name|temp_matches
decl_stmt|;
name|int
name|nmatch
decl_stmt|,
name|i
decl_stmt|;
name|matches
operator|=
operator|*
name|matchesp
expr_stmt|;
comment|/* It seems to me that in all the cases we handle we would like      to ignore duplicate possiblilities.  Scan for the text to      insert being identical to the other completions. */
if|if
condition|(
name|rl_ignore_completion_duplicates
condition|)
block|{
name|temp_matches
operator|=
name|remove_duplicate_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|temp_matches
expr_stmt|;
block|}
comment|/* If we are matching filenames, then here is our chance to      do clever processing by re-examining the list.  Call the      ignore function with the array as a parameter.  It can      munge the array, deleting matches as it desires. */
if|if
condition|(
name|rl_ignore_some_completions_function
operator|&&
name|matching_filenames
condition|)
block|{
for|for
control|(
name|nmatch
operator|=
literal|1
init|;
name|matches
index|[
name|nmatch
index|]
condition|;
name|nmatch
operator|++
control|)
empty_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|rl_ignore_some_completions_function
argument_list|)
argument_list|(
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|matches
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
operator|*
name|matchesp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If we removed some matches, recompute the common prefix. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|i
operator|<
name|nmatch
condition|)
block|{
name|t
operator|=
name|matches
index|[
literal|0
index|]
expr_stmt|;
name|compute_lcd_of_matches
argument_list|(
name|matches
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|matchesp
operator|=
name|matches
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A convenience function for displaying a list of strings in    columnar format on readline's output stream.  MATCHES is the list    of strings, in argv format, LEN is the number of strings in MATCHES,    and MAX is the length of the longest string in MATCHES. */
end_comment

begin_function
name|void
name|rl_display_match_list
parameter_list|(
name|matches
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|int
name|len
decl_stmt|,
name|max
decl_stmt|;
block|{
name|int
name|count
decl_stmt|,
name|limit
decl_stmt|,
name|printed_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* How many items of MAX length can we fit in the screen window? */
name|max
operator|+=
literal|2
expr_stmt|;
name|limit
operator|=
name|screenwidth
operator|/
name|max
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max
operator|==
name|screenwidth
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Avoid a possible floating exception.  If max> screenwidth,      limit will be 0 and a divide-by-zero fault will result. */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|len
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If LEN is less than LIMIT, then      just do the inner printing loop. 	   0< len<= limit  implies  count = 1. */
comment|/* Sort the items if they are not already sorted. */
if|if
condition|(
name|rl_ignore_completion_duplicates
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|matches
operator|+
literal|1
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|QSFUNC
operator|*
operator|)
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_print_completions_horizontally
operator|==
literal|0
condition|)
block|{
comment|/* Print the sorted items, up-and-down alphabetically, like ls. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>
name|len
operator|||
name|matches
index|[
name|l
index|]
operator|==
literal|0
condition|)
break|break;
else|else
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|l
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|limit
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|crlf
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Print the sorted items, across alphabetically, like ls -x. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printed_len
operator|=
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Have we reached the end of this line? */
if|if
condition|(
name|matches
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|&&
operator|(
name|limit
operator|>
literal|1
operator|)
operator|&&
operator|(
name|i
operator|%
name|limit
operator|)
operator|==
literal|0
condition|)
name|crlf
argument_list|()
expr_stmt|;
else|else
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max
operator|-
name|printed_len
condition|;
name|k
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
block|}
name|crlf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Display MATCHES, a list of matching filenames in argv format.  This    handles the simple case -- a single match -- first.  If there is more    than one match, we compute the number of strings in the list and the    length of the longest string, which will be needed by the display    function.  If the application wants to handle displaying the list of    matches itself, it sets RL_COMPLETION_DISPLAY_MATCHES_HOOK to the    address of a function, and we just call it.  If we're handling the    display ourselves, we just call rl_display_match_list.  We also check    that the list of matches doesn't exceed the user-settable threshold,    and ask the user if he wants to see the list if there are more matches    than RL_COMPLETION_QUERY_ITEMS. */
end_comment

begin_function
specifier|static
name|void
name|display_matches
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|max
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Move to the last visible line of a possibly-multiple-line command. */
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
comment|/* Handle simple case first.  What if there is only one answer? */
if|if
condition|(
name|matches
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|print_filename
argument_list|(
name|temp
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* There is more than one answer.  Find out how many there are,      and find the maximum printed length of a single entry. */
for|for
control|(
name|max
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|printable_part
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|max
condition|)
name|max
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* If the caller has defined a display hook, then call that now. */
if|if
condition|(
name|rl_completion_display_matches_hook
condition|)
block|{
call|(
modifier|*
name|rl_completion_display_matches_hook
call|)
argument_list|(
name|matches
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there are many items, then ask the user if she really wants to      see them all. */
if|if
condition|(
name|len
operator|>=
name|rl_completion_query_items
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"Display all %d possibilities? (y or n)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_y_or_n
argument_list|()
operator|==
literal|0
condition|)
block|{
name|crlf
argument_list|()
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|rl_display_match_list
argument_list|(
name|matches
argument_list|,
name|len
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_fixed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|make_quoted_replacement
parameter_list|(
name|match
parameter_list|,
name|mtype
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|mtype
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
comment|/* Pointer to quoting character, if any */
block|{
name|int
name|should_quote
decl_stmt|,
name|do_replace
decl_stmt|;
name|char
modifier|*
name|replacement
decl_stmt|;
comment|/* If we are doing completion on quoted substrings, and any matches      contain any of the completer_word_break_characters, then auto-      matically prepend the substring with a quote character (just pick      the first one from the list of such) if it does not already begin      with a quote string.  FIXME: Need to remove any such automatically      inserted quote character when it no longer is necessary, such as      if we change the string we are completing on and the new set of      matches don't require a quoted substring. */
name|replacement
operator|=
name|match
expr_stmt|;
name|should_quote
operator|=
name|match
operator|&&
name|rl_completer_quote_characters
operator|&&
name|rl_filename_completion_desired
operator|&&
name|rl_filename_quoting_desired
expr_stmt|;
if|if
condition|(
name|should_quote
condition|)
name|should_quote
operator|=
name|should_quote
operator|&&
operator|(
operator|!
name|qc
operator|||
operator|!
operator|*
name|qc
operator|||
operator|(
name|rl_completer_quote_characters
operator|&&
name|strchr
argument_list|(
name|rl_completer_quote_characters
argument_list|,
operator|*
name|qc
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|should_quote
condition|)
block|{
comment|/* If there is a single match, see if we need to quote it.          This also checks whether the common prefix of several 	 matches needs to be quoted. */
name|should_quote
operator|=
name|rl_filename_quote_characters
condition|?
operator|(
name|rl_strpbrk
argument_list|(
name|match
argument_list|,
name|rl_filename_quote_characters
argument_list|)
operator|!=
literal|0
operator|)
else|:
literal|0
expr_stmt|;
name|do_replace
operator|=
name|should_quote
condition|?
name|mtype
else|:
name|NO_MATCH
expr_stmt|;
comment|/* Quote the replacement, since we found an embedded 	 word break character in a potential match. */
if|if
condition|(
name|do_replace
operator|!=
name|NO_MATCH
operator|&&
name|rl_filename_quoting_function
condition|)
name|replacement
operator|=
call|(
modifier|*
name|rl_filename_quoting_function
call|)
argument_list|(
name|match
argument_list|,
name|do_replace
argument_list|,
name|qc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|replacement
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_match
parameter_list|(
name|match
parameter_list|,
name|start
parameter_list|,
name|mtype
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|;
name|int
name|start
decl_stmt|,
name|mtype
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
block|{
name|char
modifier|*
name|replacement
decl_stmt|;
name|char
name|oqc
decl_stmt|;
name|oqc
operator|=
name|qc
condition|?
operator|*
name|qc
else|:
literal|'\0'
expr_stmt|;
name|replacement
operator|=
name|make_quoted_replacement
argument_list|(
name|match
argument_list|,
name|mtype
argument_list|,
name|qc
argument_list|)
expr_stmt|;
comment|/* Now insert the match. */
if|if
condition|(
name|replacement
condition|)
block|{
comment|/* Don't double an opening quote character. */
if|if
condition|(
name|qc
operator|&&
operator|*
name|qc
operator|&&
name|start
operator|&&
name|rl_line_buffer
index|[
name|start
operator|-
literal|1
index|]
operator|==
operator|*
name|qc
operator|&&
name|replacement
index|[
literal|0
index|]
operator|==
operator|*
name|qc
condition|)
name|start
operator|--
expr_stmt|;
comment|/* If make_quoted_replacement changed the quoting character, remove 	 the opening quote and insert the (fully-quoted) replacement. */
elseif|else
if|if
condition|(
name|qc
operator|&&
operator|(
operator|*
name|qc
operator|!=
name|oqc
operator|)
operator|&&
name|start
operator|&&
name|rl_line_buffer
index|[
name|start
operator|-
literal|1
index|]
operator|==
name|oqc
operator|&&
name|replacement
index|[
literal|0
index|]
operator|!=
name|oqc
condition|)
name|start
operator|--
expr_stmt|;
name|_rl_replace_text
argument_list|(
name|replacement
argument_list|,
name|start
argument_list|,
name|rl_point
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|match
condition|)
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append any necessary closing quote and a separator character to the    just-inserted match.  If the user has specified that directories    should be marked by a trailing `/', append one of those instead.  The    default trailing character is a space.  Returns the number of characters    appended. */
end_comment

begin_function
specifier|static
name|int
name|append_to_match
parameter_list|(
name|text
parameter_list|,
name|delimiter
parameter_list|,
name|quote_char
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|quote_char
decl_stmt|;
block|{
name|char
name|temp_string
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|int
name|temp_string_index
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|temp_string_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|quote_char
operator|&&
name|rl_point
operator|&&
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
operator|!=
name|quote_char
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|quote_char
expr_stmt|;
if|if
condition|(
name|delimiter
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|delimiter
expr_stmt|;
elseif|else
if|if
condition|(
name|rl_completion_append_character
condition|)
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
name|rl_completion_append_character
expr_stmt|;
name|temp_string
index|[
name|temp_string_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_filename_completion_desired
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_complete_mark_directories
operator|&&
name|rl_line_buffer
index|[
name|rl_point
index|]
operator|!=
literal|'/'
condition|)
name|rl_insert_text
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_insert_text
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp_string_index
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_all_matches
parameter_list|(
name|matches
parameter_list|,
name|point
parameter_list|,
name|qc
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|int
name|point
decl_stmt|;
name|char
modifier|*
name|qc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* remove any opening quote character; make_quoted_replacement will add      it back. */
if|if
condition|(
name|qc
operator|&&
operator|*
name|qc
operator|&&
name|point
operator|&&
name|rl_line_buffer
index|[
name|point
operator|-
literal|1
index|]
operator|==
operator|*
name|qc
condition|)
name|point
operator|--
expr_stmt|;
name|rl_delete_text
argument_list|(
name|point
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|point
expr_stmt|;
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|make_quoted_replacement
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|,
name|SINGLE_MATCH
argument_list|,
name|qc
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|matches
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rp
operator|=
name|make_quoted_replacement
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|SINGLE_MATCH
argument_list|,
name|qc
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rl_insert_text
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|matches
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_match_list
parameter_list|(
name|matches
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complete the word at or before point.    WHAT_TO_DO says what to do with the completion.    `?' means list the possible completions.    TAB means do standard completion.    `*' means insert all of the possible completions.    `!' means to do standard completion, and list all possible completions if    there is more than one. */
end_comment

begin_function
name|int
name|rl_complete_internal
parameter_list|(
name|what_to_do
parameter_list|)
name|int
name|what_to_do
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|Function
modifier|*
name|our_func
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|delimiter
decl_stmt|,
name|found_quote
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|,
modifier|*
name|saved_line_buffer
decl_stmt|;
name|char
name|quote_char
decl_stmt|;
comment|/* Only the completion entry function can change these. */
name|rl_filename_completion_desired
operator|=
literal|0
expr_stmt|;
name|rl_filename_quoting_desired
operator|=
literal|1
expr_stmt|;
name|rl_completion_type
operator|=
name|what_to_do
expr_stmt|;
name|saved_line_buffer
operator|=
name|rl_line_buffer
condition|?
name|savestring
argument_list|(
name|rl_line_buffer
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|our_func
operator|=
name|rl_completion_entry_function
condition|?
name|rl_completion_entry_function
else|:
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
comment|/* This (possibly) changes rl_point.  If it returns a non-zero char,        we know we have an open quote. */
name|quote_char
operator|=
name|find_completion_word
argument_list|(
operator|&
name|found_quote
argument_list|,
operator|&
name|delimiter
argument_list|)
expr_stmt|;
name|start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|end
expr_stmt|;
name|text
operator|=
name|rl_copy_text
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|matches
operator|=
name|gen_completion_matches
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|our_func
argument_list|,
name|found_quote
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* If we are matching filenames, our_func will have been set to      filename_completion_function */
block|i = our_func == (Function *)filename_completion_function;
else|#
directive|else
comment|/* If we are matching filenames, the attempted completion function will      have set rl_filename_completion_desired to a non-zero value.  The basic      filename_completion_function does this. */
name|i
operator|=
name|rl_filename_completion_desired
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|postprocess_matches
argument_list|(
operator|&
name|matches
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|what_to_do
condition|)
block|{
case|case
name|TAB
case|:
case|case
literal|'!'
case|:
comment|/* Insert the first match with proper quoting. */
if|if
condition|(
operator|*
name|matches
index|[
literal|0
index|]
condition|)
name|insert_match
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|start
argument_list|,
name|matches
index|[
literal|1
index|]
condition|?
name|MULT_MATCH
else|:
name|SINGLE_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
comment|/* If there are more matches, ring the bell to indicate. 	 If we are in vi mode, Posix.2 says to not ring the bell. 	 If the `show-all-if-ambiguous' variable is set, display 	 all the matches immediately.  Otherwise, if this was the 	 only match, and we are hacking files, check the file to 	 see if it was a directory.  If so, and the `mark-directories' 	 variable is set, add a '/' to the name.  If not, and we 	 are at the end of the line, then add a space.  */
if|if
condition|(
name|matches
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|what_to_do
operator|==
literal|'!'
condition|)
block|{
name|display_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
name|ding
argument_list|()
expr_stmt|;
comment|/* There are other matches remaining. */
block|}
else|else
name|append_to_match
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|delimiter
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|insert_all_matches
argument_list|(
name|matches
argument_list|,
name|start
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|display_matches
argument_list|(
name|matches
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r\nreadline: bad value %d for what_to_do in rl_complete\n"
argument_list|,
name|what_to_do
argument_list|)
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free_match_list
argument_list|(
name|matches
argument_list|)
expr_stmt|;
comment|/* Check to see if the line has changed through all of this manipulation. */
if|if
condition|(
name|saved_line_buffer
condition|)
block|{
name|completion_changed_buffer
operator|=
name|strcmp
argument_list|(
name|rl_line_buffer
argument_list|,
name|saved_line_buffer
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|free
argument_list|(
name|saved_line_buffer
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************************/
end_comment

begin_comment
comment|/*							       */
end_comment

begin_comment
comment|/*  Application-callable completion match generator functions  */
end_comment

begin_comment
comment|/*							       */
end_comment

begin_comment
comment|/***************************************************************/
end_comment

begin_comment
comment|/* Return an array of (char *) which is a list of completions for TEXT.    If there are no completions, return a NULL pointer.    The first entry in the returned array is the substitution for TEXT.    The remaining entries are the possible completions.    The array is terminated with a NULL pointer.     ENTRY_FUNCTION is a function of two args, and returns a (char *).      The first argument is TEXT.      The second is a state argument; it should be zero on the first call, and      non-zero on subsequent calls.  It returns a NULL pointer to the caller      when there are no more matches.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|completion_matches
parameter_list|(
name|text
parameter_list|,
name|entry_function
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|CPFunction
modifier|*
name|entry_function
decl_stmt|;
block|{
comment|/* Number of slots in match_list. */
name|int
name|match_list_size
decl_stmt|;
comment|/* The list of matches. */
name|char
modifier|*
modifier|*
name|match_list
decl_stmt|;
comment|/* Number of matches actually found. */
name|int
name|matches
decl_stmt|;
comment|/* Temporary string binder. */
name|char
modifier|*
name|string
decl_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
name|match_list_size
operator|=
literal|10
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|match_list_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|string
operator|=
call|(
modifier|*
name|entry_function
call|)
argument_list|(
name|text
argument_list|,
name|matches
argument_list|)
condition|)
block|{
if|if
condition|(
name|matches
operator|+
literal|1
operator|==
name|match_list_size
condition|)
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|match_list
argument_list|,
operator|(
operator|(
name|match_list_size
operator|+=
literal|10
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
operator|++
name|matches
index|]
operator|=
name|string
expr_stmt|;
name|match_list
index|[
name|matches
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were any matches, then look through them finding out the      lowest common denominator.  That then becomes match_list[0]. */
if|if
condition|(
name|matches
condition|)
name|compute_lcd_of_matches
argument_list|(
name|match_list
argument_list|,
name|matches
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
comment|/* There were no matches. */
block|{
name|free
argument_list|(
name|match_list
argument_list|)
expr_stmt|;
name|match_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|match_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A completion function for usernames.    TEXT contains a partial username preceded by a random    character (usually `~').  */
end_comment

begin_function
name|char
modifier|*
name|username_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OPENNT
argument_list|)
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
else|#
directive|else
comment|/* !__WIN32__&& !__OPENNT) */
specifier|static
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|struct
name|passwd
modifier|*
name|entry
decl_stmt|;
specifier|static
name|int
name|namelen
decl_stmt|,
name|first_char
decl_stmt|,
name|first_char_loc
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|first_char
operator|=
operator|*
name|text
expr_stmt|;
name|first_char_loc
operator|=
name|first_char
operator|==
literal|'~'
expr_stmt|;
name|username
operator|=
name|savestring
argument_list|(
operator|&
name|text
index|[
name|first_char_loc
index|]
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|entry
operator|=
name|getpwent
argument_list|()
condition|)
block|{
comment|/* Null usernames should result in all users as possible completions. */
if|if
condition|(
name|namelen
operator|==
literal|0
operator|||
operator|(
name|STREQN
argument_list|(
name|username
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|,
name|namelen
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|value
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
operator|*
name|text
expr_stmt|;
name|strcpy
argument_list|(
name|value
operator|+
name|first_char_loc
argument_list|,
name|entry
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_char
operator|==
literal|'~'
condition|)
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !__WIN32__&& !__OPENNT */
block|}
end_function

begin_comment
comment|/* Okay, now we write the entry_function for filename completion.  In the    general case.  Note that completion in the shell is a little different    because of all the pathnames that must be followed when looking up the    completion for a command. */
end_comment

begin_function
name|char
modifier|*
name|filename_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
specifier|static
name|DIR
modifier|*
name|directory
init|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|users_dirname
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|filename_len
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|dirlen
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
decl_stmt|;
comment|/* If we don't have any state, then do some initialization. */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
comment|/* If we were interrupted before closing the directory or reading 	 all of its contents, close it. */
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|FREE
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|==
literal|0
condition|)
name|text
operator|=
literal|"."
expr_stmt|;
name|dirname
operator|=
name|savestring
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|dirname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
comment|/* special hack for //X/... */
if|if
condition|(
name|dirname
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|dirname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|isalpha
argument_list|(
name|dirname
index|[
literal|2
index|]
argument_list|)
operator|&&
name|dirname
index|[
literal|3
index|]
operator|==
literal|'/'
condition|)
name|temp
operator|=
name|strrchr
argument_list|(
name|dirname
operator|+
literal|3
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
operator|++
name|temp
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
comment|/* searches from current directory on the drive */
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|dirname
index|[
literal|0
index|]
argument_list|)
operator|&&
name|dirname
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
operator|+
literal|2
argument_list|)
expr_stmt|;
name|dirname
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|dirname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dirname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* We aren't done yet.  We also support the "~user" syntax. */
comment|/* Save the version of the directory that the user typed. */
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
operator|==
literal|'~'
condition|)
block|{
name|temp
operator|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|rl_directory_completion_hook
operator|&&
call|(
modifier|*
name|rl_directory_completion_hook
call|)
argument_list|(
operator|&
name|dirname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
name|directory
operator|=
name|opendir
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rl_filename_completion_desired
operator|=
literal|1
expr_stmt|;
block|}
comment|/* At this point we should entertain the possibility of hacking wildcarded      filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name      contains globbing characters, then build an array of directories, and      then map over that list while completing. */
comment|/* *** UNIMPLEMENTED *** */
comment|/* Now that we have some state, we can read the directory. */
name|entry
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
name|directory
operator|&&
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|directory
argument_list|)
operator|)
condition|)
block|{
comment|/* Special case for no filename. 	 All entries except "." and ".." match. */
if|if
condition|(
name|filename_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|entry
operator|->
name|d_name
index|[
literal|1
index|]
operator|&&
operator|(
name|entry
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|entry
operator|->
name|d_name
index|[
literal|2
index|]
operator|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* Otherwise, if these match up to the length of filename, then 	     it is a match. */
if|if
condition|(
name|_rl_completion_case_fold
condition|)
block|{
if|if
condition|(
operator|(
name|_rl_to_lower
argument_list|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
operator|==
name|_rl_to_lower
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
operator|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|_rl_strnicmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|filename
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
operator|(
operator|(
name|int
operator|)
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
operator|)
operator|>=
name|filename_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|directory
condition|)
block|{
name|closedir
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|directory
operator|=
operator|(
name|DIR
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dirname
condition|)
block|{
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|users_dirname
condition|)
block|{
name|free
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|users_dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
comment|/* dirname&& (strcmp (dirname, ".") != 0) */
if|if
condition|(
name|dirname
operator|&&
operator|(
name|dirname
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dirname
index|[
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|rl_complete_with_tilde_expansion
operator|&&
operator|*
name|users_dirname
operator|==
literal|'~'
condition|)
block|{
name|dirlen
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|dirlen
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
comment|/* Canonicalization cuts off any final slash present.  We 		 may need to add it back. */
if|if
condition|(
name|dirname
index|[
name|dirlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
index|[
name|dirlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|temp
index|[
name|dirlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|dirlen
operator|=
name|strlen
argument_list|(
name|users_dirname
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|dirlen
operator|+
name|D_NAMLEN
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|users_dirname
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|temp
operator|+
name|dirlen
argument_list|,
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|savestring
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* An initial implementation of a menu completion function a la tcsh.  The    first time (if the last readline command was not rl_menu_complete), we    generate the list of matches.  This code is very similar to the code in    rl_complete_internal -- there should be a way to combine the two.  Then,    for each item in the list of matches, we insert the match in an undoable    fashion, with the appropriate character appended (this happens on the    second and subsequent consecutive calls to rl_menu_complete).  When we    hit the end of the match list, we restore the original unmatched text,    ring the bell, and reset the counter to zero. */
end_comment

begin_function
name|int
name|rl_menu_complete
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|Function
modifier|*
name|our_func
decl_stmt|;
name|int
name|matching_filenames
decl_stmt|,
name|found_quote
decl_stmt|;
specifier|static
name|char
modifier|*
name|orig_text
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|matches
init|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|int
name|match_list_index
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|match_list_size
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|orig_start
decl_stmt|,
name|orig_end
decl_stmt|;
specifier|static
name|char
name|quote_char
decl_stmt|;
specifier|static
name|int
name|delimiter
decl_stmt|;
comment|/* The first time through, we generate the list of matches and set things      up to insert them. */
if|if
condition|(
name|rl_last_func
operator|!=
name|rl_menu_complete
condition|)
block|{
comment|/* Clean up from previous call, if any. */
name|FREE
argument_list|(
name|orig_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
condition|)
name|free_match_list
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|match_list_index
operator|=
name|match_list_size
operator|=
literal|0
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Only the completion entry function can change these. */
name|rl_filename_completion_desired
operator|=
literal|0
expr_stmt|;
name|rl_filename_quoting_desired
operator|=
literal|1
expr_stmt|;
name|rl_completion_type
operator|=
literal|'%'
expr_stmt|;
name|our_func
operator|=
name|rl_completion_entry_function
condition|?
name|rl_completion_entry_function
else|:
operator|(
name|Function
operator|*
operator|)
name|filename_completion_function
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word. */
name|orig_end
operator|=
name|rl_point
expr_stmt|;
name|found_quote
operator|=
name|delimiter
operator|=
literal|0
expr_stmt|;
name|quote_char
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
comment|/* This (possibly) changes rl_point.  If it returns a non-zero char, 	   we know we have an open quote. */
name|quote_char
operator|=
name|find_completion_word
argument_list|(
operator|&
name|found_quote
argument_list|,
operator|&
name|delimiter
argument_list|)
expr_stmt|;
name|orig_start
operator|=
name|rl_point
expr_stmt|;
name|rl_point
operator|=
name|orig_end
expr_stmt|;
name|orig_text
operator|=
name|rl_copy_text
argument_list|(
name|orig_start
argument_list|,
name|orig_end
argument_list|)
expr_stmt|;
name|matches
operator|=
name|gen_completion_matches
argument_list|(
name|orig_text
argument_list|,
name|orig_start
argument_list|,
name|orig_end
argument_list|,
name|our_func
argument_list|,
name|found_quote
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If we are matching filenames, our_func will have been set to 	 filename_completion_function */
block|matching_filenames = our_func == (Function *)filename_completion_function;
else|#
directive|else
comment|/* If we are matching filenames, the attempted completion function will 	 have set rl_filename_completion_desired to a non-zero value.  The basic 	 filename_completion_function does this. */
name|matching_filenames
operator|=
name|rl_filename_completion_desired
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|postprocess_matches
argument_list|(
operator|&
name|matches
argument_list|,
name|matching_filenames
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|orig_text
argument_list|)
expr_stmt|;
name|orig_text
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|match_list_size
operator|=
literal|0
init|;
name|matches
index|[
name|match_list_size
index|]
condition|;
name|match_list_size
operator|++
control|)
empty_stmt|;
comment|/* matches[0] is lcd if match_list_size> 1, but the circular buffer 	 code below should take care of it. */
block|}
comment|/* Now we have the list of matches.  Replace the text between      rl_line_buffer[orig_start] and rl_line_buffer[rl_point] with      matches[match_list_index], and add any necessary closing char. */
if|if
condition|(
name|matches
operator|==
literal|0
operator|||
name|match_list_size
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
name|completion_changed_buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|match_list_index
operator|=
operator|(
name|match_list_index
operator|+
name|count
operator|)
operator|%
name|match_list_size
expr_stmt|;
if|if
condition|(
name|match_list_index
operator|<
literal|0
condition|)
name|match_list_index
operator|+=
name|match_list_size
expr_stmt|;
if|if
condition|(
name|match_list_index
operator|==
literal|0
operator|&&
name|match_list_size
operator|>
literal|1
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
name|insert_match
argument_list|(
name|orig_text
argument_list|,
name|orig_start
argument_list|,
name|MULT_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert_match
argument_list|(
name|matches
index|[
name|match_list_index
index|]
argument_list|,
name|orig_start
argument_list|,
name|SINGLE_MATCH
argument_list|,
operator|&
name|quote_char
argument_list|)
expr_stmt|;
name|append_to_match
argument_list|(
name|matches
index|[
name|match_list_index
index|]
argument_list|,
name|delimiter
argument_list|,
name|quote_char
argument_list|)
expr_stmt|;
block|}
name|completion_changed_buffer
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

