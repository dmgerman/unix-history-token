begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* terminal.c -- controlling the terminal with termcap. */
end_comment

begin_comment
comment|/* Copyright (C) 1996-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LOCALE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GWINSZ_IN_SYS_IOCTL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GWINSZ_IN_SYS_IOCTL&& !TIOCGWINSZ */
end_comment

begin_include
include|#
directive|include
file|"rltty.h"
end_include

begin_include
include|#
directive|include
file|"tcap.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_define
define|#
directive|define
name|CUSTOM_REDISPLAY_FUNC
parameter_list|()
value|(rl_redisplay_function != rl_redisplay)
end_define

begin_define
define|#
directive|define
name|CUSTOM_INPUT_FUNC
parameter_list|()
value|(rl_getc_function != rl_getc)
end_define

begin_decl_stmt
name|int
name|rl_prefer_env_winsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Terminal and Termcap			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_string_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcap_initialized
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_EXTERN_PC
argument_list|)
end_if

begin_decl_stmt
specifier|extern
endif|#
directive|endif
comment|/* __EMX__ || NEED_EXTERN_PC */
name|char
name|PC
decl_stmt|,
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __linux__ */
end_comment

begin_comment
comment|/* Some strings to control terminal actions.  These are output by tputs (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_rl_term_clreol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_clrpag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_cr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_backspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_goto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we determine that the terminal can do character insertion. */
end_comment

begin_decl_stmt
name|int
name|_rl_terminal_can_insert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to insert characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_rl_term_im
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_ei
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_ic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_IC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to delete characters. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_rl_term_dc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_rl_term_DC
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|_rl_term_forward_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HACK_TERMCAP_MOTION */
end_comment

begin_comment
comment|/* How to go up a line. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_rl_term_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A visible bell; char if the terminal can be made to flash the screen. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the terminal can auto-wrap lines. */
end_comment

begin_decl_stmt
name|int
name|_rl_term_autowrap
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that this terminal has a meta key. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|term_has_meta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sequences to write to turn on and off the meta key, if this    terminal has one. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_mm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_mo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The key sequences output by the arrow keys, if this terminal has any. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_ku
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to initialize and reset the arrow keys, if this terminal has any. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_ks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_ke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The key sequences sent by the Home and End keys, if any. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_at7
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* @7 */
end_comment

begin_comment
comment|/* Delete key */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert key */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_kI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cursor control */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_vs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* very visible */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_rl_term_ve
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* normal */
end_comment

begin_decl_stmt
specifier|static
name|void
name|bind_termcap_arrow_keys
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables that hold the screen dimensions, used by the display code. */
end_comment

begin_decl_stmt
name|int
name|_rl_screenwidth
decl_stmt|,
name|_rl_screenheight
decl_stmt|,
name|_rl_screenchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the user wants to enable the keypad. */
end_comment

begin_decl_stmt
name|int
name|_rl_enable_keypad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means the user wants to enable a meta key. */
end_comment

begin_decl_stmt
name|int
name|_rl_enable_meta
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|_emx_get_screensize
parameter_list|(
name|swp
parameter_list|,
name|shp
parameter_list|)
name|int
modifier|*
name|swp
decl_stmt|,
decl|*
name|shp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|sz
index|[
literal|2
index|]
decl_stmt|;
name|_scrsize
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|swp
condition|)
operator|*
name|swp
operator|=
name|sz
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|shp
condition|)
operator|*
name|shp
operator|=
name|sz
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get readline's idea of the screen size.  TTY is a file descriptor open    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being    non-null serve to check whether or not we have initialized termcap. */
end_comment

begin_function
name|void
name|_rl_get_screen_size
parameter_list|(
name|tty
parameter_list|,
name|ignore_env
parameter_list|)
name|int
name|tty
decl_stmt|,
name|ignore_env
decl_stmt|;
block|{
name|char
modifier|*
name|ss
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
name|struct
name|winsize
name|window_size
decl_stmt|;
endif|#
directive|endif
comment|/* TIOCGWINSZ */
name|int
name|wr
decl_stmt|,
name|wc
decl_stmt|;
name|wr
operator|=
name|wc
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|window_size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wc
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_col
expr_stmt|;
name|wr
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_row
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGWINSZ */
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
name|_emx_get_screensize
argument_list|(
operator|&
name|_rl_screenwidth
argument_list|,
operator|&
name|_rl_screenheight
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ignore_env
operator|||
name|rl_prefer_env_winsize
operator|==
literal|0
condition|)
block|{
name|_rl_screenwidth
operator|=
name|wc
expr_stmt|;
name|_rl_screenheight
operator|=
name|wr
expr_stmt|;
block|}
else|else
name|_rl_screenwidth
operator|=
name|_rl_screenheight
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV      is unset.  If we prefer the environment, check it first before      assigning the value returned by the kernel. */
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_env
operator|==
literal|0
operator|&&
operator|(
name|ss
operator|=
name|sh_get_env_value
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
condition|)
name|_rl_screenwidth
operator|=
name|atoi
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
condition|)
name|_rl_screenwidth
operator|=
name|wc
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
operator|&&
name|term_string_buffer
condition|)
name|_rl_screenwidth
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Environment variable LINES overrides setting of "li" if IGNORE_ENV      is unset. */
if|if
condition|(
name|_rl_screenheight
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ignore_env
operator|==
literal|0
operator|&&
operator|(
name|ss
operator|=
name|sh_get_env_value
argument_list|(
literal|"LINES"
argument_list|)
operator|)
condition|)
name|_rl_screenheight
operator|=
name|atoi
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_screenheight
operator|<=
literal|0
condition|)
name|_rl_screenheight
operator|=
name|wr
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
if|if
condition|(
name|_rl_screenheight
operator|<=
literal|0
operator|&&
name|term_string_buffer
condition|)
name|_rl_screenheight
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If all else fails, default to 80x24 terminal. */
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|1
condition|)
name|_rl_screenwidth
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|_rl_screenheight
operator|<=
literal|0
condition|)
name|_rl_screenheight
operator|=
literal|24
expr_stmt|;
comment|/* If we're being compiled as part of bash, set the environment      variables $LINES and $COLUMNS to new values.  Otherwise, just      do a pair of putenv () or setenv () calls. */
name|sh_set_lines_and_columns
argument_list|(
name|_rl_screenheight
argument_list|,
name|_rl_screenwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_term_autowrap
operator|==
literal|0
condition|)
name|_rl_screenwidth
operator|--
expr_stmt|;
name|_rl_screenchars
operator|=
name|_rl_screenwidth
operator|*
name|_rl_screenheight
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_set_screen_size
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
block|{
if|if
condition|(
name|_rl_term_autowrap
operator|==
operator|-
literal|1
condition|)
name|_rl_init_terminal_io
argument_list|(
name|rl_terminal_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rows
operator|>
literal|0
condition|)
name|_rl_screenheight
operator|=
name|rows
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|0
condition|)
block|{
name|_rl_screenwidth
operator|=
name|cols
expr_stmt|;
if|if
condition|(
name|_rl_term_autowrap
operator|==
literal|0
condition|)
name|_rl_screenwidth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rows
operator|>
literal|0
operator|||
name|cols
operator|>
literal|0
condition|)
name|_rl_screenchars
operator|=
name|_rl_screenwidth
operator|*
name|_rl_screenheight
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_set_screen_size
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
block|{
name|_rl_set_screen_size
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_get_screen_size
parameter_list|(
name|rows
parameter_list|,
name|cols
parameter_list|)
name|int
modifier|*
name|rows
decl_stmt|,
decl|*
name|cols
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|rows
condition|)
operator|*
name|rows
operator|=
name|_rl_screenheight
expr_stmt|;
if|if
condition|(
name|cols
condition|)
operator|*
name|cols
operator|=
name|_rl_screenwidth
expr_stmt|;
block|}
end_block

begin_function
name|void
name|rl_reset_screen_size
parameter_list|()
block|{
name|_rl_get_screen_size
argument_list|(
name|fileno
argument_list|(
name|rl_instream
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_resize_terminal
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|_rl_get_screen_size
argument_list|(
name|fileno
argument_list|(
name|rl_instream
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CUSTOM_REDISPLAY_FUNC
argument_list|()
condition|)
name|rl_forced_update_display
argument_list|()
expr_stmt|;
else|else
name|_rl_redisplay_after_sigwinch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|_tc_string
block|{
specifier|const
name|char
modifier|*
name|tc_var
decl_stmt|;
name|char
modifier|*
modifier|*
name|tc_value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This should be kept sorted, just in case we decide to change the    search algorithm to something smarter. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_tc_string
name|tc_strings
index|[]
init|=
block|{
block|{
literal|"@7"
block|,
operator|&
name|_rl_term_at7
block|}
block|,
block|{
literal|"DC"
block|,
operator|&
name|_rl_term_DC
block|}
block|,
block|{
literal|"IC"
block|,
operator|&
name|_rl_term_IC
block|}
block|,
block|{
literal|"ce"
block|,
operator|&
name|_rl_term_clreol
block|}
block|,
block|{
literal|"cl"
block|,
operator|&
name|_rl_term_clrpag
block|}
block|,
block|{
literal|"cr"
block|,
operator|&
name|_rl_term_cr
block|}
block|,
block|{
literal|"dc"
block|,
operator|&
name|_rl_term_dc
block|}
block|,
block|{
literal|"ei"
block|,
operator|&
name|_rl_term_ei
block|}
block|,
block|{
literal|"ic"
block|,
operator|&
name|_rl_term_ic
block|}
block|,
block|{
literal|"im"
block|,
operator|&
name|_rl_term_im
block|}
block|,
block|{
literal|"kD"
block|,
operator|&
name|_rl_term_kD
block|}
block|,
comment|/* delete */
block|{
literal|"kH"
block|,
operator|&
name|_rl_term_kH
block|}
block|,
comment|/* home down ?? */
block|{
literal|"kI"
block|,
operator|&
name|_rl_term_kI
block|}
block|,
comment|/* insert */
block|{
literal|"kd"
block|,
operator|&
name|_rl_term_kd
block|}
block|,
block|{
literal|"ke"
block|,
operator|&
name|_rl_term_ke
block|}
block|,
comment|/* end keypad mode */
block|{
literal|"kh"
block|,
operator|&
name|_rl_term_kh
block|}
block|,
comment|/* home */
block|{
literal|"kl"
block|,
operator|&
name|_rl_term_kl
block|}
block|,
block|{
literal|"kr"
block|,
operator|&
name|_rl_term_kr
block|}
block|,
block|{
literal|"ks"
block|,
operator|&
name|_rl_term_ks
block|}
block|,
comment|/* start keypad mode */
block|{
literal|"ku"
block|,
operator|&
name|_rl_term_ku
block|}
block|,
block|{
literal|"le"
block|,
operator|&
name|_rl_term_backspace
block|}
block|,
block|{
literal|"mm"
block|,
operator|&
name|_rl_term_mm
block|}
block|,
block|{
literal|"mo"
block|,
operator|&
name|_rl_term_mo
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
block|{
literal|"nd"
block|,
operator|&
name|_rl_term_forward_char
block|}
block|,
endif|#
directive|endif
block|{
literal|"pc"
block|,
operator|&
name|_rl_term_pc
block|}
block|,
block|{
literal|"up"
block|,
operator|&
name|_rl_term_up
block|}
block|,
block|{
literal|"vb"
block|,
operator|&
name|_rl_visible_bell
block|}
block|,
block|{
literal|"vs"
block|,
operator|&
name|_rl_term_vs
block|}
block|,
block|{
literal|"ve"
block|,
operator|&
name|_rl_term_ve
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_TC_STRINGS
value|(sizeof (tc_strings) / sizeof (struct _tc_string))
end_define

begin_comment
comment|/* Read the desired terminal capability strings into BP.  The capabilities    are described in the TC_STRINGS table. */
end_comment

begin_function
specifier|static
name|void
name|get_term_capabilities
parameter_list|(
name|bp
parameter_list|)
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
comment|/* XXX - doesn't DJGPP have a termcap library? */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TC_STRINGS
condition|;
name|i
operator|++
control|)
operator|*
operator|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_value
operator|)
operator|=
name|tgetstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tcap_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_rl_init_terminal_io
parameter_list|(
name|terminal_name
parameter_list|)
specifier|const
name|char
modifier|*
name|terminal_name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|term
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|tty
decl_stmt|,
name|tgetent_ret
decl_stmt|;
name|term
operator|=
name|terminal_name
condition|?
name|terminal_name
else|:
name|sh_get_env_value
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
name|_rl_term_clrpag
operator|=
name|_rl_term_cr
operator|=
name|_rl_term_clreol
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|tty
operator|=
name|rl_instream
condition|?
name|fileno
argument_list|(
name|rl_instream
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|0
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
comment|/* I've separated this out for later work on not calling tgetent at all      if the calling application has supplied a custom redisplay function,      (and possibly if the application has supplied a custom input function). */
if|if
condition|(
name|CUSTOM_REDISPLAY_FUNC
argument_list|()
condition|)
block|{
name|tgetent_ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_string_buffer
operator|==
literal|0
condition|)
name|term_string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2032
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_buffer
operator|==
literal|0
condition|)
name|term_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4080
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|term_string_buffer
expr_stmt|;
name|tgetent_ret
operator|=
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tgetent_ret
operator|<=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|term_string_buffer
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|term_buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|term_buffer
operator|=
name|term_string_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_autowrap
operator|=
literal|0
expr_stmt|;
comment|/* used by _rl_get_screen_size */
comment|/* Allow calling application to set default height and width, using 	 rl_set_screen_size */
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
operator|||
name|_rl_screenheight
operator|<=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
name|_emx_get_screensize
argument_list|(
operator|&
name|_rl_screenwidth
argument_list|,
operator|&
name|_rl_screenheight
argument_list|)
expr_stmt|;
name|_rl_screenwidth
operator|--
expr_stmt|;
else|#
directive|else
comment|/* !__EMX__ */
name|_rl_get_screen_size
argument_list|(
name|tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__EMX__ */
block|}
comment|/* Defaults. */
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
operator|||
name|_rl_screenheight
operator|<=
literal|0
condition|)
block|{
name|_rl_screenwidth
operator|=
literal|79
expr_stmt|;
name|_rl_screenheight
operator|=
literal|24
expr_stmt|;
block|}
comment|/* Everything below here is used by the redisplay code (tputs). */
name|_rl_screenchars
operator|=
name|_rl_screenwidth
operator|*
name|_rl_screenheight
expr_stmt|;
name|_rl_term_cr
operator|=
literal|"\r"
expr_stmt|;
name|_rl_term_im
operator|=
name|_rl_term_ei
operator|=
name|_rl_term_ic
operator|=
name|_rl_term_IC
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_up
operator|=
name|_rl_term_dc
operator|=
name|_rl_term_DC
operator|=
name|_rl_visible_bell
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_ku
operator|=
name|_rl_term_kd
operator|=
name|_rl_term_kl
operator|=
name|_rl_term_kr
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_kh
operator|=
name|_rl_term_kH
operator|=
name|_rl_term_kI
operator|=
name|_rl_term_kD
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_ks
operator|=
name|_rl_term_ke
operator|=
name|_rl_term_at7
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_mm
operator|=
name|_rl_term_mo
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|_rl_term_ve
operator|=
name|_rl_term_vs
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
name|term_forward_char
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
name|_rl_terminal_can_insert
operator|=
name|term_has_meta
operator|=
literal|0
expr_stmt|;
comment|/* Reasonable defaults for tgoto().  Readline currently only uses          tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we          change that later... */
name|PC
operator|=
literal|'\0'
expr_stmt|;
name|BC
operator|=
name|_rl_term_backspace
operator|=
literal|"\b"
expr_stmt|;
name|UP
operator|=
name|_rl_term_up
expr_stmt|;
return|return
literal|0
return|;
block|}
name|get_term_capabilities
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* Set up the variables that the termcap library expects the application      to provide. */
name|PC
operator|=
name|_rl_term_pc
condition|?
operator|*
name|_rl_term_pc
else|:
literal|0
expr_stmt|;
name|BC
operator|=
name|_rl_term_backspace
expr_stmt|;
name|UP
operator|=
name|_rl_term_up
expr_stmt|;
if|if
condition|(
operator|!
name|_rl_term_cr
condition|)
name|_rl_term_cr
operator|=
literal|"\r"
expr_stmt|;
name|_rl_term_autowrap
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
operator|&&
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* Allow calling application to set default height and width, using      rl_set_screen_size */
if|if
condition|(
name|_rl_screenwidth
operator|<=
literal|0
operator|||
name|_rl_screenheight
operator|<=
literal|0
condition|)
name|_rl_get_screen_size
argument_list|(
name|tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "An application program can assume that the terminal can do       character insertion if *any one of* the capabilities `IC',       `im', `ic' or `ip' is provided."  But we can't do anything if       only `ip' is provided, so... */
name|_rl_terminal_can_insert
operator|=
operator|(
name|_rl_term_IC
operator|||
name|_rl_term_im
operator|||
name|_rl_term_ic
operator|)
expr_stmt|;
comment|/* Check to see if this terminal has a meta key and clear the capability      variables if there is none. */
name|term_has_meta
operator|=
operator|(
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
operator|||
name|tgetflag
argument_list|(
literal|"MT"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_has_meta
condition|)
name|_rl_term_mm
operator|=
name|_rl_term_mo
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Attempt to find and bind the arrow keys.  Do not override already      bound keys in an overzealous attempt, however. */
name|bind_termcap_arrow_keys
argument_list|(
name|emacs_standard_keymap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
name|bind_termcap_arrow_keys
argument_list|(
name|vi_movement_keymap
argument_list|)
expr_stmt|;
name|bind_termcap_arrow_keys
argument_list|(
name|vi_insertion_keymap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VI_MODE */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Bind the arrow key sequences from the termcap description in MAP. */
end_comment

begin_function
specifier|static
name|void
name|bind_termcap_arrow_keys
parameter_list|(
name|map
parameter_list|)
name|Keymap
name|map
decl_stmt|;
block|{
name|Keymap
name|xkeymap
decl_stmt|;
name|xkeymap
operator|=
name|_rl_keymap
expr_stmt|;
name|_rl_keymap
operator|=
name|map
expr_stmt|;
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_ku
argument_list|,
name|rl_get_previous_history
argument_list|)
expr_stmt|;
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_kd
argument_list|,
name|rl_get_next_history
argument_list|)
expr_stmt|;
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_kr
argument_list|,
name|rl_forward_char
argument_list|)
expr_stmt|;
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_kl
argument_list|,
name|rl_backward_char
argument_list|)
expr_stmt|;
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_kh
argument_list|,
name|rl_beg_of_line
argument_list|)
expr_stmt|;
comment|/* Home */
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_at7
argument_list|,
name|rl_end_of_line
argument_list|)
expr_stmt|;
comment|/* End */
name|rl_bind_keyseq_if_unbound
argument_list|(
name|_rl_term_kD
argument_list|,
name|rl_delete
argument_list|)
expr_stmt|;
name|_rl_keymap
operator|=
name|xkeymap
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_get_termcap
parameter_list|(
name|cap
parameter_list|)
specifier|const
name|char
modifier|*
name|cap
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tcap_initialized
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_TC_STRINGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
index|[
literal|0
index|]
operator|==
name|cap
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_var
argument_list|,
name|cap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|*
operator|(
name|tc_strings
index|[
name|i
index|]
operator|.
name|tc_value
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-initialize the terminal considering that the TERM/TERMCAP variable    has changed. */
end_comment

begin_function
name|int
name|rl_reset_terminal
parameter_list|(
name|terminal_name
parameter_list|)
specifier|const
name|char
modifier|*
name|terminal_name
decl_stmt|;
block|{
name|_rl_screenwidth
operator|=
name|_rl_screenheight
operator|=
literal|0
expr_stmt|;
name|_rl_init_terminal_io
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A function for the use of tputs () */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MINIX
end_ifdef

begin_function
name|void
name|_rl_output_character_function
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|_rl_out_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_MINIX */
end_comment

begin_function
name|int
name|_rl_output_character_function
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
name|putc
argument_list|(
name|c
argument_list|,
name|_rl_out_stream
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_MINIX */
end_comment

begin_comment
comment|/* Write COUNT characters from STRING to the output stream. */
end_comment

begin_function
name|void
name|_rl_output_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|_rl_out_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the cursor back. */
end_comment

begin_function
name|int
name|_rl_backspace
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|_rl_term_backspace
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|_rl_term_backspace
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\b'
argument_list|,
name|_rl_out_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move to the start of the next line. */
end_comment

begin_function
name|int
name|rl_crlf
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEW_TTY_DRIVER
argument_list|)
if|if
condition|(
name|_rl_term_cr
condition|)
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_TTY_DRIVER */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|_rl_out_stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Ring the terminal bell. */
end_comment

begin_function
name|int
name|rl_ding
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
switch|switch
condition|(
name|_rl_bell_preference
condition|)
block|{
case|case
name|NO_BELL
case|:
default|default:
break|break;
case|case
name|VISIBLE_BELL
case|:
if|if
condition|(
name|_rl_visible_bell
condition|)
block|{
name|tputs
argument_list|(
name|_rl_visible_bell
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|AUDIBLE_BELL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\007"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	 	Controlling the Meta Key and Keypad		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|void
name|_rl_enable_meta_key
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
if|if
condition|(
name|term_has_meta
operator|&&
name|_rl_term_mm
condition|)
name|tputs
argument_list|(
name|_rl_term_mm
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_rl_control_keypad
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
if|if
condition|(
name|on
operator|&&
name|_rl_term_ks
condition|)
name|tputs
argument_list|(
name|_rl_term_ks
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|_rl_term_ke
condition|)
name|tputs
argument_list|(
name|_rl_term_ke
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	 		Controlling the Cursor			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Set the cursor appropriately depending on IM, which is one of the    insert modes (insert or overwrite).  Insert mode gets the normal    cursor.  Overwrite mode gets a very visible cursor.  Only does    anything if we have both capabilities. */
end_comment

begin_function
name|void
name|_rl_set_cursor
parameter_list|(
name|im
parameter_list|,
name|force
parameter_list|)
name|int
name|im
decl_stmt|,
name|force
decl_stmt|;
block|{
if|if
condition|(
name|_rl_term_ve
operator|&&
name|_rl_term_vs
condition|)
block|{
if|if
condition|(
name|force
operator|||
name|im
operator|!=
name|rl_insert_mode
condition|)
block|{
if|if
condition|(
name|im
operator|==
name|RL_IM_OVERWRITE
condition|)
name|tputs
argument_list|(
name|_rl_term_vs
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
name|tputs
argument_list|(
name|_rl_term_ve
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

