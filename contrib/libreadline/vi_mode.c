begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* vi_mode.c -- A vi emulation mode for Bash.    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			VI Emulation Mode			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_include
include|#
directive|include
file|"rlconf.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|_rl_vi_last_command
init|=
literal|'i'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default `.' puts you in insert mode */
end_comment

begin_comment
comment|/* Non-zero means enter insertion mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_doing_insert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command keys which do movement for xxx_to commands. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|vi_motion
init|=
literal|" hl^$0ftFT;,%wbeWBE|"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap used for vi replace characters.  Created dynamically since    rarely used. */
end_comment

begin_decl_stmt
specifier|static
name|Keymap
name|vi_replace_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters inserted in the last replace operation. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_replace_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, we have text inserted after a c[motion] command that put    us implicitly into insert mode.  Some people want this text to be    attached to the command so that it is `redoable' with `.'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_continued_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_insert_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_insert_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_repeat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_motion
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|_rl_vi_last_search_mbchar
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_search_mblen
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_search_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_replacement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_key_before_insert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_redoing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text modification commands.  These are the `redoable' commands. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|vi_textmod
init|=
literal|"_*\\AaIiCcDdPpYyRrSsXx~"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arrays for the saved marks. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_mark_chars
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_rl_vi_stuff_insert
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_rl_vi_save_insert
name|PARAMS
argument_list|(
operator|(
name|UNDO_LIST
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_arg_dispatch
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_digit_loop1
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_set_mark
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_goto_mark
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_callback_getchar
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_callback_set_mark
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_callback_goto_mark
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_callback_change_char
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_callback_char_search
name|PARAMS
argument_list|(
operator|(
name|_rl_callback_generic_arg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_rl_vi_initialize_line
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vi_mark_chars
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|vi_mark_chars
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_VICMDONCE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_reset_last
parameter_list|()
block|{
name|_rl_vi_last_command
operator|=
literal|'i'
expr_stmt|;
name|_rl_vi_last_repeat
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_arg_sign
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_motion
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_set_last
parameter_list|(
name|key
parameter_list|,
name|repeat
parameter_list|,
name|sign
parameter_list|)
name|int
name|key
decl_stmt|,
name|repeat
decl_stmt|,
name|sign
decl_stmt|;
block|{
name|_rl_vi_last_command
operator|=
name|key
expr_stmt|;
name|_rl_vi_last_repeat
operator|=
name|repeat
expr_stmt|;
name|_rl_vi_last_arg_sign
operator|=
name|sign
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A convenience function that calls _rl_vi_set_last to save the last command    information and enters insertion mode. */
end_comment

begin_function
name|void
name|rl_vi_start_inserting
parameter_list|(
name|key
parameter_list|,
name|repeat
parameter_list|,
name|sign
parameter_list|)
name|int
name|key
decl_stmt|,
name|repeat
decl_stmt|,
name|sign
decl_stmt|;
block|{
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
name|repeat
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is the command C a VI mode text modification command? */
end_comment

begin_function
name|int
name|_rl_vi_textmod_command
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|c
argument_list|,
name|vi_textmod
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_vi_stuff_insert
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
name|rl_insert_text
argument_list|(
name|vi_insert_buffer
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bound to `.'.  Called from command mode, so we know that we have to    redo a text modification command.  The default for _rl_vi_last_command    puts you back into insert mode. */
end_comment

begin_function
name|int
name|rl_vi_redo
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|rl_explicit_arg
condition|)
block|{
name|rl_numeric_arg
operator|=
name|_rl_vi_last_repeat
expr_stmt|;
name|rl_arg_sign
operator|=
name|_rl_vi_last_arg_sign
expr_stmt|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
name|vi_redoing
operator|=
literal|1
expr_stmt|;
comment|/* If we're redoing an insert with `i', stuff in the inserted text      and do not go into insertion mode. */
if|if
condition|(
name|_rl_vi_last_command
operator|==
literal|'i'
operator|&&
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
block|{
name|_rl_vi_stuff_insert
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|/* And back up point over the last character inserted. */
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_point
operator|--
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_rl_dispatch
argument_list|(
name|_rl_vi_last_command
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
name|vi_redoing
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A placeholder for further expansion. */
end_comment

begin_function
name|int
name|rl_vi_undo
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_undo_command
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Yank the nth arg from the previous line into this line at point. */
end_comment

begin_function
name|int
name|rl_vi_yank_arg
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
comment|/* Readline thinks that the first word on a line is the 0th, while vi      thinks the first word on a line is the 1st.  Compensate. */
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_yank_nth_arg
argument_list|(
name|count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_yank_nth_arg
argument_list|(
literal|'$'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* With an argument, move back that many history lines, else move to the    beginning of history. */
end_comment

begin_function
name|int
name|rl_vi_fetch_history
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|wanted
decl_stmt|;
comment|/* Giving an argument of n means we want the nth command in the history      file.  The command number is interpreted the same way that the bash      `history' command does it -- that is, giving an argument count of 450      to this command would get the command listed as number 450 in the      output of `history'. */
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|wanted
operator|=
name|history_base
operator|+
name|where_history
argument_list|()
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|wanted
operator|<=
literal|0
condition|)
name|rl_beginning_of_history
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_get_previous_history
argument_list|(
name|wanted
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_beginning_of_history
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search again for the last thing searched for. */
end_comment

begin_function
name|int
name|rl_vi_search_again
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'n'
case|:
name|rl_noninc_reverse_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|rl_noninc_forward_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a vi style search. */
end_comment

begin_function
name|int
name|rl_vi_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'?'
case|:
name|_rl_free_saved_history_line
argument_list|()
expr_stmt|;
name|rl_noninc_forward_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|_rl_free_saved_history_line
argument_list|()
expr_stmt|;
name|rl_noninc_reverse_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rl_ding
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Completion, from vi's point of view. */
end_comment

begin_function
name|int
name|rl_vi_complete
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|+
literal|1
index|]
argument_list|)
condition|)
name|rl_vi_end_word
argument_list|(
literal|1
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|'*'
condition|)
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
comment|/* Expansion and replacement. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'='
condition|)
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
comment|/* List possible completions. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
condition|)
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
comment|/* Standard Readline completion. */
else|else
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|'*'
operator|||
name|key
operator|==
literal|'\\'
condition|)
name|rl_vi_start_inserting
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tilde expansion for vi mode. */
end_comment

begin_function
name|int
name|rl_vi_tilde_expand
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_tilde_expand
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_start_inserting
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Previous word in vi mode. */
end_comment

begin_function
name|int
name|rl_vi_prev_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_next_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_bWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_bword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Next word in vi mode. */
end_comment

begin_function
name|int
name|rl_vi_next_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_prev_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_fWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_fword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move to the end of the ?next? word. */
end_comment

begin_function
name|int
name|rl_vi_end_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_eWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_eword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move forward a word the way that 'W' does. */
end_comment

begin_function
name|int
name|rl_vi_fWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Skip until whitespace. */
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Now skip whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
comment|/* If we are at the start of a word, move back to whitespace so 	 we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_eWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move to the next non-whitespace character (to the start of the 	 next word). */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
comment|/* Skip whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Skip until whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move back to the last character of the word. */
name|rl_point
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_fword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Move to white space (really non-identifer). */
if|if
condition|(
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
else|else
comment|/* if (!whitespace (rl_line_buffer[rl_point])) */
block|{
while|while
condition|(
operator|!
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
comment|/* Move past whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
name|int
name|last_is_ident
decl_stmt|;
comment|/* If we are at the start of a word, move back to whitespace 	 so we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If this character and the previous character are `opposite', move 	 back so we don't get messed up by the rl_point++ down there in 	 the while loop.  Without this code, words like `l;' screw up the 	 function. */
name|last_is_ident
operator|=
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|last_is_ident
operator|)
operator|||
operator|(
operator|!
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|last_is_ident
operator|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_eword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|_rl_isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_insert_beg
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_append_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
name|rl_point
operator|++
expr_stmt|;
else|else
block|{
name|int
name|point
init|=
name|rl_point
decl_stmt|;
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|==
name|rl_point
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
block|}
block|}
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_append_eol
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_end_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_append_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to do in the case of C-d. */
end_comment

begin_function
name|int
name|rl_vi_eof_maybe
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
return|return
operator|(
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insertion mode stuff. */
end_comment

begin_comment
comment|/* Switching from one mode to the other really just involves    switching keymaps. */
end_comment

begin_function
name|int
name|rl_vi_insertion_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
name|_rl_vi_last_key_before_insert
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_vi_save_insert
parameter_list|(
name|up
parameter_list|)
name|UNDO_LIST
modifier|*
name|up
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vi_insert_buffer_size
operator|>=
literal|1
condition|)
name|vi_insert_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|start
operator|=
name|up
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|up
operator|->
name|end
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|vi_insert_buffer_size
condition|)
block|{
name|vi_insert_buffer_size
operator|+=
operator|(
name|len
operator|+
literal|32
operator|)
operator|-
operator|(
name|len
operator|%
literal|32
operator|)
expr_stmt|;
name|vi_insert_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|vi_insert_buffer
argument_list|,
name|vi_insert_buffer_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|vi_insert_buffer
argument_list|,
name|rl_line_buffer
operator|+
name|start
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vi_insert_buffer
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_done_inserting
parameter_list|()
block|{
if|if
condition|(
name|_rl_vi_doing_insert
condition|)
block|{
comment|/* The `C', `s', and `S' commands set this. */
name|rl_end_undo_group
argument_list|()
expr_stmt|;
comment|/* Now, the text between rl_undo_list->next->start and 	 rl_undo_list->next->end is what was inserted while in insert 	 mode.  It gets copied to VI_INSERT_BUFFER because it depends 	 on absolute indices into the line which may change (though they 	 probably will not). */
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
name|_rl_vi_save_insert
argument_list|(
name|rl_undo_list
operator|->
name|next
argument_list|)
expr_stmt|;
name|vi_continued_command
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|_rl_vi_last_key_before_insert
operator|==
literal|'i'
operator|||
name|_rl_vi_last_key_before_insert
operator|==
literal|'a'
operator|)
operator|&&
name|rl_undo_list
condition|)
name|_rl_vi_save_insert
argument_list|(
name|rl_undo_list
argument_list|)
expr_stmt|;
comment|/* XXX - Other keys probably need to be checked. */
elseif|else
if|if
condition|(
name|_rl_vi_last_key_before_insert
operator|==
literal|'C'
condition|)
name|rl_end_undo_group
argument_list|()
expr_stmt|;
while|while
condition|(
name|_rl_undo_group_level
operator|>
literal|0
condition|)
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|vi_continued_command
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rl_vi_movement_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|_rl_keymap
operator|=
name|vi_movement_keymap
expr_stmt|;
name|_rl_vi_done_inserting
argument_list|()
expr_stmt|;
comment|/* This is how POSIX.2 says `U' should behave -- everything up until the      first time you go into command mode should not be undone. */
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_VICMDONCE
argument_list|)
operator|==
literal|0
condition|)
name|rl_free_undo_list
argument_list|()
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_VICMDONCE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_arg_digit
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
operator|&&
name|rl_numeric_arg
operator|==
literal|1
operator|&&
operator|!
name|rl_explicit_arg
condition|)
return|return
operator|(
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_digit_argument
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Change the case of the next COUNT characters. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_vi_change_mbchar_case
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|wchar_t
name|wc
decl_stmt|;
name|char
name|mb
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mblen
decl_stmt|,
name|p
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_adjust_point
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
operator|&
name|ps
argument_list|)
operator|>
literal|0
condition|)
name|count
operator|--
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|rl_line_buffer
operator|+
name|rl_point
argument_list|,
name|rl_end
operator|-
name|rl_point
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|iswupper
argument_list|(
name|wc
argument_list|)
condition|)
name|wc
operator|=
name|towlower
argument_list|(
name|wc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|iswlower
argument_list|(
name|wc
argument_list|)
condition|)
name|wc
operator|=
name|towupper
argument_list|(
name|wc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Just skip over chars neither upper nor lower case */
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Vi is kind of strange here. */
if|if
condition|(
name|wc
condition|)
block|{
name|p
operator|=
name|rl_point
expr_stmt|;
name|mblen
operator|=
name|wcrtomb
argument_list|(
name|mb
argument_list|,
name|wc
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|mblen
operator|>=
literal|0
condition|)
name|mb
index|[
name|mblen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_delete
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|p
condition|)
comment|/* Did we retreat at EOL? */
name|rl_point
operator|++
expr_stmt|;
comment|/* XXX - should we advance more than 1 for mbchar? */
name|rl_insert_text
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_check
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_vi_change_case
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|p
decl_stmt|;
comment|/* Don't try this on an empty line. */
if|if
condition|(
name|rl_point
operator|>=
name|rl_end
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
return|return
operator|(
name|_rl_vi_change_mbchar_case
argument_list|(
name|count
argument_list|)
operator|)
return|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|_rl_to_lower
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_lowercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|_rl_to_upper
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Just skip over characters neither upper nor lower case. */
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Vi is kind of strange here. */
if|if
condition|(
name|c
condition|)
block|{
name|p
operator|=
name|rl_point
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|p
condition|)
comment|/* Did we retreat at EOL? */
name|rl_point
operator|++
expr_stmt|;
name|_rl_insert_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_check
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_put
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|rl_point
operator|+
literal|1
operator|<=
name|rl_end
operator|)
condition|)
name|rl_point
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
name|rl_yank
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_check
parameter_list|()
block|{
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_point
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
else|else
name|rl_point
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_column
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|>
name|rl_end
condition|)
name|rl_end_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_point
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_domove
parameter_list|(
name|key
parameter_list|,
name|nextkey
parameter_list|)
name|int
name|key
decl_stmt|,
decl|*
name|nextkey
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
decl_stmt|;
name|int
name|old_end
decl_stmt|;
name|rl_mark
operator|=
name|rl_point
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|vi_motion
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|save
operator|=
name|rl_numeric_arg
expr_stmt|;
name|rl_numeric_arg
operator|=
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_NUMERICARG
operator||
name|RL_STATE_VIMOTION
argument_list|)
expr_stmt|;
name|rl_digit_loop1
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_VIMOTION
argument_list|)
expr_stmt|;
name|rl_numeric_arg
operator|*=
name|save
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* real command */
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|c
operator|&&
operator|(
name|key
operator|==
literal|'d'
operator|||
name|key
operator|==
literal|'y'
operator|||
name|key
operator|==
literal|'c'
operator|)
condition|)
block|{
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
comment|/* Append a blank character temporarily so that the motion routines      work right at the end of the line. */
name|old_end
operator|=
name|rl_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_dispatch
argument_list|(
name|c
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
comment|/* Remove the blank that we added. */
name|rl_end
operator|=
name|old_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
name|rl_end
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
comment|/* No change in position means the command failed. */
if|if
condition|(
name|rl_mark
operator|==
name|rl_point
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* rl_vi_f[wW]ord () leaves the cursor on the first character of the next      word.  If we are not at the end of the line, and we are on a      non-whitespace character, move back one (presumably to whitespace). */
if|if
condition|(
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
operator|&&
name|rl_point
operator|<
name|rl_end
operator|&&
name|rl_point
operator|>
name|rl_mark
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If cw or cW, back up to the end of a word, so the behaviour of ce      or cE is the actual result.  Brute-force, no subtlety. */
if|if
condition|(
name|key
operator|==
literal|'c'
operator|&&
name|rl_point
operator|>=
name|rl_mark
operator|&&
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
condition|)
block|{
comment|/* Don't move farther back than where we started. */
while|while
condition|(
name|rl_point
operator|>
name|rl_mark
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* Posix.2 says that if cw or cW moves the cursor towards the end of 	 the line, the character under the cursor should be deleted. */
if|if
condition|(
name|rl_point
operator|==
name|rl_mark
condition|)
name|rl_point
operator|++
expr_stmt|;
else|else
block|{
comment|/* Move past the end of the word so that the kill doesn't 	     remove the last letter of the previous word.  Only do this 	     if we are not at the end of the line. */
if|if
condition|(
name|rl_point
operator|>=
literal|0
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rl_mark
operator|<
name|rl_point
condition|)
name|SWAP
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Process C as part of the current numeric argument.  Return -1 if the    argument should be aborted, 0 if we should not read any more chars, and    1 if we should continue to read chars. */
end_comment

begin_function
specifier|static
name|int
name|_rl_vi_arg_dispatch
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|key
decl_stmt|;
name|key
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
return|return
literal|1
return|;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* A simplified loop for vi. Don't dispatch key at end.    Don't recognize minus sign?    Should this do rl_save_prompt/rl_restore_prompt? */
end_comment

begin_function
specifier|static
name|int
name|rl_digit_loop1
parameter_list|()
block|{
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|_rl_arg_overflow
argument_list|()
condition|)
return|return
literal|1
return|;
name|c
operator|=
name|_rl_arg_getchar
argument_list|()
expr_stmt|;
name|r
operator|=
name|_rl_vi_arg_dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
break|break;
block|}
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_NUMERICARG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_delete_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_change_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|start_pos
decl_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
name|start_pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark.  c[wW] are handled by special-case code in rl_vi_domove(),      and already leave the mark at the correct location. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|hwW^0bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
comment|/* The cursor never moves with c[wW]. */
if|if
condition|(
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
operator|&&
name|rl_point
operator|<
name|start_pos
condition|)
name|rl_point
operator|=
name|start_pos
expr_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
block|{
if|if
condition|(
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
block|{
name|rl_insert_text
argument_list|(
name|vi_insert_buffer
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* to make the `u' command work */
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
comment|/* `C' does not save the text inserted for undoing or redoing. */
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
operator|==
literal|0
condition|)
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_vi_start_inserting
argument_list|(
name|key
argument_list|,
name|rl_numeric_arg
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_yank_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|save
decl_stmt|;
name|save
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0%bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_rubout
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|p
decl_stmt|,
name|opoint
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_delete
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|opoint
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_backward_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_point
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
else|else
name|rl_point
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
literal|0
condition|)
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|opoint
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_rubout
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_end
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|end
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|,
name|count
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
else|else
name|end
operator|=
name|rl_point
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|rl_end
condition|)
name|end
operator|=
name|rl_end
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_back_to_indent
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_first_print
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_vi_back_to_indent
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|_rl_cs_dir
decl_stmt|,
name|_rl_cs_orig_dir
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_vi_callback_char_search
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|_rl_vi_last_search_mblen
operator|=
name|_rl_read_mbchar
argument_list|(
name|_rl_vi_last_search_mbchar
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|_rl_vi_last_search_char
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|data
operator|->
name|count
argument_list|,
name|_rl_cs_dir
argument_list|,
name|_rl_vi_last_search_mbchar
argument_list|,
name|_rl_vi_last_search_mblen
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|data
operator|->
name|count
argument_list|,
name|_rl_cs_dir
argument_list|,
name|_rl_vi_last_search_char
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_vi_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
specifier|static
name|char
modifier|*
name|target
decl_stmt|;
specifier|static
name|int
name|tlen
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|target
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
operator|==
literal|';'
operator|||
name|key
operator|==
literal|','
condition|)
name|_rl_cs_dir
operator|=
operator|(
name|key
operator|==
literal|';'
operator|)
condition|?
name|_rl_cs_orig_dir
else|:
operator|-
name|_rl_cs_orig_dir
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'t'
case|:
name|_rl_cs_orig_dir
operator|=
name|_rl_cs_dir
operator|=
name|FTO
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|_rl_cs_orig_dir
operator|=
name|_rl_cs_dir
operator|=
name|BTO
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|_rl_cs_orig_dir
operator|=
name|_rl_cs_dir
operator|=
name|FFIND
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|_rl_cs_orig_dir
operator|=
name|_rl_cs_dir
operator|=
name|BFIND
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vi_redoing
condition|)
block|{
comment|/* set target and tlen below */
block|}
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
name|_rl_callback_data_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|_rl_callback_data
operator|->
name|i1
operator|=
name|_rl_cs_dir
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_vi_callback_char_search
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|_rl_vi_last_search_mblen
operator|=
name|_rl_read_mbchar
argument_list|(
name|_rl_vi_last_search_mbchar
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|_rl_vi_last_search_char
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|target
operator|=
name|_rl_vi_last_search_mbchar
expr_stmt|;
name|tlen
operator|=
name|_rl_vi_last_search_mblen
expr_stmt|;
else|#
directive|else
name|target
operator|=
name|_rl_vi_last_search_char
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|_rl_cs_dir
argument_list|,
name|target
argument_list|,
name|tlen
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|_rl_cs_dir
argument_list|,
name|target
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Match brackets */
end_comment

begin_function
name|int
name|rl_vi_match
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|count
init|=
literal|1
decl_stmt|,
name|brack
decl_stmt|,
name|pos
decl_stmt|,
name|tmp
decl_stmt|,
name|pre
decl_stmt|;
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pre
operator|=
name|rl_point
expr_stmt|;
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
operator|==
name|rl_point
condition|)
break|break;
block|}
block|}
else|else
while|while
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
name|rl_forward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|brack
operator|<=
literal|0
condition|)
block|{
name|rl_point
operator|=
name|pos
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|brack
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
name|tmp
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
name|pos
operator|--
expr_stmt|;
else|else
block|{
name|pos
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|pos
condition|)
name|pos
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* brack> 0 */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
name|pos
operator|++
expr_stmt|;
else|else
name|pos
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|rl_line_buffer
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|rl_end
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|rl_point
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bracktype
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
literal|1
return|;
case|case
literal|')'
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'['
case|:
return|return
literal|2
return|;
case|case
literal|']'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|'{'
case|:
return|return
literal|3
return|;
case|case
literal|'}'
case|:
return|return
operator|-
literal|3
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_vi_change_char
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|,
name|mb
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|mb
decl_stmt|;
block|{
name|int
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\033'
operator|||
name|c
operator|==
name|CTRL
argument_list|(
literal|'C'
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|p
operator|=
name|rl_point
expr_stmt|;
name|rl_vi_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|p
condition|)
comment|/* Did we retreat at EOL? */
name|rl_point
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_insert_text
argument_list|(
name|mb
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|_rl_insert_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* The cursor shall be left on the last character changed. */
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_vi_callback_getchar
parameter_list|(
name|mb
parameter_list|,
name|mblen
parameter_list|)
name|char
modifier|*
name|mb
decl_stmt|;
name|int
name|mblen
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|c
operator|=
name|_rl_read_mbstring
argument_list|(
name|c
argument_list|,
name|mb
argument_list|,
name|mblen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_vi_callback_change_char
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
name|mb
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
name|_rl_vi_last_replacement
operator|=
name|c
operator|=
name|_rl_vi_callback_getchar
argument_list|(
name|mb
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|_rl_vi_change_char
argument_list|(
name|data
operator|->
name|count
argument_list|,
name|c
argument_list|,
name|mb
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_vi_change_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
name|mb
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
block|{
name|c
operator|=
name|_rl_vi_last_replacement
expr_stmt|;
name|mb
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|mb
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
elseif|else
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
name|_rl_callback_data_alloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_vi_callback_change_char
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
else|else
name|_rl_vi_last_replacement
operator|=
name|c
operator|=
name|_rl_vi_callback_getchar
argument_list|(
name|mb
argument_list|,
name|MB_LEN_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|_rl_vi_change_char
argument_list|(
name|count
argument_list|,
name|c
argument_list|,
name|mb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_subst
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
comment|/* If we are redoing, rl_vi_change_to will stuff the last motion char */
if|if
condition|(
name|vi_redoing
operator|==
literal|0
condition|)
name|rl_stuff_char
argument_list|(
operator|(
name|key
operator|==
literal|'S'
operator|)
condition|?
literal|'c'
else|:
literal|'l'
argument_list|)
expr_stmt|;
comment|/* `S' == `cc', `s' == `cl' */
return|return
operator|(
name|rl_vi_change_to
argument_list|(
name|count
argument_list|,
literal|'c'
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_overstrike
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|_rl_vi_doing_insert
operator|==
literal|0
condition|)
block|{
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|_rl_overwrite_char
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|vi_replace_count
operator|+=
name|count
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_overstrike_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
name|vi_replace_count
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|s
condition|)
name|rl_backward_char
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
operator|&&
name|_rl_vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_replace
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vi_replace_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|vi_replace_map
condition|)
block|{
name|vi_replace_map
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
name|KEYMAP_SIZE
condition|;
name|i
operator|++
control|)
name|vi_replace_map
index|[
name|i
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike
expr_stmt|;
name|vi_replace_map
index|[
name|RUBOUT
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
name|vi_replace_map
index|[
name|ESC
index|]
operator|.
name|function
operator|=
name|rl_vi_movement_mode
expr_stmt|;
name|vi_replace_map
index|[
name|RETURN
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
name|vi_replace_map
index|[
name|NEWLINE
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
comment|/* If the normal vi insertion keymap has ^H bound to erase, do the          same here.  Probably should remove the assignment to RUBOUT up          there, but I don't think it will make a difference in real life. */
if|if
condition|(
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|==
name|rl_rubout
condition|)
name|vi_replace_map
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
block|}
name|_rl_keymap
operator|=
name|vi_replace_map
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Try to complete the word we are standing on or the word that ends with    the previous character.  A space matches everything.  Word delimiters are    space and ;. */
end_comment

begin_endif
unit|int rl_vi_possible_completions() {   int save_pos = rl_point;    if (rl_line_buffer[rl_point] != ' '&& rl_line_buffer[rl_point] != ';')     {       while (rl_point< rl_end&& rl_line_buffer[rl_point] != ' '&& 	     rl_line_buffer[rl_point] != ';') 	rl_point++;     }   else if (rl_line_buffer[rl_point - 1] == ';')     {       rl_ding ();       return (0);     }    rl_possible_completions ();   rl_point = save_pos;    return (0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions to save and restore marks. */
end_comment

begin_function
specifier|static
name|int
name|_rl_vi_set_mark
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|'a'
operator|||
name|ch
operator|>
literal|'z'
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|-=
literal|'a'
expr_stmt|;
name|vi_mark_chars
index|[
name|ch
index|]
operator|=
name|rl_point
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_vi_callback_set_mark
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|_rl_vi_set_mark
argument_list|()
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_vi_set_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
literal|0
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_vi_callback_set_mark
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|_rl_vi_set_mark
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_vi_goto_mark
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_MOREINPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'`'
condition|)
block|{
name|rl_point
operator|=
name|rl_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|'a'
operator|||
name|ch
operator|>
literal|'z'
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|-=
literal|'a'
expr_stmt|;
if|if
condition|(
name|vi_mark_chars
index|[
name|ch
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_point
operator|=
name|vi_mark_chars
index|[
name|ch
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
specifier|static
name|int
name|_rl_vi_callback_goto_mark
parameter_list|(
name|data
parameter_list|)
name|_rl_callback_generic_arg
modifier|*
name|data
decl_stmt|;
block|{
name|_rl_callback_func
operator|=
literal|0
expr_stmt|;
name|_rl_want_redisplay
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|_rl_vi_goto_mark
argument_list|()
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rl_vi_goto_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
block|{
name|_rl_callback_data
operator|=
literal|0
expr_stmt|;
name|_rl_callback_func
operator|=
name|_rl_vi_callback_goto_mark
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|_rl_vi_goto_mark
argument_list|()
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

end_unit

