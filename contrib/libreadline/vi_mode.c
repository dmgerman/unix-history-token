begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vi_mode.c -- A vi emulation mode for Bash.    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			VI Emulation Mode			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_include
include|#
directive|include
file|"rlconf.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_rl_digit_p
end_ifndef

begin_define
define|#
directive|define
name|_rl_digit_p
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_rl_digit_value
end_ifndef

begin_define
define|#
directive|define
name|_rl_digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isident
end_ifndef

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|c
parameter_list|)
value|((_rl_pure_alphabetic (c) || _rl_digit_p (c) || c == '_'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|exchange
end_ifndef

begin_define
define|#
directive|define
name|exchange
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do {int temp = x; x = y; y = temp;} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero means enter insertion mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_doing_insert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command keys which do movement for xxx_to commands. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_motion
init|=
literal|" hl^$0ftFt;,%wbeWBE|"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap used for vi replace characters.  Created dynamically since    rarely used. */
end_comment

begin_decl_stmt
specifier|static
name|Keymap
name|vi_replace_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters inserted in the last replace operation. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_replace_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, we have text inserted after a c[motion] command that put    us implicitly into insert mode.  Some people want this text to be    attached to the command so that it is `redoable' with `.'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_continued_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_insert_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_insert_buffer_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_command
init|=
literal|'i'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default `.' puts you in insert mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_repeat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_motion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_search_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_replacement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_vi_last_key_before_insert
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_redoing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text modification commands.  These are the `redoable' commands. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_textmod
init|=
literal|"_*\\AaIiCcDdPpYyRrSsXx~"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arrays for the saved marks. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_mark_chars
index|[
literal|27
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_digit_loop1
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_rl_vi_initialize_line
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vi_mark_chars
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|vi_mark_chars
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_reset_last
parameter_list|()
block|{
name|_rl_vi_last_command
operator|=
literal|'i'
expr_stmt|;
name|_rl_vi_last_repeat
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_arg_sign
operator|=
literal|1
expr_stmt|;
name|_rl_vi_last_motion
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_set_last
parameter_list|(
name|key
parameter_list|,
name|repeat
parameter_list|,
name|sign
parameter_list|)
name|int
name|key
decl_stmt|,
name|repeat
decl_stmt|,
name|sign
decl_stmt|;
block|{
name|_rl_vi_last_command
operator|=
name|key
expr_stmt|;
name|_rl_vi_last_repeat
operator|=
name|repeat
expr_stmt|;
name|_rl_vi_last_arg_sign
operator|=
name|sign
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is the command C a VI mode text modification command? */
end_comment

begin_function
name|int
name|_rl_vi_textmod_command
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|c
argument_list|,
name|vi_textmod
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_vi_stuff_insert
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
name|rl_insert_text
argument_list|(
name|vi_insert_buffer
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bound to `.'.  Called from command mode, so we know that we have to    redo a text modification command.  The default for _rl_vi_last_command    puts you back into insert mode. */
end_comment

begin_function
name|int
name|rl_vi_redo
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|rl_explicit_arg
condition|)
block|{
name|rl_numeric_arg
operator|=
name|_rl_vi_last_repeat
expr_stmt|;
name|rl_arg_sign
operator|=
name|_rl_vi_last_arg_sign
expr_stmt|;
block|}
name|vi_redoing
operator|=
literal|1
expr_stmt|;
comment|/* If we're redoing an insert with `i', stuff in the inserted text      and do not go into insertion mode. */
if|if
condition|(
name|_rl_vi_last_command
operator|==
literal|'i'
operator|&&
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
block|{
name|_rl_vi_stuff_insert
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|/* And back up point over the last character inserted. */
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_point
operator|--
expr_stmt|;
block|}
else|else
name|_rl_dispatch
argument_list|(
name|_rl_vi_last_command
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
name|vi_redoing
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A placeholder for further expansion. */
end_comment

begin_function
name|int
name|rl_vi_undo
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_undo_command
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Yank the nth arg from the previous line into this line at point. */
end_comment

begin_function
name|int
name|rl_vi_yank_arg
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
comment|/* Readline thinks that the first word on a line is the 0th, while vi      thinks the first word on a line is the 1st.  Compensate. */
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_yank_nth_arg
argument_list|(
name|count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_yank_nth_arg
argument_list|(
literal|'$'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* With an argument, move back that many history lines, else move to the    beginning of history. */
end_comment

begin_function
name|int
name|rl_vi_fetch_history
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|wanted
decl_stmt|;
comment|/* Giving an argument of n means we want the nth command in the history      file.  The command number is interpreted the same way that the bash      `history' command does it -- that is, giving an argument count of 450      to this command would get the command listed as number 450 in the      output of `history'. */
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|wanted
operator|=
name|history_base
operator|+
name|where_history
argument_list|()
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|wanted
operator|<=
literal|0
condition|)
name|rl_beginning_of_history
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_get_previous_history
argument_list|(
name|wanted
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_beginning_of_history
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search again for the last thing searched for. */
end_comment

begin_function
name|int
name|rl_vi_search_again
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'n'
case|:
name|rl_noninc_reverse_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|rl_noninc_forward_search_again
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a vi style search. */
end_comment

begin_function
name|int
name|rl_vi_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'?'
case|:
name|rl_noninc_forward_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|rl_noninc_reverse_search
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Completion, from vi's point of view. */
end_comment

begin_function
name|int
name|rl_vi_complete
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|+
literal|1
index|]
argument_list|)
condition|)
name|rl_vi_end_word
argument_list|(
literal|1
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|'*'
condition|)
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
comment|/* Expansion and replacement. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'='
condition|)
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
comment|/* List possible completions. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
condition|)
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
comment|/* Standard Readline completion. */
else|else
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|'*'
operator|||
name|key
operator|==
literal|'\\'
condition|)
block|{
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Tilde expansion for vi mode. */
end_comment

begin_function
name|int
name|rl_vi_tilde_expand
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_tilde_expand
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
literal|1
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
comment|/* XXX */
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Previous word in vi mode. */
end_comment

begin_function
name|int
name|rl_vi_prev_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_next_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_bWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_bword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Next word in vi mode. */
end_comment

begin_function
name|int
name|rl_vi_next_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|rl_vi_prev_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
operator|)
return|;
if|if
condition|(
name|rl_point
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_fWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_fword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move to the end of the ?next? word. */
end_comment

begin_function
name|int
name|rl_vi_end_word
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_eWord
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_vi_eword
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Move forward a word the way that 'W' does. */
end_comment

begin_function
name|int
name|rl_vi_fWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Skip until whitespace. */
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Now skip whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
comment|/* If we are at the start of a word, move back to whitespace so 	 we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_eWord
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move to the next non-whitespace character (to the start of the 	 next word). */
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
comment|/* Skip whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Skip until whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move back to the last character of the word. */
name|rl_point
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_fword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Move to white space (really non-identifer). */
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
else|else
comment|/* if (!whitespace (rl_line_buffer[rl_point])) */
block|{
while|while
condition|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
comment|/* Move past whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
name|int
name|last_is_ident
decl_stmt|;
comment|/* If we are at the start of a word, move back to whitespace 	 so we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If this character and the previous character are `opposite', move 	 back so we don't get messed up by the rl_point++ down there in 	 the while loop.  Without this code, words like `l;' screw up the 	 function. */
name|last_is_ident
operator|=
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|last_is_ident
operator|)
operator|||
operator|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|last_is_ident
operator|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_eword
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_insert_beg
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_append_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_append_eol
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_end_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_vi_append_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* What to do in the case of C-d. */
end_comment

begin_function
name|int
name|rl_vi_eof_maybe
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
return|return
operator|(
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insertion mode stuff. */
end_comment

begin_comment
comment|/* Switching from one mode to the other really just involves    switching keymaps. */
end_comment

begin_function
name|int
name|rl_vi_insertion_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|_rl_keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
name|_rl_vi_last_key_before_insert
operator|=
name|key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_vi_save_insert
parameter_list|(
name|up
parameter_list|)
name|UNDO_LIST
modifier|*
name|up
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vi_insert_buffer_size
operator|>=
literal|1
condition|)
name|vi_insert_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|start
operator|=
name|up
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|up
operator|->
name|end
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|vi_insert_buffer_size
condition|)
block|{
name|vi_insert_buffer_size
operator|+=
operator|(
name|len
operator|+
literal|32
operator|)
operator|-
operator|(
name|len
operator|%
literal|32
operator|)
expr_stmt|;
name|vi_insert_buffer
operator|=
name|xrealloc
argument_list|(
name|vi_insert_buffer
argument_list|,
name|vi_insert_buffer_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|vi_insert_buffer
argument_list|,
name|rl_line_buffer
operator|+
name|start
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vi_insert_buffer
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_vi_done_inserting
parameter_list|()
block|{
if|if
condition|(
name|_rl_vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
comment|/* Now, the text between rl_undo_list->next->start and 	 rl_undo_list->next->end is what was inserted while in insert 	 mode.  It gets copied to VI_INSERT_BUFFER because it depends 	 on absolute indices into the line which may change (though they 	 probably will not). */
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
name|_rl_vi_save_insert
argument_list|(
name|rl_undo_list
operator|->
name|next
argument_list|)
expr_stmt|;
name|vi_continued_command
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_rl_vi_last_key_before_insert
operator|==
literal|'i'
operator|&&
name|rl_undo_list
condition|)
name|_rl_vi_save_insert
argument_list|(
name|rl_undo_list
argument_list|)
expr_stmt|;
comment|/* XXX - Other keys probably need to be checked. */
elseif|else
if|if
condition|(
name|_rl_vi_last_key_before_insert
operator|==
literal|'C'
condition|)
name|rl_end_undo_group
argument_list|()
expr_stmt|;
while|while
condition|(
name|_rl_undo_group_level
operator|>
literal|0
condition|)
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|vi_continued_command
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rl_vi_movement_mode
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|_rl_keymap
operator|=
name|vi_movement_keymap
expr_stmt|;
name|_rl_vi_done_inserting
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_arg_digit
parameter_list|(
name|count
parameter_list|,
name|c
parameter_list|)
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
operator|&&
name|rl_numeric_arg
operator|==
literal|1
operator|&&
operator|!
name|rl_explicit_arg
condition|)
return|return
operator|(
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rl_digit_argument
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_change_case
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
name|char
name|c
init|=
literal|0
decl_stmt|;
comment|/* Don't try this on an empty line. */
if|if
condition|(
name|rl_point
operator|>=
name|rl_end
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|_rl_to_lower
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|_rl_lowercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|_rl_to_upper
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Just skip over characters neither upper nor lower case. */
name|rl_forward
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Vi is kind of strange here. */
if|if
condition|(
name|c
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_check
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_forward
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_put
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|rl_point
operator|+
literal|1
operator|<=
name|rl_end
operator|)
condition|)
name|rl_point
operator|++
expr_stmt|;
name|rl_yank
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_backward
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_check
parameter_list|()
block|{
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_point
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_column
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|>
name|rl_end
condition|)
name|rl_end_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|rl_point
operator|=
name|count
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_domove
parameter_list|(
name|key
parameter_list|,
name|nextkey
parameter_list|)
name|int
name|key
decl_stmt|,
decl|*
name|nextkey
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
decl_stmt|;
name|int
name|old_end
decl_stmt|;
name|rl_mark
operator|=
name|rl_point
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|vi_motion
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|save
operator|=
name|rl_numeric_arg
expr_stmt|;
name|rl_numeric_arg
operator|=
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_digit_loop1
argument_list|()
expr_stmt|;
name|rl_numeric_arg
operator|*=
name|save
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* real command */
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|c
operator|&&
operator|(
name|key
operator|==
literal|'d'
operator|||
name|key
operator|==
literal|'y'
operator|||
name|key
operator|==
literal|'c'
operator|)
condition|)
block|{
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_rl_vi_last_motion
operator|=
name|c
expr_stmt|;
comment|/* Append a blank character temporarily so that the motion routines      work right at the end of the line. */
name|old_end
operator|=
name|rl_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_dispatch
argument_list|(
name|c
argument_list|,
name|_rl_keymap
argument_list|)
expr_stmt|;
comment|/* Remove the blank that we added. */
name|rl_end
operator|=
name|old_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
name|rl_end
condition|)
name|rl_point
operator|=
name|rl_end
expr_stmt|;
comment|/* No change in position means the command failed. */
if|if
condition|(
name|rl_mark
operator|==
name|rl_point
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* rl_vi_f[wW]ord () leaves the cursor on the first character of the next      word.  If we are not at the end of the line, and we are on a      non-whitespace character, move back one (presumably to whitespace). */
if|if
condition|(
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
operator|&&
name|rl_point
operator|<
name|rl_end
operator|&&
name|rl_point
operator|>
name|rl_mark
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If cw or cW, back up to the end of a word, so the behaviour of ce      or cE is the actual result.  Brute-force, no subtlety. */
if|if
condition|(
name|key
operator|==
literal|'c'
operator|&&
name|rl_point
operator|>=
name|rl_mark
operator|&&
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
condition|)
block|{
comment|/* Don't move farther back than where we started. */
while|while
condition|(
name|rl_point
operator|>
name|rl_mark
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* Posix.2 says that if cw or cW moves the cursor towards the end of 	 the line, the character under the cursor should be deleted. */
if|if
condition|(
name|rl_point
operator|==
name|rl_mark
condition|)
name|rl_point
operator|++
expr_stmt|;
else|else
block|{
comment|/* Move past the end of the word so that the kill doesn't 	     remove the last letter of the previous word.  Only do this 	     if we are not at the end of the line. */
if|if
condition|(
name|rl_point
operator|>=
literal|0
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rl_mark
operator|<
name|rl_point
condition|)
name|exchange
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* A simplified loop for vi. Don't dispatch key at end.    Don't recognize minus sign? */
end_comment

begin_function
specifier|static
name|int
name|rl_digit_loop1
parameter_list|()
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|rl_arg_sign
operator|*
name|rl_numeric_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|_rl_keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_digit_p
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
name|_rl_digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_delete_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_change_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|start_pos
decl_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vi_redoing
condition|)
name|rl_stuff_char
argument_list|(
name|_rl_vi_last_motion
argument_list|)
expr_stmt|;
name|start_pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark.  c[wW] are handled by special-case code in rl_vi_domove(),      and already leave the mark at the correct location. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|hwW^0bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
comment|/* The cursor never moves with c[wW]. */
if|if
condition|(
operator|(
name|_rl_to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
operator|&&
name|rl_point
operator|<
name|start_pos
condition|)
name|rl_point
operator|=
name|start_pos
expr_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
block|{
if|if
condition|(
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
block|{
name|rl_insert_text
argument_list|(
name|vi_insert_buffer
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
comment|/* to make the `u' command work */
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
comment|/* `C' does not save the text inserted for undoing or redoing. */
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
operator|==
literal|0
condition|)
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
name|count
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_yank_to
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|save
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the motion commands that do not require adjusting the      mark. */
if|if
condition|(
operator|(
name|strchr
argument_list|(
literal|" l|h^0%bB"
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rl_mark
operator|<
name|rl_end
operator|)
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|rl_end
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|end
operator|=
name|rl_point
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|rl_end
condition|)
name|end
operator|=
name|rl_end
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_back_to_indent
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_first_print
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
operator|(
name|rl_vi_back_to_indent
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_char_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
specifier|static
name|char
name|target
decl_stmt|;
specifier|static
name|int
name|orig_dir
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|';'
operator|||
name|key
operator|==
literal|','
condition|)
name|dir
operator|=
name|key
operator|==
literal|';'
condition|?
name|orig_dir
else|:
operator|-
name|orig_dir
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vi_redoing
condition|)
name|target
operator|=
name|_rl_vi_last_search_char
expr_stmt|;
else|else
name|_rl_vi_last_search_char
operator|=
name|target
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'t'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FTO
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BTO
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FFIND
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BFIND
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|_rl_char_search_internal
argument_list|(
name|count
argument_list|,
name|dir
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Match brackets */
end_comment

begin_function
name|int
name|rl_vi_match
parameter_list|(
name|ignore
parameter_list|,
name|key
parameter_list|)
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|count
init|=
literal|1
decl_stmt|,
name|brack
decl_stmt|,
name|pos
decl_stmt|;
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
name|rl_forward
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|brack
operator|<=
literal|0
condition|)
block|{
name|rl_point
operator|=
name|pos
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|brack
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* brack> 0 */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|++
name|pos
operator|<
name|rl_end
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|rl_point
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_bracktype
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
literal|1
return|;
case|case
literal|')'
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'['
case|:
return|return
literal|2
return|;
case|case
literal|']'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|'{'
case|:
return|return
literal|3
return|;
case|case
literal|'}'
case|:
return|return
operator|-
literal|3
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|rl_vi_change_char
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
name|c
operator|=
name|_rl_vi_last_replacement
expr_stmt|;
else|else
name|_rl_vi_last_replacement
operator|=
name|c
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\033'
operator|||
name|c
operator|==
name|CTRL
argument_list|(
literal|'C'
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_subst
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|rl_beg_of_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_kill_line
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_delete_text
argument_list|(
name|rl_point
argument_list|,
name|rl_point
operator|+
name|count
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|_rl_vi_set_last
argument_list|(
name|key
argument_list|,
name|count
argument_list|,
name|rl_arg_sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_redoing
condition|)
block|{
name|int
name|o
init|=
name|_rl_doing_an_undo
decl_stmt|;
name|_rl_doing_an_undo
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vi_insert_buffer
operator|&&
operator|*
name|vi_insert_buffer
condition|)
name|rl_insert_text
argument_list|(
name|vi_insert_buffer
argument_list|)
expr_stmt|;
name|_rl_doing_an_undo
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_overstrike
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|_rl_vi_doing_insert
operator|==
literal|0
condition|)
block|{
name|_rl_vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vi_replace_count
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_overstrike_delete
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
name|vi_replace_count
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|s
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
operator|&&
name|_rl_vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|_rl_vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_replace
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vi_replace_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|vi_replace_map
condition|)
block|{
name|vi_replace_map
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
name|KEYMAP_SIZE
condition|;
name|i
operator|++
control|)
name|vi_replace_map
index|[
name|i
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike
expr_stmt|;
name|vi_replace_map
index|[
name|RUBOUT
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
name|vi_replace_map
index|[
name|ESC
index|]
operator|.
name|function
operator|=
name|rl_vi_movement_mode
expr_stmt|;
name|vi_replace_map
index|[
name|RETURN
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
name|vi_replace_map
index|[
name|NEWLINE
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
comment|/* If the normal vi insertion keymap has ^H bound to erase, do the          same here.  Probably should remove the assignment to RUBOUT up          there, but I don't think it will make a difference in real life. */
if|if
condition|(
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|==
name|rl_rubout
condition|)
name|vi_replace_map
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
block|}
name|_rl_keymap
operator|=
name|vi_replace_map
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Try to complete the word we are standing on or the word that ends with    the previous character.  A space matches everything.  Word delimiters are    space and ;. */
end_comment

begin_endif
unit|int rl_vi_possible_completions() {   int save_pos = rl_point;    if (rl_line_buffer[rl_point] != ' '&& rl_line_buffer[rl_point] != ';')     {       while (rl_point< rl_end&& rl_line_buffer[rl_point] != ' '&& 	     rl_line_buffer[rl_point] != ';') 	rl_point++;     }   else if (rl_line_buffer[rl_point - 1] == ';')     {       ding ();       return (0);     }    rl_possible_completions ();   rl_point = save_pos;    return (0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions to save and restore marks. */
end_comment

begin_function
name|int
name|rl_vi_set_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|_rl_lowercase_p
argument_list|(
name|ch
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|-=
literal|'a'
expr_stmt|;
name|vi_mark_chars
index|[
name|ch
index|]
operator|=
name|rl_point
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_vi_goto_mark
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'`'
condition|)
block|{
name|rl_point
operator|=
name|rl_mark
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|_rl_lowercase_p
argument_list|(
name|ch
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|-=
literal|'a'
expr_stmt|;
if|if
condition|(
name|vi_mark_chars
index|[
name|ch
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rl_point
operator|=
name|vi_mark_chars
index|[
name|ch
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

end_unit

