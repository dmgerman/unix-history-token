begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */
end_comment

begin_comment
comment|/* Copyright (C) 1988,1989 Free Software Foundation, Inc.     This file is part of GNU Readline, a library for reading lines    of text with interactive input and history editing.     Readline is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     Readline is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with Readline; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_MINIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_PWD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tilde.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
operator|||
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST || STATIC_MALLOC */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_GETPW_DECLS
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWUID
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
name|PARAMS
argument_list|(
operator|(
name|uid_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWNAM
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_GETPW_DECLS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|savestring
argument_list|)
end_if

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
value|strcpy ((char *)xmalloc (1 + strlen (x)), (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !savestring */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|((void *) 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NULL */
end_comment

begin_comment
comment|/* If being compiled as part of bash, these will be satisfied from    variables.o.  If being compiled as part of readline, they will    be satisfied from shell.o. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sh_get_home_dir
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sh_get_env_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default value of tilde_additional_prefixes.  This is set to    whitespace preceding a tilde so that simple programs which do not    perform any word separation get desired behaviour. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_prefixes
index|[]
init|=
block|{
literal|" ~"
block|,
literal|"\t~"
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default value of tilde_additional_suffixes.  This is set to    whitespace or newline so that simple programs which do not    perform any word separation get desired behaviour. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_suffixes
index|[]
init|=
block|{
literal|" "
block|,
literal|"\n"
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, this contains the address of a function that the application    wants called before trying the standard tilde expansions.  The function    is called with the text sans tilde, and returns a malloc()'ed string    which is the expansion, or a NULL pointer if the expansion fails. */
end_comment

begin_decl_stmt
name|tilde_hook_func_t
modifier|*
name|tilde_expansion_preexpansion_hook
init|=
operator|(
name|tilde_hook_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, this contains the address of a function to call if the    standard meaning for expanding a tilde fails.  The function is called    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string    which is the expansion, or a NULL pointer if there is no expansion. */
end_comment

begin_decl_stmt
name|tilde_hook_func_t
modifier|*
name|tilde_expansion_failure_hook
init|=
operator|(
name|tilde_hook_func_t
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-null, this is a NULL terminated array of strings which    are duplicates for a tilde prefix.  Bash uses this to expand    `=~' and `:~'. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tilde_additional_prefixes
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|default_prefixes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-null, this is a NULL terminated array of strings which match    the end of a username, instead of just "/".  Bash sets this to    `:' and `=~'. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tilde_additional_suffixes
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|default_suffixes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tilde_find_prefix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tilde_find_suffix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|isolate_tilde_prefix
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|glue_prefix_and_suffix
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the start of a tilde expansion in STRING, and return the index of    the tilde which starts the expansion.  Place the length of the text    which identified this tilde starter in LEN, excluding the tilde itself. */
end_comment

begin_function
specifier|static
name|int
name|tilde_find_prefix
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|string_len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|prefixes
decl_stmt|;
name|prefixes
operator|=
name|tilde_additional_prefixes
expr_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
operator|||
operator|*
name|string
operator|==
literal|'~'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|prefixes
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_len
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|prefixes
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|prefixes
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|prefixes
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|prefixes
index|[
name|j
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|+
operator|*
name|len
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|string_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the end of a tilde expansion in STRING, and return the index of    the character which ends the tilde definition.  */
end_comment

begin_function
specifier|static
name|int
name|tilde_find_suffix
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|string_len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|suffixes
decl_stmt|;
name|suffixes
operator|=
name|tilde_additional_suffixes
expr_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_len
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'/'
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
comment|/* || !string[i] */
condition|)
else|#
directive|else
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'/'
comment|/* || !string[i] */
condition|)
endif|#
directive|endif
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|suffixes
operator|&&
name|suffixes
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|suffixes
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|suffixes
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new string which is the result of tilde expanding STRING. */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|result_size
decl_stmt|,
name|result_index
decl_stmt|;
name|result_index
operator|=
name|result_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'~'
argument_list|)
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
operator|=
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
operator|=
operator|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Scan through STRING expanding tildes as we come to them. */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|tilde_word
decl_stmt|,
modifier|*
name|expansion
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Make START point to the tilde which starts the expansion. */
name|start
operator|=
name|tilde_find_prefix
argument_list|(
name|string
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the skipped text into the result. */
if|if
condition|(
operator|(
name|result_index
operator|+
name|start
operator|+
literal|1
operator|)
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
literal|1
operator|+
operator|(
name|result_size
operator|+=
operator|(
name|start
operator|+
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
operator|+
name|result_index
argument_list|,
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|result_index
operator|+=
name|start
expr_stmt|;
comment|/* Advance STRING to the starting tilde. */
name|string
operator|+=
name|start
expr_stmt|;
comment|/* Make END be the index of one after the last character of the 	 username. */
name|end
operator|=
name|tilde_find_suffix
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* If both START and END are zero, we are all done. */
if|if
condition|(
operator|!
name|start
operator|&&
operator|!
name|end
condition|)
break|break;
comment|/* Expand the entire tilde word, and copy it into RESULT. */
name|tilde_word
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|end
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tilde_word
argument_list|,
name|string
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|tilde_word
index|[
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string
operator|+=
name|end
expr_stmt|;
name|expansion
operator|=
name|tilde_expand_word
argument_list|(
name|tilde_word
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tilde_word
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__CYGWIN__
comment|/* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when 	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
if|if
condition|(
name|len
operator|>
literal|1
operator|||
operator|*
name|expansion
operator|!=
literal|'/'
operator|||
operator|*
name|string
operator|!=
literal|'/'
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|result_index
operator|+
name|len
operator|+
literal|1
operator|)
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
literal|1
operator|+
operator|(
name|result_size
operator|+=
operator|(
name|len
operator|+
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|result_index
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|result_index
operator|+=
name|len
expr_stmt|;
block|}
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Take FNAME and return the tilde prefix we want expanded.  If LENP is    non-null, the index of the end of the prefix into FNAME is returned in    the location it points to. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|isolate_tilde_prefix
parameter_list|(
name|fname
parameter_list|,
name|lenp
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|fname
index|[
name|i
index|]
operator|&&
name|fname
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|fname
index|[
name|i
index|]
operator|!=
literal|'\\'
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|fname
index|[
name|i
index|]
operator|&&
name|fname
index|[
name|i
index|]
operator|!=
literal|'/'
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
name|ret
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|fname
index|[
name|i
index|]
expr_stmt|;
name|ret
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|i
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Public function to scan a string (FNAME) beginning with a tilde and find    the portion of the string that should be passed to the tilde expansion    function.  Right now, it just calls tilde_find_suffix and allocates new    memory, but it can be expanded to do different things later. */
end_comment

begin_endif
unit|char * tilde_find_word (fname, flags, lenp)      const char *fname;      int flags, *lenp; {   int x;   char *r;    x = tilde_find_suffix (fname);   if (x == 0)     {       r = savestring (fname);       if (lenp) 	*lenp = 0;     }   else     {       r = (char *)xmalloc (1 + x);       strncpy (r, fname, x);       r[x] = '\0';       if (lenp) 	*lenp = x;     }    return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a string that is PREFIX concatenated with SUFFIX starting at    SUFFIND. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|glue_prefix_and_suffix
parameter_list|(
name|prefix
parameter_list|,
name|suffix
parameter_list|,
name|suffind
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|suffind
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|slen
decl_stmt|;
name|plen
operator|=
operator|(
name|prefix
operator|&&
operator|*
name|prefix
operator|)
condition|?
name|strlen
argument_list|(
name|prefix
argument_list|)
else|:
literal|0
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|suffix
operator|+
name|suffind
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|plen
operator|+
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
condition|)
name|strcpy
argument_list|(
name|ret
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|+
name|plen
argument_list|,
name|suffix
operator|+
name|suffind
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a    tilde.  If there is no expansion, call tilde_expansion_failure_hook.    This always returns a newly-allocated string, never static storage. */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand_word
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|expansion
decl_stmt|,
modifier|*
name|username
decl_stmt|;
name|int
name|user_len
decl_stmt|;
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|filename
operator|!=
literal|'~'
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
comment|/* A leading `~/' or a bare `~' is *always* translated to the value of      $HOME or the home directory of the current user, regardless of any      preexpansion hook. */
if|if
condition|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Prefix $HOME to the rest of the string. */
name|expansion
operator|=
name|sh_get_env_value
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
comment|/* If there is no HOME variable, look up the directory in 	 the password database. */
if|if
condition|(
name|expansion
operator|==
literal|0
condition|)
name|expansion
operator|=
name|sh_get_home_dir
argument_list|()
expr_stmt|;
return|return
operator|(
name|glue_prefix_and_suffix
argument_list|(
name|expansion
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
name|username
operator|=
name|isolate_tilde_prefix
argument_list|(
name|filename
argument_list|,
operator|&
name|user_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tilde_expansion_preexpansion_hook
condition|)
block|{
name|expansion
operator|=
call|(
modifier|*
name|tilde_expansion_preexpansion_hook
call|)
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
block|{
name|dirname
operator|=
name|glue_prefix_and_suffix
argument_list|(
name|expansion
argument_list|,
name|filename
argument_list|,
name|user_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirname
operator|)
return|;
block|}
block|}
comment|/* No preexpansion hook, or the preexpansion hook failed.  Look in the      password database. */
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWNAM
argument_list|)
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
else|#
directive|else
name|user_entry
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|user_entry
operator|==
literal|0
condition|)
block|{
comment|/* If the calling program has a special syntax for expanding tildes, 	 and we couldn't find a standard expansion, then let them try. */
if|if
condition|(
name|tilde_expansion_failure_hook
condition|)
block|{
name|expansion
operator|=
call|(
modifier|*
name|tilde_expansion_failure_hook
call|)
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
block|{
name|dirname
operator|=
name|glue_prefix_and_suffix
argument_list|(
name|expansion
argument_list|,
name|filename
argument_list|,
name|user_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we don't have a failure hook, or if the failure hook did not 	 expand the tilde, return a copy of what we were passed. */
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
name|dirname
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWENT
argument_list|)
else|else
name|dirname
operator|=
name|glue_prefix_and_suffix
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|,
name|filename
argument_list|,
name|user_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPWENT
argument_list|)
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|dirname
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
name|line
index|[
literal|512
index|]
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"~expand: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gets
argument_list|(
name|line
argument_list|)
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"exit"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|tilde_expand
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  --> %s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|size_t
name|bytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: out of virtual memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local variables:  * compile-command: "gcc -g -DTEST -o tilde tilde.c"  * end:  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

