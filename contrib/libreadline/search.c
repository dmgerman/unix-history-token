begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* search.c - code for non-incremental searching in emacs and vi modes. */
end_comment

begin_comment
comment|/* Copyright (C) 1992-2005 Free Software Foundation, Inc.     This file is part of the Readline Library (the Library), a set of    routines for providing Emacs style line input to programs that ask    for it.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|abs
end_ifdef

begin_undef
undef|#
directive|undef
name|abs
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|(((x)>= 0) ? (x) : -(x))
end_define

begin_decl_stmt
name|_rl_search_cxt
modifier|*
name|_rl_nscxt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HIST_ENTRY
modifier|*
name|_rl_saved_line_for_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions imported from the rest of the library. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|_rl_free_history_entry
name|PARAMS
argument_list|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noninc_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noninc_history_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_line_found
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_history_search_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_history_search_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_search_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_string_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_history_line_current
name|PARAMS
argument_list|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noninc_search_from_pos
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noninc_dosearch
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noninc_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rl_history_search_internal
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rl_history_search_reinit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|_rl_search_cxt
modifier|*
name|_rl_nsearch_init
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_nsearch_cleanup
name|PARAMS
argument_list|(
operator|(
name|_rl_search_cxt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_rl_nsearch_abort
name|PARAMS
argument_list|(
operator|(
name|_rl_search_cxt
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_rl_nsearch_dispatch
name|PARAMS
argument_list|(
operator|(
name|_rl_search_cxt
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the data from the history entry ENTRY be the contents of the    current line.  This doesn't do anything with rl_point; the caller    must set it. */
end_comment

begin_function
specifier|static
name|void
name|make_history_line_current
parameter_list|(
name|entry
parameter_list|)
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
block|{
name|_rl_replace_text
argument_list|(
name|entry
operator|->
name|line
argument_list|,
literal|0
argument_list|,
name|rl_end
argument_list|)
expr_stmt|;
name|_rl_fix_point
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|==
name|vi_mode
condition|)
comment|/* POSIX.2 says that the `U' command doesn't affect the copy of any        command lines to the edit line.  We're going to implement that by        making the undo list start after the matching line is copied to the        current editing buffer. */
name|rl_free_undo_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_rl_saved_line_for_history
condition|)
name|_rl_free_history_entry
argument_list|(
name|_rl_saved_line_for_history
argument_list|)
expr_stmt|;
name|_rl_saved_line_for_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search the history list for STRING starting at absolute history position    POS.  If STRING begins with `^', the search must match STRING at the    beginning of a history line, otherwise a full substring match is performed    for STRING.  DIR< 0 means to search backwards through the history list,    DIR>= 0 means to search forward. */
end_comment

begin_function
specifier|static
name|int
name|noninc_search_from_pos
parameter_list|(
name|string
parameter_list|,
name|pos
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|dir
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|old
operator|=
name|where_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|history_set_pos
argument_list|(
name|pos
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'^'
condition|)
name|ret
operator|=
name|history_search_prefix
argument_list|(
name|string
operator|+
literal|1
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for a line in the history containing STRING.  If DIR is< 0, the    search is backwards through previous entries, else through subsequent    entries.  Returns 1 if the search was successful, 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|noninc_dosearch
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|int
name|oldpos
decl_stmt|,
name|pos
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
operator|||
operator|*
name|string
operator|==
literal|'\0'
operator|||
name|noninc_history_pos
operator|<
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pos
operator|=
name|noninc_search_from_pos
argument_list|(
name|string
argument_list|,
name|noninc_history_pos
operator|+
name|dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Search failed, current history position unchanged. */
name|rl_maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|noninc_history_pos
operator|=
name|pos
expr_stmt|;
name|oldpos
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|noninc_history_pos
argument_list|)
expr_stmt|;
name|entry
operator|=
name|current_history
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
if|if
condition|(
name|rl_editing_mode
operator|!=
name|vi_mode
condition|)
endif|#
directive|endif
name|history_set_pos
argument_list|(
name|oldpos
argument_list|)
expr_stmt|;
name|make_history_line_current
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|_rl_search_cxt
modifier|*
name|_rl_nsearch_init
parameter_list|(
name|dir
parameter_list|,
name|pchar
parameter_list|)
name|int
name|dir
decl_stmt|,
name|pchar
decl_stmt|;
block|{
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|cxt
operator|=
name|_rl_scxt_alloc
argument_list|(
name|RL_SEARCH_NSEARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|cxt
operator|->
name|sflags
operator||=
name|SF_REVERSE
expr_stmt|;
comment|/* not strictly needed */
name|cxt
operator|->
name|direction
operator|=
name|dir
expr_stmt|;
name|cxt
operator|->
name|history_pos
operator|=
name|cxt
operator|->
name|save_line
expr_stmt|;
name|rl_maybe_save_line
argument_list|()
expr_stmt|;
comment|/* Clear the undo list, since reading the search string should create its      own undo list, and the whole list will end up being freed when we      finish reading the search string. */
name|rl_undo_list
operator|=
literal|0
expr_stmt|;
comment|/* Use the line buffer to read the search string. */
name|rl_line_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|_rl_make_prompt_for_search
argument_list|(
name|pchar
condition|?
name|pchar
else|:
literal|':'
argument_list|)
expr_stmt|;
name|rl_message
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|RL_SETSTATE
argument_list|(
name|RL_STATE_NSEARCH
argument_list|)
expr_stmt|;
name|_rl_nscxt
operator|=
name|cxt
expr_stmt|;
return|return
name|cxt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_nsearch_cleanup
parameter_list|(
name|cxt
parameter_list|,
name|r
parameter_list|)
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|_rl_scxt_dispose
argument_list|(
name|cxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_rl_nscxt
operator|=
literal|0
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_NSEARCH
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|!=
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_nsearch_abort
parameter_list|(
name|cxt
parameter_list|)
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
block|{
name|rl_maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|cxt
operator|->
name|save_point
expr_stmt|;
name|rl_mark
operator|=
name|cxt
operator|->
name|save_mark
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_NSEARCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process just-read character C according to search context CXT.  Return -1    if the caller should abort the search, 0 if we should break out of the    loop, and 1 if we should continue to read characters. */
end_comment

begin_function
specifier|static
name|int
name|_rl_nsearch_dispatch
parameter_list|(
name|cxt
parameter_list|,
name|c
parameter_list|)
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
name|rl_unix_word_rubout
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'U'
argument_list|)
case|:
name|rl_unix_line_discard
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
case|case
name|NEWLINE
case|:
return|return
literal|0
return|;
case|case
name|CTRL
argument_list|(
literal|'H'
argument_list|)
case|:
case|case
name|RUBOUT
case|:
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|_rl_nsearch_abort
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|_rl_rubout_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'C'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'G'
argument_list|)
case|:
name|rl_ding
argument_list|()
expr_stmt|;
name|_rl_nsearch_abort
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|rl_insert_text
argument_list|(
name|cxt
operator|->
name|mb
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|_rl_insert_char
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform one search according to CXT, using NONINC_SEARCH_STRING.  Return    -1 if the search should be aborted, any other value means to clean up    using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,    0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|_rl_nsearch_dosearch
parameter_list|(
name|cxt
parameter_list|)
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
block|{
name|rl_mark
operator|=
name|cxt
operator|->
name|save_mark
expr_stmt|;
comment|/* If rl_point == 0, we want to re-use the previous search string and      start from the saved history position.  If there's no previous search      string, punt. */
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|noninc_search_string
operator|==
literal|0
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|RL_UNSETSTATE
argument_list|(
name|RL_STATE_NSEARCH
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* We want to start the search from the current history position. */
name|noninc_history_pos
operator|=
name|cxt
operator|->
name|save_line
expr_stmt|;
name|FREE
argument_list|(
name|noninc_search_string
argument_list|)
expr_stmt|;
name|noninc_search_string
operator|=
name|savestring
argument_list|(
name|rl_line_buffer
argument_list|)
expr_stmt|;
comment|/* If we don't want the subsequent undo list generated by the search 	 matching a history line to include the contents of the search string, 	 we need to clear rl_line_buffer here.  For now, we just clear the 	 undo list generated by reading the search string.  (If the search 	 fails, the old undo list will be restored by rl_maybe_unsave_line.) */
name|rl_free_undo_list
argument_list|()
expr_stmt|;
block|}
name|rl_restore_prompt
argument_list|()
expr_stmt|;
return|return
operator|(
name|noninc_dosearch
argument_list|(
name|noninc_search_string
argument_list|,
name|cxt
operator|->
name|direction
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search non-interactively through the history list.  DIR< 0 means to    search backwards through the history of previous commands; otherwise    the search is for commands subsequent to the current position in the    history list.  PCHAR is the character to use for prompting when reading    the search string; if not specified (0), it defaults to `:'. */
end_comment

begin_function
specifier|static
name|int
name|noninc_search
parameter_list|(
name|dir
parameter_list|,
name|pchar
parameter_list|)
name|int
name|dir
decl_stmt|;
name|int
name|pchar
decl_stmt|;
block|{
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
name|cxt
operator|=
name|_rl_nsearch_init
argument_list|(
name|dir
argument_list|,
name|pchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|RL_ISSTATE
argument_list|(
name|RL_STATE_CALLBACK
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read the search string. */
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|_rl_search_getchar
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|r
operator|=
name|_rl_nsearch_dispatch
argument_list|(
name|cxt
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
block|}
name|r
operator|=
name|_rl_nsearch_dosearch
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|r
operator|>=
literal|0
operator|)
condition|?
name|_rl_nsearch_cleanup
argument_list|(
name|cxt
argument_list|,
name|r
argument_list|)
else|:
operator|(
name|r
operator|!=
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search forward through the history list for a string.  If the vi-mode    code calls this, KEY will be `?'. */
end_comment

begin_function
name|int
name|rl_noninc_forward_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
name|noninc_search
argument_list|(
literal|1
argument_list|,
operator|(
name|key
operator|==
literal|'?'
operator|)
condition|?
literal|'?'
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reverse search the history list for a string.  If the vi-mode code    calls this, KEY will be `/'. */
end_comment

begin_function
name|int
name|rl_noninc_reverse_search
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
return|return
name|noninc_search
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
name|key
operator|==
literal|'/'
operator|)
condition|?
literal|'/'
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search forward through the history list for the last string searched    for.  If there is no saved search string, abort. */
end_comment

begin_function
name|int
name|rl_noninc_forward_search_again
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|noninc_search_string
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|noninc_dosearch
argument_list|(
name|noninc_search_string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|!=
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reverse search in the history list for the last string searched    for.  If there is no saved search string, abort. */
end_comment

begin_function
name|int
name|rl_noninc_reverse_search_again
parameter_list|(
name|count
parameter_list|,
name|key
parameter_list|)
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|noninc_search_string
condition|)
block|{
name|rl_ding
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|noninc_dosearch
argument_list|(
name|noninc_search_string
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|!=
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|READLINE_CALLBACKS
argument_list|)
end_if

begin_function
name|int
name|_rl_nsearch_callback
parameter_list|(
name|cxt
parameter_list|)
name|_rl_search_cxt
modifier|*
name|cxt
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
name|c
operator|=
name|_rl_search_getchar
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
name|r
operator|=
name|_rl_nsearch_dispatch
argument_list|(
name|cxt
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|r
operator|=
name|_rl_nsearch_dosearch
argument_list|(
name|cxt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|r
operator|>=
literal|0
operator|)
condition|?
name|_rl_nsearch_cleanup
argument_list|(
name|cxt
argument_list|,
name|r
argument_list|)
else|:
operator|(
name|r
operator|!=
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|rl_history_search_internal
parameter_list|(
name|count
parameter_list|,
name|dir
parameter_list|)
name|int
name|count
decl_stmt|,
name|dir
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|oldpos
decl_stmt|;
name|rl_maybe_save_line
argument_list|()
expr_stmt|;
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Search COUNT times through the history for a line whose prefix      matches history_search_string.  When this loop finishes, TEMP,      if non-null, is the history line to copy into the line buffer. */
while|while
condition|(
name|count
condition|)
block|{
name|ret
operator|=
name|noninc_search_from_pos
argument_list|(
name|history_search_string
argument_list|,
name|rl_history_search_pos
operator|+
name|dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Get the history entry we found. */
name|rl_history_search_pos
operator|=
name|ret
expr_stmt|;
name|oldpos
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|rl_history_search_pos
argument_list|)
expr_stmt|;
name|temp
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|oldpos
argument_list|)
expr_stmt|;
comment|/* Don't find multiple instances of the same line. */
if|if
condition|(
name|prev_line_found
operator|&&
name|STREQ
argument_list|(
name|prev_line_found
argument_list|,
name|temp
operator|->
name|line
argument_list|)
condition|)
continue|continue;
name|prev_line_found
operator|=
name|temp
operator|->
name|line
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
comment|/* If we didn't find anything at all, return. */
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
name|rl_maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_ding
argument_list|()
expr_stmt|;
comment|/* If you don't want the saved history line (last match) to show up          in the line buffer after the search fails, change the #if 0 to          #if 1 */
if|#
directive|if
literal|0
block|if (rl_point> rl_history_search_len)         {           rl_point = rl_end = rl_history_search_len;           rl_line_buffer[rl_end] = '\0';           rl_mark = 0;         }
else|#
directive|else
name|rl_point
operator|=
name|rl_history_search_len
expr_stmt|;
comment|/* rl_maybe_unsave_line changes it */
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* Copy the line we found into the current line buffer. */
name|make_history_line_current
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|rl_point
operator|=
name|rl_history_search_len
expr_stmt|;
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rl_history_search_reinit
parameter_list|()
block|{
name|rl_history_search_pos
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|rl_history_search_len
operator|=
name|rl_point
expr_stmt|;
name|prev_line_found
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|rl_point
condition|)
block|{
if|if
condition|(
name|rl_history_search_len
operator|>=
name|history_string_size
operator|-
literal|2
condition|)
block|{
name|history_string_size
operator|=
name|rl_history_search_len
operator|+
literal|2
expr_stmt|;
name|history_search_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|history_search_string
argument_list|,
name|history_string_size
argument_list|)
expr_stmt|;
block|}
name|history_search_string
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|strncpy
argument_list|(
name|history_search_string
operator|+
literal|1
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|history_search_string
index|[
name|rl_point
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|_rl_free_saved_history_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search forward in the history for the string of characters    from the start of the line to rl_point.  This is a non-incremental    search. */
end_comment

begin_function
name|int
name|rl_history_search_forward
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rl_last_func
operator|!=
name|rl_history_search_forward
operator|&&
name|rl_last_func
operator|!=
name|rl_history_search_backward
condition|)
name|rl_history_search_reinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_history_search_len
operator|==
literal|0
condition|)
return|return
operator|(
name|rl_get_next_history
argument_list|(
name|count
argument_list|,
name|ignore
argument_list|)
operator|)
return|;
return|return
operator|(
name|rl_history_search_internal
argument_list|(
name|abs
argument_list|(
name|count
argument_list|)
argument_list|,
operator|(
name|count
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search backward through the history for the string of characters    from the start of the line to rl_point.  This is a non-incremental    search. */
end_comment

begin_function
name|int
name|rl_history_search_backward
parameter_list|(
name|count
parameter_list|,
name|ignore
parameter_list|)
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rl_last_func
operator|!=
name|rl_history_search_forward
operator|&&
name|rl_last_func
operator|!=
name|rl_history_search_backward
condition|)
name|rl_history_search_reinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_history_search_len
operator|==
literal|0
condition|)
return|return
operator|(
name|rl_get_previous_history
argument_list|(
name|count
argument_list|,
name|ignore
argument_list|)
operator|)
return|;
return|return
operator|(
name|rl_history_search_internal
argument_list|(
name|abs
argument_list|(
name|count
argument_list|)
argument_list|,
operator|(
name|count
operator|>
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

