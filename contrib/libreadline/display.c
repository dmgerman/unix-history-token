begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* display.c -- readline redisplay facility. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_comment
comment|/* Termcap library stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcap.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|term_forward_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|update_line
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|space_to_eol
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_chars
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_some_chars
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cr
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|inv_lbreaks
decl_stmt|,
modifier|*
name|vis_lbreaks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inv_lbsize
decl_stmt|,
name|vis_lbsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Heuristic used to decide whether it is faster to move from CUR to NEW    by backing up or outputting a carriage return and moving forward. */
end_comment

begin_define
define|#
directive|define
name|CR_FASTER
parameter_list|(
name|new
parameter_list|,
name|cur
parameter_list|)
value|(((new) + 1)< ((cur) - (new)))
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Display stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is the stuff that is hard for me.  I never seem to write good    display routines in C.  Let's see how I do this time. */
end_comment

begin_comment
comment|/* (PWP) Well... Good for a simple line updater, but totally ignores    the problems of input lines longer than the screen width.     update_line and the code that calls it makes a multiple line,    automatically wrapping line update.  Careful attention needs    to be paid to the vertical position variables. */
end_comment

begin_comment
comment|/* Keep two buffers; one which reflects the current contents of the    screen, and the other to draw what we think the new contents should    be.  Then compare the buffers, and make whatever changes to the    screen itself that we should.  Finally, make the buffer that we    just drew into be the one which reflects the current contents of the    screen, and place the cursor where it belongs.     Commands that want to can fix the display themselves, and then let    this function know that the display has been fixed by setting the    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
end_comment

begin_comment
comment|/* Application-specific redisplay function. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|rl_redisplay_function
init|=
name|rl_redisplay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables declared here. */
end_comment

begin_comment
comment|/* What YOU turn on when you have handled all redisplay yourself. */
end_comment

begin_decl_stmt
name|int
name|rl_display_fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_suppress_redisplay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stuff that gets printed out before the actual text of the line.    This is usually pointing to rl_prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_display_prompt
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global variables declared here. */
end_comment

begin_comment
comment|/* The visible cursor position.  If you print some text, adjust this. */
end_comment

begin_decl_stmt
name|int
name|_rl_last_c_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_last_v_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines currently on screen minus 1. */
end_comment

begin_decl_stmt
name|int
name|_rl_vis_botlin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used only in this file. */
end_comment

begin_comment
comment|/* The last left edge of text that was displayed.  This is used when    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_lmargin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line display buffers.  One is the line currently displayed on    the screen.  The other is the line about to be displayed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|invisible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer for `modeline' messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msg_buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero forces the redisplay even if we thought it was unnecessary. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forced_display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default and initial buffer size.  Can grow. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_prompt
decl_stmt|,
modifier|*
name|local_prompt_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|visible_length
decl_stmt|,
name|prefix_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of invisible characters in the line currently being    displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_wrap_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static so it can be shared between rl_redisplay and update_line */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index of the last invisible_character in the prompt string. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_invisible
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length (buffer offset) of the first line of the last (possibly    multi-line) buffer displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_first_line_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the prompt string S and return the number of visible    characters in *LP, if LP is not null.  This is currently more-or-less    a placeholder for expansion.  LIP, if non-null is a place to store the    index of the last invisible character in the returned string. */
end_comment

begin_comment
comment|/* Current implementation: 	\001 (^A) start non-visible characters 	\002 (^B) end non-visible characters    all characters except \001 and \002 (following a \001) are copied to    the returned string; all characters except those between \001 and    \002 are assumed to be `visible'. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|expand_prompt
parameter_list|(
name|pmt
parameter_list|,
name|lp
parameter_list|,
name|lip
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
name|int
modifier|*
name|lp
decl_stmt|,
decl|*
name|lip
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|rl
decl_stmt|,
name|last
decl_stmt|,
name|ignoring
decl_stmt|;
comment|/* Short-circuit if we can. */
if|if
condition|(
name|strchr
argument_list|(
name|pmt
argument_list|,
name|RL_PROMPT_START_IGNORE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|rl
operator|=
name|ignoring
operator|=
name|last
operator|=
literal|0
operator|,
name|p
operator|=
name|pmt
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* This code strips the invisible character string markers 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
if|if
condition|(
operator|*
name|p
operator|==
name|RL_PROMPT_START_IGNORE
condition|)
block|{
name|ignoring
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignoring
operator|&&
operator|*
name|p
operator|==
name|RL_PROMPT_END_IGNORE
condition|)
block|{
name|ignoring
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|r
operator|-
name|ret
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
operator|*
name|r
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ignoring
condition|)
name|rl
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|rl
expr_stmt|;
if|if
condition|(
name|lip
condition|)
operator|*
name|lip
operator|=
name|last
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from    PMT and return the rest of PMT. */
end_comment

begin_function
name|char
modifier|*
name|_rl_strip_prompt
parameter_list|(
name|pmt
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|expand_prompt
argument_list|(
name|pmt
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the prompt string into the various display components, if  * necessary.  *  * local_prompt = expanded last line of string in rl_display_prompt  *		  (portion after the final newline)  * local_prompt_prefix = portion before last newline of rl_display_prompt,  *			 expanded via expand_prompt  * visible_length = number of visible characters in local_prompt  * prefix_length = number of visible characters in local_prompt_prefix  *  * This function is called once per call to readline().  It may also be  * called arbitrarily to expand the primary prompt.  *  * The return value is the number of visible characters on the last line  * of the (possibly multi-line) prompt.  */
end_comment

begin_function
name|int
name|rl_expand_prompt
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Clear out any saved values. */
if|if
condition|(
name|local_prompt
condition|)
name|free
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_prompt_prefix
condition|)
name|free
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|last_invisible
operator|=
name|visible_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
literal|0
operator|||
operator|*
name|prompt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|/* The prompt is only one line. */
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|visible_length
argument_list|,
operator|&
name|last_invisible
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|visible_length
operator|)
return|;
block|}
else|else
block|{
comment|/* The prompt spans multiple lines. */
name|t
operator|=
operator|++
name|p
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|p
argument_list|,
operator|&
name|visible_length
argument_list|,
operator|&
name|last_invisible
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* The portion of the prompt string up to and including the 	 final newline is now null-terminated. */
name|local_prompt_prefix
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|prefix_length
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|prefix_length
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated    arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE    and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is    increased.  If the lines have already been allocated, this ensures that    they can hold at least MINSIZE characters. */
end_comment

begin_function
specifier|static
name|void
name|init_line_structures
parameter_list|(
name|minsize
parameter_list|)
name|int
name|minsize
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|invisible_line
operator|==
literal|0
condition|)
comment|/* initialize it */
block|{
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
name|line_size
operator|=
name|minsize
expr_stmt|;
name|visible_line
operator|=
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
comment|/* ensure it can hold MINSIZE chars */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
name|line_size
operator|=
name|minsize
expr_stmt|;
name|visible_line
operator|=
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|minsize
init|;
name|n
operator|<
name|line_size
condition|;
name|n
operator|++
control|)
block|{
name|visible_line
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|invisible_line
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vis_lbreaks
operator|==
literal|0
condition|)
block|{
comment|/* should be enough. */
name|inv_lbsize
operator|=
name|vis_lbsize
operator|=
literal|256
expr_stmt|;
name|inv_lbreaks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|inv_lbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vis_lbreaks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|vis_lbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|inv_lbreaks
index|[
literal|0
index|]
operator|=
name|vis_lbreaks
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Basic redisplay algorithm. */
end_comment

begin_function
name|void
name|rl_redisplay
parameter_list|()
block|{
specifier|register
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|c
decl_stmt|,
name|linenum
decl_stmt|,
name|cursor_linenum
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|c_pos
decl_stmt|,
name|inv_botlin
decl_stmt|,
name|lb_botlin
decl_stmt|,
name|lb_linenum
decl_stmt|;
name|int
name|newlines
decl_stmt|,
name|lpos
decl_stmt|,
name|temp
decl_stmt|;
name|char
modifier|*
name|prompt_this_line
decl_stmt|;
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_display_prompt
condition|)
name|rl_display_prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|invisible_line
operator|==
literal|0
condition|)
block|{
name|init_line_structures
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
comment|/* Draw the line into the buffer. */
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
name|out
operator|=
name|inv_botlin
operator|=
literal|0
expr_stmt|;
comment|/* Mark the line as modified or not.  We only do this for history      lines. */
if|if
condition|(
name|_rl_mark_modified_lines
operator|&&
name|current_history
argument_list|()
operator|&&
name|rl_undo_list
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If someone thought that the redisplay was handled, but the currently      visible line has a different modification state than the one about      to become visible, then correct the caller's misconception. */
if|if
condition|(
name|visible_line
index|[
literal|0
index|]
operator|!=
name|invisible_line
index|[
literal|0
index|]
condition|)
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If the prompt to be displayed is the `primary' readline prompt (the      one passed to readline()), use the values we have already expanded.      If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the      number of non-visible characters in the prompt string. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
operator|||
name|local_prompt
condition|)
block|{
name|int
name|local_len
init|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|local_prompt_prefix
operator|&&
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|local_prompt_prefix
argument_list|,
name|strlen
argument_list|(
name|local_prompt_prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_len
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|local_len
operator|+
name|out
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|line_size
condition|)
block|{
name|line_size
operator|=
operator|(
name|temp
operator|+
literal|1024
operator|)
operator|-
operator|(
name|temp
operator|%
literal|1024
operator|)
expr_stmt|;
name|visible_line
operator|=
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
operator|=
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|local_prompt
argument_list|,
name|local_len
argument_list|)
expr_stmt|;
name|out
operator|+=
name|local_len
expr_stmt|;
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
name|local_len
operator|-
name|visible_length
expr_stmt|;
block|}
else|else
block|{
name|int
name|pmtlen
decl_stmt|;
name|prompt_this_line
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_this_line
condition|)
name|prompt_this_line
operator|=
name|rl_display_prompt
expr_stmt|;
else|else
block|{
name|prompt_this_line
operator|++
expr_stmt|;
name|pmtlen
operator|=
name|prompt_this_line
operator|-
name|rl_display_prompt
expr_stmt|;
comment|/* temp var */
if|if
condition|(
name|forced_display
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|rl_display_prompt
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
comment|/* Make sure we are at column zero even after a newline, 		 regardless of the state of terminal output processing. */
if|if
condition|(
name|pmtlen
operator|<
literal|2
operator|||
name|prompt_this_line
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\r'
condition|)
name|cr
argument_list|()
expr_stmt|;
block|}
block|}
name|pmtlen
operator|=
name|strlen
argument_list|(
name|prompt_this_line
argument_list|)
expr_stmt|;
name|temp
operator|=
name|pmtlen
operator|+
name|out
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|line_size
condition|)
block|{
name|line_size
operator|=
operator|(
name|temp
operator|+
literal|1024
operator|)
operator|-
operator|(
name|temp
operator|%
literal|1024
operator|)
expr_stmt|;
name|visible_line
operator|=
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
operator|=
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|prompt_this_line
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
name|out
operator|+=
name|pmtlen
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
literal|0
expr_stmt|;
block|}
define|#
directive|define
name|CHECK_INV_LBREAKS
parameter_list|()
define|\
value|do { \ 	if (newlines>= (inv_lbsize - 2)) \ 	  { \ 	    inv_lbsize *= 2; \ 	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \ 	  } \       } while (0)
define|#
directive|define
name|CHECK_LPOS
parameter_list|()
define|\
value|do { \ 	lpos++; \ 	if (lpos>= screenwidth) \ 	  { \ 	    if (newlines>= (inv_lbsize - 2)) \ 	      { \ 		inv_lbsize *= 2; \ 		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \ 	      } \ 	    inv_lbreaks[++newlines] = out; \ 	    lpos = 0; \ 	  } \       } while (0)
comment|/* inv_lbreaks[i] is where line i starts in the buffer. */
name|inv_lbreaks
index|[
name|newlines
operator|=
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lpos
operator|=
name|out
operator|-
name|wrap_offset
expr_stmt|;
comment|/* XXX - what if lpos is already>= screenwidth before we start drawing the      contents of the command line? */
while|while
condition|(
name|lpos
operator|>=
name|screenwidth
condition|)
block|{
comment|/* XXX - possible fix from Darin Johnson<darin@acuson.com> for prompt 	 string with invisible characters that is longer than the screen 	 width.  XXX - this doesn't work right if invisible characters have 	 to be put on the second screen line -- it adds too much (the number 	 of invisible chars after the screenwidth). */
name|temp
operator|=
operator|(
operator|(
name|newlines
operator|+
literal|1
operator|)
operator|*
name|screenwidth
operator|)
operator|+
operator|(
operator|(
name|newlines
operator|==
literal|0
operator|)
condition|?
name|wrap_offset
else|:
literal|0
operator|)
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|temp
expr_stmt|;
name|lpos
operator|-=
name|screenwidth
expr_stmt|;
block|}
name|lb_linenum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|rl_line_buffer
index|[
name|in
index|]
expr_stmt|;
if|if
condition|(
name|out
operator|+
literal|8
operator|>=
name|line_size
condition|)
comment|/* XXX - 8 for \t */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
name|visible_line
operator|=
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
block|{
name|c_pos
operator|=
name|out
expr_stmt|;
name|lb_linenum
operator|=
name|newlines
expr_stmt|;
block|}
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|_rl_output_meta_chars
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
operator|+
name|out
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpos
operator|+
literal|4
operator|>=
name|screenwidth
condition|)
block|{
name|temp
operator|=
name|screenwidth
operator|-
name|lpos
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
operator|+
name|temp
expr_stmt|;
name|lpos
operator|=
literal|4
operator|-
name|temp
expr_stmt|;
block|}
else|else
name|lpos
operator|+=
literal|4
expr_stmt|;
name|out
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
specifier|register
name|int
name|temp
decl_stmt|,
name|newout
decl_stmt|;
if|#
directive|if
literal|0
block|newout = (out | (int)7) + 1;
else|#
directive|else
name|newout
operator|=
name|out
operator|+
literal|8
operator|-
name|lpos
operator|%
literal|8
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|newout
operator|-
name|out
expr_stmt|;
if|if
condition|(
name|lpos
operator|+
name|temp
operator|>=
name|screenwidth
condition|)
block|{
specifier|register
name|int
name|temp2
decl_stmt|;
name|temp2
operator|=
name|screenwidth
operator|-
name|lpos
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
operator|+
name|temp2
expr_stmt|;
name|lpos
operator|=
name|temp
operator|-
name|temp2
expr_stmt|;
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|lpos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|_rl_horizontal_scroll_mode
operator|==
literal|0
operator|&&
name|term_up
operator|&&
operator|*
name|term_up
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX - sentinel */
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
expr_stmt|;
name|lpos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|?
name|UNCTRL
argument_list|(
name|c
argument_list|)
else|:
literal|'?'
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c_pos
operator|<
literal|0
condition|)
block|{
name|c_pos
operator|=
name|out
expr_stmt|;
name|lb_linenum
operator|=
name|newlines
expr_stmt|;
block|}
name|inv_botlin
operator|=
name|lb_botlin
operator|=
name|newlines
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
name|newlines
operator|+
literal|1
index|]
operator|=
name|out
expr_stmt|;
name|cursor_linenum
operator|=
name|lb_linenum
expr_stmt|;
comment|/* C_POS == position in buffer where cursor should be placed. */
comment|/* PWP: now is when things get a bit hairy.  The visible and invisible      line buffers are really multiple lines, which would wrap every      (screenwidth - 1) characters.  Go through each in turn, finding      the changed region and updating it.  The line order is top to bottom. */
comment|/* If we can move the cursor up and down, then use multiple lines,      otherwise, let long lines display in a single terminal line, and      horizontally scroll it. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|==
literal|0
operator|&&
name|term_up
operator|&&
operator|*
name|term_up
condition|)
block|{
name|int
name|nleft
decl_stmt|,
name|pos
decl_stmt|,
name|changed_screen_line
decl_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than a screenful of material to display, then 	     only display a screenful.  We should display the last screen, 	     not the first.  */
if|if
condition|(
name|out
operator|>=
name|screenchars
condition|)
name|out
operator|=
name|screenchars
operator|-
literal|1
expr_stmt|;
comment|/* The first line is at character position 0 in the buffer.  The 	     second and subsequent lines start at inv_lbreaks[N], offset by 	     OFFSET (which has already been calculated above).  */
define|#
directive|define
name|W_OFFSET
parameter_list|(
name|line
parameter_list|,
name|offset
parameter_list|)
value|((line) == 0 ? offset : 0)
define|#
directive|define
name|VIS_LLEN
parameter_list|(
name|l
parameter_list|)
value|((l)> _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
define|#
directive|define
name|INV_LLEN
parameter_list|(
name|l
parameter_list|)
value|(inv_lbreaks[l+1] - inv_lbreaks[l])
define|#
directive|define
name|VIS_CHARS
parameter_list|(
name|line
parameter_list|)
value|(visible_line + vis_lbreaks[line])
define|#
directive|define
name|VIS_LINE
parameter_list|(
name|line
parameter_list|)
value|((line)> _rl_vis_botlin) ? "" : VIS_CHARS(line)
define|#
directive|define
name|INV_LINE
parameter_list|(
name|line
parameter_list|)
value|(invisible_line + inv_lbreaks[line])
comment|/* For each line in the buffer, do the updating display. */
for|for
control|(
name|linenum
operator|=
literal|0
init|;
name|linenum
operator|<=
name|inv_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|update_line
argument_list|(
name|VIS_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|linenum
argument_list|,
name|VIS_LLEN
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LLEN
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|inv_botlin
argument_list|)
expr_stmt|;
comment|/* If this is the line with the prompt, we might need to 		 compensate for invisible characters in the new line. Do 		 this only if there is not more than one new line (which 		 implies that we completely overwrite the old visible line) 		 and the new line is shorter than the old.  Make sure we are 		 at the end of the new line before clearing. */
if|if
condition|(
name|linenum
operator|==
literal|0
operator|&&
name|inv_botlin
operator|==
literal|0
operator|&&
name|_rl_last_c_pos
operator|==
name|out
operator|&&
operator|(
name|wrap_offset
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|<
name|visible_first_line_len
operator|)
condition|)
block|{
name|nleft
operator|=
name|screenwidth
operator|+
name|wrap_offset
operator|-
name|_rl_last_c_pos
expr_stmt|;
if|if
condition|(
name|nleft
condition|)
name|_rl_clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
comment|/* Since the new first line is now visible, save its length. */
if|if
condition|(
name|linenum
operator|==
literal|0
condition|)
name|visible_first_line_len
operator|=
operator|(
name|inv_botlin
operator|>
literal|0
operator|)
condition|?
name|inv_lbreaks
index|[
literal|1
index|]
else|:
name|out
operator|-
name|wrap_offset
expr_stmt|;
block|}
comment|/* We may have deleted some lines.  If so, clear the left over 	     blank ones at the bottom out. */
if|if
condition|(
name|_rl_vis_botlin
operator|>
name|inv_botlin
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
for|for
control|(
init|;
name|linenum
operator|<=
name|_rl_vis_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|tt
operator|=
name|VIS_CHARS
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
operator|(
name|linenum
operator|==
name|_rl_vis_botlin
operator|)
condition|?
name|strlen
argument_list|(
name|tt
argument_list|)
else|:
name|screenwidth
argument_list|)
expr_stmt|;
block|}
block|}
name|_rl_vis_botlin
operator|=
name|inv_botlin
expr_stmt|;
comment|/* CHANGED_SCREEN_LINE is set to 1 if we have moved to a 	     different screen line during this redisplay. */
name|changed_screen_line
operator|=
name|_rl_last_v_pos
operator|!=
name|cursor_linenum
expr_stmt|;
if|if
condition|(
name|changed_screen_line
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|cursor_linenum
argument_list|)
expr_stmt|;
comment|/* If we moved up to the line with the prompt using term_up, 		 the physical cursor position on the screen stays the same, 		 but the buffer position needs to be adjusted to account 		 for invisible characters. */
if|if
condition|(
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
condition|)
name|_rl_last_c_pos
operator|+=
name|wrap_offset
expr_stmt|;
block|}
comment|/* We have to reprint the prompt if it contains invisible 	     characters, since it's not generally OK to just reprint 	     the characters from the current cursor position.  But we 	     only need to reprint it if the cursor is before the last 	     invisible character in the prompt string. */
name|nleft
operator|=
name|visible_length
operator|+
name|wrap_offset
expr_stmt|;
if|if
condition|(
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|<=
name|last_invisible
operator|&&
name|local_prompt
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|term_cr
condition|)
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|nleft
expr_stmt|;
block|}
comment|/* Where on that line?  And where does that line start 	     in the buffer? */
name|pos
operator|=
name|inv_lbreaks
index|[
name|cursor_linenum
index|]
expr_stmt|;
comment|/* nleft == number of characters in the line buffer between the 	     start of the line and the cursor position. */
name|nleft
operator|=
name|c_pos
operator|-
name|pos
expr_stmt|;
comment|/* Since _rl_backspace() doesn't know about invisible characters in the 	     prompt, and there's no good way to tell it, we compensate for 	     those characters here and call _rl_backspace() directly. */
if|if
condition|(
name|wrap_offset
operator|&&
name|cursor_linenum
operator|==
literal|0
operator|&&
name|nleft
operator|<
name|_rl_last_c_pos
condition|)
block|{
name|_rl_backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|nleft
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|nleft
expr_stmt|;
block|}
if|if
condition|(
name|nleft
operator|!=
name|_rl_last_c_pos
condition|)
name|_rl_move_cursor_relative
argument_list|(
name|nleft
argument_list|,
operator|&
name|invisible_line
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Do horizontal scrolling. */
block|{
define|#
directive|define
name|M_OFFSET
parameter_list|(
name|margin
parameter_list|,
name|offset
parameter_list|)
value|((margin) == 0 ? offset : 0)
name|int
name|lmargin
decl_stmt|,
name|ndisp
decl_stmt|,
name|nleft
decl_stmt|,
name|phys_c_pos
decl_stmt|,
name|t
decl_stmt|;
comment|/* Always at top line. */
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
comment|/* Compute where in the buffer the displayed line should start.  This 	 will be LMARGIN. */
comment|/* The number of characters that will be displayed before the cursor. */
name|ndisp
operator|=
name|c_pos
operator|-
name|wrap_offset
expr_stmt|;
name|nleft
operator|=
name|visible_length
operator|+
name|wrap_offset
expr_stmt|;
comment|/* Where the new cursor position will be on the screen.  This can be 	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
name|phys_c_pos
operator|=
name|c_pos
operator|-
operator|(
name|last_lmargin
condition|?
name|last_lmargin
else|:
name|wrap_offset
operator|)
expr_stmt|;
name|t
operator|=
name|screenwidth
operator|/
literal|3
expr_stmt|;
comment|/* If the number of characters had already exceeded the screenwidth, 	 last_lmargin will be> 0. */
comment|/* If the number of characters to be displayed is more than the screen 	 width, compute the starting offset so that the cursor is about 	 two-thirds of the way across the screen. */
if|if
condition|(
name|phys_c_pos
operator|>
name|screenwidth
operator|-
literal|2
condition|)
block|{
name|lmargin
operator|=
name|c_pos
operator|-
operator|(
literal|2
operator|*
name|t
operator|)
expr_stmt|;
if|if
condition|(
name|lmargin
operator|<
literal|0
condition|)
name|lmargin
operator|=
literal|0
expr_stmt|;
comment|/* If the left margin would be in the middle of a prompt with 	     invisible characters, don't display the prompt at all. */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndisp
operator|<
name|screenwidth
operator|-
literal|2
condition|)
comment|/* XXX - was -1 */
name|lmargin
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|phys_c_pos
operator|<
literal|1
condition|)
block|{
comment|/* If we are moving back towards the beginning of the line and 	     the last margin is no longer correct, compute a new one. */
name|lmargin
operator|=
operator|(
operator|(
name|c_pos
operator|-
literal|1
operator|)
operator|/
name|t
operator|)
operator|*
name|t
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
else|else
name|lmargin
operator|=
name|last_lmargin
expr_stmt|;
comment|/* If the first character on the screen isn't the first character 	 in the display line, indicate this with a special character. */
if|if
condition|(
name|lmargin
operator|>
literal|0
condition|)
name|line
index|[
name|lmargin
index|]
operator|=
literal|'<'
expr_stmt|;
comment|/* If SCREENWIDTH characters starting at LMARGIN do not encompass 	 the whole line, indicate that with a special character at the 	 right edge of the screen.  If LMARGIN is 0, we need to take the 	 wrap offset into account. */
name|t
operator|=
name|lmargin
operator|+
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|+
name|screenwidth
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|out
condition|)
name|line
index|[
name|t
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
operator|||
name|lmargin
operator|!=
name|last_lmargin
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
operator|&
name|visible_line
index|[
name|last_lmargin
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|,
literal|0
argument_list|,
name|screenwidth
operator|+
name|visible_wrap_offset
argument_list|,
name|screenwidth
operator|+
operator|(
name|lmargin
condition|?
literal|0
else|:
name|wrap_offset
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the visible new line is shorter than the old, but the number 	     of invisible characters is greater, and we are at the end of 	     the new line, we need to clear to eol. */
name|t
operator|=
name|_rl_last_c_pos
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|==
name|out
operator|)
operator|&&
name|t
operator|<
name|visible_first_line_len
condition|)
block|{
name|nleft
operator|=
name|screenwidth
operator|-
name|t
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
name|visible_first_line_len
operator|=
name|out
operator|-
name|lmargin
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible_first_line_len
operator|>
name|screenwidth
condition|)
name|visible_first_line_len
operator|=
name|screenwidth
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|c_pos
operator|-
name|lmargin
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
name|lmargin
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
comment|/* Swap visible and non-visible lines. */
block|{
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
name|int
modifier|*
name|itemp
init|=
name|vis_lbreaks
decl_stmt|,
name|ntemp
init|=
name|vis_lbsize
decl_stmt|;
name|visible_line
operator|=
name|invisible_line
expr_stmt|;
name|invisible_line
operator|=
name|temp
expr_stmt|;
name|vis_lbreaks
operator|=
name|inv_lbreaks
expr_stmt|;
name|inv_lbreaks
operator|=
name|itemp
expr_stmt|;
name|vis_lbsize
operator|=
name|inv_lbsize
expr_stmt|;
name|inv_lbsize
operator|=
name|ntemp
expr_stmt|;
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If we are displaying on a single line, and last_lmargin is> 0, we        are not displaying any invisible characters, so set visible_wrap_offset        to 0. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|last_lmargin
condition|)
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
else|else
name|visible_wrap_offset
operator|=
name|wrap_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PWP: update_line() is based on finding the middle difference of each    line on the screen; vis:  			     /old first difference 	/beginning of line   |	      /old last same       /old EOL 	v		     v	      v		    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^	^			   ^ 	\beginning of line   |	\new last same	   \new end of line 			     \new first difference     All are character pointers for the sake of speed.  Special cases for    no differences, as well as for end of line additions must be handled.     Could be made even smarter, but this works well enough */
end_comment

begin_function
specifier|static
name|void
name|update_line
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|current_line
parameter_list|,
name|omax
parameter_list|,
name|nmax
parameter_list|,
name|inv_botlin
parameter_list|)
specifier|register
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|current_line
decl_stmt|,
name|omax
decl_stmt|,
name|nmax
decl_stmt|,
name|inv_botlin
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|lendiff
decl_stmt|,
name|wsatend
decl_stmt|,
name|od
decl_stmt|,
name|nd
decl_stmt|;
name|int
name|current_invis_chars
decl_stmt|;
comment|/* If we're at the right edge of a terminal that supports xn, we're      ready to wrap around, so do so.  This fixes problems with knowing      the exact cursor position and cut-and-paste with certain terminal      emulators.  In this calculation, TEMP is the physical screen      position of the cursor. */
name|temp
operator|=
name|_rl_last_c_pos
operator|-
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|visible_wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|screenwidth
operator|&&
name|_rl_term_autowrap
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_v_pos
operator|==
name|current_line
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|new
index|[
literal|0
index|]
condition|)
name|putc
argument_list|(
name|new
index|[
literal|0
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|_rl_last_v_pos
operator|++
expr_stmt|;
if|if
condition|(
name|old
index|[
literal|0
index|]
operator|&&
name|new
index|[
literal|0
index|]
condition|)
name|old
index|[
literal|0
index|]
operator|=
name|new
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Find first difference. */
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|omax
operator|)
operator|&&
operator|*
name|ofd
operator|&&
operator|(
operator|*
name|ofd
operator|==
operator|*
name|nfd
operator|)
condition|;
name|ofd
operator|++
operator|,
name|nfd
operator|++
control|)
empty_stmt|;
comment|/* Move to the end of the screen line.  ND and OD are used to keep track      of the distance between ne and new and oe and old, respectively, to      move a subtraction out of each loop. */
for|for
control|(
name|od
operator|=
name|ofd
operator|-
name|old
operator|,
name|oe
operator|=
name|ofd
init|;
name|od
operator|<
name|omax
operator|&&
operator|*
name|oe
condition|;
name|oe
operator|++
operator|,
name|od
operator|++
control|)
empty_stmt|;
for|for
control|(
name|nd
operator|=
name|nfd
operator|-
name|new
operator|,
name|ne
operator|=
name|nfd
init|;
name|nd
operator|<
name|nmax
operator|&&
operator|*
name|ne
condition|;
name|ne
operator|++
operator|,
name|nd
operator|++
control|)
empty_stmt|;
comment|/* If no difference, continue to next line. */
if|if
condition|(
name|ofd
operator|==
name|oe
operator|&&
name|nfd
operator|==
name|ne
condition|)
return|return;
name|wsatend
operator|=
literal|1
expr_stmt|;
comment|/* flag for trailing whitespace */
name|ols
operator|=
name|oe
operator|-
literal|1
expr_stmt|;
comment|/* find last same */
name|nls
operator|=
name|ne
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
name|ols
operator|==
operator|*
name|nls
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ols
operator|!=
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|--
expr_stmt|;
name|nls
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wsatend
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ols
operator|!=
operator|*
name|nls
condition|)
block|{
if|if
condition|(
operator|*
name|ols
condition|)
comment|/* don't step past the NUL */
name|ols
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nls
condition|)
name|nls
operator|++
expr_stmt|;
block|}
comment|/* count of invisible characters in the current invisible line. */
name|current_invis_chars
operator|=
name|W_OFFSET
argument_list|(
name|current_line
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|!=
name|current_line
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
name|visible_wrap_offset
condition|)
name|_rl_last_c_pos
operator|+=
name|visible_wrap_offset
expr_stmt|;
block|}
comment|/* If this is the first line and there are invisible characters in the      prompt string, and the prompt string has not changed, and the current      cursor position is before the last invisible character in the prompt,      and the index of the character to move to is past the end of the prompt      string, then redraw the entire prompt string.  We can only do this      reliably if the terminal supports a `cr' capability.       This is not an efficiency hack -- there is a problem with redrawing      portions of the prompt string if they contain terminal escape      sequences (like drawing the `unbold' sequence without a corresponding      `bold') that manifests itself on certain terminals. */
name|lendiff
operator|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|od
operator|=
name|ofd
operator|-
name|old
expr_stmt|;
comment|/* index of first difference in visible line */
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|term_cr
operator|&&
name|lendiff
operator|>
name|visible_length
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
name|od
operator|>
name|lendiff
operator|&&
name|_rl_last_c_pos
operator|<
name|last_invisible
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|lendiff
expr_stmt|;
block|}
name|_rl_move_cursor_relative
argument_list|(
name|od
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* if (len (new)> len (old)) */
name|lendiff
operator|=
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
operator|(
name|ols
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/* If we are changing the number of invisible characters in a line, and      the spot of first difference is before the end of the invisible chars,      lendiff needs to be adjusted. */
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|current_invis_chars
operator|!=
name|visible_wrap_offset
condition|)
name|lendiff
operator|+=
name|visible_wrap_offset
operator|-
name|current_invis_chars
expr_stmt|;
comment|/* Insert (diff (len (old), len (new)) ch. */
name|temp
operator|=
name|ne
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|lendiff
operator|>
literal|0
condition|)
block|{
comment|/* Non-zero if we're increasing the number of lines. */
name|int
name|gl
init|=
name|current_line
operator|>=
name|_rl_vis_botlin
operator|&&
name|inv_botlin
operator|>
name|_rl_vis_botlin
decl_stmt|;
comment|/* Sometimes it is cheaper to print the characters rather than 	 use the terminal's capabilities.  If we're growing the number 	 of lines, make sure we actually cause the new line to wrap 	 around on auto-wrapping terminals. */
if|if
condition|(
name|terminal_can_insert
operator|&&
operator|(
operator|(
literal|2
operator|*
name|temp
operator|)
operator|>=
name|lendiff
operator|||
name|term_IC
operator|)
operator|&&
operator|(
operator|!
name|_rl_term_autowrap
operator|||
operator|!
name|gl
operator|)
condition|)
block|{
comment|/* If lendiff> visible_length and _rl_last_c_pos == 0 and 	     _rl_horizontal_scroll_mode == 1, inserting the characters with 	     term_IC or term_ic will screw up the screen because of the 	     invisible characters.  We need to just draw them. */
if|if
condition|(
operator|*
name|ols
operator|&&
operator|(
operator|!
name|_rl_horizontal_scroll_mode
operator|||
name|_rl_last_c_pos
operator|>
literal|0
operator|||
name|lendiff
operator|<=
name|visible_length
operator|||
operator|!
name|current_invis_chars
operator|)
condition|)
block|{
name|insert_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ols
operator|==
literal|0
condition|)
block|{
comment|/* At the end of a line the characters do not have to 		 be "inserted".  They can just be placed on the screen. */
comment|/* However, this screws up the rest of this block, which 		 assumes you've done the insert because you can. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|lendiff
expr_stmt|;
block|}
else|else
block|{
comment|/* We have horizontal scrolling and we are not inserting at 		 the end.  We have invisible characters in this line.  This 		 is a dumb update. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
return|return;
block|}
comment|/* Copy (new) chars to screen from first diff to last match. */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|-
name|lendiff
operator|)
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
operator|+
name|lendiff
argument_list|,
name|temp
operator|-
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
operator|-
name|lendiff
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot insert chars, write to EOL */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
else|else
comment|/* Delete characters from line. */
block|{
comment|/* If possible and inexpensive to use terminal deletion, then do so. */
if|if
condition|(
name|term_dc
operator|&&
operator|(
literal|2
operator|*
name|temp
operator|)
operator|>=
operator|-
name|lendiff
condition|)
block|{
comment|/* If all we're doing is erasing the invisible characters in the 	     prompt string, don't bother.  It screws up the assumptions 	     about what's on the screen. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_c_pos
operator|==
literal|0
operator|&&
operator|-
name|lendiff
operator|==
name|visible_wrap_offset
condition|)
name|lendiff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lendiff
condition|)
name|delete_chars
argument_list|(
operator|-
name|lendiff
argument_list|)
expr_stmt|;
comment|/* delete (diff) characters */
comment|/* Copy (new) chars to screen from first diff to last match */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Otherwise, print over the existing material. */
else|else
block|{
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|temp
expr_stmt|;
block|}
name|lendiff
operator|=
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
expr_stmt|;
if|if
condition|(
name|lendiff
condition|)
block|{
if|if
condition|(
name|_rl_term_autowrap
operator|&&
name|current_line
operator|<
name|inv_botlin
condition|)
name|space_to_eol
argument_list|(
name|lendiff
argument_list|)
expr_stmt|;
else|else
name|_rl_clear_to_eol
argument_list|(
name|lendiff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Tell the update routines that we have moved onto a new (empty) line. */
end_comment

begin_function
name|int
name|rl_on_new_line
parameter_list|()
block|{
if|if
condition|(
name|visible_line
condition|)
name|visible_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
name|_rl_vis_botlin
operator|=
name|last_lmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vis_lbreaks
condition|)
name|vis_lbreaks
index|[
literal|0
index|]
operator|=
name|vis_lbreaks
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tell the update routines that we have moved onto a new line with the    prompt already displayed.  Code originally from the version of readline    distributed with CLISP. */
end_comment

begin_function
name|int
name|rl_on_new_line_with_prompt
parameter_list|()
block|{
name|int
name|prompt_size
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|real_screenwidth
decl_stmt|,
name|newlines
decl_stmt|;
name|char
modifier|*
name|prompt_last_line
decl_stmt|;
comment|/* Initialize visible_line and invisible_line to ensure that they can hold      the already-displayed prompt. */
name|prompt_size
operator|=
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
operator|+
literal|1
expr_stmt|;
name|init_line_structures
argument_list|(
name|prompt_size
argument_list|)
expr_stmt|;
comment|/* Make sure the line structures hold the already-displayed prompt for      redisplay. */
name|strcpy
argument_list|(
name|visible_line
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|invisible_line
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
comment|/* If the prompt contains newlines, take the last tail. */
name|prompt_last_line
operator|=
name|strrchr
argument_list|(
name|rl_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_last_line
condition|)
name|prompt_last_line
operator|=
name|rl_prompt
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|prompt_last_line
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|l
expr_stmt|;
comment|/* Dissect prompt_last_line into screen lines. Note that here we have      to use the real screenwidth. Readline's notion of screenwidth might be      one less, see terminal.c. */
name|real_screenwidth
operator|=
name|screenwidth
operator|+
operator|(
name|_rl_term_autowrap
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|_rl_last_v_pos
operator|=
name|l
operator|/
name|real_screenwidth
expr_stmt|;
comment|/* If the prompt length is a multiple of real_screenwidth, we don't know      whether the cursor is at the end of the last line, or already at the      beginning of the next line. Output a newline just to be safe. */
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
operator|(
name|l
operator|%
name|real_screenwidth
operator|)
operator|==
literal|0
condition|)
name|_rl_output_some_chars
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
literal|0
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|l
condition|)
block|{
name|_rl_vis_botlin
operator|=
name|newlines
expr_stmt|;
name|vis_lbreaks
index|[
name|newlines
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|+=
name|real_screenwidth
expr_stmt|;
block|}
name|vis_lbreaks
index|[
name|newlines
index|]
operator|=
name|l
expr_stmt|;
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Actually update the display, period. */
end_comment

begin_function
name|int
name|rl_forced_update_display
parameter_list|()
block|{
if|if
condition|(
name|visible_line
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
while|while
condition|(
operator|*
name|temp
condition|)
operator|*
name|temp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|forced_display
operator|++
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.    DATA is the contents of the screen line of interest; i.e., where    the movement is being done. */
end_comment

begin_function
name|void
name|_rl_move_cursor_relative
parameter_list|(
name|new
parameter_list|,
name|data
parameter_list|)
name|int
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we don't have to do anything, then return. */
if|if
condition|(
name|_rl_last_c_pos
operator|==
name|new
condition|)
return|return;
comment|/* It may be faster to output a CR, and then move forwards instead      of moving backwards. */
comment|/* i == current physical cursor position. */
name|i
operator|=
name|_rl_last_c_pos
operator|-
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|visible_wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|CR_FASTER
argument_list|(
name|new
argument_list|,
name|_rl_last_c_pos
argument_list|)
operator|||
operator|(
name|_rl_term_autowrap
operator|&&
name|i
operator|==
name|screenwidth
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__MSDOS__ */
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_rl_last_c_pos
operator|<
name|new
condition|)
block|{
comment|/* Move the cursor forward.  We do it by printing the command 	 to move the cursor forward if there is one, else print that 	 portion of the output buffer again.  Which is cheaper? */
comment|/* The above comment is left here for posterity.  It is faster 	 to print one character (non-control) than to print a control 	 sequence telling the terminal to move forward one character. 	 That kind of control is for people who don't know what the 	 data is underneath the cursor. */
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
if|if
condition|(
name|term_forward_char
condition|)
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_forward_char
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|i
operator|=
name|_rl_last_c_pos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
block|}
elseif|else
if|if
condition|(
name|_rl_last_c_pos
operator|>
name|new
condition|)
name|_rl_backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|new
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PWP: move the cursor up or down. */
end_comment

begin_function
name|void
name|_rl_move_vert
parameter_list|(
name|to
parameter_list|)
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|==
name|to
operator|||
name|to
operator|>
name|screenheight
condition|)
return|return;
if|if
condition|(
operator|(
name|delta
operator|=
name|to
operator|-
name|_rl_last_v_pos
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* delta< 0 */
if|if
condition|(
name|term_up
operator|&&
operator|*
name|term_up
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|delta
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|term_up
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
name|_rl_last_v_pos
operator|=
name|to
expr_stmt|;
comment|/* Now TO is here */
block|}
end_function

begin_comment
comment|/* Physically print C on rl_outstream.  This is for functions which know    how to optimize the display.  Return the number of characters output. */
end_comment

begin_function
name|int
name|rl_show_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
if|if
condition|(
operator|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
else|#
directive|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"C-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|?
name|UNCTRL
argument_list|(
name|c
argument_list|)
else|:
literal|'?'
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|unsigned
name|char
name|uc
decl_stmt|;
name|uc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|uc
argument_list|)
condition|)
return|return
operator|(
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|?
literal|4
else|:
literal|1
operator|)
return|;
if|if
condition|(
name|uc
operator|==
literal|'\t'
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
return|return
operator|(
operator|(
operator|(
name|pos
operator||
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|pos
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|}
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
operator|(
name|isprint
argument_list|(
name|uc
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to print things in the "echo-area".  The prompt is treated as a    mini-modeline. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_VARARGS
argument_list|)
end_if

begin_function
name|int
if|#
directive|if
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
name|rl_message
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|rl_message
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PREFER_VARARGS
argument_list|)
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_VARARGS */
end_comment

begin_function
name|int
name|rl_message
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_VARARGS */
end_comment

begin_comment
comment|/* How to clear things from the "echo-area". */
end_comment

begin_function
name|int
name|rl_clear_message
parameter_list|()
block|{
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_reset_line_state
parameter_list|()
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
expr_stmt|;
name|forced_display
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_local_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_local_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_last_invisible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_visible_length
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rl_save_prompt
parameter_list|()
block|{
name|saved_local_prompt
operator|=
name|local_prompt
expr_stmt|;
name|saved_local_prefix
operator|=
name|local_prompt_prefix
expr_stmt|;
name|saved_last_invisible
operator|=
name|last_invisible
expr_stmt|;
name|saved_visible_length
operator|=
name|visible_length
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|last_invisible
operator|=
name|visible_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_restore_prompt
parameter_list|()
block|{
if|if
condition|(
name|local_prompt
condition|)
name|free
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_prompt_prefix
condition|)
name|free
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|saved_local_prompt
expr_stmt|;
name|local_prompt_prefix
operator|=
name|saved_local_prefix
expr_stmt|;
name|last_invisible
operator|=
name|saved_last_invisible
expr_stmt|;
name|visible_length
operator|=
name|saved_visible_length
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|_rl_make_prompt_for_search
parameter_list|(
name|pchar
parameter_list|)
name|int
name|pchar
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|pmt
decl_stmt|;
name|rl_save_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_local_prompt
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|rl_prompt
operator|&&
operator|*
name|rl_prompt
operator|)
condition|?
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|pmt
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strcpy
argument_list|(
name|pmt
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
name|pmt
index|[
name|len
index|]
operator|=
name|pchar
expr_stmt|;
name|pmt
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|*
name|saved_local_prompt
condition|?
name|strlen
argument_list|(
name|saved_local_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|pmt
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strcpy
argument_list|(
name|pmt
argument_list|,
name|saved_local_prompt
argument_list|)
expr_stmt|;
name|pmt
index|[
name|len
index|]
operator|=
name|pchar
expr_stmt|;
name|pmt
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|local_prompt
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|last_invisible
operator|=
name|saved_last_invisible
expr_stmt|;
name|visible_length
operator|=
name|saved_visible_length
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|pmt
return|;
block|}
end_function

begin_comment
comment|/* Quick redisplay hack when erasing characters at the end of the line. */
end_comment

begin_function
name|void
name|_rl_erase_at_end_of_line
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|_rl_backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|visible_line
index|[
operator|--
name|_rl_last_c_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
name|void
name|_rl_clear_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|term_clreol
condition|)
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
condition|)
name|space_to_eol
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line using spaces.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
specifier|static
name|void
name|space_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_clear_screen
parameter_list|()
block|{
if|if
condition|(
name|term_clrpag
condition|)
name|tputs
argument_list|(
name|term_clrpag
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
name|crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert COUNT characters from STRING to the output stream. */
end_comment

begin_function
specifier|static
name|void
name|insert_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
comment|/* If IC is defined, then we do not have to "enter" insert mode. */
if|if
condition|(
name|term_IC
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_IC
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we have to turn on insert-mode, then do so. */
if|if
condition|(
name|term_im
operator|&&
operator|*
name|term_im
condition|)
name|tputs
argument_list|(
name|term_im
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
comment|/* If there is a special command for inserting characters, then 	 use that first to open up the space. */
if|if
condition|(
name|term_ic
operator|&&
operator|*
name|term_ic
condition|)
block|{
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|--
condition|;
control|)
name|tputs
argument_list|(
name|term_ic
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
comment|/* Print the text. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* If there is a string to turn off insert mode, we had best use 	 it now. */
if|if
condition|(
name|term_ei
operator|&&
operator|*
name|term_ei
condition|)
name|tputs
argument_list|(
name|term_ei
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete COUNT characters from the display line. */
end_comment

begin_function
specifier|static
name|void
name|delete_chars
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|>
name|screenwidth
condition|)
comment|/* XXX */
return|return;
if|if
condition|(
name|term_DC
operator|&&
operator|*
name|term_DC
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|term_DC
argument_list|,
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
name|count
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|term_dc
operator|&&
operator|*
name|term_dc
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_dc
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_rl_update_final
parameter_list|()
block|{
name|int
name|full_lines
decl_stmt|;
name|full_lines
operator|=
literal|0
expr_stmt|;
comment|/* If the cursor is the only thing on an otherwise-blank last line,      compensate so we don't print an extra CRLF. */
if|if
condition|(
name|_rl_vis_botlin
operator|&&
name|_rl_last_c_pos
operator|==
literal|0
operator|&&
name|visible_line
index|[
name|vis_lbreaks
index|[
name|_rl_vis_botlin
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|_rl_vis_botlin
operator|--
expr_stmt|;
name|full_lines
operator|=
literal|1
expr_stmt|;
block|}
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
comment|/* If we've wrapped lines, remove the final xterm line-wrap flag. */
if|if
condition|(
name|full_lines
operator|&&
name|_rl_term_autowrap
operator|&&
operator|(
name|VIS_LLEN
argument_list|(
name|_rl_vis_botlin
argument_list|)
operator|==
name|screenwidth
operator|)
condition|)
block|{
name|char
modifier|*
name|last_line
decl_stmt|;
if|#
directive|if
literal|0
block|last_line =&visible_line[inv_lbreaks[_rl_vis_botlin]];
else|#
directive|else
name|last_line
operator|=
operator|&
name|visible_line
index|[
name|vis_lbreaks
index|[
name|_rl_vis_botlin
index|]
index|]
expr_stmt|;
endif|#
directive|endif
name|_rl_move_cursor_relative
argument_list|(
name|screenwidth
operator|-
literal|1
argument_list|,
name|last_line
argument_list|)
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|last_line
index|[
name|screenwidth
operator|-
literal|1
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|crlf
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move to the start of the current line. */
end_comment

begin_function
specifier|static
name|void
name|cr
parameter_list|()
block|{
if|if
condition|(
name|term_cr
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redraw the last line of a multi-line prompt that may possibly contain    terminal escape sequences.  Called with the cursor at column 0 of the    line to draw the prompt on. */
end_comment

begin_function
specifier|static
name|void
name|redraw_prompt
parameter_list|(
name|t
parameter_list|)
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|oldp
decl_stmt|,
modifier|*
name|oldl
decl_stmt|,
modifier|*
name|oldlprefix
decl_stmt|;
name|int
name|oldlen
decl_stmt|,
name|oldlast
decl_stmt|,
name|oldplen
decl_stmt|;
comment|/* Geez, I should make this a struct. */
name|oldp
operator|=
name|rl_display_prompt
expr_stmt|;
name|oldl
operator|=
name|local_prompt
expr_stmt|;
name|oldlprefix
operator|=
name|local_prompt_prefix
expr_stmt|;
name|oldlen
operator|=
name|visible_length
expr_stmt|;
name|oldplen
operator|=
name|prefix_length
expr_stmt|;
name|oldlast
operator|=
name|last_invisible
expr_stmt|;
name|rl_display_prompt
operator|=
name|t
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|t
argument_list|,
operator|&
name|visible_length
argument_list|,
operator|&
name|last_invisible
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|oldp
expr_stmt|;
name|local_prompt
operator|=
name|oldl
expr_stmt|;
name|local_prompt_prefix
operator|=
name|oldlprefix
expr_stmt|;
name|visible_length
operator|=
name|oldlen
expr_stmt|;
name|prefix_length
operator|=
name|oldplen
expr_stmt|;
name|last_invisible
operator|=
name|oldlast
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redisplay the current line after a SIGWINCH is received. */
end_comment

begin_function
name|void
name|_rl_redisplay_after_sigwinch
parameter_list|()
block|{
name|char
modifier|*
name|t
decl_stmt|;
comment|/* Clear the current line and put the cursor at column 0.  Make sure      the right thing happens if we have wrapped to a new screen line. */
if|if
condition|(
name|term_cr
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|space_to_eol
argument_list|(
name|screenwidth
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|term_clreol
condition|)
name|tputs
argument_list|(
name|term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
block|{
name|space_to_eol
argument_list|(
name|screenwidth
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|_rl_last_v_pos
operator|>
literal|0
condition|)
name|_rl_move_vert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|crlf
argument_list|()
expr_stmt|;
comment|/* Redraw only the last line of a multi-line prompt. */
name|t
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|redraw_prompt
argument_list|(
operator|++
name|t
argument_list|)
expr_stmt|;
else|else
name|rl_forced_update_display
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_clean_up_for_exit
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_restart_output
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_rl_erase_entire_line
parameter_list|()
block|{
name|cr
argument_list|()
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cr
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return the `current display line' of the cursor -- the number of lines to    move up to get to the first screen line of the current readline line. */
end_comment

begin_function
name|int
name|_rl_current_display_line
parameter_list|()
block|{
name|int
name|ret
decl_stmt|,
name|nleft
decl_stmt|;
comment|/* Find out whether or not there might be invisible characters in the      editing buffer. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
condition|)
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|screenwidth
operator|-
name|rl_visible_prompt_length
expr_stmt|;
else|else
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|screenwidth
expr_stmt|;
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
name|ret
operator|=
literal|1
operator|+
name|nleft
operator|/
name|screenwidth
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

