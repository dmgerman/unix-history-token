begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* display.c -- readline redisplay facility. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* System-specific feature definitions and include files. */
end_comment

begin_include
include|#
directive|include
file|"rldefs.h"
end_include

begin_include
include|#
directive|include
file|"rlmbutil.h"
end_include

begin_comment
comment|/* Termcap library stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcap.h"
end_include

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"rlprivate.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|strchr
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strchr
argument_list|()
decl_stmt|,
modifier|*
name|strrchr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !strchr&& !__STDC__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|_rl_term_forward_char
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|update_line
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|space_to_eol
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_chars
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_some_chars
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|_rl_col_width
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|_rl_wrapped_line
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_rl_col_width
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
value|(((e)<= (s)) ? 0 : (e) - (s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
modifier|*
name|inv_lbreaks
decl_stmt|,
modifier|*
name|vis_lbreaks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inv_lbsize
decl_stmt|,
name|vis_lbsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Heuristic used to decide whether it is faster to move from CUR to NEW    by backing up or outputting a carriage return and moving forward. */
end_comment

begin_define
define|#
directive|define
name|CR_FASTER
parameter_list|(
name|new
parameter_list|,
name|cur
parameter_list|)
value|(((new) + 1)< ((cur) - (new)))
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Display stuff				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* This is the stuff that is hard for me.  I never seem to write good    display routines in C.  Let's see how I do this time. */
end_comment

begin_comment
comment|/* (PWP) Well... Good for a simple line updater, but totally ignores    the problems of input lines longer than the screen width.     update_line and the code that calls it makes a multiple line,    automatically wrapping line update.  Careful attention needs    to be paid to the vertical position variables. */
end_comment

begin_comment
comment|/* Keep two buffers; one which reflects the current contents of the    screen, and the other to draw what we think the new contents should    be.  Then compare the buffers, and make whatever changes to the    screen itself that we should.  Finally, make the buffer that we    just drew into be the one which reflects the current contents of the    screen, and place the cursor where it belongs.     Commands that want to can fix the display themselves, and then let    this function know that the display has been fixed by setting the    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
end_comment

begin_comment
comment|/* Application-specific redisplay function. */
end_comment

begin_decl_stmt
name|rl_voidfunc_t
modifier|*
name|rl_redisplay_function
init|=
name|rl_redisplay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables declared here. */
end_comment

begin_comment
comment|/* What YOU turn on when you have handled all redisplay yourself. */
end_comment

begin_decl_stmt
name|int
name|rl_display_fixed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_suppress_redisplay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_want_redisplay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The stuff that gets printed out before the actual text of the line.    This is usually pointing to rl_prompt. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_display_prompt
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pseudo-global variables declared here. */
end_comment

begin_comment
comment|/* The visible cursor position.  If you print some text, adjust this. */
end_comment

begin_comment
comment|/* NOTE: _rl_last_c_pos is used as a buffer index when not in a locale    supporting multibyte characters, and an absolute cursor position when    in such a locale.  This is an artifact of the donated multibyte support.    Care must be taken when modifying its value. */
end_comment

begin_decl_stmt
name|int
name|_rl_last_c_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_last_v_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpos_adjusted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines currently on screen minus 1. */
end_comment

begin_decl_stmt
name|int
name|_rl_vis_botlin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used only in this file. */
end_comment

begin_comment
comment|/* The last left edge of text that was displayed.  This is used when    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_lmargin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line display buffers.  One is the line currently displayed on    the screen.  The other is the line about to be displayed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|invisible_line
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A buffer for `modeline' messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|msg_buf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero forces the redisplay even if we thought it was unnecessary. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|forced_display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default and initial buffer size.  Can grow. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_size
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to keep track of the expanded prompt string, which may    include invisible characters. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_prompt
decl_stmt|,
modifier|*
name|local_prompt_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prompt_visible_length
decl_stmt|,
name|prompt_prefix_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of invisible characters in the line currently being    displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_wrap_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of invisible characters in the prompt string.  Static so it    can be shared between rl_redisplay and update_line */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wrap_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index of the last invisible character in the prompt string. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prompt_last_invisible
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The length (buffer offset) of the first line of the last (possibly    multi-line) buffer displayed on the screen. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|visible_first_line_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of invisible characters on the first physical line of the prompt.    Only valid when the number of physical characters in the prompt exceeds    (or is equal to) _rl_screenwidth. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prompt_invis_chars_first_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prompt_last_screen_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prompt_physical_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to save and restore prompt and display information. */
end_comment

begin_comment
comment|/* These are getting numerous enough that it's time to create a struct. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_local_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_local_prefix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_last_invisible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_visible_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_prefix_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_invis_chars_first_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_physical_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the prompt string S and return the number of visible    characters in *LP, if LP is not null.  This is currently more-or-less    a placeholder for expansion.  LIP, if non-null is a place to store the    index of the last invisible character in the returned string. NIFLP,    if non-zero, is a place to store the number of invisible characters in    the first prompt line.  The previous are used as byte counts -- indexes    into a character buffer. */
end_comment

begin_comment
comment|/* Current implementation: 	\001 (^A) start non-visible characters 	\002 (^B) end non-visible characters    all characters except \001 and \002 (following a \001) are copied to    the returned string; all characters except those between \001 and    \002 are assumed to be `visible'. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|expand_prompt
parameter_list|(
name|pmt
parameter_list|,
name|lp
parameter_list|,
name|lip
parameter_list|,
name|niflp
parameter_list|,
name|vlp
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
name|int
modifier|*
name|lp
decl_stmt|,
decl|*
name|lip
decl_stmt|,
modifier|*
name|niflp
decl_stmt|,
modifier|*
name|vlp
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|,
name|rl
decl_stmt|,
name|last
decl_stmt|,
name|ignoring
decl_stmt|,
name|ninvis
decl_stmt|,
name|invfl
decl_stmt|,
name|invflset
decl_stmt|,
name|ind
decl_stmt|,
name|pind
decl_stmt|,
name|physchars
decl_stmt|;
comment|/* Short-circuit if we can. */
if|if
condition|(
operator|(
name|MB_CUR_MAX
operator|<=
literal|1
operator|||
name|rl_byte_oriented
operator|)
operator|&&
name|strchr
argument_list|(
name|pmt
argument_list|,
name|RL_PROMPT_START_IGNORE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|lip
condition|)
operator|*
name|lip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|niflp
condition|)
operator|*
name|niflp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vlp
condition|)
operator|*
name|vlp
operator|=
name|lp
condition|?
operator|*
name|lp
else|:
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|r
operator|=
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|invfl
operator|=
literal|0
expr_stmt|;
comment|/* invisible chars in first line of prompt */
name|invflset
operator|=
literal|0
expr_stmt|;
comment|/* we only want to set invfl once */
for|for
control|(
name|rl
operator|=
name|ignoring
operator|=
name|last
operator|=
name|ninvis
operator|=
name|physchars
operator|=
literal|0
operator|,
name|p
operator|=
name|pmt
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
comment|/* This code strips the invisible character string markers 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
if|if
condition|(
operator|*
name|p
operator|==
name|RL_PROMPT_START_IGNORE
condition|)
block|{
name|ignoring
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ignoring
operator|&&
operator|*
name|p
operator|==
name|RL_PROMPT_END_IGNORE
condition|)
block|{
name|ignoring
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|RL_PROMPT_START_IGNORE
condition|)
name|last
operator|=
name|r
operator|-
name|ret
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|pind
operator|=
name|p
operator|-
name|pmt
expr_stmt|;
name|ind
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|pmt
argument_list|,
name|pind
argument_list|,
literal|1
argument_list|,
name|MB_FIND_NONZERO
argument_list|)
expr_stmt|;
name|l
operator|=
name|ind
operator|-
name|pind
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
operator|*
name|r
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ignoring
condition|)
block|{
name|rl
operator|+=
name|ind
operator|-
name|pind
expr_stmt|;
name|physchars
operator|+=
name|_rl_col_width
argument_list|(
name|pmt
argument_list|,
name|pind
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
else|else
name|ninvis
operator|+=
name|ind
operator|-
name|pind
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* compensate for later increment */
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|r
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|ignoring
condition|)
block|{
name|rl
operator|++
expr_stmt|;
comment|/* visible length byte counter */
name|physchars
operator|++
expr_stmt|;
block|}
else|else
name|ninvis
operator|++
expr_stmt|;
comment|/* invisible chars byte counter */
block|}
if|if
condition|(
name|invflset
operator|==
literal|0
operator|&&
name|rl
operator|>=
name|_rl_screenwidth
condition|)
block|{
name|invfl
operator|=
name|ninvis
expr_stmt|;
name|invflset
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rl
operator|<
name|_rl_screenwidth
condition|)
name|invfl
operator|=
name|ninvis
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lp
condition|)
operator|*
name|lp
operator|=
name|rl
expr_stmt|;
if|if
condition|(
name|lip
condition|)
operator|*
name|lip
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|niflp
condition|)
operator|*
name|niflp
operator|=
name|invfl
expr_stmt|;
if|if
condition|(
name|vlp
condition|)
operator|*
name|vlp
operator|=
name|physchars
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from    PMT and return the rest of PMT. */
end_comment

begin_function
name|char
modifier|*
name|_rl_strip_prompt
parameter_list|(
name|pmt
parameter_list|)
name|char
modifier|*
name|pmt
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|expand_prompt
argument_list|(
name|pmt
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the prompt string into the various display components, if  * necessary.  *  * local_prompt = expanded last line of string in rl_display_prompt  *		  (portion after the final newline)  * local_prompt_prefix = portion before last newline of rl_display_prompt,  *			 expanded via expand_prompt  * prompt_visible_length = number of visible characters in local_prompt  * prompt_prefix_length = number of visible characters in local_prompt_prefix  *  * This function is called once per call to readline().  It may also be  * called arbitrarily to expand the primary prompt.  *  * The return value is the number of visible characters on the last line  * of the (possibly multi-line) prompt.  */
end_comment

begin_function
name|int
name|rl_expand_prompt
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Clear out any saved values. */
name|FREE
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|prompt_last_invisible
operator|=
name|prompt_invis_chars_first_line
operator|=
literal|0
expr_stmt|;
name|prompt_visible_length
operator|=
name|prompt_physical_chars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
literal|0
operator|||
operator|*
name|prompt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|strrchr
argument_list|(
name|prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
comment|/* The prompt is only one logical line, though it might wrap. */
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|prompt_visible_length
argument_list|,
operator|&
name|prompt_last_invisible
argument_list|,
operator|&
name|prompt_invis_chars_first_line
argument_list|,
operator|&
name|prompt_physical_chars
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|prompt_visible_length
operator|)
return|;
block|}
else|else
block|{
comment|/* The prompt spans multiple lines. */
name|t
operator|=
operator|++
name|p
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|p
argument_list|,
operator|&
name|prompt_visible_length
argument_list|,
operator|&
name|prompt_last_invisible
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|prompt_physical_chars
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* The portion of the prompt string up to and including the 	 final newline is now null-terminated. */
name|local_prompt_prefix
operator|=
name|expand_prompt
argument_list|(
name|prompt
argument_list|,
operator|&
name|prompt_prefix_length
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|prompt_invis_chars_first_line
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|prompt_prefix_length
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the VISIBLE_LINE and INVISIBLE_LINE arrays, and their associated    arrays of line break markers.  MINSIZE is the minimum size of VISIBLE_LINE    and INVISIBLE_LINE; if it is greater than LINE_SIZE, LINE_SIZE is    increased.  If the lines have already been allocated, this ensures that    they can hold at least MINSIZE characters. */
end_comment

begin_function
specifier|static
name|void
name|init_line_structures
parameter_list|(
name|minsize
parameter_list|)
name|int
name|minsize
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|invisible_line
operator|==
literal|0
condition|)
comment|/* initialize it */
block|{
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
name|line_size
operator|=
name|minsize
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
comment|/* ensure it can hold MINSIZE chars */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|line_size
operator|<
name|minsize
condition|)
name|line_size
operator|=
name|minsize
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|minsize
init|;
name|n
operator|<
name|line_size
condition|;
name|n
operator|++
control|)
block|{
name|visible_line
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|invisible_line
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vis_lbreaks
operator|==
literal|0
condition|)
block|{
comment|/* should be enough. */
name|inv_lbsize
operator|=
name|vis_lbsize
operator|=
literal|256
expr_stmt|;
name|inv_lbreaks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|inv_lbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|vis_lbreaks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|vis_lbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|_rl_wrapped_line
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|vis_lbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inv_lbreaks
index|[
literal|0
index|]
operator|=
name|vis_lbreaks
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Basic redisplay algorithm. */
end_comment

begin_function
name|void
name|rl_redisplay
parameter_list|()
block|{
specifier|register
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|c
decl_stmt|,
name|linenum
decl_stmt|,
name|cursor_linenum
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|c_pos
decl_stmt|,
name|inv_botlin
decl_stmt|,
name|lb_botlin
decl_stmt|,
name|lb_linenum
decl_stmt|,
name|o_cpos
decl_stmt|;
name|int
name|newlines
decl_stmt|,
name|lpos
decl_stmt|,
name|temp
decl_stmt|,
name|modmark
decl_stmt|,
name|n0
decl_stmt|,
name|num
decl_stmt|;
name|char
modifier|*
name|prompt_this_line
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|wchar_t
name|wc
decl_stmt|;
name|size_t
name|wc_bytes
decl_stmt|;
name|int
name|wc_width
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
name|int
name|_rl_wrapped_multicolumn
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|readline_echoing_p
condition|)
return|return;
if|if
condition|(
operator|!
name|rl_display_prompt
condition|)
name|rl_display_prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|invisible_line
operator|==
literal|0
operator|||
name|vis_lbreaks
operator|==
literal|0
condition|)
block|{
name|init_line_structures
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rl_on_new_line
argument_list|()
expr_stmt|;
block|}
comment|/* Draw the line into the buffer. */
name|c_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
name|out
operator|=
name|inv_botlin
operator|=
literal|0
expr_stmt|;
comment|/* Mark the line as modified or not.  We only do this for history      lines. */
name|modmark
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_mark_modified_lines
operator|&&
name|current_history
argument_list|()
operator|&&
name|rl_undo_list
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'*'
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|modmark
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If someone thought that the redisplay was handled, but the currently      visible line has a different modification state than the one about      to become visible, then correct the caller's misconception. */
if|if
condition|(
name|visible_line
index|[
literal|0
index|]
operator|!=
name|invisible_line
index|[
literal|0
index|]
condition|)
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If the prompt to be displayed is the `primary' readline prompt (the      one passed to readline()), use the values we have already expanded.      If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the      number of non-visible characters in the prompt string. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
operator|||
name|local_prompt
condition|)
block|{
name|int
name|local_len
init|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|local_prompt_prefix
operator|&&
name|forced_display
condition|)
name|_rl_output_some_chars
argument_list|(
name|local_prompt_prefix
argument_list|,
name|strlen
argument_list|(
name|local_prompt_prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_len
operator|>
literal|0
condition|)
block|{
name|temp
operator|=
name|local_len
operator|+
name|out
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|line_size
condition|)
block|{
name|line_size
operator|=
operator|(
name|temp
operator|+
literal|1024
operator|)
operator|-
operator|(
name|temp
operator|%
literal|1024
operator|)
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|local_prompt
argument_list|,
name|local_len
argument_list|)
expr_stmt|;
name|out
operator|+=
name|local_len
expr_stmt|;
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
name|local_len
operator|-
name|prompt_visible_length
expr_stmt|;
block|}
else|else
block|{
name|int
name|pmtlen
decl_stmt|;
name|prompt_this_line
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_this_line
condition|)
name|prompt_this_line
operator|=
name|rl_display_prompt
expr_stmt|;
else|else
block|{
name|prompt_this_line
operator|++
expr_stmt|;
name|pmtlen
operator|=
name|prompt_this_line
operator|-
name|rl_display_prompt
expr_stmt|;
comment|/* temp var */
if|if
condition|(
name|forced_display
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|rl_display_prompt
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
comment|/* Make sure we are at column zero even after a newline, 		 regardless of the state of terminal output processing. */
if|if
condition|(
name|pmtlen
operator|<
literal|2
operator|||
name|prompt_this_line
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\r'
condition|)
name|cr
argument_list|()
expr_stmt|;
block|}
block|}
name|prompt_physical_chars
operator|=
name|pmtlen
operator|=
name|strlen
argument_list|(
name|prompt_this_line
argument_list|)
expr_stmt|;
name|temp
operator|=
name|pmtlen
operator|+
name|out
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|line_size
condition|)
block|{
name|line_size
operator|=
operator|(
name|temp
operator|+
literal|1024
operator|)
operator|-
operator|(
name|temp
operator|%
literal|1024
operator|)
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line
operator|+
name|out
argument_list|,
name|prompt_this_line
argument_list|,
name|pmtlen
argument_list|)
expr_stmt|;
name|out
operator|+=
name|pmtlen
expr_stmt|;
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wrap_offset
operator|=
name|prompt_invis_chars_first_line
operator|=
literal|0
expr_stmt|;
block|}
define|#
directive|define
name|CHECK_INV_LBREAKS
parameter_list|()
define|\
value|do { \ 	if (newlines>= (inv_lbsize - 2)) \ 	  { \ 	    inv_lbsize *= 2; \ 	    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \ 	  } \       } while (0)
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
define|#
directive|define
name|CHECK_LPOS
parameter_list|()
define|\
value|do { \ 	lpos++; \ 	if (lpos>= _rl_screenwidth) \ 	  { \ 	    if (newlines>= (inv_lbsize - 2)) \ 	      { \ 		inv_lbsize *= 2; \ 		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \ 		_rl_wrapped_line = (int *)xrealloc (_rl_wrapped_line, inv_lbsize * sizeof (int)); \ 	      } \ 	    inv_lbreaks[++newlines] = out; \ 	    _rl_wrapped_line[newlines] = _rl_wrapped_multicolumn; \ 	    lpos = 0; \ 	  } \       } while (0)
else|#
directive|else
define|#
directive|define
name|CHECK_LPOS
parameter_list|()
define|\
value|do { \ 	lpos++; \ 	if (lpos>= _rl_screenwidth) \ 	  { \ 	    if (newlines>= (inv_lbsize - 2)) \ 	      { \ 		inv_lbsize *= 2; \ 		inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \ 	      } \ 	    inv_lbreaks[++newlines] = out; \ 	    lpos = 0; \ 	  } \       } while (0)
endif|#
directive|endif
comment|/* inv_lbreaks[i] is where line i starts in the buffer. */
name|inv_lbreaks
index|[
name|newlines
operator|=
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|lpos = out - wrap_offset;
else|#
directive|else
name|lpos
operator|=
name|prompt_physical_chars
operator|+
name|modmark
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|memset
argument_list|(
name|_rl_wrapped_line
argument_list|,
literal|0
argument_list|,
name|vis_lbsize
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* prompt_invis_chars_first_line is the number of invisible characters in      the first physical line of the prompt.      wrap_offset - prompt_invis_chars_first_line is the number of invis      chars on the second line. */
comment|/* what if lpos is already>= _rl_screenwidth before we start drawing the      contents of the command line? */
while|while
condition|(
name|lpos
operator|>=
name|_rl_screenwidth
condition|)
block|{
comment|/* fix from Darin Johnson<darin@acuson.com> for prompt string with          invisible characters that is longer than the screen width.  The          prompt_invis_chars_first_line variable could be made into an array          saying how many invisible characters there are per line, but that's          probably too much work for the benefit gained.  How many people have          prompts that exceed two physical lines?          Additional logic fix from Edward Catmur<ed@catmur.co.uk> */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|n0
operator|=
name|num
expr_stmt|;
name|temp
operator|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|num
operator|<
name|temp
condition|)
block|{
if|if
condition|(
name|_rl_col_width
argument_list|(
name|local_prompt
argument_list|,
name|n0
argument_list|,
name|num
argument_list|)
operator|>
name|_rl_screenwidth
condition|)
block|{
name|num
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|local_prompt
argument_list|,
name|num
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
break|break;
block|}
name|num
operator|++
expr_stmt|;
block|}
name|temp
operator|=
name|num
operator|+
else|#
directive|else
name|temp
operator|=
operator|(
operator|(
name|newlines
operator|+
literal|1
operator|)
operator|*
name|_rl_screenwidth
operator|)
operator|+
endif|#
directive|endif
comment|/* !HANDLE_MULTIBYTE */
operator|(
operator|(
name|local_prompt_prefix
operator|==
literal|0
operator|)
condition|?
operator|(
operator|(
name|newlines
operator|==
literal|0
operator|)
condition|?
name|prompt_invis_chars_first_line
else|:
operator|(
operator|(
name|newlines
operator|==
literal|1
operator|)
condition|?
name|wrap_offset
else|:
literal|0
operator|)
operator|)
else|:
operator|(
operator|(
name|newlines
operator|==
literal|0
operator|)
condition|?
name|wrap_offset
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|temp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|lpos
operator|-=
name|_rl_col_width
argument_list|(
name|local_prompt
argument_list|,
name|n0
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
name|lpos
operator|-=
name|_rl_screenwidth
expr_stmt|;
endif|#
directive|endif
block|}
name|prompt_last_screen_line
operator|=
name|newlines
expr_stmt|;
comment|/* Draw the rest of the line (after the prompt) into invisible_line, keeping      track of where the cursor is (c_pos), the number of the line containing      the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).      It maintains an array of line breaks for display (inv_lbreaks).      This handles expanding tabs for display and displaying meta characters. */
name|lb_linenum
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|wc_bytes
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_end
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
else|else
name|wc_bytes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|in
operator|<
name|rl_end
condition|)
else|#
directive|else
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|rl_end
condition|;
name|in
operator|++
control|)
endif|#
directive|endif
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|rl_line_buffer
index|[
name|in
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
name|wc_bytes
argument_list|)
condition|)
block|{
comment|/* Byte sequence is invalid or shortened.  Assume that the 	         first byte represents a character. */
name|wc_bytes
operator|=
literal|1
expr_stmt|;
comment|/* Assume that a character occupies a single column. */
name|wc_width
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|wc_bytes
argument_list|)
condition|)
break|break;
comment|/* Found '\0' */
else|else
block|{
name|temp
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|wc_width
operator|=
operator|(
name|temp
operator|>=
literal|0
operator|)
condition|?
name|temp
else|:
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|out
operator|+
literal|8
operator|>=
name|line_size
condition|)
comment|/* XXX - 8 for \t */
block|{
name|line_size
operator|*=
literal|2
expr_stmt|;
name|visible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|visible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|invisible_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|invisible_line
argument_list|,
name|line_size
argument_list|)
expr_stmt|;
name|line
operator|=
name|invisible_line
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
block|{
name|c_pos
operator|=
name|out
expr_stmt|;
name|lb_linenum
operator|=
name|newlines
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
name|_rl_output_meta_chars
operator|==
literal|0
condition|)
comment|/* XXX - clean up */
else|#
directive|else
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|_rl_output_meta_chars
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
operator|+
name|out
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpos
operator|+
literal|4
operator|>=
name|_rl_screenwidth
condition|)
block|{
name|temp
operator|=
name|_rl_screenwidth
operator|-
name|lpos
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
operator|+
name|temp
expr_stmt|;
name|lpos
operator|=
literal|4
operator|-
name|temp
expr_stmt|;
block|}
else|else
name|lpos
operator|+=
literal|4
expr_stmt|;
name|out
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
specifier|register
name|int
name|newout
decl_stmt|;
if|#
directive|if
literal|0
block|newout = (out | (int)7) + 1;
else|#
directive|else
name|newout
operator|=
name|out
operator|+
literal|8
operator|-
name|lpos
operator|%
literal|8
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|newout
operator|-
name|out
expr_stmt|;
if|if
condition|(
name|lpos
operator|+
name|temp
operator|>=
name|_rl_screenwidth
condition|)
block|{
specifier|register
name|int
name|temp2
decl_stmt|;
name|temp2
operator|=
name|_rl_screenwidth
operator|-
name|lpos
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
operator|+
name|temp2
expr_stmt|;
name|lpos
operator|=
name|temp
operator|-
name|temp2
expr_stmt|;
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|out
operator|<
name|newout
condition|)
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|lpos
operator|+=
name|temp
expr_stmt|;
block|}
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|_rl_horizontal_scroll_mode
operator|==
literal|0
operator|&&
name|_rl_term_up
operator|&&
operator|*
name|_rl_term_up
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX - sentinel */
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
operator|++
name|newlines
index|]
operator|=
name|out
expr_stmt|;
name|lpos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
name|line
index|[
name|out
operator|++
index|]
operator|=
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|?
name|UNCTRL
argument_list|(
name|c
argument_list|)
else|:
literal|'?'
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|_rl_wrapped_multicolumn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|_rl_screenwidth
operator|<
name|lpos
operator|+
name|wc_width
condition|)
for|for
control|(
name|i
operator|=
name|lpos
init|;
name|i
operator|<
name|_rl_screenwidth
condition|;
name|i
operator|++
control|)
block|{
comment|/* The space will be removed in update_line() */
name|line
index|[
name|out
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|_rl_wrapped_multicolumn
operator|++
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|==
name|rl_point
condition|)
block|{
name|c_pos
operator|=
name|out
expr_stmt|;
name|lb_linenum
operator|=
name|newlines
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|in
init|;
name|i
operator|<
name|in
operator|+
name|wc_bytes
condition|;
name|i
operator|++
control|)
name|line
index|[
name|out
operator|++
index|]
operator|=
name|rl_line_buffer
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wc_width
condition|;
name|i
operator|++
control|)
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|line
index|[
name|out
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|CHECK_LPOS
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|in
operator|+=
name|wc_bytes
expr_stmt|;
name|wc_bytes
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|rl_line_buffer
operator|+
name|in
argument_list|,
name|rl_end
operator|-
name|in
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
else|else
name|in
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|line
index|[
name|out
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c_pos
operator|<
literal|0
condition|)
block|{
name|c_pos
operator|=
name|out
expr_stmt|;
name|lb_linenum
operator|=
name|newlines
expr_stmt|;
block|}
name|inv_botlin
operator|=
name|lb_botlin
operator|=
name|newlines
expr_stmt|;
name|CHECK_INV_LBREAKS
argument_list|()
expr_stmt|;
name|inv_lbreaks
index|[
name|newlines
operator|+
literal|1
index|]
operator|=
name|out
expr_stmt|;
name|cursor_linenum
operator|=
name|lb_linenum
expr_stmt|;
comment|/* C_POS == position in buffer where cursor should be placed.      CURSOR_LINENUM == line number where the cursor should be placed. */
comment|/* PWP: now is when things get a bit hairy.  The visible and invisible      line buffers are really multiple lines, which would wrap every      (screenwidth - 1) characters.  Go through each in turn, finding      the changed region and updating it.  The line order is top to bottom. */
comment|/* If we can move the cursor up and down, then use multiple lines,      otherwise, let long lines display in a single terminal line, and      horizontally scroll it. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|==
literal|0
operator|&&
name|_rl_term_up
operator|&&
operator|*
name|_rl_term_up
condition|)
block|{
name|int
name|nleft
decl_stmt|,
name|pos
decl_stmt|,
name|changed_screen_line
decl_stmt|,
name|tx
decl_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
comment|/* If we have more than a screenful of material to display, then 	     only display a screenful.  We should display the last screen, 	     not the first.  */
if|if
condition|(
name|out
operator|>=
name|_rl_screenchars
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|out
operator|=
name|_rl_find_prev_mbchar
argument_list|(
name|line
argument_list|,
name|_rl_screenchars
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
name|_rl_screenchars
operator|-
literal|1
expr_stmt|;
block|}
comment|/* The first line is at character position 0 in the buffer.  The 	     second and subsequent lines start at inv_lbreaks[N], offset by 	     OFFSET (which has already been calculated above).  */
define|#
directive|define
name|W_OFFSET
parameter_list|(
name|line
parameter_list|,
name|offset
parameter_list|)
value|((line) == 0 ? offset : 0)
define|#
directive|define
name|VIS_LLEN
parameter_list|(
name|l
parameter_list|)
value|((l)> _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
define|#
directive|define
name|INV_LLEN
parameter_list|(
name|l
parameter_list|)
value|(inv_lbreaks[l+1] - inv_lbreaks[l])
define|#
directive|define
name|VIS_CHARS
parameter_list|(
name|line
parameter_list|)
value|(visible_line + vis_lbreaks[line])
define|#
directive|define
name|VIS_LINE
parameter_list|(
name|line
parameter_list|)
value|((line)> _rl_vis_botlin) ? "" : VIS_CHARS(line)
define|#
directive|define
name|INV_LINE
parameter_list|(
name|line
parameter_list|)
value|(invisible_line + inv_lbreaks[line])
comment|/* For each line in the buffer, do the updating display. */
for|for
control|(
name|linenum
operator|=
literal|0
init|;
name|linenum
operator|<=
name|inv_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|o_cpos
operator|=
name|_rl_last_c_pos
expr_stmt|;
name|cpos_adjusted
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
name|VIS_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LINE
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|linenum
argument_list|,
name|VIS_LLEN
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|INV_LLEN
argument_list|(
name|linenum
argument_list|)
argument_list|,
name|inv_botlin
argument_list|)
expr_stmt|;
comment|/* update_line potentially changes _rl_last_c_pos, but doesn't 		 take invisible characters into account, since _rl_last_c_pos 		 is an absolute cursor position in a multibyte locale.  See 		 if compensating here is the right thing, or if we have to 		 change update_line itself.  There is one case in which 		 update_line adjusts _rl_last_c_pos itself (so it can pass 		 _rl_move_cursor_relative accurate values); it communicates 		 this back by setting cpos_adjusted */
if|if
condition|(
name|linenum
operator|==
literal|0
operator|&&
operator|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
operator|)
operator|&&
name|cpos_adjusted
operator|==
literal|0
operator|&&
name|_rl_last_c_pos
operator|!=
name|o_cpos
operator|&&
name|_rl_last_c_pos
operator|>
name|wrap_offset
operator|&&
name|o_cpos
operator|<
name|prompt_last_invisible
condition|)
name|_rl_last_c_pos
operator|-=
name|wrap_offset
expr_stmt|;
comment|/* If this is the line with the prompt, we might need to 		 compensate for invisible characters in the new line. Do 		 this only if there is not more than one new line (which 		 implies that we completely overwrite the old visible line) 		 and the new line is shorter than the old.  Make sure we are 		 at the end of the new line before clearing. */
if|if
condition|(
name|linenum
operator|==
literal|0
operator|&&
name|inv_botlin
operator|==
literal|0
operator|&&
name|_rl_last_c_pos
operator|==
name|out
operator|&&
operator|(
name|wrap_offset
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|<
name|visible_first_line_len
operator|)
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|nleft
operator|=
name|_rl_screenwidth
operator|-
name|_rl_last_c_pos
expr_stmt|;
else|else
name|nleft
operator|=
name|_rl_screenwidth
operator|+
name|wrap_offset
operator|-
name|_rl_last_c_pos
expr_stmt|;
if|if
condition|(
name|nleft
condition|)
name|_rl_clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
comment|/* Since the new first line is now visible, save its length. */
if|if
condition|(
name|linenum
operator|==
literal|0
condition|)
name|visible_first_line_len
operator|=
operator|(
name|inv_botlin
operator|>
literal|0
operator|)
condition|?
name|inv_lbreaks
index|[
literal|1
index|]
else|:
name|out
operator|-
name|wrap_offset
expr_stmt|;
block|}
comment|/* We may have deleted some lines.  If so, clear the left over 	     blank ones at the bottom out. */
if|if
condition|(
name|_rl_vis_botlin
operator|>
name|inv_botlin
condition|)
block|{
name|char
modifier|*
name|tt
decl_stmt|;
for|for
control|(
init|;
name|linenum
operator|<=
name|_rl_vis_botlin
condition|;
name|linenum
operator|++
control|)
block|{
name|tt
operator|=
name|VIS_CHARS
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_vert
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
literal|0
argument_list|,
name|tt
argument_list|)
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
operator|(
name|linenum
operator|==
name|_rl_vis_botlin
operator|)
condition|?
name|strlen
argument_list|(
name|tt
argument_list|)
else|:
name|_rl_screenwidth
argument_list|)
expr_stmt|;
block|}
block|}
name|_rl_vis_botlin
operator|=
name|inv_botlin
expr_stmt|;
comment|/* CHANGED_SCREEN_LINE is set to 1 if we have moved to a 	     different screen line during this redisplay. */
name|changed_screen_line
operator|=
name|_rl_last_v_pos
operator|!=
name|cursor_linenum
expr_stmt|;
if|if
condition|(
name|changed_screen_line
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|cursor_linenum
argument_list|)
expr_stmt|;
comment|/* If we moved up to the line with the prompt using _rl_term_up, 		 the physical cursor position on the screen stays the same, 		 but the buffer position needs to be adjusted to account 		 for invisible characters. */
if|if
condition|(
operator|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
operator|)
operator|&&
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
condition|)
name|_rl_last_c_pos
operator|+=
name|wrap_offset
expr_stmt|;
block|}
comment|/* We have to reprint the prompt if it contains invisible 	     characters, since it's not generally OK to just reprint 	     the characters from the current cursor position.  But we 	     only need to reprint it if the cursor is before the last 	     invisible character in the prompt string. */
name|nleft
operator|=
name|prompt_visible_length
operator|+
name|wrap_offset
expr_stmt|;
if|if
condition|(
name|cursor_linenum
operator|==
literal|0
operator|&&
name|wrap_offset
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
name|_rl_last_c_pos
operator|<=
name|prompt_last_invisible
operator|&&
name|local_prompt
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_rl_term_cr
condition|)
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|_rl_last_c_pos
operator|=
name|_rl_col_width
argument_list|(
name|local_prompt
argument_list|,
literal|0
argument_list|,
name|nleft
argument_list|)
operator|-
name|wrap_offset
expr_stmt|;
else|else
name|_rl_last_c_pos
operator|=
name|nleft
expr_stmt|;
block|}
comment|/* Where on that line?  And where does that line start 	     in the buffer? */
name|pos
operator|=
name|inv_lbreaks
index|[
name|cursor_linenum
index|]
expr_stmt|;
comment|/* nleft == number of characters in the line buffer between the 	     start of the line and the cursor position. */
name|nleft
operator|=
name|c_pos
operator|-
name|pos
expr_stmt|;
comment|/* NLEFT is now a number of characters in a buffer.  When in a 	     multibyte locale, however, _rl_last_c_pos is an absolute cursor 	     position that doesn't take invisible characters in the prompt 	     into account.  We use a fudge factor to compensate. */
comment|/* Since _rl_backspace() doesn't know about invisible characters in the 	     prompt, and there's no good way to tell it, we compensate for 	     those characters here and call _rl_backspace() directly. */
if|if
condition|(
name|wrap_offset
operator|&&
name|cursor_linenum
operator|==
literal|0
operator|&&
name|nleft
operator|<
name|_rl_last_c_pos
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|tx
operator|=
name|_rl_col_width
argument_list|(
operator|&
name|visible_line
index|[
name|pos
index|]
argument_list|,
literal|0
argument_list|,
name|nleft
argument_list|)
operator|-
name|visible_wrap_offset
expr_stmt|;
else|else
name|tx
operator|=
name|nleft
expr_stmt|;
if|if
condition|(
name|_rl_last_c_pos
operator|>
name|tx
condition|)
block|{
name|_rl_backspace
argument_list|(
name|_rl_last_c_pos
operator|-
name|tx
argument_list|)
expr_stmt|;
comment|/* XXX */
name|_rl_last_c_pos
operator|=
name|tx
expr_stmt|;
block|}
block|}
comment|/* We need to note that in a multibyte locale we are dealing with 	     _rl_last_c_pos as an absolute cursor position, but moving to a 	     point specified by a buffer position (NLEFT) that doesn't take 	     invisible characters into account. */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|_rl_move_cursor_relative
argument_list|(
name|nleft
argument_list|,
operator|&
name|invisible_line
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nleft
operator|!=
name|_rl_last_c_pos
condition|)
name|_rl_move_cursor_relative
argument_list|(
name|nleft
argument_list|,
operator|&
name|invisible_line
index|[
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Do horizontal scrolling. */
block|{
define|#
directive|define
name|M_OFFSET
parameter_list|(
name|margin
parameter_list|,
name|offset
parameter_list|)
value|((margin) == 0 ? offset : 0)
name|int
name|lmargin
decl_stmt|,
name|ndisp
decl_stmt|,
name|nleft
decl_stmt|,
name|phys_c_pos
decl_stmt|,
name|t
decl_stmt|;
comment|/* Always at top line. */
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
comment|/* Compute where in the buffer the displayed line should start.  This 	 will be LMARGIN. */
comment|/* The number of characters that will be displayed before the cursor. */
name|ndisp
operator|=
name|c_pos
operator|-
name|wrap_offset
expr_stmt|;
name|nleft
operator|=
name|prompt_visible_length
operator|+
name|wrap_offset
expr_stmt|;
comment|/* Where the new cursor position will be on the screen.  This can be 	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
name|phys_c_pos
operator|=
name|c_pos
operator|-
operator|(
name|last_lmargin
condition|?
name|last_lmargin
else|:
name|wrap_offset
operator|)
expr_stmt|;
name|t
operator|=
name|_rl_screenwidth
operator|/
literal|3
expr_stmt|;
comment|/* If the number of characters had already exceeded the screenwidth, 	 last_lmargin will be> 0. */
comment|/* If the number of characters to be displayed is more than the screen 	 width, compute the starting offset so that the cursor is about 	 two-thirds of the way across the screen. */
if|if
condition|(
name|phys_c_pos
operator|>
name|_rl_screenwidth
operator|-
literal|2
condition|)
block|{
name|lmargin
operator|=
name|c_pos
operator|-
operator|(
literal|2
operator|*
name|t
operator|)
expr_stmt|;
if|if
condition|(
name|lmargin
operator|<
literal|0
condition|)
name|lmargin
operator|=
literal|0
expr_stmt|;
comment|/* If the left margin would be in the middle of a prompt with 	     invisible characters, don't display the prompt at all. */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndisp
operator|<
name|_rl_screenwidth
operator|-
literal|2
condition|)
comment|/* XXX - was -1 */
name|lmargin
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|phys_c_pos
operator|<
literal|1
condition|)
block|{
comment|/* If we are moving back towards the beginning of the line and 	     the last margin is no longer correct, compute a new one. */
name|lmargin
operator|=
operator|(
operator|(
name|c_pos
operator|-
literal|1
operator|)
operator|/
name|t
operator|)
operator|*
name|t
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|wrap_offset
operator|&&
name|lmargin
operator|>
literal|0
operator|&&
name|lmargin
operator|<
name|nleft
condition|)
name|lmargin
operator|=
name|nleft
expr_stmt|;
block|}
else|else
name|lmargin
operator|=
name|last_lmargin
expr_stmt|;
comment|/* If the first character on the screen isn't the first character 	 in the display line, indicate this with a special character. */
if|if
condition|(
name|lmargin
operator|>
literal|0
condition|)
name|line
index|[
name|lmargin
index|]
operator|=
literal|'<'
expr_stmt|;
comment|/* If SCREENWIDTH characters starting at LMARGIN do not encompass 	 the whole line, indicate that with a special character at the 	 right edge of the screen.  If LMARGIN is 0, we need to take the 	 wrap offset into account. */
name|t
operator|=
name|lmargin
operator|+
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|+
name|_rl_screenwidth
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|out
condition|)
name|line
index|[
name|t
operator|-
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rl_display_fixed
operator|||
name|forced_display
operator|||
name|lmargin
operator|!=
name|last_lmargin
condition|)
block|{
name|forced_display
operator|=
literal|0
expr_stmt|;
name|update_line
argument_list|(
operator|&
name|visible_line
index|[
name|last_lmargin
index|]
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|,
literal|0
argument_list|,
name|_rl_screenwidth
operator|+
name|visible_wrap_offset
argument_list|,
name|_rl_screenwidth
operator|+
operator|(
name|lmargin
condition|?
literal|0
else|:
name|wrap_offset
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the visible new line is shorter than the old, but the number 	     of invisible characters is greater, and we are at the end of 	     the new line, we need to clear to eol. */
name|t
operator|=
name|_rl_last_c_pos
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
operator|>
name|visible_wrap_offset
operator|)
operator|&&
operator|(
name|_rl_last_c_pos
operator|==
name|out
operator|)
operator|&&
name|t
operator|<
name|visible_first_line_len
condition|)
block|{
name|nleft
operator|=
name|_rl_screenwidth
operator|-
name|t
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
name|nleft
argument_list|)
expr_stmt|;
block|}
name|visible_first_line_len
operator|=
name|out
operator|-
name|lmargin
operator|-
name|M_OFFSET
argument_list|(
name|lmargin
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|visible_first_line_len
operator|>
name|_rl_screenwidth
condition|)
name|visible_first_line_len
operator|=
name|_rl_screenwidth
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|c_pos
operator|-
name|lmargin
argument_list|,
operator|&
name|invisible_line
index|[
name|lmargin
index|]
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
name|lmargin
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
comment|/* Swap visible and non-visible lines. */
block|{
name|char
modifier|*
name|vtemp
init|=
name|visible_line
decl_stmt|;
name|int
modifier|*
name|itemp
init|=
name|vis_lbreaks
decl_stmt|,
name|ntemp
init|=
name|vis_lbsize
decl_stmt|;
name|visible_line
operator|=
name|invisible_line
expr_stmt|;
name|invisible_line
operator|=
name|vtemp
expr_stmt|;
name|vis_lbreaks
operator|=
name|inv_lbreaks
expr_stmt|;
name|inv_lbreaks
operator|=
name|itemp
expr_stmt|;
name|vis_lbsize
operator|=
name|inv_lbsize
expr_stmt|;
name|inv_lbsize
operator|=
name|ntemp
expr_stmt|;
name|rl_display_fixed
operator|=
literal|0
expr_stmt|;
comment|/* If we are displaying on a single line, and last_lmargin is> 0, we        are not displaying any invisible characters, so set visible_wrap_offset        to 0. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|last_lmargin
condition|)
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
else|else
name|visible_wrap_offset
operator|=
name|wrap_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PWP: update_line() is based on finding the middle difference of each    line on the screen; vis:  			     /old first difference 	/beginning of line   |	      /old last same       /old EOL 	v		     v	      v		    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^	^			   ^ 	\beginning of line   |	\new last same	   \new end of line 			     \new first difference     All are character pointers for the sake of speed.  Special cases for    no differences, as well as for end of line additions must be handled.     Could be made even smarter, but this works well enough */
end_comment

begin_function
specifier|static
name|void
name|update_line
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|current_line
parameter_list|,
name|omax
parameter_list|,
name|nmax
parameter_list|,
name|inv_botlin
parameter_list|)
specifier|register
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|current_line
decl_stmt|,
name|omax
decl_stmt|,
name|nmax
decl_stmt|,
name|inv_botlin
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|int
name|temp
decl_stmt|,
name|lendiff
decl_stmt|,
name|wsatend
decl_stmt|,
name|od
decl_stmt|,
name|nd
decl_stmt|;
name|int
name|current_invis_chars
decl_stmt|;
name|int
name|col_lendiff
decl_stmt|,
name|col_temp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
name|mbstate_t
name|ps_new
decl_stmt|,
name|ps_old
decl_stmt|;
name|int
name|new_offset
decl_stmt|,
name|old_offset
decl_stmt|,
name|tmp
decl_stmt|;
endif|#
directive|endif
comment|/* If we're at the right edge of a terminal that supports xn, we're      ready to wrap around, so do so.  This fixes problems with knowing      the exact cursor position and cut-and-paste with certain terminal      emulators.  In this calculation, TEMP is the physical screen      position of the cursor. */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|temp
operator|=
name|_rl_last_c_pos
expr_stmt|;
else|else
name|temp
operator|=
name|_rl_last_c_pos
operator|-
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|visible_wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|_rl_screenwidth
operator|&&
name|_rl_term_autowrap
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_v_pos
operator|==
name|current_line
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
name|mbstate_t
name|ps
decl_stmt|;
name|int
name|tempwidth
decl_stmt|,
name|bytes
decl_stmt|;
name|size_t
name|ret
decl_stmt|;
comment|/* This fixes only double-column characters, but if the wrapped 	     character comsumes more than three columns, spaces will be 	     inserted in the string buffer. */
if|if
condition|(
name|_rl_wrapped_line
index|[
name|current_line
index|]
operator|>
literal|0
condition|)
name|_rl_clear_to_eol
argument_list|(
name|_rl_wrapped_line
index|[
name|current_line
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|new
argument_list|,
name|MB_CUR_MAX
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|tempwidth
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|ret
argument_list|)
condition|)
name|tempwidth
operator|=
literal|0
expr_stmt|;
else|else
name|tempwidth
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwidth
operator|>
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|;
name|bytes
operator|=
name|ret
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bytes
condition|;
name|count
operator|++
control|)
name|putc
argument_list|(
name|new
index|[
name|count
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|tempwidth
expr_stmt|;
name|_rl_last_v_pos
operator|++
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|old
argument_list|,
name|MB_CUR_MAX
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
name|ret
argument_list|)
condition|)
name|memmove
argument_list|(
name|old
operator|+
name|bytes
argument_list|,
name|old
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|old
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
name|old
operator|+
name|bytes
argument_list|,
name|old
operator|+
name|ret
argument_list|,
name|strlen
argument_list|(
name|old
operator|+
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|1
expr_stmt|;
name|_rl_last_v_pos
operator|++
expr_stmt|;
if|if
condition|(
name|old
index|[
literal|0
index|]
operator|&&
name|new
index|[
literal|0
index|]
condition|)
name|old
index|[
literal|0
index|]
operator|=
name|new
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|new
index|[
literal|0
index|]
condition|)
name|putc
argument_list|(
name|new
index|[
literal|0
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
literal|1
expr_stmt|;
name|_rl_last_v_pos
operator|++
expr_stmt|;
if|if
condition|(
name|old
index|[
literal|0
index|]
operator|&&
name|new
index|[
literal|0
index|]
condition|)
name|old
index|[
literal|0
index|]
operator|=
name|new
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
comment|/* Find first difference. */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
comment|/* See if the old line is a subset of the new line, so that the 	 only change is adding characters. */
name|temp
operator|=
operator|(
name|omax
operator|<
name|nmax
operator|)
condition|?
name|omax
else|:
name|nmax
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ofd
operator|=
name|old
operator|+
name|temp
expr_stmt|;
name|nfd
operator|=
name|new
operator|+
name|temp
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|ps_new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps_old
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|omax
operator|==
name|nmax
operator|&&
name|STREQN
argument_list|(
name|new
argument_list|,
name|old
argument_list|,
name|omax
argument_list|)
condition|)
block|{
name|ofd
operator|=
name|old
operator|+
name|omax
expr_stmt|;
name|nfd
operator|=
name|new
operator|+
name|nmax
expr_stmt|;
block|}
else|else
block|{
name|new_offset
operator|=
name|old_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|omax
operator|)
operator|&&
operator|*
name|ofd
operator|&&
name|_rl_compare_chars
argument_list|(
name|old
argument_list|,
name|old_offset
argument_list|,
operator|&
name|ps_old
argument_list|,
name|new
argument_list|,
name|new_offset
argument_list|,
operator|&
name|ps_new
argument_list|)
condition|;
control|)
block|{
name|old_offset
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|old
argument_list|,
name|old_offset
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
name|new_offset
operator|=
name|_rl_find_next_mbchar
argument_list|(
name|new
argument_list|,
name|new_offset
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
name|ofd
operator|=
name|old
operator|+
name|old_offset
expr_stmt|;
name|nfd
operator|=
name|new
operator|+
name|new_offset
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
endif|#
directive|endif
for|for
control|(
name|ofd
operator|=
name|old
operator|,
name|nfd
operator|=
name|new
init|;
operator|(
name|ofd
operator|-
name|old
operator|<
name|omax
operator|)
operator|&&
operator|*
name|ofd
operator|&&
operator|(
operator|*
name|ofd
operator|==
operator|*
name|nfd
operator|)
condition|;
name|ofd
operator|++
operator|,
name|nfd
operator|++
control|)
empty_stmt|;
comment|/* Move to the end of the screen line.  ND and OD are used to keep track      of the distance between ne and new and oe and old, respectively, to      move a subtraction out of each loop. */
for|for
control|(
name|od
operator|=
name|ofd
operator|-
name|old
operator|,
name|oe
operator|=
name|ofd
init|;
name|od
operator|<
name|omax
operator|&&
operator|*
name|oe
condition|;
name|oe
operator|++
operator|,
name|od
operator|++
control|)
empty_stmt|;
for|for
control|(
name|nd
operator|=
name|nfd
operator|-
name|new
operator|,
name|ne
operator|=
name|nfd
init|;
name|nd
operator|<
name|nmax
operator|&&
operator|*
name|ne
condition|;
name|ne
operator|++
operator|,
name|nd
operator|++
control|)
empty_stmt|;
comment|/* If no difference, continue to next line. */
if|if
condition|(
name|ofd
operator|==
name|oe
operator|&&
name|nfd
operator|==
name|ne
condition|)
return|return;
name|wsatend
operator|=
literal|1
expr_stmt|;
comment|/* flag for trailing whitespace */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|ols
operator|=
name|old
operator|+
name|_rl_find_prev_mbchar
argument_list|(
name|old
argument_list|,
name|oe
operator|-
name|old
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
name|nls
operator|=
name|new
operator|+
name|_rl_find_prev_mbchar
argument_list|(
name|new
argument_list|,
name|ne
operator|-
name|new
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ps_old
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ps_new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* On advice from jir@yamato.ibm.com */
block|_rl_adjust_point (old, ols - old,&ps_old); 	  _rl_adjust_point (new, nls - new,&ps_new);
endif|#
directive|endif
if|if
condition|(
name|_rl_compare_chars
argument_list|(
name|old
argument_list|,
name|ols
operator|-
name|old
argument_list|,
operator|&
name|ps_old
argument_list|,
name|new
argument_list|,
name|nls
operator|-
name|new
argument_list|,
operator|&
name|ps_new
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|ols
operator|==
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|=
name|old
operator|+
name|_rl_find_prev_mbchar
argument_list|(
name|old
argument_list|,
name|ols
operator|-
name|old
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
name|nls
operator|=
name|new
operator|+
name|_rl_find_prev_mbchar
argument_list|(
name|new
argument_list|,
name|nls
operator|-
name|new
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* HANDLE_MULTIBYTE */
name|ols
operator|=
name|oe
operator|-
literal|1
expr_stmt|;
comment|/* find last same */
name|nls
operator|=
name|ne
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ols
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|nls
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
name|ols
operator|==
operator|*
name|nls
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|ols
operator|!=
literal|' '
condition|)
name|wsatend
operator|=
literal|0
expr_stmt|;
name|ols
operator|--
expr_stmt|;
name|nls
operator|--
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
block|}
endif|#
directive|endif
if|if
condition|(
name|wsatend
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
comment|/* This may not work for stateful encoding, but who cares?  To handle      stateful encoding properly, we have to scan each string from the      beginning and compare. */
elseif|else
if|if
condition|(
name|_rl_compare_chars
argument_list|(
name|ols
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|nls
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
operator|*
name|ols
operator|!=
operator|*
name|nls
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|*
name|ols
condition|)
comment|/* don't step past the NUL */
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|ols
operator|=
name|old
operator|+
name|_rl_find_next_mbchar
argument_list|(
name|old
argument_list|,
name|ols
operator|-
name|old
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
else|else
name|ols
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nls
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|nls
operator|=
name|new
operator|+
name|_rl_find_next_mbchar
argument_list|(
name|new
argument_list|,
name|nls
operator|-
name|new
argument_list|,
literal|1
argument_list|,
name|MB_FIND_ANY
argument_list|)
expr_stmt|;
else|else
name|nls
operator|++
expr_stmt|;
block|}
block|}
comment|/* count of invisible characters in the current invisible line. */
name|current_invis_chars
operator|=
name|W_OFFSET
argument_list|(
name|current_line
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|!=
name|current_line
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
operator|)
operator|&&
name|current_line
operator|==
literal|0
operator|&&
name|visible_wrap_offset
condition|)
name|_rl_last_c_pos
operator|+=
name|visible_wrap_offset
expr_stmt|;
block|}
comment|/* If this is the first line and there are invisible characters in the      prompt string, and the prompt string has not changed, and the current      cursor position is before the last invisible character in the prompt,      and the index of the character to move to is past the end of the prompt      string, then redraw the entire prompt string.  We can only do this      reliably if the terminal supports a `cr' capability.       This is not an efficiency hack -- there is a problem with redrawing      portions of the prompt string if they contain terminal escape      sequences (like drawing the `unbold' sequence without a corresponding      `bold') that manifests itself on certain terminals. */
name|lendiff
operator|=
name|local_prompt
condition|?
name|strlen
argument_list|(
name|local_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|od
operator|=
name|ofd
operator|-
name|old
expr_stmt|;
comment|/* index of first difference in visible line */
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_term_cr
operator|&&
name|lendiff
operator|>
name|prompt_visible_length
operator|&&
name|_rl_last_c_pos
operator|>
literal|0
operator|&&
name|od
operator|>=
name|lendiff
operator|&&
name|_rl_last_c_pos
operator|<=
name|prompt_last_invisible
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_output_some_chars
argument_list|(
name|local_prompt
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
comment|/* We take wrap_offset into account here so we can pass correct 	     information to _rl_move_cursor_relative. */
name|_rl_last_c_pos
operator|=
name|_rl_col_width
argument_list|(
name|local_prompt
argument_list|,
literal|0
argument_list|,
name|lendiff
argument_list|)
operator|-
name|wrap_offset
expr_stmt|;
name|cpos_adjusted
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|_rl_last_c_pos
operator|=
name|lendiff
expr_stmt|;
block|}
name|_rl_move_cursor_relative
argument_list|(
name|od
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* if (len (new)> len (old))      lendiff == difference in buffer      col_lendiff == difference on screen      When not using multibyte characters, these are equal */
name|lendiff
operator|=
operator|(
name|nls
operator|-
name|nfd
operator|)
operator|-
operator|(
name|ols
operator|-
name|ofd
operator|)
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|col_lendiff
operator|=
name|_rl_col_width
argument_list|(
name|new
argument_list|,
name|nfd
operator|-
name|new
argument_list|,
name|nls
operator|-
name|new
argument_list|)
operator|-
name|_rl_col_width
argument_list|(
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|ols
operator|-
name|old
argument_list|)
expr_stmt|;
else|else
name|col_lendiff
operator|=
name|lendiff
expr_stmt|;
comment|/* If we are changing the number of invisible characters in a line, and      the spot of first difference is before the end of the invisible chars,      lendiff needs to be adjusted. */
if|if
condition|(
name|current_line
operator|==
literal|0
operator|&&
operator|!
name|_rl_horizontal_scroll_mode
operator|&&
name|current_invis_chars
operator|!=
name|visible_wrap_offset
condition|)
block|{
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|lendiff
operator|+=
name|visible_wrap_offset
operator|-
name|current_invis_chars
expr_stmt|;
name|col_lendiff
operator|+=
name|visible_wrap_offset
operator|-
name|current_invis_chars
expr_stmt|;
block|}
else|else
block|{
name|lendiff
operator|+=
name|visible_wrap_offset
operator|-
name|current_invis_chars
expr_stmt|;
name|col_lendiff
operator|=
name|lendiff
expr_stmt|;
block|}
block|}
comment|/* Insert (diff (len (old), len (new)) ch. */
name|temp
operator|=
name|ne
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|col_temp
operator|=
name|_rl_col_width
argument_list|(
name|new
argument_list|,
name|nfd
operator|-
name|new
argument_list|,
name|ne
operator|-
name|new
argument_list|)
expr_stmt|;
else|else
name|col_temp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|col_lendiff
operator|>
literal|0
condition|)
comment|/* XXX - was lendiff */
block|{
comment|/* Non-zero if we're increasing the number of lines. */
name|int
name|gl
init|=
name|current_line
operator|>=
name|_rl_vis_botlin
operator|&&
name|inv_botlin
operator|>
name|_rl_vis_botlin
decl_stmt|;
comment|/* Sometimes it is cheaper to print the characters rather than 	 use the terminal's capabilities.  If we're growing the number 	 of lines, make sure we actually cause the new line to wrap 	 around on auto-wrapping terminals. */
if|if
condition|(
name|_rl_terminal_can_insert
operator|&&
operator|(
operator|(
literal|2
operator|*
name|col_temp
operator|)
operator|>=
name|col_lendiff
operator|||
name|_rl_term_IC
operator|)
operator|&&
operator|(
operator|!
name|_rl_term_autowrap
operator|||
operator|!
name|gl
operator|)
condition|)
block|{
comment|/* If lendiff> prompt_visible_length and _rl_last_c_pos == 0 and 	     _rl_horizontal_scroll_mode == 1, inserting the characters with 	     _rl_term_IC or _rl_term_ic will screw up the screen because of the 	     invisible characters.  We need to just draw them. */
if|if
condition|(
operator|*
name|ols
operator|&&
operator|(
operator|!
name|_rl_horizontal_scroll_mode
operator|||
name|_rl_last_c_pos
operator|>
literal|0
operator|||
name|lendiff
operator|<=
name|prompt_visible_length
operator|||
operator|!
name|current_invis_chars
operator|)
condition|)
block|{
name|insert_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|,
name|col_lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|col_lendiff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
operator|!=
literal|0
operator|)
operator|&&
operator|*
name|ols
operator|==
literal|0
operator|&&
name|lendiff
operator|>
literal|0
condition|)
block|{
comment|/* At the end of a line the characters do not have to 		 be "inserted".  They can just be placed on the screen. */
comment|/* However, this screws up the rest of this block, which 		 assumes you've done the insert because you can. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|lendiff
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|col_lendiff
expr_stmt|;
block|}
else|else
block|{
comment|/* We have horizontal scrolling and we are not inserting at 		 the end.  We have invisible characters in this line.  This 		 is a dumb update. */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|col_temp
expr_stmt|;
return|return;
block|}
comment|/* Copy (new) chars to screen from first diff to last match. */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|-
name|lendiff
operator|)
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
operator|+
name|lendiff
argument_list|,
name|temp
operator|-
name|lendiff
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX -- this bears closer inspection.  Fixes a redisplay bug 		reported against bash-3.0-alpha by Andreas Schwab involving 		multibyte characters and prompt strings with invisible 		characters, but was previously disabled. */
name|_rl_last_c_pos
operator|+=
name|_rl_col_width
argument_list|(
name|nfd
operator|+
name|lendiff
argument_list|,
literal|0
argument_list|,
name|temp
operator|-
name|col_lendiff
argument_list|)
expr_stmt|;
else|#
directive|else
name|_rl_last_c_pos
operator|+=
name|_rl_col_width
argument_list|(
name|nfd
operator|+
name|lendiff
argument_list|,
literal|0
argument_list|,
name|temp
operator|-
name|lendiff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* cannot insert chars, write to EOL */
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|col_temp
expr_stmt|;
comment|/* If we're in a multibyte locale and were before the last invisible 	     char in the current line (which implies we just output some invisible 	     characters) we need to adjust _rl_last_c_pos, since it represents 	     a physical character position. */
block|}
block|}
else|else
comment|/* Delete characters from line. */
block|{
comment|/* If possible and inexpensive to use terminal deletion, then do so. */
if|if
condition|(
name|_rl_term_dc
operator|&&
operator|(
literal|2
operator|*
name|col_temp
operator|)
operator|>=
operator|-
name|col_lendiff
condition|)
block|{
comment|/* If all we're doing is erasing the invisible characters in the 	     prompt string, don't bother.  It screws up the assumptions 	     about what's on the screen. */
if|if
condition|(
name|_rl_horizontal_scroll_mode
operator|&&
name|_rl_last_c_pos
operator|==
literal|0
operator|&&
operator|-
name|lendiff
operator|==
name|visible_wrap_offset
condition|)
name|col_lendiff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|col_lendiff
condition|)
name|delete_chars
argument_list|(
operator|-
name|col_lendiff
argument_list|)
expr_stmt|;
comment|/* delete (diff) characters */
comment|/* Copy (new) chars to screen from first diff to last match */
name|temp
operator|=
name|nls
operator|-
name|nfd
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|_rl_col_width
argument_list|(
name|nfd
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
block|}
comment|/* Otherwise, print over the existing material. */
else|else
block|{
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
block|{
name|_rl_output_some_chars
argument_list|(
name|nfd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|col_temp
expr_stmt|;
comment|/* XXX */
block|}
name|lendiff
operator|=
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|col_lendiff
operator|=
name|_rl_col_width
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|oe
operator|-
name|old
argument_list|)
operator|-
name|_rl_col_width
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|ne
operator|-
name|new
argument_list|)
expr_stmt|;
else|else
name|col_lendiff
operator|=
name|lendiff
expr_stmt|;
if|if
condition|(
name|col_lendiff
condition|)
block|{
if|if
condition|(
name|_rl_term_autowrap
operator|&&
name|current_line
operator|<
name|inv_botlin
condition|)
name|space_to_eol
argument_list|(
name|col_lendiff
argument_list|)
expr_stmt|;
else|else
name|_rl_clear_to_eol
argument_list|(
name|col_lendiff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Tell the update routines that we have moved onto a new (empty) line. */
end_comment

begin_function
name|int
name|rl_on_new_line
parameter_list|()
block|{
if|if
condition|(
name|visible_line
condition|)
name|visible_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|_rl_last_v_pos
operator|=
literal|0
expr_stmt|;
name|_rl_vis_botlin
operator|=
name|last_lmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vis_lbreaks
condition|)
name|vis_lbreaks
index|[
literal|0
index|]
operator|=
name|vis_lbreaks
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tell the update routines that we have moved onto a new line with the    prompt already displayed.  Code originally from the version of readline    distributed with CLISP.  rl_expand_prompt must have already been called    (explicitly or implicitly).  This still doesn't work exactly right. */
end_comment

begin_function
name|int
name|rl_on_new_line_with_prompt
parameter_list|()
block|{
name|int
name|prompt_size
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|real_screenwidth
decl_stmt|,
name|newlines
decl_stmt|;
name|char
modifier|*
name|prompt_last_line
decl_stmt|,
modifier|*
name|lprompt
decl_stmt|;
comment|/* Initialize visible_line and invisible_line to ensure that they can hold      the already-displayed prompt. */
name|prompt_size
operator|=
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
operator|+
literal|1
expr_stmt|;
name|init_line_structures
argument_list|(
name|prompt_size
argument_list|)
expr_stmt|;
comment|/* Make sure the line structures hold the already-displayed prompt for      redisplay. */
name|lprompt
operator|=
name|local_prompt
condition|?
name|local_prompt
else|:
name|rl_prompt
expr_stmt|;
name|strcpy
argument_list|(
name|visible_line
argument_list|,
name|lprompt
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|invisible_line
argument_list|,
name|lprompt
argument_list|)
expr_stmt|;
comment|/* If the prompt contains newlines, take the last tail. */
name|prompt_last_line
operator|=
name|strrchr
argument_list|(
name|rl_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prompt_last_line
condition|)
name|prompt_last_line
operator|=
name|rl_prompt
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|prompt_last_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|_rl_last_c_pos
operator|=
name|_rl_col_width
argument_list|(
name|prompt_last_line
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* XXX */
else|else
name|_rl_last_c_pos
operator|=
name|l
expr_stmt|;
comment|/* Dissect prompt_last_line into screen lines. Note that here we have      to use the real screenwidth. Readline's notion of screenwidth might be      one less, see terminal.c. */
name|real_screenwidth
operator|=
name|_rl_screenwidth
operator|+
operator|(
name|_rl_term_autowrap
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|_rl_last_v_pos
operator|=
name|l
operator|/
name|real_screenwidth
expr_stmt|;
comment|/* If the prompt length is a multiple of real_screenwidth, we don't know      whether the cursor is at the end of the last line, or already at the      beginning of the next line. Output a newline just to be safe. */
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
operator|(
name|l
operator|%
name|real_screenwidth
operator|)
operator|==
literal|0
condition|)
name|_rl_output_some_chars
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|last_lmargin
operator|=
literal|0
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|l
condition|)
block|{
name|_rl_vis_botlin
operator|=
name|newlines
expr_stmt|;
name|vis_lbreaks
index|[
name|newlines
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|+=
name|real_screenwidth
expr_stmt|;
block|}
name|vis_lbreaks
index|[
name|newlines
index|]
operator|=
name|l
expr_stmt|;
name|visible_wrap_offset
operator|=
literal|0
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
comment|/* XXX - make sure it's set */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Actually update the display, period. */
end_comment

begin_function
name|int
name|rl_forced_update_display
parameter_list|()
block|{
if|if
condition|(
name|visible_line
condition|)
block|{
specifier|register
name|char
modifier|*
name|temp
init|=
name|visible_line
decl_stmt|;
while|while
condition|(
operator|*
name|temp
condition|)
operator|*
name|temp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|forced_display
operator|++
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.    (Well, when we don't have multibyte characters, _rl_last_c_pos is a    buffer index.)    DATA is the contents of the screen line of interest; i.e., where    the movement is being done. */
end_comment

begin_function
name|void
name|_rl_move_cursor_relative
parameter_list|(
name|new
parameter_list|,
name|data
parameter_list|)
name|int
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|woff
decl_stmt|;
comment|/* number of invisible chars on current line */
name|int
name|cpos
decl_stmt|,
name|dpos
decl_stmt|;
comment|/* current and desired cursor positions */
name|woff
operator|=
name|W_OFFSET
argument_list|(
name|_rl_last_v_pos
argument_list|,
name|wrap_offset
argument_list|)
expr_stmt|;
name|cpos
operator|=
name|_rl_last_c_pos
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
comment|/* If we have multibyte characters, NEW is indexed by the buffer point in      a multibyte string, but _rl_last_c_pos is the display position.  In      this case, NEW's display position is not obvious and must be      calculated.  We need to account for invisible characters in this line,      as long as we are past them and they are counted by _rl_col_width. */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|dpos
operator|=
name|_rl_col_width
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpos
operator|>
name|woff
condition|)
name|dpos
operator|-=
name|woff
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|dpos
operator|=
name|new
expr_stmt|;
comment|/* If we don't have to do anything, then return. */
if|if
condition|(
name|cpos
operator|==
name|dpos
condition|)
return|return;
comment|/* It may be faster to output a CR, and then move forwards instead      of moving backwards. */
comment|/* i == current physical cursor position. */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
name|i
operator|=
name|_rl_last_c_pos
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|_rl_last_c_pos
operator|-
name|woff
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|CR_FASTER
argument_list|(
name|new
argument_list|,
name|_rl_last_c_pos
argument_list|)
operator|||
operator|(
name|_rl_term_autowrap
operator|&&
name|i
operator|==
name|_rl_screenwidth
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__MSDOS__ */
name|cpos
operator|=
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cpos
operator|<
name|dpos
condition|)
block|{
comment|/* Move the cursor forward.  We do it by printing the command 	 to move the cursor forward if there is one, else print that 	 portion of the output buffer again.  Which is cheaper? */
comment|/* The above comment is left here for posterity.  It is faster 	 to print one character (non-control) than to print a control 	 sequence telling the terminal to move forward one character. 	 That kind of control is for people who don't know what the 	 data is underneath the cursor. */
if|#
directive|if
name|defined
argument_list|(
name|HACK_TERMCAP_MOTION
argument_list|)
if|if
condition|(
name|_rl_term_forward_char
condition|)
block|{
for|for
control|(
name|i
operator|=
name|cpos
init|;
name|i
operator|<
name|dpos
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|_rl_term_forward_char
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* HACK_TERMCAP_MOTION */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|rl_byte_oriented
operator|==
literal|0
condition|)
block|{
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
name|cpos
init|;
name|i
operator|<
name|new
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
name|data
index|[
name|i
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
comment|/* NEW points to the buffer point, but _rl_last_c_pos is the display point.      The byte length of the string is probably bigger than the column width      of the string, which means that if NEW == _rl_last_c_pos, then NEW's      display point is less than _rl_last_c_pos. */
endif|#
directive|endif
elseif|else
if|if
condition|(
name|cpos
operator|>
name|dpos
condition|)
name|_rl_backspace
argument_list|(
name|cpos
operator|-
name|dpos
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|=
name|dpos
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PWP: move the cursor up or down. */
end_comment

begin_function
name|void
name|_rl_move_vert
parameter_list|(
name|to
parameter_list|)
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|delta
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|_rl_last_v_pos
operator|==
name|to
operator|||
name|to
operator|>
name|_rl_screenheight
condition|)
return|return;
if|if
condition|(
operator|(
name|delta
operator|=
name|to
operator|-
name|_rl_last_v_pos
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* delta< 0 */
if|if
condition|(
name|_rl_term_up
operator|&&
operator|*
name|_rl_term_up
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|delta
condition|;
name|i
operator|++
control|)
name|tputs
argument_list|(
name|_rl_term_up
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
name|_rl_last_v_pos
operator|=
name|to
expr_stmt|;
comment|/* Now TO is here */
block|}
end_function

begin_comment
comment|/* Physically print C on rl_outstream.  This is for functions which know    how to optimize the display.  Return the number of characters output. */
end_comment

begin_function
name|int
name|rl_show_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|n
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"M-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
if|if
condition|(
operator|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
else|#
directive|else
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"C-"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
condition|?
name|UNCTRL
argument_list|(
name|c
argument_list|)
else|:
literal|'?'
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|rl_character_len
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|unsigned
name|char
name|uc
decl_stmt|;
name|uc
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|META_CHAR
argument_list|(
name|uc
argument_list|)
condition|)
return|return
operator|(
operator|(
name|_rl_output_meta_chars
operator|==
literal|0
operator|)
condition|?
literal|4
else|:
literal|1
operator|)
return|;
if|if
condition|(
name|uc
operator|==
literal|'\t'
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DISPLAY_TABS
argument_list|)
return|return
operator|(
operator|(
operator|(
name|pos
operator||
literal|7
operator|)
operator|+
literal|1
operator|)
operator|-
name|pos
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|2
operator|)
return|;
endif|#
directive|endif
comment|/* !DISPLAY_TABS */
block|}
if|if
condition|(
name|CTRL_CHAR
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
name|RUBOUT
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
operator|(
name|ISPRINT
argument_list|(
name|uc
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How to print things in the "echo-area".  The prompt is treated as a    mini-modeline. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msg_saved_prompt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_VARARGS
argument_list|)
end_if

begin_function
name|int
if|#
directive|if
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
name|rl_message
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|rl_message
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PREFER_VARARGS
argument_list|)
name|char
modifier|*
name|format
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
name|vsnprintf
argument_list|(
name|msg_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_buf
argument_list|)
operator|-
literal|1
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|vsprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|msg_buf
index|[
sizeof|sizeof
argument_list|(
name|msg_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* overflow? */
endif|#
directive|endif
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_local_prompt
operator|==
literal|0
condition|)
block|{
name|rl_save_prompt
argument_list|()
expr_stmt|;
name|msg_saved_prompt
operator|=
literal|1
expr_stmt|;
block|}
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|msg_buf
argument_list|,
operator|&
name|prompt_visible_length
argument_list|,
operator|&
name|prompt_last_invisible
argument_list|,
operator|&
name|prompt_invis_chars_first_line
argument_list|,
operator|&
name|prompt_physical_chars
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_VARARGS */
end_comment

begin_function
name|int
name|rl_message
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|msg_buf
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|msg_buf
index|[
sizeof|sizeof
argument_list|(
name|msg_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* overflow? */
name|rl_display_prompt
operator|=
name|msg_buf
expr_stmt|;
if|if
condition|(
name|saved_local_prompt
operator|==
literal|0
condition|)
block|{
name|rl_save_prompt
argument_list|()
expr_stmt|;
name|msg_saved_prompt
operator|=
literal|1
expr_stmt|;
block|}
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|msg_buf
argument_list|,
operator|&
name|prompt_visible_length
argument_list|,
operator|&
name|prompt_last_invisible
argument_list|,
operator|&
name|prompt_invis_chars_first_line
argument_list|,
operator|&
name|prompt_physical_chars
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_VARARGS */
end_comment

begin_comment
comment|/* How to clear things from the "echo-area". */
end_comment

begin_function
name|int
name|rl_clear_message
parameter_list|()
block|{
name|rl_display_prompt
operator|=
name|rl_prompt
expr_stmt|;
if|if
condition|(
name|msg_saved_prompt
condition|)
block|{
name|rl_restore_prompt
argument_list|()
expr_stmt|;
name|msg_saved_prompt
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|rl_redisplay_function
call|)
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_reset_line_state
parameter_list|()
block|{
name|rl_on_new_line
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
expr_stmt|;
name|forced_display
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|rl_save_prompt
parameter_list|()
block|{
name|saved_local_prompt
operator|=
name|local_prompt
expr_stmt|;
name|saved_local_prefix
operator|=
name|local_prompt_prefix
expr_stmt|;
name|saved_prefix_length
operator|=
name|prompt_prefix_length
expr_stmt|;
name|saved_last_invisible
operator|=
name|prompt_last_invisible
expr_stmt|;
name|saved_visible_length
operator|=
name|prompt_visible_length
expr_stmt|;
name|saved_invis_chars_first_line
operator|=
name|prompt_invis_chars_first_line
expr_stmt|;
name|saved_physical_chars
operator|=
name|prompt_physical_chars
expr_stmt|;
name|local_prompt
operator|=
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|prompt_last_invisible
operator|=
name|prompt_visible_length
operator|=
name|prompt_prefix_length
operator|=
literal|0
expr_stmt|;
name|prompt_invis_chars_first_line
operator|=
name|prompt_physical_chars
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_restore_prompt
parameter_list|()
block|{
name|FREE
argument_list|(
name|local_prompt
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|local_prompt_prefix
argument_list|)
expr_stmt|;
name|local_prompt
operator|=
name|saved_local_prompt
expr_stmt|;
name|local_prompt_prefix
operator|=
name|saved_local_prefix
expr_stmt|;
name|prompt_prefix_length
operator|=
name|saved_prefix_length
expr_stmt|;
name|prompt_last_invisible
operator|=
name|saved_last_invisible
expr_stmt|;
name|prompt_visible_length
operator|=
name|saved_visible_length
expr_stmt|;
name|prompt_invis_chars_first_line
operator|=
name|saved_invis_chars_first_line
expr_stmt|;
name|prompt_physical_chars
operator|=
name|saved_physical_chars
expr_stmt|;
comment|/* can test saved_local_prompt to see if prompt info has been saved. */
name|saved_local_prompt
operator|=
name|saved_local_prefix
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|saved_last_invisible
operator|=
name|saved_visible_length
operator|=
name|saved_prefix_length
operator|=
literal|0
expr_stmt|;
name|saved_invis_chars_first_line
operator|=
name|saved_physical_chars
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|_rl_make_prompt_for_search
parameter_list|(
name|pchar
parameter_list|)
name|int
name|pchar
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|pmt
decl_stmt|;
name|rl_save_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_local_prompt
operator|==
literal|0
condition|)
block|{
name|len
operator|=
operator|(
name|rl_prompt
operator|&&
operator|*
name|rl_prompt
operator|)
condition|?
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|pmt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strcpy
argument_list|(
name|pmt
argument_list|,
name|rl_prompt
argument_list|)
expr_stmt|;
name|pmt
index|[
name|len
index|]
operator|=
name|pchar
expr_stmt|;
name|pmt
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|*
name|saved_local_prompt
condition|?
name|strlen
argument_list|(
name|saved_local_prompt
argument_list|)
else|:
literal|0
expr_stmt|;
name|pmt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|strcpy
argument_list|(
name|pmt
argument_list|,
name|saved_local_prompt
argument_list|)
expr_stmt|;
name|pmt
index|[
name|len
index|]
operator|=
name|pchar
expr_stmt|;
name|pmt
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|local_prompt
operator|=
name|savestring
argument_list|(
name|pmt
argument_list|)
expr_stmt|;
name|prompt_last_invisible
operator|=
name|saved_last_invisible
expr_stmt|;
name|prompt_visible_length
operator|=
name|saved_visible_length
operator|+
literal|1
expr_stmt|;
block|}
name|prompt_physical_chars
operator|=
name|saved_physical_chars
operator|+
literal|1
expr_stmt|;
return|return
name|pmt
return|;
block|}
end_function

begin_comment
comment|/* Quick redisplay hack when erasing characters at the end of the line. */
end_comment

begin_function
name|void
name|_rl_erase_at_end_of_line
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|_rl_backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_backspace
argument_list|(
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|visible_line
index|[
operator|--
name|_rl_last_c_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
name|void
name|_rl_clear_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|_rl_term_clreol
condition|)
name|tputs
argument_list|(
name|_rl_term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
condition|)
name|space_to_eol
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear to the end of the line using spaces.  COUNT is the minimum    number of character spaces to clear, */
end_comment

begin_function
specifier|static
name|void
name|space_to_eol
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
name|_rl_last_c_pos
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_clear_screen
parameter_list|()
block|{
if|if
condition|(
name|_rl_term_clrpag
condition|)
name|tputs
argument_list|(
name|_rl_term_clrpag
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
name|rl_crlf
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert COUNT characters from STRING to the output stream at column COL. */
end_comment

begin_function
specifier|static
name|void
name|insert_some_chars
parameter_list|(
name|string
parameter_list|,
name|count
parameter_list|,
name|col
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|count
decl_stmt|,
name|col
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DEBUGGING */
if|if
condition|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
name|rl_byte_oriented
condition|)
if|if
condition|(
name|count
operator|!=
name|col
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readline: debug: insert_some_chars: count (%d) != col (%d)\n"
argument_list|,
name|count
argument_list|,
name|col
argument_list|)
expr_stmt|;
comment|/* If IC is defined, then we do not have to "enter" insert mode. */
if|if
condition|(
name|_rl_term_IC
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|_rl_term_IC
argument_list|,
literal|0
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we have to turn on insert-mode, then do so. */
if|if
condition|(
name|_rl_term_im
operator|&&
operator|*
name|_rl_term_im
condition|)
name|tputs
argument_list|(
name|_rl_term_im
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
comment|/* If there is a special command for inserting characters, then 	 use that first to open up the space. */
if|if
condition|(
name|_rl_term_ic
operator|&&
operator|*
name|_rl_term_ic
condition|)
block|{
for|for
control|(
name|i
operator|=
name|col
init|;
name|i
operator|--
condition|;
control|)
name|tputs
argument_list|(
name|_rl_term_ic
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
comment|/* Print the text. */
name|_rl_output_some_chars
argument_list|(
name|string
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* If there is a string to turn off insert mode, we had best use 	 it now. */
if|if
condition|(
name|_rl_term_ei
operator|&&
operator|*
name|_rl_term_ei
condition|)
name|tputs
argument_list|(
name|_rl_term_ei
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __MSDOS__ || __MINGW32__ */
block|}
end_function

begin_comment
comment|/* Delete COUNT characters from the display line. */
end_comment

begin_function
specifier|static
name|void
name|delete_chars
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|>
name|_rl_screenwidth
condition|)
comment|/* XXX */
return|return;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
if|if
condition|(
name|_rl_term_DC
operator|&&
operator|*
name|_rl_term_DC
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|tgoto
argument_list|(
name|_rl_term_DC
argument_list|,
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
name|count
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_rl_term_dc
operator|&&
operator|*
name|_rl_term_dc
condition|)
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|_rl_term_dc
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !__MSDOS__&& !__MINGW32__ */
block|}
end_function

begin_function
name|void
name|_rl_update_final
parameter_list|()
block|{
name|int
name|full_lines
decl_stmt|;
name|full_lines
operator|=
literal|0
expr_stmt|;
comment|/* If the cursor is the only thing on an otherwise-blank last line,      compensate so we don't print an extra CRLF. */
if|if
condition|(
name|_rl_vis_botlin
operator|&&
name|_rl_last_c_pos
operator|==
literal|0
operator|&&
name|visible_line
index|[
name|vis_lbreaks
index|[
name|_rl_vis_botlin
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|_rl_vis_botlin
operator|--
expr_stmt|;
name|full_lines
operator|=
literal|1
expr_stmt|;
block|}
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
comment|/* If we've wrapped lines, remove the final xterm line-wrap flag. */
if|if
condition|(
name|full_lines
operator|&&
name|_rl_term_autowrap
operator|&&
operator|(
name|VIS_LLEN
argument_list|(
name|_rl_vis_botlin
argument_list|)
operator|==
name|_rl_screenwidth
operator|)
condition|)
block|{
name|char
modifier|*
name|last_line
decl_stmt|;
name|last_line
operator|=
operator|&
name|visible_line
index|[
name|vis_lbreaks
index|[
name|_rl_vis_botlin
index|]
index|]
expr_stmt|;
name|_rl_move_cursor_relative
argument_list|(
name|_rl_screenwidth
operator|-
literal|1
argument_list|,
name|last_line
argument_list|)
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|last_line
index|[
name|_rl_screenwidth
operator|-
literal|1
index|]
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|rl_crlf
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_display_fixed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move to the start of the current line. */
end_comment

begin_function
specifier|static
name|void
name|cr
parameter_list|()
block|{
if|if
condition|(
name|_rl_term_cr
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Redraw the last line of a multi-line prompt that may possibly contain    terminal escape sequences.  Called with the cursor at column 0 of the    line to draw the prompt on. */
end_comment

begin_function
specifier|static
name|void
name|redraw_prompt
parameter_list|(
name|t
parameter_list|)
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|oldp
decl_stmt|;
name|oldp
operator|=
name|rl_display_prompt
expr_stmt|;
name|rl_save_prompt
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|t
expr_stmt|;
name|local_prompt
operator|=
name|expand_prompt
argument_list|(
name|t
argument_list|,
operator|&
name|prompt_visible_length
argument_list|,
operator|&
name|prompt_last_invisible
argument_list|,
operator|&
name|prompt_invis_chars_first_line
argument_list|,
operator|&
name|prompt_physical_chars
argument_list|)
expr_stmt|;
name|local_prompt_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|rl_forced_update_display
argument_list|()
expr_stmt|;
name|rl_display_prompt
operator|=
name|oldp
expr_stmt|;
name|rl_restore_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redisplay the current line after a SIGWINCH is received. */
end_comment

begin_function
name|void
name|_rl_redisplay_after_sigwinch
parameter_list|()
block|{
name|char
modifier|*
name|t
decl_stmt|;
comment|/* Clear the current line and put the cursor at column 0.  Make sure      the right thing happens if we have wrapped to a new screen line. */
if|if
condition|(
name|_rl_term_cr
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_rl_last_c_pos
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|space_to_eol
argument_list|(
name|_rl_screenwidth
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|rl_outstream
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_rl_term_clreol
condition|)
name|tputs
argument_list|(
name|_rl_term_clreol
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
else|else
block|{
name|space_to_eol
argument_list|(
name|_rl_screenwidth
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|_rl_term_cr
argument_list|,
literal|1
argument_list|,
name|_rl_output_character_function
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|_rl_last_v_pos
operator|>
literal|0
condition|)
name|_rl_move_vert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_crlf
argument_list|()
expr_stmt|;
comment|/* Redraw only the last line of a multi-line prompt. */
name|t
operator|=
name|strrchr
argument_list|(
name|rl_display_prompt
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|redraw_prompt
argument_list|(
operator|++
name|t
argument_list|)
expr_stmt|;
else|else
name|rl_forced_update_display
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_rl_clean_up_for_exit
parameter_list|()
block|{
if|if
condition|(
name|readline_echoing_p
condition|)
block|{
name|_rl_move_vert
argument_list|(
name|_rl_vis_botlin
argument_list|)
expr_stmt|;
name|_rl_vis_botlin
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
name|rl_restart_output
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_rl_erase_entire_line
parameter_list|()
block|{
name|cr
argument_list|()
expr_stmt|;
name|_rl_clear_to_eol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cr
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|rl_outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return the `current display line' of the cursor -- the number of lines to    move up to get to the first screen line of the current readline line. */
end_comment

begin_function
name|int
name|_rl_current_display_line
parameter_list|()
block|{
name|int
name|ret
decl_stmt|,
name|nleft
decl_stmt|;
comment|/* Find out whether or not there might be invisible characters in the      editing buffer. */
if|if
condition|(
name|rl_display_prompt
operator|==
name|rl_prompt
condition|)
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|_rl_screenwidth
operator|-
name|rl_visible_prompt_length
expr_stmt|;
else|else
name|nleft
operator|=
name|_rl_last_c_pos
operator|-
name|_rl_screenwidth
expr_stmt|;
if|if
condition|(
name|nleft
operator|>
literal|0
condition|)
name|ret
operator|=
literal|1
operator|+
name|nleft
operator|/
name|_rl_screenwidth
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MULTIBYTE
argument_list|)
end_if

begin_comment
comment|/* Calculate the number of screen columns occupied by STR from START to END.    In the case of multibyte characters with stateful encoding, we have to    scan from the beginning of the string to take the state into account. */
end_comment

begin_function
specifier|static
name|int
name|_rl_col_width
parameter_list|(
name|str
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|wchar_t
name|wc
decl_stmt|;
name|mbstate_t
name|ps
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|point
decl_stmt|,
name|width
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|end
operator|<=
name|start
condition|)
return|return
literal|0
return|;
name|point
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|end
expr_stmt|;
while|while
condition|(
name|point
operator|<
name|start
condition|)
block|{
name|tmp
operator|=
name|mbrlen
argument_list|(
name|str
operator|+
name|point
argument_list|,
name|max
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
operator|(
name|size_t
operator|)
name|tmp
argument_list|)
condition|)
block|{
comment|/* In this case, the bytes are invalid or too short to compose a 	     multibyte character, so we assume that the first byte represents 	     a single character. */
name|point
operator|++
expr_stmt|;
name|max
operator|--
expr_stmt|;
comment|/* Clear the state of the byte sequence, because in this case the 	     effect of mbstate is undefined. */
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|tmp
argument_list|)
condition|)
break|break;
comment|/* Found '\0' */
else|else
block|{
name|point
operator|+=
name|tmp
expr_stmt|;
name|max
operator|-=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* If START is not a byte that starts a character, then POINT will be      greater than START.  In this case, assume that (POINT - START) gives      a byte count that is the number of columns of difference. */
name|width
operator|=
name|point
operator|-
name|start
expr_stmt|;
while|while
condition|(
name|point
operator|<
name|end
condition|)
block|{
name|tmp
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|str
operator|+
name|point
argument_list|,
name|max
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|MB_INVALIDCH
argument_list|(
operator|(
name|size_t
operator|)
name|tmp
argument_list|)
condition|)
block|{
comment|/* In this case, the bytes are invalid or too short to compose a 	     multibyte character, so we assume that the first byte represents 	     a single character. */
name|point
operator|++
expr_stmt|;
name|max
operator|--
expr_stmt|;
comment|/* and assume that the byte occupies a single column. */
name|width
operator|++
expr_stmt|;
comment|/* Clear the state of the byte sequence, because in this case the 	     effect of mbstate is undefined. */
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MB_NULLWCH
argument_list|(
name|tmp
argument_list|)
condition|)
break|break;
comment|/* Found '\0' */
else|else
block|{
name|point
operator|+=
name|tmp
expr_stmt|;
name|max
operator|-=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
name|width
operator|+=
operator|(
name|tmp
operator|>=
literal|0
operator|)
condition|?
name|tmp
else|:
literal|1
expr_stmt|;
block|}
block|}
name|width
operator|+=
name|point
operator|-
name|end
expr_stmt|;
return|return
name|width
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MULTIBYTE */
end_comment

end_unit

