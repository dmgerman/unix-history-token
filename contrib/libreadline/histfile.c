begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* histfile.c - functions to manipulate the history file. */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_MINIX
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_comment
comment|/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment    on win 95/98/nt), we want to open files with O_BINARY mode so that there    is no \n -> \r\n conversion performed.  On other systems, we don't want to    mess around with O_BINARY at all, so we ensure that it's defined to 0. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__EMX__&& !__CYGWIN__ */
end_comment

begin_undef
undef|#
directive|undef
name|O_BINARY
end_undef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__EMX__&& !__CYGWIN__ */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* Return the string that should be used in the place of this    filename.  This only matters when you don't specify the    filename to read_history (), or write_history (). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_filename
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|return_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|home
decl_stmt|;
name|int
name|home_len
decl_stmt|;
name|return_val
operator|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|return_val
condition|)
return|return
operator|(
name|return_val
operator|)
return|;
name|home
operator|=
name|sh_get_env_value
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|home
operator|==
literal|0
condition|)
block|{
name|home
operator|=
literal|"."
expr_stmt|;
name|home_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|home_len
operator|=
name|strlen
argument_list|(
name|home
argument_list|)
expr_stmt|;
name|return_val
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|home_len
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* strlen(".history") == 8 */
name|strcpy
argument_list|(
name|return_val
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|return_val
index|[
name|home_len
index|]
operator|=
literal|'/'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|strcpy
argument_list|(
name|return_val
operator|+
name|home_len
operator|+
literal|1
argument_list|,
literal|"_history"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|return_val
operator|+
name|home_len
operator|+
literal|1
argument_list|,
literal|".history"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the contents of FILENAME to the history list, a line at a time.    If FILENAME is NULL, then read from ~/.history.  Returns 0 if    successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|read_history_range
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a range of lines from FILENAME, adding them to the history list.    Start reading at the FROM'th line and end at the TO'th.  If FROM    is zero, start at the beginning.  If TO is less than FROM, read    until the end of the file.  If FILENAME is NULL, then read from    ~/.history.  Returns 0 if successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history_range
parameter_list|(
name|filename
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|line_start
decl_stmt|,
name|line_end
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|int
name|file
decl_stmt|,
name|current_line
decl_stmt|,
name|chars_read
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|input
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|<
literal|0
operator|)
operator|||
operator|(
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
goto|goto
name|error_and_exit
goto|;
name|file_size
operator|=
operator|(
name|size_t
operator|)
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* check for overflow on very large files */
if|if
condition|(
name|file_size
operator|!=
name|finfo
operator|.
name|st_size
operator|||
name|file_size
operator|+
literal|1
operator|<
name|file_size
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|errno
operator|=
name|EFBIG
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error_and_exit
goto|;
block|}
name|buffer
operator|=
name|xmalloc
argument_list|(
name|file_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<
literal|0
condition|)
block|{
name|error_and_exit
label|:
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set TO to larger than end of file if negative. */
if|if
condition|(
name|to
operator|<
literal|0
condition|)
name|to
operator|=
name|chars_read
expr_stmt|;
comment|/* Start at beginning of file, work to end. */
name|line_start
operator|=
name|line_end
operator|=
name|current_line
operator|=
literal|0
expr_stmt|;
comment|/* Skip lines until we are at FROM. */
while|while
condition|(
name|line_start
operator|<
name|chars_read
operator|&&
name|current_line
operator|<
name|from
condition|)
block|{
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|chars_read
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|current_line
operator|++
expr_stmt|;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|current_line
operator|==
name|from
condition|)
break|break;
block|}
block|}
comment|/* If there are lines left to gobble, then gobble them now. */
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|chars_read
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
name|buffer
index|[
name|line_end
index|]
operator|==
literal|'\n'
condition|)
block|{
name|buffer
index|[
name|line_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buffer
index|[
name|line_start
index|]
condition|)
name|add_history
argument_list|(
name|buffer
operator|+
name|line_start
argument_list|)
expr_stmt|;
name|current_line
operator|++
expr_stmt|;
if|if
condition|(
name|current_line
operator|>=
name|to
condition|)
break|break;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
block|}
name|FREE
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate the history file FNAME, leaving only LINES trailing lines.    If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno    on failure. */
end_comment

begin_function
name|int
name|history_truncate_file
parameter_list|(
name|fname
parameter_list|,
name|lines
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|file
decl_stmt|,
name|chars_read
decl_stmt|,
name|rv
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|filename
operator|=
name|history_filename
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* Don't try to truncate non-regular files. */
if|if
condition|(
name|file
operator|==
operator|-
literal|1
operator|||
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|truncate_exit
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EFTYPE
name|rv
operator|=
name|EFTYPE
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
goto|goto
name|truncate_exit
goto|;
block|}
name|file_size
operator|=
operator|(
name|size_t
operator|)
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* check for overflow on very large files */
if|if
condition|(
name|file_size
operator|!=
name|finfo
operator|.
name|st_size
operator|||
name|file_size
operator|+
literal|1
operator|<
name|file_size
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|rv
operator|=
name|errno
operator|=
name|EFBIG
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EOVERFLOW
argument_list|)
name|rv
operator|=
name|errno
operator|=
name|EOVERFLOW
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
goto|goto
name|truncate_exit
goto|;
block|}
name|buffer
operator|=
name|xmalloc
argument_list|(
name|file_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<=
literal|0
condition|)
block|{
name|rv
operator|=
operator|(
name|chars_read
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
goto|goto
name|truncate_exit
goto|;
block|}
comment|/* Count backwards from the end of buffer until we have passed      LINES lines. */
for|for
control|(
name|i
operator|=
name|chars_read
operator|-
literal|1
init|;
name|lines
operator|&&
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|lines
operator|--
expr_stmt|;
block|}
comment|/* If this is the first line, then the file contains exactly the      number of lines we want to truncate to, so we don't need to do      anything.  It's the first line if we don't find a newline between      the current value of i and 0.  Otherwise, write from the start of      this line until the end of the buffer. */
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Write only if there are more lines in the file than we want to      truncate to. */
if|if
condition|(
name|i
operator|&&
operator|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|write
argument_list|(
name|file
argument_list|,
name|buffer
operator|+
name|i
argument_list|,
name|chars_read
operator|-
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__BEOS__
argument_list|)
comment|/* BeOS ignores O_TRUNC. */
name|ftruncate
argument_list|(
name|file
argument_list|,
name|chars_read
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|truncate_exit
label|:
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Workhorse function for writing history.  Writes NELEMENT entries    from the history list to FILENAME.  OVERWRITE is non-zero if you    wish to replace FILENAME with the entries. */
end_comment

begin_function
specifier|static
name|int
name|history_do_write
parameter_list|(
name|filename
parameter_list|,
name|nelements
parameter_list|,
name|overwrite
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|nelements
decl_stmt|,
name|overwrite
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|file
decl_stmt|,
name|mode
decl_stmt|,
name|rv
decl_stmt|;
name|mode
operator|=
name|overwrite
condition|?
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
else|:
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_BINARY
expr_stmt|;
name|output
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|output
argument_list|,
name|mode
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|nelements
operator|>
name|history_length
condition|)
name|nelements
operator|=
name|history_length
expr_stmt|;
comment|/* Build a buffer of all the lines to write, and write them in one syscall.      Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
decl_stmt|;
comment|/* local */
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|buffer_size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|the_history
operator|=
name|history_list
argument_list|()
expr_stmt|;
comment|/* Calculate the total number of bytes to write. */
for|for
control|(
name|buffer_size
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|buffer_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate the buffer, and fill it. */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
operator|<
literal|0
condition|)
name|rv
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append NELEMENT entries to FILENAME.  The entries appended are from    the end of the list minus NELEMENTs up to the end of the list. */
end_comment

begin_function
name|int
name|append_history
parameter_list|(
name|nelements
parameter_list|,
name|filename
parameter_list|)
name|int
name|nelements
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|nelements
argument_list|,
name|HISTORY_APPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite FILENAME with the current history.  If FILENAME is NULL,    then write the history list to ~/.history.  Values returned    are as in read_history ().*/
end_comment

begin_function
name|int
name|write_history
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|history_length
argument_list|,
name|HISTORY_OVERWRITE
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

