begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* histfile.c - functions to manipulate the history file. */
end_comment

begin_comment
comment|/* Copyright (C) 1989-2003 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__TANDEM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<floss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MINIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|HAVE_MMAP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAP_FILE
end_ifdef

begin_define
define|#
directive|define
name|MAP_RFLAGS
value|(MAP_FILE|MAP_PRIVATE)
end_define

begin_define
define|#
directive|define
name|MAP_WFLAGS
value|(MAP_FILE|MAP_SHARED)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAP_RFLAGS
value|MAP_PRIVATE
end_define

begin_define
define|#
directive|define
name|MAP_WFLAGS
value|MAP_SHARED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((void *)-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HISTORY_USE_MMAP */
end_comment

begin_comment
comment|/* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment    on win 95/98/nt), we want to open files with O_BINARY mode so that there    is no \n -> \r\n conversion performed.  On other systems, we don't want to    mess around with O_BINARY at all, so we ensure that it's defined to 0. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__EMX__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__EMX__&& !__CYGWIN__ */
end_comment

begin_undef
undef|#
directive|undef
name|O_BINARY
end_undef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__EMX__&& !__CYGWIN__ */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_include
include|#
directive|include
file|"rlshell.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* If non-zero, we write timestamps to the history file in history_do_write() */
end_comment

begin_decl_stmt
name|int
name|history_write_timestamps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Does S look like the beginning of a history timestamp entry?  Placeholder    for more extensive tests. */
end_comment

begin_define
define|#
directive|define
name|HIST_TIMESTAMP_START
parameter_list|(
name|s
parameter_list|)
value|(*(s) == history_comment_char)
end_define

begin_comment
comment|/* Return the string that should be used in the place of this    filename.  This only matters when you don't specify the    filename to read_history (), or write_history (). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|history_filename
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|return_val
decl_stmt|;
specifier|const
name|char
modifier|*
name|home
decl_stmt|;
name|int
name|home_len
decl_stmt|;
name|return_val
operator|=
name|filename
condition|?
name|savestring
argument_list|(
name|filename
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|return_val
condition|)
return|return
operator|(
name|return_val
operator|)
return|;
name|home
operator|=
name|sh_get_env_value
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|home
operator|==
literal|0
condition|)
block|{
name|home
operator|=
literal|"."
expr_stmt|;
name|home_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|home_len
operator|=
name|strlen
argument_list|(
name|home
argument_list|)
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|home_len
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* strlen(".history") == 8 */
name|strcpy
argument_list|(
name|return_val
argument_list|,
name|home
argument_list|)
expr_stmt|;
name|return_val
index|[
name|home_len
index|]
operator|=
literal|'/'
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
name|strcpy
argument_list|(
name|return_val
operator|+
name|home_len
operator|+
literal|1
argument_list|,
literal|"_history"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|return_val
operator|+
name|home_len
operator|+
literal|1
argument_list|,
literal|".history"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|return_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add the contents of FILENAME to the history list, a line at a time.    If FILENAME is NULL, then read from ~/.history.  Returns 0 if    successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|read_history_range
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a range of lines from FILENAME, adding them to the history list.    Start reading at the FROM'th line and end at the TO'th.  If FROM    is zero, start at the beginning.  If TO is less than FROM, read    until the end of the file.  If FILENAME is NULL, then read from    ~/.history.  Returns 0 if successful, or errno if not. */
end_comment

begin_function
name|int
name|read_history_range
parameter_list|(
name|filename
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|line_start
decl_stmt|,
modifier|*
name|line_end
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|bufend
decl_stmt|,
modifier|*
name|last_ts
decl_stmt|;
name|int
name|file
decl_stmt|,
name|current_line
decl_stmt|,
name|chars_read
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|int
name|overflow_errno
init|=
name|EFBIG
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EOVERFLOW
argument_list|)
name|int
name|overflow_errno
init|=
name|EOVERFLOW
decl_stmt|;
else|#
directive|else
name|int
name|overflow_errno
init|=
name|EIO
decl_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|last_ts
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|input
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|<
literal|0
operator|)
operator|||
operator|(
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
goto|goto
name|error_and_exit
goto|;
name|file_size
operator|=
operator|(
name|size_t
operator|)
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* check for overflow on very large files */
if|if
condition|(
name|file_size
operator|!=
name|finfo
operator|.
name|st_size
operator|||
name|file_size
operator|+
literal|1
operator|<
name|file_size
condition|)
block|{
name|errno
operator|=
name|overflow_errno
expr_stmt|;
goto|goto
name|error_and_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
comment|/* We map read/write and private so we can change newlines to NULs without      affecting the underlying object. */
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|file_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_RFLAGS
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|buffer
operator|==
name|MAP_FAILED
condition|)
block|{
name|errno
operator|=
name|overflow_errno
expr_stmt|;
goto|goto
name|error_and_exit
goto|;
block|}
name|chars_read
operator|=
name|file_size
expr_stmt|;
else|#
directive|else
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|file_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|overflow_errno
expr_stmt|;
goto|goto
name|error_and_exit
goto|;
block|}
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chars_read
operator|<
literal|0
condition|)
block|{
name|error_and_exit
label|:
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|chars_read
operator|=
name|errno
expr_stmt|;
else|else
name|chars_read
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|file
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|input
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HISTORY_USE_MMAP
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|chars_read
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set TO to larger than end of file if negative. */
if|if
condition|(
name|to
operator|<
literal|0
condition|)
name|to
operator|=
name|chars_read
expr_stmt|;
comment|/* Start at beginning of file, work to end. */
name|bufend
operator|=
name|buffer
operator|+
name|chars_read
expr_stmt|;
name|current_line
operator|=
literal|0
expr_stmt|;
comment|/* Skip lines until we are at FROM. */
for|for
control|(
name|line_start
operator|=
name|line_end
operator|=
name|buffer
init|;
name|line_end
operator|<
name|bufend
operator|&&
name|current_line
operator|<
name|from
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
operator|*
name|line_end
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
comment|/* If we see something we think is a timestamp, continue with this 	   line.  We should check more extensively here... */
if|if
condition|(
name|HIST_TIMESTAMP_START
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
name|current_line
operator|++
expr_stmt|;
name|line_start
operator|=
name|p
expr_stmt|;
block|}
comment|/* If there are lines left to gobble, then gobble them now. */
for|for
control|(
name|line_end
operator|=
name|line_start
init|;
name|line_end
operator|<
name|bufend
condition|;
name|line_end
operator|++
control|)
if|if
condition|(
operator|*
name|line_end
operator|==
literal|'\n'
condition|)
block|{
comment|/* Change to allow Windows-like \r\n end of line delimiter. */
if|if
condition|(
name|line_end
operator|>
name|line_start
operator|&&
name|line_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|line_end
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|line_end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|line_start
condition|)
block|{
if|if
condition|(
name|HIST_TIMESTAMP_START
argument_list|(
name|line_start
argument_list|)
operator|==
literal|0
condition|)
block|{
name|add_history
argument_list|(
name|line_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_ts
condition|)
block|{
name|add_history_time
argument_list|(
name|last_ts
argument_list|)
expr_stmt|;
name|last_ts
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|last_ts
operator|=
name|line_start
expr_stmt|;
name|current_line
operator|--
expr_stmt|;
block|}
block|}
name|current_line
operator|++
expr_stmt|;
if|if
condition|(
name|current_line
operator|>=
name|to
condition|)
break|break;
name|line_start
operator|=
name|line_end
operator|+
literal|1
expr_stmt|;
block|}
name|FREE
argument_list|(
name|input
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HISTORY_USE_MMAP
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
name|munmap
argument_list|(
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Truncate the history file FNAME, leaving only LINES trailing lines.    If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno    on failure. */
end_comment

begin_function
name|int
name|history_truncate_file
parameter_list|(
name|fname
parameter_list|,
name|lines
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|lines
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|filename
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp1
decl_stmt|;
comment|/* bp1 == bp+1 */
name|int
name|file
decl_stmt|,
name|chars_read
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|size_t
name|file_size
decl_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|filename
operator|=
name|history_filename
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* Don't try to truncate non-regular files. */
if|if
condition|(
name|file
operator|==
operator|-
literal|1
operator|||
name|fstat
argument_list|(
name|file
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|truncate_exit
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EFTYPE
name|rv
operator|=
name|EFTYPE
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
goto|goto
name|truncate_exit
goto|;
block|}
name|file_size
operator|=
operator|(
name|size_t
operator|)
name|finfo
operator|.
name|st_size
expr_stmt|;
comment|/* check for overflow on very large files */
if|if
condition|(
name|file_size
operator|!=
name|finfo
operator|.
name|st_size
operator|||
name|file_size
operator|+
literal|1
operator|<
name|file_size
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|rv
operator|=
name|errno
operator|=
name|EFBIG
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EOVERFLOW
argument_list|)
name|rv
operator|=
name|errno
operator|=
name|EOVERFLOW
expr_stmt|;
else|#
directive|else
name|rv
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
goto|goto
name|truncate_exit
goto|;
block|}
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|file_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|truncate_exit
goto|;
block|}
name|chars_read
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_read
operator|<=
literal|0
condition|)
block|{
name|rv
operator|=
operator|(
name|chars_read
operator|<
literal|0
operator|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
goto|goto
name|truncate_exit
goto|;
block|}
comment|/* Count backwards from the end of buffer until we have passed      LINES lines.  bp1 is set funny initially.  But since bp[1] can't      be a comment character (since it's off the end) and *bp can't be      both a newline and the history comment character, it should be OK. */
for|for
control|(
name|bp1
operator|=
name|bp
operator|=
name|buffer
operator|+
name|chars_read
operator|-
literal|1
init|;
name|lines
operator|&&
name|bp
operator|>
name|buffer
condition|;
name|bp
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|HIST_TIMESTAMP_START
argument_list|(
name|bp1
argument_list|)
operator|==
literal|0
condition|)
name|lines
operator|--
expr_stmt|;
name|bp1
operator|=
name|bp
expr_stmt|;
block|}
comment|/* If this is the first line, then the file contains exactly the      number of lines we want to truncate to, so we don't need to do      anything.  It's the first line if we don't find a newline between      the current value of i and 0.  Otherwise, write from the start of      this line until the end of the buffer. */
for|for
control|(
init|;
name|bp
operator|>
name|buffer
condition|;
name|bp
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|HIST_TIMESTAMP_START
argument_list|(
name|bp1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|++
expr_stmt|;
break|break;
block|}
name|bp1
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Write only if there are more lines in the file than we want to      truncate to. */
if|if
condition|(
name|bp
operator|>
name|buffer
operator|&&
operator|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
literal|0600
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|write
argument_list|(
name|file
argument_list|,
name|bp
argument_list|,
name|chars_read
operator|-
operator|(
name|bp
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__BEOS__
argument_list|)
comment|/* BeOS ignores O_TRUNC. */
name|ftruncate
argument_list|(
name|file
argument_list|,
name|chars_read
operator|-
operator|(
name|bp
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|truncate_exit
label|:
name|FREE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* Workhorse function for writing history.  Writes NELEMENT entries    from the history list to FILENAME.  OVERWRITE is non-zero if you    wish to replace FILENAME with the entries. */
end_comment

begin_function
specifier|static
name|int
name|history_do_write
parameter_list|(
name|filename
parameter_list|,
name|nelements
parameter_list|,
name|overwrite
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|nelements
decl_stmt|,
name|overwrite
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|file
decl_stmt|,
name|mode
decl_stmt|,
name|rv
decl_stmt|;
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
name|size_t
name|cursize
decl_stmt|;
name|mode
operator|=
name|overwrite
condition|?
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
else|:
name|O_RDWR
operator||
name|O_APPEND
operator||
name|O_BINARY
expr_stmt|;
else|#
directive|else
name|mode
operator|=
name|overwrite
condition|?
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
else|:
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
name|output
operator|=
name|history_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|open
argument_list|(
name|output
argument_list|,
name|mode
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
name|cursize
operator|=
name|overwrite
condition|?
literal|0
else|:
name|lseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nelements
operator|>
name|history_length
condition|)
name|nelements
operator|=
name|history_length
expr_stmt|;
comment|/* Build a buffer of all the lines to write, and write them in one syscall.      Suggested by Peter Ho (peter@robosts.oxford.ac.uk). */
block|{
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
decl_stmt|;
comment|/* local */
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|buffer_size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|the_history
operator|=
name|history_list
argument_list|()
expr_stmt|;
comment|/* Calculate the total number of bytes to write. */
for|for
control|(
name|buffer_size
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
if|#
directive|if
literal|0
for|buffer_size += 2 + HISTENT_BYTES (the_history[i]);
else|#
directive|else
block|{
if|if
condition|(
name|history_write_timestamps
operator|&&
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
operator|&&
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
index|[
literal|0
index|]
condition|)
name|buffer_size
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buffer_size
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allocate the buffer, and fill it. */
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
if|if
condition|(
name|ftruncate
argument_list|(
name|file
argument_list|,
name|buffer_size
operator|+
name|cursize
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|mmap_error
goto|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|buffer_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_WFLAGS
argument_list|,
name|file
argument_list|,
name|cursize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|buffer
operator|==
name|MAP_FAILED
condition|)
block|{
name|mmap_error
label|:
name|rv
operator|=
name|errno
expr_stmt|;
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
else|#
directive|else
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|errno
expr_stmt|;
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|nelements
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|history_write_timestamps
operator|&&
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
operator|&&
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buffer
operator|+
name|j
argument_list|,
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HISTORY_USE_MMAP
if|if
condition|(
name|msync
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|munmap
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|)
operator|!=
literal|0
condition|)
name|rv
operator|=
name|errno
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|buffer_size
argument_list|)
operator|<
literal|0
condition|)
name|rv
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Append NELEMENT entries to FILENAME.  The entries appended are from    the end of the list minus NELEMENTs up to the end of the list. */
end_comment

begin_function
name|int
name|append_history
parameter_list|(
name|nelements
parameter_list|,
name|filename
parameter_list|)
name|int
name|nelements
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|nelements
argument_list|,
name|HISTORY_APPEND
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Overwrite FILENAME with the current history.  If FILENAME is NULL,    then write the history list to ~/.history.  Values returned    are as in read_history ().*/
end_comment

begin_function
name|int
name|write_history
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|history_do_write
argument_list|(
name|filename
argument_list|,
name|history_length
argument_list|,
name|HISTORY_OVERWRITE
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

