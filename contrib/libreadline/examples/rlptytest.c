begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Another test harness for the readline callback interface.  *  * Author: Bob Rossi<bob@brasko.net>  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* LINUX */
end_comment

begin_include
include|#
directive|include
file|<pty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|READLINE_LIBRARY
end_ifdef

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Master/Slave PTY used to keep readline off of stdin/stdout.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|masterfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slavefd
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sigint
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|tty_reset
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|masterfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|slavefd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|user_input
parameter_list|()
block|{
name|int
name|size
decl_stmt|;
specifier|const
name|int
name|MAX
init|=
literal|1024
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAX
operator|+
literal|1
argument_list|)
decl_stmt|;
name|size
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|buf
argument_list|,
name|MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|size
operator|=
name|write
argument_list|(
name|masterfd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|readline_input
parameter_list|()
block|{
specifier|const
name|int
name|MAX
init|=
literal|1024
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAX
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|read
argument_list|(
name|masterfd
argument_list|,
name|buf
argument_list|,
name|MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buf
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Display output from readline */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rlctx_send_user_command
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
comment|/* This happens when rl_callback_read_char gets EOF */
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"exit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tty_reset
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|masterfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|slavefd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Don't add the enter command */
if|if
condition|(
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'\0'
condition|)
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|custom_deprep_term_function
parameter_list|()
block|{ }
end_function

begin_function
specifier|static
name|int
name|init_readline
parameter_list|(
name|int
name|inputfd
parameter_list|,
name|int
name|outputfd
parameter_list|)
block|{
name|FILE
modifier|*
name|inputFILE
decl_stmt|,
modifier|*
name|outputFILE
decl_stmt|;
name|inputFILE
operator|=
name|fdopen
argument_list|(
name|inputfd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inputFILE
condition|)
return|return
operator|-
literal|1
return|;
name|outputFILE
operator|=
name|fdopen
argument_list|(
name|outputfd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputFILE
condition|)
return|return
operator|-
literal|1
return|;
name|rl_instream
operator|=
name|inputFILE
expr_stmt|;
name|rl_outstream
operator|=
name|outputFILE
expr_stmt|;
comment|/* Tell readline what the prompt is if it needs to put it back */
name|rl_callback_handler_install
argument_list|(
literal|"(rltest):  "
argument_list|,
name|rlctx_send_user_command
argument_list|)
expr_stmt|;
comment|/* Set the terminal type to dumb so the output of readline can be    * understood by tgdb */
if|if
condition|(
name|rl_reset_terminal
argument_list|(
literal|"dumb"
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For some reason, readline can not deprep the terminal.    * However, it doesn't matter because no other application is working on    * the terminal besides readline */
name|rl_deprep_term_function
operator|=
name|custom_deprep_term_function
expr_stmt|;
name|using_history
argument_list|()
expr_stmt|;
name|read_history
argument_list|(
literal|".history"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|main_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|fd_set
name|rset
decl_stmt|;
name|int
name|max
decl_stmt|;
name|max
operator|=
operator|(
name|masterfd
operator|>
name|STDIN_FILENO
operator|)
condition|?
name|masterfd
else|:
name|STDIN_FILENO
expr_stmt|;
name|max
operator|=
operator|(
name|max
operator|>
name|slavefd
operator|)
condition|?
name|max
else|:
name|slavefd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Reset the fd_set, and watch for input from GDB or stdin */
name|FD_ZERO
argument_list|(
operator|&
name|rset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|slavefd
argument_list|,
operator|&
name|rset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|masterfd
argument_list|,
operator|&
name|rset
argument_list|)
expr_stmt|;
comment|/* Wait for input */
if|if
condition|(
name|select
argument_list|(
name|max
operator|+
literal|1
argument_list|,
operator|&
name|rset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/* Input received through the pty:  Handle it         * Wrote to masterfd, slave fd has that input, alert readline to read it.         */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|slavefd
argument_list|,
operator|&
name|rset
argument_list|)
condition|)
name|rl_callback_read_char
argument_list|()
expr_stmt|;
comment|/* Input received through the pty.        * Readline read from slavefd, and it wrote to the masterfd.         */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|masterfd
argument_list|,
operator|&
name|rset
argument_list|)
condition|)
if|if
condition|(
name|readline_input
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Input received:  Handle it, write to masterfd (input to readline) */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rset
argument_list|)
condition|)
if|if
condition|(
name|user_input
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The terminal attributes before calling tty_cbreak */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|save_termios
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|winsize
name|size
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|RESET
block|,
name|TCBREAK
block|}
name|ttystate
init|=
name|RESET
enum|;
end_enum

begin_comment
comment|/* tty_cbreak: Sets terminal to cbreak mode. Also known as noncanonical mode.  *    1. Signal handling is still turned on, so the user can still type those.  *    2. echo is off  *    3. Read in one char at a time.  *  * fd    - The file descriptor of the terminal  *   * Returns: 0 on sucess, -1 on error  */
end_comment

begin_function
name|int
name|tty_cbreak
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|termios
name|buf
decl_stmt|;
name|int
name|ttysavefd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|save_termios
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|buf
operator|=
name|save_termios
expr_stmt|;
name|buf
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ICANON
operator|)
expr_stmt|;
name|buf
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|ICRNL
operator||
name|INLCR
operator|)
expr_stmt|;
name|buf
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|buf
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VLNEXT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
name|buf
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VDSUSP
argument_list|)
operator|&&
name|defined
argument_list|(
name|_POSIX_VDISABLE
argument_list|)
name|buf
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
endif|#
directive|endif
comment|/* enable flow control; only stty start char can restart output */
if|#
directive|if
literal|0
block|buf.c_iflag |= (IXON|IXOFF);
ifdef|#
directive|ifdef
name|IXANY
block|buf.c_iflag&= ~IXANY;
endif|#
directive|endif
endif|#
directive|endif
comment|/* disable flow control; let ^S and ^Q through to pty */
name|buf
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXANY
name|buf
operator|.
name|c_iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ttystate
operator|=
name|TCBREAK
expr_stmt|;
name|ttysavefd
operator|=
name|fd
expr_stmt|;
comment|/* set size */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|err_msg
argument_list|(
literal|"%d rows and %d cols\n"
argument_list|,
name|size
operator|.
name|ws_row
argument_list|,
name|size
operator|.
name|ws_col
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_off_xon_xoff
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|termios
name|buf
decl_stmt|;
name|int
name|ttysavefd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|buf
operator|.
name|c_iflag
operator|&=
operator|~
operator|(
name|IXON
operator||
name|IXOFF
operator|)
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* tty_reset: Sets the terminal attributes back to their previous state.  * PRE: tty_cbreak must have already been called.  *   * fd    - The file descrioptor of the terminal to reset.  *   * Returns: 0 on success, -1 on error  */
end_comment

begin_function
name|int
name|tty_reset
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|ttystate
operator|!=
name|TCBREAK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|save_termios
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ttystate
operator|=
name|RESET
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|openpty
argument_list|(
operator|&
name|masterfd
argument_list|,
operator|&
name|slavefd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|tty_off_xon_xoff
argument_list|(
name|masterfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|init_readline
argument_list|(
name|slavefd
argument_list|,
name|slavefd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|tty_cbreak
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
name|val
operator|=
name|main_loop
argument_list|()
expr_stmt|;
name|tty_reset
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

