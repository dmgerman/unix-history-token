begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A front-end using readline to "cook" input lines for Kawa.  *  * Copyright (C) 1999  Per Bothner  *   * This front-end program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as published  * by the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * Some code from Johnson& Troan: "Linux Application Development"  * (Addison-Wesley, 1998) was used directly or for inspiration.  */
end_comment

begin_comment
comment|/* PROBLEMS/TODO:  *  * Only tested under Linux;  needs to be ported.  *  * When running mc -c under the Linux console, mc does not recognize  * mouse clicks, which mc does when not running under fep.  *  * Pasting selected text containing tabs is like hitting the tab character,  * which invokes readline completion.  We don't want this.  I don't know  * if this is fixable without integrating fep into a terminal emulator.  *  * Echo suppression is a kludge, but can only be avoided with better kernel  * support: We need a tty mode to disable "real" echoing, while still  * letting the inferior think its tty driver to doing echoing.  * Stevens's book claims SCR$ and BSD4.3+ have TIOCREMOTE.  *  * The latest readline may have some hooks we can use to avoid having  * to back up the prompt.  *  * Desirable readline feature:  When in cooked no-echo mode (e.g. password),  * echo characters are they are types with '*', but remove them when done.  *  * A synchronous output while we're editing an input line should be  * inserted in the output view *before* the input line, so that the  * lines being edited (with the prompt) float at the end of the input.  *  * A "page mode" option to emulate more/less behavior:  At each page of  * output, pause for a user command.  This required parsing the output  * to keep track of line lengths.  It also requires remembering the  * output, if we want an option to scroll back, which suggests that  * this should be integrated with a terminal emulator like xterm.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|READLINE_LIBRARY
end_ifdef

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMMAND
end_ifndef

begin_define
define|#
directive|define
name|COMMAND
value|"/bin/sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMMAND_ARGS
end_ifndef

begin_define
define|#
directive|define
name|COMMAND_ARGS
value|COMMAND
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMMOVE
end_ifndef

begin_if
if|#
directive|if
name|__GNUC__
operator|>
literal|1
end_if

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|__builtin_memcpy(d, s, n)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|memcpy(d, s, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|memcpy(d, s, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|APPLICATION_NAME
value|"Fep"
end_define

begin_decl_stmt
specifier|static
name|int
name|in_from_inferior_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|out_to_inferior_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unfortunately, we cannot safely display echo from the inferior process.    The reason is that the echo bit in the pty is "owned" by the inferior,    and if we try to turn it off, we could confuse the inferior.    Thus, when echoing, we get echo twice:  First readline echoes while    we're actually editing. Then we send the line to the inferior, and the    terminal driver send back an extra echo.    The work-around is to remember the input lines, and when we see that    line come back, we supress the output.    A better solution (supposedly available on SVR4) would be a smarter    terminal driver, with more flags ... */
end_comment

begin_define
define|#
directive|define
name|ECHO_SUPPRESS_MAX
value|1024
end_define

begin_decl_stmt
name|char
name|echo_suppress_buffer
index|[
name|ECHO_SUPPRESS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|echo_suppress_start
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|echo_suppress_limit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|logfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINT0
parameter_list|(
name|FMT
parameter_list|)
value|(fprintf(logfile, FMT), fflush(logfile))
end_define

begin_define
define|#
directive|define
name|DPRINT1
parameter_list|(
name|FMT
parameter_list|,
name|V1
parameter_list|)
value|(fprintf(logfile, FMT, V1), fflush(logfile))
end_define

begin_define
define|#
directive|define
name|DPRINT2
parameter_list|(
name|FMT
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|)
value|(fprintf(logfile, FMT, V1, V2), fflush(logfile))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT0
parameter_list|(
name|FMT
parameter_list|)
end_define

begin_comment
comment|/* Do nothing */
end_comment

begin_define
define|#
directive|define
name|DPRINT1
parameter_list|(
name|FMT
parameter_list|,
name|V1
parameter_list|)
end_define

begin_comment
comment|/* Do nothing */
end_comment

begin_define
define|#
directive|define
name|DPRINT2
parameter_list|(
name|FMT
parameter_list|,
name|V1
parameter_list|,
name|V2
parameter_list|)
end_define

begin_comment
comment|/* Do nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|termios
name|orig_term
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of child process. */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|child
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sig_child
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|DPRINT0
argument_list|(
literal|"(Child process died.)\n"
argument_list|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|orig_term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|volatile
name|int
name|propagate_sigwinch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sigwinch_handler  * propagate window size changes from input file descriptor to  * master side of pty.  */
end_comment

begin_function
name|void
name|sigwinch_handler
parameter_list|(
name|int
name|signal
parameter_list|)
block|{
name|propagate_sigwinch
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_master_pty() takes a double-indirect character pointer in which  * to put a slave name, and returns an integer file descriptor.  * If it returns< 0, an error has occurred.  * Otherwise, it has returned the master pty file descriptor, and fills  * in *name with the name of the corresponding slave pty.  * Once the slave pty has been opened, you are responsible to free *name.  */
end_comment

begin_function
name|int
name|get_master_pty
parameter_list|(
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* default to returning error */
name|int
name|master
init|=
operator|-
literal|1
decl_stmt|;
comment|/* create a dummy name to fill in */
operator|*
name|name
operator|=
name|strdup
argument_list|(
literal|"/dev/ptyXX"
argument_list|)
expr_stmt|;
comment|/* search for an unused pty */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
operator|&&
name|master
operator|<=
literal|0
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|master
operator|<=
literal|0
condition|;
name|j
operator|++
control|)
block|{
operator|(
operator|*
name|name
operator|)
index|[
literal|5
index|]
operator|=
literal|'p'
expr_stmt|;
operator|(
operator|*
name|name
operator|)
index|[
literal|8
index|]
operator|=
literal|"pqrstuvwxyzPQRST"
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|name
operator|)
index|[
literal|9
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|j
index|]
expr_stmt|;
comment|/* open the master pty */
if|if
condition|(
operator|(
name|master
operator|=
name|open
argument_list|(
operator|*
name|name
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* we are out of pty devices */
name|free
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|master
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* By substituting a letter, we change the master pty             * name into the slave pty name.             */
operator|(
operator|*
name|name
operator|)
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
operator|*
name|name
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|master
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|master
operator|<
literal|0
operator|)
operator|&&
operator|(
name|i
operator|==
literal|16
operator|)
operator|&&
operator|(
name|j
operator|==
literal|16
operator|)
condition|)
block|{
comment|/* must have tried every pty unsuccessfully */
name|free
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|master
operator|)
return|;
block|}
operator|(
operator|*
name|name
operator|)
index|[
literal|5
index|]
operator|=
literal|'t'
expr_stmt|;
return|return
operator|(
name|master
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_slave_pty() returns an integer file descriptor.  * If it returns< 0, an error has occurred.  * Otherwise, it has returned the slave file descriptor.  */
end_comment

begin_function
name|int
name|get_slave_pty
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|gptr
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int
name|slave
init|=
operator|-
literal|1
decl_stmt|;
comment|/* chown/chmod the corresponding pty, if possible.     * This will only work if the process has root permissions.     * Alternatively, write and exec a small setuid program that     * does just this.     */
if|if
condition|(
operator|(
name|gptr
operator|=
name|getgrnam
argument_list|(
literal|"tty"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|gid
operator|=
name|gptr
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
block|{
comment|/* if the tty group does not exist, don't change the        * group on the slave pty, only the owner        */
name|gid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Note that we do not check for errors here.  If this is code     * where these actions are critical, check for errors!     */
name|chown
argument_list|(
name|name
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|gid
argument_list|)
expr_stmt|;
comment|/* This code only makes the slave read/writeable for the user.     * If this is for an interactive shell that will want to     * receive "write" and "wall" messages, OR S_IWGRP into the     * second argument below.     */
name|chmod
argument_list|(
name|name
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
comment|/* open the corresponding slave pty */
name|slave
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
return|return
operator|(
name|slave
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Certain special characters, such as ctrl/C, we want to pass directly    to the inferior, rather than letting readline handle them. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|special_chars
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_chars_count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_special_char
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|0
condition|)
name|special_chars
index|[
name|special_chars_count
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|eof_char
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|is_special_char
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|if (ch == eof_char&& rl_point == rl_end)     return 1;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|special_chars_count
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|special_chars
index|[
name|i
index|]
operator|==
name|ch
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buf[0 .. buf_count-1] is the what has been emitted on the current line.    It is used as the readline prompt. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buf_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_keys
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|null_prep_terminal
parameter_list|(
name|int
name|meta
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|null_deprep_terminal
parameter_list|()
block|{ }
end_function

begin_decl_stmt
name|char
name|pending_special_char
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|line_handler
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|DPRINT0
argument_list|(
literal|"saw eof!\n"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\004'
expr_stmt|;
comment|/* ctrl/d */
name|write
argument_list|(
name|out_to_inferior_fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|char
name|enter
index|[]
init|=
literal|"\r"
decl_stmt|;
comment|/*  Send line to inferior: */
name|int
name|length
init|=
name|strlen
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|ECHO_SUPPRESS_MAX
operator|-
literal|2
condition|)
block|{
name|echo_suppress_start
operator|=
literal|0
expr_stmt|;
name|echo_suppress_limit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|echo_suppress_limit
operator|+
name|length
operator|>
name|ECHO_SUPPRESS_MAX
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|echo_suppress_limit
operator|-
name|echo_suppress_start
operator|+
name|length
operator|<=
name|ECHO_SUPPRESS_MAX
operator|-
literal|2
condition|)
block|{
name|memmove
argument_list|(
name|echo_suppress_buffer
argument_list|,
name|echo_suppress_buffer
operator|+
name|echo_suppress_start
argument_list|,
name|echo_suppress_limit
operator|-
name|echo_suppress_start
argument_list|)
expr_stmt|;
name|echo_suppress_limit
operator|-=
name|echo_suppress_start
expr_stmt|;
name|echo_suppress_start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|echo_suppress_limit
operator|=
literal|0
expr_stmt|;
block|}
name|echo_suppress_start
operator|=
literal|0
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|echo_suppress_buffer
operator|+
name|echo_suppress_limit
argument_list|,
name|line
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|echo_suppress_limit
operator|+=
name|length
expr_stmt|;
name|echo_suppress_buffer
index|[
name|echo_suppress_limit
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|echo_suppress_buffer
index|[
name|echo_suppress_limit
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|write
argument_list|(
name|out_to_inferior_fd
argument_list|,
name|line
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_special_char
operator|==
literal|0
condition|)
block|{
name|write
argument_list|(
name|out_to_inferior_fd
argument_list|,
name|enter
argument_list|,
sizeof|sizeof
argument_list|(
name|enter
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
condition|)
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|rl_callback_handler_remove
argument_list|()
expr_stmt|;
name|buf_count
operator|=
literal|0
expr_stmt|;
name|num_keys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pending_special_char
operator|!=
literal|0
condition|)
block|{
name|write
argument_list|(
name|out_to_inferior_fd
argument_list|,
operator|&
name|pending_special_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_special_char
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Value of rl_getc_function.    Use this because readline should read from stdin, not rl_instream,    points to the pty (so readline has monitor its terminal modes). */
end_comment

begin_function
name|int
name|my_rl_getc
parameter_list|(
name|FILE
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|ch
init|=
name|rl_getc
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_special_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|pending_special_char
operator|=
name|ch
expr_stmt|;
return|return
literal|'\r'
return|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|master
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|in_from_tty_fd
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|struct
name|winsize
name|ws
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
name|fd_set
name|in_set
decl_stmt|;
specifier|static
name|char
name|empty_string
index|[
literal|1
index|]
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|empty_string
decl_stmt|;
name|int
name|ioctl_err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logfile
operator|=
name|fopen
argument_list|(
literal|"LOG"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rl_readline_name
operator|=
name|APPLICATION_NAME
expr_stmt|;
if|if
condition|(
operator|(
name|master
operator|=
name|get_master_pty
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ptypair: could not open master pty"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT1
argument_list|(
literal|"pty name: '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* set up SIGWINCH handler */
name|act
operator|.
name|sa_handler
operator|=
name|sigwinch_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|act
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGWINCH
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ptypair: could not handle SIGWINCH "
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ptypair: could not get window size"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|==
literal|0
condition|)
block|{
name|int
name|slave
decl_stmt|;
comment|/* file descriptor for slave pty */
comment|/* We are in the child process */
name|close
argument_list|(
name|master
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSCTTY
if|if
condition|(
operator|(
name|slave
operator|=
name|get_slave_pty
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ptypair: could not open slave pty"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We need to make this process a session group leader, because        * it is on a new PTY, and things like job control simply will        * not work correctly unless there is a session group leader        * and process group leader (which a session group leader        * automatically is). This also disassociates us from our old        * controlling tty.         */
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"could not set session leader"
argument_list|)
expr_stmt|;
block|}
comment|/* Tie us to our new controlling tty. */
ifdef|#
directive|ifdef
name|TIOCSCTTY
if|if
condition|(
name|ioctl
argument_list|(
name|slave
argument_list|,
name|TIOCSCTTY
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"could not set new controlling tty"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|slave
operator|=
name|get_slave_pty
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ptypair: could not open slave pty"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* make slave pty be standard in, out, and error */
name|dup2
argument_list|(
name|slave
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|slave
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|slave
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
comment|/* at this point the slave pty should be standard input */
if|if
condition|(
name|slave
operator|>
literal|2
condition|)
block|{
name|close
argument_list|(
name|slave
argument_list|)
expr_stmt|;
block|}
comment|/* Try to restore window size; failure isn't critical */
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"could not restore window size"
argument_list|)
expr_stmt|;
block|}
comment|/* now start the shell */
block|{
specifier|static
name|char
modifier|*
name|command_args
index|[]
init|=
block|{
name|COMMAND_ARGS
block|,
name|NULL
block|}
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|execvp
argument_list|(
name|COMMAND
argument_list|,
name|command_args
argument_list|)
expr_stmt|;
else|else
name|execvp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* should never be reached */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sig_child
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Note that we only set termios settings for standard input;    * the master side of a pty is NOT a tty.    */
name|tcgetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|orig_term
argument_list|)
expr_stmt|;
name|t
operator|=
name|orig_term
expr_stmt|;
name|eof_char
operator|=
name|t
operator|.
name|c_cc
index|[
name|VEOF
index|]
expr_stmt|;
comment|/*  add_special_char(t.c_cc[VEOF]);*/
name|add_special_char
argument_list|(
name|t
operator|.
name|c_cc
index|[
name|VINTR
index|]
argument_list|)
expr_stmt|;
name|add_special_char
argument_list|(
name|t
operator|.
name|c_cc
index|[
name|VQUIT
index|]
argument_list|)
expr_stmt|;
name|add_special_char
argument_list|(
name|t
operator|.
name|c_cc
index|[
name|VSUSP
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VDISCARD
argument_list|)
name|add_special_char
argument_list|(
name|t
operator|.
name|c_cc
index|[
name|VDISCARD
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|t.c_lflag |= (ICANON | ISIG | ECHO | ECHOCTL | ECHOE | \ 		ECHOK | ECHOKE | ECHONL | ECHOPRT );
else|#
directive|else
name|t
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ISIG
operator||
name|ECHO
operator||
name|ECHOCTL
operator||
name|ECHOE
operator||
expr|\
name|ECHOK
operator||
name|ECHOKE
operator||
name|ECHONL
operator||
name|ECHOPRT
operator|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|.
name|c_iflag
operator||=
name|IGNBRK
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|in_from_inferior_fd
operator|=
name|master
expr_stmt|;
name|out_to_inferior_fd
operator|=
name|master
expr_stmt|;
name|rl_instream
operator|=
name|fdopen
argument_list|(
name|master
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|rl_getc_function
operator|=
name|my_rl_getc
expr_stmt|;
name|rl_prep_term_function
operator|=
name|null_prep_terminal
expr_stmt|;
name|rl_deprep_term_function
operator|=
name|null_deprep_terminal
expr_stmt|;
name|rl_callback_handler_install
argument_list|(
name|prompt
argument_list|,
name|line_handler
argument_list|)
expr_stmt|;
name|in_from_tty_fd
operator|=
name|STDIN_FILENO
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|in_set
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|in_from_inferior_fd
operator|>
name|in_from_tty_fd
condition|?
name|in_from_inferior_fd
else|:
name|in_from_tty_fd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|num
decl_stmt|;
name|FD_SET
argument_list|(
name|in_from_inferior_fd
argument_list|,
operator|&
name|in_set
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|in_from_tty_fd
argument_list|,
operator|&
name|in_set
argument_list|)
expr_stmt|;
name|num
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|in_set
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|propagate_sigwinch
condition|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|master
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
expr_stmt|;
block|}
name|propagate_sigwinch
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|in_from_tty_fd
argument_list|,
operator|&
name|in_set
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|readline_echoing_p
decl_stmt|;
name|struct
name|termios
name|term_master
decl_stmt|;
name|int
name|do_canon
init|=
literal|1
decl_stmt|;
name|int
name|ioctl_ret
decl_stmt|;
name|DPRINT1
argument_list|(
literal|"[tty avail num_keys:%d]\n"
argument_list|,
name|num_keys
argument_list|)
expr_stmt|;
comment|/* If we can't get tty modes for the master side of the pty, we 	     can't handle non-canonical-mode programs.  Always assume the 	     master is in canonical echo mode if we can't tell. */
name|ioctl_ret
operator|=
name|tcgetattr
argument_list|(
name|master
argument_list|,
operator|&
name|term_master
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_ret
operator|>=
literal|0
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"echo:%d, canon:%d\n"
argument_list|,
operator|(
name|term_master
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|term_master
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|do_canon
operator|=
operator|(
name|term_master
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
operator|!=
literal|0
expr_stmt|;
name|readline_echoing_p
operator|=
operator|(
name|term_master
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl_err
operator|==
literal|0
condition|)
name|DPRINT1
argument_list|(
literal|"tcgetattr on master fd failed: errno = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|ioctl_err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_canon
operator|==
literal|0
operator|&&
name|num_keys
operator|==
literal|0
condition|)
block|{
name|char
name|ch
index|[
literal|10
index|]
decl_stmt|;
name|int
name|count
init|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|out_to_inferior_fd
argument_list|,
name|ch
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|num_keys
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Re-install callback handler for new prompt. */
if|if
condition|(
name|prompt
operator|!=
name|empty_string
condition|)
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|prompt
operator|=
name|malloc
argument_list|(
name|buf_count
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
operator|==
name|NULL
condition|)
name|prompt
operator|=
name|empty_string
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|prompt
argument_list|,
name|buf
argument_list|,
name|buf_count
argument_list|)
expr_stmt|;
name|prompt
index|[
name|buf_count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|DPRINT1
argument_list|(
literal|"New prompt '%s'\n"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ifdef HAVE_RL_ALREADY_PROMPTED -- doesn't work */
block|rl_already_prompted = buf_count> 0;
else|#
directive|else
if|if
condition|(
name|buf_count
operator|>
literal|0
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|rl_callback_handler_install
argument_list|(
name|prompt
argument_list|,
name|line_handler
argument_list|)
expr_stmt|;
block|}
name|num_keys
operator|++
expr_stmt|;
name|rl_callback_read_char
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|/* input from inferior. */
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old_count
decl_stmt|;
if|if
condition|(
name|buf_count
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|>>
literal|2
operator|)
condition|)
name|buf_count
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|read
argument_list|(
name|in_from_inferior_fd
argument_list|,
name|buf
operator|+
name|buf_count
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|buf_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
name|DPRINT0
argument_list|(
literal|"(Connection closed by foreign host.)\n"
argument_list|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|STDIN_FILENO
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|orig_term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_count
operator|=
name|buf_count
expr_stmt|;
comment|/* Look for any pending echo that we need to suppress. */
while|while
condition|(
name|echo_suppress_start
operator|<
name|echo_suppress_limit
operator|&&
name|count
operator|>
literal|0
operator|&&
name|buf
index|[
name|buf_count
index|]
operator|==
name|echo_suppress_buffer
index|[
name|echo_suppress_start
index|]
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|buf_count
operator|++
expr_stmt|;
name|echo_suppress_start
operator|++
expr_stmt|;
block|}
comment|/* Write to the terminal anything that was not suppressed. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
operator|+
name|buf_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Finally, look for a prompt candidate.            * When we get around to going input (from the keyboard),            * we will consider the prompt to be anything since the last            * line terminator.  So we need to save that text in the            * initial part of buf.  However, anything before the            * most recent end-of-line is not interesting. */
name|buf_count
operator|+=
name|count
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
name|buf_count
init|;
operator|--
name|i
operator|>=
name|old_count
condition|;
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
name|buf_count
operator|-
literal|1
init|;
name|i
operator|--
operator|>=
name|buf_count
operator|-
name|count
condition|;
control|)
endif|#
directive|endif
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|buf_count
operator|-
name|i
argument_list|)
expr_stmt|;
name|buf_count
operator|-=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|DPRINT2
argument_list|(
literal|"-> i: %d, buf_count: %d\n"
argument_list|,
name|i
argument_list|,
name|buf_count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

