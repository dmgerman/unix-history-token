begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Readline.h -- the names of functions callable from within readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987-2005 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_READLINE_H_
argument_list|)
end_if

begin_define
define|#
directive|define
name|_READLINE_H_
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|READLINE_LIBRARY
argument_list|)
include|#
directive|include
file|"rlstdc.h"
include|#
directive|include
file|"rltypedefs.h"
include|#
directive|include
file|"keymaps.h"
include|#
directive|include
file|"tilde.h"
else|#
directive|else
include|#
directive|include
file|<readline/rlstdc.h>
include|#
directive|include
file|<readline/rltypedefs.h>
include|#
directive|include
file|<readline/keymaps.h>
include|#
directive|include
file|<readline/tilde.h>
endif|#
directive|endif
comment|/* Hex-encoded Readline version number. */
define|#
directive|define
name|RL_READLINE_VERSION
value|0x0502
comment|/* Readline 5.2 */
define|#
directive|define
name|RL_VERSION_MAJOR
value|5
define|#
directive|define
name|RL_VERSION_MINOR
value|2
comment|/* Readline data structures. */
comment|/* Maintaining the state of undo.  We remember individual deletes and inserts    on a chain of things to do. */
comment|/* The actions that undo knows how to undo.  Notice that UNDO_DELETE means    to insert some text, and UNDO_INSERT means to delete some text.   I.e.,    the code tells undo what to undo, not how to undo it. */
enum|enum
name|undo_code
block|{
name|UNDO_DELETE
block|,
name|UNDO_INSERT
block|,
name|UNDO_BEGIN
block|,
name|UNDO_END
block|}
enum|;
comment|/* What an element of THE_UNDO_LIST looks like. */
typedef|typedef
struct|struct
name|undo_list
block|{
name|struct
name|undo_list
modifier|*
name|next
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* Where the change took place. */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The text to insert, if undoing a delete. */
name|enum
name|undo_code
name|what
decl_stmt|;
comment|/* Delete, Insert, Begin, End. */
block|}
name|UNDO_LIST
typedef|;
comment|/* The current undo list for RL_LINE_BUFFER. */
specifier|extern
name|UNDO_LIST
modifier|*
name|rl_undo_list
decl_stmt|;
comment|/* The data structure for mapping textual names to code addresses. */
typedef|typedef
struct|struct
name|_funmap
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|rl_command_func_t
modifier|*
name|function
decl_stmt|;
block|}
name|FUNMAP
typedef|;
specifier|extern
name|FUNMAP
modifier|*
modifier|*
name|funmap
decl_stmt|;
comment|/* **************************************************************** */
comment|/*								    */
comment|/*	     Functions available to bind to key sequences	    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* Bindable commands for numeric arguments. */
specifier|extern
name|int
name|rl_digit_argument
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_universal_argument
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for moving the cursor. */
specifier|extern
name|int
name|rl_forward_byte
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_byte
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_beg_of_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_of_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_refresh_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_clear_screen
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_arrow_keys
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for inserting and deleting text. */
specifier|extern
name|int
name|rl_insert
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_quoted_insert
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_tab_insert
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_newline
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_do_lowercase_version
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_rubout
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_rubout_or_delete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete_horizontal_space
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete_or_show_completions
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_insert_comment
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for changing case. */
specifier|extern
name|int
name|rl_upcase_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_downcase_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_capitalize_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for transposing characters and words. */
specifier|extern
name|int
name|rl_transpose_words
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_transpose_chars
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for searching within a line. */
specifier|extern
name|int
name|rl_char_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_char_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for readline's interface to the command history. */
specifier|extern
name|int
name|rl_beginning_of_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_of_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_get_next_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_get_previous_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for managing the mark and region. */
specifier|extern
name|int
name|rl_set_mark
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_exchange_point_and_mark
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands to set the editing mode (emacs or vi). */
specifier|extern
name|int
name|rl_vi_editing_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_emacs_editing_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands to change the insert mode (insert or overwrite) */
specifier|extern
name|int
name|rl_overwrite_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for managing key bindings. */
specifier|extern
name|int
name|rl_re_read_init_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_functions
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_macros
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_variables
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for word completion. */
specifier|extern
name|int
name|rl_complete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_possible_completions
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_insert_completions
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_menu_complete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for killing and yanking text, and managing the kill ring. */
specifier|extern
name|int
name|rl_kill_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_kill_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_kill_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_full_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unix_word_rubout
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unix_filename_rubout
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unix_line_discard
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_region_to_kill
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_region
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_forward_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_backward_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_pop
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_nth_arg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_last_arg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Not available unless __CYGWIN__ is defined. */
ifdef|#
directive|ifdef
name|__CYGWIN__
specifier|extern
name|int
name|rl_paste_from_clipboard
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Bindable commands for incremental searching. */
specifier|extern
name|int
name|rl_reverse_search_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward_search_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable keyboard macro commands. */
specifier|extern
name|int
name|rl_start_kbd_macro
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_kbd_macro
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_call_last_kbd_macro
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable undo commands. */
specifier|extern
name|int
name|rl_revert_line
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_undo_command
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable tilde expansion commands. */
specifier|extern
name|int
name|rl_tilde_expand
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable terminal control commands. */
specifier|extern
name|int
name|rl_restart_output
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_stop_output
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Miscellaneous bindable commands. */
specifier|extern
name|int
name|rl_abort
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_tty_status
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for incremental and non-incremental history searching. */
specifier|extern
name|int
name|rl_history_search_forward
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_history_search_backward
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_forward_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_reverse_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_forward_search_again
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_reverse_search_again
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable command used when inserting a matching close character. */
specifier|extern
name|int
name|rl_insert_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Not available unless READLINE_CALLBACKS is defined. */
specifier|extern
name|void
name|rl_callback_handler_install
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_vcpfunc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_callback_read_char
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_callback_handler_remove
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
comment|/* VI-mode bindable commands. */
specifier|extern
name|int
name|rl_vi_redo
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_undo
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_yank_arg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_fetch_history
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_search_again
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_complete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_tilde_expand
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_prev_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_next_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_end_word
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_insert_beg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_append_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_append_eol
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eof_maybe
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_insertion_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_movement_mode
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_arg_digit
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_case
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_put
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_column
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_delete_to
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_to
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_yank_to
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_rubout
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_delete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_back_to_indent
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_first_print
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_char_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_match
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_subst
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_overstrike
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_overstrike_delete
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_replace
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_set_mark
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_goto_mark
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* VI-mode utility functions. */
specifier|extern
name|int
name|rl_vi_check
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_domove
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bracktype
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_vi_start_inserting
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* VI-mode pseudo-bindable commands, used as utility functions. */
specifier|extern
name|int
name|rl_vi_fWord
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bWord
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eWord
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_fword
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bword
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eword
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Well Published Functions		    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* Readline functions. */
comment|/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
specifier|extern
name|char
modifier|*
name|readline
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_set_prompt
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_expand_prompt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_initialize
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented; unused by readline */
specifier|extern
name|int
name|rl_discard_argument
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Utility functions to bind keys to readline commands. */
specifier|extern
name|int
name|rl_add_defun
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key_in_map
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_key
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_key_in_map
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key_if_unbound
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key_if_unbound_in_map
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_function_in_map
name|PARAMS
argument_list|(
operator|(
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_command_in_map
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_keyseq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_keyseq_in_map
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_keyseq_if_unbound
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_keyseq_if_unbound_in_map
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_generic_bind
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_variable_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_variable_bind
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Backwards compatibility, use rl_bind_keyseq_in_map instead. */
specifier|extern
name|int
name|rl_set_key
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
comment|/* Backwards compatibility, use rl_generic_bind instead. */
specifier|extern
name|int
name|rl_macro_bind
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented in the texinfo manual; not really useful to programs. */
specifier|extern
name|int
name|rl_translate_keyseq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_untranslate_keyseq
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|rl_command_func_t
modifier|*
name|rl_named_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|rl_command_func_t
modifier|*
name|rl_function_of_keyseq
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|Keymap
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_list_funmap_names
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs_in_map
name|PARAMS
argument_list|(
operator|(
name|rl_command_func_t
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs
name|PARAMS
argument_list|(
operator|(
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_function_dumper
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_macro_dumper
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_variable_dumper
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_read_init_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_parse_and_bind
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for manipulating keymaps. */
specifier|extern
name|Keymap
name|rl_make_bare_keymap
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_copy_keymap
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_make_keymap
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_discard_keymap
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_get_keymap_by_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_get_keymap_name
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_set_keymap
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_get_keymap
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented; used internally only. */
specifier|extern
name|void
name|rl_set_keymap_from_edit_mode
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_get_keymap_name_from_edit_mode
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for manipulating the funmap, which maps command names to functions. */
specifier|extern
name|int
name|rl_add_funmap_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
modifier|*
name|rl_funmap_names
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented, only used internally -- there is only one funmap, and this    function may be called only once. */
specifier|extern
name|void
name|rl_initialize_funmap
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Utility functions for managing keyboard macros. */
specifier|extern
name|void
name|rl_push_macro_input
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for undoing, from undo.c */
specifier|extern
name|void
name|rl_add_undo
name|PARAMS
argument_list|(
operator|(
expr|enum
name|undo_code
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_free_undo_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_do_undo
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_begin_undo_group
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_undo_group
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_modifying
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for redisplay. */
specifier|extern
name|void
name|rl_redisplay
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_on_new_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_on_new_line_with_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forced_update_display
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_clear_message
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_reset_line_state
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_crlf
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_VARARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
specifier|extern
name|int
name|rl_message
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|printf
parameter_list|,
function_decl|1
operator|,
function_decl|2
block|)
end_extern

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|rl_message
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|rl_show_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Undocumented in texinfo manual. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_character_len
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save and restore internal prompt redisplay information. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|rl_save_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_restore_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Modifying text. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|rl_replace_line
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_insert_text
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_delete_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_kill_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_copy_text
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal and tty mode management. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|rl_prep_terminal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_deprep_terminal
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_tty_set_default_bindings
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_tty_unset_default_bindings
name|PARAMS
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_reset_terminal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_resize_terminal
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_set_screen_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_get_screen_size
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_reset_screen_size
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_get_termcap
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for character input. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_stuff_char
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_execute_next
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_clear_pending_input
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_read_key
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_getc
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_set_keyboard_input_timeout
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `Public' utility functions . */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|rl_extend_line_buffer
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_ding
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_alphabetic
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Readline signal handling, from signals.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_set_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_clear_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_cleanup_after_signal
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_reset_after_signal
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_free_line_state
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_set_paren_blink_timeout
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Undocumented. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_maybe_save_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_maybe_unsave_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_maybe_replace_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Completion functions. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_complete_internal
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|rl_display_match_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|rl_completion_matches
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rl_compentry_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_username_completion_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_filename_completion_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_mode
name|PARAMS
argument_list|(
operator|(
name|rl_command_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|RL_NO_COMPAT
argument_list|)
end_if

begin_comment
comment|/* Backwards compatibility (compat.c).  These will go away sometime. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|free_undo_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maybe_save_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maybe_unsave_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maybe_replace_line
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ding
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|alphabetic
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|crlf
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|completion_matches
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|rl_compentry_func_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|username_completion_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|filename_completion_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Well Published Variables		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The version of this incarnation of the readline library. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_library_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* e.g., "4.2" */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_readline_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* e.g., 0x0402 */
end_comment

begin_comment
comment|/* True if this is real GNU readline. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_gnu_readline_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags word encapsulating the current readline state. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_readline_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Says which editing mode readline is currently using.  1 means emacs mode;    0 means vi mode. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_editing_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert or overwrite mode for emacs mode.  1 means insert mode; 0 means    overwrite mode.  Reset to insert mode on each input line. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_insert_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the calling program.  You should initialize this to    whatever was in argv[0].  It is used when parsing conditionals. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_readline_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The prompt readline uses.  This is set from the argument to    readline (), and should not be assigned to directly. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The line buffer that is in use. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The location of point, and end. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mark, or saved cursor position. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_mark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to indicate that readline has finished with the current input    line and should return it. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set to a character value, that will be the next keystroke read. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_pending_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we called this function from _rl_dispatch().  It's present    so functions can find out whether they were called from a key binding    or directly from an application. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_dispatching
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if the user typed a numeric argument before executing the    current function. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_explicit_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current value of the numeric argument specified by the user. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_numeric_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address of the last command function Readline executed. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_command_func_t
modifier|*
name|rl_last_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the terminal to use. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_terminal_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The input and output streams. */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_outstream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, Readline gives values of LINES and COLUMNS from the environment    greater precedence than values fetched from the kernel when computing the    screen dimensions. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_prefer_env_winsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then this is the address of a function to call just    before readline_internal () prints the first prompt. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_hook_func_t
modifier|*
name|rl_startup_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is the address of a function to call just before    readline_internal_setup () returns and readline_internal starts    reading input characters. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_hook_func_t
modifier|*
name|rl_pre_input_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address of a function to call periodically while Readline is    awaiting character input, or NULL, for no event handling. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_hook_func_t
modifier|*
name|rl_event_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address of the function to call to fetch a character from the current    Readline input stream */
end_comment

begin_decl_stmt
specifier|extern
name|rl_getc_func_t
modifier|*
name|rl_getc_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rl_voidfunc_t
modifier|*
name|rl_redisplay_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rl_vintfunc_t
modifier|*
name|rl_prep_term_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rl_voidfunc_t
modifier|*
name|rl_deprep_term_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dispatch variables. */
end_comment

begin_decl_stmt
specifier|extern
name|Keymap
name|rl_executing_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Keymap
name|rl_binding_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display variables. */
end_comment

begin_comment
comment|/* If non-zero, readline will erase the entire line, including any prompt,    if the only thing typed on an otherwise-blank line is something bound to    rl_newline. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_erase_empty_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, the application has already printed the prompt (rl_prompt)    before calling readline, so readline should not output it the first time    redisplay is done. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_already_prompted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A non-zero value means to read only this many characters rather than    up to a character bound to accept-line. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_num_chars_to_read
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The text of a currently-executing keyboard macro. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_executing_macro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables to control readline signal handling. */
end_comment

begin_comment
comment|/* If non-zero, readline will install its own signal handlers for    SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_catch_signals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, readline will install a signal handler for SIGWINCH    that also attempts to call any calling application's SIGWINCH signal    handler.  Note that the terminal is not cleaned up before the    application's signal handler is called; use rl_cleanup_after_signal()    to do that. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_catch_sigwinch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Completion variables. */
end_comment

begin_comment
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use rl_filename_completion_function (), the default    filename completer. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_compentry_func_t
modifier|*
name|rl_completion_entry_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If rl_ignore_some_completions_function is non-NULL it is the address    of a function to call after all of the possible matches have been    generated, but before the actual completion is done to the input line.    The function is called with one argument; a NULL terminated array    of (char *).  If your function removes any of the elements, they    must be free()'ed. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_compignore_func_t
modifier|*
name|rl_ignore_some_completions_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_completion_func_t
modifier|*
name|rl_attempted_completion_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The initial contents of this variable is what    breaks words in the shell, i.e. "n\"\\'`@$>". */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_basic_word_break_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
end_comment

begin_decl_stmt
specifier|extern
comment|/*const*/
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook function to allow an application to set the completion word    break characters before readline breaks up the line.  Allows    position-dependent word break characters. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_cpvfunc_t
modifier|*
name|rl_completion_word_break_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters which can be used to quote a substring of the line.    Completion occurs on the entire substring, and within the substring       rl_completer_word_break_characters are treated as any other character,    unless they also appear within this list. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_completer_quote_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of quote characters which cause a word break. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_basic_quote_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that need to be quoted in filenames by the completer. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_filename_quote_characters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|rl_special_prefixes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing on a directory name.  The function is called with    the address of a string (the current directory name) as an arg.  It    changes what is displayed when the possible completions are printed    or inserted. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_icppfunc_t
modifier|*
name|rl_directory_completion_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is the address of a function to call when completing    a directory name.  This function takes the address of the directory name    to be modified as an argument.  Unlike rl_directory_completion_hook, it    only modifies the directory name used in opendir(2), not what is displayed    when the possible completions are printed or inserted.  It is called    before rl_directory_completion_hook.  I'm not happy with how this works    yet, so it's undocumented. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_icppfunc_t
modifier|*
name|rl_directory_rewrite_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Backwards compatibility with previous versions of readline. */
end_comment

begin_define
define|#
directive|define
name|rl_symbolic_link_hook
value|rl_directory_completion_hook
end_define

begin_comment
comment|/* If non-zero, then this is the address of a function to call when    completing a word would normally display the list of possible matches.    This function is called instead of actually doing the display.    It takes three arguments: (char **matches, int num_matches, int max_length)    where MATCHES is the array of strings that matched, NUM_MATCHES is the    number of strings in that array, and MAX_LENGTH is the length of the    longest string in that array. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_compdisp_func_t
modifier|*
name|rl_completion_display_matches_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_filename_completion_desired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the results of the matches are to be quoted using    double quotes (or an application-specific quoting mechanism) if the    filename contains any characters in rl_word_break_chars.  This is    ALWAYS non-zero on entry, and can only be changed within a completion    entry finder function. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_filename_quoting_desired
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a function to quote a filename in an application-specific fashion.    Called with the text to quote, the type of match found (single or multiple)    and a pointer to the quoting character to be used, which the function can    reset if desired. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_quote_func_t
modifier|*
name|rl_filename_quoting_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to remove quoting characters from a filename.  Called    before completion is attempted, so the embedded quotes do not interfere    with matching names in the file system. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_dequote_func_t
modifier|*
name|rl_filename_dequoting_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call to decide whether or not a word break character is    quoted.  If a character is quoted, it does not break words for the    completer. */
end_comment

begin_decl_stmt
specifier|extern
name|rl_linebuf_func_t
modifier|*
name|rl_char_is_quoted_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to suppress normal filename completion after the    user-specified completion function has been called. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_attempted_completion_over
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a character describing the type of completion being attempted by    rl_complete_internal; available for use by application completion    functions. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if she    is sure she wants to see them all.  The default value is 100. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_query_items
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character appended to completed words when at the end of the line.  The    default is a space.  Nothing is added if this is '\0'. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_append_character
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set to non-zero by an application completion function,    rl_completion_append_character will not be appended. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_suppress_append
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to any quote character readline thinks it finds before any application    completion function is called. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_quote_character
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to a non-zero value if readline found quoting anywhere in the word to    be completed; set before any application completion function is called. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_found_quote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, the completion functions don't append any closing quote.    This is set to 0 by rl_complete_internal and may be changed by an    application-specific completion function. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_suppress_quote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, a slash will be appended to completed filenames that are    symbolic links to directory names, subject to the value of the    mark-directories variable (which is user-settable).  This exists so    that application completion functions can override the user's preference    (set via the mark-symlinked-directories variable) if appropriate.    It's set to the value of _rl_complete_mark_symlink_dirs in    rl_complete_internal before any application-specific completion    function is called, so without that function doing anything, the user's    preferences are honored. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_completion_mark_symlink_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, then disallow duplicates in the matches. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_ignore_completion_duplicates
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this is non-zero, completion is (temporarily) inhibited, and the    completion character will be inserted as any other. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_inhibit_completion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input error; can be returned by (*rl_getc_function) if readline is reading    a top-level command (RL_ISSTATE (RL_STATE_READCMD)). */
end_comment

begin_define
define|#
directive|define
name|READERR
value|(-2)
end_define

begin_comment
comment|/* Definitions available for use by readline clients. */
end_comment

begin_define
define|#
directive|define
name|RL_PROMPT_START_IGNORE
value|'\001'
end_define

begin_define
define|#
directive|define
name|RL_PROMPT_END_IGNORE
value|'\002'
end_define

begin_comment
comment|/* Possible values for do_replace argument to rl_filename_quoting_function,    called by rl_complete_internal. */
end_comment

begin_define
define|#
directive|define
name|NO_MATCH
value|0
end_define

begin_define
define|#
directive|define
name|SINGLE_MATCH
value|1
end_define

begin_define
define|#
directive|define
name|MULT_MATCH
value|2
end_define

begin_comment
comment|/* Possible state values for rl_readline_state */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_NONE
value|0x000000
end_define

begin_comment
comment|/* no state; before first call */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_INITIALIZING
value|0x000001
end_define

begin_comment
comment|/* initializing */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_INITIALIZED
value|0x000002
end_define

begin_comment
comment|/* initialization done */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_TERMPREPPED
value|0x000004
end_define

begin_comment
comment|/* terminal is prepped */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_READCMD
value|0x000008
end_define

begin_comment
comment|/* reading a command key */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_METANEXT
value|0x000010
end_define

begin_comment
comment|/* reading input after ESC */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_DISPATCHING
value|0x000020
end_define

begin_comment
comment|/* dispatching to a command */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_MOREINPUT
value|0x000040
end_define

begin_comment
comment|/* reading more input in a command function */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_ISEARCH
value|0x000080
end_define

begin_comment
comment|/* doing incremental search */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_NSEARCH
value|0x000100
end_define

begin_comment
comment|/* doing non-inc search */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_SEARCH
value|0x000200
end_define

begin_comment
comment|/* doing a history search */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_NUMERICARG
value|0x000400
end_define

begin_comment
comment|/* reading numeric argument */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_MACROINPUT
value|0x000800
end_define

begin_comment
comment|/* getting input from a macro */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_MACRODEF
value|0x001000
end_define

begin_comment
comment|/* defining keyboard macro */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_OVERWRITE
value|0x002000
end_define

begin_comment
comment|/* overwrite mode */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_COMPLETING
value|0x004000
end_define

begin_comment
comment|/* doing completion */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_SIGHANDLER
value|0x008000
end_define

begin_comment
comment|/* in readline sighandler */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_UNDOING
value|0x010000
end_define

begin_comment
comment|/* doing an undo */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_INPUTPENDING
value|0x020000
end_define

begin_comment
comment|/* rl_execute_next called */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_TTYCSAVED
value|0x040000
end_define

begin_comment
comment|/* tty special chars saved */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_CALLBACK
value|0x080000
end_define

begin_comment
comment|/* using the callback interface */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_VIMOTION
value|0x100000
end_define

begin_comment
comment|/* reading vi motion arg */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_MULTIKEY
value|0x200000
end_define

begin_comment
comment|/* reading multiple-key command */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_VICMDONCE
value|0x400000
end_define

begin_comment
comment|/* entered vi command mode at least once */
end_comment

begin_define
define|#
directive|define
name|RL_STATE_DONE
value|0x800000
end_define

begin_comment
comment|/* done; accepted line */
end_comment

begin_define
define|#
directive|define
name|RL_SETSTATE
parameter_list|(
name|x
parameter_list|)
value|(rl_readline_state |= (x))
end_define

begin_define
define|#
directive|define
name|RL_UNSETSTATE
parameter_list|(
name|x
parameter_list|)
value|(rl_readline_state&= ~(x))
end_define

begin_define
define|#
directive|define
name|RL_ISSTATE
parameter_list|(
name|x
parameter_list|)
value|(rl_readline_state& (x))
end_define

begin_struct
struct|struct
name|readline_state
block|{
comment|/* line state */
name|int
name|point
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|mark
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|UNDO_LIST
modifier|*
name|ul
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
comment|/* global state */
name|int
name|rlstate
decl_stmt|;
name|int
name|done
decl_stmt|;
name|Keymap
name|kmap
decl_stmt|;
comment|/* input state */
name|rl_command_func_t
modifier|*
name|lastfunc
decl_stmt|;
name|int
name|insmode
decl_stmt|;
name|int
name|edmode
decl_stmt|;
name|int
name|kseqlen
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
name|int
name|pendingin
decl_stmt|;
name|char
modifier|*
name|macro
decl_stmt|;
comment|/* signal state */
name|int
name|catchsigs
decl_stmt|;
name|int
name|catchsigwinch
decl_stmt|;
comment|/* search state */
comment|/* completion state */
comment|/* options state */
comment|/* reserved for future expansion, so the struct size doesn't change */
name|char
name|reserved
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|rl_save_state
name|PARAMS
argument_list|(
operator|(
expr|struct
name|readline_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_restore_state
name|PARAMS
argument_list|(
operator|(
expr|struct
name|readline_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|RL_NO_COMPAT
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|savestring
argument_list|)
end_if

begin_define
define|#
directive|define
name|savestring
value|rl_savestring
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|savestring
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX backwards compatibility */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _READLINE_H_ */
end_comment

end_unit

