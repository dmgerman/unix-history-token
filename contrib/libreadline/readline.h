begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Readline.h -- the names of functions callable from within readline. */
end_comment

begin_comment
comment|/* Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.     This file is part of the GNU Readline Library, a library for    reading lines of text with interactive input and history editing.     The GNU Readline Library is free software; you can redistribute it    and/or modify it under the terms of the GNU General Public License    as published by the Free Software Foundation; either version 2, or    (at your option) any later version.     The GNU Readline Library is distributed in the hope that it will be    useful, but WITHOUT ANY WARRANTY; without even the implied warranty    of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_READLINE_H_
argument_list|)
end_if

begin_define
define|#
directive|define
name|_READLINE_H_
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|READLINE_LIBRARY
argument_list|)
include|#
directive|include
file|"rlstdc.h"
include|#
directive|include
file|"keymaps.h"
include|#
directive|include
file|"tilde.h"
else|#
directive|else
include|#
directive|include
file|<readline/rlstdc.h>
include|#
directive|include
file|<readline/keymaps.h>
include|#
directive|include
file|<readline/tilde.h>
endif|#
directive|endif
comment|/* Readline data structures. */
comment|/* Maintaining the state of undo.  We remember individual deletes and inserts    on a chain of things to do. */
comment|/* The actions that undo knows how to undo.  Notice that UNDO_DELETE means    to insert some text, and UNDO_INSERT means to delete some text.   I.e.,    the code tells undo what to undo, not how to undo it. */
enum|enum
name|undo_code
block|{
name|UNDO_DELETE
block|,
name|UNDO_INSERT
block|,
name|UNDO_BEGIN
block|,
name|UNDO_END
block|}
enum|;
comment|/* What an element of THE_UNDO_LIST looks like. */
typedef|typedef
struct|struct
name|undo_list
block|{
name|struct
name|undo_list
modifier|*
name|next
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* Where the change took place. */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The text to insert, if undoing a delete. */
name|enum
name|undo_code
name|what
decl_stmt|;
comment|/* Delete, Insert, Begin, End. */
block|}
name|UNDO_LIST
typedef|;
comment|/* The current undo list for RL_LINE_BUFFER. */
specifier|extern
name|UNDO_LIST
modifier|*
name|rl_undo_list
decl_stmt|;
comment|/* The data structure for mapping textual names to code addresses. */
typedef|typedef
struct|struct
name|_funmap
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|Function
modifier|*
name|function
decl_stmt|;
block|}
name|FUNMAP
typedef|;
specifier|extern
name|FUNMAP
modifier|*
modifier|*
name|funmap
decl_stmt|;
comment|/* **************************************************************** */
comment|/*								    */
comment|/*	     Functions available to bind to key sequences	    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* Bindable commands for numeric arguments. */
specifier|extern
name|int
name|rl_digit_argument
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_universal_argument
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for moving the cursor. */
specifier|extern
name|int
name|rl_forward
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_beg_of_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_of_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_refresh_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_clear_screen
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_arrow_keys
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for inserting and deleting text. */
specifier|extern
name|int
name|rl_insert
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_quoted_insert
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_tab_insert
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_newline
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_do_lowercase_version
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_rubout
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_rubout_or_delete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete_horizontal_space
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete_or_show_completions
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_insert_comment
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for changing case. */
specifier|extern
name|int
name|rl_upcase_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_downcase_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_capitalize_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for transposing characters and words. */
specifier|extern
name|int
name|rl_transpose_words
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_transpose_chars
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for searching within a line. */
specifier|extern
name|int
name|rl_char_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_char_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for readline's interface to the command history. */
specifier|extern
name|int
name|rl_beginning_of_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_of_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_get_next_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_get_previous_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for managing the mark and region. */
specifier|extern
name|int
name|rl_set_mark
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_exchange_point_and_mark
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands to set the editing mode (emacs or vi). */
specifier|extern
name|int
name|rl_vi_editing_mode
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_emacs_editing_mode
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for managing key bindings. */
specifier|extern
name|int
name|rl_re_read_init_file
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_functions
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_macros
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_dump_variables
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for word completion. */
specifier|extern
name|int
name|rl_complete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_possible_completions
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_insert_completions
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_menu_complete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for killing and yanking text, and managing the kill ring. */
specifier|extern
name|int
name|rl_kill_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_kill_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_backward_kill_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_full_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unix_word_rubout
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unix_line_discard
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_region_to_kill
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_region
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_forward_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_copy_backward_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_pop
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_nth_arg
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_yank_last_arg
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Not available unless __CYGWIN32__ is defined. */
ifdef|#
directive|ifdef
name|__CYGWIN32__
specifier|extern
name|int
name|rl_paste_from_clipboard
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Bindable commands for incremental searching. */
specifier|extern
name|int
name|rl_reverse_search_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forward_search_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable keyboard macro commands. */
specifier|extern
name|int
name|rl_start_kbd_macro
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_kbd_macro
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_call_last_kbd_macro
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable undo commands. */
specifier|extern
name|int
name|rl_revert_line
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_undo_command
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable tilde expansion commands. */
specifier|extern
name|int
name|rl_tilde_expand
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable terminal control commands. */
specifier|extern
name|int
name|rl_restart_output
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_stop_output
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Miscellaneous bindable commands. */
specifier|extern
name|int
name|rl_abort
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_tty_status
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable commands for incremental and non-incremental history searching. */
specifier|extern
name|int
name|rl_history_search_forward
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_history_search_backward
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_forward_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_reverse_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_forward_search_again
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_noninc_reverse_search_again
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Bindable command used when inserting a matching close character. */
specifier|extern
name|int
name|rl_insert_close
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Not available unless READLINE_CALLBACKS is defined. */
specifier|extern
name|void
name|rl_callback_handler_install
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|VFunction
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_callback_read_char
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_callback_handler_remove
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
comment|/* VI-mode bindable commands. */
specifier|extern
name|int
name|rl_vi_redo
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_undo
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_yank_arg
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_fetch_history
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_search_again
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_complete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_tilde_expand
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_prev_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_next_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_end_word
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_insert_beg
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_append_mode
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_append_eol
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eof_maybe
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_insertion_mode
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_movement_mode
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_arg_digit
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_case
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_put
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_column
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_delete_to
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_to
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_yank_to
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_delete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_back_to_indent
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_first_print
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_char_search
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_match
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_change_char
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_subst
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_overstrike
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_overstrike_delete
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_replace
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_set_mark
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_goto_mark
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* VI-mode utility functions. */
specifier|extern
name|int
name|rl_vi_check
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_domove
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bracktype
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* VI-mode pseudo-bindable commands, used as utility functions. */
specifier|extern
name|int
name|rl_vi_fWord
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bWord
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eWord
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_fword
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_bword
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_vi_eword
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Well Published Functions		    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* Readline functions. */
comment|/* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
specifier|extern
name|char
modifier|*
name|readline
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_initialize
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_discard_argument
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Utility functions to bind keys to readline commands. */
specifier|extern
name|int
name|rl_add_defun
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Function
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key
name|__P
argument_list|(
operator|(
name|int
operator|,
name|Function
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_bind_key_in_map
name|__P
argument_list|(
operator|(
name|int
operator|,
name|Function
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_key
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_key_in_map
name|__P
argument_list|(
operator|(
name|int
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_function_in_map
name|__P
argument_list|(
operator|(
name|Function
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_unbind_command_in_map
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_set_key
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Function
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_generic_bind
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_variable_bind
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Backwards compatibility, use rl_generic_bind instead. */
specifier|extern
name|int
name|rl_macro_bind
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented in the texinfo manual; not really useful to programs. */
specifier|extern
name|int
name|rl_translate_keyseq
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_untranslate_keyseq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Function
modifier|*
name|rl_named_function
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Function
modifier|*
name|rl_function_of_keyseq
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Keymap
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_list_funmap_names
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs_in_map
name|__P
argument_list|(
operator|(
name|Function
operator|*
operator|,
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|rl_invoking_keyseqs
name|__P
argument_list|(
operator|(
name|Function
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_function_dumper
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_macro_dumper
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_variable_dumper
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_read_init_file
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_parse_and_bind
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for manipulating keymaps. */
specifier|extern
name|Keymap
name|rl_make_bare_keymap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_copy_keymap
name|__P
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_make_keymap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_discard_keymap
name|__P
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_get_keymap_by_name
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_get_keymap_name
name|__P
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_set_keymap
name|__P
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|Keymap
name|rl_get_keymap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_set_keymap_from_edit_mode
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_get_keymap_name_from_edit_mode
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for manipulating the funmap, which maps command names to functions. */
specifier|extern
name|int
name|rl_add_funmap_entry
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Function
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_initialize_funmap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|rl_funmap_names
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Utility functions for managing keyboard macros. */
specifier|extern
name|void
name|rl_push_macro_input
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for undoing, from undo.c */
specifier|extern
name|void
name|rl_add_undo
name|__P
argument_list|(
operator|(
expr|enum
name|undo_code
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|free_undo_list
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_do_undo
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_begin_undo_group
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_end_undo_group
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_modifying
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for redisplay. */
specifier|extern
name|void
name|rl_redisplay
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_on_new_line
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_on_new_line_with_prompt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_forced_update_display
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_clear_message
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_reset_line_state
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|USE_VARARGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PREFER_STDARG
argument_list|)
specifier|extern
name|int
name|rl_message
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|int
name|rl_message
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* Undocumented in texinfo manual. */
specifier|extern
name|int
name|rl_show_char
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_character_len
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|crlf
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Save and restore internal prompt redisplay information. */
specifier|extern
name|void
name|rl_save_prompt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_restore_prompt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Modifying text. */
specifier|extern
name|int
name|rl_insert_text
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_delete_text
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_kill_text
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_copy_text
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Terminal and tty mode management. */
specifier|extern
name|void
name|rl_prep_terminal
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_deprep_terminal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rltty_set_default_bindings
name|__P
argument_list|(
operator|(
name|Keymap
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_reset_terminal
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_resize_terminal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* `Public' utility functions . */
specifier|extern
name|void
name|rl_extend_line_buffer
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|ding
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Functions for character input. */
specifier|extern
name|int
name|rl_stuff_char
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_execute_next
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_read_key
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_getc
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Readline signal handling, from signals.c */
specifier|extern
name|int
name|rl_set_signals
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|rl_clear_signals
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_cleanup_after_signal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_reset_after_signal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_free_line_state
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Undocumented. */
specifier|extern
name|int
name|rl_expand_prompt
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|maybe_save_line
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|maybe_unsave_line
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|maybe_replace_line
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Completion functions. */
specifier|extern
name|int
name|rl_complete_internal
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|rl_display_match_list
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|completion_matches
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CPFunction
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|username_completion_function
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
name|filename_completion_function
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Well Published Variables		    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* The version of this incarnation of the readline library. */
specifier|extern
name|char
modifier|*
name|rl_library_version
decl_stmt|;
comment|/* True if this is real GNU readline. */
specifier|extern
name|int
name|rl_gnu_readline_p
decl_stmt|;
comment|/* The name of the calling program.  You should initialize this to    whatever was in argv[0].  It is used when parsing conditionals. */
specifier|extern
name|char
modifier|*
name|rl_readline_name
decl_stmt|;
comment|/* The prompt readline uses.  This is set from the argument to    readline (), and should not be assigned to directly. */
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
comment|/* The line buffer that is in use. */
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
comment|/* The location of point, and end. */
specifier|extern
name|int
name|rl_point
decl_stmt|,
name|rl_end
decl_stmt|;
comment|/* The mark, or saved cursor position. */
specifier|extern
name|int
name|rl_mark
decl_stmt|;
comment|/* Flag to indicate that readline has finished with the current input    line and should return it. */
specifier|extern
name|int
name|rl_done
decl_stmt|;
comment|/* If set to a character value, that will be the next keystroke read. */
specifier|extern
name|int
name|rl_pending_input
decl_stmt|;
comment|/* Non-zero if we called this function from _rl_dispatch().  It's present    so functions can find out whether they were called from a key binding    or directly from an application. */
specifier|extern
name|int
name|rl_dispatching
decl_stmt|;
comment|/* The name of the terminal to use. */
specifier|extern
name|char
modifier|*
name|rl_terminal_name
decl_stmt|;
comment|/* The input and output streams. */
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|,
modifier|*
name|rl_outstream
decl_stmt|;
comment|/* If non-zero, then this is the address of a function to call just    before readline_internal () prints the first prompt. */
specifier|extern
name|Function
modifier|*
name|rl_startup_hook
decl_stmt|;
comment|/* If non-zero, this is the address of a function to call just before    readline_internal_setup () returns and readline_internal starts    reading input characters. */
specifier|extern
name|Function
modifier|*
name|rl_pre_input_hook
decl_stmt|;
comment|/* The address of a function to call periodically while Readline is    awaiting character input, or NULL, for no event handling. */
specifier|extern
name|Function
modifier|*
name|rl_event_hook
decl_stmt|;
specifier|extern
name|Function
modifier|*
name|rl_getc_function
decl_stmt|;
specifier|extern
name|VFunction
modifier|*
name|rl_redisplay_function
decl_stmt|;
specifier|extern
name|VFunction
modifier|*
name|rl_prep_term_function
decl_stmt|;
specifier|extern
name|VFunction
modifier|*
name|rl_deprep_term_function
decl_stmt|;
comment|/* Dispatch variables. */
specifier|extern
name|Keymap
name|rl_executing_keymap
decl_stmt|;
specifier|extern
name|Keymap
name|rl_binding_keymap
decl_stmt|;
comment|/* Display variables. */
comment|/* If non-zero, readline will erase the entire line, including any prompt,    if the only thing typed on an otherwise-blank line is something bound to    rl_newline. */
specifier|extern
name|int
name|rl_erase_empty_line
decl_stmt|;
comment|/* If non-zero, the application has already printed the prompt (rl_prompt)    before calling readline, so readline should not output it the first time    redisplay is done. */
specifier|extern
name|int
name|rl_already_prompted
decl_stmt|;
comment|/* A non-zero value means to read only this many characters rather than    up to a character bound to accept-line. */
specifier|extern
name|int
name|rl_num_chars_to_read
decl_stmt|;
comment|/* Variables to control readline signal handling. */
comment|/* If non-zero, readline will install its own signal handlers for    SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
specifier|extern
name|int
name|rl_catch_signals
decl_stmt|;
comment|/* If non-zero, readline will install a signal handler for SIGWINCH    that also attempts to call any calling application's SIGWINCH signal    handler.  Note that the terminal is not cleaned up before the    application's signal handler is called; use rl_cleanup_after_signal()    to do that. */
specifier|extern
name|int
name|rl_catch_sigwinch
decl_stmt|;
comment|/* Completion variables. */
comment|/* Pointer to the generator function for completion_matches ().    NULL means to use filename_entry_function (), the default filename    completer. */
specifier|extern
name|Function
modifier|*
name|rl_completion_entry_function
decl_stmt|;
comment|/* If rl_ignore_some_completions_function is non-NULL it is the address    of a function to call after all of the possible matches have been    generated, but before the actual completion is done to the input line.    The function is called with one argument; a NULL terminated array    of (char *).  If your function removes any of the elements, they    must be free()'ed. */
specifier|extern
name|Function
modifier|*
name|rl_ignore_some_completions_function
decl_stmt|;
comment|/* Pointer to alternative function to create matches.    Function is called with TEXT, START, and END.    START and END are indices in RL_LINE_BUFFER saying what the boundaries    of TEXT are.    If this function exists and returns NULL then call the value of    rl_completion_entry_function to try to match, otherwise use the    array of strings returned. */
specifier|extern
name|CPPFunction
modifier|*
name|rl_attempted_completion_function
decl_stmt|;
comment|/* The basic list of characters that signal a break between words for the    completer routine.  The initial contents of this variable is what    breaks words in the shell, i.e. "n\"\\'`@$>". */
specifier|extern
name|char
modifier|*
name|rl_basic_word_break_characters
decl_stmt|;
comment|/* The list of characters that signal a break between words for    rl_complete_internal.  The default list is the contents of    rl_basic_word_break_characters.  */
specifier|extern
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
comment|/* List of characters which can be used to quote a substring of the line.    Completion occurs on the entire substring, and within the substring       rl_completer_word_break_characters are treated as any other character,    unless they also appear within this list. */
specifier|extern
name|char
modifier|*
name|rl_completer_quote_characters
decl_stmt|;
comment|/* List of quote characters which cause a word break. */
specifier|extern
name|char
modifier|*
name|rl_basic_quote_characters
decl_stmt|;
comment|/* List of characters that need to be quoted in filenames by the completer. */
specifier|extern
name|char
modifier|*
name|rl_filename_quote_characters
decl_stmt|;
comment|/* List of characters that are word break characters, but should be left    in TEXT when it is passed to the completion function.  The shell uses    this to help determine what kind of completing to do. */
specifier|extern
name|char
modifier|*
name|rl_special_prefixes
decl_stmt|;
comment|/* If non-zero, then this is the address of a function to call when    completing on a directory name.  The function is called with    the address of a string (the current directory name) as an arg. */
specifier|extern
name|Function
modifier|*
name|rl_directory_completion_hook
decl_stmt|;
comment|/* Backwards compatibility with previous versions of readline. */
define|#
directive|define
name|rl_symbolic_link_hook
value|rl_directory_completion_hook
comment|/* If non-zero, then this is the address of a function to call when    completing a word would normally display the list of possible matches.    This function is called instead of actually doing the display.    It takes three arguments: (char **matches, int num_matches, int max_length)    where MATCHES is the array of strings that matched, NUM_MATCHES is the    number of strings in that array, and MAX_LENGTH is the length of the    longest string in that array. */
specifier|extern
name|VFunction
modifier|*
name|rl_completion_display_matches_hook
decl_stmt|;
comment|/* Non-zero means that the results of the matches are to be treated    as filenames.  This is ALWAYS zero on entry, and can only be changed    within a completion entry finder function. */
specifier|extern
name|int
name|rl_filename_completion_desired
decl_stmt|;
comment|/* Non-zero means that the results of the matches are to be quoted using    double quotes (or an application-specific quoting mechanism) if the    filename contains any characters in rl_word_break_chars.  This is    ALWAYS non-zero on entry, and can only be changed within a completion    entry finder function. */
specifier|extern
name|int
name|rl_filename_quoting_desired
decl_stmt|;
comment|/* Set to a function to quote a filename in an application-specific fashion.    Called with the text to quote, the type of match found (single or multiple)    and a pointer to the quoting character to be used, which the function can    reset if desired. */
specifier|extern
name|CPFunction
modifier|*
name|rl_filename_quoting_function
decl_stmt|;
comment|/* Function to call to remove quoting characters from a filename.  Called    before completion is attempted, so the embedded quotes do not interfere    with matching names in the file system. */
specifier|extern
name|CPFunction
modifier|*
name|rl_filename_dequoting_function
decl_stmt|;
comment|/* Function to call to decide whether or not a word break character is    quoted.  If a character is quoted, it does not break words for the    completer. */
specifier|extern
name|Function
modifier|*
name|rl_char_is_quoted_p
decl_stmt|;
comment|/* Non-zero means to suppress normal filename completion after the    user-specified completion function has been called. */
specifier|extern
name|int
name|rl_attempted_completion_over
decl_stmt|;
comment|/* Set to a character describing the type of completion being attempted by    rl_complete_internal; available for use by application completion    functions. */
specifier|extern
name|int
name|rl_completion_type
decl_stmt|;
comment|/* Character appended to completed words when at the end of the line.  The    default is a space.  Nothing is added if this is '\0'. */
specifier|extern
name|int
name|rl_completion_append_character
decl_stmt|;
comment|/* Up to this many items will be displayed in response to a    possible-completions call.  After that, we ask the user if she    is sure she wants to see them all.  The default value is 100. */
specifier|extern
name|int
name|rl_completion_query_items
decl_stmt|;
comment|/* If non-zero, then disallow duplicates in the matches. */
specifier|extern
name|int
name|rl_ignore_completion_duplicates
decl_stmt|;
comment|/* If this is non-zero, completion is (temporarily) inhibited, and the    completion character will be inserted as any other. */
specifier|extern
name|int
name|rl_inhibit_completion
decl_stmt|;
comment|/* Definitions available for use by readline clients. */
define|#
directive|define
name|RL_PROMPT_START_IGNORE
value|'\001'
define|#
directive|define
name|RL_PROMPT_END_IGNORE
value|'\002'
comment|/* Possible values for do_replace argument to rl_filename_quoting_function,    called by rl_complete_internal. */
define|#
directive|define
name|NO_MATCH
value|0
define|#
directive|define
name|SINGLE_MATCH
value|1
define|#
directive|define
name|MULT_MATCH
value|2
if|#
directive|if
operator|!
name|defined
argument_list|(
name|savestring
argument_list|)
define|#
directive|define
name|savestring
value|rl_savestring
specifier|extern
name|char
modifier|*
name|savestring
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* XXX backwards compatibility */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _READLINE_H_ */
end_comment

end_unit

