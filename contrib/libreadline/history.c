begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* history.c -- standalone history library */
end_comment

begin_comment
comment|/* Copyright (C) 1989-2005 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_MINIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* The number of slots to increase the_history by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HISTORY_GROW_SIZE
value|50
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hist_inittime
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An array of HIST_ENTRY.  This is where we store the history. */
end_comment

begin_decl_stmt
specifier|static
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have enforced a limit on the amount of    history that we save. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_stifled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of slots allocated to the input_history. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If HISTORY_STIFLED is non-zero, then this is the maximum number of    entries to remember. */
end_comment

begin_decl_stmt
name|int
name|history_max_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_input_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backwards compatibility */
end_comment

begin_comment
comment|/* The current location of the interactive history pointer.  Just makes    life easier for outside callers. */
end_comment

begin_decl_stmt
name|int
name|history_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of strings currently stored in the history list. */
end_comment

begin_decl_stmt
name|int
name|history_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The logical `base' of the history array.  It defaults to 1. */
end_comment

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current HISTORY_STATE of the history. */
end_comment

begin_function
name|HISTORY_STATE
modifier|*
name|history_get_history_state
parameter_list|()
block|{
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|HISTORY_STATE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HISTORY_STATE
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|entries
operator|=
name|the_history
expr_stmt|;
name|state
operator|->
name|offset
operator|=
name|history_offset
expr_stmt|;
name|state
operator|->
name|length
operator|=
name|history_length
expr_stmt|;
name|state
operator|->
name|size
operator|=
name|history_size
expr_stmt|;
name|state
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_stifled
condition|)
name|state
operator|->
name|flags
operator||=
name|HS_STIFLED
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the state of the current history array to STATE. */
end_comment

begin_function
name|void
name|history_set_history_state
parameter_list|(
name|state
parameter_list|)
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
block|{
name|the_history
operator|=
name|state
operator|->
name|entries
expr_stmt|;
name|history_offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
name|history_length
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|history_size
operator|=
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|HS_STIFLED
condition|)
name|history_stifled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a session in which the history functions might be used.  This    initializes interactive variables. */
end_comment

begin_function
name|void
name|using_history
parameter_list|()
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes that the primary history entries are using.    This just adds up the lengths of the_history->lines and the associated    timestamps. */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
name|result
operator|=
literal|0
init|;
name|the_history
operator|&&
name|the_history
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
operator|+=
name|HISTENT_BYTES
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the magic number which says what history element we are    looking at now.  In this implementation, it returns history_offset. */
end_comment

begin_function
name|int
name|where_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make the current history item be the one at POS, an absolute index.    Returns zero if POS is out of range, else non-zero. */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|pos
parameter_list|)
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|history_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current history array.  The caller has to be carefull, since this    is the actual array of data, and could be bashed or made corrupt easily.    The array is terminated with a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
block|{
return|return
operator|(
name|the_history
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry at the current position, as determined by    history_offset.  If there is no entry there, return a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|()
block|{
return|return
operator|(
operator|(
name|history_offset
operator|==
name|history_length
operator|)
operator|||
name|the_history
operator|==
literal|0
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
name|history_offset
index|]
return|;
block|}
end_function

begin_comment
comment|/* Back up history_offset to the previous history entry, and return    a pointer to that entry.  If there is no previous entry then return    a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|()
block|{
return|return
name|history_offset
condition|?
name|the_history
index|[
operator|--
name|history_offset
index|]
else|:
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Move history_offset forward to the next history entry, and return    a pointer to that entry.  If there is no next entry then return a    NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|==
name|history_length
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
operator|++
name|history_offset
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry which is logically at OFFSET in the history array.    OFFSET is relative to history_base. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|local_index
decl_stmt|;
name|local_index
operator|=
name|offset
operator|-
name|history_base
expr_stmt|;
return|return
operator|(
name|local_index
operator|>=
name|history_length
operator|||
name|local_index
operator|<
literal|0
operator|||
name|the_history
operator|==
literal|0
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
name|local_index
index|]
return|;
block|}
end_function

begin_function
name|HIST_ENTRY
modifier|*
name|alloc_history_entry
parameter_list|(
name|string
parameter_list|,
name|ts
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|string
condition|?
name|savestring
argument_list|(
name|string
argument_list|)
else|:
name|string
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|->
name|timestamp
operator|=
name|ts
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
name|time_t
name|history_get_time
parameter_list|(
name|hist
parameter_list|)
name|HIST_ENTRY
modifier|*
name|hist
decl_stmt|;
block|{
name|char
modifier|*
name|ts
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|hist
operator|==
literal|0
operator|||
name|hist
operator|->
name|timestamp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ts
operator|=
name|hist
operator|->
name|timestamp
expr_stmt|;
if|if
condition|(
name|ts
index|[
literal|0
index|]
operator|!=
name|history_comment_char
condition|)
return|return
literal|0
return|;
name|t
operator|=
operator|(
name|time_t
operator|)
name|atol
argument_list|(
name|ts
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX - should use strtol() here */
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hist_inittime
parameter_list|()
block|{
name|time_t
name|t
decl_stmt|;
name|char
name|ts
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|t
operator|=
operator|(
name|time_t
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
comment|/* assume snprintf if vsnprintf exists */
name|snprintf
argument_list|(
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
operator|-
literal|1
argument_list|,
literal|"X%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|ts
argument_list|,
literal|"X%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|savestring
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ret
index|[
literal|0
index|]
operator|=
name|history_comment_char
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Place STRING at the end of the history list.  The data field    is  set to NULL. */
end_comment

begin_function
name|void
name|add_history
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|==
name|history_max_entries
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the history is stifled, and history_length is zero, 	 and it equals history_max_entries, we don't save items. */
if|if
condition|(
name|history_length
operator|==
literal|0
condition|)
return|return;
comment|/* If there is something in the slot, then remove it. */
if|if
condition|(
name|the_history
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|free_history_entry
argument_list|(
name|the_history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Copy the rest of the entries, moving down one slot. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_base
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_size
operator|==
literal|0
condition|)
block|{
name|history_size
operator|=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_length
operator|==
operator|(
name|history_size
operator|-
literal|1
operator|)
condition|)
block|{
name|history_size
operator|+=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_history
argument_list|,
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|history_length
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|alloc_history_entry
argument_list|(
name|string
argument_list|,
name|hist_inittime
argument_list|()
argument_list|)
expr_stmt|;
name|the_history
index|[
name|history_length
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the time stamp of the most recent history entry to STRING. */
end_comment

begin_function
name|void
name|add_history_time
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|hs
decl_stmt|;
name|hs
operator|=
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
expr_stmt|;
name|FREE
argument_list|(
name|hs
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|hs
operator|->
name|timestamp
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free HIST and return the data so the calling application can free it    if necessary and desired. */
end_comment

begin_function
name|histdata_t
name|free_history_entry
parameter_list|(
name|hist
parameter_list|)
name|HIST_ENTRY
modifier|*
name|hist
decl_stmt|;
block|{
name|histdata_t
name|x
decl_stmt|;
if|if
condition|(
name|hist
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|histdata_t
operator|)
literal|0
operator|)
return|;
name|FREE
argument_list|(
name|hist
operator|->
name|line
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hist
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|x
operator|=
name|hist
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|hist
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|HIST_ENTRY
modifier|*
name|copy_history_entry
parameter_list|(
name|hist
parameter_list|)
name|HIST_ENTRY
modifier|*
name|hist
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
name|hist
operator|==
literal|0
condition|)
return|return
name|hist
return|;
name|ret
operator|=
name|alloc_history_entry
argument_list|(
name|hist
operator|->
name|line
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ts
operator|=
name|hist
operator|->
name|timestamp
condition|?
name|savestring
argument_list|(
name|hist
operator|->
name|timestamp
argument_list|)
else|:
name|hist
operator|->
name|timestamp
expr_stmt|;
name|ret
operator|->
name|timestamp
operator|=
name|ts
expr_stmt|;
name|ret
operator|->
name|data
operator|=
name|hist
operator|->
name|data
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Make the history entry at WHICH have LINE and DATA.  This returns    the old entry so you can dispose of the data.  In the case of an    invalid WHICH, a NULL pointer is returned. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|which
parameter_list|,
name|line
parameter_list|,
name|data
parameter_list|)
name|int
name|which
decl_stmt|;
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|histdata_t
name|data
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|,
modifier|*
name|old_value
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|old_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|temp
operator|->
name|timestamp
operator|=
name|savestring
argument_list|(
name|old_value
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|the_history
index|[
name|which
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|old_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the DATA in the specified history entries, replacing OLD with    NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace    all of the history entries where entry->data == OLD; WHICH == -2 means    to replace the `newest' history entry where entry->data == OLD; and    WHICH>= 0 means to replace that particular history entry's data, as    long as it matches OLD. */
end_comment

begin_function
name|void
name|replace_history_data
parameter_list|(
name|which
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|which
decl_stmt|;
name|histdata_t
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
name|HIST_ENTRY
modifier|*
name|entry
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
name|which
operator|<
operator|-
literal|2
operator|||
name|which
operator|>=
name|history_length
operator|||
name|history_length
operator|==
literal|0
operator|||
name|the_history
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|which
operator|>=
literal|0
condition|)
block|{
name|entry
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|entry
operator|->
name|data
operator|==
name|old
condition|)
name|entry
operator|->
name|data
operator|=
name|new
expr_stmt|;
return|return;
block|}
name|last
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|data
operator|==
name|old
condition|)
block|{
name|last
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
name|entry
operator|->
name|data
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
name|which
operator|==
operator|-
literal|2
operator|&&
name|last
operator|>=
literal|0
condition|)
block|{
name|entry
operator|=
name|the_history
index|[
name|last
index|]
expr_stmt|;
name|entry
operator|->
name|data
operator|=
name|new
expr_stmt|;
comment|/* XXX - we don't check entry->old */
block|}
block|}
end_block

begin_comment
comment|/* Remove history element WHICH from the history.  The removed    element is returned to you so you can free the line, data,    and containing structure. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|return_value
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|history_length
operator|||
name|history_length
operator|==
literal|0
operator|||
name|the_history
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|return_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|which
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_length
operator|--
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stifle the history list, remembering only MAX number of lines. */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_length
operator|>
name|max
condition|)
block|{
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|history_length
operator|-
name|max
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|free_history_entry
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|history_base
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|max
init|;
name|j
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|the_history
index|[
name|j
index|]
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
name|the_history
index|[
name|j
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|history_length
operator|=
name|j
expr_stmt|;
block|}
name|history_stifled
operator|=
literal|1
expr_stmt|;
name|max_input_history
operator|=
name|history_max_entries
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop stifling the history.  This returns the previous maximum    number of history entries.  The value is positive if the history    was stifled,  negative if it wasn't. */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|()
block|{
if|if
condition|(
name|history_stifled
condition|)
block|{
name|history_stifled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|history_max_entries
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
name|history_max_entries
operator|)
return|;
block|}
end_function

begin_function
name|int
name|history_is_stifled
parameter_list|()
block|{
return|return
operator|(
name|history_stifled
operator|)
return|;
block|}
end_function

begin_function
name|void
name|clear_history
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|free_history_entry
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_history
index|[
name|i
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|history_offset
operator|=
name|history_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

