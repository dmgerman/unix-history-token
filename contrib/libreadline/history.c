begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* History.c -- standalone history library */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992 Free Software Foundation, Inc.     This file contains the GNU History Library (the Library), a set of    routines for managing the text of previously typed lines.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     The Library is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     The GNU General Public License is often shipped with GNU software, and    is generally kept in a file called COPYING or LICENSE.  If you do not    have a copy of the license, write to the Free Software Foundation,    59 Temple Place, Suite 330, Boston, MA 02111 USA. */
end_comment

begin_comment
comment|/* The goal is to make the implementation transparent, so that you    don't have to know what data types are used, just what functions    you can call.  I think I have done that. */
end_comment

begin_define
define|#
directive|define
name|READLINE_LIBRARY
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ansi_stdlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDLIB_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_MINIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"histlib.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_comment
comment|/* The number of slots to increase the_history by. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HISTORY_GROW_SIZE
value|50
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			History Functions			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* An array of HIST_ENTRY.  This is where we store the history. */
end_comment

begin_decl_stmt
specifier|static
name|HIST_ENTRY
modifier|*
modifier|*
name|the_history
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have enforced a limit on the amount of    history that we save. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_stifled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If HISTORY_STIFLED is non-zero, then this is the maximum number of    entries to remember. */
end_comment

begin_decl_stmt
name|int
name|max_input_history
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current location of the interactive history pointer.  Just makes    life easier for outside callers. */
end_comment

begin_decl_stmt
name|int
name|history_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of strings currently stored in the history list. */
end_comment

begin_decl_stmt
name|int
name|history_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current number of slots allocated to the input_history. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The logical `base' of the history array.  It defaults to 1. */
end_comment

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current HISTORY_STATE of the history. */
end_comment

begin_function
name|HISTORY_STATE
modifier|*
name|history_get_history_state
parameter_list|()
block|{
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|HISTORY_STATE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HISTORY_STATE
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|entries
operator|=
name|the_history
expr_stmt|;
name|state
operator|->
name|offset
operator|=
name|history_offset
expr_stmt|;
name|state
operator|->
name|length
operator|=
name|history_length
expr_stmt|;
name|state
operator|->
name|size
operator|=
name|history_size
expr_stmt|;
name|state
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_stifled
condition|)
name|state
operator|->
name|flags
operator||=
name|HS_STIFLED
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the state of the current history array to STATE. */
end_comment

begin_function
name|void
name|history_set_history_state
parameter_list|(
name|state
parameter_list|)
name|HISTORY_STATE
modifier|*
name|state
decl_stmt|;
block|{
name|the_history
operator|=
name|state
operator|->
name|entries
expr_stmt|;
name|history_offset
operator|=
name|state
operator|->
name|offset
expr_stmt|;
name|history_length
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|history_size
operator|=
name|state
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
name|HS_STIFLED
condition|)
name|history_stifled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a session in which the history functions might be used.  This    initializes interactive variables. */
end_comment

begin_function
name|void
name|using_history
parameter_list|()
block|{
name|history_offset
operator|=
name|history_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes that the primary history entries are using.    This just adds up the lengths of the_history->lines. */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|the_history
operator|&&
name|the_history
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
operator|+=
name|strlen
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the magic number which says what history element we are    looking at now.  In this implementation, it returns history_offset. */
end_comment

begin_function
name|int
name|where_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make the current history item be the one at POS, an absolute index.    Returns zero if POS is out of range, else non-zero. */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|pos
parameter_list|)
name|int
name|pos
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
operator|||
operator|!
name|the_history
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|history_offset
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current history array.  The caller has to be carefull, since this    is the actual array of data, and could be bashed or made corrupt easily.    The array is terminated with a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
modifier|*
name|history_list
parameter_list|()
block|{
return|return
operator|(
name|the_history
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry at the current position, as determined by    history_offset.  If there is no entry there, return a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|()
block|{
return|return
operator|(
operator|(
name|history_offset
operator|==
name|history_length
operator|)
operator|||
name|the_history
operator|==
literal|0
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
name|history_offset
index|]
return|;
block|}
end_function

begin_comment
comment|/* Back up history_offset to the previous history entry, and return    a pointer to that entry.  If there is no previous entry then return    a NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|()
block|{
return|return
name|history_offset
condition|?
name|the_history
index|[
operator|--
name|history_offset
index|]
else|:
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Move history_offset forward to the next history entry, and return    a pointer to that entry.  If there is no next entry then return a    NULL pointer. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|()
block|{
return|return
operator|(
name|history_offset
operator|==
name|history_length
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
operator|++
name|history_offset
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the history entry which is logically at OFFSET in the history array.    OFFSET is relative to history_base. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|local_index
decl_stmt|;
name|local_index
operator|=
name|offset
operator|-
name|history_base
expr_stmt|;
return|return
operator|(
name|local_index
operator|>=
name|history_length
operator|||
name|local_index
operator|<
literal|0
operator|||
operator|!
name|the_history
operator|)
condition|?
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
else|:
name|the_history
index|[
name|local_index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Place STRING at the end of the history list.  The data field    is  set to NULL. */
end_comment

begin_function
name|void
name|add_history
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|history_stifled
operator|&&
operator|(
name|history_length
operator|==
name|max_input_history
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the history is stifled, and history_length is zero, 	 and it equals max_input_history, we don't save items. */
if|if
condition|(
name|history_length
operator|==
literal|0
condition|)
return|return;
comment|/* If there is something in the slot, then remove it. */
if|if
condition|(
name|the_history
index|[
literal|0
index|]
condition|)
block|{
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the rest of the entries, moving down one slot. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_base
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_size
operator|==
literal|0
condition|)
block|{
name|history_size
operator|=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|history_length
operator|==
operator|(
name|history_size
operator|-
literal|1
operator|)
condition|)
block|{
name|history_size
operator|+=
name|DEFAULT_HISTORY_GROW_SIZE
expr_stmt|;
name|the_history
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_history
argument_list|,
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|history_length
operator|++
expr_stmt|;
block|}
block|}
name|temp
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|the_history
index|[
name|history_length
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the history entry at WHICH have LINE and DATA.  This returns    the old entry so you can dispose of the data.  In the case of an    invalid WHICH, a NULL pointer is returned. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|which
parameter_list|,
name|line
parameter_list|,
name|data
parameter_list|)
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|histdata_t
name|data
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|temp
init|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HIST_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|old_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
condition|)
return|return
operator|(
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
name|old_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
name|temp
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|temp
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|the_history
index|[
name|which
index|]
operator|=
name|temp
expr_stmt|;
return|return
operator|(
name|old_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove history element WHICH from the history.  The removed    element is returned to you so you can free the line, data,    and containing structure. */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|HIST_ENTRY
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|which
operator|>=
name|history_length
operator|||
operator|!
name|history_length
condition|)
name|return_value
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|return_value
operator|=
name|the_history
index|[
name|which
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|which
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
name|the_history
index|[
name|i
index|]
operator|=
name|the_history
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|history_length
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Stifle the history list, remembering only MAX number of lines. */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|history_length
operator|>
name|max
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|history_length
operator|-
name|max
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|history_base
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|history_length
operator|-
name|max
init|;
name|j
operator|<
name|max
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|the_history
index|[
name|j
index|]
operator|=
name|the_history
index|[
name|i
index|]
expr_stmt|;
name|the_history
index|[
name|j
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
name|history_length
operator|=
name|j
expr_stmt|;
block|}
name|history_stifled
operator|=
literal|1
expr_stmt|;
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop stifling the history.  This returns the previous amount the     history was stifled by.  The value is positive if the history was    stifled,  negative if it wasn't. */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|()
block|{
if|if
condition|(
name|history_stifled
condition|)
block|{
name|history_stifled
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
name|max_input_history
operator|)
return|;
block|}
return|return
operator|(
name|max_input_history
operator|)
return|;
block|}
end_function

begin_function
name|int
name|history_is_stifled
parameter_list|()
block|{
return|return
operator|(
name|history_stifled
operator|)
return|;
block|}
end_function

begin_function
name|void
name|clear_history
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This loses because we cannot free the data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|history_length
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_history
index|[
name|i
index|]
operator|=
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|history_offset
operator|=
name|history_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

