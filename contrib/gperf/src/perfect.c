begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Provides high-level routines to manipulate the keywork list     structures the code generation output.    Copyright (C) 1989 Free Software Foundation, Inc.    written by Douglas C. Schmidt (schmidt@ics.uci.edu)  This file is part of GNU GPERF.  GNU GPERF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU GPERF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU GPERF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"perfect.h"
end_include

begin_include
include|#
directive|include
file|"stderr.h"
end_include

begin_comment
comment|/* Current release version. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counts occurrences of each key set character. */
end_comment

begin_decl_stmt
name|int
name|occurrences
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value associated with each character. */
end_comment

begin_decl_stmt
name|int
name|asso_values
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Locally visible PERFECT object. */
end_comment

begin_decl_stmt
name|PERFECT
name|perfect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Efficiently returns the least power of two greater than or equal to X! */
end_comment

begin_define
define|#
directive|define
name|POW
parameter_list|(
name|X
parameter_list|)
value|((!X)?1:(X-=1,X|=X>>1,X|=X>>2,X|=X>>4,X|=X>>8,X|=X>>16,(++X)))
end_define

begin_comment
comment|/* Reads input keys, possibly applies the reordering heuristic, sets the    maximum associated value size (rounded up to the nearest power of 2),    may initialize the associated values array, and determines the maximum    hash table size.  Note: using the random numbers is often helpful,    though not as deterministic, of course! */
end_comment

begin_function
name|void
name|perfect_init
parameter_list|()
block|{
name|int
name|asso_value_max
decl_stmt|;
name|int
name|len
decl_stmt|;
name|perfect
operator|.
name|num_done
operator|=
literal|1
expr_stmt|;
name|perfect
operator|.
name|fewest_collisions
operator|=
literal|0
expr_stmt|;
name|read_keys
argument_list|()
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ORDER
argument_list|)
condition|)
name|reorder
argument_list|()
expr_stmt|;
name|asso_value_max
operator|=
name|GET_ASSO_MAX
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|len
operator|=
name|keyword_list_length
argument_list|()
expr_stmt|;
name|asso_value_max
operator|=
operator|(
name|asso_value_max
condition|?
name|asso_value_max
operator|*
name|len
else|:
name|len
operator|)
expr_stmt|;
name|SET_ASSO_MAX
argument_list|(
name|option
argument_list|,
name|POW
argument_list|(
name|asso_value_max
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|RANDOM
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|srandom
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALPHABET_SIZE
condition|;
name|i
operator|++
control|)
name|asso_values
index|[
name|i
index|]
operator|=
operator|(
name|random
argument_list|()
operator|&
name|asso_value_max
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|asso_value
init|=
name|INITIAL_VALUE
argument_list|(
name|option
argument_list|)
decl_stmt|;
if|if
condition|(
name|asso_value
condition|)
comment|/* Initialize array if user requests non-zero default. */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ALPHABET_SIZE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|asso_values
index|[
name|i
index|]
operator|=
name|asso_value
operator|&
name|GET_ASSO_MAX
argument_list|(
name|option
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|perfect
operator|.
name|max_hash_value
operator|=
name|max_key_length
argument_list|()
operator|+
name|GET_ASSO_MAX
argument_list|(
name|option
argument_list|)
operator|*
name|GET_CHARSET_SIZE
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/* C code produced by gperf version %s */\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|print_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnumber of keys = %d\nmaximum associated value is %d\ \nmaximum possible size of generated hash table is %d\n"
argument_list|,
name|len
argument_list|,
name|asso_value_max
argument_list|,
name|perfect
operator|.
name|max_hash_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge two hash key multisets to form the ordered disjoint union of the sets.    (In a multiset, an element can occur multiple times). Precondition: both     set_1 and set_2 must be ordered. Returns the length of the combined set. */
end_comment

begin_function
specifier|static
name|int
name|compute_disjoint_union
parameter_list|(
name|set_1
parameter_list|,
name|set_2
parameter_list|,
name|set_3
parameter_list|)
name|char
modifier|*
name|set_1
decl_stmt|;
name|char
modifier|*
name|set_2
decl_stmt|;
name|char
modifier|*
name|set_3
decl_stmt|;
block|{
name|char
modifier|*
name|base
init|=
name|set_3
decl_stmt|;
while|while
condition|(
operator|*
name|set_1
operator|&&
operator|*
name|set_2
condition|)
if|if
condition|(
operator|*
name|set_1
operator|==
operator|*
name|set_2
condition|)
name|set_1
operator|++
operator|,
name|set_2
operator|++
expr_stmt|;
else|else
block|{
operator|*
name|set_3
operator|=
operator|*
name|set_1
operator|<
operator|*
name|set_2
condition|?
operator|*
name|set_1
operator|++
else|:
operator|*
name|set_2
operator|++
expr_stmt|;
if|if
condition|(
name|set_3
operator|==
name|base
operator|||
operator|*
name|set_3
operator|!=
operator|*
operator|(
name|set_3
operator|-
literal|1
operator|)
condition|)
name|set_3
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|set_1
condition|)
block|{
operator|*
name|set_3
operator|=
operator|*
name|set_1
operator|++
expr_stmt|;
if|if
condition|(
name|set_3
operator|==
name|base
operator|||
operator|*
name|set_3
operator|!=
operator|*
operator|(
name|set_3
operator|-
literal|1
operator|)
condition|)
name|set_3
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|set_2
condition|)
block|{
operator|*
name|set_3
operator|=
operator|*
name|set_2
operator|++
expr_stmt|;
if|if
condition|(
name|set_3
operator|==
name|base
operator|||
operator|*
name|set_3
operator|!=
operator|*
operator|(
name|set_3
operator|-
literal|1
operator|)
condition|)
name|set_3
operator|++
expr_stmt|;
block|}
operator|*
name|set_3
operator|=
literal|'\0'
expr_stmt|;
return|return
name|set_3
operator|-
name|base
return|;
block|}
end_function

begin_comment
comment|/* Sort the UNION_SET in increasing frequency of occurrence.    This speeds up later processing since we may assume the resulting    set (Set_3, in this case), is ordered. Uses insertion sort, since    the UNION_SET is typically short. */
end_comment

begin_function
specifier|static
name|void
name|sort_set
parameter_list|(
name|union_set
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|union_set
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|char
name|curr
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|i
operator|+
literal|1
operator|,
name|tmp
operator|=
name|union_set
index|[
name|curr
index|]
init|;
name|curr
operator|>
literal|0
operator|&&
name|occurrences
index|[
name|tmp
index|]
operator|<
name|occurrences
index|[
name|union_set
index|[
name|curr
operator|-
literal|1
index|]
index|]
condition|;
name|curr
operator|--
control|)
name|union_set
index|[
name|curr
index|]
operator|=
name|union_set
index|[
name|curr
operator|-
literal|1
index|]
expr_stmt|;
name|union_set
index|[
name|curr
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a key set's hash value. */
end_comment

begin_function
specifier|static
name|int
name|hash
parameter_list|(
name|key_node
parameter_list|)
name|LIST_NODE
modifier|*
name|key_node
decl_stmt|;
block|{
name|int
name|sum
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|0
else|:
name|key_node
operator|->
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|key_node
operator|->
name|char_set
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
name|sum
operator|+=
name|asso_values
index|[
operator|*
name|ptr
index|]
expr_stmt|;
return|return
name|key_node
operator|->
name|hash_value
operator|=
name|sum
return|;
block|}
end_function

begin_comment
comment|/* Find out how associated value changes affect successfully hashed items.    Returns FALSE if no other hash values are affected, else returns TRUE.    Note that because GET_ASSO_MAX (option) is a power of two we can guarantee    that all legal ASSO_VALUES are visited without repetition since    GET_JUMP (option) was forced to be an odd value! */
end_comment

begin_function
specifier|static
name|bool
name|affects_prev
parameter_list|(
name|c
parameter_list|,
name|curr
parameter_list|)
name|char
name|c
decl_stmt|;
name|LIST_NODE
modifier|*
name|curr
decl_stmt|;
block|{
name|int
name|original_char
init|=
name|asso_values
index|[
name|c
index|]
decl_stmt|;
name|int
name|i
init|=
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|FAST
argument_list|)
condition|?
name|GET_ASSO_MAX
argument_list|(
name|option
argument_list|)
else|:
name|GET_ITERATIONS
argument_list|(
name|option
argument_list|)
operator|==
literal|0
condition|?
name|key_list
operator|.
name|list_len
else|:
name|GET_ITERATIONS
argument_list|(
name|option
argument_list|)
decl_stmt|;
comment|/* Try all asso_values. */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|int
name|collisions
init|=
literal|0
decl_stmt|;
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
name|asso_values
index|[
name|c
index|]
operator|=
name|asso_values
index|[
name|c
index|]
operator|+
operator|(
name|GET_JUMP
argument_list|(
name|option
argument_list|)
condition|?
name|GET_JUMP
argument_list|(
name|option
argument_list|)
else|:
name|random
argument_list|()
operator|)
operator|&
name|GET_ASSO_MAX
argument_list|(
name|option
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bool_array_reset
argument_list|()
expr_stmt|;
comment|/* See how this asso_value change affects previous keywords.  If          it does better than before we'll take it! */
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
init|;
operator|!
name|lookup
argument_list|(
name|hash
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|||
operator|++
name|collisions
operator|<
name|perfect
operator|.
name|fewest_collisions
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|==
name|curr
condition|)
block|{
name|perfect
operator|.
name|fewest_collisions
operator|=
name|collisions
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|asso_values
index|[
name|c
index|]
operator|=
name|original_char
expr_stmt|;
comment|/* Restore original values, no more tries. */
return|return
name|TRUE
return|;
comment|/* If we're this far it's time to try the next character.... */
block|}
end_function

begin_comment
comment|/* Change a character value, try least-used characters first. */
end_comment

begin_function
specifier|static
name|void
name|change
parameter_list|(
name|prior
parameter_list|,
name|curr
parameter_list|)
name|LIST_NODE
modifier|*
name|prior
decl_stmt|;
name|LIST_NODE
modifier|*
name|curr
decl_stmt|;
block|{
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
specifier|static
name|char
modifier|*
name|union_set
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|union_set
condition|)
name|union_set
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
name|GET_CHARSET_SIZE
argument_list|(
name|option
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
comment|/* Very useful for debugging. */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collision on keyword #%d, prior=\"%s\", curr=\"%s\", hash=%d\n"
argument_list|,
name|perfect
operator|.
name|num_done
argument_list|,
name|prior
operator|->
name|key
argument_list|,
name|curr
operator|->
name|key
argument_list|,
name|curr
operator|->
name|hash_value
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|sort_set
argument_list|(
name|union_set
argument_list|,
name|compute_disjoint_union
argument_list|(
name|prior
operator|->
name|char_set
argument_list|,
name|curr
operator|->
name|char_set
argument_list|,
name|union_set
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try changing some values, if change doesn't alter other values continue normal action. */
name|perfect
operator|.
name|fewest_collisions
operator|++
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|union_set
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
if|if
condition|(
operator|!
name|affects_prev
argument_list|(
operator|*
name|temp
argument_list|,
name|curr
argument_list|)
condition|)
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"- resolved by changing asso_value['%c'] (char #%d) to %d\n"
argument_list|,
operator|*
name|temp
argument_list|,
name|temp
operator|-
name|union_set
operator|+
literal|1
argument_list|,
name|asso_values
index|[
operator|*
name|temp
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Good, doesn't affect previous hash values, we'll take it. */
block|}
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
init|;
name|ptr
operator|!=
name|curr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|hash
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|hash
argument_list|(
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"** collision not resolved, %d duplicates remain, continuing...\n"
argument_list|,
name|perfect
operator|.
name|fewest_collisions
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Does the hard stuff....    Initializes the Iteration Number boolean array, and then trys to find a     perfect function that will hash all the key words without getting any    duplications.  This is made much easier since we aren't attempting    to generate *minimum* functions, only perfect ones.    If we can't generate a perfect function in one pass *and* the user    hasn't enabled the DUP option, we'll inform the user to try the    randomization option, use -D, or choose alternative key positions.      The alternatives (e.g., back-tracking) are too time-consuming, i.e,    exponential in the number of keys. */
end_comment

begin_function
name|int
name|perfect_generate
parameter_list|()
block|{
name|LIST_NODE
modifier|*
name|curr
decl_stmt|;
name|bool_array_init
argument_list|(
name|perfect
operator|.
name|max_hash_value
argument_list|)
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|key_list
operator|.
name|head
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
name|hash
argument_list|(
name|curr
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
init|;
name|ptr
operator|!=
name|curr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|hash_value
operator|==
name|curr
operator|->
name|hash_value
condition|)
block|{
name|change
argument_list|(
name|ptr
argument_list|,
name|curr
argument_list|)
expr_stmt|;
break|break;
block|}
name|perfect
operator|.
name|num_done
operator|++
expr_stmt|;
block|}
comment|/* Make one final check, just to make sure nothing weird happened.... */
name|bool_array_reset
argument_list|()
expr_stmt|;
for|for
control|(
name|curr
operator|=
name|key_list
operator|.
name|head
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
if|if
condition|(
name|lookup
argument_list|(
name|hash
argument_list|(
name|curr
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
comment|/* We'll try to deal with this later..... */
break|break;
else|else
comment|/* Yow, big problems.  we're outta here! */
block|{
name|report_error
argument_list|(
literal|"\nInternal error, duplicate value %d:\n\ try options -D or -r, or use new key positions.\n\n"
argument_list|,
name|hash
argument_list|(
name|curr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bool_array_destroy
argument_list|()
expr_stmt|;
comment|/* First sorts the key word list by hash value, and the outputs the      list to the proper ostream. The generated hash table code is only       output if the early stage of processing turned out O.K. */
name|sort
argument_list|()
expr_stmt|;
name|print_output
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prints out some diagnostics upon completion. */
end_comment

begin_function
name|void
name|perfect_destroy
parameter_list|()
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndumping occurrence and associated values tables\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALPHABET_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|occurrences
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"asso_values[%c] = %3d, occurrences[%c] = %3d\n"
argument_list|,
name|i
argument_list|,
name|asso_values
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|occurrences
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"end table dumping\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

