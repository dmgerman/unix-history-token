begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Getopt for GNU.    Copyright (C) 1987, 1989 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This version of `getopt' appears to the caller like standard Unix `getopt'    but it behaves differently for the user, since it allows the user    to intersperse the options with the other arguments.     As `getopt' works, it permutes the elements of `argv' so that,    when it is done, all the options precede everything else.  Thus    all application programs are extended to handle flexible argument order.     Setting the environment variable _POSIX_OPTION_ORDER disables permutation.    Then the behavior is completely standard.     GNU application programs can use a third alternative mode in which    they can distinguish the relative order of options and other arguments.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|memcpy((d), (s), (l))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For communication from `getopt' to the caller.    When `getopt' finds an option that takes an argument,    the argument value is returned here.    Also, when `ordering' is RETURN_IN_ORDER,    each non-option ARGV-element is returned here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in ARGV of the next element to be scanned.    This is used for communication to and from the caller    and for communication between successive calls to `getopt'.     On entry to `getopt', zero means this is the first call; initialize.     When `getopt' returns EOF, this is the index of the first of the    non-option elements that the caller should itself scan.     Otherwise, `optind' communicates from one call to the next    how much of ARGV has been scanned so far.  */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next char to be scanned in the option-element    in which the last option character we returned was found.    This allows us to pick up the scan where we left off.     If this is zero, or a null string, it means resume the scan    by advancing to the next ARGV-element.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callers store zero here to inhibit the error message    for unrecognized options.  */
end_comment

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe how to deal with options that follow non-option ARGV-elements.     UNSPECIFIED means the caller did not specify anything;    the default is then REQUIRE_ORDER if the environment variable    _OPTIONS_FIRST is defined, PERMUTE otherwise.     REQUIRE_ORDER means don't recognize them as options.    Stop option processing when the first non-option is seen.    This is what Unix does.     PERMUTE is the default.  We permute the contents of `argv' as we scan,    so that eventually all the options are at the end.  This allows options    to be given in any order, even with programs that were not written to    expect this.     RETURN_IN_ORDER is an option available to programs that were written    to expect options and other ARGV-elements in any order and that care about    the ordering of the two.  We describe each non-option ARGV-element    as if it were the argument of an option with character code zero.    Using `-' as the first character of the list of option characters    requests this mode of operation.     The special argument `--' forces an end of option-scanning regardless    of the value of `ordering'.  In the case of RETURN_IN_ORDER, only    `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|REQUIRE_ORDER
block|,
name|PERMUTE
block|,
name|RETURN_IN_ORDER
block|}
name|ordering
enum|;
end_enum

begin_escape
end_escape

begin_comment
comment|/* Handle permutation of arguments.  */
end_comment

begin_comment
comment|/* Describe the part of ARGV that contains non-options that have    been skipped.  `first_nonopt' is the index in ARGV of the first of them;    `last_nonopt' is the index after the last of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_nonopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_nonopt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exchange two adjacent subsequences of ARGV.    One subsequence is elements [first_nonopt,last_nonopt)     which contains all the non-options that have been skipped so far.    The other is elements [last_nonopt,optind), which contains all     the options processed since those non-options were skipped.     `first_nonopt' and `last_nonopt' are relocated so that they describe     the new indices of the non-options in ARGV after they are moved.  */
end_comment

begin_function
specifier|static
name|void
name|exchange
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|nonopts_size
init|=
operator|(
name|last_nonopt
operator|-
name|first_nonopt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nonopts_size
argument_list|)
decl_stmt|;
comment|/* Interchange the two blocks of data in argv.  */
name|bcopy
argument_list|(
operator|&
name|argv
index|[
name|first_nonopt
index|]
argument_list|,
name|temp
argument_list|,
name|nonopts_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|argv
index|[
name|last_nonopt
index|]
argument_list|,
operator|&
name|argv
index|[
name|first_nonopt
index|]
argument_list|,
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
operator|&
name|argv
index|[
name|first_nonopt
operator|+
name|optind
operator|-
name|last_nonopt
index|]
argument_list|,
name|nonopts_size
argument_list|)
expr_stmt|;
comment|/* Update records for the slots the non-options now occupy.  */
name|first_nonopt
operator|+=
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan elements of ARGV (whose length is ARGC) for option characters    given in OPTSTRING.     If an element of ARGV starts with '-', and is not exactly "-" or "--",    then it is an option element.  The characters of this element    (aside from the initial '-') are option characters.  If `getopt'    is called repeatedly, it returns successively each of theoption characters    from each of the option elements.     If `getopt' finds another option character, it returns that character,    updating `optind' and `nextchar' so that the next call to `getopt' can    resume the scan with the following option character or ARGV-element.     If there are no more option characters, `getopt' returns `EOF'.    Then `optind' is the index in ARGV of the first ARGV-element    that is not an option.  (The ARGV-elements have been permuted    so that those that are not options now come last.)     OPTSTRING is a string containing the legitimate option characters.    A colon in OPTSTRING means that the previous character is an option    that wants an argument.  The argument is taken from the rest of the    current ARGV-element, or from the following ARGV-element,    and returned in `optarg'.     If an option character is seen that is not listed in OPTSTRING,    return '?' after printing an error message.  If you set `opterr' to    zero, the error message is suppressed but we still return '?'.     If a char in OPTSTRING is followed by a colon, that means it wants an arg,    so the following text in the same ARGV-element, or the text of the following    ARGV-element, is returned in `optarg.  Two colons mean an option that    wants an optional arg; if there is text in the current ARGV-element,    it is returned in `optarg'.     If OPTSTRING starts with `-', it requests a different method of handling the    non-option ARGV-elements.  See the comments about RETURN_IN_ORDER, above.  */
end_comment

begin_function
name|int
name|getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
comment|/* Initialize the internal data when the first call is made.      Start processing options with ARGV-element 1 (since ARGV-element 0      is the program name); the sequence of previously skipped      non-option ARGV-elements is empty.  */
if|if
condition|(
name|optind
operator|==
literal|0
condition|)
block|{
name|first_nonopt
operator|=
name|last_nonopt
operator|=
name|optind
operator|=
literal|1
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
comment|/* Determine how to handle the ordering of options and nonoptions.  */
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|ordering
operator|=
name|RETURN_IN_ORDER
expr_stmt|;
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"_POSIX_OPTION_ORDER"
argument_list|)
operator|!=
literal|0
condition|)
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
else|else
name|ordering
operator|=
name|PERMUTE
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|==
literal|0
operator|||
operator|*
name|nextchar
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|PERMUTE
condition|)
block|{
comment|/* If we have just processed some options following some non-options, 	     exchange them so that the options come first.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_nonopt
operator|!=
name|optind
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
comment|/* Now skip any additional non-options 	     and extend the range of non-options previously skipped.  */
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|optind
operator|++
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
comment|/* Special ARGV-element `--' means premature end of options. 	 Skip it like a null option, 	 then exchange with previous non-options as if it were an option, 	 then skip everything else like a non-option.  */
if|if
condition|(
name|optind
operator|!=
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_nonopt
operator|==
name|last_nonopt
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
name|last_nonopt
operator|=
name|argc
expr_stmt|;
name|optind
operator|=
name|argc
expr_stmt|;
block|}
comment|/* If we have done all the ARGV-elements, stop the scan 	 and back over any non-options that we skipped and permuted.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Set the next-arg-index to point at the non-options 	     that we previously skipped, so the caller will digest them.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
condition|)
name|optind
operator|=
name|first_nonopt
expr_stmt|;
return|return
name|EOF
return|;
block|}
comment|/* If we have come to a non-option and did not permute it, 	 either stop the scan or describe it to the caller and pass it by.  */
if|if
condition|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|REQUIRE_ORDER
condition|)
return|return
name|EOF
return|;
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We have found another option-ARGV-element. 	 Start decoding its characters.  */
name|nextchar
operator|=
name|argv
index|[
name|optind
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Look at and handle the next option-character.  */
block|{
name|char
name|c
init|=
operator|*
name|nextchar
operator|++
decl_stmt|;
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
decl_stmt|;
comment|/* Increment `optind' when we start to process its last character.  */
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|0
condition|)
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|opterr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|>=
literal|0177
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option, character code 0%o\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `-%c'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|temp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* This is an option that accepts an argument optionally.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|0
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
else|else
name|optarg
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|0
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 		   we must advance to the next element now.  */
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|opterr
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no argument for `-%c' option\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
comment|/* We already incremented `optind' once; 		 increment it again when taking next ARGV-elt as argument.  */
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|nextchar
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Compile with -DTEST to make an executable for use in testing    the above definition of `getopt'.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|digit_optind
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|this_option_optind
init|=
name|optind
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abc:d:0123456789"
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|digit_optind
operator|!=
literal|0
operator|&&
name|digit_optind
operator|!=
name|this_option_optind
condition|)
name|printf
argument_list|(
literal|"digits occur in two different argv-elements.\n"
argument_list|)
expr_stmt|;
name|digit_optind
operator|=
name|this_option_optind
expr_stmt|;
name|printf
argument_list|(
literal|"option %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"option a\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printf
argument_list|(
literal|"option b\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
literal|"option c with value `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"?? getopt returned character code 0%o ??\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"non-option ARGV-elements: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

