begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Creates and initializes a new list node.    Copyright (C) 1989 Free Software Foundation, Inc.    written by Douglas C. Schmidt (schmidt@ics.uci.edu)  This file is part of GNU GPERF.  GNU GPERF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU GPERF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU GPERF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"listnode.h"
end_include

begin_include
include|#
directive|include
file|"stderr.h"
end_include

begin_comment
comment|/* See comments in perfect.cc. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|occurrences
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sorts the key set alphabetically to speed up subsequent operations.    Uses insertion sort since the set is probably quite small. */
end_comment

begin_function
specifier|static
name|void
name|set_sort
parameter_list|(
name|base
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|char
name|curr
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|i
operator|+
literal|1
operator|,
name|tmp
operator|=
name|base
index|[
name|curr
index|]
init|;
name|curr
operator|>
literal|0
operator|&&
name|tmp
operator|<
name|base
index|[
name|curr
operator|-
literal|1
index|]
condition|;
name|curr
operator|--
control|)
name|base
index|[
name|curr
index|]
operator|=
name|base
index|[
name|curr
operator|-
literal|1
index|]
expr_stmt|;
name|base
index|[
name|curr
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initializes a List_Node.  This requires obtaining memory for the KEY_SET    initializing them using the information stored in the    KEY_POSITIONS array in Options, and checking for simple errors.    It's important to note that KEY and REST are both pointers to    the different offsets into the same block of dynamic memory pointed to    by parameter K. The data member REST is used to store any additional fields     of the input file (it is set to the "" string if Option[TYPE] is not enabled).    This is useful if the user wishes to incorporate a lookup structure,    rather than just an array of keys. */
end_comment

begin_function
name|LIST_NODE
modifier|*
name|make_list_node
parameter_list|(
name|k
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|k
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|LIST_NODE
modifier|*
name|buffered_malloc
parameter_list|()
function_decl|;
name|int
name|char_set_size
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
condition|?
name|len
else|:
name|GET_CHARSET_SIZE
argument_list|(
name|option
argument_list|)
operator|+
literal|1
decl_stmt|;
name|LIST_NODE
modifier|*
name|temp
init|=
name|buffered_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LIST_NODE
argument_list|)
operator|+
name|char_set_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|temp
operator|->
name|char_set
decl_stmt|;
name|k
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null terminate KEY to separate it from REST. */
name|temp
operator|->
name|key
operator|=
name|k
expr_stmt|;
name|temp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|temp
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|rest
operator|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
condition|?
name|k
operator|+
name|len
operator|+
literal|1
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
condition|)
comment|/* Use all the character position in the KEY. */
for|for
control|(
init|;
operator|*
name|k
condition|;
name|k
operator|++
operator|,
name|ptr
operator|++
control|)
operator|++
name|occurrences
index|[
operator|*
name|ptr
operator|=
operator|*
name|k
index|]
expr_stmt|;
else|else
comment|/* Only use those character positions specified by the user. */
block|{
name|int
name|i
decl_stmt|;
comment|/* Iterate thru the list of key_positions, initializing occurrences table          and temp->char_set (via char * pointer ptr). */
for|for
control|(
name|RESET
argument_list|(
name|option
argument_list|)
init|;
operator|(
name|i
operator|=
name|GET
argument_list|(
name|option
argument_list|)
operator|)
operator|!=
name|EOS
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
name|WORD_END
condition|)
comment|/* Special notation for last KEY position, i.e. '$'. */
operator|*
name|ptr
operator|=
name|temp
operator|->
name|key
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|len
condition|)
comment|/* Within range of KEY length, so we'll keep it. */
operator|*
name|ptr
operator|=
name|temp
operator|->
name|key
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
else|else
comment|/* Out of range of KEY length, so we'll just skip it. */
continue|continue;
operator|++
name|occurrences
index|[
operator|*
name|ptr
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|temp
operator|->
name|char_set
condition|)
comment|/* Didn't get any hits, i.e., no usable positions. */
name|report_error
argument_list|(
literal|"can't hash keyword %s with chosen key positions\n%a"
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate this bastard.... */
comment|/* Sort the KEY_SET items alphabetically. */
name|set_sort
argument_list|(
name|temp
operator|->
name|char_set
argument_list|,
name|ptr
operator|-
name|temp
operator|->
name|char_set
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

end_unit

