begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hash table for checking keyword links.  Implemented using double hashing.    Copyright (C) 1989 Free Software Foundation, Inc.    written by Douglas C. Schmidt (schmidt@ics.uci.edu)  This file is part of GNU GPERF.  GNU GPERF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU GPERF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU GPERF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_comment
comment|/* Find out how well our double hashing is working! */
end_comment

begin_expr_stmt
specifier|static
name|collisions
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Locally visible hash table. */
end_comment

begin_decl_stmt
specifier|static
name|HASH_TABLE
name|hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basically the algorithm from the Dragon book. */
end_comment

begin_function
specifier|static
name|unsigned
name|hash_pjw
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|unsigned
name|g
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|str
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|(
operator|*
name|temp
operator|*
literal|13
operator|)
expr_stmt|;
if|if
condition|(
name|g
operator|=
name|h
operator|&
literal|0xf0000000
condition|)
block|{
name|h
operator|^=
operator|(
name|g
operator|>>
literal|24
operator|)
expr_stmt|;
name|h
operator|^=
name|g
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* The size of the hash table is always the smallest power of 2>= the size    indicated by the user.  This allows several optimizations, including    the use of double hashing and elimination of the mod instruction.    Note that the size had better be larger than the number of items    in the hash table, else there's trouble!!!  Note that the memory    for the hash table is allocated *outside* the intialization routine.    This compromises information hiding somewhat, but greatly reduces    memory fragmentation, since we can now use alloca! */
end_comment

begin_function
name|void
name|hash_table_init
parameter_list|(
name|table
parameter_list|,
name|s
parameter_list|)
name|LIST_NODE
modifier|*
modifier|*
name|table
decl_stmt|;
name|int
name|s
decl_stmt|;
block|{
name|hash_table
operator|.
name|size
operator|=
name|s
expr_stmt|;
name|hash_table
operator|.
name|table
operator|=
name|table
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hash_table
operator|.
name|table
argument_list|,
name|hash_table
operator|.
name|size
operator|*
sizeof|sizeof
expr|*
name|hash_table
operator|.
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Frees the dynamically allocated table.  Note that since we don't    really need this space anymore, and since it is potentially quite    big it is best to return it when we are done. */
end_comment

begin_function
name|void
name|hash_table_destroy
parameter_list|()
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndumping the hash table\ntotal elements = %d, bytes = %d\n"
argument_list|,
name|hash_table
operator|.
name|size
argument_list|,
name|hash_table
operator|.
name|size
operator|*
sizeof|sizeof
expr|*
name|hash_table
operator|.
name|table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hash_table
operator|.
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|hash_table
operator|.
name|table
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"location[%d] has charset \"%s\" and keyword \"%s\"\n"
argument_list|,
name|i
argument_list|,
name|hash_table
operator|.
name|table
index|[
name|i
index|]
operator|->
name|char_set
argument_list|,
name|hash_table
operator|.
name|table
index|[
name|i
index|]
operator|->
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntotal collisions during hashing = %d\n"
argument_list|,
name|collisions
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"end dumping hash table\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the ITEM is already in the hash table return the item found    in the table.  Otherwise inserts the ITEM, and returns FALSE.    Uses double hashing. */
end_comment

begin_function
name|LIST_NODE
modifier|*
name|retrieve
parameter_list|(
name|item
parameter_list|,
name|ignore_length
parameter_list|)
name|LIST_NODE
modifier|*
name|item
decl_stmt|;
name|int
name|ignore_length
decl_stmt|;
block|{
name|unsigned
name|hash_val
init|=
name|hash_pjw
argument_list|(
name|item
operator|->
name|char_set
argument_list|)
decl_stmt|;
name|int
name|probe
init|=
name|hash_val
operator|&
name|hash_table
operator|.
name|size
operator|-
literal|1
decl_stmt|;
name|int
name|increment
init|=
operator|(
name|hash_val
operator|^
name|item
operator|->
name|length
operator||
literal|1
operator|)
operator|&
name|hash_table
operator|.
name|size
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
operator|->
name|char_set
argument_list|,
name|item
operator|->
name|char_set
argument_list|)
operator|||
operator|(
operator|!
name|ignore_length
operator|&&
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
operator|->
name|length
operator|!=
name|item
operator|->
name|length
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|collisions
operator|++
expr_stmt|;
endif|#
directive|endif
name|probe
operator|=
name|probe
operator|+
name|increment
operator|&
name|hash_table
operator|.
name|size
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
condition|)
return|return
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
return|;
else|else
block|{
name|hash_table
operator|.
name|table
index|[
name|probe
index|]
operator|=
name|item
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

