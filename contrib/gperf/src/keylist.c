begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines for building, ordering, and printing the keyword list.    Copyright (C) 1989 Free Software Foundation, Inc.    written by Douglas C. Schmidt (schmidt@ics.uci.edu)  This file is part of GNU GPERF.  GNU GPERF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU GPERF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU GPERF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"keylist.h"
end_include

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_include
include|#
directive|include
file|"stderr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Current release version. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See comments in perfect.cc. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|occurrences
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ditto. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|asso_values
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in function reorder, below. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|determined
index|[
name|ALPHABET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default type for generated code. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_array_type
init|=
literal|"char *"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generated function ``in_word_set'' default return type. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_return_type
init|=
literal|"char *"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Largest positive integer value. */
end_comment

begin_define
define|#
directive|define
name|MAX_INT
value|((~(unsigned)0)>>1)
end_define

begin_comment
comment|/* Most negative integer value. */
end_comment

begin_define
define|#
directive|define
name|NEG_MAX_INT
value|((~(unsigned)0)^((~(unsigned)0)>>1))
end_define

begin_comment
comment|/* Maximum value an unsigned char can take. */
end_comment

begin_define
define|#
directive|define
name|MAX_UNSIGNED_CHAR
value|256
end_define

begin_comment
comment|/* Maximum value an unsigned short can take. */
end_comment

begin_define
define|#
directive|define
name|MAX_UNSIGNED_SHORT
value|65536
end_define

begin_comment
comment|/* Make the hash table 5 times larger than the number of keyword entries. */
end_comment

begin_define
define|#
directive|define
name|TABLE_MULTIPLE
value|5
end_define

begin_comment
comment|/* Efficiently returns the least power of two greater than or equal to X! */
end_comment

begin_define
define|#
directive|define
name|POW
parameter_list|(
name|X
parameter_list|)
value|((!X)?1:(X-=1,X|=X>>1,X|=X>>2,X|=X>>4,X|=X>>8,X|=X>>16,(++X)))
end_define

begin_comment
comment|/* How wide the printed field width must be to contain the maximum hash value. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|field_width
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Globally visible KEY_LIST object. */
end_comment

begin_decl_stmt
name|KEY_LIST
name|key_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Gathers the input stream into a buffer until one of two things occur:     1. We read a '%' followed by a '%'    2. We read a '%' followed by a '}'     The first symbolizes the beginning of the keyword list proper,    The second symbolizes the end of the C source code to be generated    verbatim in the output file.     I assume that the keys are separated from the optional preceding struct    declaration by a consecutive % followed by either % or } starting in     the first column. The code below uses an expandible buffer to scan off     and return a pointer to all the code (if any) appearing before the delimiter. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_special_input
parameter_list|(
name|delimiter
parameter_list|)
name|char
name|delimiter
decl_stmt|;
block|{
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
name|int
name|size
init|=
literal|80
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|delimiter
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* Discard newline. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
literal|""
return|;
else|else
block|{
name|buf
index|[
name|delimiter
operator|==
literal|'%'
operator|&&
name|buf
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|';'
condition|?
name|i
operator|-
literal|2
else|:
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|size
condition|)
comment|/* Yikes, time to grow the buffer! */
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
name|size
operator|*=
literal|2
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|temp
index|[
name|j
index|]
operator|=
name|buf
index|[
name|j
index|]
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|temp
expr_stmt|;
block|}
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
return|return
name|NULL
return|;
comment|/* Problem here. */
block|}
end_function

begin_comment
comment|/* Stores any C text that must be included verbatim into the     generated code output. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|save_include_src
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'%'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'{'
condition|)
name|report_error
argument_list|(
literal|"internal error, %c != '{' on line %d in file %s%a"
argument_list|,
name|c
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
comment|/*NOT REACHED*/
else|else
return|return
name|get_special_input
argument_list|(
literal|'}'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* strcspn - find length of initial segment of s consisting entirely    of characters not from reject (borrowed from Henry Spencer's    ANSI string package). */
end_comment

begin_function
specifier|static
name|int
name|strcspn
parameter_list|(
name|s
parameter_list|,
name|reject
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|reject
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|rej_scan
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|s
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
for|for
control|(
name|rej_scan
operator|=
name|reject
init|;
operator|*
name|rej_scan
condition|;
control|)
if|if
condition|(
operator|*
name|scan
operator|==
operator|*
name|rej_scan
operator|++
condition|)
return|return
name|count
return|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Determines from the input file whether the user wants to build a table    from a user-defined struct, or whether the user is content to simply    use the default array of keys. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_array_type
parameter_list|()
block|{
return|return
name|get_special_input
argument_list|(
literal|'%'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sets up the Return_Type, the Struct_Tag type and the Array_Type    based upon various user Options. */
end_comment

begin_function
specifier|static
name|void
name|set_output_types
parameter_list|()
block|{
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
operator|&&
operator|!
operator|(
name|key_list
operator|.
name|array_type
operator|=
name|get_array_type
argument_list|()
operator|)
condition|)
return|return;
comment|/* Something's wrong, bug we'll catch it later on.... */
elseif|else
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
condition|)
comment|/* Yow, we've got a user-defined type... */
block|{
name|int
name|struct_tag_length
init|=
name|strcspn
argument_list|(
name|key_list
operator|.
name|array_type
argument_list|,
literal|"{\n\0"
argument_list|)
decl_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
condition|)
comment|/* And it must return a pointer... */
block|{
name|key_list
operator|.
name|return_type
operator|=
name|xmalloc
argument_list|(
name|struct_tag_length
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|key_list
operator|.
name|return_type
argument_list|,
name|key_list
operator|.
name|array_type
argument_list|,
name|struct_tag_length
argument_list|)
expr_stmt|;
name|key_list
operator|.
name|return_type
index|[
name|struct_tag_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|key_list
operator|.
name|return_type
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|key_list
operator|.
name|struct_tag
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|struct_tag_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|key_list
operator|.
name|struct_tag
argument_list|,
name|key_list
operator|.
name|array_type
argument_list|,
name|struct_tag_length
argument_list|)
expr_stmt|;
name|key_list
operator|.
name|struct_tag
index|[
name|struct_tag_length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
condition|)
comment|/* Return a char *. */
name|key_list
operator|.
name|return_type
operator|=
name|default_array_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reads in all keys from standard input and creates a linked list pointed    to by Head.  This list is then quickly checked for ``links,'' i.e.,    unhashable elements possessing identical key sets and lengths. */
end_comment

begin_function
name|void
name|read_keys
parameter_list|()
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|key_list
operator|.
name|include_src
operator|=
name|save_include_src
argument_list|()
expr_stmt|;
name|set_output_types
argument_list|()
expr_stmt|;
comment|/* Oops, problem with the input file. */
if|if
condition|(
operator|!
operator|(
name|ptr
operator|=
name|read_line
argument_list|()
operator|)
condition|)
name|report_error
argument_list|(
literal|"No words in input file, did you forget\  to prepend %s or use -t accidentally?\n%a"
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
comment|/* Read in all the keywords from the input file. */
else|else
block|{
name|LIST_NODE
modifier|*
name|temp
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
modifier|*
name|delimiter
init|=
name|GET_DELIMITER
argument_list|(
name|option
argument_list|)
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|key_list
operator|.
name|head
operator|=
name|make_list_node
argument_list|(
name|ptr
argument_list|,
name|strcspn
argument_list|(
name|ptr
argument_list|,
name|delimiter
argument_list|)
argument_list|)
init|;
operator|(
name|ptr
operator|=
name|read_line
argument_list|()
operator|)
operator|&&
name|strcmp
argument_list|(
name|ptr
argument_list|,
literal|"%%"
argument_list|)
condition|;
name|key_list
operator|.
name|total_keys
operator|++
operator|,
name|temp
operator|=
name|temp
operator|->
name|next
control|)
name|temp
operator|->
name|next
operator|=
name|make_list_node
argument_list|(
name|ptr
argument_list|,
name|strcspn
argument_list|(
name|ptr
argument_list|,
name|delimiter
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if any additional C code is included at end of this file. */
if|if
condition|(
name|ptr
condition|)
name|key_list
operator|.
name|additional_code
operator|=
name|TRUE
expr_stmt|;
block|{
comment|/* If this becomes TRUE we've got a link. */
name|bool
name|link
init|=
name|FALSE
decl_stmt|;
comment|/* Make large hash table for efficiency. */
name|int
name|table_size
init|=
operator|(
name|key_list
operator|.
name|list_len
operator|=
name|key_list
operator|.
name|total_keys
operator|)
operator|*
name|TABLE_MULTIPLE
decl_stmt|;
comment|/* By allocating the memory here we save on dynamic allocation overhead.             Table must be a power of 2 for the hash function scheme to work. */
name|LIST_NODE
modifier|*
modifier|*
name|table
init|=
operator|(
name|LIST_NODE
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|POW
argument_list|(
name|table_size
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|LIST_NODE
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|hash_table_init
argument_list|(
name|table
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
comment|/* Test whether there are any links and also set the maximum length of           an identifier in the keyword list. */
for|for
control|(
name|temp
operator|=
name|key_list
operator|.
name|head
operator|,
name|trail
operator|=
name|NULL
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|LIST_NODE
modifier|*
name|ptr
init|=
name|retrieve
argument_list|(
name|temp
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check for links.  We deal with these by building an equivalence class               of all duplicate values (i.e., links) so that only 1 keyword is                 representative of the entire collection.  This *greatly* simplifies                   processing during later stages of the program. */
if|if
condition|(
name|ptr
condition|)
block|{
name|key_list
operator|.
name|list_len
operator|--
expr_stmt|;
name|trail
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|link
operator|=
name|ptr
operator|->
name|link
expr_stmt|;
name|ptr
operator|->
name|link
operator|=
name|temp
expr_stmt|;
name|link
operator|=
name|TRUE
expr_stmt|;
comment|/* Complain if user hasn't enabled the duplicate option. */
if|if
condition|(
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key link: \"%s\" = \"%s\", with key set \"%s\".\n"
argument_list|,
name|temp
operator|->
name|key
argument_list|,
name|ptr
operator|->
name|key
argument_list|,
name|temp
operator|->
name|char_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key link: \"%s\" = \"%s\", with key set \"%s\".\n"
argument_list|,
name|temp
operator|->
name|key
argument_list|,
name|ptr
operator|->
name|key
argument_list|,
name|temp
operator|->
name|char_set
argument_list|)
expr_stmt|;
block|}
else|else
name|trail
operator|=
name|temp
expr_stmt|;
comment|/* Update minimum and maximum keyword length, if needed. */
if|if
condition|(
name|temp
operator|->
name|length
operator|>
name|key_list
operator|.
name|max_key_len
condition|)
name|key_list
operator|.
name|max_key_len
operator|=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|<
name|key_list
operator|.
name|min_key_len
condition|)
name|key_list
operator|.
name|min_key_len
operator|=
name|temp
operator|->
name|length
expr_stmt|;
block|}
comment|/* Free up the dynamic memory used in the hash table. */
name|hash_table_destroy
argument_list|()
expr_stmt|;
comment|/* Exit program if links exists and option[DUP] not set, since we can't continue safely. */
if|if
condition|(
name|link
condition|)
name|report_error
argument_list|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|?
literal|"Some input keys have identical hash values, examine output carefully...\n"
else|:
literal|"Some input keys have identical hash values,\ntry different key positions or use option -D.\n%a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
condition|)
name|SET_CHARSET_SIZE
argument_list|(
name|option
argument_list|,
name|key_list
operator|.
name|max_key_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Recursively merges two sorted lists together to form one sorted list. The    ordering criteria is by frequency of occurrence of elements in the key set    or by the hash value.  This is a kludge, but permits nice sharing of    almost identical code without incurring the overhead of a function    call comparison. */
end_comment

begin_function
specifier|static
name|LIST_NODE
modifier|*
name|merge
parameter_list|(
name|list1
parameter_list|,
name|list2
parameter_list|)
name|LIST_NODE
modifier|*
name|list1
decl_stmt|;
name|LIST_NODE
modifier|*
name|list2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|list1
condition|)
return|return
name|list2
return|;
elseif|else
if|if
condition|(
operator|!
name|list2
condition|)
return|return
name|list1
return|;
elseif|else
if|if
condition|(
name|key_list
operator|.
name|occurrence_sort
operator|&&
name|list1
operator|->
name|occurrence
operator|<
name|list2
operator|->
name|occurrence
operator|||
name|key_list
operator|.
name|hash_sort
operator|&&
name|list1
operator|->
name|hash_value
operator|>
name|list2
operator|->
name|hash_value
condition|)
block|{
name|list2
operator|->
name|next
operator|=
name|merge
argument_list|(
name|list2
operator|->
name|next
argument_list|,
name|list1
argument_list|)
expr_stmt|;
return|return
name|list2
return|;
block|}
else|else
block|{
name|list1
operator|->
name|next
operator|=
name|merge
argument_list|(
name|list1
operator|->
name|next
argument_list|,
name|list2
argument_list|)
expr_stmt|;
return|return
name|list1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Applies the merge sort algorithm to recursively sort the key list by    frequency of occurrence of elements in the key set. */
end_comment

begin_function
specifier|static
name|LIST_NODE
modifier|*
name|merge_sort
parameter_list|(
name|head
parameter_list|)
name|LIST_NODE
modifier|*
name|head
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|head
operator|||
operator|!
name|head
operator|->
name|next
condition|)
return|return
name|head
return|;
else|else
block|{
name|LIST_NODE
modifier|*
name|middle
init|=
name|head
decl_stmt|;
name|LIST_NODE
modifier|*
name|temp
init|=
name|head
operator|->
name|next
operator|->
name|next
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|middle
operator|=
name|middle
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|temp
operator|=
name|middle
operator|->
name|next
expr_stmt|;
name|middle
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|merge
argument_list|(
name|merge_sort
argument_list|(
name|head
argument_list|)
argument_list|,
name|merge_sort
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the frequency of occurrence of elements in the key set. */
end_comment

begin_function
specifier|static
name|int
name|get_occurrence
parameter_list|(
name|ptr
parameter_list|)
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|ptr
operator|->
name|char_set
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
name|value
operator|+=
name|occurrences
index|[
operator|*
name|temp
index|]
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Enables the index location of all key set elements that are now     determined. */
end_comment

begin_function
specifier|static
name|void
name|set_determined
parameter_list|(
name|ptr
parameter_list|)
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|ptr
operator|->
name|char_set
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
name|determined
index|[
operator|*
name|temp
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if PTR's key set is already completely determined. */
end_comment

begin_function
specifier|static
name|bool
name|already_determined
parameter_list|(
name|ptr
parameter_list|)
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
block|{
name|bool
name|is_determined
init|=
name|TRUE
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|ptr
operator|->
name|char_set
init|;
name|is_determined
operator|&&
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
name|is_determined
operator|=
name|determined
index|[
operator|*
name|temp
index|]
expr_stmt|;
return|return
name|is_determined
return|;
block|}
end_function

begin_comment
comment|/* Reorders the table by first sorting the list so that frequently occuring     keys appear first, and then the list is reorded so that keys whose values     are already determined will be placed towards the front of the list.  This    helps prune the search time by handling inevitable collisions early in the    search process.  See Cichelli's paper from Jan 1980 JACM for details.... */
end_comment

begin_function
name|void
name|reorder
parameter_list|()
block|{
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|occurrence
operator|=
name|get_occurrence
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|key_list
operator|.
name|hash_sort
operator|=
name|FALSE
expr_stmt|;
name|key_list
operator|.
name|occurrence_sort
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
operator|=
name|merge_sort
argument_list|(
name|key_list
operator|.
name|head
argument_list|)
init|;
name|ptr
operator|->
name|next
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|set_determined
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|already_determined
argument_list|(
name|ptr
operator|->
name|next
argument_list|)
condition|)
continue|continue;
else|else
block|{
name|LIST_NODE
modifier|*
name|trail_ptr
init|=
name|ptr
operator|->
name|next
decl_stmt|;
name|LIST_NODE
modifier|*
name|run_ptr
init|=
name|trail_ptr
operator|->
name|next
decl_stmt|;
for|for
control|(
init|;
name|run_ptr
condition|;
name|run_ptr
operator|=
name|trail_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|already_determined
argument_list|(
name|run_ptr
argument_list|)
condition|)
block|{
name|trail_ptr
operator|->
name|next
operator|=
name|run_ptr
operator|->
name|next
expr_stmt|;
name|run_ptr
operator|->
name|next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|=
name|run_ptr
expr_stmt|;
block|}
else|else
name|trail_ptr
operator|=
name|run_ptr
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determines the maximum and minimum hash values.  One notable feature is     Ira Pohl's optimal algorithm to calculate both the maximum and minimum    items in a list in O(3n/2) time (faster than the O (2n) method).     Returns the maximum hash value encountered. */
end_comment

begin_function
specifier|static
name|int
name|print_min_max
parameter_list|()
block|{
name|int
name|min_hash_value
decl_stmt|;
name|int
name|max_hash_value
decl_stmt|;
name|LIST_NODE
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|key_list
operator|.
name|list_len
argument_list|)
condition|)
comment|/* Pre-process first item, list now has an even length. */
block|{
name|min_hash_value
operator|=
name|max_hash_value
operator|=
name|key_list
operator|.
name|head
operator|->
name|hash_value
expr_stmt|;
name|temp
operator|=
name|key_list
operator|.
name|head
operator|->
name|next
expr_stmt|;
block|}
else|else
comment|/* List is already even length, no extra work necessary. */
block|{
name|min_hash_value
operator|=
name|MAX_INT
expr_stmt|;
name|max_hash_value
operator|=
name|NEG_MAX_INT
expr_stmt|;
name|temp
operator|=
name|key_list
operator|.
name|head
expr_stmt|;
block|}
for|for
control|(
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
comment|/* Find max and min in optimal o(3n/2) time. */
block|{
specifier|static
name|int
name|i
decl_stmt|;
name|int
name|key_2
decl_stmt|,
name|key_1
init|=
name|temp
operator|->
name|hash_value
decl_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|key_2
operator|=
name|temp
operator|->
name|hash_value
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|key_1
operator|<
name|key_2
condition|)
block|{
if|if
condition|(
name|key_1
operator|<
name|min_hash_value
condition|)
name|min_hash_value
operator|=
name|key_1
expr_stmt|;
if|if
condition|(
name|key_2
operator|>
name|max_hash_value
condition|)
name|max_hash_value
operator|=
name|key_2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key_2
operator|<
name|min_hash_value
condition|)
name|min_hash_value
operator|=
name|key_2
expr_stmt|;
if|if
condition|(
name|key_1
operator|>
name|max_hash_value
condition|)
name|max_hash_value
operator|=
name|key_1
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n#define MIN_WORD_LENGTH %d\n#define MAX_WORD_LENGTH %d\ \n#define MIN_HASH_VALUE %d\n#define MAX_HASH_VALUE %d\ \n/*\n%5d keywords\n%5d is the maximum key range\n*/\n\n"
argument_list|,
name|key_list
operator|.
name|min_key_len
operator|==
name|MAX_INT
condition|?
name|key_list
operator|.
name|max_key_len
else|:
name|key_list
operator|.
name|min_key_len
argument_list|,
name|key_list
operator|.
name|max_key_len
argument_list|,
name|min_hash_value
argument_list|,
name|max_hash_value
argument_list|,
name|key_list
operator|.
name|total_keys
argument_list|,
operator|(
name|max_hash_value
operator|-
name|min_hash_value
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|max_hash_value
return|;
block|}
end_function

begin_comment
comment|/* Generates the output using a C switch.  This trades increased search    time for decreased table space (potentially *much* less space for    sparse tables). It the user has specified their own struct in the    keyword file *and* they enable the POINTER option we have extra work to    do.  The solution here is to maintain a local static array of user    defined struct's, as with the Print_Lookup_Function.  Then we use for    switch statements to perform a strcmp or strncmp, returning 0 if the str     fails to match, and otherwise returning a pointer to appropriate index    location in the local static array. */
end_comment

begin_function
specifier|static
name|void
name|print_switch
parameter_list|()
block|{
name|char
modifier|*
name|comp_buffer
decl_stmt|;
name|LIST_NODE
modifier|*
name|curr
init|=
name|key_list
operator|.
name|head
decl_stmt|;
name|int
name|pointer_and_type_enabled
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
decl_stmt|;
name|int
name|total_switches
init|=
name|GET_TOTAL_SWITCHES
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|int
name|switch_size
init|=
name|keyword_list_length
argument_list|()
operator|/
name|total_switches
decl_stmt|;
if|if
condition|(
name|pointer_and_type_enabled
condition|)
block|{
name|comp_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
literal|"*str == *resword->%s&& !strncmp (str + 1, resword->%s + 1, len - 1)"
argument_list|)
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|GET_KEY_NAME
argument_list|(
name|option
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|comp_buffer
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
condition|?
literal|"*str == *resword->%s&& !strncmp (str + 1, resword->%s + 1, len - 1)"
else|:
literal|"*str == *resword->%s&& !strcmp (str + 1, resword->%s + 1)"
argument_list|,
name|GET_KEY_NAME
argument_list|(
name|option
argument_list|)
argument_list|,
name|GET_KEY_NAME
argument_list|(
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|comp_buffer
operator|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
condition|?
literal|"*str == *resword&& !strncmp (str + 1, resword + 1, len - 1)"
else|:
literal|"*str == *resword&& !strcmp (str + 1, resword + 1)"
expr_stmt|;
name|printf
argument_list|(
literal|"  if (len<= MAX_WORD_LENGTH&& len>= MIN_WORD_LENGTH)\n    {\n\       register int key = %s (str, len);\n\n\       if (key<= MAX_HASH_VALUE&& key>= MIN_HASH_VALUE)\n        {\n"
argument_list|,
name|GET_HASH_NAME
argument_list|(
name|option
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Properly deal with user's who request multiple switch statements. */
while|while
condition|(
name|curr
condition|)
block|{
name|LIST_NODE
modifier|*
name|temp
init|=
name|curr
decl_stmt|;
name|int
name|lowest_case_value
init|=
name|curr
operator|->
name|hash_value
decl_stmt|;
name|int
name|number_of_cases
init|=
literal|0
decl_stmt|;
comment|/* Figure out a good cut point to end this switch. */
for|for
control|(
init|;
name|temp
operator|&&
operator|++
name|number_of_cases
operator|<
name|switch_size
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|temp
operator|->
name|next
operator|&&
name|temp
operator|->
name|hash_value
operator|==
name|temp
operator|->
name|next
operator|->
name|hash_value
condition|)
while|while
condition|(
name|temp
operator|->
name|next
operator|&&
name|temp
operator|->
name|hash_value
operator|==
name|temp
operator|->
name|next
operator|->
name|hash_value
condition|)
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|printf
argument_list|(
literal|"          if (key<= %d)\n            {\n"
argument_list|,
name|temp
operator|->
name|hash_value
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"            {\n"
argument_list|)
expr_stmt|;
comment|/* Output each keyword as part of a switch statement indexed by hash value. */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
operator|||
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"              %s%s *resword; %s\n\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|pointer_and_type_enabled
condition|?
name|key_list
operator|.
name|struct_tag
else|:
literal|"char"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
operator|&&
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|?
literal|"int key_len;"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"              switch (key - %d)\n                {\n"
argument_list|,
name|lowest_case_value
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|curr
init|;
name|temp
operator|&&
operator|++
name|i
operator|<=
name|number_of_cases
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"                case %*d:"
argument_list|,
name|field_width
argument_list|,
name|temp
operator|->
name|hash_value
operator|-
name|lowest_case_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
name|printf
argument_list|(
literal|" /* hash value = %4d, keyword = \"%s\" */"
argument_list|,
name|temp
operator|->
name|hash_value
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Handle `natural links,' i.e., those that occur statically. */
if|if
condition|(
name|temp
operator|->
name|link
condition|)
block|{
name|LIST_NODE
modifier|*
name|links
decl_stmt|;
for|for
control|(
name|links
operator|=
name|temp
init|;
name|links
condition|;
name|links
operator|=
name|links
operator|->
name|link
control|)
block|{
if|if
condition|(
name|pointer_and_type_enabled
condition|)
name|printf
argument_list|(
literal|"                  resword =&wordlist[%d];\n"
argument_list|,
name|links
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                  resword = \"%s\";\n"
argument_list|,
name|links
operator|->
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                  if (%s) return resword;\n"
argument_list|,
name|comp_buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle unresolved duplicate hash values.  These are guaranteed                 to be adjacent since we sorted the keyword list by increasing                   hash values. */
if|if
condition|(
name|temp
operator|->
name|next
operator|&&
name|temp
operator|->
name|hash_value
operator|==
name|temp
operator|->
name|next
operator|->
name|hash_value
condition|)
block|{
for|for
control|(
init|;
name|temp
operator|->
name|next
operator|&&
name|temp
operator|->
name|hash_value
operator|==
name|temp
operator|->
name|next
operator|->
name|hash_value
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pointer_and_type_enabled
condition|)
name|printf
argument_list|(
literal|"                  resword =&wordlist[%d];\n"
argument_list|,
name|temp
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                  resword = \"%s\";\n"
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                  if (%s) return resword;\n"
argument_list|,
name|comp_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pointer_and_type_enabled
condition|)
name|printf
argument_list|(
literal|"                  resword =&wordlist[%d];\n"
argument_list|,
name|temp
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                  resword = \"%s\";\n"
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                  return %s ? resword : 0;\n"
argument_list|,
name|comp_buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|->
name|link
condition|)
name|printf
argument_list|(
literal|"                  return 0;\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pointer_and_type_enabled
condition|)
name|printf
argument_list|(
literal|"                  resword =&wordlist[%d];"
argument_list|,
name|temp
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                  resword = \"%s\";"
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
operator|&&
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
name|printf
argument_list|(
literal|" key_len = %d;"
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" break;\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"                default: return 0;\n                }\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
operator|&&
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|?
literal|"              if (len == key_len&& %s)\n                return resword;\n"
else|:
literal|"              if (%s)\n                return resword;\n"
argument_list|,
name|comp_buffer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"              return 0;\n            }\n"
argument_list|)
expr_stmt|;
name|curr
operator|=
name|temp
expr_stmt|;
block|}
else|else
comment|/* Nothing special required here. */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"              char *s;\n\n              switch (key - %d)\n                {\n"
argument_list|,
name|lowest_case_value
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|curr
init|;
name|temp
operator|&&
operator|++
name|i
operator|<=
name|number_of_cases
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"                case %*d: if (len == %d) s = \"%s\"; else return 0; break;\n"
argument_list|,
name|field_width
argument_list|,
name|temp
operator|->
name|hash_value
operator|-
name|lowest_case_value
argument_list|,
name|temp
operator|->
name|length
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                case %*d: s = \"%s\"; break;\n"
argument_list|,
name|field_width
argument_list|,
name|temp
operator|->
name|hash_value
operator|-
name|lowest_case_value
argument_list|,
name|temp
operator|->
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                default: return 0;\n                }\n              "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"return *s == *str&& !%s;\n            }\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
condition|?
literal|"strncmp (s + 1, str + 1, len - 1)"
else|:
literal|"strcmp (s + 1, str + 1)"
argument_list|)
expr_stmt|;
name|curr
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"         }\n    }\n  return 0;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints out a table of keyword lengths, for use with the     comparison code in generated function ``in_word_set.'' */
end_comment

begin_function
specifier|static
name|void
name|print_keylength_table
parameter_list|()
block|{
name|int
name|max_column
init|=
literal|15
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|column
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|indent
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GLOBAL
argument_list|)
condition|?
literal|""
else|:
literal|"  "
decl_stmt|;
name|LIST_NODE
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
operator|&&
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n%sstatic %sunsigned %s lengthtable[] =\n%s%s{\n    "
argument_list|,
name|indent
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|key_list
operator|.
name|max_key_len
operator|<
name|MAX_UNSIGNED_CHAR
condition|?
literal|"char"
else|:
operator|(
name|key_list
operator|.
name|max_key_len
operator|<
name|MAX_UNSIGNED_SHORT
condition|?
literal|"short"
else|:
literal|"long"
operator|)
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|key_list
operator|.
name|head
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
if|if
condition|(
name|index
operator|<
name|temp
operator|->
name|hash_value
condition|)
block|{
for|for
control|(
init|;
name|index
operator|<
name|temp
operator|->
name|hash_value
condition|;
name|index
operator|++
control|)
name|printf
argument_list|(
literal|"%3d%s"
argument_list|,
literal|0
argument_list|,
operator|++
name|column
operator|%
operator|(
name|max_column
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|",\n    "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%3d%s"
argument_list|,
name|temp
operator|->
name|length
argument_list|,
operator|++
name|column
operator|%
operator|(
name|max_column
operator|-
literal|1
operator|)
condition|?
literal|","
else|:
literal|",\n    "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%s%s};\n\n"
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prints out the array containing the key words for the Perfect    hash function. */
end_comment

begin_function
specifier|static
name|void
name|print_keyword_table
parameter_list|()
block|{
name|char
modifier|*
name|l_brace
init|=
operator|*
name|key_list
operator|.
name|head
operator|->
name|rest
condition|?
literal|"{"
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|r_brace
init|=
operator|*
name|key_list
operator|.
name|head
operator|->
name|rest
condition|?
literal|"},"
else|:
literal|""
decl_stmt|;
name|int
name|doing_switch
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
decl_stmt|;
name|char
modifier|*
name|indent
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GLOBAL
argument_list|)
condition|?
literal|""
else|:
literal|"  "
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|LIST_NODE
modifier|*
name|temp
decl_stmt|;
name|printf
argument_list|(
literal|"\n%sstatic %s%s wordlist[] =\n%s%s{\n"
argument_list|,
name|indent
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|key_list
operator|.
name|struct_tag
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
comment|/* Generate an array of reserved words at appropriate locations. */
for|for
control|(
name|temp
operator|=
name|key_list
operator|.
name|head
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
operator|,
name|index
operator|++
control|)
block|{
name|temp
operator|->
name|index
operator|=
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|doing_switch
operator|&&
name|index
operator|<
name|temp
operator|->
name|hash_value
condition|)
block|{
name|int
name|column
decl_stmt|;
name|printf
argument_list|(
literal|"      "
argument_list|)
expr_stmt|;
for|for
control|(
name|column
operator|=
literal|1
init|;
name|index
operator|<
name|temp
operator|->
name|hash_value
condition|;
name|index
operator|++
operator|,
name|column
operator|++
control|)
name|printf
argument_list|(
literal|"%s\"\",%s %s"
argument_list|,
name|l_brace
argument_list|,
name|r_brace
argument_list|,
name|column
operator|%
literal|9
condition|?
literal|""
else|:
literal|"\n      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|column
operator|%
literal|10
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s\"%s\", %s%s\n"
argument_list|,
name|l_brace
argument_list|,
name|temp
operator|->
name|key
argument_list|,
name|temp
operator|->
name|rest
argument_list|,
name|r_brace
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|printf
argument_list|(
literal|"      %s\"%s\", %s%s\n"
argument_list|,
name|l_brace
argument_list|,
name|temp
operator|->
name|key
argument_list|,
name|temp
operator|->
name|rest
argument_list|,
name|r_brace
argument_list|)
expr_stmt|;
comment|/* Deal with links specially. */
if|if
condition|(
name|temp
operator|->
name|link
condition|)
block|{
name|LIST_NODE
modifier|*
name|links
decl_stmt|;
for|for
control|(
name|links
operator|=
name|temp
operator|->
name|link
init|;
name|links
condition|;
name|links
operator|=
name|links
operator|->
name|link
control|)
block|{
name|links
operator|->
name|index
operator|=
operator|++
name|index
expr_stmt|;
name|printf
argument_list|(
literal|"      %s\"%s\", %s%s\n"
argument_list|,
name|l_brace
argument_list|,
name|links
operator|->
name|key
argument_list|,
name|links
operator|->
name|rest
argument_list|,
name|r_brace
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"%s%s};\n\n"
argument_list|,
name|indent
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates C code for the hash function that returns the    proper encoding for each key word. */
end_comment

begin_function
specifier|static
name|void
name|print_hash_function
parameter_list|(
name|max_hash_value
parameter_list|)
name|int
name|max_hash_value
decl_stmt|;
block|{
name|int
name|max_column
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
name|max_hash_value
decl_stmt|;
comment|/* Calculate maximum number of digits required for MAX_HASH_VALUE. */
while|while
condition|(
operator|(
name|count
operator|/=
literal|10
operator|)
operator|>
literal|0
condition|)
name|field_width
operator|++
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GNU
argument_list|)
condition|)
name|printf
argument_list|(
literal|"#ifdef __GNUC__\ninline\n#endif\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ANSI
argument_list|)
condition|?
literal|"static int\n%s (register const char *str, register int len)\n{\n  static %sunsigned %s hash_table[] =\n    {"
else|:
literal|"static int\n%s (str, len)\n     register char *str;\n     register unsigned int  len;\n{\n  static %sunsigned %s hash_table[] =\n    {"
argument_list|,
name|GET_HASH_NAME
argument_list|(
name|option
argument_list|)
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|max_hash_value
operator|<
name|MAX_UNSIGNED_CHAR
condition|?
literal|"char"
else|:
operator|(
name|max_hash_value
operator|<
name|MAX_UNSIGNED_SHORT
condition|?
literal|"short"
else|:
literal|"int"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|ALPHABET_SIZE
condition|;
operator|++
name|count
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|count
operator|%
name|max_column
operator|)
condition|)
name|printf
argument_list|(
literal|"\n    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*d,"
argument_list|,
name|field_width
argument_list|,
name|occurrences
index|[
name|count
index|]
condition|?
name|asso_values
index|[
name|count
index|]
else|:
name|max_hash_value
argument_list|)
expr_stmt|;
block|}
comment|/* Optimize special case of ``-k 1,$'' */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEFAULTCHARS
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n    };\n  return %s + hash_table[str[len - 1]] + hash_table[str[0]];\n}\n\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|"0"
else|:
literal|"len"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|key_pos
decl_stmt|;
name|RESET
argument_list|(
name|option
argument_list|)
expr_stmt|;
comment|/* Get first (also highest) key position. */
name|key_pos
operator|=
name|GET
argument_list|(
name|option
argument_list|)
expr_stmt|;
comment|/* We can perform additional optimizations here. */
if|if
condition|(
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
operator|&&
name|key_pos
operator|<=
name|key_list
operator|.
name|min_key_len
condition|)
block|{
name|printf
argument_list|(
literal|"\n  };\n  return %s"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|"0"
else|:
literal|"len"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|key_pos
operator|!=
name|EOS
operator|&&
name|key_pos
operator|!=
name|WORD_END
condition|;
name|key_pos
operator|=
name|GET
argument_list|(
name|option
argument_list|)
control|)
name|printf
argument_list|(
literal|" + hash_table[str[%d]]"
argument_list|,
name|key_pos
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s;\n}\n\n"
argument_list|,
name|key_pos
operator|==
name|WORD_END
condition|?
literal|" + hash_table[str[len - 1]]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* We've got to use the correct, but brute force, technique. */
else|else
block|{
name|printf
argument_list|(
literal|"\n    };\n  register int hval = %s;\n\n  switch (%s)\n    {\n      default:\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|"0"
else|:
literal|"len"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|"len"
else|:
literal|"hval"
argument_list|)
expr_stmt|;
comment|/* User wants *all* characters considered in hash. */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|key_list
operator|.
name|max_key_len
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"      case %d:\n        hval += hash_table[str[%d]];\n"
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n  return hval;\n}\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* do the hard part... */
block|{
name|count
operator|=
name|key_pos
operator|+
literal|1
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|--
name|count
operator|>
name|key_pos
condition|)
name|printf
argument_list|(
literal|"      case %d:\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      case %d:\n        hval += hash_table[str[%d]];\n"
argument_list|,
name|key_pos
argument_list|,
name|key_pos
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|key_pos
operator|=
name|GET
argument_list|(
name|option
argument_list|)
operator|)
operator|!=
name|EOS
operator|&&
name|key_pos
operator|!=
name|WORD_END
condition|)
do|;
name|printf
argument_list|(
literal|"    }\n  return hval%s ;\n}\n\n"
argument_list|,
name|key_pos
operator|==
name|WORD_END
condition|?
literal|" + hash_table[str[len - 1]]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generates C code to perform the keyword lookup. */
end_comment

begin_function
specifier|static
name|void
name|print_lookup_function
parameter_list|()
block|{
name|printf
argument_list|(
literal|"  if (len<= MAX_WORD_LENGTH&& len>= MIN_WORD_LENGTH)\n    {\n\       register int key = %s (str, len);\n\n\       if (key<= MAX_HASH_VALUE&& key>= MIN_HASH_VALUE)\n        {\n\           register %schar *s = wordlist[key]"
argument_list|,
name|GET_HASH_NAME
argument_list|(
name|option
argument_list|)
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_list
operator|.
name|array_type
operator|!=
name|default_array_type
condition|)
name|printf
argument_list|(
literal|".%s"
argument_list|,
name|GET_KEY_NAME
argument_list|(
name|option
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n\n          if (%s*s == *str&& !%s)\n            return %s"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
condition|?
literal|"len == lengthtable[key]\n&& "
else|:
literal|""
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
condition|?
literal|"strncmp (str + 1, s + 1, len - 1)"
else|:
literal|"strcmp (str + 1, s + 1)"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
condition|?
literal|"&wordlist[key]"
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";\n        }\n    }\n  return 0;\n}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates the hash function and the key word recognizer function    based upon the user's Options. */
end_comment

begin_function
name|void
name|print_output
parameter_list|()
block|{
name|int
name|global_table
init|=
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GLOBAL
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|key_list
operator|.
name|include_src
argument_list|)
expr_stmt|;
comment|/* Potentially output type declaration now, reference it later on.... */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
operator|&&
operator|!
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOTYPE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s;\n"
argument_list|,
name|key_list
operator|.
name|array_type
argument_list|)
expr_stmt|;
name|print_hash_function
argument_list|(
name|print_min_max
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_table
condition|)
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
condition|)
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
name|print_keylength_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
condition|)
name|print_keyword_table
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
condition|)
name|print_keylength_table
argument_list|()
expr_stmt|;
name|print_keyword_table
argument_list|()
expr_stmt|;
block|}
comment|/* Use the inline keyword to remove function overhead. */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GNU
argument_list|)
condition|)
name|printf
argument_list|(
literal|"#ifdef __GNUC__\ninline\n#endif\n"
argument_list|)
expr_stmt|;
comment|/* Use ANSI function prototypes. */
name|printf
argument_list|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ANSI
argument_list|)
condition|?
literal|"%s%s\n%s (register const char *str, register int len)\n{\n"
else|:
literal|"%s%s\n%s (str, len)\n     register char *str;\n     register unsigned int len;\n{\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"const "
else|:
literal|""
argument_list|,
name|key_list
operator|.
name|return_type
argument_list|,
name|GET_FUNCTION_NAME
argument_list|(
name|option
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the switch in place of lookup table. */
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|global_table
condition|)
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|)
name|print_keylength_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
operator|&&
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
condition|)
name|print_keyword_table
argument_list|()
expr_stmt|;
block|}
name|print_switch
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Use the lookup table, in place of switch. */
block|{
if|if
condition|(
operator|!
name|global_table
condition|)
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
condition|)
name|print_keylength_table
argument_list|()
expr_stmt|;
name|print_keyword_table
argument_list|()
expr_stmt|;
block|}
name|print_lookup_function
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|key_list
operator|.
name|additional_code
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sorts the keys by hash value. */
end_comment

begin_function
name|void
name|sort
parameter_list|()
block|{
name|key_list
operator|.
name|hash_sort
operator|=
name|TRUE
expr_stmt|;
name|key_list
operator|.
name|occurrence_sort
operator|=
name|FALSE
expr_stmt|;
name|key_list
operator|.
name|head
operator|=
name|merge_sort
argument_list|(
name|key_list
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dumps the key list to stderr stream. */
end_comment

begin_function
specifier|static
name|void
name|dump
parameter_list|()
block|{
name|LIST_NODE
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nList contents are:\n(hash value, key length, index, key set, key):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|key_list
operator|.
name|head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%7d,%7d,%6d, %s, %s\n"
argument_list|,
name|ptr
operator|->
name|hash_value
argument_list|,
name|ptr
operator|->
name|length
argument_list|,
name|ptr
operator|->
name|index
argument_list|,
name|ptr
operator|->
name|char_set
argument_list|,
name|ptr
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple-minded constructor action here... */
end_comment

begin_function
name|void
name|key_list_init
parameter_list|()
block|{
name|key_list
operator|.
name|total_keys
operator|=
literal|1
expr_stmt|;
name|key_list
operator|.
name|max_key_len
operator|=
name|NEG_MAX_INT
expr_stmt|;
name|key_list
operator|.
name|min_key_len
operator|=
name|MAX_INT
expr_stmt|;
name|key_list
operator|.
name|return_type
operator|=
name|default_return_type
expr_stmt|;
name|key_list
operator|.
name|array_type
operator|=
name|key_list
operator|.
name|struct_tag
operator|=
name|default_array_type
expr_stmt|;
name|key_list
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|key_list
operator|.
name|additional_code
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the length of entire key list. */
end_comment

begin_function
name|int
name|keyword_list_length
parameter_list|()
block|{
return|return
name|key_list
operator|.
name|list_len
return|;
block|}
end_function

begin_comment
comment|/* Returns length of longest key read. */
end_comment

begin_function
name|int
name|max_key_length
parameter_list|()
block|{
return|return
name|key_list
operator|.
name|max_key_len
return|;
block|}
end_function

begin_comment
comment|/* DESTRUCTOR dumps diagnostics during debugging. */
end_comment

begin_function
name|void
name|key_list_destroy
parameter_list|()
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nDumping key list information:\ntotal unique keywords = %d\ \ntotal keywords = %d\nmaximum key length = %d.\n"
argument_list|,
name|key_list
operator|.
name|list_len
argument_list|,
name|key_list
operator|.
name|total_keys
argument_list|,
name|key_list
operator|.
name|max_key_len
argument_list|)
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End dumping list.\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

