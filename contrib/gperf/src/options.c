begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handles parsing the Options provided to the user.    Copyright (C) 1989 Free Software Foundation, Inc.    written by Douglas C. Schmidt (schmidt@ics.uci.edu)  This file is part of GNU GPERF.  GNU GPERF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU GPERF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU GPERF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"iterator.h"
end_include

begin_include
include|#
directive|include
file|"stderr.h"
end_include

begin_comment
comment|/* Current program version. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size to jump on a collision. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_JUMP_VALUE
value|5
end_define

begin_comment
comment|/* Default name for generated lookup function. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_NAME
value|"in_word_set"
end_define

begin_comment
comment|/* Default name for the key component. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_KEY
value|"name"
end_define

begin_comment
comment|/* Default name for generated hash function. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_HASH_NAME
value|"hash"
end_define

begin_comment
comment|/* Globally visible OPTIONS object. */
end_comment

begin_decl_stmt
name|OPTIONS
name|option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default delimiters that separate keywords from their attributes. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DELIMITERS
value|",\n"
end_define

begin_comment
comment|/* Prints program usage to standard error stream. */
end_comment

begin_function
name|void
name|usage
parameter_list|()
block|{
name|report_error
argument_list|(
literal|"usage: %n [-acCdDef[num]gGhH<hashname>i<init>jk<keys>\ K<keyname>lnN<name>oprs<size>S<switches>tTv].\n(type %n -h for help)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sorts the key positions *IN REVERSE ORDER!!*    This makes further routines more efficient.  Especially when generating code.    Uses a simple Insertion Sort since the set is probably ordered.    Returns 1 if there are no duplicates, 0 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|key_sort
parameter_list|(
name|base
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|int
name|curr
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|i
operator|+
literal|1
operator|,
name|tmp
operator|=
name|base
index|[
name|curr
index|]
init|;
name|curr
operator|>
literal|0
operator|&&
name|tmp
operator|>=
name|base
index|[
name|curr
operator|-
literal|1
index|]
condition|;
name|curr
operator|--
control|)
if|if
condition|(
operator|(
name|base
index|[
name|curr
index|]
operator|=
name|base
index|[
name|curr
operator|-
literal|1
index|]
operator|)
operator|==
name|tmp
condition|)
comment|/* oh no, a duplicate!!! */
return|return
literal|0
return|;
name|base
index|[
name|curr
index|]
operator|=
name|tmp
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dumps option status when debug is set. */
end_comment

begin_function
name|void
name|options_destroy
parameter_list|()
block|{
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndumping Options:\nDEBUG is.......: %s\nORDER is.......: %s\ \nANSI is........: %s\nTYPE is........: %s\nGNU is.........: %s\nRANDOM is......: %s\ \nDEFAULTCHARS is: %s\nSWITCH is......: %s\nPOINTER is.....: %s\nNOLENGTH is....: %s\ \nLENTABLE is....: %s\nDUP is.........: %s\nCOMP is........: %s\nFAST is........: %s\ \nNOTYPE is......: %s\nGLOBAL is......: %s\nCONST is.......: %s\niterations = %d\ \nlookup function name = %s\nhash function name = %s\nkey name = %s\ \njump value = %d\nmax associcated value = %d\ninitial associated value = %d\ \ndelimiters = %s\nnumber of switch statements = %d\napproximate switch statement size = %d\n"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ORDER
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ANSI
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GNU
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|RANDOM
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DEFAULTCHARS
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|FAST
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|NOTYPE
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|GLOBAL
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|option
operator|.
name|iterations
argument_list|,
name|option
operator|.
name|function_name
argument_list|,
name|option
operator|.
name|hash_name
argument_list|,
name|option
operator|.
name|key_name
argument_list|,
name|option
operator|.
name|jump
argument_list|,
name|option
operator|.
name|size
operator|-
literal|1
argument_list|,
name|option
operator|.
name|initial_asso_value
argument_list|,
name|option
operator|.
name|delimiters
argument_list|,
name|option
operator|.
name|total_switches
argument_list|,
name|keyword_list_length
argument_list|()
operator|/
name|option
operator|.
name|total_switches
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"all characters are used in the hash function\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maximum charset size = %d\nkey positions are: \n"
argument_list|,
name|option
operator|.
name|total_charset_size
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|option
operator|.
name|key_positions
init|;
operator|*
name|ptr
operator|!=
name|EOS
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
name|WORD_END
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"$\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"finished dumping Options\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parses the command line Options and sets appropriate flags in option.option_word. */
end_comment

begin_function
name|void
name|options_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|option_char
decl_stmt|;
name|option
operator|.
name|key_positions
index|[
literal|0
index|]
operator|=
name|WORD_START
expr_stmt|;
name|option
operator|.
name|key_positions
index|[
literal|1
index|]
operator|=
name|WORD_END
expr_stmt|;
name|option
operator|.
name|key_positions
index|[
literal|2
index|]
operator|=
name|EOS
expr_stmt|;
name|option
operator|.
name|total_charset_size
operator|=
literal|2
expr_stmt|;
name|option
operator|.
name|jump
operator|=
name|DEFAULT_JUMP_VALUE
expr_stmt|;
name|option
operator|.
name|option_word
operator|=
operator|(
name|int
operator|)
name|DEFAULTCHARS
expr_stmt|;
name|option
operator|.
name|function_name
operator|=
name|DEFAULT_NAME
expr_stmt|;
name|option
operator|.
name|hash_name
operator|=
name|DEFAULT_HASH_NAME
expr_stmt|;
name|option
operator|.
name|key_name
operator|=
name|DEFAULT_KEY
expr_stmt|;
name|option
operator|.
name|delimiters
operator|=
name|DEFAULT_DELIMITERS
expr_stmt|;
name|option
operator|.
name|initial_asso_value
operator|=
name|option
operator|.
name|size
operator|=
name|option
operator|.
name|iterations
operator|=
literal|0
expr_stmt|;
name|option
operator|.
name|total_switches
operator|=
literal|1
expr_stmt|;
name|option
operator|.
name|argument_count
operator|=
name|argc
expr_stmt|;
name|option
operator|.
name|argument_vector
operator|=
name|argv
expr_stmt|;
name|set_program_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|option_char
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"adcCDe:f:gGhH:i:j:k:K:lnN:oprs:S:tTv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|option_char
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Generated coded uses the ANSI prototype format. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|ANSI
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
comment|/* Generate strncmp rather than strcmp. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|COMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'C'
case|:
comment|/* Make the generated tables readonly (const). */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|CONST
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'d'
case|:
comment|/* Enable debugging option. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|DEBUG
argument_list|)
expr_stmt|;
name|report_error
argument_list|(
literal|"starting program %n, version %s, with debuggin on.\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'D'
case|:
comment|/* Enable duplicate option. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|DUP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'e'
case|:
comment|/* Allows user to provide keyword/attribute separator */
block|{
name|SET_DELIMITERS
argument_list|(
name|option
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'f'
case|:
comment|/* Generate the hash table ``fast.'' */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|FAST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|.
name|iterations
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|report_error
argument_list|(
literal|"iterations value must not be negative, assuming 0\n"
argument_list|)
expr_stmt|;
name|option
operator|.
name|iterations
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'g'
case|:
comment|/* Use the ``inline'' keyword for generated sub-routines. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|GNU
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'G'
case|:
comment|/* Make the keyword table a global variable. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|GLOBAL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'h'
case|:
comment|/* Displays a list of helpful Options to the user. */
block|{
name|report_error
argument_list|(
literal|"-a\tGenerate ANSI standard C output code, i.e., function prototypes.\n\ -c\tGenerate comparison code using strncmp rather than strcmp.\n\ -C\tMake the contents of generated lookup tables constant, i.e., readonly.\n\ -d\tEnables the debugging option (produces verbose output to Std_Err).\n\ -D\tHandle keywords that hash to duplicate values.  This is useful\n\ \tfor certain highly redundant keyword sets.  It enables the -S option.\n\ -e\tAllow user to provide a string containing delimiters used to separate\n\ \tkeywords from their attributes.  Default is \",\\n\"\n\ -f\tGenerate the perfect hash function ``fast.''  This decreases GPERF's\n\ \trunning time at the cost of minimizing generated table-size.\n\ \tThe numeric argument represents the number of times to iterate when\n\ \tresolving a collision.  `0' means ``iterate by the number of keywords''.\n\ -g\tAssume a GNU compiler, e.g., g++ or gcc.  This makes all generated\n\ \troutines use the ``inline'' keyword to remove cost of function calls.\n\ -G\tGenerate the static table of keywords as a static global variable,\n\ \trather than hiding it inside of the lookup function (which is the\n\ \tdefault behavior).\n\ -h\tPrints this mesage.\n"
argument_list|)
expr_stmt|;
name|report_error
argument_list|(
literal|"-H\tAllow user to specify name of generated hash function. Default is `hash'.\n\ -i\tProvide an initial value for the associate values array.  Default is 0.\n\ \tSetting this value larger helps inflate the size of the final table.\n\ -j\tAffects the ``jump value,'' i.e., how far to advance the associated\n\ \tcharacter value upon collisions.  Must be an odd number, default is %d.\n\ -k\tAllows selection of the key positions used in the hash function.\n\ \tThe allowable choices range between 1-%d, inclusive.  The positions\n\ \tare separated by commas, ranges may be used, and key positions may\n\ \toccur in any order.  Also, the meta-character '*' causes the generated\n\ \thash function to consider ALL key positions, and $ indicates the\n\ \t``final character'' of a key, e.g., $,1,2,4,6-10.\n\ -K\tAllow user to select name of the keyword component in the keyword structure.\n\ -l\tCompare key lengths before trying a string comparison.  This helps\n\ \tcut down on the number of string comparisons made during the lookup.\n\ -n\tDo not include the length of the keyword when computing the hash function\n\ -N\tAllow user to specify name of generated lookup function.  Default\n\ \tname is `in_word_set.'\n\ -o\tReorders input keys by frequency of occurrence of the key sets.\n\ \tThis should decrease the search time dramatically.\n\ -p\tChanges the return value of the generated function ``in_word_set''\n\ \tfrom its default boolean value (i.e., 0 or 1), to type ``pointer\n\ \tto wordlist array''  This is most useful when the -t option, allowing\n\ \tuser-defined structs, is used.\n"
argument_list|,
name|DEFAULT_JUMP_VALUE
argument_list|,
name|MAX_KEY_POS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|report_error
argument_list|(
literal|"-r\tUtilizes randomness to initialize the associated values table.\n\ -s\tAffects the size of the generated hash table.  The numeric argument\n\ \tfor this option indicates ``how many times larger'' the table range\n\ \tshould be, in relationship to the number of keys, e.g. a value of 3\n\ \tmeans ``make the table about 3 times larger than the number of input\n\ \tkeys.''  A larger table should decrease the time required for an\n\ \tunsuccessful search, at the expense of extra table space.  Default\n\ \tvalue is 1.  This actual table size may vary somewhat.\n\ -S\tCauses the generated C code to use a switch statement scheme, rather\n\ \tthan an array lookup table.  This can lead to a reduction in both\n\ \ttime and space requirements for some keyfiles.  The argument to\n\ \tthis option determines how many switch statements are generated.\n\ \tA value of 1 generates 1 switch containing all the elements, a value of 2\n\ \tgenerates 2 tables with 1/2 the elements in each table, etc.  This\n\ \tis useful since many C compilers cannot correctly generate code for\n\ \tlarge switch statements.\n\ \tthe expense of longer time for each lookup.  Mostly important for\n\ \t*large* input sets, i.e., greater than around 100 items or so.\n\ -t\tAllows the user to include a structured type declaration for \n\ \tgenerated code. Any text before %%%% is consider part of the type\n\ \tdeclaration.  Key words and additional fields may follow this, one\n\ \tgroup of fields per line.\n\ -T\tPrevents the transfer of the type declaration to the output file.\n\ \tUse this option if the type is already defined elsewhere.\n\ -v\tPrints out the current version number\n%e%a\n"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
case|case
literal|'H'
case|:
comment|/* Sets the name for the hash function */
block|{
name|option
operator|.
name|hash_name
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
case|case
literal|'i'
case|:
comment|/* Sets the initial value for the associated values array. */
block|{
if|if
condition|(
operator|(
name|option
operator|.
name|initial_asso_value
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|report_error
argument_list|(
literal|"initial value %d must be non-zero, ignoring and continuing\n"
argument_list|,
name|option
operator|.
name|initial_asso_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|OPTION_ENABLED
argument_list|(
name|option
argument_list|,
name|RANDOM
argument_list|)
condition|)
name|report_error
argument_list|(
literal|"warning, -r option superceeds -i, ignoring -i option and continuing\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'j'
case|:
comment|/* Sets the jump value, must be odd for later algorithms. */
block|{
if|if
condition|(
operator|(
name|option
operator|.
name|jump
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|report_error
argument_list|(
literal|"jump value %d must be a positive number\n%e%a"
argument_list|,
name|option
operator|.
name|jump
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|.
name|jump
operator|&&
name|EVEN
argument_list|(
name|option
operator|.
name|jump
argument_list|)
condition|)
name|report_error
argument_list|(
literal|"jump value %d should be odd, adding 1 and continuing...\n"
argument_list|,
name|option
operator|.
name|jump
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'k'
case|:
comment|/* Sets key positions used for hash function. */
block|{
name|int
name|BAD_VALUE
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|value
decl_stmt|;
name|iterator_init
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
name|MAX_KEY_POS
operator|-
literal|1
argument_list|,
name|WORD_END
argument_list|,
name|BAD_VALUE
argument_list|,
name|EOS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'*'
condition|)
comment|/* Use all the characters for hashing!!!! */
block|{
name|UNSET_OPTION
argument_list|(
name|option
argument_list|,
name|DEFAULTCHARS
argument_list|)
expr_stmt|;
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|ALLCHARS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|key_pos
decl_stmt|;
for|for
control|(
name|key_pos
operator|=
name|option
operator|.
name|key_positions
init|;
operator|(
name|value
operator|=
name|next
argument_list|()
operator|)
operator|!=
name|EOS
condition|;
name|key_pos
operator|++
control|)
if|if
condition|(
name|value
operator|==
name|BAD_VALUE
condition|)
name|report_error
argument_list|(
literal|"illegal key value or range, use 1,2,3-%d,'$' or '*'.\n%e%a"
argument_list|,
operator|(
name|MAX_KEY_POS
operator|-
literal|1
operator|)
argument_list|,
name|usage
argument_list|)
expr_stmt|;
else|else
operator|*
name|key_pos
operator|=
name|value
expr_stmt|;
empty_stmt|;
operator|*
name|key_pos
operator|=
name|EOS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|option
operator|.
name|total_charset_size
operator|=
operator|(
name|key_pos
operator|-
name|option
operator|.
name|key_positions
operator|)
operator|)
condition|)
name|report_error
argument_list|(
literal|"no keys selected\n%e%a"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|key_sort
argument_list|(
name|option
operator|.
name|key_positions
argument_list|,
name|option
operator|.
name|total_charset_size
argument_list|)
condition|)
name|report_error
argument_list|(
literal|"duplicate keys selected\n%e%a"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|.
name|total_charset_size
operator|!=
literal|2
operator|||
operator|(
name|option
operator|.
name|key_positions
index|[
literal|0
index|]
operator|!=
literal|1
operator|||
name|option
operator|.
name|key_positions
index|[
literal|1
index|]
operator|!=
name|WORD_END
operator|)
condition|)
name|UNSET_OPTION
argument_list|(
name|option
argument_list|,
name|DEFAULTCHARS
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'K'
case|:
comment|/* Make this the keyname for the keyword component field. */
block|{
name|option
operator|.
name|key_name
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
case|case
literal|'l'
case|:
comment|/* Create length table to avoid extra string compares. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|LENTABLE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'n'
case|:
comment|/* Don't include the length when computing hash function. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|NOLENGTH
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'N'
case|:
comment|/* Make generated lookup function name be optarg */
block|{
name|option
operator|.
name|function_name
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
comment|/* Order input by frequency of key set occurrence. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|ORDER
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'p'
case|:
comment|/* Generated lookup function now a pointer instead of int. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|POINTER
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'r'
case|:
comment|/* Utilize randomness to initialize the associated values table. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|RANDOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|.
name|initial_asso_value
operator|!=
literal|0
condition|)
name|report_error
argument_list|(
literal|"warning, -r option superceeds -i, disabling -i option and continuing\n"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
comment|/* Range of associated values, determines size of final table. */
block|{
if|if
condition|(
operator|(
name|option
operator|.
name|size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|report_error
argument_list|(
literal|"improper range argument %s\n%e%a"
argument_list|,
name|optarg
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|.
name|size
operator|>
literal|50
condition|)
name|report_error
argument_list|(
literal|"%d is excessive, did you really mean this?! (type %n -h for help)\n"
argument_list|,
name|option
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'S'
case|:
comment|/* Generate switch statement output, rather than lookup table. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|SWITCH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|.
name|total_switches
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|report_error
argument_list|(
literal|"number of switches %s must be a positive number\n%e%a"
argument_list|,
name|optarg
argument_list|,
name|usage
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
comment|/* Enable the TYPE mode, allowing arbitrary user structures. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|TYPE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'T'
case|:
comment|/* Don't print structure definition. */
block|{
name|SET_OPTION
argument_list|(
name|option
argument_list|,
name|NOTYPE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'v'
case|:
comment|/* Print out the version and quit. */
name|report_error
argument_list|(
literal|"%n: version %s\n%e%a\n"
argument_list|,
name|version_string
argument_list|,
name|usage
argument_list|)
expr_stmt|;
default|default:
name|report_error
argument_list|(
literal|"%e%a"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argv
index|[
name|optind
index|]
operator|&&
operator|!
name|freopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
condition|)
name|report_error
argument_list|(
literal|"unable to read key word file %s\n%e%a"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|usage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|optind
operator|<
name|argc
condition|)
name|report_error
argument_list|(
literal|"extra trailing arguments to %n\n%e%a"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output command-line Options. */
end_comment

begin_function
name|void
name|print_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"/* Command-line: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|option
operator|.
name|argument_count
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|option
operator|.
name|argument_vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" */\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

