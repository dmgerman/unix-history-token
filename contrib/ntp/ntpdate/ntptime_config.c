begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntptime_config.c  *  * What follows is a simplified version of the config parsing code  * in ntpd/ntp_config.c.  We only parse a subset of the configuration  * syntax, and don't bother whining about things we don't understand.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntpdate.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * These routines are used to read the configuration file at  * startup time.  An entry in the file must fit on a single line.  * Entries are processed as multiple tokens separated by white space  * Lines are considered terminated when a '#' is encountered.  Blank  * lines are ignored.  */
end_comment

begin_comment
comment|/*  * Configuration file name  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_FILE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"/etc/ntp.conf"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_define
define|#
directive|define
name|CONFIG_FILE
value|"%windir%\\ntp.conf"
end_define

begin_define
define|#
directive|define
name|ALT_CONFIG_FILE
value|"%windir%\\ntp.ini"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CONFIG_FILE */
end_comment

begin_comment
comment|/*  *  * We understand the following configuration entries and defaults.  *  * peer [ addr ] [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * server [ addr ] [ version 3 ] [ key 0 ] [ minpoll 6 ] [ maxpoll 10 ]  * keys file_name  */
end_comment

begin_define
define|#
directive|define
name|CONFIG_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|CONFIG_PEER
value|1
end_define

begin_define
define|#
directive|define
name|CONFIG_SERVER
value|2
end_define

begin_define
define|#
directive|define
name|CONFIG_KEYS
value|8
end_define

begin_define
define|#
directive|define
name|CONF_MOD_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|CONF_MOD_KEY
value|2
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MINPOLL
value|3
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MAXPOLL
value|4
end_define

begin_define
define|#
directive|define
name|CONF_MOD_PREFER
value|5
end_define

begin_define
define|#
directive|define
name|CONF_MOD_BURST
value|6
end_define

begin_define
define|#
directive|define
name|CONF_MOD_SKEY
value|7
end_define

begin_define
define|#
directive|define
name|CONF_MOD_TTL
value|8
end_define

begin_define
define|#
directive|define
name|CONF_MOD_MODE
value|9
end_define

begin_comment
comment|/*  * Translation table - keywords to function index  */
end_comment

begin_struct
struct|struct
name|keyword
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|keytype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Command keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|keywords
index|[]
init|=
block|{
block|{
literal|"peer"
block|,
name|CONFIG_PEER
block|}
block|,
block|{
literal|"server"
block|,
name|CONFIG_SERVER
block|}
block|,
block|{
literal|"keys"
block|,
name|CONFIG_KEYS
block|}
block|,
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "peer", "server", "broadcast" modifier keywords  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|mod_keywords
index|[]
init|=
block|{
block|{
literal|"version"
block|,
name|CONF_MOD_VERSION
block|}
block|,
block|{
literal|"key"
block|,
name|CONF_MOD_KEY
block|}
block|,
block|{
literal|"minpoll"
block|,
name|CONF_MOD_MINPOLL
block|}
block|,
block|{
literal|"maxpoll"
block|,
name|CONF_MOD_MAXPOLL
block|}
block|,
block|{
literal|"prefer"
block|,
name|CONF_MOD_PREFER
block|}
block|,
block|{
literal|"burst"
block|,
name|CONF_MOD_BURST
block|}
block|,
block|{
literal|"autokey"
block|,
name|CONF_MOD_SKEY
block|}
block|,
block|{
literal|"mode"
block|,
name|CONF_MOD_MODE
block|}
block|,
comment|/* reference clocks */
block|{
literal|"ttl"
block|,
name|CONF_MOD_TTL
block|}
block|,
comment|/* NTP peers */
block|{
literal|""
block|,
name|CONFIG_UNKNOWN
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Limits on things  */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|20
end_define

begin_comment
comment|/* 20 tokens on line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|1024
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXFILENAME
value|128
end_define

begin_comment
comment|/* maximum length of a file name (alloca()?) */
end_comment

begin_comment
comment|/*  * Miscellaneous macros  */
end_comment

begin_define
define|#
directive|define
name|STRSAME
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(*(s1) == *(s2)&& strcmp((s1), (s2)) == 0)
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '#' || (c) == '\n' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Systemwide parameters and flags  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|server
modifier|*
modifier|*
name|sys_servers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the server list */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sys_numservers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of servers to poll */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|key_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gettokens
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|matchkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|keyword
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnetnum
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|num
operator|,
expr|struct
name|sockaddr_in
operator|*
name|addr
operator|,
name|int
name|complain
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * loadservers - load list of NTP servers from configuration file  */
end_comment

begin_function
name|void
name|loadservers
parameter_list|(
name|char
modifier|*
name|cfgpath
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|peerversion
decl_stmt|;
name|int
name|minpoll
decl_stmt|;
name|int
name|maxpoll
decl_stmt|;
comment|/* int ttl; */
name|int
name|srvcnt
decl_stmt|;
comment|/* u_long peerkey; */
name|int
name|peerflags
decl_stmt|;
name|struct
name|sockaddr_in
name|peeraddr
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
argument_list|*
operator|(
name|tokens
index|[
name|MAXTOKENS
index|]
operator|)
argument_list|;
name|int
name|ntokens
argument_list|;
name|int
name|tok
argument_list|;
specifier|const
name|char
operator|*
name|config_file
argument_list|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|char
operator|*
name|alt_config_file
argument_list|;
name|LPTSTR
name|temp
argument_list|;
name|char
name|config_file_storage
index|[
name|MAX_PATH
index|]
argument_list|;
name|char
name|alt_config_file_storage
index|[
name|MAX_PATH
index|]
argument_list|;
endif|#
directive|endif
comment|/* SYS_WINNT */
expr|struct
name|server
operator|*
name|server
argument_list|,
operator|*
name|srvlist
argument_list|;
comment|/* 	 * Initialize, initialize 	 */
name|srvcnt
operator|=
literal|0
argument_list|;
name|srvlist
operator|=
literal|0
argument_list|;
name|errflg
operator|=
literal|0
argument_list|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|0
argument_list|;
endif|#
directive|endif
comment|/* DEBUG */
ifndef|#
directive|ifndef
name|SYS_WINNT
name|config_file
operator|=
name|cfgpath
condition|?
name|cfgpath
else|:
name|CONFIG_FILE
argument_list|;
else|#
directive|else
argument_list|if
operator|(
name|cfgpath
operator|)
block|{
name|config_file
operator|=
name|cfgpath
block|; 	}
else|else
block|{
name|temp
operator|=
name|CONFIG_FILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|config_file_storage
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings CONFIG_FILE failed: %m\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|config_file
operator|=
name|config_file_storage
expr_stmt|;
block|}
name|temp
operator|=
name|ALT_CONFIG_FILE
argument_list|; 	if
operator|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
operator|(
name|LPCTSTR
operator|)
name|temp
argument_list|,
operator|(
name|LPTSTR
operator|)
name|alt_config_file_storage
argument_list|,
operator|(
name|DWORD
operator|)
sizeof|sizeof
argument_list|(
name|alt_config_file_storage
argument_list|)
argument_list|)
operator|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings ALT_CONFIG_FILE failed: %m\n"
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; 	}
name|alt_config_file
operator|=
name|alt_config_file_storage
argument_list|;
name|M
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|config_file
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* Under WinNT try alternate_config_file name, first NTP.CONF, then NTP.INI */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Broadcast clients can sometimes run without 			 * a configuration file. 			 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getconfig: Couldn't open<%s>\n"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"getconfig: Couldn't open<%s>"
argument_list|,
name|FindConfig
argument_list|(
name|alt_config_file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
comment|/* not SYS_WINNT */
return|return;
endif|#
directive|endif
comment|/* not SYS_WINNT */
block|}
while|while
condition|(
operator|(
name|tok
operator|=
name|gettokens
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntokens
argument_list|)
operator|)
operator|!=
name|CONFIG_UNKNOWN
condition|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|CONFIG_PEER
case|:
case|case
name|CONFIG_SERVER
case|:
if|if
condition|(
name|ntokens
operator|<
literal|2
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No address for %s, line ignored"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|,
operator|&
name|peeraddr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Resolve now, or lose! */
break|break;
block|}
else|else
block|{
name|errflg
operator|=
literal|0
expr_stmt|;
comment|/* Shouldn't be able to specify multicast */
if|if
condition|(
name|IN_CLASSD
argument_list|(
name|ntohl
argument_list|(
name|peeraddr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|ISBADADR
argument_list|(
operator|&
name|peeraddr
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"attempt to configure invalid address %s"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|peeraddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|peerversion
operator|=
name|NTP_VERSION
expr_stmt|;
name|minpoll
operator|=
name|NTP_MINDPOLL
expr_stmt|;
name|maxpoll
operator|=
name|NTP_MAXDPOLL
expr_stmt|;
comment|/* peerkey = 0; */
name|peerflags
operator|=
literal|0
expr_stmt|;
comment|/* ttl = 0; */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|ntokens
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|matchkey
argument_list|(
name|tokens
index|[
name|i
index|]
argument_list|,
name|mod_keywords
argument_list|)
condition|)
block|{
case|case
name|CONF_MOD_VERSION
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"peer/server version requires an argument"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|peerversion
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_char
operator|)
name|peerversion
operator|>
name|NTP_VERSION
operator|||
operator|(
name|u_char
operator|)
name|peerversion
operator|<
name|NTP_OLDVERSION
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inappropriate version number %s, line ignored"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CONF_MOD_KEY
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"key: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
comment|/* peerkey = (int)atol(tokens[i]); */
name|peerflags
operator||=
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MINPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"minpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|minpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minpoll
operator|<
name|NTP_MINPOLL
condition|)
name|minpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_MAXPOLL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"maxpoll: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|maxpoll
operator|=
name|atoi
argument_list|(
name|tokens
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxpoll
operator|>
name|NTP_MAXPOLL
condition|)
name|maxpoll
operator|=
name|NTP_MAXPOLL
expr_stmt|;
break|break;
case|case
name|CONF_MOD_PREFER
case|:
name|peerflags
operator||=
name|FLAG_PREFER
expr_stmt|;
break|break;
case|case
name|CONF_MOD_BURST
case|:
name|peerflags
operator||=
name|FLAG_BURST
expr_stmt|;
break|break;
case|case
name|CONF_MOD_SKEY
case|:
name|peerflags
operator||=
name|FLAG_SKEY
operator||
name|FLAG_AUTHENABLE
expr_stmt|;
break|break;
case|case
name|CONF_MOD_TTL
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ttl: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
comment|/* ttl = atoi(tokens[i]); */
break|break;
case|case
name|CONF_MOD_MODE
case|:
if|if
condition|(
name|i
operator|>=
name|ntokens
operator|-
literal|1
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mode: argument required"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
comment|/* ttl = atoi(tokens[i]); */
break|break;
case|case
name|CONFIG_UNKNOWN
case|:
name|errflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|minpoll
operator|>
name|maxpoll
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"config error: minpoll> maxpoll"
argument_list|)
expr_stmt|;
name|errflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|errflg
operator|==
literal|0
condition|)
block|{
name|server
operator|=
operator|(
expr|struct
name|server
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|->
name|srcadr
operator|=
name|peeraddr
expr_stmt|;
name|server
operator|->
name|version
operator|=
name|peerversion
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
name|PEER_MAXDISP
expr_stmt|;
name|server
operator|->
name|next_server
operator|=
name|srvlist
expr_stmt|;
name|srvlist
operator|=
name|server
expr_stmt|;
name|srvcnt
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_KEYS
case|:
if|if
condition|(
name|ntokens
operator|>=
literal|2
condition|)
block|{
name|key_file
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|tokens
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|key_file
argument_list|,
name|tokens
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* build final list */
name|sys_numservers
operator|=
name|srvcnt
expr_stmt|;
name|sys_servers
operator|=
operator|(
expr|struct
name|server
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
name|sys_numservers
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|server
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
block|{
name|sys_servers
index|[
name|i
index|]
operator|=
name|srvlist
expr_stmt|;
name|srvlist
operator|=
name|srvlist
operator|->
name|next_server
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * gettokens - read a line and return tokens  */
end_comment

begin_function
specifier|static
name|int
name|gettokens
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokenlist
parameter_list|,
name|int
modifier|*
name|ntokens
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|eol
decl_stmt|;
specifier|register
name|int
name|ntok
decl_stmt|;
specifier|register
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* 	 * Find start of first token 	 */
name|again
label|:
while|while
condition|(
operator|(
name|cp
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|MAXLINE
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|*
name|ntokens
operator|=
literal|0
expr_stmt|;
return|return
name|CONFIG_UNKNOWN
return|;
comment|/* hack.  Is recognized as EOF */
block|}
comment|/* 	 * Now separate out the tokens 	 */
name|eol
operator|=
literal|0
expr_stmt|;
name|ntok
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|eol
condition|)
block|{
name|tokenlist
index|[
name|ntok
operator|++
index|]
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|(
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|quoted
operator|)
condition|)
name|quoted
operator|^=
operator|(
operator|*
name|cp
operator|++
operator|==
literal|'"'
operator|)
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|eol
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* must be space */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ntok
operator|==
name|MAXTOKENS
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Return the match 	 */
operator|*
name|ntokens
operator|=
name|ntok
expr_stmt|;
name|ntok
operator|=
name|matchkey
argument_list|(
name|tokenlist
index|[
literal|0
index|]
argument_list|,
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|CONFIG_UNKNOWN
condition|)
goto|goto
name|again
goto|;
return|return
name|ntok
return|;
block|}
end_function

begin_comment
comment|/*  * matchkey - match a keyword to a list  */
end_comment

begin_function
specifier|static
name|int
name|matchkey
parameter_list|(
specifier|register
name|char
modifier|*
name|word
parameter_list|,
specifier|register
name|struct
name|keyword
modifier|*
name|keys
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|keys
operator|->
name|keytype
operator|==
name|CONFIG_UNKNOWN
condition|)
block|{
return|return
name|CONFIG_UNKNOWN
return|;
block|}
if|if
condition|(
name|STRSAME
argument_list|(
name|word
argument_list|,
name|keys
operator|->
name|text
argument_list|)
condition|)
return|return
name|keys
operator|->
name|keytype
return|;
name|keys
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * getnetnum - return a net number (this is crude, but careful)  */
end_comment

begin_function
specifier|static
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|num
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|,
name|int
name|complain
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* will core dump on really stupid stuff */
name|u_int32
name|netnum
decl_stmt|;
comment|/* XXX ELIMINATE replace with decodenetnum */
name|cp
operator|=
name|num
expr_stmt|;
name|netnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
break|break;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|255
condition|)
break|break;
name|netnum
operator|<<=
literal|8
expr_stmt|;
name|netnum
operator|+=
name|temp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum %s step %d buf %s temp %d netnum %lu\n"
argument_list|,
name|num
argument_list|,
name|i
argument_list|,
name|buf
argument_list|,
name|temp
argument_list|,
operator|(
name|u_long
operator|)
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetnum: \"%s\" invalid host number, line ignored"
argument_list|,
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"getnetnum: \"%s\" invalid host number, line ignored\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * make up socket address.	Clear it out for neatness. 	 */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"getnetnum given %s, got %s (%lx)\n"
argument_list|,
name|num
argument_list|,
name|ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|netnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

end_unit

