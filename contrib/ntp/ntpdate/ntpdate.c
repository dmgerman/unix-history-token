begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpdate - set the time of day by polling one or more NTP servers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_machine.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|"ntpdate.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_include
include|#
directive|include
file|"isc/net.h"
end_include

begin_include
include|#
directive|include
file|"isc/result.h"
end_include

begin_include
include|#
directive|include
file|"isc/sockaddr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL_H
end_ifdef

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SIGNAL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_include
include|#
directive|include
file|"ioLib.h"
end_include

begin_include
include|#
directive|include
file|"sockLib.h"
end_include

begin_include
include|#
directive|include
file|"timers.h"
end_include

begin_comment
comment|/* select wants a zero structure ... */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
end_elif

begin_comment
comment|/*  * Windows does not abort a select select call if SIGALRM goes off  * so a 200 ms timeout is needed (TIMER_HZ is 5).  */
end_comment

begin_decl_stmt
name|struct
name|sock_timeval
name|timeout
init|=
block|{
literal|0
block|,
literal|1000000
operator|/
name|TIMER_HZ
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|timeval
name|timeout
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"recvbuff.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_define
define|#
directive|define
name|TARGET_RESOLUTION
value|1
end_define

begin_comment
comment|/* Try for 1-millisecond accuracy 				on Windows NT timers. */
end_comment

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|lib
name|,
literal|"winmm"
name|)
end_pragma

begin_function_decl
name|isc_boolean_t
name|ntp_port_inuse
parameter_list|(
name|int
name|af
parameter_list|,
name|u_short
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|UINT
name|wTimerRes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Scheduling priority we run at  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_VXWORKS
end_ifndef

begin_define
define|#
directive|define
name|NTPDATE_PRIO
value|(-12)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NTPDATE_PRIO
value|(100)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
end_ifdef

begin_comment
comment|/* POSIX TIMERS - vxWorks doesn't have itimer - casey */
end_comment

begin_decl_stmt
specifier|static
name|timer_t
name|ntpdate_timerid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compatibility stuff for Version 2  */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXSKW
value|0x28f
end_define

begin_comment
comment|/* 0.01 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|NTP_MINDIST
value|0x51f
end_define

begin_comment
comment|/* 0.02 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|PEER_MAXDISP
value|(64*FP_SECOND)
end_define

begin_comment
comment|/* maximum dispersion (fp 64) */
end_comment

begin_define
define|#
directive|define
name|NTP_INFIN
value|15
end_define

begin_comment
comment|/* max stratum, infinity a la Bellman-Ford */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXWGT
value|(8*FP_SECOND)
end_define

begin_comment
comment|/* maximum select weight 8 seconds */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXLIST
value|5
end_define

begin_comment
comment|/* maximum select list size */
end_comment

begin_define
define|#
directive|define
name|PEER_SHIFT
value|8
end_define

begin_comment
comment|/* 8 suitable for crystal time base */
end_comment

begin_comment
comment|/*  * for get_systime()  */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_comment
comment|/*  * File descriptor masks etc. for call to select  */
end_comment

begin_decl_stmt
name|int
name|ai_fam_templ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the number of sockets used */
end_comment

begin_decl_stmt
name|SOCKET
name|fd
index|[
name|MAX_AF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd_family
index|[
name|MAX_AF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to remember the socket family */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL_H
end_ifdef

begin_decl_stmt
name|struct
name|pollfd
name|fdmask
index|[
name|MAX_AF
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|fd_set
name|fdmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SOCKET
name|maxfd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|polltest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initializing flag.  All async routines watch this and only do their  * thing when it is clear.  */
end_comment

begin_decl_stmt
name|int
name|initializing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Alarm flag.	Set when an alarm occurs  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|alarm_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Simple query flag.  */
end_comment

begin_decl_stmt
name|int
name|simple_query
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unprivileged port flag.  */
end_comment

begin_decl_stmt
name|int
name|unpriv_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Program name.  */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Systemwide parameters and flags  */
end_comment

begin_decl_stmt
name|int
name|sys_samples
init|=
name|DEFSAMPLES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of samples/server */
end_comment

begin_decl_stmt
name|u_long
name|sys_timeout
init|=
name|DEFTIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timeout time, in TIMER_HZ units */
end_comment

begin_decl_stmt
name|struct
name|server
modifier|*
name|sys_servers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the server list */
end_comment

begin_decl_stmt
name|int
name|sys_numservers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of servers to poll */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true when authenticating */
end_comment

begin_decl_stmt
name|u_int32
name|sys_authkey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to authentication key in use */
end_comment

begin_decl_stmt
name|u_long
name|sys_authdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_decl_stmt
name|int
name|sys_version
init|=
name|NTP_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version to poll with */
end_comment

begin_comment
comment|/*  * The current internal time  */
end_comment

begin_decl_stmt
name|u_long
name|current_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Counter for keeping track of completed servers  */
end_comment

begin_decl_stmt
name|int
name|complete_servers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File of encryption keys  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KEYFILE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_define
define|#
directive|define
name|KEYFILE
value|"/etc/ntp.keys"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KEYFILE
value|"%windir%\\ntp.keys"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEYFILE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|key_file
init|=
name|KEYFILE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|key_file_storage
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|key_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Miscellaneous flags  */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|always_step
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|never_step
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ntpdatemain
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|transmit
parameter_list|(
name|struct
name|server
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|server_data
parameter_list|(
name|struct
name|server
modifier|*
parameter_list|,
name|s_fp
parameter_list|,
name|l_fp
modifier|*
parameter_list|,
name|u_fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clock_filter
parameter_list|(
name|struct
name|server
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|server
modifier|*
name|clock_select
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clock_adjust
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addserver
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|server
modifier|*
name|findserver
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_alarm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_function_decl
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_function_decl
specifier|static
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sendpkt
parameter_list|(
name|sockaddr_u
modifier|*
parameter_list|,
name|struct
name|pkt
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|input_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|l_adj_systime
parameter_list|(
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|l_step_systime
parameter_list|(
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printserver
parameter_list|(
name|struct
name|server
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|int
name|on
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WORD
name|wVersionRequested
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WSADATA
name|wsaData
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_expr_stmt
name|CALL
argument_list|(
name|ntpdate
argument_list|,
literal|"ntpdate"
argument_list|,
name|ntpdatemain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|clear_globals
parameter_list|()
block|{
comment|/*    * Debugging flag    */
name|debug
operator|=
literal|0
expr_stmt|;
name|ntp_optind
operator|=
literal|0
expr_stmt|;
comment|/*    * Initializing flag.  All async routines watch this and only do their    * thing when it is clear.    */
name|initializing
operator|=
literal|1
expr_stmt|;
comment|/*    * Alarm flag.  Set when an alarm occurs    */
name|alarm_flag
operator|=
literal|0
expr_stmt|;
comment|/*    * Simple query flag.    */
name|simple_query
operator|=
literal|0
expr_stmt|;
comment|/*    * Unprivileged port flag.    */
name|unpriv_port
operator|=
literal|0
expr_stmt|;
comment|/*    * Systemwide parameters and flags    */
name|sys_numservers
operator|=
literal|0
expr_stmt|;
comment|/* number of servers to poll */
name|sys_authenticate
operator|=
literal|0
expr_stmt|;
comment|/* true when authenticating */
name|sys_authkey
operator|=
literal|0
expr_stmt|;
comment|/* set to authentication key in use */
name|sys_authdelay
operator|=
literal|0
expr_stmt|;
comment|/* authentication delay */
name|sys_version
operator|=
name|NTP_VERSION
expr_stmt|;
comment|/* version to poll with */
comment|/*    * The current internal time    */
name|current_time
operator|=
literal|0
expr_stmt|;
comment|/*    * Counter for keeping track of completed servers    */
name|complete_servers
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|always_step
operator|=
literal|0
expr_stmt|;
name|never_step
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_function_decl
specifier|static
name|ni_namelist
modifier|*
name|getnetinfoservers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Main program.  Initialize us and loop waiting for I/O and/or  * timer expiries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAIN_ALLOWED
end_ifndef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntpdatemain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MAIN_ALLOWED */
end_comment

begin_function
name|int
name|ntpdatemain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|was_alarmed
decl_stmt|;
name|int
name|tot_recvbufs
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbuf
decl_stmt|;
name|l_fp
name|tmp
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|nfound
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
name|ni_namelist
modifier|*
name|netinfoservers
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
name|key_file
operator|=
name|key_file_storage
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
name|KEYFILE
argument_list|,
name|key_file
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings(KEYFILE) failed: %m"
argument_list|)
expr_stmt|;
name|ssl_applink
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
name|clear_globals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_lib
argument_list|()
expr_stmt|;
comment|/* sets up ipv4_works, ipv6_works */
comment|/* Check to see if we have IPv6. Otherwise default to IPv4 */
if|if
condition|(
operator|!
name|ipv6_works
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
name|errflg
operator|=
literal|0
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decode argument list 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"46a:bBde:k:o:p:qst:uv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'4'
case|:
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|c
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|sys_authkey
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|always_step
operator|++
expr_stmt|;
name|never_step
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|never_step
operator|++
expr_stmt|;
name|always_step
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
operator|||
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: encryption delay %s is unlikely\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_authdelay
operator|=
name|tmp
operator|.
name|l_uf
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
name|key_file
operator|=
name|ntp_optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|sys_version
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|c
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
name|c
operator|>
name|NTP_SHIFT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: number of samples (%d) is invalid\n"
argument_list|,
name|progname
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_samples
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|simple_query
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|syslogit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timeout %s is undecodeable\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_timeout
operator|=
operator|(
operator|(
name|LFPTOFP
argument_list|(
operator|&
name|tmp
argument_list|)
operator|*
name|TIMER_HZ
operator|)
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
expr_stmt|;
name|sys_timeout
operator|=
name|max
argument_list|(
name|sys_timeout
argument_list|,
name|MINTIMEOUT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unpriv_port
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflg
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|errflg
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-46bBdqsuv] [-a key#] [-e delay] [-k file] [-p samples] [-o version#] [-t timeo] server ...\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|||
name|simple_query
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|buf
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Logging.  Open the syslog if we have to 	 */
if|if
condition|(
name|syslogit
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|&&
operator|!
name|defined
name|SYS_CYGWIN32
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntpdate"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntpdate"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* 	 * Add servers we are going to be polling 	 */
ifdef|#
directive|ifdef
name|HAVE_NETINFO
name|netinfoservers
operator|=
name|getnetinfoservers
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|ntp_optind
operator|<
name|argc
condition|;
name|ntp_optind
operator|++
control|)
name|addserver
argument_list|(
name|argv
index|[
name|ntp_optind
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
if|if
condition|(
name|netinfoservers
condition|)
block|{
if|if
condition|(
name|netinfoservers
operator|->
name|ni_namelist_len
operator|&&
operator|*
name|netinfoservers
operator|->
name|ni_namelist_val
condition|)
block|{
name|u_int
name|servercount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|servercount
operator|<
name|netinfoservers
operator|->
name|ni_namelist_len
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Adding time server %s from NetInfo configuration."
argument_list|,
name|netinfoservers
operator|->
name|ni_namelist_val
index|[
name|servercount
index|]
argument_list|)
expr_stmt|;
name|addserver
argument_list|(
name|netinfoservers
operator|->
name|ni_namelist_val
index|[
name|servercount
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|ni_namelist_free
argument_list|(
name|netinfoservers
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|netinfoservers
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sys_numservers
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no servers can be used, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize the time of day routines and the I/O subsystem 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|init_auth
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|authreadkeys
argument_list|(
name|key_file
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no key file<%s>, exiting"
argument_list|,
name|key_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|authtrust
argument_list|(
name|sys_authkey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|sys_authkey
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"authentication key %lu unknown"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sys_authkey
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|init_io
argument_list|()
expr_stmt|;
name|init_alarm
argument_list|()
expr_stmt|;
comment|/* 	 * Set the priority. 	 */
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATT_NICE
argument_list|)
name|nice
argument_list|(
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_NICE
argument_list|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initializing
operator|=
literal|0
expr_stmt|;
name|was_alarmed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|complete_servers
operator|<
name|sys_numservers
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL_H
name|struct
name|pollfd
modifier|*
name|rdfdes
decl_stmt|;
name|rdfdes
operator|=
name|fdmask
expr_stmt|;
else|#
directive|else
name|fd_set
name|rdfdes
decl_stmt|;
name|rdfdes
operator|=
name|fdmask
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|alarm_flag
condition|)
block|{
comment|/* alarmed? */
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
name|tot_recvbufs
operator|=
name|full_recvbuffs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
if|if
condition|(
operator|!
name|was_alarmed
operator|&&
name|tot_recvbufs
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Nothing to do.	 Wait for something. 			 */
ifdef|#
directive|ifdef
name|HAVE_POLL_H
name|nfound
operator|=
name|poll
argument_list|(
name|rdfdes
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbsock
argument_list|,
name|timeout
operator|.
name|tv_sec
operator|*
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|nfound
operator|=
name|select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|rdfdes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
name|input_handler
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nfound
operator|==
name|SOCKET_ERROR
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINTR
condition|)
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_POLL_H
literal|"poll() error: %m"
else|#
directive|else
literal|"select() error: %m"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_VXWORKS
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_POLL_H
literal|"poll(): nfound = %d, error: %m"
argument_list|,
else|#
directive|else
literal|"select(): nfound = %d, error: %m"
argument_list|,
endif|#
directive|endif
name|nfound
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|alarm_flag
condition|)
block|{
comment|/* alarmed? */
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
name|tot_recvbufs
operator|=
name|full_recvbuffs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
block|}
comment|/* 		 * Out here, signals are unblocked.  Call receive 		 * procedure for each incoming packet. 		 */
name|rbuf
operator|=
name|get_full_recv_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
name|rbuf
operator|!=
name|NULL
condition|)
block|{
name|receive
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|rbuf
operator|=
name|get_full_recv_buffer
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Call timer to process any timeouts 		 */
if|if
condition|(
name|was_alarmed
condition|)
block|{
name|timer
argument_list|()
expr_stmt|;
name|was_alarmed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Go around again 		 */
block|}
comment|/* 	 * When we get here we've completed the polling of all servers. 	 * Adjust the clock, then exit. 	 */
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|timer_delete
argument_list|(
name|ntpdate_timerid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|clock_adjust
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * transmit - transmit a packet to the given server, or mark it completed.  *		This is called by the timeout routine and by the receive  *		procedure.  */
end_comment

begin_function
specifier|static
name|void
name|transmit
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|server
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"transmit(%s)\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|filter_nextpt
operator|<
name|server
operator|->
name|xmtcnt
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
comment|/* 		 * Last message to this server timed out.  Shift 		 * zeros into the filter. 		 */
name|L_CLR
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|server_data
argument_list|(
name|server
argument_list|,
literal|0
argument_list|,
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|server
operator|->
name|filter_nextpt
operator|>=
name|sys_samples
condition|)
block|{
comment|/* 		 * Got all the data we need.  Mark this guy 		 * completed and return. 		 */
name|server
operator|->
name|event_time
operator|=
literal|0
expr_stmt|;
name|complete_servers
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're here, send another message to the server.  Fill in 	 * the packet and let 'er rip. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|sys_version
argument_list|,
name|MODE_CLIENT
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|NTPDATE_PRECISION
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISTANCE
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdisp
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISP
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|htonl
argument_list|(
name|NTPDATE_REFID
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether to authenticate or not.	If so, 	 * fill in the extended part of the packet and do it. 	 * If not, just timestamp it and send it away. 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|xpkt
operator|.
name|exten
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|sys_authkey
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|authencrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|,
operator|&
name|xpkt
argument_list|,
call|(
name|int
call|)
argument_list|(
name|LEN_PKT_NOMAC
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit auth to %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_systime
argument_list|(
operator|&
operator|(
name|server
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|sendpkt
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit to %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the server timeout and transmit count 	 */
name|server
operator|->
name|event_time
operator|=
name|current_time
operator|+
name|sys_timeout
expr_stmt|;
name|server
operator|->
name|xmtcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - receive and process an incoming frame  */
end_comment

begin_function
specifier|static
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|s_fp
name|di
decl_stmt|;
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|,
name|tmp
decl_stmt|;
name|l_fp
name|org
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|is_authentic
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive(%s)\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the packet basically looks like something 	 * intended for us. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
operator|(
name|int
operator|)
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: packet length %d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
return|return;
comment|/* funny length packet */
block|}
name|rpkt
operator|=
operator|&
operator|(
name|rbufp
operator|->
name|recv_pkt
operator|)
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_SERVER
operator|&&
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_PASSIVE
operator|)
operator|||
name|rpkt
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: mode %d stratum %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * So far, so good.  See if this is from a server we know. 	 */
name|server
operator|=
name|findserver
argument_list|(
operator|&
operator|(
name|rbufp
operator|->
name|recv_srcadr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: server not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Decode the org timestamp and make sure we're getting a response 	 * to our last request. 	 */
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|org
argument_list|,
operator|&
name|server
operator|->
name|xmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: pkt.org and peer.xmt differ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check out the authenticity if we're doing that. 	 */
if|if
condition|(
operator|!
name|sys_authenticate
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|is_authentic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: rpkt keyid=%ld sys_authkey=%ld decrypt=%ld\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|sys_authkey
argument_list|,
operator|(
name|long
name|int
operator|)
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mac
operator|&&
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
argument_list|)
operator|==
name|sys_authkey
operator|&&
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
argument_list|)
argument_list|)
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: authentication %s\n"
argument_list|,
name|is_authentic
condition|?
literal|"passed"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
block|}
name|server
operator|->
name|trust
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_authentic
condition|)
name|server
operator|->
name|trust
operator||=
literal|1
expr_stmt|;
comment|/* 	 * Check for a KoD (rate limiting) response, cease and decist. 	 */
if|if
condition|(
name|LEAP_NOTINSYNC
operator|==
name|PKT_LEAP
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|&&
name|STRATUM_PKT_UNSPEC
operator|==
name|rpkt
operator|->
name|stratum
operator|&&
operator|!
name|memcmp
argument_list|(
literal|"RATE"
argument_list|,
operator|&
name|rpkt
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s rate limit response from server."
argument_list|,
name|stoa
argument_list|(
operator|&
name|rbufp
operator|->
name|recv_srcadr
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|->
name|event_time
operator|=
literal|0
expr_stmt|;
name|complete_servers
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Looks good.	Record info from the packet. 	 */
name|server
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|server
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|server
operator|->
name|precision
operator|=
name|rpkt
operator|->
name|precision
expr_stmt|;
name|server
operator|->
name|rootdelay
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|server
operator|->
name|rootdisp
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdisp
argument_list|)
expr_stmt|;
name|server
operator|->
name|refid
operator|=
name|rpkt
operator|->
name|refid
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|reftime
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|rec
argument_list|,
operator|&
name|rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|xmt
argument_list|,
operator|&
name|server
operator|->
name|org
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the server is at least somewhat sane.	If not, try 	 * again. 	 */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|rec
argument_list|)
operator|||
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
block|{
name|server
operator|->
name|event_time
operator|=
name|current_time
operator|+
name|sys_timeout
expr_stmt|;
return|return;
block|}
comment|/* 	 * Calculate the round trip delay (di) and the clock offset (ci). 	 * We use the equations (reordered from those in the spec): 	 * 	 * d = (t2 - t3) - (t1 - t0) 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 */
name|t10
operator|=
name|server
operator|->
name|org
expr_stmt|;
comment|/* pkt.xmt == t1 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
comment|/* recv_time == t0*/
name|t23
operator|=
name|rec
expr_stmt|;
comment|/* pkt.rec == t2 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
comment|/* pkt->org == t3 */
comment|/* now have (t2 - t3) and (t0 - t1).	Calculate (ci) and (di) */
comment|/* 	 * Calculate (ci) = ((t1 - t0) / 2) + ((t2 - t3) / 2) 	 * For large offsets this may prevent an overflow on '+' 	 */
name|ci
operator|=
name|t10
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|t23
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate di in t23 in full precision, then truncate 	 * to an s_fp. 	 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|di
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|t23
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"offset: %s, delay %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ci
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|di
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|+=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|server
operator|->
name|precision
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
if|if
condition|(
name|di
operator|<=
literal|0
condition|)
block|{
comment|/* value still too raunchy to use? */
name|L_CLR
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|di
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|di
operator|=
name|max
argument_list|(
name|di
argument_list|,
name|NTP_MINDIST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shift this data in, then schedule another transmit. 	 */
name|server_data
argument_list|(
name|server
argument_list|,
operator|(
name|s_fp
operator|)
name|di
argument_list|,
operator|&
name|ci
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|server
operator|->
name|filter_nextpt
operator|>=
name|sys_samples
condition|)
block|{
comment|/* 		 * Got all the data we need.  Mark this guy 		 * completed and return. 		 */
name|server
operator|->
name|event_time
operator|=
literal|0
expr_stmt|;
name|complete_servers
operator|++
expr_stmt|;
return|return;
block|}
name|server
operator|->
name|event_time
operator|=
name|current_time
operator|+
name|sys_timeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * server_data - add a sample to the server's filter registers  */
end_comment

begin_function
specifier|static
name|void
name|server_data
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|server
parameter_list|,
name|s_fp
name|d
parameter_list|,
name|l_fp
modifier|*
name|c
parameter_list|,
name|u_fp
name|e
parameter_list|)
block|{
name|u_short
name|i
decl_stmt|;
name|i
operator|=
name|server
operator|->
name|filter_nextpt
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NTP_SHIFT
condition|)
block|{
name|server
operator|->
name|filter_delay
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
name|server
operator|->
name|filter_offset
index|[
name|i
index|]
operator|=
operator|*
name|c
expr_stmt|;
name|server
operator|->
name|filter_soffset
index|[
name|i
index|]
operator|=
name|LFPTOFP
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|server
operator|->
name|filter_error
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
name|server
operator|->
name|filter_nextpt
operator|=
call|(
name|u_short
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clock_filter - determine a server's delay, dispersion and offset  */
end_comment

begin_function
specifier|static
name|void
name|clock_filter
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|server
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* 	 * Sort indices into increasing delay order 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_samples
condition|;
name|i
operator|++
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sys_samples
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|sys_samples
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|)
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now compute the dispersion, and assign values to delay and 	 * offset.	If there are no samples in the register, delay and 	 * offset go to zero and dispersion is set to the maximum. 	 */
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|server
operator|->
name|delay
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
literal|0
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|s_fp
name|d
decl_stmt|;
name|server
operator|->
name|delay
operator|=
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|offset
operator|=
name|server
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sys_samples
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
else|else
block|{
name|d
operator|=
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|-
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|PEER_MAXDISP
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
comment|/* 			 * XXX This *knows* PEER_FILTER is 1/2 			 */
name|server
operator|->
name|dispersion
operator|+=
call|(
name|u_fp
call|)
argument_list|(
name|d
argument_list|)
operator|>>
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * We're done 	 */
block|}
end_function

begin_comment
comment|/*  * clock_select - select the pick-of-the-litter clock from the samples  *		  we've got.  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|u_int
name|nlist
decl_stmt|;
name|s_fp
name|d
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|u_int
name|j
decl_stmt|;
name|u_int
name|k
decl_stmt|;
name|int
name|n
decl_stmt|;
name|s_fp
name|local_threshold
decl_stmt|;
name|struct
name|server
modifier|*
name|server_list
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|u_fp
name|server_badness
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|server
modifier|*
name|sys_server
decl_stmt|;
comment|/* 	 * This first chunk of code is supposed to go through all 	 * servers we know about to find the NTP_MAXLIST servers which 	 * are most likely to succeed.	We run through the list 	 * doing the sanity checks and trying to insert anyone who 	 * looks okay.	We are at all times aware that we should 	 * only keep samples from the top two strata and we only need 	 * NTP_MAXLIST of them. 	 */
name|nlist
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|server
operator|=
name|sys_servers
init|;
name|server
operator|!=
name|NULL
condition|;
name|server
operator|=
name|server
operator|->
name|next_server
control|)
block|{
if|if
condition|(
name|server
operator|->
name|delay
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: no data\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* no data */
block|}
if|if
condition|(
name|server
operator|->
name|stratum
operator|>
name|NTP_INFIN
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: strata too high\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* stratum no good */
block|}
if|if
condition|(
name|server
operator|->
name|delay
operator|>
name|NTP_MAXWGT
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: server too far away\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* too far away */
block|}
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: Leap not in sync\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* he's in trouble */
block|}
if|if
condition|(
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: server is very broken\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* very broken host */
block|}
if|if
condition|(
operator|(
name|server
operator|->
name|org
operator|.
name|l_ui
operator|-
name|server
operator|->
name|reftime
operator|.
name|l_ui
operator|)
operator|>=
name|NTP_MAXAGE
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: Server has gone too long without sync\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* too long without sync */
block|}
if|if
condition|(
name|server
operator|->
name|trust
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%s: Server dropped: Server is untrusted\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * This one seems sane.  Find where he belongs 		 * on the list. 		 */
name|d
operator|=
name|server
operator|->
name|dispersion
operator|+
name|server
operator|->
name|dispersion
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server
operator|->
name|stratum
operator|<=
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|stratum
operator|<
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
if|if
condition|(
name|d
operator|<
operator|(
name|s_fp
operator|)
name|server_badness
index|[
name|i
index|]
condition|)
break|break;
block|}
comment|/* 		 * If i points past the end of the list, this 		 * guy is a loser, else stick him in. 		 */
if|if
condition|(
name|i
operator|>=
name|NTP_MAXLIST
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|nlist
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|j
operator|<
name|NTP_MAXLIST
condition|)
block|{
name|server_list
index|[
name|j
index|]
operator|=
name|server_list
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|server_badness
index|[
name|j
index|]
operator|=
name|server_badness
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|server_list
index|[
name|i
index|]
operator|=
name|server
expr_stmt|;
name|server_badness
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|nlist
operator|<
name|NTP_MAXLIST
condition|)
name|nlist
operator|++
expr_stmt|;
block|}
comment|/* 	 * Got the five-or-less best.	 Cut the list where the number of 	 * strata exceeds two. 	 */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|>
name|server_list
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|stratum
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
literal|2
operator|==
name|count
condition|)
block|{
name|nlist
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Whew!  What we should have by now is 0 to 5 candidates for 	 * the job of syncing us.  If we have none, we're out of luck. 	 * If we have one, he's a winner.  If we have more, do falseticker 	 * detection. 	 */
if|if
condition|(
literal|0
operator|==
name|nlist
condition|)
name|sys_server
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
operator|==
name|nlist
condition|)
block|{
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Re-sort by stratum, bdelay estimate quality and 		 * server.delay. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|stratum
condition|)
comment|/* already sorted by stratum */
break|break;
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|delay
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|delay
condition|)
continue|continue;
name|server
operator|=
name|server_list
index|[
name|i
index|]
expr_stmt|;
name|server_list
index|[
name|i
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|server_list
index|[
name|j
index|]
operator|=
name|server
expr_stmt|;
block|}
comment|/* 		 * Calculate the fixed part of the dispersion limit 		 */
name|local_threshold
operator|=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
comment|/* 		 * Now drop samples until we're down to one. 		 */
while|while
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nlist
condition|;
name|k
operator|++
control|)
block|{
name|server_badness
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|k
condition|)
comment|/* with self? */
continue|continue;
name|d
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|soffset
operator|-
name|server_list
index|[
name|k
index|]
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
comment|/* abs value */
name|d
operator|=
operator|-
name|d
expr_stmt|;
comment|/* 					 * XXX This code *knows* that 					 * NTP_SELECT is 3/4 					 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|>>
literal|2
operator|)
expr_stmt|;
name|server_badness
index|[
name|k
index|]
operator|+=
name|d
expr_stmt|;
block|}
block|}
comment|/* 			 * We now have an array of nlist badness 			 * coefficients.	Find the badest.  Find 			 * the minimum precision while we're at 			 * it. 			 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|server_list
index|[
literal|0
index|]
operator|->
name|precision
expr_stmt|;
empty_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_badness
index|[
name|j
index|]
operator|>=
name|server_badness
index|[
name|i
index|]
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|server_list
index|[
name|j
index|]
operator|->
name|precision
condition|)
name|n
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|precision
expr_stmt|;
block|}
comment|/* 			 * i is the index of the server with the worst 			 * dispersion.	If his dispersion is less than 			 * the threshold, stop now, else delete him and 			 * continue around again. 			 */
if|if
condition|(
operator|(
name|s_fp
operator|)
name|server_badness
index|[
name|i
index|]
operator|<
operator|(
name|local_threshold
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
name|n
operator|)
operator|)
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|server_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 		 * What remains is a list of less than 5 servers.  Take 		 * the best. 		 */
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * That's it.  Return our server. 	 */
return|return
name|sys_server
return|;
block|}
end_function

begin_comment
comment|/*  * clock_adjust - process what we've received, and adjust the time  *		 if we got anything decent.  */
end_comment

begin_function
specifier|static
name|int
name|clock_adjust
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|server
modifier|*
name|sp
decl_stmt|,
modifier|*
name|server
decl_stmt|;
name|s_fp
name|absoffset
decl_stmt|;
name|int
name|dostep
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|sys_servers
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next_server
control|)
name|clock_filter
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|server
operator|=
name|clock_select
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
operator|||
name|simple_query
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|sys_servers
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next_server
control|)
name|printserver
argument_list|(
name|sp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no server suitable for synchronization found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|always_step
condition|)
block|{
name|dostep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|never_step
condition|)
block|{
name|dostep
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|absoffset
operator|=
name|server
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|absoffset
operator|<
literal|0
condition|)
name|absoffset
operator|=
operator|-
name|absoffset
expr_stmt|;
name|dostep
operator|=
operator|(
name|absoffset
operator|>=
name|NTPDATE_THRESHOLD
operator|||
name|absoffset
operator|<
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dostep
condition|)
block|{
if|if
condition|(
name|simple_query
operator|||
name|debug
operator|||
name|l_step_systime
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"step time server %s offset %s sec"
argument_list|,
name|stoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|simple_query
operator|||
name|l_adj_systime
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"adjust time server %s offset %s sec"
argument_list|,
name|stoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* The NT SetSystemTimeAdjustment() call achieves slewing by 		 * changing the clock frequency. This means that we cannot specify 		 * it to slew the clock by a definite amount and then stop like 		 * the Unix adjtime() routine. We can technically adjust the clock 		 * frequency, have ntpdate sleep for a while, and then wake 		 * up and reset the clock frequency, but this might cause some 		 * grief if the user attempts to run ntpd immediately after 		 * ntpdate and the socket is in use. 		 */
name|printf
argument_list|(
literal|"\nThe -b option is required by ntpdate on Windows NT platforms\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * is_unreachable - check to see if we have a route to given destination  *		    (non-blocking).  */
end_comment

begin_function
specifier|static
name|int
name|is_reachable
parameter_list|(
name|sockaddr_u
modifier|*
name|dst
parameter_list|)
block|{
name|SOCKET
name|sockfd
decl_stmt|;
name|sockfd
operator|=
name|socket
argument_list|(
name|AF
argument_list|(
name|dst
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|&
name|dst
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
block|{
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE: merge BIG slew into adj_systime in lib/systime.c */
end_comment

begin_comment
comment|/*  * addserver - determine a server's address and allocate a new structure  *		for it.  */
end_comment

begin_function
specifier|static
name|void
name|addserver
parameter_list|(
name|char
modifier|*
name|serv
parameter_list|)
block|{
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
comment|/* Address infos structure to store result of getaddrinfo */
name|struct
name|addrinfo
modifier|*
name|addrResult
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
comment|/* Address infos structure to store hints for getaddrinfo */
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* Error variable for getaddrinfo */
name|int
name|error
decl_stmt|;
comment|/* Service name */
name|char
name|service
index|[
literal|5
index|]
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|strlcpy
argument_list|(
name|service
argument_list|,
literal|"ntp"
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get host address. Looking for UDP datagram connection. */
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_fam_templ
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Looking for host %s and service %s\n"
argument_list|,
name|serv
argument_list|,
name|service
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|getaddrinfo
argument_list|(
name|serv
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|addrResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Conduct more refined error analysis */
if|if
condition|(
name|error
operator|==
name|EAI_FAIL
operator|||
name|error
operator|==
name|EAI_AGAIN
condition|)
block|{
comment|/* Name server is unusable. Exit after failing on the 			   first server, in order to shorten the timeout caused 			   by waiting for resolution of several servers */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exiting, name server cannot be used: %s (%d)"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"name server cannot be used: %s (%d)"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error resolving %s: %s (%d)\n"
argument_list|,
name|serv
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't find host %s: %s (%d)"
argument_list|,
name|serv
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|addrResult
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|addrResult
operator|->
name|ai_addr
argument_list|,
name|addrResult
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"host found : %s\n"
argument_list|,
name|stohost
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We must get all returned server in case the first one fails */
for|for
control|(
name|ptr
operator|=
name|addrResult
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|ai_next
control|)
block|{
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ptr
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|ptr
operator|->
name|ai_addr
argument_list|,
name|ptr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_reachable
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
block|{
name|server
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|,
name|ptr
operator|->
name|ai_addr
argument_list|,
name|ptr
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|server
operator|->
name|event_time
operator|=
operator|++
name|sys_numservers
expr_stmt|;
if|if
condition|(
name|sys_servers
operator|==
name|NULL
condition|)
name|sys_servers
operator|=
name|server
expr_stmt|;
else|else
block|{
name|struct
name|server
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|sys_servers
init|;
name|sp
operator|->
name|next_server
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next_server
control|)
comment|/* empty */
empty_stmt|;
name|sp
operator|->
name|next_server
operator|=
name|server
expr_stmt|;
block|}
block|}
block|}
name|freeaddrinfo
argument_list|(
name|addrResult
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findserver - find a server in the list given its address  * ***(For now it isn't totally AF-Independant, to check later..)  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|findserver
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|struct
name|server
modifier|*
name|mc_server
decl_stmt|;
name|mc_server
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|SRCPORT
argument_list|(
name|addr
argument_list|)
operator|!=
name|NTP_PORT
condition|)
return|return
literal|0
return|;
for|for
control|(
name|server
operator|=
name|sys_servers
init|;
name|server
operator|!=
name|NULL
condition|;
name|server
operator|=
name|server
operator|->
name|next_server
control|)
block|{
if|if
condition|(
name|SOCK_EQ
argument_list|(
name|addr
argument_list|,
operator|&
name|server
operator|->
name|srcadr
argument_list|)
condition|)
return|return
name|server
return|;
if|if
condition|(
name|AF
argument_list|(
name|addr
argument_list|)
operator|==
name|AF
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MCAST
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
condition|)
name|mc_server
operator|=
name|server
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mc_server
operator|!=
name|NULL
condition|)
block|{
name|struct
name|server
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|mc_server
operator|->
name|event_time
operator|!=
literal|0
condition|)
block|{
name|mc_server
operator|->
name|event_time
operator|=
literal|0
expr_stmt|;
name|complete_servers
operator|++
expr_stmt|;
block|}
name|server
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|server
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|->
name|srcadr
operator|=
operator|*
name|addr
expr_stmt|;
name|server
operator|->
name|event_time
operator|=
operator|++
name|sys_numservers
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|sys_servers
init|;
name|sp
operator|->
name|next_server
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next_server
control|)
comment|/* empty */
empty_stmt|;
name|sp
operator|->
name|next_server
operator|=
name|server
expr_stmt|;
name|transmit
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * timer - process a timer interrupt  */
end_comment

begin_function
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|server
modifier|*
name|server
decl_stmt|;
comment|/* 	 * Bump the current idea of the time 	 */
name|current_time
operator|++
expr_stmt|;
comment|/* 	 * Search through the server list looking for guys 	 * who's event timers have expired.  Give these to 	 * the transmit routine. 	 */
for|for
control|(
name|server
operator|=
name|sys_servers
init|;
name|server
operator|!=
name|NULL
condition|;
name|server
operator|=
name|server
operator|->
name|next_server
control|)
block|{
if|if
condition|(
name|server
operator|->
name|event_time
operator|!=
literal|0
operator|&&
name|server
operator|->
name|event_time
operator|<=
name|current_time
condition|)
name|transmit
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The code duplication in the following subroutine sucks, but  * we need to appease ansi2knr.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * alarming - record the occurance of an alarm interrupt  */
end_comment

begin_function
specifier|static
name|RETSIGTYPE
name|alarming
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|alarm_flag
operator|++
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYS_WINNT follows */
end_comment

begin_function
name|void
name|CALLBACK
name|alarming
parameter_list|(
name|UINT
name|uTimerID
parameter_list|,
name|UINT
name|uMsg
parameter_list|,
name|DWORD
name|dwUser
parameter_list|,
name|DWORD
name|dw1
parameter_list|,
name|DWORD
name|dw2
parameter_list|)
block|{
name|UNUSED_ARG
argument_list|(
name|uTimerID
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|uMsg
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|dwUser
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|dw1
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|dw2
argument_list|)
expr_stmt|;
name|alarm_flag
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|callTimeEndPeriod
parameter_list|(
name|void
parameter_list|)
block|{
name|timeEndPeriod
argument_list|(
name|wTimerRes
argument_list|)
expr_stmt|;
name|wTimerRes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * init_alarm - set up the timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|init_alarm
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
name|struct
name|itimerspec
name|its
decl_stmt|;
else|#
directive|else
name|struct
name|itimerval
name|itv
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SYS_WINNT follows */
name|TIMECAPS
name|tc
decl_stmt|;
name|UINT
name|wTimerID
decl_stmt|;
name|HANDLE
name|hToken
decl_stmt|;
name|TOKEN_PRIVILEGES
name|tkp
decl_stmt|;
name|DWORD
name|dwUser
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|alarm_flag
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
ifdef|#
directive|ifdef
name|HAVE_TIMER_CREATE
name|alarm_flag
operator|=
literal|0
expr_stmt|;
comment|/* this code was put in as setitimer() is non existant this us the 	 * POSIX "equivalents" setup - casey 	 */
comment|/* ntpdate_timerid is global - so we can kill timer later */
if|if
condition|(
name|timer_create
argument_list|(
name|CLOCK_REALTIME
argument_list|,
name|NULL
argument_list|,
operator|&
name|ntpdate_timerid
argument_list|)
operator|==
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|ERROR
else|#
directive|else
operator|-
literal|1
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"init_alarm(): timer_create (...) FAILED\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*	TIMER_HZ = (5) 	 * Set up the alarm interrupt.	The first comes 1/(2*TIMER_HZ) 	 * seconds from now and they continue on every 1/TIMER_HZ seconds. 	 */
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|its
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|its
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|its
operator|.
name|it_interval
operator|.
name|tv_nsec
operator|=
literal|1000000000
operator|/
name|TIMER_HZ
expr_stmt|;
name|its
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
literal|1000000000
operator|/
operator|(
name|TIMER_HZ
operator|<<
literal|1
operator|)
expr_stmt|;
name|timer_settime
argument_list|(
name|ntpdate_timerid
argument_list|,
literal|0
comment|/* !TIMER_ABSTIME */
argument_list|,
operator|&
name|its
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !HAVE_TIMER_CREATE follows */
comment|/* 	 * Set up the alarm interrupt.	The first comes 1/(2*TIMER_HZ) 	 * seconds from now and they continue on every 1/TIMER_HZ seconds. 	 */
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
name|TIMER_HZ
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
operator|(
name|TIMER_HZ
operator|<<
literal|1
operator|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVE_TIMER_CREATE */
else|#
directive|else
comment|/* SYS_WINNT follows */
name|_tzset
argument_list|()
expr_stmt|;
comment|/* 	 * Get privileges needed for fiddling with the clock 	 */
comment|/* get the current process token handle */
if|if
condition|(
operator|!
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_ADJUST_PRIVILEGES
operator||
name|TOKEN_QUERY
argument_list|,
operator|&
name|hToken
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"OpenProcessToken failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get the LUID for system-time privilege. */
name|LookupPrivilegeValue
argument_list|(
name|NULL
argument_list|,
name|SE_SYSTEMTIME_NAME
argument_list|,
operator|&
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Luid
argument_list|)
expr_stmt|;
name|tkp
operator|.
name|PrivilegeCount
operator|=
literal|1
expr_stmt|;
comment|/* one privilege to set */
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|=
name|SE_PRIVILEGE_ENABLED
expr_stmt|;
comment|/* get set-time privilege for this process. */
name|AdjustTokenPrivileges
argument_list|(
name|hToken
argument_list|,
name|FALSE
argument_list|,
operator|&
name|tkp
argument_list|,
literal|0
argument_list|,
operator|(
name|PTOKEN_PRIVILEGES
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot test return value of AdjustTokenPrivileges. */
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"AdjustTokenPrivileges failed: %m"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up timer interrupts for every 2**EVENT_TIMEOUT seconds 	 * Under Win/NT, expiry of timer interval leads to invocation 	 * of a callback function (on a different thread) rather than 	 * generating an alarm signal 	 */
comment|/* determine max and min resolution supported */
if|if
condition|(
name|timeGetDevCaps
argument_list|(
operator|&
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|TIMECAPS
argument_list|)
argument_list|)
operator|!=
name|TIMERR_NOERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"timeGetDevCaps failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wTimerRes
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|tc
operator|.
name|wPeriodMin
argument_list|,
name|TARGET_RESOLUTION
argument_list|)
argument_list|,
name|tc
operator|.
name|wPeriodMax
argument_list|)
expr_stmt|;
comment|/* establish the minimum timer resolution that we'll use */
name|timeBeginPeriod
argument_list|(
name|wTimerRes
argument_list|)
expr_stmt|;
name|atexit
argument_list|(
name|callTimeEndPeriod
argument_list|)
expr_stmt|;
comment|/* start the timer event */
name|wTimerID
operator|=
name|timeSetEvent
argument_list|(
call|(
name|UINT
call|)
argument_list|(
literal|1000
operator|/
name|TIMER_HZ
argument_list|)
argument_list|,
comment|/* Delay */
name|wTimerRes
argument_list|,
comment|/* Resolution */
operator|(
name|LPTIMECALLBACK
operator|)
name|alarming
argument_list|,
comment|/* Callback function */
operator|(
name|DWORD
operator|)
name|dwUser
argument_list|,
comment|/* User data */
name|TIME_PERIODIC
argument_list|)
expr_stmt|;
comment|/* Event type (periodic) */
if|if
condition|(
name|wTimerID
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"timeSetEvent failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
end_function

begin_comment
comment|/*  * We do asynchronous input using the SIGIO facility.  A number of  * recvbuf buffers are preallocated for input.	In the signal  * handler we poll to see if the socket is ready and read the  * packets from it into the recvbuf's along with a time stamp and  * an indication of the source host and the interface it was received  * through.  This allows us to get as accurate receive time stamps  * as possible independent of other processing going on.  *  * We allocate a number of recvbufs equal to the number of servers  * plus 2.	This should be plenty.  */
end_comment

begin_comment
comment|/*  * init_io - initialize I/O data and open socket  */
end_comment

begin_function
specifier|static
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|,
modifier|*
name|ressave
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|char
name|service
index|[
literal|5
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|optval
init|=
literal|1
decl_stmt|;
name|int
name|check_ntp_port_in_use
init|=
operator|!
name|debug
operator|&&
operator|!
name|simple_query
operator|&&
operator|!
name|unpriv_port
decl_stmt|;
comment|/* 	 * Init buffer free list and stat counters 	 */
name|init_recvbuff
argument_list|(
name|sys_numservers
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Open the socket 	 */
name|strlcpy
argument_list|(
name|service
argument_list|,
literal|"ntp"
argument_list|,
sizeof|sizeof
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Init hints addrinfo structure 	 */
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_fam_templ
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
name|service
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getaddrinfo() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
name|check_ntp_port_in_use
operator|&&
name|ntp_port_inuse
argument_list|(
name|AF_INET
argument_list|,
name|NTP_PORT
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"the NTP socket is in use, exiting: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Remember the address of the addrinfo structure chain */
name|ressave
operator|=
name|res
expr_stmt|;
comment|/* 	 * For each structure returned, open and bind socket 	 */
for|for
control|(
name|nbsock
operator|=
literal|0
init|;
operator|(
name|nbsock
operator|<
name|MAX_AF
operator|)
operator|&&
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* create a datagram (UDP) socket */
name|fd
index|[
name|nbsock
index|]
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
index|[
name|nbsock
index|]
operator|==
name|SOCKET_ERROR
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|errno
operator|==
name|EPROTONOSUPPORT
operator|||
name|errno
operator|==
name|EAFNOSUPPORT
operator|||
name|errno
operator|==
name|EPFNOSUPPORT
condition|)
else|#
directive|else
name|int
name|err
init|=
name|WSAGetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|WSAEPROTONOSUPPORT
operator|||
name|err
operator|==
name|WSAEAFNOSUPPORT
operator|||
name|err
operator|==
name|WSAEPFNOSUPPORT
condition|)
endif|#
directive|endif
continue|continue;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* set socket to reuse address */
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt() SO_REUSEADDR failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
comment|/* Restricts AF_INET6 socket to IPv6 communications (see RFC 2553bis-03) */
if|if
condition|(
name|res
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt() IPV6_V6ONLY failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
endif|#
directive|endif
comment|/* Remember the socket family in fd_family structure */
name|fd_family
index|[
name|nbsock
index|]
operator|=
name|res
operator|->
name|ai_family
expr_stmt|;
comment|/* 		 * bind the socket to the NTP port 		 */
if|if
condition|(
name|check_ntp_port_in_use
condition|)
block|{
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|res
operator|->
name|ai_addrlen
operator|<=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bind
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
operator|&
name|addr
operator|.
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|EADDRINUSE
operator|==
name|socket_errno
argument_list|()
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"the NTP socket is in use, exiting"
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind() fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_POLL_H
name|fdmask
index|[
name|nbsock
index|]
operator|.
name|fd
operator|=
name|fd
index|[
name|nbsock
index|]
expr_stmt|;
name|fdmask
index|[
name|nbsock
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
else|#
directive|else
name|FD_SET
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxfd
operator|<
name|fd
index|[
name|nbsock
index|]
operator|+
literal|1
condition|)
block|{
name|maxfd
operator|=
name|fd
index|[
name|nbsock
index|]
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * set non-blocking, 		 */
ifndef|#
directive|ifndef
name|SYS_WINNT
ifdef|#
directive|ifdef
name|SYS_VXWORKS
block|{
name|int
name|on
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|==
name|ERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not SYS_VXWORKS */
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* not O_NONBLOCK */
if|#
directive|if
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY|FASYNC) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
comment|/* FNDELAY */
include|#
directive|include
file|"Bletch: Need non blocking I/O"
endif|#
directive|endif
comment|/* FNDELAY */
endif|#
directive|endif
comment|/* not O_NONBLOCK */
endif|#
directive|endif
comment|/* SYS_VXWORKS */
else|#
directive|else
comment|/* SYS_WINNT */
if|if
condition|(
name|ioctlsocket
argument_list|(
name|fd
index|[
name|nbsock
index|]
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctlsocket(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|nbsock
operator|++
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ressave
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination  */
end_comment

begin_function
specifier|static
name|void
name|sendpkt
parameter_list|(
name|sockaddr_u
modifier|*
name|dest
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|SOCKET
name|sock
init|=
name|INVALID_SOCKET
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|DWORD
name|err
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* Find a local family compatible socket to send ntp packet to ntp server */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MAX_AF
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AF
argument_list|(
name|dest
argument_list|)
operator|==
name|fd_family
index|[
name|i
index|]
condition|)
block|{
name|sock
operator|=
name|fd
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|INVALID_SOCKET
operator|==
name|sock
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find family compatible socket to send ntp packet"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|cc
operator|=
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
name|SOCKLEN
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOCKET_ERROR
operator|==
name|cc
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
condition|)
else|#
directive|else
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|err
operator|!=
name|WSAENOBUFS
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|stohost
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * input_handler - receive packets asynchronously  */
end_comment

begin_function
name|void
name|input_handler
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
name|struct
name|sock_timeval
name|tvzero
decl_stmt|;
name|GETSOCKNAME_SOCKLEN_TYPE
name|fromlen
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POLL_H
name|struct
name|pollfd
name|fds
index|[
name|MAX_AF
index|]
decl_stmt|;
else|#
directive|else
name|fd_set
name|fds
decl_stmt|;
endif|#
directive|endif
name|SOCKET
name|fdc
init|=
literal|0
decl_stmt|;
comment|/* 	 * Do a poll to see if we have data 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_POLL_H
name|memcpy
argument_list|(
name|fds
argument_list|,
name|fdmask
argument_list|,
sizeof|sizeof
argument_list|(
name|fdmask
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|poll
argument_list|(
name|fds
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|nbsock
argument_list|,
name|tvzero
operator|.
name|tv_sec
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 		 * Determine which socket received data 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbsock
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fds
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|POLLIN
condition|)
block|{
name|fdc
operator|=
name|fd
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
name|fds
operator|=
name|fdmask
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|maxfd
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 		 * Determine which socket received data 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbsock
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
index|[
name|i
index|]
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|fdc
operator|=
name|fd
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * If nothing to do, just return.  If an error occurred, 		 * complain and return.  If we've got some, freeze a 		 * timestamp. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_POLL_H
literal|"poll() error: %m"
else|#
directive|else
literal|"select() error: %m"
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 		 * Get a buffer and read the frame.  If we 		 * haven't got a buffer, or this is received 		 * on the wild card socket, just dump the packet. 		 */
if|if
condition|(
name|initializing
operator|||
name|free_recvbuffs
argument_list|()
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|read
argument_list|(
name|fdc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NT's _read does not operate on nonblocking sockets 			 * either recvfrom or ReadFile() has to be used here. 			 * ReadFile is used in [ntpd]ntp_intres() and ntpdc, 			 * just to be different use recvfrom() here 			 */
name|recvfrom
argument_list|(
name|fdc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
continue|continue;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_srcadr
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fdc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_pkt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Got one.  Mark how and when it got here, 		 * put it on the full list. 		 */
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
name|SYS_WINNT
operator|&&
operator|!
name|defined
name|SYS_CYGWIN32
end_if

begin_comment
comment|/*  * adj_systime - do a big long slew of the system time  */
end_comment

begin_function
specifier|static
name|int
name|l_adj_systime
parameter_list|(
name|l_fp
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|timeval
name|adjtv
decl_stmt|,
name|oadjtv
decl_stmt|;
name|int
name|isneg
init|=
literal|0
decl_stmt|;
name|l_fp
name|offset
decl_stmt|;
ifndef|#
directive|ifndef
name|STEP_SLEW
name|l_fp
name|overshoot
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Take the absolute value of the offset 	 */
name|offset
operator|=
operator|*
name|ts
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|offset
argument_list|)
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|L_NEG
argument_list|(
operator|&
name|offset
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|STEP_SLEW
comment|/* 	 * Calculate the overshoot.  XXX N.B. This code *knows* 	 * ADJ_OVERSHOOT is 1/2. 	 */
name|overshoot
operator|=
name|offset
expr_stmt|;
name|L_RSHIFTU
argument_list|(
operator|&
name|overshoot
argument_list|)
expr_stmt|;
if|if
condition|(
name|overshoot
operator|.
name|l_ui
operator|!=
literal|0
operator|||
operator|(
name|overshoot
operator|.
name|l_uf
operator|>
name|ADJ_MAXOVERSHOOT
operator|)
condition|)
block|{
name|overshoot
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|overshoot
operator|.
name|l_uf
operator|=
name|ADJ_MAXOVERSHOOT
expr_stmt|;
block|}
name|L_ADD
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|overshoot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TSTOTV
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|adjtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|isneg
condition|)
block|{
name|adjtv
operator|.
name|tv_sec
operator|=
operator|-
name|adjtv
operator|.
name|tv_sec
expr_stmt|;
name|adjtv
operator|.
name|tv_usec
operator|=
operator|-
name|adjtv
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|adjtv
operator|.
name|tv_usec
operator|!=
literal|0
operator|&&
operator|!
name|debug
condition|)
block|{
if|if
condition|(
name|adjtime
argument_list|(
operator|&
name|adjtv
argument_list|,
operator|&
name|oadjtv
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't adjust the time of day: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * This fuction is not the same as lib/systime step_systime!!!  */
end_comment

begin_function
specifier|static
name|int
name|l_step_systime
parameter_list|(
name|l_fp
modifier|*
name|ts
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
ifdef|#
directive|ifdef
name|SLEWALWAYS
ifdef|#
directive|ifdef
name|STEP_SLEW
name|l_fp
name|ftmp
decl_stmt|;
name|int
name|isneg
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
comment|/* 	 * Take the absolute value of the offset 	 */
name|ftmp
operator|=
operator|*
name|ts
expr_stmt|;
if|if
condition|(
name|L_ISNEG
argument_list|(
operator|&
name|ftmp
argument_list|)
condition|)
block|{
name|L_NEG
argument_list|(
operator|&
name|ftmp
argument_list|)
expr_stmt|;
name|isneg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|isneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ftmp
operator|.
name|l_ui
operator|>=
literal|3
condition|)
block|{
comment|/* Step it and slew - we might win */
name|LFPTOD
argument_list|(
name|ts
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|n
operator|=
name|step_systime
argument_list|(
name|dtemp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|n
return|;
if|if
condition|(
name|isneg
condition|)
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|ts
operator|->
name|l_ui
operator|=
operator|~
literal|0
expr_stmt|;
block|}
comment|/* 	 * Just add adjustment into the current offset.  The update 	 * routine will take care of bringing the system clock into 	 * line. 	 */
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|FORCE_NTPDATE_STEP
name|LFPTOD
argument_list|(
name|ts
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
return|return
name|step_systime
argument_list|(
name|dtemp
argument_list|)
return|;
else|#
directive|else
name|l_adj_systime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
else|#
directive|else
comment|/* SLEWALWAYS */
if|if
condition|(
name|debug
condition|)
return|return
literal|1
return|;
name|LFPTOD
argument_list|(
name|ts
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
return|return
name|step_systime
argument_list|(
name|dtemp
argument_list|)
return|;
endif|#
directive|endif
comment|/* SLEWALWAYS */
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE printserver similar in ntptrace.c, ntpdate.c */
end_comment

begin_comment
comment|/*  * printserver - print detail information for a server  */
end_comment

begin_function
specifier|static
name|void
name|printserver
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|pp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|junk
index|[
literal|5
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server %s, stratum %d, offset %s, delay %s\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
operator|(
name|s_fp
operator|)
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server %s, port %d\n"
argument_list|,
name|stoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|pp
operator|->
name|srcadr
operator|)
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"stratum %d, precision %d, leap %c%c, trust %03o\n"
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|pp
operator|->
name|precision
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x2
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x1
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|trust
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|stratum
operator|==
literal|1
condition|)
block|{
name|junk
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|memmove
argument_list|(
name|junk
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|str
operator|=
name|junk
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|stoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"refid [%s], delay %s, dispersion %s\n"
argument_list|,
name|str
argument_list|,
name|fptoa
argument_list|(
operator|(
name|s_fp
operator|)
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmitted %d, in filter %d\n"
argument_list|,
name|pp
operator|->
name|xmtcnt
argument_list|,
name|pp
operator|->
name|filter_nextpt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"reference time:    %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|reftime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"originate timestamp: %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|org
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmit timestamp:  %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|xmt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter delay: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|filter_delay
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|NTP_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter offset:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEER_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|filter_offset
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|PEER_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %s, dispersion %s\n"
argument_list|,
name|fptoa
argument_list|(
operator|(
name|s_fp
operator|)
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"offset %s\n\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_function
specifier|static
name|ni_namelist
modifier|*
name|getnetinfoservers
parameter_list|(
name|void
parameter_list|)
block|{
name|ni_status
name|status
decl_stmt|;
name|void
modifier|*
name|domain
decl_stmt|;
name|ni_id
name|confdir
decl_stmt|;
name|ni_namelist
modifier|*
name|namelist
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ni_namelist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Find a time server in NetInfo */
if|if
condition|(
operator|(
name|status
operator|=
name|ni_open
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|,
operator|&
name|domain
argument_list|)
operator|)
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|status
operator|=
name|ni_pathsearch
argument_list|(
name|domain
argument_list|,
operator|&
name|confdir
argument_list|,
name|NETINFO_CONFIG_DIR
argument_list|)
operator|==
name|NI_NODIR
condition|)
block|{
name|void
modifier|*
name|next_domain
decl_stmt|;
if|if
condition|(
name|ni_open
argument_list|(
name|domain
argument_list|,
literal|".."
argument_list|,
operator|&
name|next_domain
argument_list|)
operator|!=
name|NI_OK
condition|)
break|break;
name|ni_free
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|=
name|next_domain
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|NI_OK
condition|)
return|return
name|NULL
return|;
name|NI_INIT
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni_lookupprop
argument_list|(
name|domain
argument_list|,
operator|&
name|confdir
argument_list|,
literal|"server"
argument_list|,
name|namelist
argument_list|)
operator|!=
name|NI_OK
condition|)
block|{
name|ni_namelist_free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|namelist
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function
name|isc_boolean_t
name|ntp_port_inuse
parameter_list|(
name|int
name|af
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
comment|/* 	 * Check if NTP socket is already in use on this system 	 * This is only for Windows Systems, as they tend not to fail on the real bind() below 	 */
name|SOCKET
name|checksocket
decl_stmt|;
name|struct
name|sockaddr_in
name|checkservice
decl_stmt|;
name|checksocket
operator|=
name|socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksocket
operator|==
name|INVALID_SOCKET
condition|)
block|{
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|checkservice
operator|.
name|sin_family
operator|=
operator|(
name|short
operator|)
name|AF_INET
expr_stmt|;
name|checkservice
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_LOOPBACK
expr_stmt|;
name|checkservice
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|checksocket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|checkservice
argument_list|,
sizeof|sizeof
argument_list|(
name|checkservice
argument_list|)
argument_list|)
operator|==
name|SOCKET_ERROR
condition|)
block|{
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEADDRINUSE
condition|)
block|{
name|closesocket
argument_list|(
name|checksocket
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
block|}
name|closesocket
argument_list|(
name|checksocket
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

