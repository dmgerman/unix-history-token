begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntptimeset - get/set the time via ntp  *  * GOAL:  * The goal of ntptime is to set the current time on system startup  * to the best possible time using the network very wisely. It is assumed  * that after a resonable time has been sett then ntp daemon will  * maintain it.  *  * PROBLEM DOMAIN:  * We have three sets of issues related to acheiving the goal. The first  * issue is using the network when normal traffic is happening or when  * the entire network world is recovering from a campus wide power failure  * and is restarting. The second issue is the class of machine whether it  * is a user's office workstation being handled by an uneducated user or  * a server computer being handled by a trained operations staff. The third  * issue is whether the ratio of people to computers and whether the   * environment is stable and viable or not.  *  * NETWORK USAGE:  * The first issue of using the network wisely is a question of whether  * the network load and time server load and state are normal. If things  * are normal ntptime can do what ntpdate does of sending out 4 packets  * quickly to each server (new transmit done with each ack). However  * if network or time load is high then this scheme will simply contribute  * to problems. Given we have minimal state, we simply weight lost packets  * significantly and make sure we throttle output as much as possible  * without performance lost for quick startups.  *  * TRAINING AND KNOWLEDGE:  * The second issue of uneducated user of a office workstation versus a  * trained operation staff of a server machine translates into simply an  * issue of untrained and trained users.  *   * The training issue implies that for the sake of the users involved in the  * handling of their office workstation, problems and options should be  * communicated simply and effectively and not in terse expert related  * descriptions without possible options to be taken. The operator's training  * and education enables them to deal with either type of communication and  * control.  *  * AUTOMATION AND MANUAL CONTROL:  * The last issue boils down to a design problem. If the design tends to go  * into a manual mode when the environment is non-viable then one person  * handling many computers all at the same time will be heavily impacted. On  * the other hand, if the design tends to be automatic and does not indicate  * a way for the user to take over control then the computer will be  * unavailable for the user until the proble is resolved by someone else or  * the user.  *  * NOTE: Please do not have this program print out every minute some line,  *       of output. If this happens and the environment is in trouble then  *       many pages of paper on many different machines will be filled up.  *       Save some tress in your lifetime.  *   * CONCLUSION:  * The behavior of the program derived from these three issues should be  * that during normal situations it quickly sets the time and allow the  * system to startup.  *  * However during abnormal conditions as detected by unresponsive servers,  * out-of-sync or bad responses and other detections, it should print out  * a simple but clear message and continue in a mellow way to get the best  * possible time. It may never get the time and if so should also indicate  * this.  *  * Rudy Nedved  * 18-May-1993  *  ****************************************************************  *  * Much of the above is confusing or no longer relevant.  For example,  * it is rare these days for a machine's console to be a printing terminal,  * so the comment about saving trees doesn't mean much.  Nonetheless,  * the basic principles still stand:  *  * - Work automatically, without human control or intervention.  To  *   this end, we use the same configuration file as ntpd itself, so  *   you don't have to specify servers or other information on the  *   command line.  We also recognize that sometimes we won't be able  *   to contact any servers, and give up in that event instead of  *   hanging forever.  *  * - Behave in a sane way, both internally and externally, even in the  *   face of insane conditions.  That means we back off quickly when  *   we don't hear a response, to avoid network congestion.  Like  *   ntpd, we verify responses from several servers before accepting  *   the new time data.  *  *   However, we don't assume that the local clock is right, or even  *   close, because it might not be at boot time, and we want to catch  *   and correct that situation.  This behaviour has saved us in several  *   instances.  On HP-UX 9.0x, there used to be a bug in adjtimed which  *   would cause the time to be set to some wild value, making the machine  *   essentially unusable (we use Kerberos authentication pervasively,  *   and it requires workstations and servers to have a time within five  *   minutes of the Kerberos server).  We also have problems on PC's  *   running both Linux and some Microsoft OS -- they tend to disagree  *   on what the BIOS clock should say, and who should update it, and  *   when.  On those systems, we not only run ntptimeset at boot, we  *   also reset the BIOS clock based on the result, so the correct  *   time will be retained across reboots.  *  * For these reasons, and others, we have continued to use this tool  * rather than ntpdate.  It is run automatically at boot time on every  * workstation and server in our facility.  *  * In the past, we called this program 'ntptime'.  Unfortunately, the  * ntp v4 distribution also includes a program with that name.  In  * order to avoid confusion, we have renamed our program 'ntptimeset',  * which more accurately describes what it does.  *  * Jeffrey T. Hutzelman (N3NHS)<jhutz+@cmu.edu>  * School of Computer Science - Research Computing Facility  * Carnegie Mellon University - Pittsburgh, PA  * 16-Aug-1999  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_io.h"
end_include

begin_include
include|#
directive|include
file|"iosignal.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntpdate.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syslog.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_RESOURCE_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_include
include|#
directive|include
file|"ioLib.h"
end_include

begin_include
include|#
directive|include
file|"sockLib.h"
end_include

begin_include
include|#
directive|include
file|"timers.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"recvbuff.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_define
define|#
directive|define
name|TARGET_RESOLUTION
value|1
end_define

begin_comment
comment|/* Try for 1-millisecond accuracy 				on Windows NT timers. */
end_comment

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|lib
name|,
literal|"winmm"
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Scheduling priority we run at  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_VXWORKS
end_ifndef

begin_define
define|#
directive|define
name|NTPDATE_PRIO
value|(-12)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NTPDATE_PRIO
value|(100)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIMER_SETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TIMER_CREATE
argument_list|)
end_if

begin_comment
comment|/* POSIX TIMERS - vxWorks doesn't have itimer - casey */
end_comment

begin_decl_stmt
specifier|static
name|timer_t
name|ntpdate_timerid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compatibility stuff for Version 2  */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXSKW
value|0x28f
end_define

begin_comment
comment|/* 0.01 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|NTP_MINDIST
value|0x51f
end_define

begin_comment
comment|/* 0.02 sec in fp format */
end_comment

begin_define
define|#
directive|define
name|NTP_INFIN
value|15
end_define

begin_comment
comment|/* max stratum, infinity a la Bellman-Ford */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXWGT
value|(8*FP_SECOND)
end_define

begin_comment
comment|/* maximum select weight 8 seconds */
end_comment

begin_define
define|#
directive|define
name|NTP_MAXLIST
value|5
end_define

begin_comment
comment|/* maximum select list size */
end_comment

begin_define
define|#
directive|define
name|PEER_SHIFT
value|8
end_define

begin_comment
comment|/* 8 suitable for crystal time base */
end_comment

begin_comment
comment|/*  * Debugging flag  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File descriptor masks etc. for call to select  */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fd_set
name|fdmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initializing flag.  All async routines watch this and only do their  * thing when it is clear.  */
end_comment

begin_decl_stmt
name|int
name|initializing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Alarm flag.	Set when an alarm occurs  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|alarm_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set the time if valid time determined  */
end_comment

begin_decl_stmt
name|int
name|set_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * transmission rate control  */
end_comment

begin_define
define|#
directive|define
name|MINTRANSMITS
value|(3)
end_define

begin_comment
comment|/* minimum total packets per server */
end_comment

begin_define
define|#
directive|define
name|MAXXMITCOUNT
value|(2)
end_define

begin_comment
comment|/* maximum packets per time interrupt */
end_comment

begin_comment
comment|/*  * time setting constraints  */
end_comment

begin_define
define|#
directive|define
name|DESIREDDISP
value|(4*FP_SECOND)
end_define

begin_comment
comment|/* desired dispersion, (fp 4) */
end_comment

begin_decl_stmt
name|int
name|max_period
init|=
name|DEFMAXPERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|min_servers
init|=
name|DEFMINSERVERS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|min_valid
init|=
name|DEFMINVALID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * counters related to time setting constraints  */
end_comment

begin_decl_stmt
name|int
name|contacted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of servers we have sent to */
end_comment

begin_decl_stmt
name|int
name|responding
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* servers responding */
end_comment

begin_decl_stmt
name|int
name|validcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* servers with valid time */
end_comment

begin_decl_stmt
name|int
name|valid_n_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid time servers with low dispersion */
end_comment

begin_comment
comment|/*  * Unpriviledged port flag.  */
end_comment

begin_decl_stmt
name|int
name|unpriv_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Program name.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Systemwide parameters and flags  */
end_comment

begin_decl_stmt
name|struct
name|server
modifier|*
modifier|*
name|sys_servers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the server list */
end_comment

begin_decl_stmt
name|int
name|sys_numservers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of servers to poll */
end_comment

begin_decl_stmt
name|int
name|sys_authenticate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true when authenticating */
end_comment

begin_decl_stmt
name|u_int32
name|sys_authkey
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to authentication key in use */
end_comment

begin_decl_stmt
name|u_long
name|sys_authdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* authentication delay */
end_comment

begin_comment
comment|/*  * The current internal time  */
end_comment

begin_decl_stmt
name|u_long
name|current_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File of encryption keys  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KEYFILE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_define
define|#
directive|define
name|KEYFILE
value|"/etc/ntp.keys"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KEYFILE
value|"%windir%\\ntp.keys"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KEYFILE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|key_file
init|=
name|KEYFILE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|key_file_storage
index|[
name|MAX_PATH
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|key_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * total packet counts  */
end_comment

begin_decl_stmt
name|u_long
name|total_xmit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|total_recv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Miscellaneous flags  */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HORRIBLEOK
value|3
end_define

begin_comment
comment|/* how many packets to let out */
end_comment

begin_decl_stmt
name|int
name|horrible
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many packets we drop for testing */
end_comment

begin_decl_stmt
name|int
name|secondhalf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* second half of timeout period */
end_comment

begin_decl_stmt
name|int
name|printmsg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print time response analysis */
end_comment

begin_comment
comment|/*  * The half time and finish time in internal time  */
end_comment

begin_decl_stmt
name|u_long
name|half_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|finish_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntptimesetmain
name|P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
name|argv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|analysis
name|P
argument_list|(
operator|(
name|int
name|final
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_enough
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|transmit
name|P
argument_list|(
operator|(
specifier|register
expr|struct
name|server
operator|*
name|server
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|receive
name|P
argument_list|(
operator|(
expr|struct
name|recvbuf
operator|*
name|rbufp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_filter
name|P
argument_list|(
operator|(
specifier|register
expr|struct
name|server
operator|*
name|server
operator|,
name|s_fp
name|d
operator|,
name|l_fp
operator|*
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clock_count
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|server
modifier|*
name|clock_select
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_local_clock
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|server
modifier|*
name|findserver
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timer
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|alarming
name|P
argument_list|(
operator|(
name|int
name|sig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_alarm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_io
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendpkt
name|P
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
name|dest
operator|,
expr|struct
name|pkt
operator|*
name|pkt
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|input_handler
name|P
argument_list|(
operator|(
name|l_fp
operator|*
name|xts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printserver
name|P
argument_list|(
operator|(
specifier|register
expr|struct
name|server
operator|*
name|pp
operator|,
name|FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
end_if

begin_decl_stmt
name|int
name|vsprintf
name|P
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
specifier|const
name|char
operator|*
name|fmt
operator|,
name|va_list
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|wait_for_signal
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|unblock_io_and_alarm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|block_io_and_alarm
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_expr_stmt
name|CALL
argument_list|(
name|ntptimeset
argument_list|,
literal|"ntptimeset"
argument_list|,
name|ntptimesetmain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|clear_globals
parameter_list|()
block|{
comment|/*    * Debugging flag    */
name|debug
operator|=
literal|0
expr_stmt|;
name|ntp_optind
operator|=
literal|0
expr_stmt|;
comment|/*    * Initializing flag.  All async routines watch this and only do their    * thing when it is clear.    */
name|initializing
operator|=
literal|1
expr_stmt|;
comment|/*    * Alarm flag.  Set when an alarm occurs    */
name|alarm_flag
operator|=
literal|0
expr_stmt|;
comment|/*    * Unpriviledged port flag.    */
name|unpriv_port
operator|=
literal|0
expr_stmt|;
comment|/*    * Systemwide parameters and flags    */
name|sys_numservers
operator|=
literal|0
expr_stmt|;
comment|/* number of servers to poll */
name|sys_authenticate
operator|=
literal|0
expr_stmt|;
comment|/* true when authenticating */
name|sys_authkey
operator|=
literal|0
expr_stmt|;
comment|/* set to authentication key in use */
name|sys_authdelay
operator|=
literal|0
expr_stmt|;
comment|/* authentication delay */
comment|/*    * The current internal time    */
name|current_time
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MAIN_ALLOWED */
end_comment

begin_comment
comment|/*  * Main program.  Initialize us and loop waiting for I/O and/or  * timer expiries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAIN_ALLOWED
end_ifndef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntptimesetmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MAIN_ALLOWED */
end_comment

begin_function
name|int
name|ntptimesetmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|was_alarmed
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbuflist
decl_stmt|;
name|struct
name|recvbuf
modifier|*
name|rbuf
decl_stmt|;
name|l_fp
name|tmp
decl_stmt|;
name|int
name|errflg
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|int
name|ltmp
decl_stmt|;
name|char
modifier|*
name|cfgpath
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|HANDLE
name|process_handle
decl_stmt|;
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No useable winsock.dll: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
name|clear_globals
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|errflg
operator|=
literal|0
expr_stmt|;
name|cfgpath
operator|=
literal|0
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|syslogit
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Decode argument list 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:c:de:slt:uvHS:V:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|c
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
name|sys_authenticate
operator|=
literal|1
expr_stmt|;
name|sys_authkey
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cfgpath
operator|=
name|ntp_optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|atolfp
argument_list|(
name|ntp_optarg
argument_list|,
operator|&
name|tmp
argument_list|)
operator|||
name|tmp
operator|.
name|l_ui
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: encryption delay %s is unlikely\n"
argument_list|,
name|progname
argument_list|,
name|ntp_optarg
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sys_authdelay
operator|=
name|tmp
operator|.
name|l_uf
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|set_time
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|syslogit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ltmp
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltmp
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: maximum time period (%d) is invalid\n"
argument_list|,
name|progname
argument_list|,
name|ltmp
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
name|max_period
operator|=
name|ltmp
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unpriv_port
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|horrible
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ltmp
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltmp
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: minimum responding (%d) is invalid\n"
argument_list|,
name|progname
argument_list|,
name|ltmp
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
name|min_servers
operator|=
name|ltmp
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|ltmp
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltmp
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: minimum valid (%d) is invalid\n"
argument_list|,
name|progname
argument_list|,
name|ltmp
argument_list|)
expr_stmt|;
name|errflg
operator|++
expr_stmt|;
block|}
else|else
name|min_valid
operator|=
name|ltmp
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflg
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|errflg
operator|||
name|ntp_optind
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [switches...]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -v       (verbose)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -c path  (set config file path)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -a key   (authenticate using key)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -e delay (authentication delay)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -S num   (# of servers that must respond)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -V num   (# of servers that must valid)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -s       (set the time based if okay)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -t secs  (time period before ending)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -l       (use syslog facility)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -u       (use unprivileged port)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -H       (drop packets for debugging)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  -d       (debug output)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Logging.  Open the syslog if we have to 	 */
if|if
condition|(
name|syslogit
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
operator|&&
operator|!
name|defined
name|SYS_CYGWIN32
ifndef|#
directive|ifndef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"ntptimeset"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOG_NTP
define|#
directive|define
name|LOG_NTP
value|LOG_DAEMON
endif|#
directive|endif
name|openlog
argument_list|(
literal|"ntptimeset"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_NTP
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
if|if
condition|(
name|horrible
condition|)
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Dropping %d out of %d packets"
argument_list|,
name|horrible
argument_list|,
name|horrible
operator|+
name|HORRIBLEOK
argument_list|)
expr_stmt|;
comment|/* 	 * Add servers we are going to be polling 	 */
name|loadservers
argument_list|(
name|cfgpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_numservers
operator|<
name|min_servers
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Found %d servers, require %d servers"
argument_list|,
name|sys_numservers
argument_list|,
name|min_servers
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * determine when we will end at least  	 */
name|finish_time
operator|=
name|max_period
operator|*
name|TIMER_HZ
expr_stmt|;
name|half_time
operator|=
name|finish_time
operator|>>
literal|1
expr_stmt|;
comment|/* 	 * Initialize the time of day routines and the I/O subsystem 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|init_auth
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
if|if
condition|(
operator|!
name|key_file
condition|)
name|key_file
operator|=
name|KEYFILE
expr_stmt|;
if|if
condition|(
operator|!
name|ExpandEnvironmentStrings
argument_list|(
name|key_file
argument_list|,
name|key_file_storage
argument_list|,
name|MAX_PATH
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ExpandEnvironmentStrings(%s) failed: %m\n"
argument_list|,
name|key_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key_file
operator|=
name|key_file_storage
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
operator|!
name|authreadkeys
argument_list|(
name|key_file
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no key file, exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|sys_authkey
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sys_authkey
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"authentication key %s unknown"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|init_io
argument_list|()
expr_stmt|;
name|init_alarm
argument_list|()
expr_stmt|;
comment|/* 	 * Set the priority. 	 */
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATT_NICE
argument_list|)
name|nice
argument_list|(
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_BSD_NICE
argument_list|)
operator|(
name|void
operator|)
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
name|NTPDATE_PRIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
name|process_handle
operator|=
name|GetCurrentProcess
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|SetPriorityClass
argument_list|(
name|process_handle
argument_list|,
operator|(
name|DWORD
operator|)
name|REALTIME_PRIORITY_CLASS
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SetPriorityClass failed: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|initializing
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use select() on all on all input fd's for unlimited 	 * time.  select() will terminate on SIGALARM or on the 	 * reception of input.	Using select() means we can't do 	 * robust signal handling and we get a potential race 	 * between checking for alarms and doing the select(). 	 * Mostly harmless, I think. 	 * Keep going until we have enough information, or time is up. 	 */
comment|/* On VMS, I suspect that select() can't be interrupted 	 * by a "signal" either, so I take the easy way out and 	 * have select() time out after one second. 	 * System clock updates really aren't time-critical, 	 * and - lacking a hardware reference clock - I have 	 * yet to learn about anything else that is. 	 */
name|was_alarmed
operator|=
literal|0
expr_stmt|;
name|rbuflist
operator|=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|finish_time
operator|>
name|current_time
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
name|fd_set
name|rdfdes
decl_stmt|;
name|int
name|nfound
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
name|block_io_and_alarm
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|rbuflist
operator|=
name|getrecvbufs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
if|if
condition|(
name|printmsg
condition|)
block|{
name|printmsg
operator|=
literal|0
expr_stmt|;
name|analysis
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alarm_flag
condition|)
block|{
comment|/* alarmed? */
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|was_alarmed
operator|&&
name|rbuflist
operator|==
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 			 * Nothing to do.  Wait for something. 			 */
ifndef|#
directive|ifndef
name|HAVE_SIGNALED_IO
name|rdfdes
operator|=
name|fdmask
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_VXWORKS
argument_list|)
comment|/* make select() wake up after one second */
block|{
name|struct
name|timeval
name|t1
decl_stmt|;
name|t1
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|t1
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|rdfdes
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|nfound
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|rdfdes
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|nfound
operator|>
literal|0
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|input_handler
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfound
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
condition|)
block|{
if|#
directive|if
operator|!
name|defined
name|SYS_VXWORKS
operator|&&
operator|!
name|defined
name|SYS_CYGWIN32
comment|/* to unclutter log */
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"select(): nfound=%d, error: %m"
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* HAVE_SIGNALED_IO */
name|wait_for_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
if|if
condition|(
name|alarm_flag
condition|)
comment|/* alarmed? */
block|{
name|was_alarmed
operator|=
literal|1
expr_stmt|;
name|alarm_flag
operator|=
literal|0
expr_stmt|;
block|}
name|rbuflist
operator|=
name|getrecvbufs
argument_list|()
expr_stmt|;
comment|/* get received buffers */
block|}
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|unblock_io_and_alarm
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGNALED_IO */
comment|/* 		 * Out here, signals are unblocked.  Call timer routine 		 * to process expiry. 		 */
if|if
condition|(
name|was_alarmed
condition|)
block|{
name|timer
argument_list|()
expr_stmt|;
name|was_alarmed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Call the data procedure to handle each received 		 * packet. 		 */
while|while
condition|(
name|rbuflist
operator|!=
operator|(
expr|struct
name|recvbuf
operator|*
operator|)
literal|0
condition|)
block|{
name|rbuf
operator|=
name|rbuflist
expr_stmt|;
name|rbuflist
operator|=
name|rbuf
operator|->
name|next
expr_stmt|;
name|receive
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
name|freerecvbuf
argument_list|(
name|rbuf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|DEBUG
operator|&&
name|defined
name|SYS_WINNT
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"getrecvbufs: %ld handler interrupts, %ld frames\n"
argument_list|,
name|handler_calls
argument_list|,
name|handler_pkts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Do we have enough information to stop now? 		 */
if|if
condition|(
name|have_enough
argument_list|()
condition|)
break|break;
comment|/* time to end */
comment|/* 		 * Go around again 		 */
block|}
comment|/* 	 * adjust the clock and exit accordingly 	 */
name|set_local_clock
argument_list|()
expr_stmt|;
comment|/* 	 * if we get here then we are in trouble 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * analysis - print a message indicating what is happening with time service  *	      must mimic have_enough() procedure.  */
end_comment

begin_function
specifier|static
name|void
name|analysis
parameter_list|(
name|int
name|final
parameter_list|)
block|{
if|if
condition|(
name|contacted
operator|<
name|sys_numservers
condition|)
block|{
name|printf
argument_list|(
literal|"%d servers of %d have been probed with %d packets\n"
argument_list|,
name|contacted
argument_list|,
name|sys_numservers
argument_list|,
name|MINTRANSMITS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|responding
condition|)
block|{
name|printf
argument_list|(
literal|"No response from any of %d servers, network problem?\n"
argument_list|,
name|sys_numservers
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|responding
operator|<
name|min_servers
condition|)
block|{
name|printf
argument_list|(
literal|"%d servers out of %d responding, need at least %d.\n"
argument_list|,
name|responding
argument_list|,
name|sys_numservers
argument_list|,
name|min_servers
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|validcount
condition|)
block|{
name|printf
argument_list|(
literal|"%d servers responding but none have valid time\n"
argument_list|,
name|responding
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|validcount
operator|<
name|min_valid
condition|)
block|{
name|printf
argument_list|(
literal|"%d servers responding, %d are valid, need %d valid\n"
argument_list|,
name|responding
argument_list|,
name|validcount
argument_list|,
name|min_valid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|final
operator|&&
name|valid_n_low
operator|!=
name|validcount
condition|)
block|{
name|printf
argument_list|(
literal|"%d valid servers but only %d have low dispersion\n"
argument_list|,
name|validcount
argument_list|,
name|valid_n_low
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* have_enough - see if we have enough information to terminate probing  */
end_comment

begin_function
specifier|static
name|int
name|have_enough
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* have we contacted all servers yet? */
if|if
condition|(
name|contacted
operator|<
name|sys_numservers
condition|)
return|return
literal|0
return|;
comment|/* no...try some more */
comment|/* have we got at least minimum servers responding? */
if|if
condition|(
name|responding
operator|<
name|min_servers
condition|)
return|return
literal|0
return|;
comment|/* no...try some more */
comment|/* count the clocks */
operator|(
name|void
operator|)
name|clock_count
argument_list|()
expr_stmt|;
comment|/* have we got at least minimum valid clocks? */
if|if
condition|(
name|validcount
operator|<=
literal|0
operator|||
name|validcount
operator|<
name|min_valid
condition|)
return|return
literal|0
return|;
comment|/* no...try some more */
comment|/* do we have all valid servers with low dispersion */
if|if
condition|(
operator|!
name|secondhalf
operator|&&
name|valid_n_low
operator|!=
name|validcount
condition|)
return|return
literal|0
return|;
comment|/* if we get into the secondhalf then we ignore dispersion */
comment|/* all conditions have been met...end */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * transmit - transmit a packet to the given server, or mark it completed.  *	      This is called by the timeout routine and by the receive  *	      procedure.  */
end_comment

begin_function
specifier|static
name|void
name|transmit
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|server
parameter_list|)
block|{
name|struct
name|pkt
name|xpkt
decl_stmt|;
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"transmit(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|server
operator|->
name|reach
operator|&
literal|01
operator|)
operator|==
literal|0
condition|)
block|{
name|l_fp
name|ts
decl_stmt|;
comment|/* 		 * Last message to this server timed out.  Shift 		 * zeros into the filter. 		 */
name|L_CLR
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|clock_filter
argument_list|(
name|server
argument_list|,
literal|0
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * shift reachable register over 	 */
name|server
operator|->
name|reach
operator|<<=
literal|1
expr_stmt|;
comment|/* 	 * If we're here, send another message to the server.  Fill in 	 * the packet and let 'er rip. 	 */
name|xpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
name|LEAP_NOTINSYNC
argument_list|,
name|server
operator|->
name|version
argument_list|,
name|MODE_CLIENT
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
name|xpkt
operator|.
name|precision
operator|=
name|NTPDATE_PRECISION
expr_stmt|;
name|xpkt
operator|.
name|rootdelay
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISTANCE
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|rootdispersion
operator|=
name|htonl
argument_list|(
name|NTPDATE_DISP
argument_list|)
expr_stmt|;
name|xpkt
operator|.
name|refid
operator|=
name|htonl
argument_list|(
name|NTPDATE_REFID
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|reftime
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|org
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|xpkt
operator|.
name|rec
argument_list|)
expr_stmt|;
comment|/* 	 * Determine whether to authenticate or not.  If so, 	 * fill in the extended part of the packet and do it. 	 * If not, just timestamp it and send it away. 	 */
if|if
condition|(
name|sys_authenticate
condition|)
block|{
name|int
name|len
decl_stmt|;
name|xpkt
operator|.
name|exten
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|sys_authkey
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|L_ADDUF
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
name|sys_authdelay
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|authencrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendpkt
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|,
operator|&
name|xpkt
argument_list|,
call|(
name|int
call|)
argument_list|(
name|LEN_PKT_NOMAC
operator|+
name|len
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"failed transmit auth to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit auth to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_systime
argument_list|(
operator|&
operator|(
name|server
operator|->
name|xmt
operator|)
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|server
operator|->
name|xmt
argument_list|,
operator|&
name|xpkt
operator|.
name|xmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendpkt
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|,
operator|&
name|xpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"failed transmit to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"transmit to %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
operator|(
name|server
operator|->
name|srcadr
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * count transmits, record contacted count and set transmit time 	 */
if|if
condition|(
operator|++
name|server
operator|->
name|xmtcnt
operator|==
name|MINTRANSMITS
condition|)
name|contacted
operator|++
expr_stmt|;
name|server
operator|->
name|last_xmit
operator|=
name|current_time
expr_stmt|;
comment|/* 	 * determine timeout for this packet. The more packets we send 	 * to the host, the slower we get. If the host indicates that 	 * it is not "sane" then we expect even less. 	 */
if|if
condition|(
name|server
operator|->
name|xmtcnt
operator|<
name|MINTRANSMITS
condition|)
block|{
comment|/* we have not sent enough */
name|timeout
operator|=
name|TIMER_HZ
expr_stmt|;
comment|/* 1 second probe */
block|}
elseif|else
if|if
condition|(
name|server
operator|->
name|rcvcnt
operator|<=
literal|0
condition|)
block|{
comment|/* we have heard nothing */
if|if
condition|(
name|secondhalf
condition|)
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|4
expr_stmt|;
comment|/* 16 second probe */
else|else
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|3
expr_stmt|;
comment|/* 8 second probe */
block|}
else|else
block|{
comment|/* if we have low dispersion then probe infrequently */
if|if
condition|(
name|server
operator|->
name|dispersion
operator|<=
name|DESIREDDISP
condition|)
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|4
expr_stmt|;
comment|/* 16 second probe */
comment|/* if the server is not in sync then let it alone */
elseif|else
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|4
expr_stmt|;
comment|/* 16 second probe */
comment|/* if the server looks broken ignore it */
elseif|else
if|if
condition|(
name|server
operator|->
name|org
operator|.
name|l_ui
operator|<
name|server
operator|->
name|reftime
operator|.
name|l_ui
condition|)
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|5
expr_stmt|;
comment|/* 32 second probe */
elseif|else
if|if
condition|(
name|secondhalf
condition|)
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|2
expr_stmt|;
comment|/* 4 second probe */
else|else
name|timeout
operator|=
name|TIMER_HZ
operator|<<
literal|1
expr_stmt|;
comment|/* 2 second probe */
block|}
comment|/* 	 * set next transmit time based on timeout 	 */
name|server
operator|->
name|event_time
operator|=
name|current_time
operator|+
name|timeout
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * receive - receive and process an incoming frame  */
end_comment

begin_function
specifier|static
name|void
name|receive
parameter_list|(
name|struct
name|recvbuf
modifier|*
name|rbufp
parameter_list|)
block|{
specifier|register
name|struct
name|pkt
modifier|*
name|rpkt
decl_stmt|;
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|s_fp
name|di
decl_stmt|;
name|l_fp
name|t10
decl_stmt|,
name|t23
decl_stmt|;
name|l_fp
name|org
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ci
decl_stmt|;
name|int
name|has_mac
decl_stmt|;
name|int
name|is_authentic
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive(%s)\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the packet basically looks like something 	 * intended for us. 	 */
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|==
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rbufp
operator|->
name|recv_length
operator|>=
name|LEN_PKT_NOMAC
condition|)
name|has_mac
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"receive: packet length %d\n"
argument_list|,
name|rbufp
operator|->
name|recv_length
argument_list|)
expr_stmt|;
return|return;
comment|/* funny length packet */
block|}
name|rpkt
operator|=
operator|&
operator|(
name|rbufp
operator|->
name|recv_pkt
operator|)
expr_stmt|;
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: bad version %d\n"
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_SERVER
operator|&&
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_PASSIVE
operator|)
operator|||
name|rpkt
operator|->
name|stratum
operator|>=
name|STRATUM_UNSPEC
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: mode %d stratum %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
argument_list|,
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * So far, so good.  See if this is from a server we know. 	 */
name|server
operator|=
name|findserver
argument_list|(
operator|&
operator|(
name|rbufp
operator|->
name|srcadr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: server not found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Decode the org timestamp and make sure we're getting a response 	 * to our last request. 	 */
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|L_ISEQU
argument_list|(
operator|&
name|org
argument_list|,
operator|&
name|server
operator|->
name|xmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: pkt.org and peer.xmt differ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check out the authenticity if we're doing that. 	 */
if|if
condition|(
operator|!
name|sys_authenticate
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|is_authentic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"receive: rpkt keyid=%ld sys_authkey=%ld decrypt=%ld\n"
argument_list|,
operator|(
name|long
name|int
operator|)
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|sys_authkey
argument_list|,
operator|(
name|long
name|int
operator|)
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mac
operator|&&
name|ntohl
argument_list|(
name|rpkt
operator|->
name|exten
index|[
literal|0
index|]
argument_list|)
operator|==
name|sys_authkey
operator|&&
name|authdecrypt
argument_list|(
name|sys_authkey
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
name|rpkt
argument_list|,
name|LEN_PKT_NOMAC
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rbufp
operator|->
name|recv_length
operator|-
name|LEN_PKT_NOMAC
argument_list|)
argument_list|)
condition|)
name|is_authentic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"receive: authentication %s\n"
argument_list|,
name|is_authentic
condition|?
literal|"passed"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
block|}
name|server
operator|->
name|trust
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|is_authentic
condition|)
name|server
operator|->
name|trust
operator||=
literal|1
expr_stmt|;
comment|/* 	 * Looks good.  Record info from the packet. 	 */
name|server
operator|->
name|leap
operator|=
name|PKT_LEAP
argument_list|(
name|rpkt
operator|->
name|li_vn_mode
argument_list|)
expr_stmt|;
name|server
operator|->
name|stratum
operator|=
name|PKT_TO_STRATUM
argument_list|(
name|rpkt
operator|->
name|stratum
argument_list|)
expr_stmt|;
name|server
operator|->
name|precision
operator|=
name|rpkt
operator|->
name|precision
expr_stmt|;
name|server
operator|->
name|rootdelay
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|server
operator|->
name|rootdispersion
operator|=
name|ntohl
argument_list|(
name|rpkt
operator|->
name|rootdispersion
argument_list|)
expr_stmt|;
name|server
operator|->
name|refid
operator|=
name|rpkt
operator|->
name|refid
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|reftime
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|rec
argument_list|,
operator|&
name|rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|xmt
argument_list|,
operator|&
name|server
operator|->
name|org
argument_list|)
expr_stmt|;
comment|/* 	 * count this guy as responding 	 */
name|server
operator|->
name|reach
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|rcvcnt
operator|++
operator|==
literal|0
condition|)
name|responding
operator|++
expr_stmt|;
comment|/* 	 * Make sure the server is at least somewhat sane.  If not, ignore 	 * it for later. 	 */
if|if
condition|(
name|L_ISZERO
argument_list|(
operator|&
name|rec
argument_list|)
operator|||
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive: pkt insane\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Calculate the round trip delay (di) and the clock offset (ci). 	 * We use the equations (reordered from those in the spec): 	 * 	 * d = (t2 - t3) - (t1 - t0) 	 * c = ((t2 - t3) + (t1 - t0)) / 2 	 */
name|t10
operator|=
name|server
operator|->
name|org
expr_stmt|;
comment|/* pkt.xmt == t1 */
name|L_SUB
argument_list|(
operator|&
name|t10
argument_list|,
operator|&
name|rbufp
operator|->
name|recv_time
argument_list|)
expr_stmt|;
comment|/* recv_time == t0*/
name|t23
operator|=
name|rec
expr_stmt|;
comment|/* pkt.rec == t2 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|org
argument_list|)
expr_stmt|;
comment|/* pkt->org == t3 */
comment|/* now have (t2 - t3) and (t0 - t1).  Calculate (ci) and (di) */
name|ci
operator|=
name|t10
expr_stmt|;
name|L_ADD
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|t23
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate di in t23 in full precision, then truncate 	 * to an s_fp. 	 */
name|L_SUB
argument_list|(
operator|&
name|t23
argument_list|,
operator|&
name|t10
argument_list|)
expr_stmt|;
name|di
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|t23
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"offset: %s, delay %s\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|ci
argument_list|,
literal|6
argument_list|)
argument_list|,
name|fptoa
argument_list|(
name|di
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|di
operator|+=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|server
operator|->
name|precision
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
if|if
condition|(
name|di
operator|<=
literal|0
condition|)
block|{
comment|/* value still too raunchy to use? */
name|L_CLR
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|di
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|di
operator|=
name|max
argument_list|(
name|di
argument_list|,
name|NTP_MINDIST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This one is valid.  Give it to clock_filter(), 	 */
name|clock_filter
argument_list|(
name|server
argument_list|,
name|di
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"receive from %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|rbufp
operator|->
name|srcadr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if we should goes the transmission. If not return now 	 * otherwise have the next event time be shortened 	 */
if|if
condition|(
name|server
operator|->
name|stratum
operator|<=
name|NTP_INFIN
condition|)
return|return;
comment|/* server does not have a stratum */
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
return|return;
comment|/* just booted server or out of sync */
if|if
condition|(
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
condition|)
return|return;
comment|/* broken host */
if|if
condition|(
name|server
operator|->
name|trust
operator|!=
literal|0
condition|)
return|return;
comment|/* can not trust it */
if|if
condition|(
name|server
operator|->
name|dispersion
operator|<
name|DESIREDDISP
condition|)
return|return;
comment|/* we have the desired dispersion */
name|server
operator|->
name|event_time
operator|-=
operator|(
name|TIMER_HZ
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_filter - add clock sample, determine a server's delay, dispersion  *                and offset  */
end_comment

begin_function
specifier|static
name|void
name|clock_filter
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|server
parameter_list|,
name|s_fp
name|di
parameter_list|,
name|l_fp
modifier|*
name|c
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ord
index|[
name|NTP_SHIFT
index|]
decl_stmt|;
comment|/* 	 * Insert sample and increment nextpt 	 */
name|i
operator|=
name|server
operator|->
name|filter_nextpt
expr_stmt|;
name|server
operator|->
name|filter_delay
index|[
name|i
index|]
operator|=
name|di
expr_stmt|;
name|server
operator|->
name|filter_offset
index|[
name|i
index|]
operator|=
operator|*
name|c
expr_stmt|;
name|server
operator|->
name|filter_soffset
index|[
name|i
index|]
operator|=
name|LFPTOFP
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|server
operator|->
name|filter_nextpt
operator|++
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|filter_nextpt
operator|>=
name|NTP_SHIFT
condition|)
name|server
operator|->
name|filter_nextpt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Sort indices into increasing delay order 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
name|ord
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|NTP_SHIFT
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|NTP_SHIFT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|>
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|j
index|]
index|]
operator|)
condition|)
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ord
index|[
name|i
index|]
expr_stmt|;
name|ord
index|[
name|i
index|]
operator|=
name|ord
index|[
name|j
index|]
expr_stmt|;
name|ord
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now compute the dispersion, and assign values to delay and 	 * offset.  If there are no samples in the register, delay and 	 * offset go to zero and dispersion is set to the maximum. 	 */
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|server
operator|->
name|delay
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
literal|0
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|s_fp
name|d
decl_stmt|;
name|server
operator|->
name|delay
operator|=
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|offset
operator|=
name|server
operator|->
name|filter_offset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
name|server
operator|->
name|soffset
operator|=
name|LFPTOFP
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|)
expr_stmt|;
name|server
operator|->
name|dispersion
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|filter_delay
index|[
name|ord
index|[
name|i
index|]
index|]
operator|==
literal|0
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
else|else
block|{
name|d
operator|=
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
name|i
index|]
index|]
operator|-
name|server
operator|->
name|filter_soffset
index|[
name|ord
index|[
literal|0
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|PEER_MAXDISP
condition|)
name|d
operator|=
name|PEER_MAXDISP
expr_stmt|;
block|}
comment|/* 			 * XXX This *knows* PEER_FILTER is 1/2 			 */
name|server
operator|->
name|dispersion
operator|+=
call|(
name|u_fp
call|)
argument_list|(
name|d
argument_list|)
operator|>>
name|i
expr_stmt|;
block|}
block|}
comment|/* 	 * We're done 	 */
block|}
end_function

begin_comment
comment|/* clock_count - count the clock sources we have  */
end_comment

begin_function
specifier|static
name|void
name|clock_count
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/* reset counts */
name|validcount
operator|=
name|valid_n_low
operator|=
literal|0
expr_stmt|;
comment|/* go through the list of servers and count the clocks we believe 	 * and that have low dispersion 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sys_numservers
condition|;
name|n
operator|++
control|)
block|{
name|server
operator|=
name|sys_servers
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|delay
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|/* no data */
block|}
if|if
condition|(
name|server
operator|->
name|stratum
operator|>
name|NTP_INFIN
condition|)
block|{
continue|continue;
comment|/* stratum no good */
block|}
if|if
condition|(
name|server
operator|->
name|delay
operator|>
name|NTP_MAXWGT
condition|)
block|{
continue|continue;
comment|/* too far away */
block|}
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
continue|continue;
comment|/* he's in trouble */
if|if
condition|(
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
condition|)
block|{
continue|continue;
comment|/* very broken host */
block|}
if|if
condition|(
operator|(
name|server
operator|->
name|org
operator|.
name|l_ui
operator|-
name|server
operator|->
name|reftime
operator|.
name|l_ui
operator|)
operator|>=
name|NTP_MAXAGE
condition|)
block|{
continue|continue;
comment|/* too long without sync */
block|}
if|if
condition|(
name|server
operator|->
name|trust
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * This one is a valid time source.. 		 */
name|validcount
operator|++
expr_stmt|;
comment|/* 		 * See if this one has a okay low dispersion 		 */
if|if
condition|(
name|server
operator|->
name|dispersion
operator|<=
name|DESIREDDISP
condition|)
name|valid_n_low
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"have %d, valid %d, low %d\n"
argument_list|,
name|responding
argument_list|,
name|validcount
argument_list|,
name|valid_n_low
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clock_select - select the pick-of-the-litter clock from the samples  *		  we've got.  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|clock_select
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|nlist
decl_stmt|;
specifier|register
name|s_fp
name|d
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|s_fp
name|local_threshold
decl_stmt|;
name|struct
name|server
modifier|*
name|server_list
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|u_fp
name|server_badness
index|[
name|NTP_MAXCLOCK
index|]
decl_stmt|;
name|struct
name|server
modifier|*
name|sys_server
decl_stmt|;
comment|/* 	 * This first chunk of code is supposed to go through all 	 * servers we know about to find the NTP_MAXLIST servers which 	 * are most likely to succeed.  We run through the list 	 * doing the sanity checks and trying to insert anyone who 	 * looks okay.  We are at all times aware that we should 	 * only keep samples from the top two strata and we only need 	 * NTP_MAXLIST of them. 	 */
name|nlist
operator|=
literal|0
expr_stmt|;
comment|/* none yet */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sys_numservers
condition|;
name|n
operator|++
control|)
block|{
name|server
operator|=
name|sys_servers
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|delay
operator|==
literal|0
condition|)
continue|continue;
comment|/* no data */
if|if
condition|(
name|server
operator|->
name|stratum
operator|>
name|NTP_INFIN
condition|)
continue|continue;
comment|/* stratum no good */
if|if
condition|(
name|server
operator|->
name|delay
operator|>
name|NTP_MAXWGT
condition|)
block|{
continue|continue;
comment|/* too far away */
block|}
if|if
condition|(
name|server
operator|->
name|leap
operator|==
name|LEAP_NOTINSYNC
condition|)
continue|continue;
comment|/* he's in trouble */
if|if
condition|(
operator|!
name|L_ISHIS
argument_list|(
operator|&
name|server
operator|->
name|org
argument_list|,
operator|&
name|server
operator|->
name|reftime
argument_list|)
condition|)
block|{
continue|continue;
comment|/* very broken host */
block|}
if|if
condition|(
operator|(
name|server
operator|->
name|org
operator|.
name|l_ui
operator|-
name|server
operator|->
name|reftime
operator|.
name|l_ui
operator|)
operator|>=
name|NTP_MAXAGE
condition|)
block|{
continue|continue;
comment|/* too long without sync */
block|}
if|if
condition|(
name|server
operator|->
name|trust
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * This one seems sane.  Find where he belongs 		 * on the list. 		 */
name|d
operator|=
name|server
operator|->
name|dispersion
operator|+
name|server
operator|->
name|dispersion
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server
operator|->
name|stratum
operator|<=
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|server
operator|->
name|stratum
operator|<
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
condition|)
break|break;
if|if
condition|(
name|d
operator|<
operator|(
name|s_fp
operator|)
name|server_badness
index|[
name|i
index|]
condition|)
break|break;
block|}
comment|/* 		 * If i points past the end of the list, this 		 * guy is a loser, else stick him in. 		 */
if|if
condition|(
name|i
operator|>=
name|NTP_MAXLIST
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|nlist
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|j
operator|<
name|NTP_MAXLIST
condition|)
block|{
name|server_list
index|[
name|j
index|]
operator|=
name|server_list
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|server_badness
index|[
name|j
index|]
operator|=
name|server_badness
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|server_list
index|[
name|i
index|]
operator|=
name|server
expr_stmt|;
name|server_badness
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|nlist
operator|<
name|NTP_MAXLIST
condition|)
name|nlist
operator|++
expr_stmt|;
block|}
comment|/* 	 * Got the five-or-less best.  Cut the list where the number of 	 * strata exceeds two. 	 */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nlist
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|>
name|server_list
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|stratum
condition|)
if|if
condition|(
operator|++
name|j
operator|==
literal|2
condition|)
block|{
name|nlist
operator|=
name|i
expr_stmt|;
break|break;
block|}
comment|/* 	 * Whew!  What we should have by now is 0 to 5 candidates for 	 * the job of syncing us.  If we have none, we're out of luck. 	 * If we have one, he's a winner.  If we have more, do falseticker 	 * detection. 	 */
if|if
condition|(
name|nlist
operator|==
literal|0
condition|)
name|sys_server
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nlist
operator|==
literal|1
condition|)
block|{
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Re-sort by stratum, bdelay estimate quality and 		 * server.delay. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlist
operator|-
literal|1
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|stratum
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|stratum
condition|)
break|break;
comment|/* already sorted by stratum */
if|if
condition|(
name|server_list
index|[
name|i
index|]
operator|->
name|delay
operator|<
name|server_list
index|[
name|j
index|]
operator|->
name|delay
condition|)
continue|continue;
name|server
operator|=
name|server_list
index|[
name|i
index|]
expr_stmt|;
name|server_list
index|[
name|i
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|server_list
index|[
name|j
index|]
operator|=
name|server
expr_stmt|;
block|}
comment|/* 		 * Calculate the fixed part of the dispersion limit 		 */
name|local_threshold
operator|=
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
operator|(
name|int
operator|)
name|NTPDATE_PRECISION
operator|)
operator|)
operator|+
name|NTP_MAXSKW
expr_stmt|;
comment|/* 		 * Now drop samples until we're down to one. 		 */
while|while
condition|(
name|nlist
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nlist
condition|;
name|n
operator|++
control|)
block|{
name|server_badness
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|n
condition|)
comment|/* with self? */
continue|continue;
name|d
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|soffset
operator|-
name|server_list
index|[
name|n
index|]
operator|->
name|soffset
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
comment|/* absolute value */
name|d
operator|=
operator|-
name|d
expr_stmt|;
comment|/* 					 * XXX This code *knows* that 					 * NTP_SELECT is 3/4 					 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|d
operator|=
operator|(
name|d
operator|>>
literal|1
operator|)
operator|+
operator|(
name|d
operator|>>
literal|2
operator|)
expr_stmt|;
name|server_badness
index|[
name|n
index|]
operator|+=
name|d
expr_stmt|;
block|}
block|}
comment|/* 			 * We now have an array of nlist badness 			 * coefficients.  Find the badest.  Find 			 * the minimum precision while we're at 			 * it. 			 */
name|i
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|server_list
index|[
literal|0
index|]
operator|->
name|precision
expr_stmt|;
empty_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|server_badness
index|[
name|j
index|]
operator|>=
name|server_badness
index|[
name|i
index|]
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|server_list
index|[
name|j
index|]
operator|->
name|precision
condition|)
name|n
operator|=
name|server_list
index|[
name|j
index|]
operator|->
name|precision
expr_stmt|;
block|}
comment|/* 			 * i is the index of the server with the worst 			 * dispersion.  If his dispersion is less than 			 * the threshold, stop now, else delete him and 			 * continue around again. 			 */
if|if
condition|(
name|server_badness
index|[
name|i
index|]
operator|<
operator|(
name|local_threshold
operator|+
operator|(
name|FP_SECOND
operator|>>
operator|(
operator|-
name|n
operator|)
operator|)
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nlist
condition|;
name|j
operator|++
control|)
name|server_list
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|server_list
index|[
name|j
index|]
expr_stmt|;
name|nlist
operator|--
expr_stmt|;
block|}
comment|/* 		 * What remains is a list of less than 5 servers.  Take 		 * the best. 		 */
name|sys_server
operator|=
name|server_list
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * That's it.  Return our server. 	 */
return|return
name|sys_server
return|;
block|}
end_function

begin_comment
comment|/*  * set_local_clock -- handle setting the local clock or displaying info.  */
end_comment

begin_function
specifier|static
name|void
name|set_local_clock
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|server
modifier|*
name|server
decl_stmt|;
name|time_t
name|tmp
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
comment|/* 	 * if setting time then print final analysis 	 */
if|if
condition|(
name|set_time
condition|)
name|analysis
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * pick a clock 	 */
name|server
operator|=
name|clock_select
argument_list|()
expr_stmt|;
comment|/* 	 * do some display of information 	 */
if|if
condition|(
name|debug
operator|||
name|verbose
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
name|printserver
argument_list|(
name|sys_servers
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"packets sent %ld, received %ld\n"
argument_list|,
name|total_xmit
argument_list|,
name|total_recv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * see if we have a server to set the time with 	 */
if|if
condition|(
name|server
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|set_time
operator|||
name|verbose
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"No servers available to sync time with\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * we have a valid and selected time to use!!!!! 	 */
comment|/* 	 * if we are not setting the time then display offset and exit 	 */
if|if
condition|(
operator|!
name|set_time
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Your clock is off by %s seconds. (%s) [%ld/%ld]\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|7
argument_list|)
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|total_xmit
argument_list|,
name|total_recv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * set the clock 	 * XXX: Examine the more flexible approach used by ntpdate. 	 * Note that a design consideration here is that we sometimes 	 * _want_ to step the clock by a _huge_ amount in either 	 * direction, because the local clock is completely bogus. 	 * This condition must be recognized and dealt with, so 	 * that we always get a good time when this completes. 	 * -- jhutz+@cmu.edu, 16-Aug-1999 	 */
name|LFPTOD
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
name|dtemp
argument_list|)
expr_stmt|;
name|step_systime
argument_list|(
name|dtemp
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Time set to %.20s [%s %s %ld/%ld]\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|tmp
argument_list|)
operator|+
literal|4
argument_list|,
name|ntoa
argument_list|(
operator|&
name|server
operator|->
name|srcadr
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|server
operator|->
name|offset
argument_list|,
literal|7
argument_list|)
argument_list|,
name|total_xmit
argument_list|,
name|total_recv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findserver - find a server in the list given its address  */
end_comment

begin_function
specifier|static
name|struct
name|server
modifier|*
name|findserver
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_int32
name|netnum
decl_stmt|;
if|if
condition|(
name|htons
argument_list|(
name|addr
operator|->
name|sin_port
argument_list|)
operator|!=
name|NTP_PORT
condition|)
return|return
literal|0
return|;
name|netnum
operator|=
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|netnum
operator|==
name|sys_servers
index|[
name|i
index|]
operator|->
name|srcadr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
name|sys_servers
index|[
name|i
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * timer - process a timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|timer
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
comment|/* 	 * Bump the current idea of the time 	 */
name|current_time
operator|++
expr_stmt|;
comment|/* 	 * see if we have reached half time 	 */
if|if
condition|(
name|current_time
operator|>=
name|half_time
operator|&&
operator|!
name|secondhalf
condition|)
block|{
name|secondhalf
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"\nSecond Half of Timeout!\n"
argument_list|)
expr_stmt|;
name|printmsg
operator|++
expr_stmt|;
block|}
comment|/* 	 * We only want to send a few packets per transmit interrupt 	 * to throttle things 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAXXMITCOUNT
condition|;
name|k
operator|++
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|oldi
decl_stmt|;
specifier|register
name|u_long
name|oldxtime
decl_stmt|;
comment|/* 	     * We want to send a packet out for a server that has an 	     * expired event time. However to be mellow about this, we only 	     * use one expired event timer and to avoid starvation we use 	     * the one with the oldest last transmit time. 	     */
name|oldi
operator|=
operator|-
literal|1
expr_stmt|;
name|oldxtime
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sys_numservers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sys_servers
index|[
name|i
index|]
operator|->
name|event_time
operator|<=
name|current_time
condition|)
block|{
if|if
condition|(
name|oldi
operator|<
literal|0
operator|||
name|oldxtime
operator|>
name|sys_servers
index|[
name|i
index|]
operator|->
name|last_xmit
condition|)
block|{
name|oldxtime
operator|=
name|sys_servers
index|[
name|i
index|]
operator|->
name|last_xmit
expr_stmt|;
name|oldi
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|oldi
operator|>=
literal|0
condition|)
name|transmit
argument_list|(
name|sys_servers
index|[
name|oldi
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
comment|/* no expired event */
block|}
comment|/* end of transmit loop */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_comment
comment|/*  * alarming - record the occurance of an alarm interrupt  */
end_comment

begin_decl_stmt
specifier|static
name|RETSIGTYPE
name|alarming
argument_list|(
name|int
name|sig
argument_list|)
else|#
directive|else
name|void
name|CALLBACK
name|alarming
argument_list|(
name|UINT
name|uTimerID
argument_list|,
name|UINT
name|uMsg
argument_list|,
name|DWORD
name|dwUser
argument_list|,
name|DWORD
name|dw1
argument_list|,
name|DWORD
name|dw2
argument_list|)
endif|#
directive|endif
comment|/* SYS_WINNT */
block|{
name|alarm_flag
operator|++
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * init_alarm - set up the timer interrupt  */
end_comment

begin_function
specifier|static
name|void
name|init_alarm
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
ifndef|#
directive|ifndef
name|HAVE_TIMER_SETTIME
name|struct
name|itimerval
name|itimer
decl_stmt|;
else|#
directive|else
name|struct
name|itimerspec
name|ntpdate_itimer
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
name|TIMECAPS
name|tc
decl_stmt|;
name|UINT
name|wTimerRes
decl_stmt|,
name|wTimerID
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
if|#
directive|if
name|defined
name|SYS_CYGWIN32
operator|||
name|defined
name|SYS_WINNT
name|HANDLE
name|hToken
decl_stmt|;
name|TOKEN_PRIVILEGES
name|tkp
decl_stmt|;
name|DWORD
name|dwUser
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|alarm_flag
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TIMER_CREATE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_TIMER_SETTIME
argument_list|)
name|alarm_flag
operator|=
literal|0
expr_stmt|;
comment|/* this code was put in as setitimer() is non existant this us the 	 * POSIX "equivalents" setup - casey 	 */
comment|/* ntpdate_timerid is global - so we can kill timer later */
if|if
condition|(
name|timer_create
argument_list|(
name|CLOCK_REALTIME
argument_list|,
name|NULL
argument_list|,
operator|&
name|ntpdate_timerid
argument_list|)
operator|==
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|ERROR
else|#
directive|else
operator|-
literal|1
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"init_alarm(): timer_create (...) FAILED\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*	TIMER_HZ = (5) 	 * Set up the alarm interrupt.	The first comes 1/(2*TIMER_HZ) 	 * seconds from now and they continue on every 1/TIMER_HZ seconds. 	 */
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|ntpdate_itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|ntpdate_itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntpdate_itimer
operator|.
name|it_interval
operator|.
name|tv_nsec
operator|=
literal|1000000000
operator|/
name|TIMER_HZ
expr_stmt|;
name|ntpdate_itimer
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
literal|1000000000
operator|/
operator|(
name|TIMER_HZ
operator|<<
literal|1
operator|)
expr_stmt|;
name|timer_settime
argument_list|(
name|ntpdate_timerid
argument_list|,
literal|0
comment|/* !TIMER_ABSTIME */
argument_list|,
operator|&
name|ntpdate_itimer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Set up the alarm interrupt.	The first comes 1/(2*TIMER_HZ) 	 * seconds from now and they continue on every 1/TIMER_HZ seconds. 	 */
operator|(
name|void
operator|)
name|signal_no_reset
argument_list|(
name|SIGALRM
argument_list|,
name|alarming
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
name|TIMER_HZ
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|1000000
operator|/
operator|(
name|TIMER_HZ
operator|<<
literal|1
operator|)
expr_stmt|;
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
name|SYS_CYGWIN32
comment|/* 	 * Get previleges needed for fiddling with the clock 	 */
comment|/* get the current process token handle */
if|if
condition|(
operator|!
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_ADJUST_PRIVILEGES
operator||
name|TOKEN_QUERY
argument_list|,
operator|&
name|hToken
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"OpenProcessToken failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get the LUID for system-time privilege. */
name|LookupPrivilegeValue
argument_list|(
name|NULL
argument_list|,
name|SE_SYSTEMTIME_NAME
argument_list|,
operator|&
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Luid
argument_list|)
expr_stmt|;
name|tkp
operator|.
name|PrivilegeCount
operator|=
literal|1
expr_stmt|;
comment|/* one privilege to set */
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|=
name|SE_PRIVILEGE_ENABLED
expr_stmt|;
comment|/* get set-time privilege for this process. */
name|AdjustTokenPrivileges
argument_list|(
name|hToken
argument_list|,
name|FALSE
argument_list|,
operator|&
name|tkp
argument_list|,
literal|0
argument_list|,
operator|(
name|PTOKEN_PRIVILEGES
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot test return value of AdjustTokenPrivileges. */
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"AdjustTokenPrivileges failed: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SYS_WINNT */
name|_tzset
argument_list|()
expr_stmt|;
comment|/* 	 * Get previleges needed for fiddling with the clock 	 */
comment|/* get the current process token handle */
if|if
condition|(
operator|!
name|OpenProcessToken
argument_list|(
name|GetCurrentProcess
argument_list|()
argument_list|,
name|TOKEN_ADJUST_PRIVILEGES
operator||
name|TOKEN_QUERY
argument_list|,
operator|&
name|hToken
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"OpenProcessToken failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get the LUID for system-time privilege. */
name|LookupPrivilegeValue
argument_list|(
name|NULL
argument_list|,
name|SE_SYSTEMTIME_NAME
argument_list|,
operator|&
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Luid
argument_list|)
expr_stmt|;
name|tkp
operator|.
name|PrivilegeCount
operator|=
literal|1
expr_stmt|;
comment|/* one privilege to set */
name|tkp
operator|.
name|Privileges
index|[
literal|0
index|]
operator|.
name|Attributes
operator|=
name|SE_PRIVILEGE_ENABLED
expr_stmt|;
comment|/* get set-time privilege for this process. */
name|AdjustTokenPrivileges
argument_list|(
name|hToken
argument_list|,
name|FALSE
argument_list|,
operator|&
name|tkp
argument_list|,
literal|0
argument_list|,
operator|(
name|PTOKEN_PRIVILEGES
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot test return value of AdjustTokenPrivileges. */
if|if
condition|(
name|GetLastError
argument_list|()
operator|!=
name|ERROR_SUCCESS
condition|)
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"AdjustTokenPrivileges failed: %m"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up timer interrupts for every 2**EVENT_TIMEOUT seconds 	 * Under Win/NT, expiry of timer interval leads to invocation 	 * of a callback function (on a different thread) rather than 	 * generating an alarm signal 	 */
comment|/* determine max and min resolution supported */
if|if
condition|(
name|timeGetDevCaps
argument_list|(
operator|&
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|TIMECAPS
argument_list|)
argument_list|)
operator|!=
name|TIMERR_NOERROR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"timeGetDevCaps failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wTimerRes
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|tc
operator|.
name|wPeriodMin
argument_list|,
name|TARGET_RESOLUTION
argument_list|)
argument_list|,
name|tc
operator|.
name|wPeriodMax
argument_list|)
expr_stmt|;
comment|/* establish the minimum timer resolution that we'll use */
name|timeBeginPeriod
argument_list|(
name|wTimerRes
argument_list|)
expr_stmt|;
comment|/* start the timer event */
name|wTimerID
operator|=
name|timeSetEvent
argument_list|(
call|(
name|UINT
call|)
argument_list|(
literal|1000
operator|/
name|TIMER_HZ
argument_list|)
argument_list|,
comment|/* Delay */
name|wTimerRes
argument_list|,
comment|/* Resolution */
operator|(
name|LPTIMECALLBACK
operator|)
name|alarming
argument_list|,
comment|/* Callback function */
operator|(
name|DWORD
operator|)
name|dwUser
argument_list|,
comment|/* User data */
name|TIME_PERIODIC
argument_list|)
expr_stmt|;
comment|/* Event type (periodic) */
if|if
condition|(
name|wTimerID
operator|==
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"timeSetEvent failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
block|}
end_function

begin_comment
comment|/*  * init_io - initialize I/O data and open socket  */
end_comment

begin_function
specifier|static
name|void
name|init_io
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|init_transmitbuff
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
comment|/* 	 * Init buffer free list and stat counters 	 */
name|init_recvbuff
argument_list|(
name|sys_numservers
operator|+
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGNALED_IO
argument_list|)
name|set_signal
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_WINNT
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No useable winsock.dll: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|BLOCKIO
argument_list|()
expr_stmt|;
comment|/* create a datagram (UDP) socket */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * bind the socket to the NTP port 	 */
if|if
condition|(
operator|!
name|debug
operator|&&
name|set_time
operator|&&
operator|!
name|unpriv_port
condition|)
block|{
name|struct
name|sockaddr_in
name|addr
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NTP_PORT
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
else|#
directive|else
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAEADDRINUSE
condition|)
endif|#
directive|endif
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"the NTP socket is in use, exiting"
argument_list|)
expr_stmt|;
else|else
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind() fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|FD_ZERO
argument_list|(
operator|&
name|fdmask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fdmask
argument_list|)
expr_stmt|;
comment|/* 	 * set non-blocking, 	 */
ifdef|#
directive|ifdef
name|USE_FIONBIO
comment|/* in vxWorks we use FIONBIO, but the others are defined for old systems, so 	 * all hell breaks loose if we leave them defined 	 */
undef|#
directive|undef
name|O_NONBLOCK
undef|#
directive|undef
name|FNDELAY
undef|#
directive|undef
name|O_NDELAY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NONBLOCK
argument_list|)
comment|/* POSIX */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NONBLOCK) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FNDELAY
argument_list|)
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(FNDELAY) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
comment|/* generally the same as FNDELAY */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(O_NDELAY) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIONBIO
argument_list|)
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
literal|1
argument_list|)
operator|<
literal|0
operator|)
elif|#
directive|elif
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|(
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|on
argument_list|)
operator|==
name|SOCKET_ERROR
operator|)
else|#
directive|else
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIONBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FIOSNBIO
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOSNBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(FIOSNBIO) fails: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|#
directive|else
include|#
directive|include
file|"Bletch: Need non-blocking I/O!"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SIGNALED_IO
name|init_socket_sig
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGNALED_IO */
name|UNBLOCKIO
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sendpkt - send a packet to the specified destination  */
end_comment

begin_function
specifier|static
name|int
name|sendpkt
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|dest
parameter_list|,
name|struct
name|pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
specifier|static
name|int
name|horriblecnt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
name|DWORD
name|err
decl_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
name|total_xmit
operator|++
expr_stmt|;
comment|/* count it */
if|if
condition|(
name|horrible
condition|)
block|{
if|if
condition|(
operator|++
name|horriblecnt
operator|>
name|HORRIBLEOK
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"dropping send (%s)\n"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|horriblecnt
operator|>=
name|HORRIBLEOK
operator|+
name|horrible
condition|)
name|horriblecnt
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cc
operator|=
name|sendto
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
operator|&&
name|errno
operator|!=
name|ENOBUFS
condition|)
else|#
directive|else
if|if
condition|(
name|cc
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|err
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|WSAEWOULDBLOCK
operator|&&
name|err
operator|!=
name|WSAENOBUFS
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto(%s): %m"
argument_list|,
name|ntoa
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * input_handler - receive packets asynchronously  */
name|void
name|input_handler
parameter_list|(
name|l_fp
modifier|*
name|xts
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|recvbuf
modifier|*
name|rb
decl_stmt|;
name|struct
name|timeval
name|tvzero
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|ts
operator|=
operator|*
name|xts
expr_stmt|;
comment|/* we ignore xts, but make the compiler happy */
comment|/* 	 * Do a poll to see if we have data 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fds
operator|=
name|fdmask
expr_stmt|;
name|tvzero
operator|.
name|tv_sec
operator|=
name|tvzero
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tvzero
argument_list|)
expr_stmt|;
comment|/* 		 * If nothing to do, just return.  If an error occurred, 		 * complain and return.  If we've got some, freeze a 		 * timestamp. 		 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select() error: %m"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 		 * Get a buffer and read the frame.  If we 		 * haven't got a buffer, or this is received 		 * on the wild card socket, just dump the packet. 		 */
if|if
condition|(
name|initializing
operator|||
name|free_recvbuffs
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
operator|(
name|void
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NT's _read does not operate on nonblocking sockets 			 * either recvfrom or ReadFile() has to be used here. 			 * ReadFile is used in [ntpd]ntp_intres() and ntpdc, 			 * just to be different use recvfrom() here 			 */
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
continue|continue;
block|}
name|rb
operator|=
name|get_free_recv_buffer
argument_list|()
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rb
operator|->
name|recv_length
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rb
operator|->
name|recv_pkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rb
operator|->
name|recv_pkt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|rb
operator|->
name|srcadr
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|recv_length
operator|==
operator|-
literal|1
condition|)
block|{
name|freerecvbuf
argument_list|(
name|rb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Got one.  Mark how and when it got here, 		 * put it on the full list. 		 */
name|rb
operator|->
name|recv_time
operator|=
name|ts
expr_stmt|;
name|add_full_recv_buffer
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|total_recv
operator|++
expr_stmt|;
comment|/* count it */
block|}
block|}
comment|/* XXX ELIMINATE printserver similar in ntptrace.c, ntpdate.c */
comment|/*  * printserver - print detail information for a server  */
specifier|static
name|void
name|printserver
parameter_list|(
specifier|register
name|struct
name|server
modifier|*
name|pp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|junk
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-15s %d/%d %03o v%d s%d offset %9s delay %s disp %s\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|pp
operator|->
name|xmtcnt
argument_list|,
name|pp
operator|->
name|rcvcnt
argument_list|,
name|pp
operator|->
name|reach
argument_list|,
name|pp
operator|->
name|version
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"server %s, port %d\n"
argument_list|,
name|ntoa
argument_list|(
operator|&
name|pp
operator|->
name|srcadr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|pp
operator|->
name|srcadr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"stratum %d, precision %d, leap %c%c, trust %03o\n"
argument_list|,
name|pp
operator|->
name|stratum
argument_list|,
name|pp
operator|->
name|precision
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x2
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|leap
operator|&
literal|0x1
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|pp
operator|->
name|trust
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|stratum
operator|==
literal|1
condition|)
block|{
name|junk
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|memmove
argument_list|(
name|junk
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pp
operator|->
name|refid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|str
operator|=
name|junk
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|numtoa
argument_list|(
name|pp
operator|->
name|refid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"refid [%s], delay %s, dispersion %s\n"
argument_list|,
name|str
argument_list|,
name|fptoa
argument_list|(
operator|(
name|s_fp
operator|)
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmitted %d, received %d, reachable %03o\n"
argument_list|,
name|pp
operator|->
name|xmtcnt
argument_list|,
name|pp
operator|->
name|rcvcnt
argument_list|,
name|pp
operator|->
name|reach
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"reference time:    %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|reftime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"originate timestamp: %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|org
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"transmit timestamp:  %s\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|pp
operator|->
name|xmt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter delay: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTP_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|fptoa
argument_list|(
name|pp
operator|->
name|filter_delay
index|[
name|i
index|]
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|NTP_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"filter offset:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PEER_SHIFT
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %-8.8s"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|filter_offset
index|[
name|i
index|]
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|(
name|PEER_SHIFT
operator|>>
literal|1
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n        "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %s, dispersion %s\n"
argument_list|,
name|fptoa
argument_list|(
operator|(
name|s_fp
operator|)
name|pp
operator|->
name|delay
argument_list|,
literal|5
argument_list|)
argument_list|,
name|ufptoa
argument_list|(
name|pp
operator|->
name|dispersion
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"offset %s\n\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|pp
operator|->
name|offset
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
name|int
name|vsprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|FILE
name|f
decl_stmt|;
name|int
name|len
decl_stmt|;
name|f
operator|.
name|_flag
operator|=
name|_IOWRT
operator|+
name|_IOSTRG
expr_stmt|;
name|f
operator|.
name|_ptr
operator|=
name|str
expr_stmt|;
name|f
operator|.
name|_cnt
operator|=
literal|32767
expr_stmt|;
name|len
operator|=
name|_doprnt
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
operator|*
name|f
operator|.
name|_ptr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

