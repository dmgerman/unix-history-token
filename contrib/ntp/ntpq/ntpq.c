begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpq - query an NTP server using mode 6 commands  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_include
include|#
directive|include
file|<mswsock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"ntp_select.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"lib_strbuf.h"
end_include

begin_include
include|#
directive|include
file|"ntp_lineedit.h"
end_include

begin_include
include|#
directive|include
file|"ntp_debug.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/objects.h"
end_include

begin_include
include|#
directive|include
file|"openssl/err.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_include
include|#
directive|include
file|"ntp_libopts.h"
end_include

begin_include
include|#
directive|include
file|"safecast.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_VXWORKS
end_ifdef

begin_comment
comment|/* vxWorks needs mode flag -casey*/
end_comment

begin_define
define|#
directive|define
name|open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|open(name, flags, 0777)
end_define

begin_define
define|#
directive|define
name|SERVER_PORT_NUM
value|123
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* we use COMMAND as an autogen keyword */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMAND
end_ifdef

begin_undef
undef|#
directive|undef
name|COMMAND
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Because we potentially understand a lot of commands we will run  * interactive if connected to a terminal.  */
end_comment

begin_decl_stmt
name|int
name|interactive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when we should prompt */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|prompt
init|=
literal|"ntpq> "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt to ask him about */
end_comment

begin_comment
comment|/*  * use old readvars behavior?  --old-rv processing in ntpq resets  * this value based on the presence or absence of --old-rv.  It is  * initialized to 1 here to maintain backward compatibility with  * libntpq clients such as ntpsnmpd, which are free to reset it as  * desired.  */
end_comment

begin_decl_stmt
name|int
name|old_rv
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * How should we display the refid?  * REFID_HASH, REFID_IPV4  */
end_comment

begin_decl_stmt
name|te_Refid
name|drefid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * for get_systime()  */
end_comment

begin_decl_stmt
name|s_char
name|sys_precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local clock precision (log2 s) */
end_comment

begin_comment
comment|/*  * Keyid used for authenticated requests.  Obtained on the fly.  */
end_comment

begin_decl_stmt
name|u_long
name|info_auth_keyid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_auth_keytype
init|=
name|NID_md5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|info_auth_hashlen
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MD5 */
end_comment

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed by authkeys; not used */
end_comment

begin_comment
comment|/*  * Flag which indicates we should always send authenticated requests  */
end_comment

begin_decl_stmt
name|int
name|always_auth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flag which indicates raw mode output.  */
end_comment

begin_decl_stmt
name|int
name|rawmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Packet version number we use  */
end_comment

begin_decl_stmt
name|u_char
name|pktversion
init|=
name|NTP_OLDVERSION
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Don't jump if no set jmp.  */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Format values  */
end_comment

begin_define
define|#
directive|define
name|PADDING
value|0
end_define

begin_define
define|#
directive|define
name|HA
value|1
end_define

begin_comment
comment|/* host address */
end_comment

begin_define
define|#
directive|define
name|NA
value|2
end_define

begin_comment
comment|/* network address */
end_comment

begin_define
define|#
directive|define
name|LP
value|3
end_define

begin_comment
comment|/* leap (print in binary) */
end_comment

begin_define
define|#
directive|define
name|RF
value|4
end_define

begin_comment
comment|/* refid (sometimes string, sometimes not) */
end_comment

begin_define
define|#
directive|define
name|AR
value|5
end_define

begin_comment
comment|/* array of times */
end_comment

begin_define
define|#
directive|define
name|FX
value|6
end_define

begin_comment
comment|/* test flags */
end_comment

begin_define
define|#
directive|define
name|TS
value|7
end_define

begin_comment
comment|/* l_fp timestamp in hex */
end_comment

begin_define
define|#
directive|define
name|OC
value|8
end_define

begin_comment
comment|/* integer, print in octal */
end_comment

begin_define
define|#
directive|define
name|EOV
value|255
end_define

begin_comment
comment|/* end of table */
end_comment

begin_comment
comment|/*  * For the most part ntpq simply displays what ntpd provides in the  * mostly plain-text mode 6 responses.  A few variable names are by  * default "cooked" to provide more human-friendly output.  */
end_comment

begin_decl_stmt
specifier|const
name|var_format
name|cookedvars
index|[]
init|=
block|{
block|{
literal|"leap"
block|,
name|LP
block|}
block|,
block|{
literal|"reach"
block|,
name|OC
block|}
block|,
block|{
literal|"refid"
block|,
name|RF
block|}
block|,
block|{
literal|"reftime"
block|,
name|TS
block|}
block|,
block|{
literal|"clock"
block|,
name|TS
block|}
block|,
block|{
literal|"org"
block|,
name|TS
block|}
block|,
block|{
literal|"rec"
block|,
name|TS
block|}
block|,
block|{
literal|"xmt"
block|,
name|TS
block|}
block|,
block|{
literal|"flash"
block|,
name|FX
block|}
block|,
block|{
literal|"srcadr"
block|,
name|HA
block|}
block|,
block|{
literal|"peeradr"
block|,
name|HA
block|}
block|,
comment|/* compat with others */
block|{
literal|"dstadr"
block|,
name|NA
block|}
block|,
block|{
literal|"filtdelay"
block|,
name|AR
block|}
block|,
block|{
literal|"filtoffset"
block|,
name|AR
block|}
block|,
block|{
literal|"filtdisp"
block|,
name|AR
block|}
block|,
block|{
literal|"filterror"
block|,
name|AR
block|}
block|,
comment|/* compat with others */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * flasher bits  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tstflagnames
index|[]
init|=
block|{
literal|"pkt_dup"
block|,
comment|/* TEST1 */
literal|"pkt_bogus"
block|,
comment|/* TEST2 */
literal|"pkt_unsync"
block|,
comment|/* TEST3 */
literal|"pkt_denied"
block|,
comment|/* TEST4 */
literal|"pkt_auth"
block|,
comment|/* TEST5 */
literal|"pkt_stratum"
block|,
comment|/* TEST6 */
literal|"pkt_header"
block|,
comment|/* TEST7 */
literal|"pkt_autokey"
block|,
comment|/* TEST8 */
literal|"pkt_crypto"
block|,
comment|/* TEST9 */
literal|"peer_stratum"
block|,
comment|/* TEST10 */
literal|"peer_dist"
block|,
comment|/* TEST11 */
literal|"peer_loop"
block|,
comment|/* TEST12 */
literal|"peer_unreach"
comment|/* TEST13 */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ntpqmain
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built in command handler declarations  */
end_comment

begin_function_decl
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_hex_printable
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|u_short
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
parameter_list|,
name|associd_t
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tstflags
parameter_list|(
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_function_decl
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_WINNT
end_ifndef

begin_function_decl
specifier|static
name|int
name|abortcmd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_function_decl
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getarg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|arg_v
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUILD_AS_LIB */
end_comment

begin_function_decl
specifier|static
name|int
name|findcmd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtdatetolfp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decodearr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|auth_delay
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntp_poll
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|showdrefid
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|raw
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cooked
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|authenticate
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntpversion
parameter_list|(
name|struct
name|parse
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|1
operator|,
function_decl|2
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atoascii
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cookedprint
parameter_list|(
name|int
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rawprint
parameter_list|(
name|int
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|startoutput
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|endoutput
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outputarr
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assoccmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|on_ctrlc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|varfmt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|my_easprintf
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|NTP_PRINTF
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|ntpq_custom_opt_handler
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVP_MD_DO_ALL_SORTED
end_ifdef

begin_function_decl
specifier|static
name|void
name|list_md_fn
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|list_digest_names
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Built-in commands we understand  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|builtins
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"help"
block|,
name|help
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"command"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"tell the use and syntax of commands"
block|}
block|,
block|{
literal|"timeout"
block|,
name|timeout
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the primary receive time out"
block|}
block|,
block|{
literal|"delay"
block|,
name|auth_delay
block|,
block|{
name|OPT
operator||
name|NTP_INT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"msec"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the delay added to encryption time stamps"
block|}
block|,
block|{
literal|"host"
block|,
name|host
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"-4|-6"
block|,
literal|"hostname"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify the host whose NTP server we talk to"
block|}
block|,
block|{
literal|"poll"
block|,
name|ntp_poll
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"n"
block|,
literal|"verbose"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"poll an NTP server in client mode `n' times"
block|}
block|,
block|{
literal|"passwd"
block|,
name|passwd
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify a password to use for authenticated requests"
block|}
block|,
block|{
literal|"hostnames"
block|,
name|hostnames
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"specify whether hostnames or net numbers are printed"
block|}
block|,
block|{
literal|"debug"
block|,
name|setdebug
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"no|more|less"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set/change debugging level"
block|}
block|,
block|{
literal|"quit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpq"
block|}
block|,
block|{
literal|"exit"
block|,
name|quit
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"exit ntpq"
block|}
block|,
block|{
literal|"keyid"
block|,
name|keyid
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key#"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set keyid to use for authenticated requests"
block|}
block|,
block|{
literal|"drefid"
block|,
name|showdrefid
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"hash|ipv4"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"display refid's as IPv4 or hash"
block|}
block|,
block|{
literal|"version"
block|,
name|version
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print version number"
block|}
block|,
block|{
literal|"raw"
block|,
name|raw
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do raw mode variable output"
block|}
block|,
block|{
literal|"cooked"
block|,
name|cooked
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"do cooked mode variable output"
block|}
block|,
block|{
literal|"authenticate"
block|,
name|authenticate
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"yes|no"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"always authenticate requests to this server"
block|}
block|,
block|{
literal|"ntpversion"
block|,
name|ntpversion
block|,
block|{
name|OPT
operator||
name|NTP_UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"version number"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"set the NTP version number to use for requests"
block|}
block|,
block|{
literal|"keytype"
block|,
name|keytype
block|,
block|{
name|OPT
operator||
name|NTP_STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"key type %s"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
name|NULL
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default values we use.  */
end_comment

begin_define
define|#
directive|define
name|DEFHOST
value|"localhost"
end_define

begin_comment
comment|/* default host name */
end_comment

begin_define
define|#
directive|define
name|DEFTIMEOUT
value|5
end_define

begin_comment
comment|/* wait 5 seconds for 1st pkt */
end_comment

begin_define
define|#
directive|define
name|DEFSTIMEOUT
value|3
end_define

begin_comment
comment|/* and 3 more for each additional */
end_comment

begin_comment
comment|/*  * Requests are automatically retried once, so total timeout with no  * response is a bit over 2 * DEFTIMEOUT, or 10 seconds.  At the other  * extreme, a request eliciting 32 packets of responses each for some  * reason nearly DEFSTIMEOUT seconds after the prior in that series,  * with a single packet dropped, would take around 32 * DEFSTIMEOUT, or  * 93 seconds to fail each of two times, or 186 seconds.  * Some commands involve a series of requests, such as "peers" and  * "mrulist", so the cumulative timeouts are even longer for those.  */
end_comment

begin_define
define|#
directive|define
name|DEFDELAY
value|0x51EB852
end_define

begin_comment
comment|/* 20 milliseconds, l_fp fraction */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_define
define|#
directive|define
name|MAXCMDS
value|100
end_define

begin_comment
comment|/* maximum commands on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTS
value|200
end_define

begin_comment
comment|/* maximum hosts on cmd line */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|512
end_define

begin_comment
comment|/* maximum line length */
end_comment

begin_define
define|#
directive|define
name|MAXTOKENS
value|(1+MAXARGS+2)
end_define

begin_comment
comment|/* maximum number of usable tokens */
end_comment

begin_define
define|#
directive|define
name|MAXVARLEN
value|256
end_define

begin_comment
comment|/* maximum length of a variable name */
end_comment

begin_define
define|#
directive|define
name|MAXVALLEN
value|2048
end_define

begin_comment
comment|/* maximum length of a variable value */
end_comment

begin_define
define|#
directive|define
name|MAXOUTLINE
value|72
end_define

begin_comment
comment|/* maximum length of an output line */
end_comment

begin_define
define|#
directive|define
name|SCREENWIDTH
value|76
end_define

begin_comment
comment|/* nominal screen width in columns */
end_comment

begin_comment
comment|/*  * Some variables used and manipulated locally  */
end_comment

begin_decl_stmt
name|struct
name|sock_timeval
name|tvout
init|=
block|{
name|DEFTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time out for reads */
end_comment

begin_decl_stmt
name|struct
name|sock_timeval
name|tvsout
init|=
block|{
name|DEFSTIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* secondary time out */
end_comment

begin_decl_stmt
name|l_fp
name|delay_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay time */
end_comment

begin_decl_stmt
name|char
name|currenthost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current host name */
end_comment

begin_decl_stmt
name|int
name|currenthostisnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is prior text from IP? */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host address */
end_comment

begin_decl_stmt
name|int
name|showhostnames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show host names by default */
end_comment

begin_decl_stmt
name|int
name|wideremote
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show wide remote names? */
end_comment

begin_decl_stmt
name|int
name|ai_fam_templ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address family */
end_comment

begin_decl_stmt
name|int
name|ai_fam_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default address family */
end_comment

begin_decl_stmt
name|SOCKET
name|sockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd socket is opened on */
end_comment

begin_decl_stmt
name|int
name|havehost
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to 1 when host open */
end_comment

begin_decl_stmt
name|int
name|s_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|servent
modifier|*
name|server_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* server entry for ntp */
end_comment

begin_comment
comment|/*  * Sequence number used for requests.  It is incremented before  * it is used.  */
end_comment

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Holds data returned from queries.  Declare buffer long to be sure of  * alignment.  */
end_comment

begin_define
define|#
directive|define
name|DATASIZE
value|(MAXFRAGS*480)
end_define

begin_comment
comment|/* maximum amount of data */
end_comment

begin_decl_stmt
name|long
name|pktdata
index|[
name|DATASIZE
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * assoc_cache[] is a dynamic array which allows references to  * associations using&1 ...&N for n associations, avoiding manual  * lookup of the current association IDs for a given ntpd.  It also  * caches the status word for each association, retrieved incidentally.  */
end_comment

begin_decl_stmt
name|struct
name|association
modifier|*
name|assoc_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|assoc_cache_slots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of allocated array entries */
end_comment

begin_decl_stmt
name|u_int
name|numassoc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached associations */
end_comment

begin_comment
comment|/*  * For commands typed on the command line (with the -c option)  */
end_comment

begin_decl_stmt
name|int
name|numcmds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ccmds
index|[
name|MAXCMDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDCMD
parameter_list|(
name|cp
parameter_list|)
value|if (numcmds< MAXCMDS) ccmds[numcmds++] = (cp)
end_define

begin_comment
comment|/*  * When multiple hosts are specified.  */
end_comment

begin_decl_stmt
name|u_int
name|numhosts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chost
name|chosts
index|[
name|MAXHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADDHOST
parameter_list|(
name|cp
parameter_list|)
define|\
value|do {							\ 		if (numhosts< MAXHOSTS) {			\ 			chosts[numhosts].name = (cp);		\ 			chosts[numhosts].fam = ai_fam_templ;	\ 			numhosts++;				\ 		}						\ 	} while (0)
end_define

begin_comment
comment|/*  * Macro definitions we use  */
end_comment

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_define
define|#
directive|define
name|ISEOL
parameter_list|(
name|c
parameter_list|)
value|((c) == '\n' || (c) == '\r' || (c) == '\0')
end_define

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * Jump buffer for longjumping back to the command level  */
end_comment

begin_decl_stmt
name|jmp_buf
name|interrupt_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Points at file being currently printed into  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|current_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Command table imported from ntpdc_ops.c  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|xcmd
name|opcmds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MAIN_ALLOWED
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_expr_stmt
name|CALL
argument_list|(
name|ntpq
argument_list|,
literal|"ntpq"
argument_list|,
name|ntpqmain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|clear_globals
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
name|showhostnames
operator|=
literal|0
expr_stmt|;
comment|/* don'tshow host names by default */
name|ntp_optind
operator|=
literal|0
expr_stmt|;
name|server_entry
operator|=
name|NULL
expr_stmt|;
comment|/* server entry for ntp */
name|havehost
operator|=
literal|0
expr_stmt|;
comment|/* set to 1 when host open */
name|numassoc
operator|=
literal|0
expr_stmt|;
comment|/* number of cached associations */
name|numcmds
operator|=
literal|0
expr_stmt|;
name|numhosts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_MAIN_ALLOWED */
end_comment

begin_comment
comment|/*  * main - parse arguments and handle options  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAIN_ALLOWED
end_ifndef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
return|return
name|ntpqmain
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_function
name|int
name|ntpqmain
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|u_int
name|ihost
decl_stmt|;
name|int
name|icmd
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
name|clear_globals
argument_list|()
expr_stmt|;
name|taskPrioritySet
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delay_time
operator|.
name|l_ui
operator|=
literal|0
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|DEFDELAY
expr_stmt|;
name|init_lib
argument_list|()
expr_stmt|;
comment|/* sets up ipv4_works, ipv6_works */
name|ssl_applink
argument_list|()
expr_stmt|;
name|init_auth
argument_list|()
expr_stmt|;
comment|/* Check to see if we have IPv6. Otherwise default to IPv4 */
if|if
condition|(
operator|!
name|ipv6_works
condition|)
name|ai_fam_default
operator|=
name|AF_INET
expr_stmt|;
comment|/* Fixup keytype's help based on available digest names */
block|{
name|char
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|list
operator|=
name|list_digest_names
argument_list|()
expr_stmt|;
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
condition|;
name|icmd
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"keytype"
argument_list|,
name|builtins
index|[
name|icmd
index|]
operator|.
name|keyword
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* CID: 1295478 */
comment|/* This should only "trip" if "keytype" is removed from builtins */
name|INSIST
argument_list|(
name|icmd
operator|<
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|builtins
index|[
name|icmd
index|]
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|"digest-name"
expr_stmt|;
name|my_easprintf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"set key type to use for authenticated requests, one of:%s"
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|#
directive|else
name|builtins
index|[
name|icmd
index|]
operator|.
name|desc
index|[
literal|0
index|]
operator|=
literal|"md5"
expr_stmt|;
name|my_easprintf
argument_list|(
operator|&
name|msg
argument_list|,
literal|"set key type to use for authenticated requests (%s)"
argument_list|,
name|list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|builtins
index|[
name|icmd
index|]
operator|.
name|comment
operator|=
name|msg
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|{
name|int
name|optct
init|=
name|ntpOptionProcess
argument_list|(
operator|&
name|ntpqOptions
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|argc
operator|-=
name|optct
expr_stmt|;
name|argv
operator|+=
name|optct
expr_stmt|;
block|}
comment|/* 	 * Process options other than -c and -p, which are specially 	 * handled by ntpq_custom_opt_handler(). 	 */
name|debug
operator|=
name|OPT_VALUE_SET_DEBUG_LEVEL
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV4
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV6
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|INTERACTIVE
argument_list|)
condition|)
name|interactive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|NUMERIC
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|WIDE
argument_list|)
condition|)
name|wideremote
operator|=
literal|1
expr_stmt|;
name|old_rv
operator|=
name|HAVE_OPT
argument_list|(
name|OLD_RV
argument_list|)
expr_stmt|;
name|drefid
operator|=
name|OPT_VALUE_REFID
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|argc
condition|)
block|{
name|ADDHOST
argument_list|(
name|DEFHOST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
operator|(
name|u_int
operator|)
name|argc
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
literal|'-'
operator|==
operator|*
name|argv
index|[
name|ihost
index|]
condition|)
block|{
comment|//
comment|// If I really cared I'd also check:
comment|// 0 == argv[ihost][2]
comment|//
comment|// and there are other cases as well...
comment|//
if|if
condition|(
literal|'4'
operator|==
name|argv
index|[
name|ihost
index|]
index|[
literal|1
index|]
condition|)
block|{
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|'6'
operator|==
name|argv
index|[
name|ihost
index|]
index|[
literal|1
index|]
condition|)
block|{
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|// XXX Throw a usage error
block|}
block|}
name|ADDHOST
argument_list|(
name|argv
index|[
name|ihost
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numcmds
operator|==
literal|0
operator|&&
name|interactive
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
condition|)
block|{
name|interactive
operator|=
literal|1
expr_stmt|;
block|}
name|set_ctrl_c_hook
argument_list|(
name|on_ctrlc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
comment|/* Under NT cannot handle SIGINT, WIN32 spawns a handler */
if|if
condition|(
name|interactive
condition|)
name|push_ctrl_c_handler
argument_list|(
name|abortcmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
if|if
condition|(
name|numcmds
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|openhost
argument_list|(
name|chosts
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|chosts
index|[
literal|0
index|]
operator|.
name|fam
argument_list|)
expr_stmt|;
name|getcmds
argument_list|()
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ihost
operator|=
literal|0
init|;
name|ihost
operator|<
name|numhosts
condition|;
name|ihost
operator|++
control|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|chosts
index|[
name|ihost
index|]
operator|.
name|name
argument_list|,
name|chosts
index|[
name|ihost
index|]
operator|.
name|fam
argument_list|)
condition|)
for|for
control|(
name|icmd
operator|=
literal|0
init|;
name|icmd
operator|<
name|numcmds
condition|;
name|icmd
operator|++
control|)
name|docmd
argument_list|(
name|ccmds
index|[
name|icmd
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SYS_WINNT
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_WINNT */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_comment
comment|/*  * openhost - open a socket to a host  */
end_comment

begin_function
specifier|static
name|int
name|openhost
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|,
name|int
name|fam
parameter_list|)
block|{
specifier|const
name|char
name|svc
index|[]
init|=
literal|"ntp"
decl_stmt|;
name|char
name|temphost
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|int
name|a_info
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|name
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
comment|/* 	 * We need to get by the [] if they were entered 	 */
name|cp
operator|=
name|hname
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
condition|)
block|{
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|']'
condition|;
name|cp
operator|++
operator|,
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|']'
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * First try to resolve it as an ip address and if that fails, 	 * do a fullblown (dns) lookup. That way we only use the dns 	 * when it is needed and work around some implementations that 	 * will return an "IPv4-mapped IPv6 address" address if you 	 * give it an IPv4 address to lookup. 	 */
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|fam
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|Z_AI_NUMERICHOST
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|svc
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_info
operator|==
name|EAI_NONAME
ifdef|#
directive|ifdef
name|EAI_NODATA
operator|||
name|a_info
operator|==
name|EAI_NODATA
endif|#
directive|endif
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|svc
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
comment|/* Some older implementations don't like AI_ADDRCONFIG. */
if|if
condition|(
name|a_info
operator|==
name|EAI_BADFLAGS
condition|)
block|{
name|hints
operator|.
name|ai_flags
operator|&=
operator|~
name|AI_ADDRCONFIG
expr_stmt|;
name|a_info
operator|=
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
name|svc
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|a_info
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gai_strerror
argument_list|(
name|a_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|INSIST
argument_list|(
name|ai
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|octets
operator|=
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|octets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|temphost
argument_list|,
name|stoa
argument_list|(
operator|&
name|addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|temphost
argument_list|)
argument_list|)
expr_stmt|;
name|currenthostisnum
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|strlcpy
argument_list|(
name|temphost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
sizeof|sizeof
argument_list|(
name|temphost
argument_list|)
argument_list|)
expr_stmt|;
name|currenthostisnum
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Opening host %s (%s)\n"
argument_list|,
name|temphost
argument_list|,
operator|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET
operator|)
condition|?
literal|"AF_INET"
else|:
operator|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|)
condition|?
literal|"AF_INET6"
else|:
literal|"AF-???"
argument_list|)
expr_stmt|;
if|if
condition|(
name|havehost
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Closing old host %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
name|havehost
operator|=
literal|0
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|currenthost
argument_list|,
name|temphost
argument_list|,
sizeof|sizeof
argument_list|(
name|currenthost
argument_list|)
argument_list|)
expr_stmt|;
comment|/* port maps to the same location in both families */
name|s_port
operator|=
name|NSRCPORT
argument_list|(
operator|&
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_VXWORKS
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|SERVER_PORT_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET
condition|)
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
else|else
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|hostaddr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS_VXWORKS */
ifdef|#
directive|ifdef
name|SYS_WINNT
block|{
name|int
name|optionValue
init|=
name|SO_SYNCHRONOUS_NONALERT
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|setsockopt
argument_list|(
name|INVALID_SOCKET
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OPENTYPE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|optionValue
argument_list|,
sizeof|sizeof
argument_list|(
name|optionValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mfprintf
argument_list|(
name|stderr
argument_list|,
literal|"setsockopt(SO_SYNCHRONOUS_NONALERT)"
literal|" error: %m\n"
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYS_WINNT */
name|sockfd
operator|=
name|socket
argument_list|(
name|ai
operator|->
name|ai_family
argument_list|,
name|ai
operator|->
name|ai_socktype
argument_list|,
name|ai
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockfd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|error
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NEED_RCVBUF_SLOP
ifdef|#
directive|ifdef
name|SO_RCVBUF
block|{
name|int
name|rbufsize
init|=
name|DATASIZE
operator|+
literal|2048
decl_stmt|;
comment|/* 2K for slop */
if|if
condition|(
name|setsockopt
argument_list|(
name|sockfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rbufsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"setsockopt"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
ifdef|#
directive|ifdef
name|SYS_VXWORKS
condition|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hostaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|hostaddr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
operator|(
name|connect
argument_list|(
name|sockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
operator|==
operator|-
literal|1
operator|)
endif|#
directive|endif
comment|/* SYS_VXWORKS */
block|{
name|error
argument_list|(
literal|"connect"
argument_list|)
block|;
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|havehost
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|numassoc
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_function
unit|}   static
name|void
name|dump_hex_printable
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cdata
decl_stmt|;
specifier|const
name|char
modifier|*
name|rowstart
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|size_t
name|rowlen
decl_stmt|;
name|u_char
name|uch
decl_stmt|;
name|cdata
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|rowstart
operator|=
name|cdata
expr_stmt|;
name|rowlen
operator|=
name|min
argument_list|(
literal|16
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|rowlen
condition|;
name|idx
operator|++
control|)
block|{
name|uch
operator|=
operator|*
operator|(
name|cdata
operator|++
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|uch
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|idx
operator|<
literal|16
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|cdata
operator|=
name|rowstart
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|rowlen
condition|;
name|idx
operator|++
control|)
block|{
name|uch
operator|=
operator|*
operator|(
name|cdata
operator|++
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|isprint
argument_list|(
name|uch
argument_list|)
operator|)
condition|?
name|uch
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|len
operator|-=
name|rowlen
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX ELIMINATE sendpkt similar in ntpq.c, ntpdc.c, ntp_io.c, ntptrace.c */
end_comment

begin_comment
comment|/*  * sendpkt - send a packet to the remote host  */
end_comment

begin_function
specifier|static
name|int
name|sendpkt
parameter_list|(
name|void
modifier|*
name|xdata
parameter_list|,
name|size_t
name|xdatalen
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"Sending %zu octets\n"
argument_list|,
name|xdatalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|sockfd
argument_list|,
name|xdata
argument_list|,
name|xdatalen
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"write to %s failed"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"Request packet:\n"
argument_list|)
expr_stmt|;
name|dump_hex_printable
argument_list|(
name|xdata
argument_list|,
name|xdatalen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * getresponse - get a (series of) response packet(s) and return the data  */
end_comment

begin_function
specifier|static
name|int
name|getresponse
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|associd
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|timeo
parameter_list|)
block|{
name|struct
name|ntp_control
name|rpkt
decl_stmt|;
name|struct
name|sock_timeval
name|tvo
decl_stmt|;
name|u_short
name|offsets
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|counts
index|[
name|MAXFRAGS
operator|+
literal|1
index|]
decl_stmt|;
name|u_short
name|offset
decl_stmt|;
name|u_short
name|count
decl_stmt|;
name|size_t
name|numfrags
decl_stmt|;
name|size_t
name|f
decl_stmt|;
name|size_t
name|ff
decl_stmt|;
name|int
name|seenlastfrag
decl_stmt|;
name|int
name|shouldbesize
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|errcode
decl_stmt|;
comment|/* absolute timeout checks. Not 'time_t' by intention! */
name|uint32_t
name|tobase
decl_stmt|;
comment|/* base value for timeout */
name|uint32_t
name|tospan
decl_stmt|;
comment|/* timeout span (max delay) */
name|uint32_t
name|todiff
decl_stmt|;
comment|/* current delay */
comment|/* 	 * This is pretty tricky.  We may get between 1 and MAXFRAG packets 	 * back in response to the request.  We peel the data out of 	 * each packet and collect it in one long block.  When the last 	 * packet in the sequence is received we'll know how much data we 	 * should have had.  Note we use one long time out, should reconsider. 	 */
operator|*
name|rsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstatus
condition|)
operator|*
name|rstatus
operator|=
literal|0
expr_stmt|;
operator|*
name|rdata
operator|=
operator|(
name|char
operator|*
operator|)
name|pktdata
expr_stmt|;
name|numfrags
operator|=
literal|0
expr_stmt|;
name|seenlastfrag
operator|=
literal|0
expr_stmt|;
name|tobase
operator|=
operator|(
name|uint32_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
comment|/* 	 * Loop until we have an error or a complete response.  Nearly all 	 * code paths to loop again use continue. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
name|tvo
operator|=
name|tvout
expr_stmt|;
else|else
name|tvo
operator|=
name|tvsout
expr_stmt|;
name|tospan
operator|=
operator|(
name|uint32_t
operator|)
name|tvo
operator|.
name|tv_sec
operator|+
operator|(
name|tvo
operator|.
name|tv_usec
operator|!=
literal|0
operator|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sockfd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sockfd
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
name|defined
argument_list|(
name|EINTR
argument_list|)
comment|/* Windows does not know about EINTR (until very 			 * recently) and the handling of console events 			 * is *very* different from POSIX/UNIX signal 			 * handling anyway. 			 * 			 * Under non-windows targets we map EINTR as 			 * 'last packet was received' and try to exit 			 * the receive sequence. 			 */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|seenlastfrag
operator|=
literal|1
expr_stmt|;
goto|goto
name|maybe_final
goto|;
block|}
endif|#
directive|endif
name|warning
argument_list|(
literal|"select fails"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * Check if this is already too late. Trash the data and 		 * fake a timeout if this is so. 		 */
name|todiff
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|-
name|tobase
operator|)
operator|&
literal|0x7FFFFFFFu
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|>
literal|0
operator|)
operator|&&
operator|(
name|todiff
operator|>
name|tospan
operator|)
condition|)
block|{
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
comment|/* faked timeout return from 'select()'*/
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Timed out.  Return what we have 			 */
if|if
condition|(
name|numfrags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeo
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out, nothing received\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
return|return
name|ERR_TIMEOUT
return|;
block|}
if|if
condition|(
name|timeo
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: timed out with incomplete data\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERR_INCOMPLETE: Received fragments:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|numfrags
condition|;
name|f
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2u: %5d %5d\t%3d octets\n"
argument_list|,
operator|(
name|u_int
operator|)
name|f
argument_list|,
name|offsets
index|[
name|f
index|]
argument_list|,
name|offsets
index|[
name|f
index|]
operator|+
name|counts
index|[
name|f
index|]
argument_list|,
name|counts
index|[
name|f
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"last fragment %sreceived\n"
argument_list|,
operator|(
name|seenlastfrag
operator|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
return|return
name|ERR_INCOMPLETE
return|;
block|}
name|n
operator|=
name|recv
argument_list|(
name|sockfd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"Response packet:\n"
argument_list|)
expr_stmt|;
name|dump_hex_printable
argument_list|(
operator|&
name|rpkt
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check for format errors.  Bug proofing. 		 */
if|if
condition|(
name|n
operator|<
operator|(
name|int
operator|)
name|CTL_HEADER_LEN
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Short (%d byte) packet received\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|>
name|NTP_VERSION
operator|||
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|<
name|NTP_OLDVERSION
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with version %d\n"
argument_list|,
name|PKT_VERSION
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
operator|!=
name|MODE_CONTROL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Packet received with mode %d\n"
argument_list|,
name|PKT_MODE
argument_list|(
name|rpkt
operator|.
name|li_vn_mode
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|CTL_ISRESPONSE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received request packet, wanted response\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check opcode and sequence number for a match. 		 * Could be old data getting to us. 		 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
operator|!=
name|sequence
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received sequnce number %d, wanted %d\n"
argument_list|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|sequence
argument_list|)
argument_list|,
name|sequence
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
operator|!=
name|opcode
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Received opcode %d, wanted %d (sequence number okay)\n"
argument_list|,
name|CTL_OP
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check the error code.  If non-zero, return it. 		 */
if|if
condition|(
name|CTL_ISERROR
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|errcode
operator|=
operator|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Error code %d received on not-final packet\n"
operator|,
name|errcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
name|CERR_UNSPEC
condition|)
return|return
name|ERR_UNSPEC
return|;
return|return
name|errcode
return|;
block|}
comment|/* 		 * Check the association ID to make sure it matches what 		 * we sent. 		 */
if|if
condition|(
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
operator|!=
name|associd
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Association ID %d doesn't match expected %d\n"
operator|,
name|ntohs
argument_list|(
name|rpkt
operator|.
name|associd
argument_list|)
operator|,
name|associd
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Hack for silly fuzzballs which, at the time of writing, 			 * return an assID of sys.peer when queried for system variables. 			 */
ifdef|#
directive|ifdef
name|notdef
continue|continue;
endif|#
directive|endif
block|}
comment|/* 		 * Collect offset and count.  Make sure they make sense. 		 */
name|offset
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|count
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* 		 * validate received payload size is padded to next 32-bit 		 * boundary and no smaller than claimed by rpkt.count 		 */
if|if
condition|(
name|n
operator|&
literal|0x3
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Response packet not padded, size = %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|shouldbesize
operator|=
operator|(
name|CTL_HEADER_LEN
operator|+
name|count
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|shouldbesize
condition|)
block|{
name|printf
argument_list|(
literal|"Response packet claims %u octets payload, above %ld received\n"
argument_list|,
name|count
argument_list|,
call|(
name|long
call|)
argument_list|(
name|n
operator|-
name|CTL_HEADER_LEN
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ERR_INCOMPLETE
return|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|3
operator|&&
name|shouldbesize
operator|>
name|n
condition|)
block|{
name|u_int32
name|key
decl_stmt|;
name|u_int32
modifier|*
name|lpkt
decl_stmt|;
name|int
name|maclen
decl_stmt|;
comment|/* 			 * Usually we ignore authentication, but for debugging purposes 			 * we watch it here. 			 */
comment|/* round to 8 octet boundary */
name|shouldbesize
operator|=
operator|(
name|shouldbesize
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|maclen
operator|=
name|n
operator|-
name|shouldbesize
expr_stmt|;
if|if
condition|(
name|maclen
operator|>=
operator|(
name|int
operator|)
name|MIN_MAC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"Packet shows signs of authentication (total %d, data %d, mac %d)\n"
argument_list|,
name|n
argument_list|,
name|shouldbesize
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
name|lpkt
operator|=
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
expr_stmt|;
name|printf
argument_list|(
literal|"%08lx %08lx %08lx %08lx %08lx %08lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|3
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|2
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|+
literal|1
index|]
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|+
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|ntohl
argument_list|(
name|lpkt
index|[
operator|(
name|n
operator|-
name|maclen
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Authenticated with keyid %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|0
operator|&&
name|key
operator|!=
name|info_auth_keyid
condition|)
block|{
name|printf
argument_list|(
literal|"We don't know that key\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|authdecrypt
argument_list|(
name|key
argument_list|,
operator|(
name|u_int32
operator|*
operator|)
operator|&
name|rpkt
argument_list|,
name|n
operator|-
name|maclen
argument_list|,
name|maclen
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Auth okay!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Auth failed!\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Got packet, size = %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
operator|(
name|n
operator|-
name|CTL_HEADER_LEN
operator|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Received count of %u octets, data in packet is %ld\n"
operator|,
name|count
operator|,
operator|(
name|long
operator|)
name|n
operator|-
name|CTL_HEADER_LEN
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Received count of 0 in non-final fragment\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|offset
operator|+
name|count
operator|>
sizeof|sizeof
argument_list|(
name|pktdata
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Offset %u, count %u, too big for buffer\n"
operator|,
name|offset
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
if|if
condition|(
name|seenlastfrag
operator|&&
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Received second last fragment packet\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * So far, so good.  Record this fragment, making sure it doesn't 		 * overlap anything. 		 */
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Packet okay\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfrags
operator|>
operator|(
name|MAXFRAGS
operator|-
literal|1
operator|)
condition|)
block|{
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Number of fragments exceeds maximum %d\n"
operator|,
name|MAXFRAGS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERR_TOOMUCH
return|;
block|}
comment|/* 		 * Find the position for the fragment relative to any 		 * previously received. 		 */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|numfrags
operator|&&
name|offsets
index|[
name|f
index|]
operator|<
name|offset
condition|;
name|f
operator|++
control|)
block|{
comment|/* empty body */
empty_stmt|;
block|}
if|if
condition|(
name|f
operator|<
name|numfrags
operator|&&
name|offset
operator|==
name|offsets
index|[
name|f
index|]
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"duplicate %u octets at %u ignored, prior %u at %u\n"
operator|,
name|count
operator|,
name|offset
operator|,
name|counts
index|[
name|f
index|]
operator|,
name|offsets
index|[
name|f
index|]
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f
operator|>
literal|0
operator|&&
operator|(
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
operator|)
operator|>
name|offset
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"received frag at %u overlaps with %u octet frag at %u\n"
operator|,
name|offset
operator|,
name|counts
index|[
name|f
operator|-
literal|1
index|]
operator|,
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f
operator|<
name|numfrags
operator|&&
operator|(
name|offset
operator|+
name|count
operator|)
operator|>
name|offsets
index|[
name|f
index|]
condition|)
block|{
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"received %u octet frag at %u overlaps with frag at %u\n"
operator|,
name|count
operator|,
name|offset
operator|,
name|offsets
index|[
name|f
index|]
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|ff
operator|=
name|numfrags
init|;
name|ff
operator|>
name|f
condition|;
name|ff
operator|--
control|)
block|{
name|offsets
index|[
name|ff
index|]
operator|=
name|offsets
index|[
name|ff
operator|-
literal|1
index|]
expr_stmt|;
name|counts
index|[
name|ff
index|]
operator|=
name|counts
index|[
name|ff
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|offsets
index|[
name|f
index|]
operator|=
name|offset
expr_stmt|;
name|counts
index|[
name|f
index|]
operator|=
name|count
expr_stmt|;
name|numfrags
operator|++
expr_stmt|;
comment|/* 		 * Got that stuffed in right.  Figure out if this was the last. 		 * Record status info out of the last packet. 		 */
if|if
condition|(
operator|!
name|CTL_ISMORE
argument_list|(
name|rpkt
operator|.
name|r_m_e_op
argument_list|)
condition|)
block|{
name|seenlastfrag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rstatus
operator|!=
literal|0
condition|)
operator|*
name|rstatus
operator|=
name|ntohs
argument_list|(
name|rpkt
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Copy the data into the data buffer, and bump the 		 * timout base in case we need more. 		 */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pktdata
operator|+
name|offset
argument_list|,
operator|&
name|rpkt
operator|.
name|u
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|tobase
operator|=
operator|(
name|uint32_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If we've seen the last fragment, look for holes in the sequence. 		 * If there aren't any, we're done. 		 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
name|defined
argument_list|(
name|EINTR
argument_list|)
name|maybe_final
label|:
endif|#
directive|endif
if|if
condition|(
name|seenlastfrag
operator|&&
name|offsets
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|f
operator|=
literal|1
init|;
name|f
operator|<
name|numfrags
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
operator|!=
name|offsets
index|[
name|f
index|]
condition|)
break|break;
if|if
condition|(
name|f
operator|==
name|numfrags
condition|)
block|{
operator|*
name|rsize
operator|=
name|offsets
index|[
name|f
operator|-
literal|1
index|]
operator|+
name|counts
index|[
name|f
operator|-
literal|1
index|]
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%lu packets reassembled into response\n"
operator|,
operator|(
name|u_long
operator|)
name|numfrags
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* giant for (;;) collecting response packets */
block|}
end_function

begin_comment
comment|/* getresponse() */
end_comment

begin_comment
comment|/*  * sendrequest - format and send a request packet  */
end_comment

begin_function
specifier|static
name|int
name|sendrequest
parameter_list|(
name|int
name|opcode
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|size_t
name|qsize
parameter_list|,
specifier|const
name|char
modifier|*
name|qdata
parameter_list|)
block|{
name|struct
name|ntp_control
name|qpkt
decl_stmt|;
name|size_t
name|pktsize
decl_stmt|;
name|u_long
name|key_id
decl_stmt|;
name|char
modifier|*
name|pass
decl_stmt|;
name|size_t
name|maclen
decl_stmt|;
comment|/* 	 * Check to make sure the data will fit in one packet 	 */
if|if
condition|(
name|qsize
operator|>
name|CTL_MAX_DATA_LEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Internal error!  qsize (%zu) too large\n"
argument_list|,
name|qsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Fill in the packet 	 */
name|qpkt
operator|.
name|li_vn_mode
operator|=
name|PKT_LI_VN_MODE
argument_list|(
literal|0
argument_list|,
name|pktversion
argument_list|,
name|MODE_CONTROL
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|r_m_e_op
operator|=
call|(
name|u_char
call|)
argument_list|(
name|opcode
operator|&
name|CTL_OP_MASK
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|sequence
operator|=
name|htons
argument_list|(
name|sequence
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|associd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|associd
argument_list|)
expr_stmt|;
name|qpkt
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|qpkt
operator|.
name|count
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|qsize
argument_list|)
expr_stmt|;
name|pktsize
operator|=
name|CTL_HEADER_LEN
expr_stmt|;
comment|/* 	 * If we have data, copy and pad it out to a 32-bit boundary. 	 */
if|if
condition|(
name|qsize
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|qpkt
operator|.
name|u
argument_list|,
name|qdata
argument_list|,
operator|(
name|size_t
operator|)
name|qsize
argument_list|)
expr_stmt|;
name|pktsize
operator|+=
name|qsize
expr_stmt|;
while|while
condition|(
name|pktsize
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|u_int32
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|qpkt
operator|.
name|u
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If it isn't authenticated we can just send it.  Otherwise 	 * we're going to have to think about it a little. 	 */
if|if
condition|(
operator|!
name|auth
operator|&&
operator|!
name|always_auth
condition|)
block|{
return|return
name|sendpkt
argument_list|(
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
return|;
block|}
comment|/* 	 * Pad out packet to a multiple of 8 octets to be sure 	 * receiver can handle it. 	 */
while|while
condition|(
name|pktsize
operator|&
literal|7
condition|)
block|{
name|qpkt
operator|.
name|u
operator|.
name|data
index|[
name|qsize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pktsize
operator|++
expr_stmt|;
block|}
comment|/* 	 * Get the keyid and the password if we don't have one. 	 */
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|key_id
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_id
operator|==
literal|0
operator|||
name|key_id
operator|>
name|NTP_MAXKEY
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|info_auth_keyid
operator|=
name|key_id
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|authistrusted
argument_list|(
name|info_auth_keyid
argument_list|)
condition|)
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|pass
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid password\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do the encryption. 	 */
name|maclen
operator|=
name|authencrypt
argument_list|(
name|info_auth_keyid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maclen
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Key not found\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|size_t
operator|)
name|maclen
operator|!=
operator|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%zu octet MAC, %zu expected with %zu octet digest\n"
argument_list|,
name|maclen
argument_list|,
operator|(
name|info_auth_hashlen
operator|+
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|)
argument_list|,
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|sendpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qpkt
argument_list|,
name|pktsize
operator|+
name|maclen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * show_error_msg - display the error text for a mode 6 error response.  */
end_comment

begin_function
name|void
name|show_error_msg
parameter_list|(
name|int
name|m6resp
parameter_list|,
name|associd_t
name|associd
parameter_list|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m6resp
condition|)
block|{
case|case
name|CERR_BADFMT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad format request packet\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_PERMISSION
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server disallowed request (authentication?)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADOP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server reports a bad opcode in request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADASSOC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %d unknown to server\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_UNKNOWNVAR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***A request variable unknown to the server\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CERR_BADVALUE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server indicates a request variable was bad\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_UNSPEC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned an unspecified error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TIMEOUT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Request timed out\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_INCOMPLETE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Response from server was incomplete\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERR_TOOMUCH
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Buffer size exceeded for returned data\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returns unknown error code %d\n"
argument_list|,
name|m6resp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * doquery - send a request and process the response, displaying  *	     error messages for any error responses.  */
end_comment

begin_function
name|int
name|doquery
parameter_list|(
name|int
name|opcode
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|size_t
name|qsize
parameter_list|,
specifier|const
name|char
modifier|*
name|qdata
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
return|return
name|doqueryex
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|,
name|rstatus
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * doqueryex - send a request and process the response, optionally  *	       displaying error messages for any error responses.  */
end_comment

begin_function
name|int
name|doqueryex
parameter_list|(
name|int
name|opcode
parameter_list|,
name|associd_t
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|size_t
name|qsize
parameter_list|,
specifier|const
name|char
modifier|*
name|qdata
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* 	 * Check to make sure host is open 	 */
if|if
condition|(
operator|!
name|havehost
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No host open, use `host' command\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|done
operator|=
literal|0
expr_stmt|;
name|sequence
operator|++
expr_stmt|;
name|again
label|:
comment|/* 	 * send a request 	 */
name|res
operator|=
name|sendrequest
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|qsize
argument_list|,
name|qdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
name|res
return|;
comment|/* 	 * Get the response.  If we got a standard error, print a message 	 */
name|res
operator|=
name|getresponse
argument_list|(
name|opcode
argument_list|,
name|associd
argument_list|,
name|rstatus
argument_list|,
name|rsize
argument_list|,
name|rdata
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|done
operator|&&
operator|(
name|res
operator|==
name|ERR_TIMEOUT
operator|||
name|res
operator|==
name|ERR_INCOMPLETE
operator|)
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|ERR_INCOMPLETE
condition|)
block|{
comment|/* 				 * better bump the sequence so we don't 				 * get confused about differing fragments. 				 */
name|sequence
operator|++
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|show_error_msg
argument_list|(
name|res
argument_list|,
name|associd
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_comment
comment|/*  * getcmds - read commands from the standard input and execute them  */
end_comment

begin_function
specifier|static
name|void
name|getcmds
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ntp_readline_init
argument_list|(
name|interactive
condition|?
name|prompt
else|:
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|ntp_readline
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|line
condition|)
break|break;
name|docmd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|ntp_readline_uninit
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_WINNT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BUILD_AS_LIB
argument_list|)
end_if

begin_comment
comment|/*  * abortcmd - catch interrupts and abort the current command  */
end_comment

begin_function
specifier|static
name|int
name|abortcmd
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_output
operator|==
name|stdout
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
block|{
name|jump
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|interrupt_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SYS_WINNT&& !BUILD_AS_LIB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BUILD_AS_LIB
end_ifndef

begin_comment
comment|/*  * docmd - decode the command line and execute a command  */
end_comment

begin_function
specifier|static
name|void
name|docmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmdline
parameter_list|)
block|{
name|char
modifier|*
name|tokens
index|[
literal|1
operator|+
name|MAXARGS
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|parse
name|pcmd
decl_stmt|;
name|int
name|ntok
decl_stmt|;
specifier|static
name|int
name|i
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|xcmd
decl_stmt|;
comment|/* 	 * Tokenize the command line.  If nothing on it, return. 	 */
name|tokenize
argument_list|(
name|cmdline
argument_list|,
name|tokens
argument_list|,
operator|&
name|ntok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Find the appropriate command description. 	 */
name|i
operator|=
name|findcmd
argument_list|(
name|tokens
index|[
literal|0
index|]
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' unknown\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Command `%s' ambiguous\n"
argument_list|,
name|tokens
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Warn about ignored extra args */
for|for
control|(
name|i
operator|=
name|MAXARGS
operator|+
literal|1
init|;
name|i
operator|<
name|ntok
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Extra arg `%s' ignored\n"
argument_list|,
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save the keyword, then walk through the arguments, interpreting 	 * as we go. 	 */
name|pcmd
operator|.
name|keyword
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pcmd
operator|.
name|nargs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|>=
name|ntok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
condition|)
block|{
name|printusage
argument_list|(
name|xcmd
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
operator|)
operator|&&
operator|(
operator|*
name|tokens
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getarg
argument_list|(
name|tokens
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|int
operator|)
name|xcmd
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
operator|&
name|pcmd
operator|.
name|argval
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
name|pcmd
operator|.
name|nargs
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntok
operator|&&
operator|*
name|tokens
index|[
name|i
index|]
operator|==
literal|'>'
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|tokens
index|[
name|i
index|]
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|ntok
condition|)
name|fname
operator|=
name|tokens
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No file for redirect\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|current_output
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_output
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Error opening %s: "
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* flag we need a close */
block|}
else|else
block|{
name|current_output
operator|=
name|stdout
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* flag no close */
block|}
if|if
condition|(
name|interactive
operator|&&
name|setjmp
argument_list|(
name|interrupt_buf
argument_list|)
condition|)
block|{
name|jump
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|jump
operator|++
expr_stmt|;
call|(
name|xcmd
operator|->
name|handler
call|)
argument_list|(
operator|&
name|pcmd
argument_list|,
name|current_output
argument_list|)
expr_stmt|;
name|jump
operator|=
literal|0
expr_stmt|;
comment|/* HMS: 961106: was after fclose() */
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|current_output
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * tokenize - turn a command line into tokens  *  * SK: Modified to allow a quoted string  *  * HMS: If the first character of the first token is a ':' then (after  * eating inter-token whitespace) the 2nd token is the rest of the line.  */
end_comment

begin_function
specifier|static
name|void
name|tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|char
modifier|*
modifier|*
name|tokens
parameter_list|,
name|int
modifier|*
name|ntok
parameter_list|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
name|char
name|tspace
index|[
name|MAXLINE
index|]
decl_stmt|;
name|sp
operator|=
name|tspace
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
for|for
control|(
operator|*
name|ntok
operator|=
literal|0
init|;
operator|*
name|ntok
operator|<
name|MAXTOKENS
condition|;
operator|(
operator|*
name|ntok
operator|)
operator|++
control|)
block|{
name|tokens
index|[
operator|*
name|ntok
index|]
operator|=
name|sp
expr_stmt|;
comment|/* Skip inter-token whitespace */
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* If we're at EOL we're done */
if|if
condition|(
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
comment|/* If this is the 2nd token and the first token begins 		 * with a ':', then just grab to EOL. 		 */
if|if
condition|(
operator|*
name|ntok
operator|==
literal|1
operator|&&
name|tokens
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
do|do
block|{
if|if
condition|(
name|sp
operator|-
name|tspace
operator|>=
name|MAXLINE
condition|)
goto|goto
name|toobig
goto|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
block|}
comment|/* Check if this token begins with a double quote. 		 * If yes, continue reading till the next double quote 		 */
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\"'
condition|)
block|{
operator|++
name|cp
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sp
operator|-
name|tspace
operator|>=
name|MAXLINE
condition|)
goto|goto
name|toobig
goto|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\"'
operator|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
comment|/* HMS: a missing closing " should be an error */
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|sp
operator|-
name|tspace
operator|>=
name|MAXLINE
condition|)
goto|goto
name|toobig
goto|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\"'
operator|)
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|ISEOL
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
comment|/* HMS: Why check for a " in the previous line? */
block|}
if|if
condition|(
name|sp
operator|-
name|tspace
operator|>=
name|MAXLINE
condition|)
goto|goto
name|toobig
goto|;
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return;
name|toobig
label|:
operator|*
name|ntok
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Line `%s' is too big\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * getarg - interpret an argument token  */
end_comment

begin_function
specifier|static
name|int
name|getarg
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|code
parameter_list|,
name|arg_v
modifier|*
name|argp
parameter_list|)
block|{
name|u_long
name|ul
decl_stmt|;
switch|switch
condition|(
name|code
operator|&
operator|~
name|OPT
condition|)
block|{
case|case
name|NTP_STR
case|:
name|argp
operator|->
name|string
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|NTP_ADD
case|:
if|if
condition|(
operator|!
name|getnetnum
argument_list|(
name|str
argument_list|,
operator|&
name|argp
operator|->
name|netnum
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|NTP_UINT
case|:
if|if
condition|(
literal|'&'
operator|==
name|str
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|atouint
argument_list|(
operator|&
name|str
index|[
literal|1
index|]
argument_list|,
operator|&
name|ul
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association index `%s' invalid/undecodable\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
literal|0
operator|==
name|numassoc
condition|)
block|{
name|dogetassoc
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|numassoc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No associations found, `%s' unknown\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|ul
operator|=
name|min
argument_list|(
name|ul
argument_list|,
name|numassoc
argument_list|)
expr_stmt|;
name|argp
operator|->
name|uval
operator|=
name|assoc_cache
index|[
name|ul
operator|-
literal|1
index|]
operator|.
name|assid
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|atouint
argument_list|(
name|str
argument_list|,
operator|&
name|argp
operator|->
name|uval
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal unsigned value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|NTP_INT
case|:
if|if
condition|(
operator|!
name|atoint
argument_list|(
name|str
argument_list|,
operator|&
name|argp
operator|->
name|ival
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Illegal integer value %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|IP_VERSION
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|argp
operator|->
name|ival
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|argp
operator|->
name|ival
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Version must be either 4 or 6\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILD_AS_LIB */
end_comment

begin_comment
comment|/*  * findcmd - find a command in a command description table  */
end_comment

begin_function
specifier|static
name|int
name|findcmd
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist1
parameter_list|,
name|struct
name|xcmd
modifier|*
name|clist2
parameter_list|,
name|struct
name|xcmd
modifier|*
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|xcmd
modifier|*
name|cl
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|nearmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|xcmd
modifier|*
name|clist
decl_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clist1
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist1
expr_stmt|;
elseif|else
if|if
condition|(
name|clist2
operator|!=
literal|0
condition|)
name|clist
operator|=
name|clist2
expr_stmt|;
else|else
return|return
literal|0
return|;
name|again
label|:
for|for
control|(
name|cl
operator|=
name|clist
init|;
name|cl
operator|->
name|keyword
operator|!=
literal|0
condition|;
name|cl
operator|++
control|)
block|{
comment|/* do a first character check, for efficiency */
if|if
condition|(
operator|*
name|str
operator|!=
operator|*
operator|(
name|cl
operator|->
name|keyword
operator|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|cl
operator|->
name|keyword
argument_list|,
operator|(
name|unsigned
operator|)
name|clen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Could be extact match, could be approximate. 			 * Is exact if the length of the keyword is the 			 * same as the str. 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|cl
operator|->
name|keyword
operator|)
operator|+
name|clen
operator|)
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cmd
operator|=
name|cl
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|nearmatch
operator|=
name|cl
expr_stmt|;
block|}
block|}
comment|/* 	 * See if there is more to do.  If so, go again.  Sorry about the 	 * goto, too much looking at BSD sources... 	 */
if|if
condition|(
name|clist
operator|==
name|clist1
operator|&&
name|clist2
operator|!=
literal|0
condition|)
block|{
name|clist
operator|=
name|clist2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * If we got extactly 1 near match, use it, else return number 	 * of matches. 	 */
if|if
condition|(
name|nmatch
operator|==
literal|1
condition|)
block|{
operator|*
name|cmd
operator|=
name|nearmatch
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|nmatch
return|;
block|}
end_function

begin_comment
comment|/*  * getnetnum - given a host name, return its net number  *	       and (optional) full name  */
end_comment

begin_function
name|int
name|getnetnum
parameter_list|(
specifier|const
name|char
modifier|*
name|hname
parameter_list|,
name|sockaddr_u
modifier|*
name|num
parameter_list|,
name|char
modifier|*
name|fullhost
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
ifdef|#
directive|ifdef
name|AI_ADDRCONFIG
name|hints
operator|.
name|ai_flags
operator||=
name|AI_ADDRCONFIG
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * decodenetnum only works with addresses, but handles syntax 	 * that getaddrinfo doesn't:  [2001::1]:1234 	 */
if|if
condition|(
name|decodenetnum
argument_list|(
name|hname
argument_list|,
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|getaddrinfo
argument_list|(
name|hname
argument_list|,
literal|"ntp"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|num
argument_list|)
operator|>=
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|num
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullhost
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|fullhost
argument_list|,
name|ai
operator|->
name|ai_canonname
argument_list|,
name|LENHOSTNAME
argument_list|)
expr_stmt|;
else|else
name|getnameinfo
argument_list|(
operator|&
name|num
operator|->
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
name|num
argument_list|)
argument_list|,
name|fullhost
argument_list|,
name|LENHOSTNAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Can't find host %s\n"
argument_list|,
name|hname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * nntohost - convert network number to host name.  This routine enforces  *	       the showhostnames setting.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nntohost
parameter_list|(
name|sockaddr_u
modifier|*
name|netnum
parameter_list|)
block|{
return|return
name|nntohost_col
argument_list|(
name|netnum
argument_list|,
name|LIB_BUFLENGTH
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * nntohost_col - convert network number to host name in fixed width.  *		  This routine enforces the showhostnames setting.  *		  When displaying hostnames longer than the width,  *		  the first part of the hostname is displayed.  When  *		  displaying numeric addresses longer than the width,  *		  Such as IPv6 addresses, the caller decides whether  *		  the first or last of the numeric address is used.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nntohost_col
parameter_list|(
name|sockaddr_u
modifier|*
name|addr
parameter_list|,
name|size_t
name|width
parameter_list|,
name|int
name|preserve_lowaddrbits
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|showhostnames
operator|||
name|SOCK_UNSPEC
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|preserve_lowaddrbits
condition|)
name|out
operator|=
name|trunc_left
argument_list|(
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
else|else
name|out
operator|=
name|trunc_right
argument_list|(
name|stoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|out
operator|=
name|refnumtoa
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|trunc_right
argument_list|(
name|socktohost
argument_list|(
name|addr
argument_list|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/*  * nntohostp() is the same as nntohost() plus a :port suffix  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|nntohostp
parameter_list|(
name|sockaddr_u
modifier|*
name|netnum
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hostn
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|showhostnames
operator|||
name|SOCK_UNSPEC
argument_list|(
name|netnum
argument_list|)
condition|)
return|return
name|sptoa
argument_list|(
name|netnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
name|netnum
argument_list|)
condition|)
return|return
name|refnumtoa
argument_list|(
name|netnum
argument_list|)
return|;
name|hostn
operator|=
name|socktohost
argument_list|(
name|netnum
argument_list|)
expr_stmt|;
name|LIB_GETBUF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|LIB_BUFLENGTH
argument_list|,
literal|"%s:%u"
argument_list|,
name|hostn
argument_list|,
name|SRCPORT
argument_list|(
name|netnum
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * rtdatetolfp - decode an RT-11 date into an l_fp  */
end_comment

begin_function
specifier|static
name|int
name|rtdatetolfp
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|calendar
name|cal
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|cal
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
comment|/* 	 * An RT-11 date looks like: 	 * 	 * d[d]-Mth-y[y] hh:mm:ss 	 * 	 * (No docs, but assume 4-digit years are also legal...) 	 * 	 * d[d]-Mth-y[y[y[y]]] hh:mm:ss 	 */
name|cp
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * Catch special case 			 */
name|L_CLR
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
comment|/* ascii dependent */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|monthday
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|monthday
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|monthday
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|buf
argument_list|,
name|months
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|12
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|month
operator|=
call|(
name|u_char
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'-'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
name|cal
operator|.
name|year
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|cal
operator|.
name|year
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|year
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|year
operator|=
call|(
name|u_short
call|)
argument_list|(
name|cal
operator|.
name|year
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Catch special case.  If cal.year == 0 this is a zero timestamp. 	 */
if|if
condition|(
name|cal
operator|.
name|year
operator|==
literal|0
condition|)
block|{
name|L_CLR
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|' '
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|hour
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|hour
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|hour
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|minute
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|minute
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|minute
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|':'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cal
operator|.
name|second
operator|<<
literal|3
operator|)
operator|+
operator|(
name|cal
operator|.
name|second
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|second
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cal
operator|.
name|second
operator|+
operator|*
name|cp
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For RT-11, 1972 seems to be the pivot year 	 */
if|if
condition|(
name|cal
operator|.
name|year
operator|<
literal|72
condition|)
name|cal
operator|.
name|year
operator|+=
literal|2000
expr_stmt|;
if|if
condition|(
name|cal
operator|.
name|year
operator|<
literal|100
condition|)
name|cal
operator|.
name|year
operator|+=
literal|1900
expr_stmt|;
name|lfp
operator|->
name|l_ui
operator|=
name|caltontp
argument_list|(
operator|&
name|cal
argument_list|)
expr_stmt|;
name|lfp
operator|->
name|l_uf
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * decodets - decode a timestamp into an l_fp format number, with  *	      consideration of fuzzball formats.  */
end_comment

begin_function
name|int
name|decodets
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|size_t
name|b
decl_stmt|;
comment|/* 	 * If it starts with a 0x, decode as hex. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
operator|&&
operator|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * If it starts with a '"', try it as an RT-11 date. 	 */
if|if
condition|(
operator|*
name|str
operator|==
literal|'"'
condition|)
block|{
name|cp
operator|=
name|str
operator|+
literal|1
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'"'
operator|!=
operator|*
name|cp
operator|&&
literal|'\0'
operator|!=
operator|*
name|cp
operator|&&
name|b
operator|<
name|COUNTOF
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
name|buf
index|[
name|b
operator|++
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
name|b
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rtdatetolfp
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
return|;
block|}
comment|/* 	 * Might still be hex.  Check out the first character.  Talk 	 * about heuristics! 	 */
if|if
condition|(
operator|(
operator|*
name|str
operator|>=
literal|'A'
operator|&&
operator|*
name|str
operator|<=
literal|'F'
operator|)
operator|||
operator|(
operator|*
name|str
operator|>=
literal|'a'
operator|&&
operator|*
name|str
operator|<=
literal|'f'
operator|)
condition|)
return|return
name|hextolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
comment|/* 	 * Try it as a decimal.  If this fails, try as an unquoted 	 * RT-11 date.  This code should go away eventually. 	 */
if|if
condition|(
name|atolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|rtdatetolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodetime - decode a time value.  It should be in milliseconds  */
end_comment

begin_function
name|int
name|decodetime
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
return|return
name|mstolfp
argument_list|(
name|str
argument_list|,
name|lfp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodeint - decode an integer  */
end_comment

begin_function
name|int
name|decodeint
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|long
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|val
argument_list|)
return|;
return|return
name|octtoint
argument_list|(
name|str
argument_list|,
operator|(
name|u_long
operator|*
operator|)
name|val
argument_list|)
return|;
block|}
return|return
name|atoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodeuint - decode an unsigned integer  */
end_comment

begin_function
name|int
name|decodeuint
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|u_long
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'x'
operator|||
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|==
literal|'X'
condition|)
return|return
operator|(
name|hextoint
argument_list|(
name|str
operator|+
literal|2
argument_list|,
name|val
argument_list|)
operator|)
return|;
return|return
operator|(
name|octtoint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|atouint
argument_list|(
name|str
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * decodearr - decode an array of time values  */
end_comment

begin_function
specifier|static
name|int
name|decodearr
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|narr
parameter_list|,
name|l_fp
modifier|*
name|lfparr
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|l_fp
modifier|*
name|lfp
decl_stmt|;
name|char
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|lfp
operator|=
name|lfparr
expr_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
operator|*
name|narr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|narr
operator|<
literal|8
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|decodetime
argument_list|(
name|buf
argument_list|,
name|lfp
argument_list|)
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|narr
operator|)
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Finally, the built in command handlers  */
end_comment

begin_comment
comment|/*  * help - tell about commands, or details of a particular command  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|xcmd
modifier|*
name|xcp
init|=
name|NULL
decl_stmt|;
comment|/* quiet warning */
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|list
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|word
decl_stmt|,
name|words
decl_stmt|;
name|size_t
name|row
decl_stmt|,
name|rows
decl_stmt|;
name|size_t
name|col
decl_stmt|,
name|cols
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|xcp
operator|=
name|builtins
init|;
name|xcp
operator|->
name|keyword
operator|!=
name|NULL
condition|;
name|xcp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|xcp
operator|->
name|keyword
operator|)
operator|!=
literal|'?'
operator|&&
name|words
operator|<
name|COUNTOF
argument_list|(
name|list
argument_list|)
condition|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
block|}
for|for
control|(
name|xcp
operator|=
name|opcmds
init|;
name|xcp
operator|->
name|keyword
operator|!=
name|NULL
condition|;
name|xcp
operator|++
control|)
if|if
condition|(
name|words
operator|<
name|COUNTOF
argument_list|(
name|list
argument_list|)
condition|)
name|list
index|[
name|words
operator|++
index|]
operator|=
name|xcp
operator|->
name|keyword
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|list
argument_list|,
name|words
argument_list|,
sizeof|sizeof
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|helpsort
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|++
control|)
block|{
name|length
operator|=
name|strlen
argument_list|(
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|col
operator|=
name|max
argument_list|(
name|col
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|cols
operator|=
name|SCREENWIDTH
operator|/
operator|++
name|col
expr_stmt|;
name|rows
operator|=
operator|(
name|words
operator|+
name|cols
operator|-
literal|1
operator|)
operator|/
name|cols
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ntpq commands:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|word
operator|=
name|row
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|+=
name|rows
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s"
argument_list|,
operator|(
name|int
operator|)
name|col
argument_list|,
operator|(
name|int
operator|)
name|col
operator|-
literal|1
argument_list|,
name|list
index|[
name|word
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cmd
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|words
operator|=
name|findcmd
argument_list|(
name|cmd
argument_list|,
name|builtins
argument_list|,
name|opcmds
argument_list|,
operator|&
name|xcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is unknown\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|words
operator|>=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Command `%s' is ambiguous\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"function: %s\n"
argument_list|,
name|xcp
operator|->
name|comment
argument_list|)
expr_stmt|;
name|printusage
argument_list|(
name|xcp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * helpsort - do hostname qsort comparisons  */
end_comment

begin_function
specifier|static
name|int
name|helpsort
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name1
init|=
name|t1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|name2
init|=
name|t2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|*
name|name1
argument_list|,
operator|*
name|name2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * printusage - print usage information for a command  */
end_comment

begin_function
specifier|static
name|void
name|printusage
parameter_list|(
name|struct
name|xcmd
modifier|*
name|xcp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* XXX: Do we need to warn about extra args here too? */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage: %s"
argument_list|,
name|xcp
operator|->
name|keyword
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXARGS
operator|&&
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|NO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xcp
operator|->
name|arg
index|[
name|i
index|]
operator|&
name|OPT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" [ %s ]"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|xcp
operator|->
name|desc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * timeout - set time out time  */
end_comment

begin_function
specifier|static
name|void
name|timeout
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
operator|(
name|int
operator|)
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tvout
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"primary timeout %d ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tvout
operator|.
name|tv_sec
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|/
literal|1000
expr_stmt|;
name|tvout
operator|.
name|tv_usec
operator|=
operator|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|-
operator|(
operator|(
name|long
operator|)
name|tvout
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * auth_delay - set delay for auth requests  */
end_comment

begin_function
specifier|static
name|void
name|auth_delay
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|isneg
decl_stmt|;
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|delay_time
operator|.
name|l_ui
operator|*
literal|1000
operator|+
name|delay_time
operator|.
name|l_uf
operator|/
literal|4294967
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"delay %lu ms\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
operator|<
literal|0
condition|)
block|{
name|isneg
operator|=
literal|1
expr_stmt|;
name|val
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|-
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isneg
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|u_long
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|ival
expr_stmt|;
block|}
name|delay_time
operator|.
name|l_ui
operator|=
name|val
operator|/
literal|1000
expr_stmt|;
name|val
operator|%=
literal|1000
expr_stmt|;
name|delay_time
operator|.
name|l_uf
operator|=
name|val
operator|*
literal|4294967
expr_stmt|;
comment|/* 2**32/1000 */
if|if
condition|(
name|isneg
condition|)
name|L_NEG
argument_list|(
operator|&
name|delay_time
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * host - set the host we are dealing with.  */
end_comment

begin_function
specifier|static
name|void
name|host
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|havehost
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host is %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no current host\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|ai_fam_templ
operator|=
name|ai_fam_default
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-4"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-6"
argument_list|,
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|)
condition|)
name|ai_fam_templ
operator|=
name|AF_INET6
expr_stmt|;
else|else
goto|goto
name|no_change
goto|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|openhost
argument_list|(
name|pcmd
operator|->
name|argval
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|ai_fam_templ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host set to %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_change
label|:
if|if
condition|(
name|havehost
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"current host remains %s\n"
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"still no current host\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * poll - do one (or more) polls of the host via NTP  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|ntp_poll
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"poll not implemented yet\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * showdrefid2str - return a string explanation of the value of drefid  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|showdrefid2str
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|drefid
condition|)
block|{
case|case
name|REFID_HASH
case|:
return|return
literal|"hash"
return|;
case|case
name|REFID_IPV4
case|:
return|return
literal|"ipv4"
return|;
default|default:
return|return
literal|"Unknown"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * drefid - display/change "display hash"   */
end_comment

begin_function
specifier|static
name|void
name|showdrefid
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"drefid value is %s\n"
argument_list|,
name|showdrefid2str
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"hash"
argument_list|)
condition|)
block|{
name|drefid
operator|=
name|REFID_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"ipv4"
argument_list|)
condition|)
block|{
name|drefid
operator|=
name|REFID_IPV4
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"drefid value set to %s\n"
argument_list|,
name|showdrefid2str
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * keyid - get a keyid to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keyid
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"no keyid defined\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keyid is %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_keyid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* allow zero so that keyid can be cleared. */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|>
name|NTP_MAXKEY
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Invalid key identifier\n"
argument_list|)
expr_stmt|;
name|info_auth_keyid
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * keytype - get type of key to use for authenticating requests  */
end_comment

begin_function
specifier|static
name|void
name|keytype
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_name
decl_stmt|;
name|size_t
name|digest_len
decl_stmt|;
name|int
name|key_type
decl_stmt|;
if|if
condition|(
operator|!
name|pcmd
operator|->
name|nargs
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is %s with %lu octet digests\n"
argument_list|,
name|keytype_name
argument_list|(
name|info_auth_keytype
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|info_auth_hashlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|digest_name
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
name|digest_len
operator|=
literal|0
expr_stmt|;
name|key_type
operator|=
name|keytype_from_text
argument_list|(
name|digest_name
argument_list|,
operator|&
name|digest_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_type
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"keytype is not valid. "
ifdef|#
directive|ifdef
name|OPENSSL
literal|"Type \"help keytype\" for the available digest types.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"Only \"md5\" is available.\n"
block|)
empty_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_expr_stmt
name|info_auth_keytype
operator|=
name|key_type
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|info_auth_hashlen
operator|=
name|digest_len
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * passwd - get an authentication key  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
unit|static
name|void
name|passwd
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pass
decl_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
name|info_auth_keyid
operator|=
name|getkeyid
argument_list|(
literal|"Keyid: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_auth_keyid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keyid must be defined\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|1
condition|)
name|pass
operator|=
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
expr_stmt|;
else|else
block|{
name|pass
operator|=
name|getpass_keytype
argument_list|(
name|info_auth_keytype
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|pass
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Password unchanged\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|authusekey
argument_list|(
name|info_auth_keyid
argument_list|,
name|info_auth_keytype
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|pass
argument_list|)
expr_stmt|;
name|authtrust
argument_list|(
name|info_auth_keyid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * hostnames - set the showhostnames flag  */
end_comment

begin_function
specifier|static
name|void
name|hostnames
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|showhostnames
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames being shown\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"hostnames not being shown\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
name|showhostnames
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * setdebug - set/change debugging level  */
end_comment

begin_function
specifier|static
name|void
name|setdebug
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level is %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"more"
argument_list|)
condition|)
block|{
name|debug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"less"
argument_list|)
condition|)
block|{
name|debug
operator|--
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"debug level set to %d\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * quit - stop this nonsense  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|havehost
condition|)
name|closesocket
argument_list|(
name|sockfd
argument_list|)
expr_stmt|;
comment|/* cleanliness next to godliness */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * version - print the current version number  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * raw - set raw mode output  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|raw
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|rawmode
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to raw\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cooked - set cooked mode output  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|cooked
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|rawmode
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Output set to cooked\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * authenticate - always authenticate requests to this host  */
end_comment

begin_function
specifier|static
name|void
name|authenticate
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|always_auth
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"authenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"unauthenticated requests being sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"yes"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|,
literal|"no"
argument_list|)
condition|)
block|{
name|always_auth
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"What?\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ntpversion - choose the NTP version to use  */
end_comment

begin_function
specifier|static
name|void
name|ntpversion
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"NTP version being claimed is %d\n"
argument_list|,
name|pktversion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|<
name|NTP_OLDVERSION
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|>
name|NTP_VERSION
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"versions %d to %d, please\n"
argument_list|,
name|NTP_OLDVERSION
argument_list|,
name|NTP_VERSION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pktversion
operator|=
operator|(
name|u_char
operator|)
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
name|vwarning
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
name|va_list
name|ap
argument_list|)
block|{
name|int
name|serrno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|strerror
argument_list|(
name|serrno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * warning - print a warning message  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|warning
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarning
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * error - print a message and exit  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|error
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarning
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * getkeyid - prompt the user for a keyid to use  */
end_comment

begin_function
specifier|static
name|u_long
name|getkeyid
parameter_list|(
specifier|const
name|char
modifier|*
name|keyprompt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|fi
decl_stmt|;
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|ilim
decl_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
if|if
condition|(
operator|(
name|fi
operator|=
name|fdopen
argument_list|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fi
operator|=
name|_fdopen
argument_list|(
name|open
argument_list|(
literal|"CONIN$"
argument_list|,
name|_O_TEXT
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
comment|/* SYS_WINNT */
name|fi
operator|=
name|stdin
expr_stmt|;
else|else
name|setbuf
argument_list|(
name|fi
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|keyprompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ilim
operator|=
name|COUNTOF
argument_list|(
name|pbuf
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<
name|ilim
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fi
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
name|pbuf
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|pbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_long
operator|)
name|atoi
argument_list|(
name|pbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * atoascii - printable-ize possibly ascii data using the character  *	      transformations cat -v uses.  */
end_comment

begin_function
specifier|static
name|void
name|atoascii
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|size_t
name|in_octets
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|out_octets
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|pchIn
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pchInLimit
decl_stmt|;
name|u_char
modifier|*
name|pchOut
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|pchIn
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|in
expr_stmt|;
name|pchInLimit
operator|=
name|pchIn
operator|+
name|in_octets
expr_stmt|;
name|pchOut
operator|=
operator|(
name|u_char
operator|*
operator|)
name|out
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pchIn
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|out_octets
condition|)
operator|*
name|pchOut
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|ONEOUT
parameter_list|(
name|c
parameter_list|)
define|\
value|do {							\ 	if (0 == --out_octets) {			\ 		*pchOut = '\0';				\ 		return;					\ 	}						\ 	*pchOut++ = (c);				\ } while (0)
for|for
control|(
init|;
name|pchIn
operator|<
name|pchInLimit
condition|;
name|pchIn
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|pchIn
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|c
condition|)
break|break;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
call|(
name|u_char
call|)
argument_list|(
name|c
operator|+
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0x7f
operator|==
name|c
condition|)
block|{
name|ONEOUT
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|ONEOUT
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
block|}
else|else
name|ONEOUT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|ONEOUT
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ONEOUT
block|}
end_function

begin_comment
comment|/*  * makeascii - print possibly ascii data using the character  *	       transformations that cat -v uses.  */
end_comment

begin_function
name|void
name|makeascii
parameter_list|(
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|data_u_char
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|data_u_char
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|data_u_char
init|;
name|cp
operator|<
name|data_u_char
operator|+
name|length
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|int
operator|)
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
block|{
name|putc
argument_list|(
literal|'M'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|c
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
operator|+
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0x7f
operator|==
name|c
condition|)
block|{
name|putc
argument_list|(
literal|'^'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'?'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * asciize - same thing as makeascii except add a newline  */
end_comment

begin_function
name|void
name|asciize
parameter_list|(
name|int
name|length
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|makeascii
argument_list|(
name|length
argument_list|,
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * truncate string to fit clipping excess at end.  *	"too long"	->	"too l"  * Used for hostnames.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trunc_right
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|width
parameter_list|)
block|{
name|size_t
name|sl
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|>
name|width
operator|&&
name|LIB_BUFLENGTH
operator|-
literal|1
operator|>
name|width
operator|&&
name|width
operator|>
literal|0
condition|)
block|{
name|LIB_GETBUF
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|src
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|out
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|out
return|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/*  * truncate string to fit by preserving right side and using '_' to hint  *	"too long"	->	"_long"  * Used for local IPv6 addresses, where low bits differentiate.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|trunc_left
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|width
parameter_list|)
block|{
name|size_t
name|sl
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|sl
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|sl
operator|>
name|width
operator|&&
name|LIB_BUFLENGTH
operator|-
literal|1
operator|>
name|width
operator|&&
name|width
operator|>
literal|1
condition|)
block|{
name|LIB_GETBUF
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|out
index|[
literal|1
index|]
argument_list|,
operator|&
name|src
index|[
name|sl
operator|+
literal|1
operator|-
name|width
index|]
argument_list|,
name|width
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
return|return
name|src
return|;
block|}
end_function

begin_comment
comment|/*  * Some circular buffer space  */
end_comment

begin_define
define|#
directive|define
name|CBLEN
value|80
end_define

begin_define
define|#
directive|define
name|NUMCB
value|6
end_define

begin_decl_stmt
name|char
name|circ_buf
index|[
name|NUMCB
index|]
index|[
name|CBLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nextcb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nextvar - find the next variable in the buffer  */
end_comment

begin_function
name|int
name|nextvar
parameter_list|(
name|size_t
modifier|*
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|datap
parameter_list|,
name|char
modifier|*
modifier|*
name|vname
parameter_list|,
name|char
modifier|*
modifier|*
name|vvalue
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|cpend
decl_stmt|;
name|size_t
name|srclen
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|MAXVARLEN
index|]
decl_stmt|;
specifier|static
name|char
name|value
index|[
name|MAXVALLEN
index|]
decl_stmt|;
name|cp
operator|=
operator|*
name|datap
expr_stmt|;
name|cpend
operator|=
name|cp
operator|+
operator|*
name|datalen
expr_stmt|;
comment|/* 	 * Space past commas and white space 	 */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|cpend
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy name until we hit a ',', an '=', a '\r' or a '\n'.  Backspace 	 * over any white space and terminate it. 	 */
name|srclen
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|",=\r\n"
argument_list|)
expr_stmt|;
name|srclen
operator|=
name|min
argument_list|(
name|srclen
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|cpend
operator|-
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|srclen
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|name
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|vname
operator|=
name|name
expr_stmt|;
name|cp
operator|+=
name|srclen
expr_stmt|;
comment|/* 	 * Check if we hit the end of the buffer or a ','.  If so we are done. 	 */
if|if
condition|(
name|cp
operator|>=
name|cpend
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|'\r'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cp
operator|<
name|cpend
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|cp
expr_stmt|;
operator|*
name|datalen
operator|=
name|size2int_sat
argument_list|(
name|cpend
operator|-
name|cp
argument_list|)
expr_stmt|;
operator|*
name|vvalue
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * So far, so good.  Copy out the value 	 */
name|cp
operator|++
expr_stmt|;
comment|/* past '=' */
while|while
condition|(
name|cp
operator|<
name|cpend
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\r'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
name|np
operator|=
name|cp
expr_stmt|;
if|if
condition|(
literal|'"'
operator|==
operator|*
name|np
condition|)
block|{
do|do
block|{
name|np
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|np
operator|<
name|cpend
operator|&&
literal|'"'
operator|!=
operator|*
name|np
condition|)
do|;
if|if
condition|(
name|np
operator|<
name|cpend
operator|&&
literal|'"'
operator|==
operator|*
name|np
condition|)
name|np
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|np
operator|<
name|cpend
operator|&&
literal|','
operator|!=
operator|*
name|np
operator|&&
literal|'\r'
operator|!=
operator|*
name|np
condition|)
name|np
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|np
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|np
operator|>
name|cpend
operator|||
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|||
operator|(
name|np
operator|<
name|cpend
operator|&&
literal|','
operator|!=
operator|*
name|np
operator|&&
literal|'\r'
operator|!=
operator|*
name|np
operator|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|value
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Trim off any trailing whitespace 	 */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|value
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|value
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Return this.  All done. 	 */
if|if
condition|(
name|np
operator|<
name|cpend
operator|&&
literal|','
operator|==
operator|*
name|np
condition|)
name|np
operator|++
expr_stmt|;
operator|*
name|datap
operator|=
name|np
expr_stmt|;
operator|*
name|datalen
operator|=
name|size2int_sat
argument_list|(
name|cpend
operator|-
name|np
argument_list|)
expr_stmt|;
operator|*
name|vvalue
operator|=
name|value
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|u_short
name|varfmt
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COUNTOF
argument_list|(
name|cookedvars
argument_list|)
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|varname
argument_list|,
name|cookedvars
index|[
name|n
index|]
operator|.
name|varname
argument_list|)
condition|)
return|return
name|cookedvars
index|[
name|n
index|]
operator|.
name|fmt
return|;
return|return
name|PADDING
return|;
block|}
end_function

begin_comment
comment|/*  * printvars - print variables returned in response packet  */
end_comment

begin_function
name|void
name|printvars
parameter_list|(
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|sttype
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|rawmode
condition|)
name|rawprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|cookedprint
argument_list|(
name|sttype
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|status
argument_list|,
name|quiet
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rawprint - do a printout of the data in raw mode  */
end_comment

begin_function
specifier|static
name|void
name|rawprint
parameter_list|(
name|int
name|datatype
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cpend
decl_stmt|;
comment|/* 	 * Essentially print the data as is.  We reformat unprintables, though. 	 */
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=0x%04x,\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
comment|/* 			 * If this is a \r and the next character is a 			 * \n, supress this, else pretty print it.  Otherwise 			 * just output the character. 			 */
if|if
condition|(
name|cp
operator|==
operator|(
name|cpend
operator|-
literal|1
operator|)
operator|||
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|makeascii
argument_list|(
literal|1
argument_list|,
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Global data used by the cooked output routines  */
end_comment

begin_decl_stmt
name|int
name|out_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters output */
end_comment

begin_decl_stmt
name|int
name|out_linecount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters output on this line */
end_comment

begin_comment
comment|/*  * startoutput - get ready to do cooked output  */
end_comment

begin_function
specifier|static
name|void
name|startoutput
parameter_list|(
name|void
parameter_list|)
block|{
name|out_chars
operator|=
literal|0
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * output - output a variable=value combination  */
end_comment

begin_function
specifier|static
name|void
name|output
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
comment|/* strlen of "name=value" */
name|len
operator|=
name|size2int_sat
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
block|{
name|out_chars
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|out_linecount
operator|+
name|len
operator|+
literal|2
operator|)
operator|>
name|MAXOUTLINE
condition|)
block|{
name|fputs
argument_list|(
literal|",\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_linecount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|", "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_linecount
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'='
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|value
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|out_chars
operator|+=
name|len
expr_stmt|;
name|out_linecount
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * endoutput - terminate a block of cooked output  */
end_comment

begin_function
specifier|static
name|void
name|endoutput
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|out_chars
operator|!=
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * outputarr - output an array of values  */
end_comment

begin_function
specifier|static
name|void
name|outputarr
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|narr
parameter_list|,
name|l_fp
modifier|*
name|lfp
parameter_list|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Hack to align delay and offset values 	 */
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
name|narr
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|narr
condition|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cp
operator|=
name|lfptoms
argument_list|(
name|lfp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|7
condition|)
block|{
name|cp
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
literal|7
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|7
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|lfp
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tstflags
parameter_list|(
name|u_long
name|val
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|cb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
name|s
operator|=
name|cp
operator|=
name|circ_buf
index|[
name|nextcb
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|nextcb
operator|>=
name|NUMCB
condition|)
name|nextcb
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
sizeof|sizeof
argument_list|(
name|circ_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cp
argument_list|,
name|cb
argument_list|,
literal|"%02lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
block|{
name|strlcat
argument_list|(
name|cp
argument_list|,
literal|" ok"
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cb
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cb
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|COUNTOF
argument_list|(
name|tstflagnames
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|&
literal|0x1
condition|)
block|{
name|snprintf
argument_list|(
name|cp
argument_list|,
name|cb
argument_list|,
literal|"%s%s"
argument_list|,
name|sep
argument_list|,
name|tstflagnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cb
operator|-=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|val
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cb
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * cookedprint - output variables in cooked mode  */
end_comment

begin_function
specifier|static
name|void
name|cookedprint
parameter_list|(
name|int
name|datatype
parameter_list|,
name|size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|quiet
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
name|output_raw
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|l_fp
name|lfp
decl_stmt|;
name|sockaddr_u
name|hval
decl_stmt|;
name|u_long
name|uval
decl_stmt|;
name|int
name|narr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|l_fp
name|lfparr
index|[
literal|8
index|]
decl_stmt|;
name|char
name|b
index|[
literal|12
index|]
decl_stmt|;
name|char
name|bn
index|[
literal|2
operator|*
name|MAXVARLEN
index|]
decl_stmt|;
name|char
name|bv
index|[
literal|2
operator|*
name|MAXVALLEN
index|]
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|datatype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"status=%04x %s,\n"
argument_list|,
name|status
argument_list|,
name|statustoa
argument_list|(
name|datatype
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|startoutput
argument_list|()
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|length
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|fmt
operator|=
name|varfmt
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|output_raw
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|PADDING
case|:
name|output_raw
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
name|TS
case|:
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|lfp
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|prettydate
argument_list|(
operator|&
name|lfp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HA
case|:
comment|/* fallthru */
case|case
name|NA
case|:
if|if
condition|(
operator|!
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|hval
argument_list|)
condition|)
block|{
name|output_raw
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|HA
condition|)
block|{
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|nntohost
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RF
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|hval
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISREFCLOCKADR
argument_list|(
operator|&
name|hval
argument_list|)
condition|)
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|refnumtoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|stoa
argument_list|(
operator|&
name|hval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
condition|)
block|{
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_raw
operator|=
literal|'?'
expr_stmt|;
block|}
break|break;
case|case
name|LP
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
operator|||
name|uval
operator|>
literal|3
condition|)
block|{
name|output_raw
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
name|b
index|[
literal|0
index|]
operator|=
operator|(
literal|0x2
operator|&
name|uval
operator|)
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
operator|(
literal|0x1
operator|&
name|uval
operator|)
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OC
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
block|{
name|output_raw
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
literal|"%03lo"
argument_list|,
name|uval
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AR
case|:
if|if
condition|(
operator|!
name|decodearr
argument_list|(
name|value
argument_list|,
operator|&
name|narr
argument_list|,
name|lfparr
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|outputarr
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|narr
argument_list|,
name|lfparr
argument_list|)
expr_stmt|;
break|break;
case|case
name|FX
case|:
if|if
condition|(
operator|!
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|uval
argument_list|)
condition|)
name|output_raw
operator|=
literal|'?'
expr_stmt|;
else|else
name|output
argument_list|(
name|fp
argument_list|,
name|name
argument_list|,
name|tstflags
argument_list|(
name|uval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error in cookedprint, %s=%s, fmt %d\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|output_raw
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|output_raw
operator|!=
literal|0
condition|)
block|{
comment|/* TALOS-CAN-0063: avoid buffer overrun */
name|atoascii
argument_list|(
name|name
argument_list|,
name|MAXVARLEN
argument_list|,
name|bn
argument_list|,
sizeof|sizeof
argument_list|(
name|bn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_raw
operator|!=
literal|'*'
condition|)
block|{
name|atoascii
argument_list|(
name|value
argument_list|,
name|MAXVALLEN
argument_list|,
name|bv
argument_list|,
sizeof|sizeof
argument_list|(
name|bv
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|bv
argument_list|)
expr_stmt|;
name|bv
index|[
name|len
index|]
operator|=
name|output_raw
expr_stmt|;
name|bv
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|atoascii
argument_list|(
name|value
argument_list|,
name|MAXVALLEN
argument_list|,
name|bv
argument_list|,
sizeof|sizeof
argument_list|(
name|bv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output
argument_list|(
name|fp
argument_list|,
name|bn
argument_list|,
name|bv
argument_list|)
expr_stmt|;
block|}
block|}
name|endoutput
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sortassoc - sort associations in the cache into ascending order  */
end_comment

begin_function
name|void
name|sortassoc
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|numassoc
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|assoc_cache
argument_list|,
operator|(
name|size_t
operator|)
name|numassoc
argument_list|,
sizeof|sizeof
argument_list|(
name|assoc_cache
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|assoccmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * assoccmp - compare two associations  */
end_comment

begin_function
specifier|static
name|int
name|assoccmp
parameter_list|(
specifier|const
name|void
modifier|*
name|t1
parameter_list|,
specifier|const
name|void
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|struct
name|association
modifier|*
name|ass1
init|=
name|t1
decl_stmt|;
specifier|const
name|struct
name|association
modifier|*
name|ass2
init|=
name|t2
decl_stmt|;
if|if
condition|(
name|ass1
operator|->
name|assid
operator|<
name|ass2
operator|->
name|assid
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ass1
operator|->
name|assid
operator|>
name|ass2
operator|->
name|assid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * grow_assoc_cache() - enlarge dynamic assoc_cache array  *  * The strategy is to add an assumed 4k page size at a time, leaving  * room for malloc() bookkeeping overhead equivalent to 4 pointers.  */
end_comment

begin_function
name|void
name|grow_assoc_cache
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|size_t
name|prior_sz
decl_stmt|;
name|size_t
name|new_sz
decl_stmt|;
name|new_sz
operator|=
name|prior_sz
operator|+
literal|4
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|prior_sz
condition|)
block|{
name|new_sz
operator|-=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
name|assoc_cache
operator|=
name|erealloc_zero
argument_list|(
name|assoc_cache
argument_list|,
name|new_sz
argument_list|,
name|prior_sz
argument_list|)
expr_stmt|;
name|prior_sz
operator|=
name|new_sz
expr_stmt|;
name|assoc_cache_slots
operator|=
call|(
name|u_int
call|)
argument_list|(
name|new_sz
operator|/
sizeof|sizeof
argument_list|(
name|assoc_cache
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntpq_custom_opt_handler - autoopts handler for -c and -p  *  * By default, autoopts loses the relative order of -c and -p options  * on the command line.  This routine replaces the default handler for  * those routines and builds a list of commands to execute preserving  * the order.  */
end_comment

begin_function
name|void
name|ntpq_custom_opt_handler
parameter_list|(
name|tOptions
modifier|*
name|pOptions
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
block|{
switch|switch
condition|(
name|pOptDesc
operator|->
name|optValue
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ntpq_custom_opt_handler unexpected option '%c' (%d)\n"
argument_list|,
name|pOptDesc
operator|->
name|optValue
argument_list|,
name|pOptDesc
operator|->
name|optValue
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|ADDCMD
argument_list|(
name|pOptDesc
operator|->
name|pzLastArg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ADDCMD
argument_list|(
literal|"peers"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Obtain list of digest names  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVP_MD_DO_ALL_SORTED
end_ifdef

begin_struct
struct|struct
name|hstate
block|{
name|char
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|seen
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|K_PER_LINE
value|8
end_define

begin_define
define|#
directive|define
name|K_NL_PFX_STR
value|"\n    "
end_define

begin_define
define|#
directive|define
name|K_DELIM_STR
value|", "
end_define

begin_function
specifier|static
name|void
name|list_md_fn
parameter_list|(
specifier|const
name|EVP_MD
modifier|*
name|m
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|seen
decl_stmt|;
name|struct
name|hstate
modifier|*
name|hstate
init|=
name|arg
decl_stmt|;
name|EVP_MD_CTX
name|ctx
decl_stmt|;
name|u_int
name|digest_len
decl_stmt|;
name|u_char
name|digest
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
comment|/* Ignore aliases */
name|name
operator|=
name|EVP_MD_name
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Lowercase names aren't accepted by keytype_from_text in ssl_init.c */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return;
block|}
name|len
operator|=
operator|(
name|cp
operator|-
name|name
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* There are duplicates.  Discard if name has been seen. */
for|for
control|(
name|seen
operator|=
name|hstate
operator|->
name|seen
init|;
operator|*
name|seen
condition|;
name|seen
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|seen
argument_list|,
name|name
argument_list|)
condition|)
return|return;
name|n
operator|=
operator|(
name|seen
operator|-
name|hstate
operator|->
name|seen
operator|)
operator|+
literal|2
expr_stmt|;
name|hstate
operator|->
name|seen
operator|=
name|erealloc
argument_list|(
name|hstate
operator|->
name|seen
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|seen
argument_list|)
argument_list|)
expr_stmt|;
name|hstate
operator|->
name|seen
index|[
name|n
operator|-
literal|2
index|]
operator|=
name|name
expr_stmt|;
name|hstate
operator|->
name|seen
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Discard MACs that NTP won't accept.      * Keep this consistent with keytype_from_text() in ssl_init.c.      */
name|EVP_DigestInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|EVP_get_digestbyname
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|digest
argument_list|,
operator|&
name|digest_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest_len
operator|>
operator|(
name|MAX_MAC_LEN
operator|-
sizeof|sizeof
argument_list|(
name|keyid_t
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|hstate
operator|->
name|list
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|hstate
operator|->
name|list
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|hstate
operator|->
name|idx
operator|>=
name|K_PER_LINE
operator|)
condition|?
name|strlen
argument_list|(
name|K_NL_PFX_STR
argument_list|)
else|:
name|strlen
argument_list|(
name|K_DELIM_STR
argument_list|)
expr_stmt|;
if|if
condition|(
name|hstate
operator|->
name|list
operator|==
name|NULL
condition|)
block|{
name|hstate
operator|->
name|list
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|hstate
operator|->
name|list
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|hstate
operator|->
name|list
operator|=
operator|(
name|char
operator|*
operator|)
name|erealloc
argument_list|(
name|hstate
operator|->
name|list
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hstate
operator|->
name|list
operator|+
name|strlen
argument_list|(
name|hstate
operator|->
name|list
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
operator|(
name|hstate
operator|->
name|idx
operator|>=
name|K_PER_LINE
operator|)
condition|?
name|K_NL_PFX_STR
else|:
name|K_DELIM_STR
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hstate
operator|->
name|idx
operator|>=
name|K_PER_LINE
condition|)
name|hstate
operator|->
name|idx
operator|=
literal|1
expr_stmt|;
else|else
name|hstate
operator|->
name|idx
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|list_digest_names
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
ifdef|#
directive|ifdef
name|HAVE_EVP_MD_DO_ALL_SORTED
name|struct
name|hstate
name|hstate
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|K_PER_LINE
operator|+
literal|1
block|}
decl_stmt|;
name|hstate
operator|.
name|seen
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|emalloc_zero
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|// replaces -> calloc(1, sizeof( const char * ));
name|INIT_SSL
argument_list|()
expr_stmt|;
name|EVP_MD_do_all_sorted
argument_list|(
name|list_md_fn
argument_list|,
operator|&
name|hstate
argument_list|)
expr_stmt|;
name|list
operator|=
name|hstate
operator|.
name|list
expr_stmt|;
name|free
argument_list|(
name|hstate
operator|.
name|seen
argument_list|)
expr_stmt|;
else|#
directive|else
name|list
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"md5, others (upgrade to OpenSSL-1.0 for full list)"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|list
argument_list|,
literal|"md5, others (upgrade to OpenSSL-1.0 for full list)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|list
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"md5"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|list
argument_list|,
literal|"md5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|list
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CTRLC_STACK_MAX
value|4
end_define

begin_decl_stmt
specifier|static
specifier|volatile
name|size_t
name|ctrlc_stack_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|Ctrl_C_Handler
name|ctrlc_stack
index|[
name|CTRLC_STACK_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
comment|/*BOOL*/
name|push_ctrl_c_handler
parameter_list|(
name|Ctrl_C_Handler
name|func
parameter_list|)
block|{
name|size_t
name|size
init|=
name|ctrlc_stack_len
decl_stmt|;
if|if
condition|(
name|func
operator|&&
operator|(
name|size
operator|<
name|CTRLC_STACK_MAX
operator|)
condition|)
block|{
name|ctrlc_stack
index|[
name|size
index|]
operator|=
name|func
expr_stmt|;
name|ctrlc_stack_len
operator|=
name|size
operator|+
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
comment|/*BOOL*/
name|pop_ctrl_c_handler
parameter_list|(
name|Ctrl_C_Handler
name|func
parameter_list|)
block|{
name|size_t
name|size
init|=
name|ctrlc_stack_len
decl_stmt|;
if|if
condition|(
name|size
condition|)
block|{
operator|--
name|size
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|func
operator|==
name|ctrlc_stack
index|[
name|size
index|]
condition|)
block|{
name|ctrlc_stack_len
operator|=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|on_ctrlc
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|size
init|=
name|ctrlc_stack_len
decl_stmt|;
while|while
condition|(
name|size
condition|)
if|if
condition|(
call|(
modifier|*
name|ctrlc_stack
index|[
operator|--
name|size
index|]
call|)
argument_list|()
condition|)
break|break;
block|}
end_function

begin_function
specifier|static
name|int
name|my_easprintf
parameter_list|(
name|char
modifier|*
modifier|*
name|ppinto
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|int
name|prc
decl_stmt|;
name|size_t
name|len
init|=
literal|128
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|emalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|again
label|:
comment|/* Note: we expect the memory allocation to fail long before the 	 * increment in buffer size actually overflows. 	 */
name|buf
operator|=
operator|(
name|buf
operator|)
condition|?
name|erealloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
else|:
name|emalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|prc
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|prc
operator|<
literal|0
condition|)
block|{
comment|/* might be very old vsnprintf. Or actually MSVC... */
name|len
operator|+=
name|len
operator|>>
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|prc
operator|>=
name|len
condition|)
block|{
comment|/* at least we have the proper size now... */
name|len
operator|=
operator|(
name|size_t
operator|)
name|prc
operator|+
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|prc
operator|<
operator|(
name|len
operator|-
literal|32
operator|)
condition|)
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|prc
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ppinto
operator|=
name|buf
expr_stmt|;
return|return
name|prc
return|;
block|}
end_function

end_unit

