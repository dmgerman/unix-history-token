begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ntpdc_ops.c - subroutines which are called to perform operations by ntpdc  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"ntpq.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|chosts
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|currenthost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|numhosts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxhostlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations for command handlers in here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|checkassocid
name|P
argument_list|(
operator|(
name|u_int32
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strsave
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doaddvlist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dormvlist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doclearvlist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|makequerydata
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doquerylist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|u_short
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doprintvlist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addvars
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rmvars
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clearvars
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|showvars
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dolist
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readlist
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|writelist
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|readvar
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|writevar
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clocklist
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clockvar
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findassidrange
name|P
argument_list|(
operator|(
name|u_int32
operator|,
name|u_int32
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mreadlist
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mreadvar
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dogetassoc
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printassoc
name|P
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|associations
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lassociations
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|passociations
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lpassociations
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|radiostatus
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pstatus
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|when
name|P
argument_list|(
operator|(
name|l_fp
operator|*
operator|,
name|l_fp
operator|*
operator|,
name|l_fp
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prettyinterval
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doprintpeers
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dogetpeers
name|P
argument_list|(
operator|(
expr|struct
name|varlist
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dopeers
name|P
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|peers
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lpeers
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doopeers
name|P
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|opeers
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lopeers
name|P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Commands we understand.	Ntpdc imports this.  */
end_comment

begin_decl_stmt
name|struct
name|xcmd
name|opcmds
index|[]
init|=
block|{
block|{
literal|"associations"
block|,
name|associations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of association ID's and statuses for the server's peers"
block|}
block|,
block|{
literal|"passociations"
block|,
name|passociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations returned by last associations command"
block|}
block|,
block|{
literal|"lassociations"
block|,
name|lassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print list of associations including all client information"
block|}
block|,
block|{
literal|"lpassociations"
block|,
name|lpassociations
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print last obtained list of associations, including client information"
block|}
block|,
block|{
literal|"addvars"
block|,
name|addvars
block|,
block|{
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[=value][,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"add variables to the variable list or change their values"
block|}
block|,
block|{
literal|"rmvars"
block|,
name|rmvars
block|,
block|{
name|STR
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"name[,...]"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove variables from the variable list"
block|}
block|,
block|{
literal|"clearvars"
block|,
name|clearvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"remove all variables from the variable list"
block|}
block|,
block|{
literal|"showvars"
block|,
name|showvars
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print variables on the variable list"
block|}
block|,
block|{
literal|"readlist"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"rl"
block|,
name|readlist
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"writelist"
block|,
name|writelist
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write the system or peer variables included in the variable list"
block|}
block|,
block|{
literal|"readvar"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"rv"
block|,
name|readvar
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read system or peer variables"
block|}
block|,
block|{
literal|"writevar"
block|,
name|writevar
block|,
block|{
name|UINT
block|,
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value,[...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"write system or peer variables"
block|}
block|,
block|{
literal|"mreadlist"
block|,
name|mreadlist
block|,
block|{
name|UINT
block|,
name|UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mrl"
block|,
name|mreadlist
block|,
block|{
name|UINT
block|,
name|UINT
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the peer variables in the variable list for multiple peers"
block|}
block|,
block|{
literal|"mreadvar"
block|,
name|mreadvar
block|,
block|{
name|UINT
block|,
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"mrv"
block|,
name|mreadvar
block|,
block|{
name|UINT
block|,
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|}
block|,
literal|"read peer variables from multiple peers"
block|}
block|,
block|{
literal|"clocklist"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"cl"
block|,
name|clocklist
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read the clock variables included in the variable list"
block|}
block|,
block|{
literal|"clockvar"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"cv"
block|,
name|clockvar
block|,
block|{
name|OPT
operator||
name|UINT
block|,
name|OPT
operator||
name|STR
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|"name=value[,...]"
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"read clock variables"
block|}
block|,
block|{
literal|"pstatus"
block|,
name|pstatus
block|,
block|{
name|UINT
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|"assocID"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print status information returned for a peer"
block|}
block|,
block|{
literal|"peers"
block|,
name|peers
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of the server's peers"
block|}
block|,
block|{
literal|"lpeers"
block|,
name|lpeers
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients"
block|}
block|,
block|{
literal|"opeers"
block|,
name|opeers
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"print peer list the old way, with dstadr shown rather than refid"
block|}
block|,
block|{
literal|"lopeers"
block|,
name|lopeers
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|"obtain and print a list of all peers and clients showing dstadr"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
name|NO
block|,
name|NO
block|,
name|NO
block|,
name|NO
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable list data space  */
end_comment

begin_define
define|#
directive|define
name|MAXLIST
value|64
end_define

begin_comment
comment|/* maximum number of variables in list */
end_comment

begin_define
define|#
directive|define
name|LENHOSTNAME
value|256
end_define

begin_comment
comment|/* host name is 256 characters long */
end_comment

begin_comment
comment|/*  * Old CTL_PST defines for version 2.  */
end_comment

begin_define
define|#
directive|define
name|OLD_CTL_PST_CONFIG
value|0x80
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENABLE
value|0x40
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_AUTHENTIC
value|0x20
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_REACH
value|0x10
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SANE
value|0x08
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_DISP
value|0x04
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_REJECT
value|0
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SELCAND
value|1
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYNCCAND
value|2
end_define

begin_define
define|#
directive|define
name|OLD_CTL_PST_SEL_SYSPEER
value|3
end_define

begin_decl_stmt
name|char
name|flash2
index|[]
init|=
literal|" .+*    "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for version 2 */
end_comment

begin_decl_stmt
name|char
name|flash3
index|[]
init|=
literal|" x.-+#*o"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flash decode for peer status version 3 */
end_comment

begin_struct
struct|struct
name|varlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|varlist
index|[
name|MAXLIST
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Imported from ntpq.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|showhostnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rawmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|servent
modifier|*
name|server_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|association
name|assoc_cache
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|numassoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
name|pktversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ctl_var
name|peer_var
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For quick string comparisons  */
end_comment

begin_define
define|#
directive|define
name|STREQ
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(a) == *(b)&& strcmp((a), (b)) == 0)
end_define

begin_comment
comment|/*  * checkassocid - return the association ID, checking to see if it is valid  */
end_comment

begin_function
specifier|static
name|int
name|checkassocid
parameter_list|(
name|u_int32
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
operator|||
name|value
operator|>=
literal|65536
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Invalid association ID specified\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * strsave - save a string  * XXX - should be in libntp.a  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strsave
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Malloc failed!!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * findlistvar - look for the named variable in a list and return if found  */
end_comment

begin_function
specifier|static
name|struct
name|varlist
modifier|*
name|findlistvar
parameter_list|(
name|struct
name|varlist
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|list
init|;
name|vl
operator|<
name|list
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|vl
operator|->
name|name
argument_list|)
condition|)
return|return
name|vl
return|;
if|if
condition|(
name|vl
operator|<
name|list
operator|+
name|MAXLIST
condition|)
return|return
name|vl
return|;
return|return
operator|(
expr|struct
name|varlist
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * doaddvlist - add variable(s) to the variable list  */
end_comment

begin_function
specifier|static
name|void
name|doaddvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|char
modifier|*
name|vars
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable list full\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vl
operator|->
name|name
operator|==
literal|0
condition|)
block|{
name|vl
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|vl
operator|->
name|value
operator|=
name|strsave
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * dormvlist - remove variable(s) from the variable list  */
end_comment

begin_function
specifier|static
name|void
name|dormvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|char
modifier|*
name|vars
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vars
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|vars
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|vl
operator|=
name|findlistvar
argument_list|(
name|vlist
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|==
literal|0
operator|||
name|vl
operator|->
name|name
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable `%s' not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|vl
operator|+
literal|1
operator|)
operator|<
operator|(
name|varlist
operator|+
name|MAXLIST
operator|)
operator|&&
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|vl
operator|->
name|name
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|name
expr_stmt|;
name|vl
operator|->
name|value
operator|=
operator|(
name|vl
operator|+
literal|1
operator|)
operator|->
name|value
expr_stmt|;
block|}
name|vl
operator|->
name|name
operator|=
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * doclearvlist - clear a variable list  */
end_comment

begin_function
specifier|static
name|void
name|doclearvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
name|vl
operator|->
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|vl
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * makequerydata - form a data buffer to be included with a query  */
end_comment

begin_function
specifier|static
name|void
name|makequerydata
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
modifier|*
name|datalen
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpend
decl_stmt|;
specifier|register
name|int
name|namelen
decl_stmt|,
name|valuelen
decl_stmt|;
specifier|register
name|int
name|totallen
decl_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|cpend
operator|=
name|data
operator|+
operator|*
name|datalen
expr_stmt|;
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
name|namelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|->
name|value
operator|==
literal|0
condition|)
name|valuelen
operator|=
literal|0
expr_stmt|;
else|else
name|valuelen
operator|=
name|strlen
argument_list|(
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|namelen
operator|+
name|valuelen
operator|+
operator|(
name|valuelen
operator|!=
literal|0
operator|)
operator|+
operator|(
name|cp
operator|!=
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|totallen
operator|>
name|cpend
condition|)
break|break;
if|if
condition|(
name|cp
operator|!=
name|data
condition|)
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|namelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|namelen
expr_stmt|;
if|if
condition|(
name|valuelen
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|vl
operator|->
name|value
argument_list|,
operator|(
name|unsigned
operator|)
name|valuelen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|valuelen
expr_stmt|;
block|}
block|}
operator|*
name|datalen
operator|=
name|cp
operator|-
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * doquerylist - send a message including variables in a list  */
end_comment

begin_function
specifier|static
name|int
name|doquerylist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|auth
parameter_list|,
name|u_short
modifier|*
name|rstatus
parameter_list|,
name|int
modifier|*
name|dsize
parameter_list|,
name|char
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|char
name|data
index|[
name|CTL_MAX_DATA_LEN
index|]
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|datalen
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|makequerydata
argument_list|(
name|vlist
argument_list|,
operator|&
name|datalen
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|doquery
argument_list|(
name|op
argument_list|,
name|associd
argument_list|,
name|auth
argument_list|,
name|datalen
argument_list|,
name|data
argument_list|,
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * doprintvlist - print the variables on a list  */
end_comment

begin_function
specifier|static
name|void
name|doprintvlist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|struct
name|varlist
modifier|*
name|vl
decl_stmt|;
if|if
condition|(
name|vlist
operator|->
name|name
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No variables on list\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|vl
operator|=
name|vlist
init|;
name|vl
operator|<
name|vlist
operator|+
name|MAXLIST
operator|&&
name|vl
operator|->
name|name
operator|!=
literal|0
condition|;
name|vl
operator|++
control|)
block|{
if|if
condition|(
name|vl
operator|->
name|value
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|vl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s=%s\n"
argument_list|,
name|vl
operator|->
name|name
argument_list|,
name|vl
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * addvars - add variables to the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|addvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doaddvlist
argument_list|(
name|varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rmvars - remove variables from the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|rmvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|dormvlist
argument_list|(
name|varlist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clearvars - clear the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|clearvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doclearvlist
argument_list|(
name|varlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * showvars - show variables on the variable list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|showvars
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doprintvlist
argument_list|(
name|varlist
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dolist - send a request with the given list of variables  */
end_comment

begin_function
specifier|static
name|int
name|dolist
parameter_list|(
name|struct
name|varlist
modifier|*
name|vlist
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|type
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|vlist
argument_list|,
name|op
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|associd
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No system%s variables returned\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No information returned for%s association %u\n"
argument_list|,
operator|(
name|type
operator|==
name|TYPE_CLOCK
operator|)
condition|?
literal|" clock"
else|:
literal|""
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|type
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * readlist - send a read variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|readlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|associd
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: I think we want the u_int32 target here, not the u_long */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
operator|(
name|void
operator|)
name|dolist
argument_list|(
name|varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
operator|(
name|associd
operator|==
literal|0
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writelist - send a write variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|writelist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HMS: Do we really want uval here? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
name|res
operator|=
name|doquerylist
argument_list|(
name|varlist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
operator|(
name|associd
operator|!=
literal|0
operator|)
condition|?
name|TYPE_PEER
else|:
name|TYPE_SYS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * readvar - send a read variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|readvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|associd
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|2
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READVAR
argument_list|,
operator|(
name|associd
operator|==
literal|0
operator|)
condition|?
name|TYPE_SYS
else|:
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * writevar - send a write variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|writevar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
name|res
operator|=
name|doquerylist
argument_list|(
name|tmplist
argument_list|,
name|CTL_OP_WRITEVAR
argument_list|,
name|associd
argument_list|,
literal|1
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"done! (no data returned)\n"
argument_list|)
expr_stmt|;
else|else
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
operator|(
name|associd
operator|!=
literal|0
operator|)
condition|?
name|TYPE_PEER
else|:
name|TYPE_SYS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * clocklist - send a clock variables request with the variables on the list  */
end_comment

begin_function
specifier|static
name|void
name|clocklist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|associd
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
condition|)
block|{
name|associd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
block|}
operator|(
name|void
operator|)
name|dolist
argument_list|(
name|varlist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clockvar - send a clock variables request with the specified variables  */
end_comment

begin_function
specifier|static
name|void
name|clockvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|associd
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|==
literal|0
operator|||
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
operator|==
literal|0
condition|)
name|associd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|2
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dolist
argument_list|(
name|tmplist
argument_list|,
name|associd
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|TYPE_CLOCK
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * findassidrange - verify a range of association ID's  */
end_comment

begin_function
specifier|static
name|int
name|findassidrange
parameter_list|(
name|u_int32
name|assid1
parameter_list|,
name|u_int32
name|assid2
parameter_list|,
name|int
modifier|*
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|f
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|assid1
operator|==
literal|0
operator|||
name|assid1
operator|>
literal|65535
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Invalid association ID %lu specified\n"
argument_list|,
operator|(
name|u_long
operator|)
name|assid1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|assid2
operator|==
literal|0
operator|||
name|assid2
operator|>
literal|65535
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Invalid association ID %lu specified\n"
argument_list|,
operator|(
name|u_long
operator|)
name|assid2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|f
operator|=
name|t
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
operator|==
name|assid1
condition|)
block|{
name|f
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|t
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
operator|==
name|assid2
condition|)
block|{
name|t
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|f
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
operator|-
literal|1
operator|||
name|t
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Association ID %lu not found in list\n"
argument_list|,
operator|(
name|f
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|u_long
operator|)
name|assid1
else|:
operator|(
name|u_long
operator|)
name|assid2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|f
operator|<
name|t
condition|)
block|{
operator|*
name|from
operator|=
name|f
expr_stmt|;
operator|*
name|to
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
operator|*
name|from
operator|=
name|t
expr_stmt|;
operator|*
name|to
operator|=
name|f
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * mreadlist - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadlist
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|from
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|varlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * mreadvar - send a read variables request for multiple associations  */
end_comment

begin_function
specifier|static
name|void
name|mreadvar
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
name|struct
name|varlist
name|tmplist
index|[
name|MAXLIST
index|]
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|!
name|findassidrange
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|1
index|]
operator|.
name|uval
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
return|return;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcmd
operator|->
name|nargs
operator|>=
literal|3
condition|)
name|doaddvlist
argument_list|(
name|tmplist
argument_list|,
name|pcmd
operator|->
name|argval
index|[
literal|2
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<=
name|to
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|from
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dolist
argument_list|(
name|varlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
condition|)
break|break;
block|}
name|doclearvlist
argument_list|(
name|tmplist
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * dogetassoc - query the host for its list of associations  */
end_comment

begin_function
specifier|static
name|int
name|dogetassoc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_short
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READSTAT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's returned\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dsize
operator|&
literal|0x3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Server returned %d octets, should be multiple of 4\n"
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|numassoc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dsize
operator|>
literal|0
condition|)
block|{
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|assid
operator|=
name|ntohs
argument_list|(
operator|*
name|datap
argument_list|)
expr_stmt|;
name|datap
operator|++
expr_stmt|;
name|assoc_cache
index|[
name|numassoc
index|]
operator|.
name|status
operator|=
name|ntohs
argument_list|(
operator|*
name|datap
argument_list|)
expr_stmt|;
name|datap
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|numassoc
operator|>=
name|MAXASSOC
condition|)
break|break;
name|dsize
operator|-=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|sortassoc
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * printassoc - print the current list of associations  */
end_comment

begin_function
specifier|static
name|void
name|printassoc
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|statval
decl_stmt|;
name|int
name|event
decl_stmt|;
name|u_long
name|event_count
decl_stmt|;
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
specifier|const
name|char
modifier|*
name|reach
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth
decl_stmt|;
specifier|const
name|char
modifier|*
name|condition
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_event
decl_stmt|;
specifier|const
name|char
modifier|*
name|cnt
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|numassoc
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No association ID's in list\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Output a header 	 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ind assID status  conf reach auth condition  last_event cnt\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"===========================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
name|statval
operator|=
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|statval
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
name|event
operator|=
name|CTL_PEER_EVENT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
name|event_count
operator|=
name|CTL_PEER_NEVNT
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_CONFIG
condition|)
name|conf
operator|=
literal|"yes"
expr_stmt|;
else|else
name|conf
operator|=
literal|"no"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_REACH
condition|)
block|{
name|reach
operator|=
literal|"yes"
expr_stmt|;
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENABLE
condition|)
block|{
if|if
condition|(
name|statval
operator|&
name|CTL_PST_AUTHENTIC
condition|)
name|auth
operator|=
literal|"ok "
expr_stmt|;
else|else
name|auth
operator|=
literal|"bad"
expr_stmt|;
block|}
else|else
name|auth
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
switch|switch
condition|(
name|statval
operator|&
literal|0x7
condition|)
block|{
case|case
name|CTL_PST_SEL_REJECT
case|:
name|condition
operator|=
literal|"reject"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SANE
case|:
name|condition
operator|=
literal|"falsetick"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_CORRECT
case|:
name|condition
operator|=
literal|"excess"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"outlyer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"candidat"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_DISTSYSPEER
case|:
name|condition
operator|=
literal|"selected"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys.peer"
expr_stmt|;
break|break;
case|case
name|CTL_PST_SEL_PPS
case|:
name|condition
operator|=
literal|"pps.peer"
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|statval
operator|&
literal|0x3
condition|)
block|{
case|case
name|OLD_CTL_PST_SEL_REJECT
case|:
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_SANE
operator|)
condition|)
name|condition
operator|=
literal|"insane"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|statval
operator|&
name|OLD_CTL_PST_DISP
operator|)
condition|)
name|condition
operator|=
literal|"hi_disp"
expr_stmt|;
else|else
name|condition
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SELCAND
case|:
name|condition
operator|=
literal|"sel_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYNCCAND
case|:
name|condition
operator|=
literal|"sync_cand"
expr_stmt|;
break|break;
case|case
name|OLD_CTL_PST_SEL_SYSPEER
case|:
name|condition
operator|=
literal|"sys_peer"
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|reach
operator|=
literal|"no"
expr_stmt|;
name|auth
operator|=
name|condition
operator|=
literal|""
expr_stmt|;
block|}
switch|switch
condition|(
name|PEER_EVENT
operator||
name|event
condition|)
block|{
case|case
name|EVNT_PEERIPERR
case|:
name|last_event
operator|=
literal|"IP error"
expr_stmt|;
break|break;
case|case
name|EVNT_PEERAUTH
case|:
name|last_event
operator|=
literal|"auth fail"
expr_stmt|;
break|break;
case|case
name|EVNT_UNREACH
case|:
name|last_event
operator|=
literal|"lost reach"
expr_stmt|;
break|break;
case|case
name|EVNT_REACH
case|:
name|last_event
operator|=
literal|"reachable"
expr_stmt|;
break|break;
case|case
name|EVNT_PEERCLOCK
case|:
name|last_event
operator|=
literal|"clock expt"
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case EVNT_PEERSTRAT: 			last_event = "stratum chg"; 			break;
endif|#
directive|endif
default|default:
name|last_event
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|event_count
operator|!=
literal|0
condition|)
name|cnt
operator|=
name|uinttoa
argument_list|(
name|event_count
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|=
literal|""
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2s"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|,
name|conf
argument_list|,
name|reach
argument_list|,
name|auth
argument_list|,
name|condition
argument_list|,
name|last_event
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|bp
operator|>
name|buf
operator|&&
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
literal|' '
condition|)
operator|*
operator|(
operator|--
name|bp
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * associations - get, record and print a list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|associations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lassociations - get, record and print a long list of associations  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * passociations - print the association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|passociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpassociations - print the long association list  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpassociations
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|printassoc
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNUSED
end_ifdef

begin_comment
comment|/*  * radiostatus - print the radio status returned by the server  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|radiostatus
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READCLOCK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No radio status string returned\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|asciize
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_comment
comment|/*  * pstatus - print peer status returned by the server  */
end_comment

begin_function
specifier|static
name|void
name|pstatus
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|associd
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
comment|/* HMS: uval? */
if|if
condition|(
operator|(
name|associd
operator|=
name|checkassocid
argument_list|(
name|pcmd
operator|->
name|argval
index|[
literal|0
index|]
operator|.
name|uval
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READSTAT
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"No information returned for association %u\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return;
block|}
name|printvars
argument_list|(
name|dsize
argument_list|,
name|datap
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|TYPE_PEER
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * when - print how long its been since his last packet arrived  */
end_comment

begin_function
specifier|static
name|long
name|when
parameter_list|(
name|l_fp
modifier|*
name|ts
parameter_list|,
name|l_fp
modifier|*
name|rec
parameter_list|,
name|l_fp
modifier|*
name|reftime
parameter_list|)
block|{
name|l_fp
modifier|*
name|lasttime
decl_stmt|;
if|if
condition|(
name|rec
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|rec
expr_stmt|;
elseif|else
if|if
condition|(
name|reftime
operator|->
name|l_ui
operator|!=
literal|0
condition|)
name|lasttime
operator|=
name|reftime
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
operator|(
name|ts
operator|->
name|l_ui
operator|-
name|lasttime
operator|->
name|l_ui
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pretty-print an interval into the given buffer, in a human-friendly format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prettyinterval
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|diff
parameter_list|)
block|{
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|diff
operator|<=
literal|2048
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|300
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ldm"
argument_list|,
operator|(
name|long
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|29
operator|)
operator|/
literal|60
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|96
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ldh"
argument_list|,
operator|(
name|long
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|diff
operator|=
operator|(
name|diff
operator|+
literal|11
operator|)
operator|/
literal|24
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ldd"
argument_list|,
operator|(
name|long
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * A list of variables required by the peers command  */
end_comment

begin_decl_stmt
name|struct
name|varlist
name|opeervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"dstadr"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|varlist
name|peervarlist
index|[]
init|=
block|{
block|{
literal|"srcadr"
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|"refid"
block|,
literal|0
block|}
block|,
comment|/* 1 */
block|{
literal|"stratum"
block|,
literal|0
block|}
block|,
comment|/* 2 */
block|{
literal|"hpoll"
block|,
literal|0
block|}
block|,
comment|/* 3 */
block|{
literal|"ppoll"
block|,
literal|0
block|}
block|,
comment|/* 4 */
block|{
literal|"reach"
block|,
literal|0
block|}
block|,
comment|/* 5 */
block|{
literal|"delay"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"offset"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|"jitter"
block|,
literal|0
block|}
block|,
comment|/* 8 */
block|{
literal|"dispersion"
block|,
literal|0
block|}
block|,
comment|/* 9 */
block|{
literal|"rec"
block|,
literal|0
block|}
block|,
comment|/* 10 */
block|{
literal|"reftime"
block|,
literal|0
block|}
block|,
comment|/* 11 */
block|{
literal|"srcport"
block|,
literal|0
block|}
block|,
comment|/* 12 */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAVE_SRCADR
value|0
end_define

begin_define
define|#
directive|define
name|HAVE_DSTADR
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_REFID
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_STRATUM
value|2
end_define

begin_define
define|#
directive|define
name|HAVE_HPOLL
value|3
end_define

begin_define
define|#
directive|define
name|HAVE_PPOLL
value|4
end_define

begin_define
define|#
directive|define
name|HAVE_REACH
value|5
end_define

begin_define
define|#
directive|define
name|HAVE_DELAY
value|6
end_define

begin_define
define|#
directive|define
name|HAVE_OFFSET
value|7
end_define

begin_define
define|#
directive|define
name|HAVE_JITTER
value|8
end_define

begin_define
define|#
directive|define
name|HAVE_DISPERSION
value|9
end_define

begin_define
define|#
directive|define
name|HAVE_REC
value|10
end_define

begin_define
define|#
directive|define
name|HAVE_REFTIME
value|11
end_define

begin_define
define|#
directive|define
name|HAVE_SRCPORT
value|12
end_define

begin_define
define|#
directive|define
name|MAXHAVE
value|13
end_define

begin_comment
comment|/*  * Decode an incoming data buffer and print a line in the peer list  */
end_comment

begin_function
specifier|static
name|int
name|doprintpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|int
name|associd
parameter_list|,
name|int
name|rstatus
parameter_list|,
name|int
name|datalen
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|u_int32
name|srcadr
decl_stmt|;
name|u_int32
name|dstadr
decl_stmt|;
name|u_long
name|srcport
decl_stmt|;
specifier|const
name|char
modifier|*
name|dstadr_refid
init|=
literal|"0.0.0.0"
decl_stmt|;
name|u_long
name|stratum
decl_stmt|;
name|long
name|ppoll
decl_stmt|;
name|long
name|hpoll
decl_stmt|;
name|u_long
name|reach
decl_stmt|;
name|l_fp
name|estoffset
decl_stmt|;
name|l_fp
name|estdelay
decl_stmt|;
name|l_fp
name|estjitter
decl_stmt|;
name|l_fp
name|estdisp
decl_stmt|;
name|l_fp
name|reftime
decl_stmt|;
name|l_fp
name|rec
decl_stmt|;
name|l_fp
name|ts
decl_stmt|;
name|u_char
name|havevar
index|[
name|MAXHAVE
index|]
decl_stmt|;
name|u_long
name|poll_sec
decl_stmt|;
name|char
name|type
init|=
literal|'?'
decl_stmt|;
name|char
name|refid_string
index|[
literal|10
index|]
decl_stmt|;
name|char
name|whenbuf
index|[
literal|8
index|]
decl_stmt|,
name|pollbuf
index|[
literal|8
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|havevar
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|havevar
argument_list|)
argument_list|)
expr_stmt|;
name|get_systime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|datalen
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|u_int32
name|dummy
decl_stmt|;
name|i
operator|=
name|findvar
argument_list|(
name|name
argument_list|,
name|peer_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't know this one */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|CP_SRCADR
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|srcadr
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_SRCADR
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_DSTADR
case|:
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|dummy
argument_list|)
condition|)
block|{
name|dummy
operator|=
name|ntohl
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
operator|(
name|dummy
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xe0000000
operator|)
condition|?
literal|'m'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0x000000ff
operator|)
condition|?
literal|'b'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffff
operator|)
operator|==
literal|0x7f000001
operator|)
condition|?
literal|'l'
else|:
operator|(
operator|(
name|dummy
operator|&
literal|0xffffffe0
operator|)
operator|==
literal|0x00000000
operator|)
condition|?
literal|'-'
else|:
literal|'u'
expr_stmt|;
block|}
if|if
condition|(
name|pvl
operator|==
name|opeervarlist
condition|)
block|{
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|dstadr
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_DSTADR
index|]
operator|=
literal|1
expr_stmt|;
name|dstadr_refid
operator|=
name|numtoa
argument_list|(
name|dstadr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CP_REFID
case|:
if|if
condition|(
name|pvl
operator|==
name|peervarlist
condition|)
block|{
name|havevar
index|[
name|HAVE_REFID
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'\0'
condition|)
block|{
name|dstadr_refid
operator|=
literal|"0.0.0.0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decodenetnum
argument_list|(
name|value
argument_list|,
operator|&
name|dstadr
argument_list|)
condition|)
block|{
if|if
condition|(
name|dstadr
operator|==
literal|0
condition|)
name|dstadr_refid
operator|=
literal|"0.0.0.0"
expr_stmt|;
else|else
name|dstadr_refid
operator|=
name|nntohost
argument_list|(
name|dstadr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|value
argument_list|)
operator|<=
literal|4
condition|)
block|{
name|refid_string
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|refid_string
index|[
literal|1
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|refid_string
argument_list|)
expr_stmt|;
name|refid_string
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
name|refid_string
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dstadr_refid
operator|=
name|refid_string
expr_stmt|;
block|}
else|else
block|{
name|havevar
index|[
name|HAVE_REFID
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CP_STRATUM
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|stratum
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_STRATUM
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_HPOLL
case|:
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|hpoll
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_HPOLL
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hpoll
operator|<
literal|0
condition|)
name|hpoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CP_PPOLL
case|:
if|if
condition|(
name|decodeint
argument_list|(
name|value
argument_list|,
operator|&
name|ppoll
argument_list|)
condition|)
block|{
name|havevar
index|[
name|HAVE_PPOLL
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ppoll
operator|<
literal|0
condition|)
name|ppoll
operator|=
name|NTP_MINPOLL
expr_stmt|;
block|}
break|break;
case|case
name|CP_REACH
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|reach
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_REACH
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_DELAY
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdelay
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_DELAY
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_OFFSET
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estoffset
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_OFFSET
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_JITTER
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estjitter
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_JITTER
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_DISPERSION
case|:
if|if
condition|(
name|decodetime
argument_list|(
name|value
argument_list|,
operator|&
name|estdisp
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_DISPERSION
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_REC
case|:
if|if
condition|(
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|rec
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_REC
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_SRCPORT
case|:
if|if
condition|(
name|decodeuint
argument_list|(
name|value
argument_list|,
operator|&
name|srcport
argument_list|)
condition|)
name|havevar
index|[
name|HAVE_SRCPORT
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CP_REFTIME
case|:
name|havevar
index|[
name|HAVE_REFTIME
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|decodets
argument_list|(
name|value
argument_list|,
operator|&
name|reftime
argument_list|)
condition|)
name|L_CLR
argument_list|(
operator|&
name|reftime
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Check to see if the srcport is NTP's port.  If not this probably 	 * isn't a valid peer association. 	 */
if|if
condition|(
name|havevar
index|[
name|HAVE_SRCPORT
index|]
operator|&&
name|srcport
operator|!=
name|NTP_PORT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Got everything, format the line 	 */
name|poll_sec
operator|=
literal|1
operator|<<
name|max
argument_list|(
name|min3
argument_list|(
name|ppoll
argument_list|,
name|hpoll
argument_list|,
name|NTP_MAXPOLL
argument_list|)
argument_list|,
name|NTP_MINPOLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktversion
operator|>
name|NTP_OLDVERSION
condition|)
name|c
operator|=
name|flash3
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x7
index|]
expr_stmt|;
else|else
name|c
operator|=
name|flash2
index|[
name|CTL_PEER_STATVAL
argument_list|(
name|rstatus
argument_list|)
operator|&
literal|0x3
index|]
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*s "
argument_list|,
name|maxhostlen
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%c%-15.15s %-15.15s %2ld %c %4.4s %4.4s  %3lo  %7.7s %8.7s %7.7s\n"
argument_list|,
name|c
argument_list|,
name|nntohost
argument_list|(
name|srcadr
argument_list|)
argument_list|,
name|dstadr_refid
argument_list|,
name|stratum
argument_list|,
name|type
argument_list|,
name|prettyinterval
argument_list|(
name|whenbuf
argument_list|,
name|when
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|rec
argument_list|,
operator|&
name|reftime
argument_list|)
argument_list|)
argument_list|,
name|prettyinterval
argument_list|(
name|pollbuf
argument_list|,
operator|(
name|int
operator|)
name|poll_sec
argument_list|)
argument_list|,
name|reach
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estdelay
argument_list|,
literal|3
argument_list|)
argument_list|,
name|lfptoms
argument_list|(
operator|&
name|estoffset
argument_list|,
literal|3
argument_list|)
argument_list|,
name|havevar
index|[
name|HAVE_JITTER
index|]
condition|?
name|lfptoms
argument_list|(
operator|&
name|estjitter
argument_list|,
literal|3
argument_list|)
else|:
name|lfptoms
argument_list|(
operator|&
name|estdisp
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|HAVE_SRCADR
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_DSTADR
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_STRATUM
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_PPOLL
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_HPOLL
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REACH
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTDELAY
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTOFFSET
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_JITTER
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_ESTDISP
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REFID
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REC
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_SRCPORT
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_REFTIME
end_undef

begin_undef
undef|#
directive|undef
name|MAXHAVE
end_undef

begin_comment
comment|/*  * dogetpeers - given an association ID, read and print the spreadsheet  *		peer variables.  */
end_comment

begin_function
specifier|static
name|int
name|dogetpeers
parameter_list|(
name|struct
name|varlist
modifier|*
name|pvl
parameter_list|,
name|int
name|associd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|res
operator|=
name|doquerylist
argument_list|(
name|pvl
argument_list|,
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Damn fuzzballs 	 */
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No information returned for association %d\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|doprintpeers
argument_list|(
name|pvl
argument_list|,
name|associd
argument_list|,
operator|(
name|int
operator|)
name|rstatus
argument_list|,
name|dsize
argument_list|,
name|datap
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|dopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|fullname
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|u_int32
name|netnum
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
name|maxhostlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numhosts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|getnetnum
argument_list|(
name|chosts
index|[
name|i
index|]
argument_list|,
operator|&
name|netnum
argument_list|,
name|fullname
argument_list|)
condition|)
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|fullname
argument_list|)
operator|>
name|maxhostlen
condition|)
name|maxhostlen
operator|=
name|strlen
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%-*.*s "
argument_list|,
name|maxhostlen
argument_list|,
name|maxhostlen
argument_list|,
literal|"host"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           refid      st t when poll reach   delay   offset  jitter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxhostlen
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|peervarlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * peers - print a peer spreadsheet  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|peers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|dopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lpeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lpeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|dopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet  */
end_comment

begin_function
specifier|static
name|void
name|doopeers
parameter_list|(
name|int
name|showall
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dogetassoc
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"     remote           local      st t when poll reach   delay   offset    disp\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"==============================================================================\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|showall
operator|&&
operator|!
operator|(
name|CTL_PEER_STATVAL
argument_list|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|status
argument_list|)
operator|&
operator|(
name|CTL_PST_CONFIG
operator||
name|CTL_PST_REACH
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dogetpeers
argument_list|(
name|opeervarlist
argument_list|,
operator|(
name|int
operator|)
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
argument_list|,
name|fp
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * opeers - print a peer spreadsheet the old way  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|opeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doopeers
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lopeers - print a peer spreadsheet including all fuzzball peers  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lopeers
parameter_list|(
name|struct
name|parse
modifier|*
name|pcmd
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|doopeers
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

