begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *  *  libntpq.c  *  *  This is the wrapper library for ntpq, the NTP query utility.   *  This library reuses the sourcecode from ntpq and exports a number  *  of useful functions in a library that can be linked against applications  *  that need to query the status of a running ntpd. The whole   *  communcation is based on mode 6 packets.  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|LIBNTPQ_C
end_define

begin_define
define|#
directive|define
name|NO_MAIN_ALLOWED
value|1
end_define

begin_comment
comment|/* #define BUILD_AS_LIB		Already provided by the Makefile */
end_comment

begin_include
include|#
directive|include
file|"ntpq.c"
end_include

begin_include
include|#
directive|include
file|"libntpq.h"
end_include

begin_comment
comment|/* Function Prototypes */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|Version
init|=
literal|"libntpq 0.3beta"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global variables used for holding snapshots of data */
end_comment

begin_decl_stmt
name|char
name|peervars
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|peervarlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|associd_t
name|peervar_assoc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|clockvars
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clockvarlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clockvar_assoc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|sysvars
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sysvarlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ntpq_resultbuffer
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|ntpq_associations
index|[
name|MAXASSOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ntpq_varlist
name|ntpq_varlist
index|[
name|MAXLIST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************  *  *  ntpq_stripquotes  *  *  Parses a given character buffer srcbuf and removes all quoted  *  characters. The resulting string is copied to the specified   *  resultbuf character buffer.  E.g. \" will be translated into "  *   ****************************************************************************  * Parameters:  *	resultbuf	char*	The resulting string without quoted  *				characters  *	srcbuf		char*	The buffer holding the original string  *	datalen		int	The number of bytes stored in srcbuf  *	maxlen		int	Max. number of bytes for resultbuf  *  * Returns:  *	int		number of chars that have been copied to   *			resultbuf   ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_stripquotes
parameter_list|(
name|char
modifier|*
name|resultbuf
parameter_list|,
name|char
modifier|*
name|srcbuf
parameter_list|,
name|int
name|datalen
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|char
modifier|*
name|tmpbuf
init|=
name|srcbuf
decl_stmt|;
while|while
condition|(
operator|*
name|tmpbuf
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'\"'
condition|)
block|{
name|tmpbuf
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|tmpbuf
operator|==
literal|'\\'
condition|)
block|{
name|tmpbuf
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|tmpbuf
condition|)
block|{
comment|/* ignore if end of string */
case|case
literal|0
case|:
continue|continue;
comment|/* skip and do not copy */
case|case
literal|'\"'
case|:
comment|/* quotes */
case|case
literal|'n'
case|:
comment|/*newline*/
case|case
literal|'r'
case|:
comment|/*carriage return*/
case|case
literal|'g'
case|:
comment|/*bell*/
case|case
literal|'t'
case|:
comment|/*tab*/
name|tmpbuf
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|resultbuf
operator|++
operator|=
operator|*
name|tmpbuf
operator|++
expr_stmt|;
block|}
operator|*
name|resultbuf
operator|=
literal|0
expr_stmt|;
return|return
name|strlen
argument_list|(
name|resultbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_getvar  *  *  This function parses a given buffer for a variable/value pair and  *  copies the value of the requested variable into the specified  *  varvalue buffer.  *  *  It returns the number of bytes copied or zero for an empty result  *  (=no matching variable found or empty value)  *  ****************************************************************************  * Parameters:  *	resultbuf	char*	The resulting string without quoted  *				characters  *	datalen		size_t	The number of bytes stored in   *							resultbuf  *	varname		char*	Name of the required variable   *	varvalue	char*	Where the value of the variable should  *							be stored  *	maxlen		size_t	Max. number of bytes for varvalue  *  * Returns:  *	size_t		number of chars that have been copied to   *			varvalue  ****************************************************************************/
end_comment

begin_function
name|size_t
name|ntpq_getvar
parameter_list|(
specifier|const
name|char
modifier|*
name|resultbuf
parameter_list|,
name|size_t
name|datalen
parameter_list|,
specifier|const
name|char
modifier|*
name|varname
parameter_list|,
name|char
modifier|*
name|varvalue
parameter_list|,
name|size_t
name|maxlen
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|idatalen
decl_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
name|idatalen
operator|=
operator|(
name|int
operator|)
name|datalen
expr_stmt|;
while|while
condition|(
name|nextvar
argument_list|(
operator|&
name|idatalen
argument_list|,
operator|&
name|resultbuf
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|varname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ntpq_stripquotes
argument_list|(
name|varvalue
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|varvalue
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_queryhost  *  *  Sends a mode 6 query packet to the current open host (see   *  ntpq_openhost) and stores the requested variable set in the specified  *  character buffer.   *  It returns the number of bytes read or zero for an empty result  *  (=no answer or empty value)  *  ****************************************************************************  * Parameters:  *      VARSET		u_short	Which variable set should be  *				read (PEERVARS or CLOCKVARS)  *	association	int	The association ID that should be read  *				0 represents the ntpd instance itself  *	resultbuf	char*	The resulting string without quoted  *				characters  *	maxlen		int	Max. number of bytes for varvalue  *  * Returns:  *	int		number of bytes that have been copied to   *			resultbuf  *  			- OR -  *			0 (zero) if no reply has been received or  *			another failure occured  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_queryhost
parameter_list|(
name|unsigned
name|short
name|VARSET
parameter_list|,
name|unsigned
name|short
name|association
parameter_list|,
name|char
modifier|*
name|resultbuf
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
if|if
condition|(
name|numhosts
operator|>
literal|0
condition|)
name|res
operator|=
name|doquery
argument_list|(
name|VARSET
argument_list|,
name|association
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|res
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dsize
operator|==
literal|0
operator|)
condition|)
comment|/* no data */
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|>
name|maxlen
condition|)
name|dsize
operator|=
name|maxlen
expr_stmt|;
comment|/* fill result resultbuf */
name|memcpy
argument_list|(
name|resultbuf
argument_list|,
name|datap
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
name|dsize
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_openhost  *  *  Sets up a connection to the ntpd instance of a specified host. Note:  *  There is no real "connection" established because NTP solely works  *  based on UDP.  *  ****************************************************************************  * Parameters:  *	hostname	char*	Hostname/IP of the host running ntpd  *	fam		int	Address Family (AF_INET, AF_INET6, or 0)  *  * Returns:  *	int		1 if the host connection could be set up, i.e.   *			name resolution was succesful and/or IP address  *			has been validated  *  			- OR -  *			0 (zero) if a failure occured  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_openhost
parameter_list|(
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|fam
parameter_list|)
block|{
if|if
condition|(
name|openhost
argument_list|(
name|hostname
argument_list|,
name|fam
argument_list|)
condition|)
block|{
name|numhosts
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|numhosts
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|numhosts
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_closehost  *  *  Cleans up a connection by closing the used socket. Should be called  *  when no further queries are required for the currently used host.  *  ****************************************************************************  * Parameters:  *	- none -  *  * Returns:  *	int		0 (zero) if no host has been opened before  *			- OR -  *			the resultcode from the closesocket function call  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_closehost
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|numhosts
condition|)
return|return
name|closesocket
argument_list|(
name|sockfd
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_read_associations  *  *  This function queries the ntp host for its associations and returns the   *  number of associations found.  *  *  It takes an u_short array as its first parameter, this array holds the   *  IDs of the associations,   *  the function will not write more entries than specified with the   *  max_entries parameter.  *  *  However, if more than max_entries associations were found, the return   *  value of this function will reflect the real number, even if not all   *  associations have been stored in the array.  *  ****************************************************************************  * Parameters:  *	resultbuf	u_short*Array that should hold the list of  *				association IDs  *	maxentries	int	maximum number of association IDs that can  *				be stored in resultbuf  *  * Returns:  *	int		number of association IDs stored in resultbuf  *  			- OR -  *			0 (zero) if a failure occured or no association has  *			been returned.  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_read_associations
parameter_list|(
name|u_short
name|resultbuf
index|[]
parameter_list|,
name|int
name|max_entries
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ntpq_dogetassoc
argument_list|()
condition|)
block|{
if|if
condition|(
name|numassoc
operator|<
name|max_entries
condition|)
name|max_entries
operator|=
name|numassoc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_entries
condition|;
name|i
operator|++
control|)
name|resultbuf
index|[
name|i
index|]
operator|=
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
expr_stmt|;
return|return
name|numassoc
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_get_assocs  *  *  This function reads the associations of a previously selected (with   *  ntpq_openhost) NTP host into its own (global) array and returns the   *  number of associations found.   *  *  The obtained association IDs can be read by using the ntpq_get_assoc_id   *  function.  *  ****************************************************************************  * Parameters:  *	- none -  *  * Returns:  *	int		number of association IDs stored in resultbuf  *  			- OR -  *			0 (zero) if a failure occured or no association has  *			been returned.  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assocs
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ntpq_read_associations
argument_list|(
name|ntpq_associations
argument_list|,
name|MAXASSOC
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_get_assoc_number  *  *  This function returns for a given Association ID the association number   *  in the internal association array, which is filled by the ntpq_get_assocs   *  function.  *   ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *  * Returns:  *	int		the number of the association array element that is  *			representing the given association ID  *  			- OR -  *			-1 if a failure occured or no matching association   * 			ID has been found  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assoc_number
parameter_list|(
name|associd_t
name|associd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numassoc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|assoc_cache
index|[
name|i
index|]
operator|.
name|assid
operator|==
name|associd
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_read_assoc_peervars  *  *  This function reads the peervars variable-set of a specified association   *  from a NTP host and writes it to the result buffer specified, honoring   *  the maxsize limit.  *  *  It returns the number of bytes written or 0 when the variable-set is   *  empty or failed to read.  *    ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *	resultbuf	char*	character buffer where the variable set  *				should be stored  *	maxsize		int	the maximum number of bytes that can be  *				written to resultbuf  *  * Returns:  *	int		number of chars that have been copied to   *			resultbuf  *			- OR -   *			0 (zero) if an error occured  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_read_assoc_peervars
parameter_list|(
name|associd_t
name|associd
parameter_list|,
name|char
modifier|*
name|resultbuf
parameter_list|,
name|int
name|maxsize
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READVAR
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No information returned for association %d\n"
argument_list|,
name|associd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dsize
operator|>
name|maxsize
condition|)
name|dsize
operator|=
name|maxsize
expr_stmt|;
name|memcpy
argument_list|(
name|resultbuf
argument_list|,
name|datap
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
return|return
name|dsize
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_read_sysvars  *  *  This function reads the sysvars variable-set from a NTP host and writes it  *  to the result buffer specified, honoring the maxsize limit.  *  *  It returns the number of bytes written or 0 when the variable-set is empty  *  or could not be read.  *    ****************************************************************************  * Parameters:  *	resultbuf	char*	character buffer where the variable set  *				should be stored  *	maxsize		int	the maximum number of bytes that can be  *				written to resultbuf  *  * Returns:  *	int		number of chars that have been copied to   *			resultbuf  *			- OR -   *			0 (zero) if an error occured  ****************************************************************************/
end_comment

begin_function
name|size_t
name|ntpq_read_sysvars
parameter_list|(
name|char
modifier|*
name|resultbuf
parameter_list|,
name|size_t
name|maxsize
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|i_dsize
decl_stmt|;
name|size_t
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|doquery
argument_list|(
name|CTL_OP_READVAR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|i_dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i_dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"server=%s "
argument_list|,
name|currenthost
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***No sysvar information returned\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|dsize
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|i_dsize
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|min
argument_list|(
name|dsize
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|resultbuf
argument_list|,
name|datap
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|dsize
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  ntpq_get_assoc_allvars  *  *  With this function all association variables for the specified association  *  ID can be requested from a NTP host. They are stored internally and can be  *  read by using the ntpq_get_peervar or ntpq_get_clockvar functions.  *  *  Basically this is only a combination of the ntpq_get_assoc_peervars and   *  ntpq_get_assoc_clockvars functions.  *  *  It returns 1 if both variable-sets (peervars and clockvars) were   *  received successfully. If one variable-set or both of them weren't   *  received,  *  ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *  * Returns:  *	int		nonzero if at least one variable set could be read  * 			- OR -   *			0 (zero) if an error occured and both variable sets  *			could not be read  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assoc_allvars
parameter_list|(
name|associd_t
name|associd
parameter_list|)
block|{
return|return
name|ntpq_get_assoc_peervars
argument_list|(
name|associd
argument_list|)
operator|&
name|ntpq_get_assoc_clockvars
argument_list|(
name|associd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  ntpq_get_sysvars  *  *  The system variables of a NTP host can be requested by using this function  *  and afterwards using ntpq_get_sysvar to read the single variable values.  *  ****************************************************************************  * Parameters:  *	- none -  *  * Returns:  *	int		nonzero if the variable set could be read  * 			- OR -   *			0 (zero) if an error occured and the sysvars  *			could not be read  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_sysvars
parameter_list|(
name|void
parameter_list|)
block|{
name|sysvarlen
operator|=
name|ntpq_read_sysvars
argument_list|(
name|sysvars
argument_list|,
sizeof|sizeof
argument_list|(
name|sysvars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysvarlen
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntp_get_peervar  *  *  This function uses the variable-set which was read by using   *  ntp_get_peervars and searches for a variable specified with varname. If   *  such a variable exists, it writes its value into  *  varvalue (maxlen specifies the size of this target buffer).  *    ****************************************************************************  * Parameters:  *	varname		char*	requested variable name  *	varvalue	char*	the buffer where the value should go into  *	maxlen		int	maximum number of bytes that can be copied to  *				varvalue  *  * Returns:  *	int		number of bytes copied to varvalue  * 			- OR -   *			0 (zero) if an error occured or the variable could   *			not be found  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_peervar
parameter_list|(
specifier|const
name|char
modifier|*
name|varname
parameter_list|,
name|char
modifier|*
name|varvalue
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
return|return
operator|(
name|ntpq_getvar
argument_list|(
name|peervars
argument_list|,
name|peervarlen
argument_list|,
name|varname
argument_list|,
name|varvalue
argument_list|,
name|maxlen
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_get_assoc_peervars  *  *  This function requests the peer variables of the specified association   *  from a NTP host. In order to access the variable values, the function   *  ntpq_get_peervar must be used.  *  ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *  * Returns:  *	int		1 (one) if the peervars have been read  * 			- OR -   *			0 (zero) if an error occured and the variable set  *			could not be read  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assoc_peervars
parameter_list|(
name|associd_t
name|associd
parameter_list|)
block|{
name|peervarlen
operator|=
name|ntpq_read_assoc_peervars
argument_list|(
name|associd
argument_list|,
name|peervars
argument_list|,
sizeof|sizeof
argument_list|(
name|peervars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peervarlen
operator|<=
literal|0
condition|)
block|{
name|peervar_assoc
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|peervar_assoc
operator|=
name|associd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntp_read_assoc_clockvars  *  *  This function reads the clockvars variable-set of a specified association  *  from a NTP host and writes it to the result buffer specified, honoring   *  the maxsize limit.  *  *  It returns the number of bytes written or 0 when the variable-set is   *  empty or failed to read.  *    ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *	resultbuf	char*	character buffer where the variable set  *				should be stored  *	maxsize		int	the maximum number of bytes that can be  *				written to resultbuf  *  * Returns:  *	int		number of chars that have been copied to   *			resultbuf  *			- OR -   *			0 (zero) if an error occured  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_read_assoc_clockvars
parameter_list|(
name|associd_t
name|associd
parameter_list|,
name|char
modifier|*
name|resultbuf
parameter_list|,
name|int
name|maxsize
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|datap
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|u_short
name|rstatus
decl_stmt|;
name|res
operator|=
name|ntpq_doquerylist
argument_list|(
name|ntpq_varlist
argument_list|,
name|CTL_OP_READCLOCK
argument_list|,
name|associd
argument_list|,
literal|0
argument_list|,
operator|&
name|rstatus
argument_list|,
operator|&
name|dsize
argument_list|,
operator|&
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|numhosts
operator|>
literal|1
condition|)
comment|/* no information returned from server */
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|dsize
operator|>
name|maxsize
condition|)
name|dsize
operator|=
name|maxsize
expr_stmt|;
name|memcpy
argument_list|(
name|resultbuf
argument_list|,
name|datap
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
block|}
return|return
name|dsize
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_get_assoc_clocktype  *  *  This function returns a clocktype value for a given association number   *  (not ID!):  *  *  NTP_CLOCKTYPE_UNKNOWN   Unknown clock type  *  NTP_CLOCKTYPE_BROADCAST Broadcast server  *  NTP_CLOCKTYPE_LOCAL     Local clock  *  NTP_CLOCKTYPE_UNICAST   Unicast server  *  NTP_CLOCKTYPE_MULTICAST Multicast server  *   ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assoc_clocktype
parameter_list|(
name|int
name|assoc_index
parameter_list|)
block|{
name|associd_t
name|associd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sockaddr_u
name|dum_store
decl_stmt|;
name|char
name|dstadr
index|[
name|LENHOSTNAME
index|]
decl_stmt|;
name|char
name|resultbuf
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
if|if
condition|(
name|assoc_index
operator|<
literal|0
operator|||
name|assoc_index
operator|>=
name|numassoc
condition|)
return|return
operator|-
literal|1
return|;
name|associd
operator|=
name|assoc_cache
index|[
name|assoc_index
index|]
operator|.
name|assid
expr_stmt|;
if|if
condition|(
name|associd
operator|==
name|peervar_assoc
condition|)
block|{
name|rc
operator|=
name|ntpq_get_peervar
argument_list|(
literal|"dstadr"
argument_list|,
name|dstadr
argument_list|,
sizeof|sizeof
argument_list|(
name|dstadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ntpq_read_assoc_peervars
argument_list|(
name|associd
argument_list|,
name|resultbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|resultbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|rc
operator|=
name|ntpq_getvar
argument_list|(
name|resultbuf
argument_list|,
name|i
argument_list|,
literal|"dstadr"
argument_list|,
name|dstadr
argument_list|,
sizeof|sizeof
argument_list|(
name|dstadr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|!=
name|rc
operator|&&
name|decodenetnum
argument_list|(
name|dstadr
argument_list|,
operator|&
name|dum_store
argument_list|)
condition|)
return|return
name|ntpq_decodeaddrtype
argument_list|(
operator|&
name|dum_store
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *    *  ntpq_get_assoc_clockvars  *  *  With this function the clock variables of the specified association are   *  requested from a NTP host. This makes only sense for associations with   *  the type 'l' (Local Clock) and you should check this with   *  ntpq_get_assoc_clocktype for each association, before you use this function  *  on it.  *  ****************************************************************************  * Parameters:  *	associd		int	requested associaton ID   *  * Returns:  *	int		1 (one) if the clockvars have been read  * 			- OR -   *			0 (zero) if an error occured and the variable set  *			could not be read  ****************************************************************************/
end_comment

begin_function
name|int
name|ntpq_get_assoc_clockvars
parameter_list|(
name|associd_t
name|associd
parameter_list|)
block|{
if|if
condition|(
name|NTP_CLOCKTYPE_LOCAL
operator|!=
name|ntpq_get_assoc_clocktype
argument_list|(
name|ntpq_get_assoc_number
argument_list|(
name|associd
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|clockvarlen
operator|=
name|ntpq_read_assoc_clockvars
argument_list|(
name|associd
argument_list|,
name|clockvars
argument_list|,
sizeof|sizeof
argument_list|(
name|clockvars
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockvarlen
operator|<=
literal|0
condition|)
block|{
name|clockvar_assoc
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|clockvar_assoc
operator|=
name|associd
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

end_unit

