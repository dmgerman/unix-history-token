begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   -*- buffer-read-only: t -*- vi: set ro:  *    *  DO NOT EDIT THIS FILE   (options.h)  *    *  It has been AutoGen-ed  Saturday May  5, 2007 at 12:02:34 PM PDT  *  From the definitions    funcs.def  *  and the template file   options_h  *  *  This file defines all the global structures and special values  *  used in the automated option processing library.  *  *  Automated Options copyright 1992-Y Bruce Korb  *  *  AutoOpts is free software; you can redistribute it and/or  *  modify it under the terms of the GNU Lesser General Public  *  License as published by the Free Software Foundation; either  *  version 2.1 of the License, or (at your option) any later version.  *    *  AutoOpts is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *  Lesser General Public License for more details.  *    *  You should have received a copy of the GNU Lesser General Public  *  License along with AutoOpts.  If not, write to:  *  	The Free Software Foundation, Inc.,  *  	51 Franklin Street, Fifth Floor  *  	Boston, MA  02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUTOOPTS_OPTIONS_H_GUARD
end_ifndef

begin_define
define|#
directive|define
name|AUTOOPTS_OPTIONS_H_GUARD
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STDINT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INTTYPES_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STDINT/INTTYPES_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIMITS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_SYS_LIMITS_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIMITS/SYS_LIMITS_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYSEXITS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYSEXITS_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EX_USAGE
end_ifndef

begin_define
define|#
directive|define
name|EX_USAGE
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  PUBLIC DEFINES  *  *  The following defines may be used in applications that need to test the  *  state of an option.  To test against these masks and values, a pointer  *  to an option descriptor must be obtained.  There are two ways:  *  *  1. inside an option processing procedure, it is the second argument,  *  conventionally "tOptDesc* pOD".  *  *  2.  Outside of an option procedure (or to reference a different option  *  descriptor), use either "&DESC( opt_name )" or "&pfx_DESC( opt_name )".  *  *  See the relevant generated header file to determine which and what  *  values for "opt_name" are available.  */
end_comment

begin_define
define|#
directive|define
name|OPTIONS_STRUCT_VERSION
value|118784
end_define

begin_define
define|#
directive|define
name|OPTIONS_VERSION_STRING
value|"29:0:4"
end_define

begin_define
define|#
directive|define
name|OPTIONS_MINIMUM_VERSION
value|102400
end_define

begin_define
define|#
directive|define
name|OPTIONS_MIN_VER_STRING
value|"25:0:0"
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|OPARG_TYPE_NONE
init|=
literal|0
block|,
name|OPARG_TYPE_STRING
init|=
literal|1
block|,
comment|/* default type/ vanilla string      */
name|OPARG_TYPE_ENUMERATION
init|=
literal|2
block|,
comment|/* opt arg is an enum (keyword list) */
name|OPARG_TYPE_BOOLEAN
init|=
literal|3
block|,
comment|/* opt arg is boolean-valued         */
name|OPARG_TYPE_MEMBERSHIP
init|=
literal|4
block|,
comment|/* opt arg sets set membership bits  */
name|OPARG_TYPE_NUMERIC
init|=
literal|5
block|,
comment|/* opt arg has numeric value         */
name|OPARG_TYPE_HIERARCHY
init|=
literal|6
comment|/* option arg is hierarchical value  */
block|}
name|teOptArgType
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|optionValue
block|{
name|teOptArgType
name|valType
decl_stmt|;
name|char
modifier|*
name|pzName
decl_stmt|;
union|union
block|{
name|char
name|strVal
index|[
literal|1
index|]
decl_stmt|;
comment|/* OPARG_TYPE_STRING      */
name|unsigned
name|int
name|enumVal
decl_stmt|;
comment|/* OPARG_TYPE_ENUMERATION */
name|unsigned
name|int
name|boolVal
decl_stmt|;
comment|/* OPARG_TYPE_BOOLEAN     */
name|unsigned
name|long
name|setVal
decl_stmt|;
comment|/* OPARG_TYPE_MEMBERSHIP  */
name|long
name|longVal
decl_stmt|;
comment|/* OPARG_TYPE_NUMERIC     */
name|void
modifier|*
name|nestVal
decl_stmt|;
comment|/* OPARG_TYPE_HIERARCHY   */
block|}
name|v
union|;
block|}
name|tOptionValue
typedef|;
end_typedef

begin_comment
comment|/*  *  Bits in the fOptState option descriptor field.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OPTST_SET_ID
init|=
literal|0
block|,
comment|/* Set via the "SET_OPT()" macro */
name|OPTST_PRESET_ID
init|=
literal|1
block|,
comment|/* Set via an RC/INI file        */
name|OPTST_DEFINED_ID
init|=
literal|2
block|,
comment|/* Set via a command line option */
name|OPTST_EQUIVALENCE_ID
init|=
literal|4
block|,
comment|/* selected by equiv'ed option   */
name|OPTST_DISABLED_ID
init|=
literal|5
block|,
comment|/* option is in disabled state   */
name|OPTST_ALLOC_ARG_ID
init|=
literal|6
block|,
comment|/* pzOptArg was allocated        */
name|OPTST_NO_INIT_ID
init|=
literal|8
block|,
comment|/* option cannot be preset       */
name|OPTST_NUMBER_OPT_ID
init|=
literal|9
block|,
comment|/* opt value (flag) is any digit */
name|OPTST_STACKED_ID
init|=
literal|10
block|,
comment|/* opt uses optionStackArg proc  */
name|OPTST_INITENABLED_ID
init|=
literal|11
block|,
comment|/* option defaults to enabled    */
name|OPTST_ARG_TYPE_1_ID
init|=
literal|12
block|,
comment|/* bit 1 of arg type enum        */
name|OPTST_ARG_TYPE_2_ID
init|=
literal|13
block|,
comment|/* bit 2 of arg type enum        */
name|OPTST_ARG_TYPE_3_ID
init|=
literal|14
block|,
comment|/* bit 3 of arg type enum        */
name|OPTST_ARG_TYPE_4_ID
init|=
literal|15
block|,
comment|/* bit 4 of arg type enum        */
name|OPTST_ARG_OPTIONAL_ID
init|=
literal|16
block|,
comment|/* the option arg not required   */
name|OPTST_IMM_ID
init|=
literal|17
block|,
comment|/* process opt on first pass     */
name|OPTST_DISABLE_IMM_ID
init|=
literal|18
block|,
comment|/* process disablement immed.    */
name|OPTST_OMITTED_ID
init|=
literal|19
block|,
comment|/* compiled out of program       */
name|OPTST_MUST_SET_ID
init|=
literal|20
block|,
comment|/* must be set or pre-set        */
name|OPTST_DOCUMENT_ID
init|=
literal|21
block|,
comment|/* opt is for doc only           */
name|OPTST_TWICE_ID
init|=
literal|22
block|,
comment|/* process opt twice - imm + reg */
name|OPTST_DISABLE_TWICE_ID
init|=
literal|23
comment|/* process disabled option twice */
block|}
name|opt_state_enum_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OPTST_INIT
value|0U
end_define

begin_define
define|#
directive|define
name|OPTST_SET
value|(1U<< OPTST_SET_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_PRESET
value|(1U<< OPTST_PRESET_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_DEFINED
value|(1U<< OPTST_DEFINED_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_EQUIVALENCE
value|(1U<< OPTST_EQUIVALENCE_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_DISABLED
value|(1U<< OPTST_DISABLED_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ALLOC_ARG
value|(1U<< OPTST_ALLOC_ARG_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_NO_INIT
value|(1U<< OPTST_NO_INIT_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_NUMBER_OPT
value|(1U<< OPTST_NUMBER_OPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_STACKED
value|(1U<< OPTST_STACKED_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_INITENABLED
value|(1U<< OPTST_INITENABLED_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_1
value|(1U<< OPTST_ARG_TYPE_1_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_2
value|(1U<< OPTST_ARG_TYPE_2_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_3
value|(1U<< OPTST_ARG_TYPE_3_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_4
value|(1U<< OPTST_ARG_TYPE_4_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_OPTIONAL
value|(1U<< OPTST_ARG_OPTIONAL_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_IMM
value|(1U<< OPTST_IMM_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_DISABLE_IMM
value|(1U<< OPTST_DISABLE_IMM_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_OMITTED
value|(1U<< OPTST_OMITTED_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_MUST_SET
value|(1U<< OPTST_MUST_SET_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_DOCUMENT
value|(1U<< OPTST_DOCUMENT_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_TWICE
value|(1U<< OPTST_TWICE_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_DISABLE_TWICE
value|(1U<< OPTST_DISABLE_TWICE_ID)
end_define

begin_define
define|#
directive|define
name|OPT_STATE_MASK
value|0x00FFFF77U
end_define

begin_define
define|#
directive|define
name|OPTST_SET_MASK
value|(  \         OPTST_SET | \         OPTST_PRESET | \         OPTST_DEFINED )
end_define

begin_define
define|#
directive|define
name|OPTST_MUTABLE_MASK
value|(  \         OPTST_SET | \         OPTST_PRESET | \         OPTST_DEFINED | \         OPTST_EQUIVALENCE | \         OPTST_DISABLED | \         OPTST_ALLOC_ARG )
end_define

begin_define
define|#
directive|define
name|OPTST_SELECTED_MASK
value|(  \         OPTST_SET | \         OPTST_DEFINED )
end_define

begin_define
define|#
directive|define
name|OPTST_ARG_TYPE_MASK
value|(  \         OPTST_ARG_TYPE_1 | \         OPTST_ARG_TYPE_2 | \         OPTST_ARG_TYPE_3 | \         OPTST_ARG_TYPE_4 )
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_OPTIONAL_OPT_ARGS
end_ifdef

begin_undef
undef|#
directive|undef
name|OPTST_ARG_OPTIONAL
end_undef

begin_define
define|#
directive|define
name|OPTST_ARG_OPTIONAL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPTST_PERSISTENT_MASK
value|(~OPTST_MUTABLE_MASK)
end_define

begin_define
define|#
directive|define
name|SELECTED_OPT
parameter_list|(
name|pod
parameter_list|)
value|((pod)->fOptState& OPTST_SELECTED_MASK)
end_define

begin_define
define|#
directive|define
name|UNUSED_OPT
parameter_list|(
name|pod
parameter_list|)
value|(((pod)->fOptState& OPTST_SET_MASK) == 0)
end_define

begin_define
define|#
directive|define
name|DISABLED_OPT
parameter_list|(
name|pod
parameter_list|)
value|((pod)->fOptState& OPTST_DISABLED)
end_define

begin_define
define|#
directive|define
name|OPTION_STATE
parameter_list|(
name|pod
parameter_list|)
value|((pod)->fOptState)
end_define

begin_define
define|#
directive|define
name|OPTST_SET_ARGTYPE
parameter_list|(
name|n
parameter_list|)
value|((n)<< OPTST_ARG_TYPE_1_ID)
end_define

begin_define
define|#
directive|define
name|OPTST_GET_ARGTYPE
parameter_list|(
name|f
parameter_list|)
value|(((f)& OPTST_ARG_TYPE_MASK)>>OPTST_ARG_TYPE_1_ID)
end_define

begin_comment
comment|/*  *  PRIVATE INTERFACES  *  *  The following values are used in the generated code to communicate  *  with the option library procedures.  They are not for public use  *  and may be subject to change.  */
end_comment

begin_comment
comment|/*  *  Define the processing state flags  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OPTPROC_LONGOPT_ID
init|=
literal|0
block|,
comment|/* Process long style options      */
name|OPTPROC_SHORTOPT_ID
init|=
literal|1
block|,
comment|/* Process short style "flags"     */
name|OPTPROC_ERRSTOP_ID
init|=
literal|2
block|,
comment|/* Stop on argument errors         */
name|OPTPROC_DISABLEDOPT_ID
init|=
literal|3
block|,
comment|/* Current option is disabled      */
name|OPTPROC_NO_REQ_OPT_ID
init|=
literal|4
block|,
comment|/* no options are required         */
name|OPTPROC_NUM_OPT_ID
init|=
literal|5
block|,
comment|/* there is a number option        */
name|OPTPROC_INITDONE_ID
init|=
literal|6
block|,
comment|/* have initializations been done? */
name|OPTPROC_NEGATIONS_ID
init|=
literal|7
block|,
comment|/* any negation options?           */
name|OPTPROC_ENVIRON_ID
init|=
literal|8
block|,
comment|/* check environment?              */
name|OPTPROC_NO_ARGS_ID
init|=
literal|9
block|,
comment|/* Disallow remaining arguments    */
name|OPTPROC_ARGS_REQ_ID
init|=
literal|10
block|,
comment|/* Require arguments after options */
name|OPTPROC_REORDER_ID
init|=
literal|11
block|,
comment|/* reorder operands after options  */
name|OPTPROC_GNUUSAGE_ID
init|=
literal|12
block|,
comment|/* emit usage in GNU style         */
name|OPTPROC_TRANSLATE_ID
init|=
literal|13
block|,
comment|/* Translate strings in tOptions   */
name|OPTPROC_HAS_IMMED_ID
init|=
literal|14
block|,
comment|/* program defines immed options   */
name|OPTPROC_PRESETTING_ID
init|=
literal|19
comment|/* opt processing in preset state  */
block|}
name|optproc_state_enum_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|OPTPROC_NONE
value|0U
end_define

begin_define
define|#
directive|define
name|OPTPROC_LONGOPT
value|(1U<< OPTPROC_LONGOPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_SHORTOPT
value|(1U<< OPTPROC_SHORTOPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_ERRSTOP
value|(1U<< OPTPROC_ERRSTOP_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_DISABLEDOPT
value|(1U<< OPTPROC_DISABLEDOPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_NO_REQ_OPT
value|(1U<< OPTPROC_NO_REQ_OPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_NUM_OPT
value|(1U<< OPTPROC_NUM_OPT_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_INITDONE
value|(1U<< OPTPROC_INITDONE_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_NEGATIONS
value|(1U<< OPTPROC_NEGATIONS_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_ENVIRON
value|(1U<< OPTPROC_ENVIRON_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_NO_ARGS
value|(1U<< OPTPROC_NO_ARGS_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_ARGS_REQ
value|(1U<< OPTPROC_ARGS_REQ_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_REORDER
value|(1U<< OPTPROC_REORDER_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_GNUUSAGE
value|(1U<< OPTPROC_GNUUSAGE_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_TRANSLATE
value|(1U<< OPTPROC_TRANSLATE_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_HAS_IMMED
value|(1U<< OPTPROC_HAS_IMMED_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_PRESETTING
value|(1U<< OPTPROC_PRESETTING_ID)
end_define

begin_define
define|#
directive|define
name|OPTPROC_STATE_MASK
value|0x00087FFFU
end_define

begin_define
define|#
directive|define
name|STMTS
parameter_list|(
name|s
parameter_list|)
value|do { s; } while (0)
end_define

begin_comment
comment|/*  *  The following must be #defined instead of typedef-ed  *  because "static const" cannot both be applied to a type,  *  tho each individually can...so they all are  */
end_comment

begin_define
define|#
directive|define
name|tSCC
value|static char const
end_define

begin_define
define|#
directive|define
name|tCC
value|char const
end_define

begin_define
define|#
directive|define
name|tAoSC
value|static char
end_define

begin_define
define|#
directive|define
name|tAoUC
value|unsigned char
end_define

begin_define
define|#
directive|define
name|tAoUI
value|unsigned int
end_define

begin_define
define|#
directive|define
name|tAoUL
value|unsigned long
end_define

begin_define
define|#
directive|define
name|tAoUS
value|unsigned short
end_define

begin_comment
comment|/*  *  It is so disgusting that there must be so many ways  *  of specifying TRUE and FALSE.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|AG_FALSE
init|=
literal|0
block|,
name|AG_TRUE
block|}
name|ag_bool
typedef|;
end_typedef

begin_comment
comment|/*  *  Define a structure that describes each option and  *  a pointer to the procedure that handles it.  *  The argument is the count of this flag previously seen.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|options
name|tOptions
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|optDesc
name|tOptDesc
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|optNames
name|tOptNames
typedef|;
end_typedef

begin_comment
comment|/*  *  The option procedures do the special processing for each  *  option flag that needs it.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tOptProc
function_decl|)
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOptDesc
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|tOptProc
modifier|*
name|tpOptProc
typedef|;
end_typedef

begin_comment
comment|/*  *  The usage procedure will never return.  It calls "exit(2)"  *  with the "exitCode" argument passed to it.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tUsageProc
function_decl|)
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|exitCode
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|tUsageProc
modifier|*
name|tpUsageProc
typedef|;
end_typedef

begin_comment
comment|/*  *  Special definitions.  "NOLIMIT" is the 'max' value to use when  *  a flag may appear multiple times without limit.  "NO_EQUIVALENT"  *  is an illegal value for 'optIndex' (option description index).  */
end_comment

begin_define
define|#
directive|define
name|NOLIMIT
value|USHRT_MAX
end_define

begin_define
define|#
directive|define
name|OPTION_LIMIT
value|SHRT_MAX
end_define

begin_define
define|#
directive|define
name|NO_EQUIVALENT
value|(OPTION_LIMIT+1)
end_define

begin_comment
comment|/*  *  Special values for optValue.  It must not be generatable from the  *  computation "optIndex +96".  Since "optIndex" is limited to 100, ...  */
end_comment

begin_define
define|#
directive|define
name|NUMBER_OPTION
value|'#'
end_define

begin_typedef
typedef|typedef
name|struct
name|argList
name|tArgList
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MIN_ARG_ALLOC_CT
value|6
end_define

begin_define
define|#
directive|define
name|INCR_ARG_ALLOC_CT
value|8
end_define

begin_struct
struct|struct
name|argList
block|{
name|int
name|useCt
decl_stmt|;
name|int
name|allocCt
decl_stmt|;
name|tCC
modifier|*
name|apzArgs
index|[
name|MIN_ARG_ALLOC_CT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
union|union
block|{
name|char
specifier|const
modifier|*
name|argString
decl_stmt|;
name|uintptr_t
name|argEnum
decl_stmt|;
name|uintptr_t
name|argIntptr
decl_stmt|;
name|long
name|argInt
decl_stmt|;
name|unsigned
name|long
name|argUint
decl_stmt|;
name|unsigned
name|int
name|argBool
decl_stmt|;
block|}
name|optArgBucket_t
typedef|;
end_typedef

begin_comment
comment|/*  *  Descriptor structure for each option.  *  Only the fields marked "PUBLIC" are for public use.  */
end_comment

begin_struct
struct|struct
name|optDesc
block|{
name|tAoUS
specifier|const
name|optIndex
decl_stmt|;
comment|/* PUBLIC */
name|tAoUS
specifier|const
name|optValue
decl_stmt|;
comment|/* PUBLIC */
name|tAoUS
name|optActualIndex
decl_stmt|;
comment|/* PUBLIC */
name|tAoUS
name|optActualValue
decl_stmt|;
comment|/* PUBLIC */
name|tAoUS
specifier|const
name|optEquivIndex
decl_stmt|;
comment|/* PUBLIC */
name|tAoUS
specifier|const
name|optMinCt
decl_stmt|;
name|tAoUS
specifier|const
name|optMaxCt
decl_stmt|;
name|tAoUS
name|optOccCt
decl_stmt|;
comment|/* PUBLIC */
name|tAoUI
name|fOptState
decl_stmt|;
comment|/* PUBLIC */
name|tAoUI
name|reserved
decl_stmt|;
name|optArgBucket_t
name|optArg
decl_stmt|;
comment|/* PUBLIC */
define|#
directive|define
name|pzLastArg
value|optArg.argString
name|void
modifier|*
name|optCookie
decl_stmt|;
comment|/* PUBLIC */
specifier|const
name|int
modifier|*
name|pOptMust
decl_stmt|;
specifier|const
name|int
modifier|*
name|pOptCant
decl_stmt|;
name|tpOptProc
name|pOptProc
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzText
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz_NAME
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz_Name
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz_DisableName
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz_DisablePfx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Some options need special processing, so we store their  *  indexes in a known place:  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|optSpecIndex
name|tOptSpecIndex
typedef|;
end_typedef

begin_struct
struct|struct
name|optSpecIndex
block|{
specifier|const
name|tAoUS
name|more_help
decl_stmt|;
specifier|const
name|tAoUS
name|save_opts
decl_stmt|;
specifier|const
name|tAoUS
name|number_option
decl_stmt|;
specifier|const
name|tAoUS
name|default_opt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  The procedure generated for translating option text  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|tOptionXlateProc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|options
block|{
name|int
specifier|const
name|structVersion
decl_stmt|;
name|int
name|origArgCt
decl_stmt|;
name|char
modifier|*
modifier|*
name|origArgVect
decl_stmt|;
name|unsigned
name|int
name|fOptSet
decl_stmt|;
name|unsigned
name|int
name|curOptIdx
decl_stmt|;
name|char
modifier|*
name|pzCurOpt
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzProgPath
decl_stmt|;
name|char
specifier|const
modifier|*
name|pzProgName
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzPROGNAME
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzRcName
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzCopyright
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzCopyNotice
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzFullVersion
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
specifier|const
name|papzHomeList
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzUsageTitle
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzExplain
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzDetail
decl_stmt|;
name|tOptDesc
modifier|*
specifier|const
name|pOptDesc
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
name|pzBugAddr
decl_stmt|;
name|void
modifier|*
name|pExtensions
decl_stmt|;
name|void
modifier|*
name|pSavedState
decl_stmt|;
name|tpUsageProc
name|pUsageProc
decl_stmt|;
name|tOptionXlateProc
modifier|*
name|pTransProc
decl_stmt|;
name|tOptSpecIndex
name|specOptIdx
decl_stmt|;
name|int
specifier|const
name|optCt
decl_stmt|;
name|int
specifier|const
name|presetOptCt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  "token list" structure returned by "string_tokenize()"  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|tkn_ct
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tkn_list
index|[
literal|1
index|]
decl_stmt|;
block|}
name|token_list_t
typedef|;
end_typedef

begin_comment
comment|/*  *  Hide the interface - it pollutes a POSIX claim, but leave it for  *  anyone #include-ing this header  */
end_comment

begin_define
define|#
directive|define
name|strneqvcmp
value|option_strneqvcmp
end_define

begin_define
define|#
directive|define
name|streqvcmp
value|option_streqvcmp
end_define

begin_define
define|#
directive|define
name|streqvmap
value|option_streqvmap
end_define

begin_define
define|#
directive|define
name|strequate
value|option_strequate
end_define

begin_define
define|#
directive|define
name|strtransform
value|option_strtransform
end_define

begin_comment
comment|/*  *  This is an output only structure used by text_mmap and text_munmap.  *  Clients must not alter the contents and must provide it to both  *  the text_mmap and text_munmap procedures.  BE ADVISED: if you are  *  mapping the file with PROT_WRITE the NUL byte at the end MIGHT NOT  *  BE WRITABLE.  In any event, that byte is not be written back  *  to the source file.  ALSO: if "txt_data" is valid and "txt_errno"  *  is not zero, then there *may* not be a terminating NUL.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|txt_data
decl_stmt|;
comment|/* text file data   */
name|size_t
name|txt_size
decl_stmt|;
comment|/* actual file size */
name|size_t
name|txt_full_size
decl_stmt|;
comment|/* mmaped mem size  */
name|int
name|txt_fd
decl_stmt|;
comment|/* file descriptor  */
name|int
name|txt_zero_fd
decl_stmt|;
comment|/* fd for /dev/zero */
name|int
name|txt_errno
decl_stmt|;
comment|/* warning code     */
name|int
name|txt_prot
decl_stmt|;
comment|/* "prot" flags     */
name|int
name|txt_flags
decl_stmt|;
comment|/* mapping type     */
name|int
name|txt_alloc
decl_stmt|;
comment|/* if we malloced memory */
block|}
name|tmap_info_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TEXT_MMAP_FAILED_ADDR
parameter_list|(
name|a
parameter_list|)
value|((void*)(a) ==  (void*)MAP_FAILED)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
define|#
directive|define
name|CPLUSPLUS_CLOSER
value|}
else|#
directive|else
define|#
directive|define
name|CPLUSPLUS_CLOSER
endif|#
directive|endif
comment|/*  *  The following routines may be coded into AutoOpts client code:  */
comment|/* From: tokenize.c line 115  *  * ao_string_tokenize - tokenize an input string  *  * Arguments:  *   string       string to be tokenized  *  * Returns: token_list_t* - pointer to a structure that lists each token  *  *  This function will convert one input string into a list of strings.  *  The list of strings is derived by separating the input based on  *  white space separation.  However, if the input contains either single  *  or double quote characters, then the text after that character up to  *  a matching quote will become the string in the list.  *    *  The returned pointer should be deallocated with @code{free(3C)} when  *  are done using the data.  The data are placed in a single block of  *  allocated memory.  Do not deallocate individual token/strings.  *    *  The structure pointed to will contain at least these two fields:  *  @table @samp  *  @item tkn_ct  *  The number of tokens found in the input string.  *  @item tok_list  *  An array of @code{tkn_ct + 1} pointers to substring tokens, with  *  the last pointer set to NULL.  *  @end table  *    *  There are two types of quoted strings: single quoted (@code{'}) and  *  double quoted (@code{"}).  Singly quoted strings are fairly raw in that  *  escape characters (@code{\\}) are simply another character, except when  *  preceding the following characters:  *  @example  *  @code{\\}  double backslashes reduce to one  *  @code{'}   incorporates the single quote into the string  *  @code{\n}  suppresses both the backslash and newline character  *  @end example  *    *  Double quote strings are formed according to the rules of string  *  constants in ANSI-C programs.  */
specifier|extern
name|token_list_t
modifier|*
name|ao_string_tokenize
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 113  *  * configFileLoad - parse a configuration file  *  * Arguments:  *   pzFile       the file to load  *  * Returns: const tOptionValue* - An allocated, compound value structure  *  *  This routine will load a named configuration file and parse the  *  text as a hierarchically valued option.  The option descriptor  *  created from an option definition file is not used via this interface.  *  The returned value is "named" with the input file name and is of  *  type "@code{OPARG_TYPE_HIERARCHY}".  It may be used in calls to  *  @code{optionGetValue()}, @code{optionNextValue()} and  *  @code{optionUnloadNested()}.  */
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|configFileLoad
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 883  *  * optionFileLoad - Load the locatable config files, in order  *  * Arguments:  *   pOpts        program options descriptor  *   pzProg       program name  *  * Returns: int - 0 -> SUCCESS, -1 -> FAILURE  *  *  This function looks in all the specified directories for a configuration  *  file ("rc" file or "ini" file) and processes any found twice.  The first  *  time through, they are processed in reverse order (last file first).  At  *  that time, only "immediate action" configurables are processed.  For  *  example, if the last named file specifies not processing any more  *  configuration files, then no more configuration files will be processed.  *  Such an option in the @strong{first} named directory will have no effect.  *    *  Once the immediate action configurables have been handled, then the  *  directories are handled in normal, forward order.  In that way, later  *  config files can override the settings of earlier config files.  *    *  See the AutoOpts documentation for a thorough discussion of the  *  config file format.  *    *  Configuration files not found or not decipherable are simply ignored.  */
specifier|extern
name|int
name|optionFileLoad
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 245  *  * optionFindNextValue - find a hierarcicaly valued option instance  *  * Arguments:  *   pOptDesc     an option with a nested arg type  *   pPrevVal     the last entry  *   name         name of value to find  *   value        the matching value  *  * Returns: const tOptionValue* - a compound value structure  *  *  This routine will find the next entry in a nested value option or  *  configurable.  It will search through the list and return the next entry  *  that matches the criteria.  */
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionFindNextValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 171  *  * optionFindValue - find a hierarcicaly valued option instance  *  * Arguments:  *   pOptDesc     an option with a nested arg type  *   name         name of value to find  *   value        the matching value  *  * Returns: const tOptionValue* - a compound value structure  *  *  This routine will find an entry in a nested value option or configurable.  *  It will search through the list and return a matching entry.  */
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionFindValue
parameter_list|(
specifier|const
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: restore.c line 188  *  * optionFree - free allocated option processing memory  *  * Arguments:  *   pOpts        program options descriptor  *  *  AutoOpts sometimes allocates memory and puts pointers to it in the  *  option state structures.  This routine deallocates all such memory.  */
specifier|extern
name|void
name|optionFree
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 314  *  * optionGetValue - get a specific value from a hierarcical list  *  * Arguments:  *   pOptValue    a hierarchcal value  *   valueName    name of value to get  *  * Returns: const tOptionValue* - a compound value structure  *  *  This routine will find an entry in a nested value option or configurable.  *  If "valueName" is NULL, then the first entry is returned.  Otherwise,  *  the first entry with a name that exactly matches the argument will be  *  returned.  */
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionGetValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: load.c line 521  *  * optionLoadLine - process a string for an option name and value  *  * Arguments:  *   pOpts        program options descriptor  *   pzLine       NUL-terminated text  *  *  This is a client program callable routine for setting options from, for  *  example, the contents of a file that they read in.  Only one option may  *  appear in the text.  It will be treated as a normal (non-preset) option.  *    *  When passed a pointer to the option struct and a string, it will find  *  the option named by the first token on the string and set the option  *  argument to the remainder of the string.  The caller must NUL terminate  *  the string.  Any embedded new lines will be included in the option  *  argument.  If the input looks like one or more quoted strings, then the  *  input will be "cooked".  The "cooking" is identical to the string  *  formation used in AutoGen definition files (@pxref{basic expression}),  *  except that you may not use backquotes.  */
specifier|extern
name|void
name|optionLoadLine
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: configfile.c line 373  *  * optionNextValue - get the next value from a hierarchical list  *  * Arguments:  *   pOptValue    a hierarchcal list value  *   pOldValue    a value from this list  *  * Returns: const tOptionValue* - a compound value structure  *  *  This routine will return the next entry after the entry passed in.  At the  *  end of the list, NULL will be returned.  If the entry is not found on the  *  list, NULL will be returned and "@var{errno}" will be set to EINVAL.  *  The "@var{pOldValue}" must have been gotten from a prior call to this  *  routine or to "@code{opitonGetValue()}".  */
specifier|extern
specifier|const
name|tOptionValue
modifier|*
name|optionNextValue
parameter_list|(
specifier|const
name|tOptionValue
modifier|*
parameter_list|,
specifier|const
name|tOptionValue
modifier|*
parameter_list|)
function_decl|;
comment|/* From: usage.c line 128  *  * optionOnlyUsage - Print usage text for just the options  *  * Arguments:  *   pOpts        program options descriptor  *   ex_code      exit code for calling exit(3)  *  *  This routine will print only the usage for each option.  *  This function may be used when the emitted usage must incorporate  *  information not available to AutoOpts.  */
specifier|extern
name|void
name|optionOnlyUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* From: autoopts.c line 1012  *  * optionProcess - this is the main option processing routine  *  * Arguments:  *   pOpts        program options descriptor  *   argc         program arg count  *   argv         program arg vector  *  * Returns: int - the count of the arguments processed  *  *  This is the main entry point for processing options.  It is intended  *  that this procedure be called once at the beginning of the execution of  *  a program.  Depending on options selected earlier, it is sometimes  *  necessary to stop and restart option processing, or to select completely  *  different sets of options.  This can be done easily, but you generally  *  do not want to do this.  *    *  The number of arguments processed always includes the program name.  *  If one of the arguments is "--", then it is counted and the processing  *  stops.  If an error was encountered and errors are to be tolerated, then  *  the returned value is the index of the argument causing the error.  *  A hyphen by itself ("-") will also cause processing to stop and will  *  @emph{not} be counted among the processed arguments.  A hyphen by itself  *  is treated as an operand.  Encountering an operand stops option  *  processing.  */
specifier|extern
name|int
name|optionProcess
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
comment|/* From: restore.c line 145  *  * optionRestore - restore option state from memory copy  *  * Arguments:  *   pOpts        program options descriptor  *  *  Copy back the option state from saved memory.  *  The allocated memory is left intact, so this routine can be  *  called repeatedly without having to call optionSaveState again.  *  If you are restoring a state that was saved before the first call  *  to optionProcess(3AO), then you may change the contents of the  *  argc/argv parameters to optionProcess.  */
specifier|extern
name|void
name|optionRestore
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
comment|/* From: save.c line 334  *  * optionSaveFile - saves the option state to a file  *  * Arguments:  *   pOpts        program options descriptor  *  *  This routine will save the state of option processing to a file.  The name  *  of that file can be specified with the argument to the @code{--save-opts}  *  option, or by appending the @code{rcfile} attribute to the last  *  @code{homerc} attribute.  If no @code{rcfile} attribute was specified, it  *  will default to @code{.@i{programname}rc}.  If you wish to specify another  *  file, you should invoke the @code{SET_OPT_SAVE_OPTS( @i{filename} )} macro.  */
specifier|extern
name|void
name|optionSaveFile
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
comment|/* From: restore.c line 93  *  * optionSaveState - saves the option state to memory  *  * Arguments:  *   pOpts        program options descriptor  *  *  This routine will allocate enough memory to save the current option  *  processing state.  If this routine has been called before, that memory  *  will be reused.  You may only save one copy of the option state.  This  *  routine may be called before optionProcess(3AO).  If you do call it  *  before the first call to optionProcess, then you may also change the  *  contents of argc/argv after you call optionRestore(3AO)  *    *  In fact, more strongly put: it is safest to only use this function  *  before having processed any options.  In particular, the saving and  *  restoring of stacked string arguments and hierarchical values is  *  disabled.  The values are not saved.  */
specifier|extern
name|void
name|optionSaveState
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
comment|/* From: nested.c line 559  *  * optionUnloadNested - Deallocate the memory for a nested value  *  * Arguments:  *   pOptVal      the hierarchical value  *  *  A nested value needs to be deallocated.  The pointer passed in should  *  have been gotten from a call to @code{configFileLoad()} (See  *  @pxref{libopts-configFileLoad}).  */
specifier|extern
name|void
name|optionUnloadNested
parameter_list|(
name|tOptionValue
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: version.c line 58  *  * optionVersion - return the compiled AutoOpts version number  *  * Returns: char const* - the version string in constant memory  *  *  Returns the full version string compiled into the library.  *  The returned string cannot be modified.  */
specifier|extern
name|char
specifier|const
modifier|*
name|optionVersion
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* From: ../compat/pathfind.c line 34  *  * pathfind - fild a file in a list of directories  *  * Arguments:  *   path         colon separated list of search directories  *   file         the name of the file to look for  *   mode         the mode bits that must be set to match  *  * Returns: char* - the path to the located file  *  * the pathfind function is available only if HAVE_PATHFIND is not defined  *  *  pathfind looks for a a file with name "FILE" and "MODE" access  *  along colon delimited "PATH", and returns the full pathname as a  *  string, or NULL if not found.  If "FILE" contains a slash, then  *  it is treated as a relative or absolute path and "PATH" is ignored.  *    *  @strong{NOTE}: this function is compiled into @file{libopts} only if  *  it is not natively supplied.  *    *  The "MODE" argument is a string of option letters chosen from the  *  list below:  *  @example  *  Letter    Meaning  *  r         readable  *  w         writable  *  x         executable  *  f         normal file       (NOT IMPLEMENTED)  *  b         block special     (NOT IMPLEMENTED)  *  c         character special (NOT IMPLEMENTED)  *  d         directory         (NOT IMPLEMENTED)  *  p         FIFO (pipe)       (NOT IMPLEMENTED)  *  u         set user ID bit   (NOT IMPLEMENTED)  *  g         set group ID bit  (NOT IMPLEMENTED)  *  k         sticky bit        (NOT IMPLEMENTED)  *  s         size nonzero      (NOT IMPLEMENTED)  *  @end example  */
ifndef|#
directive|ifndef
name|HAVE_PATHFIND
specifier|extern
name|char
modifier|*
name|pathfind
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* HAVE_PATHFIND */
comment|/* From: streqvcmp.c line 233  *  * strequate - map a list of characters to the same value  *  * Arguments:  *   ch_list      characters to equivalence  *  *  Each character in the input string get mapped to the first character  *  in the string.  *  This function name is mapped to option_strequate so as to not conflict  *  with the POSIX name space.  */
specifier|extern
name|void
name|strequate
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: streqvcmp.c line 143  *  * streqvcmp - compare two strings with an equivalence mapping  *  * Arguments:  *   str1         first string  *   str2         second string  *  * Returns: int - the difference between two differing characters  *  *  Using a character mapping, two strings are compared for "equivalence".  *  Each input character is mapped to a comparison character and the  *  mapped-to characters are compared for the two NUL terminated input strings.  *  This function name is mapped to option_streqvcmp so as to not conflict  *  with the POSIX name space.  */
specifier|extern
name|int
name|streqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/* From: streqvcmp.c line 180  *  * streqvmap - Set the character mappings for the streqv functions  *  * Arguments:  *   From         Input character  *   To           Mapped-to character  *   ct           compare length  *  *  Set the character mapping.  If the count (@code{ct}) is set to zero, then  *  the map is cleared by setting all entries in the map to their index  *  value.  Otherwise, the "@code{From}" character is mapped to the "@code{To}"  *  character.  If @code{ct} is greater than 1, then @code{From} and @code{To}  *  are incremented and the process repeated until @code{ct} entries have been  *  set. For example,  *  @example  *  streqvmap( 'a', 'A', 26 );  *  @end example  *  @noindent  *  will alter the mapping so that all English lower case letters  *  will map to upper case.  *    *  This function name is mapped to option_streqvmap so as to not conflict  *  with the POSIX name space.  */
specifier|extern
name|void
name|streqvmap
parameter_list|(
name|char
parameter_list|,
name|char
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* From: streqvcmp.c line 102  *  * strneqvcmp - compare two strings with an equivalence mapping  *  * Arguments:  *   str1         first string  *   str2         second string  *   ct           compare length  *  * Returns: int - the difference between two differing characters  *  *  Using a character mapping, two strings are compared for "equivalence".  *  Each input character is mapped to a comparison character and the  *  mapped-to characters are compared for the two NUL terminated input strings.  *  The comparison is limited to @code{ct} bytes.  *  This function name is mapped to option_strneqvcmp so as to not conflict  *  with the POSIX name space.  */
specifier|extern
name|int
name|strneqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* From: streqvcmp.c line 259  *  * strtransform - convert a string into its mapped-to value  *  * Arguments:  *   dest         output string  *   src          input string  *  *  Each character in the input string is mapped and the mapped-to  *  character is put into the output.  *  This function name is mapped to option_strtransform so as to not conflict  *  with the POSIX name space.  */
specifier|extern
name|void
name|strtransform
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
comment|/*  AutoOpts PRIVATE FUNCTIONS:  */
name|tOptProc
name|optionStackArg
decl_stmt|,
name|optionUnstackArg
decl_stmt|,
name|optionBooleanVal
decl_stmt|,
name|optionNumericVal
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ao_string_cook
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|unsigned
name|int
name|ao_string_cook_escape_char
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|export_options_to_guile
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|genshelloptUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionBooleanVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|uintptr_t
name|optionEnumerationVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
specifier|extern
name|char
specifier|const
modifier|*
name|optionKeywordName
parameter_list|(
name|tOptDesc
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionLoadOpt
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|ag_bool
name|optionMakePath
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionNestedVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionNumericVal
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionPagedUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionParseShell
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionPrintVersion
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionPutShell
parameter_list|(
name|tOptions
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionSetMembers
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionStackArg
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionUnstackArg
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionUsage
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|void
name|optionVersionStderr
parameter_list|(
name|tOptions
modifier|*
parameter_list|,
name|tOptDesc
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|text_mmap
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tmap_info_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|text_munmap
parameter_list|(
name|tmap_info_t
modifier|*
parameter_list|)
function_decl|;
name|CPLUSPLUS_CLOSER
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOOPTS_OPTIONS_H_GUARD */
end_comment

begin_comment
comment|/*  * Local Variables:  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * options.h ends here */
end_comment

end_unit

