begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: autoopts.c,v 4.25 2007/04/15 19:01:18 bkorb Exp $  *  Time-stamp:      "2007-04-15 11:10:40 bkorb"  *  *  This file contains all of the routines that must be linked into  *  an executable to use the generated option processing.  The optional  *  routines are in separately compiled modules so that they will not  *  necessarily be linked in.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zNil
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|tSuccess
name|findOptDesc
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|nextOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|doPresets
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checkConsistency
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_function
name|LOCAL
name|void
modifier|*
name|ao_malloc
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc of %d bytes failed\n"
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|_s
parameter_list|)
value|ao_malloc(_s)
end_define

begin_function
name|LOCAL
name|void
modifier|*
name|ao_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"realloc of %d bytes at 0x%p failed\n"
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_define
define|#
directive|define
name|realloc
parameter_list|(
name|_p
parameter_list|,
name|_s
parameter_list|)
value|ao_realloc(_p,_s)
end_define

begin_function
name|LOCAL
name|void
name|ao_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_define
define|#
directive|define
name|free
parameter_list|(
name|_p
parameter_list|)
value|ao_free(_p)
end_define

begin_function
name|LOCAL
name|char
modifier|*
name|ao_strdup
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|strdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strdup of %d byte string failed\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|strdup
end_undef

begin_define
define|#
directive|define
name|strdup
parameter_list|(
name|_p
parameter_list|)
value|ao_strdup(_p)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PATHFIND
end_ifndef

begin_include
include|#
directive|include
file|"compat/pathfind.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SNPRINTF
end_ifndef

begin_include
include|#
directive|include
file|"compat/snprintf.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRDUP
end_ifndef

begin_include
include|#
directive|include
file|"compat/strdup.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRCHR
end_ifndef

begin_include
include|#
directive|include
file|"compat/strchr.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  handleOption  *  *  This routine handles equivalencing, sets the option state flags and  *  invokes the handler procedure, if any.  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|handleOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  Save a copy of the option procedure pointer.      *  If this is an equivalence class option, we still want this proc.      */
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOptState
operator|->
name|pOD
decl_stmt|;
name|tOptProc
modifier|*
name|pOP
init|=
name|pOD
operator|->
name|pOptProc
decl_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOptState
operator|->
name|pzOptArg
expr_stmt|;
comment|/*      *  IF we are presetting options, then we will ignore any un-presettable      *  options.  They are the ones either marked as such.      */
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|PROBLEM
return|;
comment|/*      *  IF this is an equivalence class option,      *  THEN      *      Save the option value that got us to this option      *      entry.  (It may not be pOD->optChar[0], if this is an      *      equivalence entry.)      *      set the pointer to the equivalence class base      */
if|if
condition|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOD
operator|->
name|optEquivIndex
decl_stmt|;
comment|/*          * IF the current option state has not been defined (set on the          *    command line), THEN we will allow continued resetting of          *    the value.  Once "defined", then it must not change.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              *  The equivalenced-to option has been found on the command              *  line before.  Make sure new occurrences are the same type.              *              *  IF this option has been previously equivalenced and              *     it was not the same equivalenced-to option,              *  THEN we have a usage problem.              */
if|if
condition|(
name|p
operator|->
name|optActualIndex
operator|!=
name|pOD
operator|->
name|optIndex
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zMultiEquiv
argument_list|,
name|p
operator|->
name|pz_Name
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
operator|(
name|pOpts
operator|->
name|pOptDesc
operator|+
name|p
operator|->
name|optActualIndex
operator|)
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/*              *  Set the equivalenced-to actual option index to no-equivalent              *  so that we set all the entries below.  This option may either              *  never have been selected before, or else it was selected by              *  some sort of "presetting" mechanism.              */
name|p
operator|->
name|optActualIndex
operator|=
name|NO_EQUIVALENT
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|optActualIndex
operator|!=
name|pOD
operator|->
name|optIndex
condition|)
block|{
comment|/*              *  First time through, copy over the state              *  and add in the equivalence flag              */
name|p
operator|->
name|optActualValue
operator|=
name|pOD
operator|->
name|optValue
expr_stmt|;
name|p
operator|->
name|optActualIndex
operator|=
name|pOD
operator|->
name|optIndex
expr_stmt|;
name|pOptState
operator|->
name|flags
operator||=
name|OPTST_EQUIVALENCE
expr_stmt|;
block|}
comment|/*          *  Copy the most recent option argument.  set membership state          *  is kept in ``p->optCookie''.  Do not overwrite.          */
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
name|pOD
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|pOD
operator|->
name|optActualValue
operator|=
name|pOD
operator|->
name|optValue
expr_stmt|;
name|pOD
operator|->
name|optActualIndex
operator|=
name|pOD
operator|->
name|optIndex
expr_stmt|;
block|}
name|pOD
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator||=
operator|(
name|pOptState
operator|->
name|flags
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
comment|/*      *  Keep track of count only for DEFINED (command line) options.      *  IF we have too many, build up an error message and bail.      */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|&&
operator|(
operator|++
name|pOD
operator|->
name|optOccCt
operator|>
name|pOD
operator|->
name|optMaxCt
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|pzEqv
init|=
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
condition|?
name|zEquiv
else|:
name|zNil
decl_stmt|;
name|fputs
argument_list|(
name|zErrOnly
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zAtMost
argument_list|,
name|pOD
operator|->
name|optMaxCt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pzEqv
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zOnlyOne
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pzEqv
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
comment|/*      *  If provided a procedure to call, call it      */
if|if
condition|(
name|pOP
operator|!=
operator|(
name|tpOptProc
operator|)
name|NULL
condition|)
call|(
modifier|*
name|pOP
call|)
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  HUNT FOR OPTIONS IN THE ARGUMENT LIST  *  *  The next four procedures are "private" to nextOption().  *  nextOption() uses findOptDesc() to find the next descriptor and it, in  *  turn, uses longOptionFind() and shortOptionFind() to actually do the hunt.  *  *  longOptionFind  *  *  Find the long option descriptor for the current option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|longOptionFind
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzOptName
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|ag_bool
name|disable
init|=
name|AG_FALSE
decl_stmt|;
name|char
modifier|*
name|pzEq
init|=
name|strchr
argument_list|(
name|pzOptName
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|int
name|idxLim
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
name|int
name|matchCt
init|=
literal|0
decl_stmt|;
name|int
name|matchIdx
init|=
literal|0
decl_stmt|;
name|int
name|nameLen
decl_stmt|;
comment|/*      *  IF the value is attached to the name,      *  THEN clip it off.      *  Either way, figure out how long our name is      */
if|if
condition|(
name|pzEq
operator|!=
name|NULL
condition|)
block|{
name|nameLen
operator|=
call|(
name|int
call|)
argument_list|(
name|pzEq
operator|-
name|pzOptName
argument_list|)
expr_stmt|;
operator|*
name|pzEq
operator|=
name|NUL
expr_stmt|;
block|}
else|else
name|nameLen
operator|=
name|strlen
argument_list|(
name|pzOptName
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strneqvcmp
argument_list|(
name|pzOptName
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|nameLen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_Name
index|[
name|nameLen
index|]
operator|==
name|NUL
condition|)
block|{
name|matchCt
operator|=
literal|1
expr_stmt|;
name|matchIdx
operator|=
name|idx
expr_stmt|;
break|break;
block|}
block|}
comment|/*          *  IF       there is a disable name          *     *AND* no argument value has been supplied          *              (disabled options may have no argument)          *     *AND* the option name matches the disable name          *  THEN ...          */
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|pz_DisableName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strneqvcmp
argument_list|(
name|pzOptName
argument_list|,
name|pOD
operator|->
name|pz_DisableName
argument_list|,
name|nameLen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|disable
operator|=
name|AG_TRUE
expr_stmt|;
comment|/*              *  IF we have a complete match              *  THEN it takes priority over any already located partial              */
if|if
condition|(
name|pOD
operator|->
name|pz_DisableName
index|[
name|nameLen
index|]
operator|==
name|NUL
condition|)
block|{
name|matchCt
operator|=
literal|1
expr_stmt|;
name|matchIdx
operator|=
name|idx
expr_stmt|;
break|break;
block|}
block|}
else|else
continue|continue;
comment|/*          *  We found a partial match, either regular or disabling.          *  Remember the index for later.          */
name|matchIdx
operator|=
name|idx
expr_stmt|;
if|if
condition|(
operator|++
name|matchCt
operator|>
literal|1
condition|)
break|break;
block|}
do|while
condition|(
name|pOD
operator|++
operator|,
operator|(
operator|++
name|idx
operator|<
name|idxLim
operator|)
condition|)
do|;
if|if
condition|(
name|pzEq
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|pzEq
operator|++
operator|)
operator|=
literal|'='
expr_stmt|;
comment|/*      *  Make sure we either found an exact match or found only one partial      */
if|if
condition|(
name|matchCt
operator|==
literal|1
condition|)
block|{
comment|/*          *  IF we found a disablement name,          *  THEN set the bit in the callers' flag word          */
if|if
condition|(
name|disable
condition|)
name|pOptState
operator|->
name|flags
operator||=
name|OPTST_DISABLED
expr_stmt|;
name|pOptState
operator|->
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|matchIdx
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzEq
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_LONG
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  IF there is no equal sign      *     *AND* we are using named arguments      *     *AND* there is a default named option,      *  THEN return that option.      */
if|if
condition|(
operator|(
name|pzEq
operator|==
name|NULL
operator|)
operator|&&
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|default_opt
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|default_opt
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzOptName
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_DEFAULT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  IF we are to stop on errors (the default, actually)      *  THEN call the usage procedure.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
operator|(
name|matchCt
operator|==
literal|0
operator|)
condition|?
name|zIllegal
else|:
name|zAmbiguous
argument_list|,
name|pzOptName
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*  *  shortOptionFind  *  *  Find the short option descriptor for the current option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|shortOptionFind
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|uint_t
name|optValue
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pRes
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
comment|/*      *  Search the option list      */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/*          *  IF the values match,          *  THEN we stop here          */
if|if
condition|(
operator|(
operator|!
name|SKIP_OPT
argument_list|(
name|pRes
argument_list|)
operator|)
operator|&&
operator|(
name|optValue
operator|==
name|pRes
operator|->
name|optValue
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
name|pRes
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*          *  Advance to next option description          */
name|pRes
operator|++
expr_stmt|;
comment|/*          *  IF we have searched everything, ...          */
if|if
condition|(
operator|--
name|ct
operator|<=
literal|0
condition|)
break|break;
block|}
comment|/*      *  IF    the character value is a digit      *    AND there is a special number option ("-n")      *  THEN the result is the "option" itself and the      *       option is the specially marked "number" option.      */
if|if
condition|(
name|isdigit
argument_list|(
name|optValue
argument_list|)
operator|&&
operator|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
operator|!=
name|NO_EQUIVALENT
operator|)
condition|)
block|{
name|pOptState
operator|->
name|pOD
operator|=
expr|\
name|pRes
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|number_option
expr_stmt|;
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|--
expr_stmt|;
name|pOptState
operator|->
name|optType
operator|=
name|TOPT_SHORT
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  IF we are to stop on errors (the default, actually)      *  THEN call the usage procedure.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptChr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|optValue
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*  *  findOptDesc  *  *  Find the option descriptor for the current option  */
end_comment

begin_function
specifier|static
name|tSuccess
name|findOptDesc
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
comment|/*      *  IF we are continuing a short option list (e.g. -xyz...)      *  THEN continue a single flag option.      *  OTHERWISE see if there is room to advance and then do so.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NUL
operator|)
condition|)
return|return
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|pOptState
argument_list|)
return|;
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
expr_stmt|;
comment|/*      *  IF all arguments must be named options, ...      */
if|if
condition|(
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pz
init|=
name|pOpts
operator|->
name|pzCurOpt
decl_stmt|;
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/*          *  Skip over any flag/option markers.          *  In this mode, they are not required.          */
while|while
condition|(
operator|*
name|pz
operator|==
literal|'-'
condition|)
name|pz
operator|++
expr_stmt|;
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pz
argument_list|,
name|pOptState
argument_list|)
return|;
block|}
comment|/*      *  Note the kind of flag/option marker      */
if|if
condition|(
operator|*
operator|(
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|++
operator|)
operator|!=
literal|'-'
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  Special hack for a hyphen by itself      */
if|if
condition|(
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
return|return
name|PROBLEM
return|;
comment|/* NORMAL COMPLETION - this + rest are operands */
comment|/*      *  The current argument is to be processed as an option argument      */
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/*      *  We have an option marker.      *  Test the next character for long option indication      */
if|if
condition|(
name|pOpts
operator|->
name|pzCurOpt
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
comment|/*              *  NORMAL COMPLETION - NOT this arg, but rest are operands              */
return|return
name|PROBLEM
return|;
comment|/*          *  We do not allow the hyphen to be used as a flag value.          *  Therefore, if long options are not to be accepted, we punt.          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_LONGOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zIllOptStr
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|zIllegal
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
argument_list|,
name|pOptState
argument_list|)
return|;
block|}
comment|/*      *  If short options are not allowed, then do long      *  option processing.  Otherwise the character must be a      *  short (i.e. single character) option.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|!=
literal|0
condition|)
return|return
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
argument_list|,
name|pOptState
argument_list|)
return|;
return|return
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pOpts
operator|->
name|pzCurOpt
argument_list|,
name|pOptState
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  nextOption  *  *  Find the option descriptor and option argument (if any) for the  *  next command line argument.  DO NOT modify the descriptor.  Put  *  all the state in the state argument so that the option can be skipped  *  without consequence (side effect).  */
end_comment

begin_function
specifier|static
name|tSuccess
name|nextOption
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptState
modifier|*
name|pOptState
parameter_list|)
block|{
name|tSuccess
name|res
decl_stmt|;
enum|enum
block|{
name|ARG_NONE
block|,
name|ARG_MAY
block|,
name|ARG_MUST
block|}
name|arg_type
init|=
name|ARG_NONE
enum|;
name|teOptArgType
name|at
decl_stmt|;
name|res
operator|=
name|findOptDesc
argument_list|(
name|pOpts
argument_list|,
name|pOptState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
name|pOptState
operator|->
name|flags
operator||=
operator|(
name|pOptState
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
name|at
operator|=
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOptState
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/*      *  Figure out what to do about option arguments.  An argument may be      *  required, not associated with the option, or be optional.  We detect the      *  latter by examining for an option marker on the next possible argument.      *  Disabled mode option selection also disables option arguments.      */
if|if
condition|(
operator|(
name|pOptState
operator|->
name|flags
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
name|arg_type
operator|=
name|ARG_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|at
operator|==
name|OPARG_TYPE_NONE
condition|)
name|arg_type
operator|=
name|ARG_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|pOptState
operator|->
name|flags
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
name|arg_type
operator|=
name|ARG_MAY
expr_stmt|;
else|else
name|arg_type
operator|=
name|ARG_MUST
expr_stmt|;
switch|switch
condition|(
name|arg_type
condition|)
block|{
case|case
name|ARG_MUST
case|:
comment|/*          *  An option argument is required.  Long options can either have          *  a separate command line argument, or an argument attached by          *  the '=' character.  Figure out which.          */
switch|switch
condition|(
name|pOptState
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*              *  See if an arg string follows the flag character              */
if|if
condition|(
operator|*
operator|++
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|==
name|NUL
condition|)
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|pzCurOpt
expr_stmt|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*              *  See if an arg string has already been assigned (glued on              *  with an `=' character)              */
if|if
condition|(
name|pOptState
operator|->
name|pzOptArg
operator|==
name|NULL
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
operator|++
index|]
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|fputs
argument_list|(
literal|"AutoOpts lib error: option type not selected\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|TOPT_DEFAULT
case|:
comment|/*              *  The option was selected by default.  The current token is              *  the option argument.              */
break|break;
block|}
comment|/*          *  Make sure we did not overflow the argument list.          */
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>
name|pOpts
operator|->
name|origArgCt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zMisArg
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pOptState
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/* next time advance to next arg */
break|break;
case|case
name|ARG_MAY
case|:
comment|/*          *  An option argument is optional.          */
switch|switch
condition|(
name|pOptState
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
if|if
condition|(
operator|*
operator|++
name|pOpts
operator|->
name|pzCurOpt
operator|!=
name|NUL
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pOpts
operator|->
name|pzCurOpt
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*                  *  BECAUSE it is optional, we must make sure                  *  we did not find another flag and that there                  *  is such an argument.                  */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*              *  Look for an argument if we don't already have one (glued on              *  with a `=' character) *AND* we are not in named argument mode              */
if|if
condition|(
operator|(
name|pOptState
operator|->
name|pzOptArg
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|pzLA
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
decl_stmt|;
comment|/*                  *  BECAUSE it is optional, we must make sure                  *  we did not find another flag and that there                  *  is such an argument.                  */
if|if
condition|(
operator|(
name|pzLA
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzLA
operator|==
literal|'-'
operator|)
condition|)
name|pOptState
operator|->
name|pzOptArg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pOpts
operator|->
name|curOptIdx
operator|++
expr_stmt|;
comment|/* argument found */
name|pOptState
operator|->
name|pzOptArg
operator|=
name|pzLA
expr_stmt|;
block|}
block|}
break|break;
default|default:
case|case
name|TOPT_DEFAULT
case|:
name|fputs
argument_list|(
literal|"AutoOpts lib error: defaulted to option with optional arg\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
comment|/*          *  After an option with an optional argument, we will          *  *always* start with the next option because if there          *  were any characters following the option name/flag,          *  they would be interpreted as the argument.          */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
comment|/* CANNOT */
comment|/*          *  No option argument.  Make sure next time around we find          *  the correct option flag character for short options          */
if|if
condition|(
name|pOptState
operator|->
name|optType
operator|==
name|TOPT_SHORT
condition|)
operator|(
name|pOpts
operator|->
name|pzCurOpt
operator|)
operator|++
expr_stmt|;
comment|/*          *  It is a long option.  Make sure there was no ``=xxx'' argument          */
elseif|else
if|if
condition|(
name|pOptState
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoArg
argument_list|,
name|pOpts
operator|->
name|pzProgPath
argument_list|,
name|pOptState
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*          *  It is a long option.  Advance to next command line argument.          */
else|else
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  DO PRESETS  *  *  The next several routines do the immediate action pass on the command  *  line options, then the environment variables, then the config files in  *  reverse order.  Once done with that, the order is reversed and all  *  the config files and environment variables are processed again, this  *  time only processing the non-immediate action options.  doPresets()  *  will then return for optionProcess() to do the final pass on the command  *  line arguments.  */
end_comment

begin_comment
comment|/*  *  doImmediateOpts - scan the command line for immediate action options  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|doImmediateOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
comment|/* start by skipping program name */
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/*      *  Examine all the options from the start.  We process any options that      *  are marked for immediate processing.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|optState
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nextOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|optionsDone
goto|;
case|case
name|PROBLEM
case|:
return|return
name|SUCCESS
return|;
comment|/* no more args */
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this *is* an immediate-attribute option, then do it.          */
if|if
condition|(
operator|!
name|DO_IMMEDIATELY
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handleOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|optionsDone
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function

begin_function
name|LOCAL
name|tSuccess
name|doRegularOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
comment|/*      *  Now, process all the options from our current position onward.      *  (This allows interspersed options and arguments for the few      *  non-standard programs that require it.)      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|optState
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nextOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|optionsDone
goto|;
case|case
name|PROBLEM
case|:
return|return
name|SUCCESS
return|;
comment|/* no more args */
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this is not being processed normally (i.e. is immediate action)          *  THEN skip it (unless we are supposed to do it a second time).          */
if|if
condition|(
operator|!
name|DO_NORMALLY
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DO_SECOND_TIME
argument_list|(
name|optState
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
name|optState
operator|.
name|pOD
operator|->
name|optOccCt
operator|--
expr_stmt|;
comment|/* don't count last time */
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handleOption
argument_list|(
name|pOpts
argument_list|,
operator|&
name|optState
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|optionsDone
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*  *  doPresets - check for preset values from a config file or the envrionment  */
end_comment

begin_function
specifier|static
name|tSuccess
name|doPresets
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doImmediateOpts
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/*      *  IF this option set has a --save-opts option, then it also      *  has a --load-opts option.  See if a command line option has disabled      *  option presetting.      */
if|if
condition|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
literal|0
condition|)
block|{
name|pOD
operator|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  Until we return from this procedure, disable non-presettable opts      */
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_PRESETTING
expr_stmt|;
comment|/*      *  IF there are no config files,      *  THEN do any environment presets and leave.      */
if|if
condition|(
name|pOpts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
block|{
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_IMM
argument_list|)
expr_stmt|;
comment|/*          *  Check to see if environment variables have disabled presetting.          */
if|if
condition|(
operator|(
name|pOD
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
name|internalFileLoad
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
comment|/*          *  ${PROGRAM_LOAD_OPTS} value of "no" cannot disable other environment          *  variable options.  Only the loading of .rc files.          */
name|doEnvPresets
argument_list|(
name|pOpts
argument_list|,
name|ENV_NON_IMM
argument_list|)
expr_stmt|;
block|}
name|pOpts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_PRESETTING
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  VERIFY OPTION CONSISTENCY  *  *  Make sure that the argument list passes our consistency tests.  */
end_comment

begin_function
specifier|static
name|int
name|checkConsistency
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|errCt
init|=
literal|0
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|oCt
init|=
name|pOpts
operator|->
name|presetOptCt
decl_stmt|;
comment|/*      *  FOR each of "oCt" options, ...      */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|int
modifier|*
name|pMust
init|=
name|pOD
operator|->
name|pOptMust
decl_stmt|;
specifier|const
name|int
modifier|*
name|pCant
init|=
name|pOD
operator|->
name|pOptCant
decl_stmt|;
comment|/*          *  IF the current option was provided on the command line          *  THEN ensure that any "MUST" requirements are not          *       "DEFAULT" (unspecified) *AND* ensure that any          *       "CANT" options have not been SET or DEFINED.          */
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
if|if
condition|(
name|pMust
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
operator|*
operator|(
name|pMust
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|UNUSED_OPT
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|const
name|tOptDesc
modifier|*
name|pN
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pMust
index|[
operator|-
literal|1
index|]
decl_stmt|;
name|errCt
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zReqFmt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pN
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pMust
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
if|if
condition|(
name|pCant
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
operator|*
operator|(
name|pCant
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|p
argument_list|)
condition|)
block|{
specifier|const
name|tOptDesc
modifier|*
name|pN
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pCant
index|[
operator|-
literal|1
index|]
decl_stmt|;
name|errCt
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zCantFmt
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pN
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pCant
operator|==
name|NO_EQUIVALENT
condition|)
break|break;
block|}
block|}
comment|/*          *  IF       this option is not equivalenced to another,          *        OR it is equivalenced to itself (is the equiv. root)          *  THEN we need to make sure it occurs often enough.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|==
name|NO_EQUIVALENT
operator|)
operator|||
operator|(
name|pOD
operator|->
name|optEquivIndex
operator|==
name|pOD
operator|->
name|optIndex
operator|)
condition|)
do|do
block|{
comment|/*              *  IF the occurrence counts have been satisfied,              *  THEN there is no problem.              */
if|if
condition|(
name|pOD
operator|->
name|optOccCt
operator|>=
name|pOD
operator|->
name|optMinCt
condition|)
break|break;
comment|/*              *  IF MUST_SET means SET and PRESET are okay,              *  so min occurrence count doesn't count              */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_MUST_SET
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|fOptState
operator|&
operator|(
name|OPTST_PRESET
operator||
name|OPTST_SET
operator|)
operator|)
condition|)
break|break;
name|errCt
operator|++
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|optMinCt
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotEnough
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|,
name|pOD
operator|->
name|optMinCt
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNeedOne
argument_list|,
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
operator|--
name|oCt
operator|<=
literal|0
condition|)
break|break;
name|pOD
operator|++
expr_stmt|;
block|}
comment|/*      *  IF we are stopping on errors, check to see if any remaining      *  arguments are required to be there or prohibited from being there.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*          *  Check for prohibition          */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_ARGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pOpts
operator|->
name|origArgCt
operator|>
name|pOpts
operator|->
name|curOptIdx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoArgs
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
operator|++
name|errCt
expr_stmt|;
block|}
block|}
comment|/*          *  ELSE not prohibited, check for being required          */
elseif|else
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ARGS_REQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pOpts
operator|->
name|origArgCt
operator|<=
name|pOpts
operator|->
name|curOptIdx
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zArgsMust
argument_list|,
name|pOpts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
operator|++
name|errCt
expr_stmt|;
block|}
block|}
block|}
return|return
name|errCt
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  THESE ROUTINES ARE CALLABLE FROM THE GENERATED OPTION PROCESSING CODE  */
end_comment

begin_comment
comment|/*=--subblock=arg=arg_type,arg_name,arg_desc =*/
end_comment

begin_comment
comment|/*=*  * library:  opts  * header:   your-opts.h  *  * lib_description:  *  *  These are the routines that libopts users may call directly from their  *  code.  There are several other routines that can be called by code  *  generated by the libopts option templates, but they are not to be  *  called from any other user code.  The @file{options.h} header is  *  fairly clear about this, too. =*/
end_comment

begin_comment
comment|/*=export_func optionProcess  *  * what: this is the main option processing routine  *  * arg:  + tOptions* + pOpts + program options descriptor +  * arg:  + int       + argc  + program arg count  +  * arg:  + char**    + argv  + program arg vector +  *  * ret_type:  int  * ret_desc:  the count of the arguments processed  *  * doc:  *  * This is the main entry point for processing options.  It is intended  * that this procedure be called once at the beginning of the execution of  * a program.  Depending on options selected earlier, it is sometimes  * necessary to stop and restart option processing, or to select completely  * different sets of options.  This can be done easily, but you generally  * do not want to do this.  *  * The number of arguments processed always includes the program name.  * If one of the arguments is "--", then it is counted and the processing  * stops.  If an error was encountered and errors are to be tolerated, then  * the returned value is the index of the argument causing the error.  * A hyphen by itself ("-") will also cause processing to stop and will  * @emph{not} be counted among the processed arguments.  A hyphen by itself  * is treated as an operand.  Encountering an operand stops option  * processing.  *  * err:  Errors will cause diagnostics to be printed.  @code{exit(3)} may  *       or may not be called.  It depends upon whether or not the options  *       were generated with the "allow-errors" attribute, or if the  *       ERRSKIP_OPTERR or ERRSTOP_OPTERR macros were invoked. =*/
end_comment

begin_function
name|int
name|optionProcess
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|int
name|argCt
parameter_list|,
name|char
modifier|*
modifier|*
name|argVect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validateOptionsStruct
argument_list|(
name|pOpts
argument_list|,
name|argVect
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
comment|/*      *  Establish the real program name, the program full path,      *  and do all the presetting the first time thru only.      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_INITDONE
operator|)
operator|==
literal|0
condition|)
block|{
name|pOpts
operator|->
name|origArgCt
operator|=
name|argCt
expr_stmt|;
name|pOpts
operator|->
name|origArgVect
operator|=
name|argVect
expr_stmt|;
name|pOpts
operator|->
name|fOptSet
operator||=
name|OPTPROC_INITDONE
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doPresets
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
name|optionSort
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      *  IF we are (re)starting,      *  THEN reset option location      */
elseif|else
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|<=
literal|0
condition|)
block|{
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|doRegularOpts
argument_list|(
name|pOpts
argument_list|)
argument_list|)
condition|)
return|return
name|pOpts
operator|->
name|origArgCt
return|;
comment|/*      *  IF    there were no errors      *    AND we have RC/INI files      *    AND there is a request to save the files      *  THEN do that now before testing for conflicts.      *       (conflicts are ignored in preset options)      */
if|if
condition|(
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
literal|0
condition|)
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOpts
operator|->
name|specOptIdx
operator|.
name|save_opts
decl_stmt|;
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
block|{
name|optionSaveFile
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      *  IF we are checking for errors,      *  THEN look for too few occurrences of required options      */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|checkConsistency
argument_list|(
name|pOpts
argument_list|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|pOpts
operator|->
name|pUsageProc
call|)
argument_list|(
name|pOpts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|pOpts
operator|->
name|curOptIdx
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/autoopts.c */
end_comment

end_unit

