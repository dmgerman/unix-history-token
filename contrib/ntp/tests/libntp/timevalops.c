begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|//some unused features are still in the wrapper, unconverted
end_comment

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"unity.h"
end_include

begin_define
define|#
directive|define
name|TEST_ASSERT_EQUAL_timeval
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{				\     TEST_ASSERT_EQUAL_MESSAGE(a.tv_sec, b.tv_sec, "Field tv_sec");	\     TEST_ASSERT_EQUAL_MESSAGE(a.tv_usec, b.tv_usec, "Field tv_usec");	\ }
end_define

begin_function_decl
specifier|static
name|u_int32
name|my_tick_to_tsf
parameter_list|(
name|u_int32
name|ticks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|my_tsf_to_tick
parameter_list|(
name|u_int32
name|tsf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// that's it...
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|usec
decl_stmt|;
name|u_int32
name|frac
decl_stmt|;
block|}
name|lfpfracdata
typedef|;
end_typedef

begin_function_decl
name|struct
name|timeval
name|timeval_init
parameter_list|(
name|time_t
name|hi
parameter_list|,
name|long
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|bool
name|timeval_isValid
parameter_list|(
name|struct
name|timeval
name|V
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|l_fp
name|l_fp_init
parameter_list|(
name|int32
name|i
parameter_list|,
name|u_int32
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|AssertTimevalClose
parameter_list|(
specifier|const
name|struct
name|timeval
name|m
parameter_list|,
specifier|const
name|struct
name|timeval
name|n
parameter_list|,
specifier|const
name|struct
name|timeval
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|AssertFpClose
parameter_list|(
specifier|const
name|l_fp
name|m
parameter_list|,
specifier|const
name|l_fp
name|n
parameter_list|,
specifier|const
name|l_fp
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Helpers1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Normalise
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SignNoFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SignWithFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracEQ
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracGT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracLT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddFullNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddFullOflow1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddUsecNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddUsecOflow1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubFullNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubFullOflow
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubUsecNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubUsecOflow
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Neg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AbsNoFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AbsWithFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Helpers2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPbittest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPrelPos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPrelNeg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPabs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPbittest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPrelPos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPrelNeg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_LFProundtrip
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToString
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//**********************************MY CUSTOM FUNCTIONS***********************
end_comment

begin_function
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
block|{
name|init_lib
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|timeval
name|timeval_init
parameter_list|(
name|time_t
name|hi
parameter_list|,
name|long
name|lo
parameter_list|)
block|{
name|struct
name|timeval
name|V
decl_stmt|;
name|V
operator|.
name|tv_sec
operator|=
name|hi
expr_stmt|;
name|V
operator|.
name|tv_usec
operator|=
name|lo
expr_stmt|;
return|return
name|V
return|;
block|}
end_function

begin_function
specifier|const
name|bool
name|timeval_isValid
parameter_list|(
name|struct
name|timeval
name|V
parameter_list|)
block|{
return|return
name|V
operator|.
name|tv_usec
operator|>=
literal|0
operator|&&
name|V
operator|.
name|tv_usec
operator|<
literal|1000000
return|;
block|}
end_function

begin_function
name|l_fp
name|l_fp_init
parameter_list|(
name|int32
name|i
parameter_list|,
name|u_int32
name|f
parameter_list|)
block|{
name|l_fp
name|temp
decl_stmt|;
name|temp
operator|.
name|l_i
operator|=
name|i
expr_stmt|;
name|temp
operator|.
name|l_uf
operator|=
name|f
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
name|bool
name|AssertTimevalClose
parameter_list|(
specifier|const
name|struct
name|timeval
name|m
parameter_list|,
specifier|const
name|struct
name|timeval
name|n
parameter_list|,
specifier|const
name|struct
name|timeval
name|limit
parameter_list|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|diff
operator|=
name|abs_tval
argument_list|(
name|sub_tval
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_tval
argument_list|(
name|limit
argument_list|,
name|diff
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
else|else
block|{
name|printf
argument_list|(
literal|"m_expr which is %ld.%lu \nand\nn_expr which is %ld.%lu\nare not close; diff=%ld.%luusec\n"
argument_list|,
name|m
operator|.
name|tv_sec
argument_list|,
name|m
operator|.
name|tv_usec
argument_list|,
name|n
operator|.
name|tv_sec
argument_list|,
name|n
operator|.
name|tv_usec
argument_list|,
name|diff
operator|.
name|tv_sec
argument_list|,
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|//I don't have variables m_expr and n_expr in unity, those are command line arguments which only getst has!!!
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|bool
name|AssertFpClose
parameter_list|(
specifier|const
name|l_fp
name|m
parameter_list|,
specifier|const
name|l_fp
name|n
parameter_list|,
specifier|const
name|l_fp
name|limit
parameter_list|)
block|{
name|l_fp
name|diff
decl_stmt|;
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
name|diff
operator|=
name|m
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|n
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|limit
argument_list|,
operator|&
name|diff
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"m_expr which is %s \nand\nn_expr which is %s\nare not close; diff=%susec\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|m
argument_list|,
literal|10
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|n
argument_list|,
literal|10
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|diff
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|//printf("m_expr which is %d.%d \nand\nn_expr which is %d.%d\nare not close; diff=%d.%dusec\n", m.l_uf, m.Ul_i, n.l_uf, n.Ul_i, diff.l_uf, diff.Ul_i);
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|//---------------------------------------------------
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|lfpfracdata
name|fdata
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0x00000000
block|}
block|,
block|{
literal|7478
block|,
literal|0x01ea1405
block|}
block|,
block|{
literal|22077
block|,
literal|0x05a6d699
block|}
block|,
block|{
literal|125000
block|,
literal|0x20000000
block|}
block|,
block|{
literal|180326
block|,
literal|0x2e29d841
block|}
block|,
block|{
literal|207979
block|,
literal|0x353e1c9b
block|}
block|,
block|{
literal|250000
block|,
literal|0x40000000
block|}
block|,
block|{
literal|269509
block|,
literal|0x44fe8ab5
block|}
block|,
block|{
literal|330441
block|,
literal|0x5497c808
block|}
block|,
block|{
literal|333038
block|,
literal|0x5541fa76
block|}
block|,
block|{
literal|375000
block|,
literal|0x60000000
block|}
block|,
block|{
literal|394734
block|,
literal|0x650d4995
block|}
block|,
block|{
literal|446327
block|,
literal|0x72427c7c
block|}
block|,
block|{
literal|500000
block|,
literal|0x80000000
block|}
block|,
block|{
literal|517139
block|,
literal|0x846338b4
block|}
block|,
block|{
literal|571953
block|,
literal|0x926b8306
block|}
block|,
block|{
literal|587353
block|,
literal|0x965cc426
block|}
block|,
block|{
literal|625000
block|,
literal|0xa0000000
block|}
block|,
block|{
literal|692136
block|,
literal|0xb12fd32c
block|}
block|,
block|{
literal|750000
block|,
literal|0xc0000000
block|}
block|,
block|{
literal|834068
block|,
literal|0xd5857aff
block|}
block|,
block|{
literal|848454
block|,
literal|0xd9344806
block|}
block|,
block|{
literal|854222
block|,
literal|0xdaae4b02
block|}
block|,
block|{
literal|861465
block|,
literal|0xdc88f862
block|}
block|,
block|{
literal|875000
block|,
literal|0xe0000000
block|}
block|,
block|{
literal|910661
block|,
literal|0xe921144d
block|}
block|,
block|{
literal|922162
block|,
literal|0xec12cf10
block|}
block|,
block|{
literal|942190
block|,
literal|0xf1335d25
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|u_int32
name|my_tick_to_tsf
parameter_list|(
name|u_int32
name|ticks
parameter_list|)
block|{
comment|// convert microseconds to l_fp fractional units, using double
comment|// precision float calculations or, if available, 64bit integer
comment|// arithmetic. This should give the precise fraction, rounded to
comment|// the nearest representation.
ifdef|#
directive|ifdef
name|HAVE_U_INT64
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
operator|(
operator|(
call|(
name|u_int64
call|)
argument_list|(
name|ticks
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator|+
literal|500000
operator|)
operator|/
literal|1000000
argument_list|)
return|;
comment|//I put too much () when casting just to be safe
else|#
directive|else
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
call|(
name|double
call|)
argument_list|(
name|ticks
argument_list|)
operator|)
operator|*
literal|4294.967296
operator|+
literal|0.5
argument_list|)
return|;
endif|#
directive|endif
comment|// And before you ask: if ticks>= 1000000, the result is
comment|// truncated nonsense, so don't use it out-of-bounds.
block|}
end_function

begin_function
name|u_int32
name|my_tsf_to_tick
parameter_list|(
name|u_int32
name|tsf
parameter_list|)
block|{
comment|// Inverse operation: converts fraction to microseconds.
ifdef|#
directive|ifdef
name|HAVE_U_INT64
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
call|(
name|u_int64
call|)
argument_list|(
name|tsf
argument_list|)
operator|*
literal|1000000
operator|+
literal|0x80000000
operator|)
operator|>>
literal|32
argument_list|)
return|;
comment|//CHECK ME!!!
else|#
directive|else
return|return
call|(
name|u_int32
call|)
argument_list|(
name|double
argument_list|(
name|tsf
argument_list|)
operator|/
literal|4294.967296
operator|+
literal|0.5
argument_list|)
return|;
endif|#
directive|endif
comment|// Beware: The result might be 10^6 due to rounding!
block|}
end_function

begin_comment
comment|//*******************************END OF CUSTOM FUNCTIONS*********************
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test support stuff - part1
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Helpers1
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|x
decl_stmt|;
for|for
control|(
name|x
operator|.
name|tv_sec
operator|=
operator|-
literal|2
init|;
name|x
operator|.
name|tv_sec
operator|<
literal|3
condition|;
name|x
operator|.
name|tv_sec
operator|++
control|)
block|{
name|x
operator|.
name|tv_usec
operator|=
operator|-
literal|1
expr_stmt|;
name|TEST_ASSERT_FALSE
argument_list|(
name|timeval_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timeval_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|=
literal|999999
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timeval_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_usec
operator|=
literal|1000000
expr_stmt|;
name|TEST_ASSERT_FALSE
argument_list|(
name|timeval_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test normalisation
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Normalise
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
operator|-
literal|2000000000
init|;
name|ns
operator|<=
literal|2000000000
condition|;
name|ns
operator|+=
literal|10000000
control|)
block|{
name|struct
name|timeval
name|x
init|=
name|timeval_init
argument_list|(
literal|0
argument_list|,
name|ns
argument_list|)
decl_stmt|;
name|x
operator|=
name|normalize_tval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timeval_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test classification
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_SignNoFrac
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|// sign test, no fraction
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
literal|0
operator|)
operator|-
operator|(
name|i
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|r
init|=
name|test_tval
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SignWithFrac
parameter_list|(
name|void
parameter_list|)
block|{
comment|// sign test, with fraction
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>=
literal|0
operator|)
operator|-
operator|(
name|i
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|r
init|=
name|test_tval
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test compare
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_CmpFracEQ
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|// fractions are equal
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
name|j
operator|)
operator|-
operator|(
name|i
operator|<
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tval_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_CmpFracGT
parameter_list|(
name|void
parameter_list|)
block|{
comment|// fraction a bigger fraction b
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|999800
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>=
name|j
operator|)
operator|-
operator|(
name|i
operator|<
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tval_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_CmpFracLT
parameter_list|(
name|void
parameter_list|)
block|{
comment|// fraction a less fraction b
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|999800
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
name|j
operator|)
operator|-
operator|(
name|i
operator|<=
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tval_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// Test addition (sum)
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_AddFullNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|+
name|j
argument_list|,
literal|200
operator|+
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|add_tval
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddFullOflow1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|999900
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|+
name|j
operator|+
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|add_tval
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddUsecNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|add_tval_us
argument_list|(
name|a
argument_list|,
literal|600
operator|-
literal|200
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddUsecOflow1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|add_tval_us
argument_list|(
name|a
argument_list|,
name|MICROSECONDS
operator|-
literal|100
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test subtraction (difference)
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_SubFullNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|-
name|j
argument_list|,
literal|600
operator|-
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|sub_tval
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubFullOflow
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
init|=
name|timeval_init
argument_list|(
name|j
argument_list|,
literal|999900
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|-
name|j
operator|-
literal|1
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|sub_tval
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubUsecNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|sub_tval_us
argument_list|(
name|a
argument_list|,
literal|600
operator|-
literal|200
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubUsecOflow
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|i
operator|-
literal|1
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|c
operator|=
name|sub_tval_us
argument_list|(
name|a
argument_list|,
name|MICROSECONDS
operator|-
literal|100
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test negation
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Neg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
decl_stmt|;
name|struct
name|timeval
name|c
decl_stmt|;
name|b
operator|=
name|neg_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_tval
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|0
argument_list|,
name|test_tval
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test abs value
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_AbsNoFrac
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
decl_stmt|;
name|b
operator|=
name|abs_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
operator|(
name|i
operator|!=
literal|0
operator|)
argument_list|,
name|test_tval
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AbsWithFrac
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
operator|-
literal|4
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|b
decl_stmt|;
name|b
operator|=
name|abs_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|1
argument_list|,
name|test_tval
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test support stuff -- part 2
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Helpers2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|limit
init|=
name|timeval_init
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|x
decl_stmt|,
name|y
decl_stmt|;
name|long
name|i
decl_stmt|;
for|for
control|(
name|x
operator|.
name|tv_sec
operator|=
operator|-
literal|2
init|;
name|x
operator|.
name|tv_sec
operator|<
literal|3
condition|;
name|x
operator|.
name|tv_sec
operator|++
control|)
block|{
for|for
control|(
name|x
operator|.
name|tv_usec
operator|=
literal|1
init|;
name|x
operator|.
name|tv_usec
operator|<
literal|1000000
condition|;
name|x
operator|.
name|tv_usec
operator|+=
literal|499999
control|)
block|{
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|y
operator|.
name|tv_usec
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|-
literal|2
operator|&&
name|i
operator|<=
literal|2
condition|)
block|{
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimevalClose
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
comment|//ASSERT_PRED_FORMAT2(isClose, x, y);
block|}
else|else
block|{
name|TEST_ASSERT_FALSE
argument_list|(
name|AssertTimevalClose
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|// and the global predicate instances we're using here
end_comment

begin_comment
comment|//static l_fp lfpClose =  l_fp_init(0, 1); //static AssertFpClose FpClose(0, 1);
end_comment

begin_comment
comment|//static struct timeval timevalClose = timeval_init(0, 1); //static AssertTimevalClose TimevalClose(0, 1);
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// conversion to l_fp
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_ToLFPbittest
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|lfpClose
init|=
name|l_fp_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|u_int32
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000000
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|my_tick_to_tsf
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tval_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertFpClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|lfpClose
argument_list|)
argument_list|)
expr_stmt|;
comment|//ASSERT_PRED_FORMAT2(FpClose, E, r);
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPrelPos
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|lfpClose
init|=
name|l_fp_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tval_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertFpClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|lfpClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPrelNeg
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|lfpClose
init|=
name|l_fp_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
operator|-
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
operator|~
literal|0
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tval_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertFpClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|lfpClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPabs
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|lfpClose
init|=
name|l_fp_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
operator|+
name|JAN_1970
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tval_stamp_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertFpClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|lfpClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// conversion from l_fp
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_FromLFPbittest
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timevalClose
init|=
name|timeval_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// Not *exactly* a bittest, because 2**32 tests would take a
comment|// really long time even on very fast machines! So we do test
comment|// every 1000 fractional units.
name|u_int32
name|tsf
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tsf
operator|=
literal|0
init|;
name|tsf
operator|<
operator|~
operator|(
call|(
name|u_int32
call|)
argument_list|(
literal|1000
argument_list|)
operator|)
condition|;
name|tsf
operator|+=
literal|1000
control|)
block|{
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
literal|1
argument_list|,
name|my_tsf_to_tick
argument_list|(
name|tsf
argument_list|)
argument_list|)
decl_stmt|;
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|tsf
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// The conversion might be off by one microsecond when
comment|// comparing to calculated value.
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimevalClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|timevalClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_FromLFPrelPos
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timevalClose
init|=
name|timeval_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimevalClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|timevalClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_FromLFPrelNeg
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|timevalClose
init|=
name|timeval_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
operator|~
literal|0
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
operator|-
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimevalClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|timevalClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// usec -> frac -> usec roundtrip, using a prime start and increment
end_comment

begin_function
name|void
name|test_LFProundtrip
parameter_list|(
name|void
parameter_list|)
block|{
name|int32_t
name|t
init|=
operator|-
literal|1
decl_stmt|;
name|u_int32
name|i
init|=
literal|5
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|-
literal|1
init|;
name|t
operator|<
literal|2
condition|;
operator|++
name|t
control|)
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<
literal|1000000
condition|;
name|i
operator|+=
literal|11
control|)
block|{
name|struct
name|timeval
name|E
init|=
name|timeval_init
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|l_fp
name|a
decl_stmt|;
name|struct
name|timeval
name|r
decl_stmt|;
name|a
operator|=
name|tval_intv_to_lfp
argument_list|(
name|E
argument_list|)
expr_stmt|;
name|r
operator|=
name|lfp_intv_to_tval
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timeval
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// string formatting
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_ToString
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|time_t
name|sec
decl_stmt|;
name|long
name|usec
decl_stmt|;
specifier|const
name|char
modifier|*
name|repr
decl_stmt|;
block|}
name|data
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|"0.000000"
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
literal|"2.000000"
block|}
block|,
block|{
operator|-
literal|2
block|,
literal|0
block|,
literal|"-2.000000"
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|"0.000001"
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|,
literal|"-0.000001"
block|}
block|,
block|{
literal|1
block|,
operator|-
literal|1
block|,
literal|"0.999999"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|"-0.999999"
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|"-1.000001"
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|data
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timeval
name|a
init|=
name|timeval_init
argument_list|(
name|data
index|[
name|i
index|]
operator|.
name|sec
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|usec
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|E
init|=
name|data
index|[
name|i
index|]
operator|.
name|repr
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|tvaltoa
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL_STRING
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// -*- EOF -*-
end_comment

end_unit

