begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"timespecops.h"
end_include

begin_include
include|#
directive|include
file|"unity.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|TEST_ASSERT_EQUAL_timespec
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{				\     TEST_ASSERT_EQUAL_MESSAGE(a.tv_sec, b.tv_sec, "Field tv_sec");	\     TEST_ASSERT_EQUAL_MESSAGE(a.tv_nsec, b.tv_nsec, "Field tv_nsec");	\ }
end_define

begin_define
define|#
directive|define
name|TEST_ASSERT_EQUAL_l_fp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{					\     TEST_ASSERT_EQUAL_MESSAGE(a.l_i, b.l_i, "Field l_i");		\     TEST_ASSERT_EQUAL_UINT_MESSAGE(a.l_uf, b.l_uf, "Field l_uf");	\ }
end_define

begin_function_decl
specifier|static
name|u_int32
name|my_tick_to_tsf
parameter_list|(
name|u_int32
name|ticks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|my_tsf_to_tick
parameter_list|(
name|u_int32
name|tsf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// that's it...
end_comment

begin_struct
struct|struct
name|lfpfracdata
block|{
name|long
name|nsec
decl_stmt|;
name|u_int32
name|frac
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Helpers1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Normalise
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SignNoFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SignWithFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracEQ
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracGT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_CmpFracLT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddFullNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddFullOflow1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddNsecNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AddNsecOflow1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubFullNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubFullOflow
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubNsecNorm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SubNsecOflow
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Neg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AbsNoFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_AbsWithFrac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_Helpers2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPbittest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPrelPos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPrelNeg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToLFPabs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPbittest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPrelPos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_FromLFPrelNeg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_LFProundtrip
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_ToString
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|bool
name|timespec_isValid
parameter_list|(
name|struct
name|timespec
name|V
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|timespec
name|timespec_init
parameter_list|(
name|time_t
name|hi
parameter_list|,
name|long
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|l_fp
name|l_fp_init
parameter_list|(
name|int32
name|i
parameter_list|,
name|u_int32
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|AssertFpClose
parameter_list|(
specifier|const
name|l_fp
name|m
parameter_list|,
specifier|const
name|l_fp
name|n
parameter_list|,
specifier|const
name|l_fp
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|AssertTimespecClose
parameter_list|(
specifier|const
name|struct
name|timespec
name|m
parameter_list|,
specifier|const
name|struct
name|timespec
name|n
parameter_list|,
specifier|const
name|struct
name|timespec
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//***************************MY CUSTOM FUNCTIONS***************************
end_comment

begin_function
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
block|{
name|init_lib
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|const
name|bool
name|timespec_isValid
parameter_list|(
name|struct
name|timespec
name|V
parameter_list|)
block|{
return|return
name|V
operator|.
name|tv_nsec
operator|>=
literal|0
operator|&&
name|V
operator|.
name|tv_nsec
operator|<
literal|1000000000
return|;
block|}
end_function

begin_function
name|struct
name|timespec
name|timespec_init
parameter_list|(
name|time_t
name|hi
parameter_list|,
name|long
name|lo
parameter_list|)
block|{
name|struct
name|timespec
name|V
decl_stmt|;
name|V
operator|.
name|tv_sec
operator|=
name|hi
expr_stmt|;
name|V
operator|.
name|tv_nsec
operator|=
name|lo
expr_stmt|;
return|return
name|V
return|;
block|}
end_function

begin_function
name|l_fp
name|l_fp_init
parameter_list|(
name|int32
name|i
parameter_list|,
name|u_int32
name|f
parameter_list|)
block|{
name|l_fp
name|temp
decl_stmt|;
name|temp
operator|.
name|l_i
operator|=
name|i
expr_stmt|;
name|temp
operator|.
name|l_uf
operator|=
name|f
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_function
name|bool
name|AssertFpClose
parameter_list|(
specifier|const
name|l_fp
name|m
parameter_list|,
specifier|const
name|l_fp
name|n
parameter_list|,
specifier|const
name|l_fp
name|limit
parameter_list|)
block|{
name|l_fp
name|diff
decl_stmt|;
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
name|diff
operator|=
name|m
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
name|n
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|L_ISGEQ
argument_list|(
operator|&
name|limit
argument_list|,
operator|&
name|diff
argument_list|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"m_expr which is %s \nand\nn_expr which is %s\nare not close; diff=%susec\n"
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|m
argument_list|,
literal|10
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|n
argument_list|,
literal|10
argument_list|)
argument_list|,
name|lfptoa
argument_list|(
operator|&
name|diff
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|bool
name|AssertTimespecClose
parameter_list|(
specifier|const
name|struct
name|timespec
name|m
parameter_list|,
specifier|const
name|struct
name|timespec
name|n
parameter_list|,
specifier|const
name|struct
name|timespec
name|limit
parameter_list|)
block|{
name|struct
name|timespec
name|diff
decl_stmt|;
name|diff
operator|=
name|abs_tspec
argument_list|(
name|sub_tspec
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_tspec
argument_list|(
name|limit
argument_list|,
name|diff
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
else|else
block|{
name|printf
argument_list|(
literal|"m_expr which is %ld.%lu \nand\nn_expr which is %ld.%lu\nare not close; diff=%ld.%lunsec\n"
argument_list|,
name|m
operator|.
name|tv_sec
argument_list|,
name|m
operator|.
name|tv_nsec
argument_list|,
name|n
operator|.
name|tv_sec
argument_list|,
name|n
operator|.
name|tv_nsec
argument_list|,
name|diff
operator|.
name|tv_sec
argument_list|,
name|diff
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|lfpfracdata
name|fdata
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0x00000000
block|}
block|,
block|{
literal|2218896
block|,
literal|0x00916ae6
block|}
block|,
block|{
literal|16408100
block|,
literal|0x0433523d
block|}
block|,
block|{
literal|125000000
block|,
literal|0x20000000
block|}
block|,
block|{
literal|250000000
block|,
literal|0x40000000
block|}
block|,
block|{
literal|287455871
block|,
literal|0x4996b53d
block|}
block|,
block|{
literal|375000000
block|,
literal|0x60000000
block|}
block|,
block|{
literal|500000000
block|,
literal|0x80000000
block|}
block|,
block|{
literal|518978897
block|,
literal|0x84dbcd0e
block|}
block|,
block|{
literal|563730222
block|,
literal|0x90509fb3
block|}
block|,
block|{
literal|563788007
block|,
literal|0x9054692c
block|}
block|,
block|{
literal|583289882
block|,
literal|0x95527c57
block|}
block|,
block|{
literal|607074509
block|,
literal|0x9b693c2a
block|}
block|,
block|{
literal|625000000
block|,
literal|0xa0000000
block|}
block|,
block|{
literal|645184059
block|,
literal|0xa52ac851
block|}
block|,
block|{
literal|676497788
block|,
literal|0xad2ef583
block|}
block|,
block|{
literal|678910895
block|,
literal|0xadcd1abb
block|}
block|,
block|{
literal|679569625
block|,
literal|0xadf84663
block|}
block|,
block|{
literal|690926741
block|,
literal|0xb0e0932d
block|}
block|,
block|{
literal|705656483
block|,
literal|0xb4a5e73d
block|}
block|,
block|{
literal|723553854
block|,
literal|0xb93ad34c
block|}
block|,
block|{
literal|750000000
block|,
literal|0xc0000000
block|}
block|,
block|{
literal|763550253
block|,
literal|0xc3780785
block|}
block|,
block|{
literal|775284917
block|,
literal|0xc6791284
block|}
block|,
block|{
literal|826190764
block|,
literal|0xd3813ce8
block|}
block|,
block|{
literal|875000000
block|,
literal|0xe0000000
block|}
block|,
block|{
literal|956805507
block|,
literal|0xf4f134a9
block|}
block|,
block|{
literal|982570733
block|,
literal|0xfb89c16c
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|u_int32
name|my_tick_to_tsf
parameter_list|(
name|u_int32
name|ticks
parameter_list|)
block|{
comment|// convert nanoseconds to l_fp fractional units, using double
comment|// precision float calculations or, if available, 64bit integer
comment|// arithmetic. This should give the precise fraction, rounded to
comment|// the nearest representation.
ifdef|#
directive|ifdef
name|HAVE_U_INT64
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
operator|(
operator|(
call|(
name|u_int64
call|)
argument_list|(
name|ticks
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator|+
literal|500000000
operator|)
operator|/
literal|1000000000
argument_list|)
return|;
else|#
directive|else
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
name|double
argument_list|(
name|ticks
argument_list|)
operator|)
operator|*
literal|4.294967296
operator|+
literal|0.5
argument_list|)
return|;
endif|#
directive|endif
comment|// And before you ask: if ticks>= 1000000000, the result is
comment|// truncated nonsense, so don't use it out-of-bounds.
block|}
end_function

begin_function
name|u_int32
name|my_tsf_to_tick
parameter_list|(
name|u_int32
name|tsf
parameter_list|)
block|{
comment|// Inverse operation: converts fraction to microseconds.
ifdef|#
directive|ifdef
name|HAVE_U_INT64
return|return
call|(
name|u_int32
call|)
argument_list|(
operator|(
operator|(
call|(
name|u_int64
call|)
argument_list|(
name|tsf
argument_list|)
operator|)
operator|*
literal|1000000000
operator|+
literal|0x80000000
operator|)
operator|>>
literal|32
argument_list|)
return|;
else|#
directive|else
return|return
call|(
name|u_int32
call|)
argument_list|(
name|double
argument_list|(
name|tsf
argument_list|)
operator|/
literal|4.294967296
operator|+
literal|0.5
argument_list|)
return|;
endif|#
directive|endif
comment|// Beware: The result might be 10^9 due to rounding!
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test support stuff -- part 1
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Helpers1
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|x
decl_stmt|;
for|for
control|(
name|x
operator|.
name|tv_sec
operator|=
operator|-
literal|2
init|;
name|x
operator|.
name|tv_sec
operator|<
literal|3
condition|;
name|x
operator|.
name|tv_sec
operator|++
control|)
block|{
name|x
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
name|TEST_ASSERT_FALSE
argument_list|(
name|timespec_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timespec_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
literal|999999999
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timespec_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|.
name|tv_nsec
operator|=
literal|1000000000
expr_stmt|;
name|TEST_ASSERT_FALSE
argument_list|(
name|timespec_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test normalisation
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Normalise
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|ns
decl_stmt|;
for|for
control|(
name|ns
operator|=
operator|-
literal|2000000000
init|;
name|ns
operator|<=
literal|2000000000
condition|;
name|ns
operator|+=
literal|10000000
control|)
block|{
name|struct
name|timespec
name|x
init|=
name|timespec_init
argument_list|(
literal|0
argument_list|,
name|ns
argument_list|)
decl_stmt|;
name|x
operator|=
name|normalize_tspec
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|timespec_isValid
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test classification
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_SignNoFrac
parameter_list|(
name|void
parameter_list|)
block|{
comment|// sign test, no fraction
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
literal|0
operator|)
operator|-
operator|(
name|i
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|r
init|=
name|test_tspec
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SignWithFrac
parameter_list|(
name|void
parameter_list|)
block|{
comment|// sign test, with fraction
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>=
literal|0
operator|)
operator|-
operator|(
name|i
operator|<
literal|0
operator|)
decl_stmt|;
name|int
name|r
init|=
name|test_tspec
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test compare
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_CmpFracEQ
parameter_list|(
name|void
parameter_list|)
block|{
comment|// fractions are equal
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
name|j
operator|)
operator|-
operator|(
name|i
operator|<
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tspec_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_CmpFracGT
parameter_list|(
name|void
parameter_list|)
block|{
comment|// fraction a bigger fraction b
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|999999800
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>=
name|j
operator|)
operator|-
operator|(
name|i
operator|<
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tspec_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_CmpFracLT
parameter_list|(
name|void
parameter_list|)
block|{
comment|// fraction a less fraction b
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|999999800
argument_list|)
decl_stmt|;
name|int
name|E
init|=
operator|(
name|i
operator|>
name|j
operator|)
operator|-
operator|(
name|i
operator|<=
name|j
operator|)
decl_stmt|;
name|int
name|r
init|=
name|cmp_tspec_denorm
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// Test addition (sum)
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_AddFullNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|+
name|j
argument_list|,
literal|200
operator|+
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|add_tspec
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddFullOflow1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|999999900
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|+
name|j
operator|+
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|add_tspec
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddNsecNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|add_tspec_ns
argument_list|(
name|a
argument_list|,
literal|600
operator|-
literal|200
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AddNsecOflow1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|add_tspec_ns
argument_list|(
name|a
argument_list|,
name|NANOSECONDS
operator|-
literal|100
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test subtraction (difference)
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_SubFullNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|400
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|-
name|j
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|sub_tspec
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubFullOflow
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
operator|-
literal|4
init|;
name|j
operator|<=
literal|4
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
init|=
name|timespec_init
argument_list|(
name|j
argument_list|,
literal|999999900
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|-
name|j
operator|-
literal|1
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|sub_tspec
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubNsecNorm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|sub_tspec_ns
argument_list|(
name|a
argument_list|,
literal|600
operator|-
literal|200
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_SubNsecOflow
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|i
operator|-
literal|1
argument_list|,
literal|200
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|c
operator|=
name|sub_tspec_ns
argument_list|(
name|a
argument_list|,
name|NANOSECONDS
operator|-
literal|100
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test negation
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Neg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
decl_stmt|;
name|struct
name|timespec
name|c
decl_stmt|;
name|b
operator|=
name|neg_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_tspec
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|0
argument_list|,
name|test_tspec
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// test abs value
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_AbsNoFrac
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
decl_stmt|;
name|b
operator|=
name|abs_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
operator|(
name|i
operator|!=
literal|0
operator|)
argument_list|,
name|test_tspec
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_AbsWithFrac
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<=
literal|4
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|i
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|b
decl_stmt|;
name|b
operator|=
name|abs_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|1
argument_list|,
name|test_tspec
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test support stuff -- part 2
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_Helpers2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|limit
init|=
name|timespec_init
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|x
decl_stmt|,
name|y
decl_stmt|;
name|long
name|i
decl_stmt|;
for|for
control|(
name|x
operator|.
name|tv_sec
operator|=
operator|-
literal|2
init|;
name|x
operator|.
name|tv_sec
operator|<
literal|3
condition|;
name|x
operator|.
name|tv_sec
operator|++
control|)
for|for
control|(
name|x
operator|.
name|tv_nsec
operator|=
literal|1
init|;
name|x
operator|.
name|tv_nsec
operator|<
literal|1000000000
condition|;
name|x
operator|.
name|tv_nsec
operator|+=
literal|499999999
control|)
block|{
for|for
control|(
name|i
operator|=
operator|-
literal|4
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
name|y
operator|=
name|x
expr_stmt|;
name|y
operator|.
name|tv_nsec
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|-
literal|2
operator|&&
name|i
operator|<=
literal|2
condition|)
block|{
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimespecClose
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TEST_ASSERT_FALSE
argument_list|(
name|AssertTimespecClose
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// conversion to l_fp
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_ToLFPbittest
parameter_list|(
name|void
parameter_list|)
block|{
name|l_fp
name|lfpClose
init|=
name|l_fp_init
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|u_int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000000000
condition|;
name|i
operator|+=
literal|1000
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
literal|1
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|my_tick_to_tsf
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertFpClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|lfpClose
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPrelPos
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_l_fp
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPrelNeg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
operator|-
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
operator|~
literal|0
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_l_fp
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_ToLFPabs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
name|l_fp
name|E
init|=
name|l_fp_init
argument_list|(
literal|1
operator|+
name|JAN_1970
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|l_fp
name|r
decl_stmt|;
name|r
operator|=
name|tspec_stamp_to_lfp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_l_fp
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// conversion from l_fp
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_FromLFPbittest
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|limit
init|=
name|timespec_init
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// Not *exactly* a bittest, because 2**32 tests would take a
comment|// really long time even on very fast machines! So we do test
comment|// every 1000 fractional units.
name|u_int32
name|tsf
decl_stmt|;
for|for
control|(
name|tsf
operator|=
literal|0
init|;
name|tsf
operator|<
operator|~
operator|(
call|(
name|u_int32
call|)
argument_list|(
literal|1000
argument_list|)
operator|)
condition|;
name|tsf
operator|+=
literal|1000
control|)
block|{
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
literal|1
argument_list|,
name|my_tsf_to_tick
argument_list|(
name|tsf
argument_list|)
argument_list|)
decl_stmt|;
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|tsf
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|// The conversion might be off by one nanosecond when
comment|// comparing to calculated value.
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimespecClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_FromLFPrelPos
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|limit
init|=
name|timespec_init
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimespecClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|test_FromLFPrelNeg
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timespec
name|limit
init|=
name|timespec_init
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|fdata
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|l_fp
name|a
init|=
name|l_fp_init
argument_list|(
operator|~
literal|0
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|frac
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
operator|-
literal|1
argument_list|,
name|fdata
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|r
decl_stmt|;
name|r
operator|=
name|lfp_intv_to_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|AssertTimespecClose
argument_list|(
name|E
argument_list|,
name|r
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// nsec -> frac -> nsec roundtrip, using a prime start and increment
end_comment

begin_function
name|void
name|test_LFProundtrip
parameter_list|(
name|void
parameter_list|)
block|{
name|int32_t
name|t
decl_stmt|;
name|u_int32
name|i
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|-
literal|1
init|;
name|t
operator|<
literal|2
condition|;
operator|++
name|t
control|)
for|for
control|(
name|i
operator|=
literal|4999
init|;
name|i
operator|<
literal|1000000000
condition|;
name|i
operator|+=
literal|10007
control|)
block|{
name|struct
name|timespec
name|E
init|=
name|timespec_init
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|l_fp
name|a
decl_stmt|;
name|struct
name|timespec
name|r
decl_stmt|;
name|a
operator|=
name|tspec_intv_to_lfp
argument_list|(
name|E
argument_list|)
expr_stmt|;
name|r
operator|=
name|lfp_intv_to_tspec
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL_timespec
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_comment
comment|// string formatting
end_comment

begin_comment
comment|//----------------------------------------------------------------------
end_comment

begin_function
name|void
name|test_ToString
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|time_t
name|sec
decl_stmt|;
name|long
name|nsec
decl_stmt|;
specifier|const
name|char
modifier|*
name|repr
decl_stmt|;
block|}
name|data
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|"0.000000000"
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
literal|"2.000000000"
block|}
block|,
block|{
operator|-
literal|2
block|,
literal|0
block|,
literal|"-2.000000000"
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|"0.000000001"
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|,
literal|"-0.000000001"
block|}
block|,
block|{
literal|1
block|,
operator|-
literal|1
block|,
literal|"0.999999999"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|"-0.999999999"
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|"-1.000000001"
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COUNTOF
argument_list|(
name|data
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|timespec
name|a
init|=
name|timespec_init
argument_list|(
name|data
index|[
name|i
index|]
operator|.
name|sec
argument_list|,
name|data
index|[
name|i
index|]
operator|.
name|nsec
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|E
init|=
name|data
index|[
name|i
index|]
operator|.
name|repr
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|tspectoa
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TEST_ASSERT_EQUAL_STRING
argument_list|(
name|E
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|// -*- EOF -*-
end_comment

end_unit

