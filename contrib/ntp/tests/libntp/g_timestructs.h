begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * timestructs.h -- test bed adaptors for time structs.  *  * Written by Juergen Perlinger (perlinger@ntp.org) for the NTP project.  * The contents of 'html/copyright.html' apply.  *  * Some wrapper classes and a closeness predicate that are used to  * bridge the gap between the goggletest framework and the structs used  * for representing time stamps (l_fp, struct timeval, struct timespec).  *  * Some ostream conversion operators are provided to give diagnostic  * output on errors. The normal string conversion functions will give  * HRVs (human readable values) but we might also be interested in the  * machine representation for diagnostic purposes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIMESTRUCTS_H
end_ifndef

begin_define
define|#
directive|define
name|TIMESTRUCTS_H
end_define

begin_extern
extern|extern
literal|"C"
block|{
include|#
directive|include
file|"ntp_fp.h"
block|}
end_extern

begin_decl_stmt
name|namespace
name|timeStruct
block|{
comment|// wrap a l_fp struct with common operations
name|class
name|l_fp_wrap
block|{
name|public
label|:
name|l_fp
name|V
decl_stmt|;
name|l_fp_wrap
argument_list|()
block|{
name|ZERO
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|l_fp_wrap
argument_list|(
argument|u_int32 hi
argument_list|,
argument|u_int32 lo
argument_list|)
block|{
name|V
operator|.
name|l_ui
operator|=
name|hi
expr_stmt|;
name|V
operator|.
name|l_uf
operator|=
name|lo
expr_stmt|;
block|}
name|l_fp_wrap
argument_list|(
argument|const l_fp&rhs
argument_list|)
block|{
name|V
operator|=
name|rhs
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|l_fp_wrap
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|L_ISEQU
argument_list|(
operator|&
name|V
argument_list|,
operator|&
name|rhs
operator|.
name|V
argument_list|)
return|;
block|}
name|operator
name|l_fp
modifier|*
parameter_list|()
block|{
return|return
operator|&
name|V
return|;
block|}
name|operator
name|l_fp
function|& ()
block|{
return|return
name|V
return|;
block|}
name|l_fp_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
name|l_fp_wrap
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
operator|.
name|V
block|;
return|return
operator|*
name|this
return|;
block|}
name|l_fp_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
name|l_fp
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
block|;
return|return
operator|*
name|this
return|;
block|}
block|}
empty_stmt|;
comment|// wrap a 'struct timeval' with common operations
name|class
name|timeval_wrap
block|{
name|public
label|:
name|struct
name|timeval
name|V
decl_stmt|;
name|timeval_wrap
argument_list|()
block|{
name|ZERO
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|timeval_wrap
argument_list|(
argument|time_t hi
argument_list|,
argument|long lo
argument_list|)
block|{
name|V
operator|.
name|tv_sec
operator|=
name|hi
expr_stmt|;
name|V
operator|.
name|tv_usec
operator|=
name|lo
expr_stmt|;
block|}
name|timeval_wrap
argument_list|(
argument|const struct timeval& rhs
argument_list|)
block|{
name|V
operator|=
name|rhs
expr_stmt|;
block|}
name|timeval_wrap
argument_list|(
argument|const timeval_wrap& rhs
argument_list|)
block|{
name|V
operator|=
name|rhs
operator|.
name|V
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|timeval_wrap
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|V
operator|.
name|tv_sec
operator|==
name|rhs
operator|.
name|V
operator|.
name|tv_sec
operator|&&
name|V
operator|.
name|tv_usec
operator|==
name|rhs
operator|.
name|V
operator|.
name|tv_usec
return|;
block|}
name|bool
name|valid
argument_list|()
specifier|const
block|{
return|return
name|V
operator|.
name|tv_usec
operator|>=
literal|0
operator|&&
name|V
operator|.
name|tv_usec
operator|<
literal|1000000
return|;
block|}
name|operator
name|struct
name|timeval
modifier|*
function|()
block|{
return|return
operator|&
name|V
return|;
block|}
name|operator
name|struct
name|timeval
modifier|&
function|()
block|{
return|return
name|V
return|;
block|}
name|timeval_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
name|timeval_wrap
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
operator|.
name|V
block|;
return|return
operator|*
name|this
return|;
block|}
name|timeval_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
expr|struct
name|timeval
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
block|;
return|return
operator|*
name|this
return|;
block|}
block|}
empty_stmt|;
comment|// wrap a 'struct timespec' with common operations
name|class
name|timespec_wrap
block|{
name|public
label|:
name|struct
name|timespec
name|V
decl_stmt|;
name|timespec_wrap
argument_list|()
block|{
name|ZERO
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|timespec_wrap
argument_list|(
argument|time_t hi
argument_list|,
argument|long lo
argument_list|)
block|{
name|V
operator|.
name|tv_sec
operator|=
name|hi
expr_stmt|;
name|V
operator|.
name|tv_nsec
operator|=
name|lo
expr_stmt|;
block|}
name|timespec_wrap
argument_list|(
argument|const struct timespec& rhs
argument_list|)
block|{
name|V
operator|=
name|rhs
expr_stmt|;
block|}
name|timespec_wrap
argument_list|(
argument|const timespec_wrap& rhs
argument_list|)
block|{
name|V
operator|=
name|rhs
operator|.
name|V
expr_stmt|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|timespec_wrap
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
name|V
operator|.
name|tv_sec
operator|==
name|rhs
operator|.
name|V
operator|.
name|tv_sec
operator|&&
name|V
operator|.
name|tv_nsec
operator|==
name|rhs
operator|.
name|V
operator|.
name|tv_nsec
return|;
block|}
name|bool
name|valid
argument_list|()
specifier|const
block|{
return|return
name|V
operator|.
name|tv_nsec
operator|>=
literal|0
operator|&&
name|V
operator|.
name|tv_nsec
operator|<
literal|1000000000
return|;
block|}
name|operator
name|struct
name|timespec
modifier|*
function|()
block|{
return|return
operator|&
name|V
return|;
block|}
name|operator
name|struct
name|timespec
modifier|&
function|()
block|{
return|return
name|V
return|;
block|}
name|timespec_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
name|timespec_wrap
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
operator|.
name|V
block|;
return|return
operator|*
name|this
return|;
block|}
name|timespec_wrap
modifier|&
name|operator
init|=
operator|(
specifier|const
expr|struct
name|timespec
operator|&
name|rhs
operator|)
block|{
name|V
operator|=
name|rhs
block|;
return|return
operator|*
name|this
return|;
block|}
block|}
empty_stmt|;
comment|// l_fp closeness testing predicate
comment|//
comment|// This predicate is used for the closeness ('near') testing of l_fp
comment|// values. Once constructed with a limit, it can be used to check the
comment|// absolute difference of two l_fp structs against that limit; if the
comment|// difference is less or equal to this limit, the test passes.
name|class
name|AssertFpClose
block|{
name|private
label|:
name|l_fp
name|limit
decl_stmt|;
name|public
label|:
name|AssertFpClose
argument_list|(
argument|u_int32 hi
argument_list|,
argument|u_int32 lo
argument_list|)
empty_stmt|;
operator|::
name|testing
operator|::
name|AssertionResult
name|operator
argument_list|()
argument_list|(
specifier|const
name|char
operator|*
name|m_expr
argument_list|,
specifier|const
name|char
operator|*
name|n_expr
argument_list|,
specifier|const
name|l_fp
operator|&
name|m
argument_list|,
specifier|const
name|l_fp
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// timeval closeness testing predicate
comment|//
comment|// CAVEAT: This class uses the timevalops functions
comment|// - sub_tval
comment|// - abs_tval
comment|// - cmp_tval
comment|//
comment|// This creates a dependency loop of sorts. The loop is defused by the
comment|// fact that these basic operations can be tested by exact value tests,
comment|// so once the basic timeval operations passed it's safe to use this
comment|// predicate.
name|class
name|AssertTimevalClose
block|{
name|private
label|:
name|struct
name|timeval
name|limit
decl_stmt|;
name|public
label|:
comment|// note: (hi,lo) should be a positive normalised timeval;
comment|// the constructor does not normalise the values!
name|AssertTimevalClose
argument_list|(
argument|time_t hi
argument_list|,
argument|int32 lo
argument_list|)
empty_stmt|;
operator|::
name|testing
operator|::
name|AssertionResult
name|operator
argument_list|()
argument_list|(
specifier|const
name|char
operator|*
name|m_expr
argument_list|,
specifier|const
name|char
operator|*
name|n_expr
argument_list|,
specifier|const
expr|struct
name|timeval
operator|&
name|m
argument_list|,
specifier|const
expr|struct
name|timeval
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// timespec closeness testing predicate
comment|//
comment|// CAVEAT: This class uses the timespecops functions
comment|// - sub_tspec
comment|// - abs_tspec
comment|// - cmp_tspec
comment|//
comment|// See the equivalent timeval helper.
name|class
name|AssertTimespecClose
block|{
name|private
label|:
name|struct
name|timespec
name|limit
decl_stmt|;
name|public
label|:
comment|// note: (hi,lo) should be a positive normalised timespec;
comment|// the constructor does not normalise the values!
name|AssertTimespecClose
argument_list|(
argument|time_t hi
argument_list|,
argument|int32 lo
argument_list|)
empty_stmt|;
operator|::
name|testing
operator|::
name|AssertionResult
name|operator
argument_list|()
argument_list|(
specifier|const
name|char
operator|*
name|m_expr
argument_list|,
specifier|const
name|char
operator|*
name|n_expr
argument_list|,
specifier|const
expr|struct
name|timespec
operator|&
name|m
argument_list|,
specifier|const
expr|struct
name|timespec
operator|&
name|n
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// since googletest wants to string format items, we declare the
comment|// necessary operators. Since all adaptors have only public members
comment|// there is need for friend declarations anywhere.
extern|extern std::ostream& operator<< (std::ostream& os
operator|,
extern|const timeStruct::l_fp_wrap& val
block|)
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern std::ostream& operator<< (std::ostream& os
operator|,
extern|const timeStruct::timeval_wrap& val
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern std::ostream& operator<< (std::ostream& os
operator|,
extern|const timeStruct::timespec_wrap& val
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace timeStruct
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// TIMESTRUCTS_H
end_comment

end_unit

