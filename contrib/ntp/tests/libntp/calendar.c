begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|//test fail without this include, for some reason
end_comment

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"unity.h"
end_include

begin_comment
comment|//#include "test-libntp.h"
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|//#include<sstream>
end_comment

begin_function_decl
specifier|static
name|int
name|leapdays
parameter_list|(
name|int
name|year
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|CalendarFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
name|cal
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&
end_comment

begin_function_decl
name|char
modifier|*
name|CalendarFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
name|iso
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&
end_comment

begin_comment
comment|//tehnically, booleans
end_comment

begin_function_decl
name|int
name|IsEqualCal
parameter_list|(
specifier|const
name|struct
name|calendar
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&&
end_comment

begin_function_decl
name|int
name|IsEqualIso
parameter_list|(
specifier|const
name|struct
name|isodate
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&&
end_comment

begin_function_decl
name|char
modifier|*
name|DateFromCalToStringCal
parameter_list|(
specifier|const
name|struct
name|calendar
name|cal
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&
end_comment

begin_function_decl
name|char
modifier|*
name|DateFromIsoToStringIso
parameter_list|(
specifier|const
name|struct
name|isodate
name|iso
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&
end_comment

begin_comment
comment|//tehnically, booleans
end_comment

begin_function_decl
name|int
name|sEqualDateCal
parameter_list|(
specifier|const
name|struct
name|calendar
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&&
end_comment

begin_function_decl
name|int
name|IsEqualDateIso
parameter_list|(
specifier|const
name|struct
name|isodate
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//&&
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test support stuff
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|//function which, in combination with TEST_ASSERT_TRUE replaces google test framework's EXPECT_GT(a,b); -> GT means Greather Than
end_comment

begin_comment
comment|//boolean
end_comment

begin_function
name|int
name|isGT
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|>
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|leapdays
parameter_list|(
name|int
name|year
parameter_list|)
block|{
if|if
condition|(
name|year
operator|%
literal|400
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|year
operator|%
literal|100
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|year
operator|%
literal|4
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|CalendarFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
name|cal
parameter_list|)
block|{
comment|//&
name|char
modifier|*
name|ss
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
init|=
literal|""
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|cal
operator|.
name|year
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|month
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|monthday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|cal
operator|.
name|yearday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|hour
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|minute
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|second
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|//ss<< cal.year<< "-"<< (u_int)cal.month<< "-"<< (u_int)cal.monthday<< " ("<< cal.yearday<< ") "<< (u_int)cal.hour<< ":"<< (u_int)cal.minute<< ":"<< (u_int)cal.second;
return|return
name|ss
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|CalendarFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
name|iso
parameter_list|)
block|{
comment|//&
name|char
modifier|*
name|ss
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
init|=
literal|""
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|iso
operator|.
name|year
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|week
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|weekday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|hour
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|minute
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|second
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|//ss<< iso.year<< "-"<< (u_int)iso.week<< "-"<< (u_int)iso.weekday<< (u_int)iso.hour<< ":"<< (u_int)iso.minute<< ":"<< (u_int)iso.second;
return|return
name|ss
return|;
block|}
end_function

begin_function
name|int
name|IsEqualCal
parameter_list|(
specifier|const
name|struct
name|calendar
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
name|actual
parameter_list|)
block|{
comment|//&&
if|if
condition|(
name|expected
operator|.
name|year
operator|==
name|actual
operator|.
name|year
operator|&&
operator|(
operator|!
name|expected
operator|.
name|yearday
operator|||
name|expected
operator|.
name|yearday
operator|==
name|actual
operator|.
name|yearday
operator|)
operator|&&
name|expected
operator|.
name|month
operator|==
name|actual
operator|.
name|month
operator|&&
name|expected
operator|.
name|monthday
operator|==
name|actual
operator|.
name|monthday
operator|&&
name|expected
operator|.
name|hour
operator|==
name|actual
operator|.
name|hour
operator|&&
name|expected
operator|.
name|minute
operator|==
name|actual
operator|.
name|minute
operator|&&
name|expected
operator|.
name|second
operator|==
name|actual
operator|.
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|CalendarFromCalToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|CalendarFromCalToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|int
name|IsEqualIso
parameter_list|(
specifier|const
name|struct
name|isodate
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
name|actual
parameter_list|)
block|{
comment|//&&
if|if
condition|(
name|expected
operator|.
name|year
operator|==
name|actual
operator|.
name|year
operator|&&
name|expected
operator|.
name|week
operator|==
name|actual
operator|.
name|week
operator|&&
name|expected
operator|.
name|weekday
operator|==
name|actual
operator|.
name|weekday
operator|&&
name|expected
operator|.
name|hour
operator|==
name|actual
operator|.
name|hour
operator|&&
name|expected
operator|.
name|minute
operator|==
name|actual
operator|.
name|minute
operator|&&
name|expected
operator|.
name|second
operator|==
name|actual
operator|.
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|CalendarFromIsoToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|CalendarFromIsoToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|DateFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
name|cal
parameter_list|)
block|{
comment|//&
name|char
modifier|*
name|ss
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
init|=
literal|""
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|cal
operator|.
name|year
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|month
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|.
name|monthday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|cal
operator|.
name|yearday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|ss
return|;
comment|//ss<< cal.year<< "-"<< (u_int)cal.month<< "-"<< (u_int)cal.monthday<< " ("<< cal.yearday<< ")";
block|}
end_function

begin_function
name|char
modifier|*
name|DateFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
name|iso
parameter_list|)
block|{
comment|//&
name|char
modifier|*
name|ss
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
init|=
literal|""
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|iso
operator|.
name|year
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|week
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|.
name|weekday
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ss
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|ss
return|;
comment|//ss<< iso.year<< "-"<< (u_int)iso.week<< "-"<< (u_int)iso.weekday;
block|}
end_function

begin_comment
comment|//boolean
end_comment

begin_function
name|int
name|IsEqualDateCal
parameter_list|(
specifier|const
name|struct
name|calendar
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
name|actual
parameter_list|)
block|{
comment|//&&
if|if
condition|(
name|expected
operator|.
name|year
operator|==
name|actual
operator|.
name|year
operator|&&
operator|(
operator|!
name|expected
operator|.
name|yearday
operator|||
name|expected
operator|.
name|yearday
operator|==
name|actual
operator|.
name|yearday
operator|)
operator|&&
name|expected
operator|.
name|month
operator|==
name|actual
operator|.
name|month
operator|&&
name|expected
operator|.
name|monthday
operator|==
name|actual
operator|.
name|monthday
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|DateFromCalToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|DateFromCalToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|//boolean
end_comment

begin_function
name|int
name|IsEqualDateIso
parameter_list|(
specifier|const
name|struct
name|isodate
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
name|actual
parameter_list|)
block|{
comment|//&&
if|if
condition|(
name|expected
operator|.
name|year
operator|==
name|actual
operator|.
name|year
operator|&&
name|expected
operator|.
name|week
operator|==
name|actual
operator|.
name|week
operator|&&
name|expected
operator|.
name|weekday
operator|==
name|actual
operator|.
name|weekday
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|DateFromIsoToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|DateFromIsoToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_comment
comment|// test cases
end_comment

begin_comment
comment|// ---------------------------------------------------------------------
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|real_month_table
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|60
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|// days in month, with one month wrap-around at both ends
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|real_month_days
index|[
literal|2
index|]
index|[
literal|14
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|31
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|31
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|// test the day/sec join& split ops, making sure that 32bit
end_comment

begin_comment
comment|// intermediate results would definitely overflow and the hi DWORD of
end_comment

begin_comment
comment|// the 'vint64' is definitely needed.
end_comment

begin_function
name|void
name|test_DaySplitMerge
parameter_list|()
block|{
name|int32
name|day
decl_stmt|,
name|sec
decl_stmt|;
for|for
control|(
name|day
operator|=
operator|-
literal|1000000
init|;
name|day
operator|<=
literal|1000000
condition|;
name|day
operator|+=
literal|100
control|)
block|{
for|for
control|(
name|sec
operator|=
operator|-
literal|100000
init|;
name|sec
operator|<=
literal|186400
condition|;
name|sec
operator|+=
literal|10000
control|)
block|{
name|vint64
name|merge
init|=
name|ntpcal_dayjoin
argument_list|(
name|day
argument_list|,
name|sec
argument_list|)
decl_stmt|;
name|ntpcal_split
name|split
init|=
name|ntpcal_daysplit
argument_list|(
operator|&
name|merge
argument_list|)
decl_stmt|;
name|int32
name|eday
init|=
name|day
decl_stmt|;
name|int32
name|esec
init|=
name|sec
decl_stmt|;
while|while
condition|(
name|esec
operator|>=
literal|86400
condition|)
block|{
name|eday
operator|+=
literal|1
expr_stmt|;
name|esec
operator|-=
literal|86400
expr_stmt|;
block|}
while|while
condition|(
name|esec
operator|<
literal|0
condition|)
block|{
name|eday
operator|-=
literal|1
expr_stmt|;
name|esec
operator|+=
literal|86400
expr_stmt|;
block|}
name|TEST_ASSERT_EQUAL
argument_list|(
name|eday
argument_list|,
name|split
operator|.
name|hi
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|esec
argument_list|,
name|split
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|test_SplitYearDays1
parameter_list|()
block|{
name|int32
name|eyd
decl_stmt|;
for|for
control|(
name|eyd
operator|=
operator|-
literal|1
init|;
name|eyd
operator|<=
literal|365
condition|;
name|eyd
operator|++
control|)
block|{
name|ntpcal_split
name|split
init|=
name|ntpcal_split_yeardays
argument_list|(
name|eyd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|lo
operator|>=
literal|0
operator|&&
name|split
operator|.
name|hi
operator|>=
literal|0
condition|)
block|{
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
literal|12
argument_list|,
name|split
operator|.
name|hi
argument_list|)
argument_list|)
expr_stmt|;
comment|//EXPECT_GT(12, split.hi);
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
name|real_month_days
index|[
literal|0
index|]
index|[
name|split
operator|.
name|hi
operator|+
literal|1
index|]
argument_list|,
name|split
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
comment|//EXPECT_GT(real_month_days[0][split.hi+1], split.lo);
name|int32
name|tyd
init|=
name|real_month_table
index|[
literal|0
index|]
index|[
name|split
operator|.
name|hi
index|]
operator|+
name|split
operator|.
name|lo
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|eyd
argument_list|,
name|tyd
argument_list|)
expr_stmt|;
block|}
else|else
name|TEST_ASSERT_TRUE
argument_list|(
name|eyd
operator|<
literal|0
operator|||
name|eyd
operator|>
literal|364
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_SplitYearDays2
parameter_list|()
block|{
name|int32
name|eyd
decl_stmt|;
for|for
control|(
name|eyd
operator|=
operator|-
literal|1
init|;
name|eyd
operator|<=
literal|366
condition|;
name|eyd
operator|++
control|)
block|{
name|ntpcal_split
name|split
init|=
name|ntpcal_split_yeardays
argument_list|(
name|eyd
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|lo
operator|>=
literal|0
operator|&&
name|split
operator|.
name|hi
operator|>=
literal|0
condition|)
block|{
comment|//TEST_ASSERT_TRUE(12> split.hi); //simpler version, works for basic types, doesn't work for complex structs
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
literal|12
argument_list|,
name|split
operator|.
name|hi
argument_list|)
argument_list|)
expr_stmt|;
comment|//EXPECT_GT(12, split.hi);
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
name|real_month_days
index|[
literal|1
index|]
index|[
name|split
operator|.
name|hi
operator|+
literal|1
index|]
argument_list|,
name|split
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
comment|//EXPECT_GT(real_month_days[1][split.hi+1], split.lo);
name|int32
name|tyd
init|=
name|real_month_table
index|[
literal|1
index|]
index|[
name|split
operator|.
name|hi
index|]
operator|+
name|split
operator|.
name|lo
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|eyd
argument_list|,
name|tyd
argument_list|)
expr_stmt|;
block|}
else|else
name|TEST_ASSERT_TRUE
argument_list|(
name|eyd
operator|<
literal|0
operator|||
name|eyd
operator|>
literal|365
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_RataDie1
parameter_list|()
block|{
name|int32
name|testDate
init|=
literal|1
decl_stmt|;
comment|// 0001-01-01 (proleptic date)
name|struct
name|calendar
name|expected
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|struct
name|calendar
name|actual
decl_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|actual
argument_list|,
name|testDate
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// check last day of february for first 10000 years
end_comment

begin_function
name|void
name|test_LeapYears1
parameter_list|()
block|{
name|struct
name|calendar
name|dateIn
decl_stmt|,
name|dateOut
decl_stmt|;
for|for
control|(
name|dateIn
operator|.
name|year
operator|=
literal|1
init|;
name|dateIn
operator|.
name|year
operator|<
literal|10000
condition|;
operator|++
name|dateIn
operator|.
name|year
control|)
block|{
name|dateIn
operator|.
name|month
operator|=
literal|2
expr_stmt|;
name|dateIn
operator|.
name|monthday
operator|=
literal|28
operator|+
name|leapdays
argument_list|(
name|dateIn
operator|.
name|year
argument_list|)
expr_stmt|;
name|dateIn
operator|.
name|yearday
operator|=
literal|31
operator|+
name|dateIn
operator|.
name|monthday
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|dateOut
argument_list|,
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|dateIn
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
name|dateIn
argument_list|,
name|dateOut
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// check first day of march for first 10000 years
end_comment

begin_function
name|void
name|test_LeapYears2
parameter_list|()
block|{
name|struct
name|calendar
name|dateIn
decl_stmt|,
name|dateOut
decl_stmt|;
for|for
control|(
name|dateIn
operator|.
name|year
operator|=
literal|1
init|;
name|dateIn
operator|.
name|year
operator|<
literal|10000
condition|;
operator|++
name|dateIn
operator|.
name|year
control|)
block|{
name|dateIn
operator|.
name|month
operator|=
literal|3
expr_stmt|;
name|dateIn
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|dateIn
operator|.
name|yearday
operator|=
literal|60
operator|+
name|leapdays
argument_list|(
name|dateIn
operator|.
name|year
argument_list|)
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|dateOut
argument_list|,
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|dateIn
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
name|dateIn
argument_list|,
name|dateOut
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Full roundtrip for 1601-01-01 to 2400-12-31
end_comment

begin_comment
comment|// checks sequence of rata die numbers and validates date output
end_comment

begin_comment
comment|// (since the input is all nominal days of the calendar in that range
end_comment

begin_comment
comment|// and the result of the inverse calculation must match the input no
end_comment

begin_comment
comment|// invalid output can occur.)
end_comment

begin_function
name|void
name|test_RoundTripDate
parameter_list|()
block|{
name|struct
name|calendar
name|truDate
decl_stmt|,
name|expDate
init|=
block|{
literal|1600
block|,
literal|0
block|,
literal|12
block|,
literal|31
block|}
decl_stmt|;
empty_stmt|;
name|int32
name|truRdn
decl_stmt|,
name|expRdn
init|=
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|expDate
argument_list|)
decl_stmt|;
name|int
name|leaps
decl_stmt|;
while|while
condition|(
name|expDate
operator|.
name|year
operator|<
literal|2400
condition|)
block|{
name|expDate
operator|.
name|year
operator|++
expr_stmt|;
name|expDate
operator|.
name|month
operator|=
literal|0
expr_stmt|;
name|expDate
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
name|leaps
operator|=
name|leapdays
argument_list|(
name|expDate
operator|.
name|year
argument_list|)
expr_stmt|;
while|while
condition|(
name|expDate
operator|.
name|month
operator|<
literal|12
condition|)
block|{
name|expDate
operator|.
name|month
operator|++
expr_stmt|;
name|expDate
operator|.
name|monthday
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|expDate
operator|.
name|monthday
operator|<
name|real_month_days
index|[
name|leaps
index|]
index|[
name|expDate
operator|.
name|month
index|]
condition|)
block|{
name|expDate
operator|.
name|monthday
operator|++
expr_stmt|;
name|expDate
operator|.
name|yearday
operator|++
expr_stmt|;
name|expRdn
operator|++
expr_stmt|;
name|truRdn
operator|=
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|expDate
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expRdn
argument_list|,
name|truRdn
argument_list|)
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|truDate
argument_list|,
name|truRdn
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
name|expDate
argument_list|,
name|truDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|// Roundtrip testing on calyearstart
end_comment

begin_function
name|void
name|test_RoundTripYearStart
parameter_list|()
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expys
decl_stmt|,
name|truys
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|30000000u
condition|;
name|ntp
operator|+=
literal|30000000u
control|)
block|{
name|truys
operator|=
name|calyearstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|month
operator|=
name|date
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expys
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expys
argument_list|,
name|truys
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Roundtrip testing on calymonthstart
end_comment

begin_function
name|void
name|test_RoundTripMonthStart
parameter_list|()
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expms
decl_stmt|,
name|trums
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|2000000u
condition|;
name|ntp
operator|+=
literal|2000000u
control|)
block|{
name|trums
operator|=
name|calmonthstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expms
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expms
argument_list|,
name|trums
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Roundtrip testing on calweekstart
end_comment

begin_function
name|void
name|test_RoundTripWeekStart
parameter_list|()
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expws
decl_stmt|,
name|truws
decl_stmt|;
name|struct
name|isodate
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|600000u
condition|;
name|ntp
operator|+=
literal|600000u
control|)
block|{
name|truws
operator|=
name|calweekstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|isocal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|date
operator|.
name|weekday
operator|=
literal|1
expr_stmt|;
name|expws
operator|=
name|isocal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expws
argument_list|,
name|truws
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Roundtrip testing on caldaystart
end_comment

begin_function
name|void
name|test_RoundTripDayStart
parameter_list|()
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expds
decl_stmt|,
name|truds
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|80000u
condition|;
name|ntp
operator|+=
literal|80000u
control|)
block|{
name|truds
operator|=
name|caldaystart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expds
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expds
argument_list|,
name|truds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

