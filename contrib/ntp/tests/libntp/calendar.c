begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/* test fail without this include, for some reason */
end_comment

begin_include
include|#
directive|include
file|"ntp_calendar.h"
end_include

begin_include
include|#
directive|include
file|"unity.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|static
name|int
name|leapdays
parameter_list|(
name|int
name|year
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isGT
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|second
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|leapdays
parameter_list|(
name|int
name|year
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|CalendarFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|cal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|CalendarFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|iso
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|IsEqualCal
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|IsEqualIso
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
modifier|*
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|DateFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|cal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|DateFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|iso
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|IsEqualDateCal
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|IsEqualDateIso
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
modifier|*
name|actual
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_DaySplitMerge
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SplitYearDays1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_SplitYearDays2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RataDie1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_LeapYears1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_LeapYears2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RoundTripDate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RoundTripYearStart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RoundTripMonthStart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RoundTripWeekStart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_RoundTripDayStart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_IsoCalYearsToWeeks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_IsoCalWeeksToYearStart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_IsoCalWeeksToYearEnd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|test_DaySecToDate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ---------------------------------------------------------------------  * test support stuff  * ---------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|isGT
parameter_list|(
name|int
name|first
parameter_list|,
name|int
name|second
parameter_list|)
block|{
if|if
condition|(
name|first
operator|>
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|int
name|leapdays
parameter_list|(
name|int
name|year
parameter_list|)
block|{
if|if
condition|(
name|year
operator|%
literal|400
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|year
operator|%
literal|100
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|year
operator|%
literal|4
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|CalendarFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|cal
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
literal|100
argument_list|,
literal|"%u-%02u-%02u (%u) %02u:%02u:%02u"
argument_list|,
name|cal
operator|->
name|year
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|month
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|monthday
argument_list|,
name|cal
operator|->
name|yearday
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|hour
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|minute
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|second
argument_list|)
expr_stmt|;
name|str
index|[
literal|99
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* paranoia rulez! */
return|return
name|str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|CalendarFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|iso
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
literal|100
argument_list|,
literal|"%u-W%02u-%02u %02u:%02u:%02u"
argument_list|,
name|iso
operator|->
name|year
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|week
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|weekday
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|hour
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|minute
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|second
argument_list|)
expr_stmt|;
name|str
index|[
literal|99
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* paranoia rulez! */
return|return
name|str
return|;
block|}
end_function

begin_function
name|int
name|IsEqualCal
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|actual
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|->
name|year
operator|==
name|actual
operator|->
name|year
operator|&&
operator|(
operator|!
name|expected
operator|->
name|yearday
operator|||
name|expected
operator|->
name|yearday
operator|==
name|actual
operator|->
name|yearday
operator|)
operator|&&
name|expected
operator|->
name|month
operator|==
name|actual
operator|->
name|month
operator|&&
name|expected
operator|->
name|monthday
operator|==
name|actual
operator|->
name|monthday
operator|&&
name|expected
operator|->
name|hour
operator|==
name|actual
operator|->
name|hour
operator|&&
name|expected
operator|->
name|minute
operator|==
name|actual
operator|->
name|minute
operator|&&
name|expected
operator|->
name|second
operator|==
name|actual
operator|->
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|CalendarFromCalToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|CalendarFromCalToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|int
name|IsEqualIso
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
modifier|*
name|actual
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|->
name|year
operator|==
name|actual
operator|->
name|year
operator|&&
name|expected
operator|->
name|week
operator|==
name|actual
operator|->
name|week
operator|&&
name|expected
operator|->
name|weekday
operator|==
name|actual
operator|->
name|weekday
operator|&&
name|expected
operator|->
name|hour
operator|==
name|actual
operator|->
name|hour
operator|&&
name|expected
operator|->
name|minute
operator|==
name|actual
operator|->
name|minute
operator|&&
name|expected
operator|->
name|second
operator|==
name|actual
operator|->
name|second
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|CalendarFromIsoToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|CalendarFromIsoToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|DateFromCalToString
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|cal
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
literal|100
argument_list|,
literal|"%u-%02u-%02u (%u)"
argument_list|,
name|cal
operator|->
name|year
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|month
argument_list|,
operator|(
name|u_int
operator|)
name|cal
operator|->
name|monthday
argument_list|,
name|cal
operator|->
name|yearday
argument_list|)
expr_stmt|;
name|str
index|[
literal|99
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* paranoia rulez! */
return|return
name|str
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|DateFromIsoToString
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|iso
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|100
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
literal|100
argument_list|,
literal|"%u-W%02u-%02u"
argument_list|,
name|iso
operator|->
name|year
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|week
argument_list|,
operator|(
name|u_int
operator|)
name|iso
operator|->
name|weekday
argument_list|)
expr_stmt|;
name|str
index|[
literal|99
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* paranoia rulez! */
return|return
name|str
return|;
block|}
end_function

begin_function
name|int
comment|/*BOOL*/
name|IsEqualDateCal
parameter_list|(
specifier|const
name|struct
name|calendar
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|calendar
modifier|*
name|actual
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|->
name|year
operator|==
name|actual
operator|->
name|year
operator|&&
operator|(
operator|!
name|expected
operator|->
name|yearday
operator|||
name|expected
operator|->
name|yearday
operator|==
name|actual
operator|->
name|yearday
operator|)
operator|&&
name|expected
operator|->
name|month
operator|==
name|actual
operator|->
name|month
operator|&&
name|expected
operator|->
name|monthday
operator|==
name|actual
operator|->
name|monthday
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|DateFromCalToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|DateFromCalToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
name|int
comment|/*BOOL*/
name|IsEqualDateIso
parameter_list|(
specifier|const
name|struct
name|isodate
modifier|*
name|expected
parameter_list|,
specifier|const
name|struct
name|isodate
modifier|*
name|actual
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|->
name|year
operator|==
name|actual
operator|->
name|year
operator|&&
name|expected
operator|->
name|week
operator|==
name|actual
operator|->
name|week
operator|&&
name|expected
operator|->
name|weekday
operator|==
name|actual
operator|->
name|weekday
condition|)
block|{
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"expected: %s but was %s"
argument_list|,
name|DateFromIsoToString
argument_list|(
name|expected
argument_list|)
argument_list|,
name|DateFromIsoToString
argument_list|(
name|actual
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * ---------------------------------------------------------------------  * test cases  * ---------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* days before month, with a full-year pad at the upper end */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|real_month_table
index|[
literal|2
index|]
index|[
literal|13
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|0
block|,
literal|31
block|,
literal|60
block|,
literal|91
block|,
literal|121
block|,
literal|152
block|,
literal|182
block|,
literal|213
block|,
literal|244
block|,
literal|274
block|,
literal|305
block|,
literal|335
block|,
literal|366
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* days in month, with one month wrap-around at both ends */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|real_month_days
index|[
literal|2
index|]
index|[
literal|14
index|]
init|=
block|{
comment|/* -*- table for regular years -*- */
block|{
literal|31
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|}
block|,
comment|/* -*- table for leap years -*- */
block|{
literal|31
block|,
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test the day/sec join& split ops, making sure that 32bit  * intermediate results would definitely overflow and the hi DWORD of  * the 'vint64' is definitely needed.  */
end_comment

begin_function
name|void
name|test_DaySplitMerge
parameter_list|(
name|void
parameter_list|)
block|{
name|int32
name|day
decl_stmt|,
name|sec
decl_stmt|;
for|for
control|(
name|day
operator|=
operator|-
literal|1000000
init|;
name|day
operator|<=
literal|1000000
condition|;
name|day
operator|+=
literal|100
control|)
block|{
for|for
control|(
name|sec
operator|=
operator|-
literal|100000
init|;
name|sec
operator|<=
literal|186400
condition|;
name|sec
operator|+=
literal|10000
control|)
block|{
name|vint64
name|merge
decl_stmt|;
name|ntpcal_split
name|split
decl_stmt|;
name|int32
name|eday
decl_stmt|;
name|int32
name|esec
decl_stmt|;
name|merge
operator|=
name|ntpcal_dayjoin
argument_list|(
name|day
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|split
operator|=
name|ntpcal_daysplit
argument_list|(
operator|&
name|merge
argument_list|)
expr_stmt|;
name|eday
operator|=
name|day
expr_stmt|;
name|esec
operator|=
name|sec
expr_stmt|;
while|while
condition|(
name|esec
operator|>=
literal|86400
condition|)
block|{
name|eday
operator|+=
literal|1
expr_stmt|;
name|esec
operator|-=
literal|86400
expr_stmt|;
block|}
while|while
condition|(
name|esec
operator|<
literal|0
condition|)
block|{
name|eday
operator|-=
literal|1
expr_stmt|;
name|esec
operator|+=
literal|86400
expr_stmt|;
block|}
name|TEST_ASSERT_EQUAL
argument_list|(
name|eday
argument_list|,
name|split
operator|.
name|hi
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|esec
argument_list|,
name|split
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|test_SplitYearDays1
parameter_list|(
name|void
parameter_list|)
block|{
name|int32
name|eyd
decl_stmt|;
for|for
control|(
name|eyd
operator|=
operator|-
literal|1
init|;
name|eyd
operator|<=
literal|365
condition|;
name|eyd
operator|++
control|)
block|{
name|ntpcal_split
name|split
init|=
name|ntpcal_split_yeardays
argument_list|(
name|eyd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|lo
operator|>=
literal|0
operator|&&
name|split
operator|.
name|hi
operator|>=
literal|0
condition|)
block|{
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
literal|12
argument_list|,
name|split
operator|.
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
name|real_month_days
index|[
literal|0
index|]
index|[
name|split
operator|.
name|hi
operator|+
literal|1
index|]
argument_list|,
name|split
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|int32
name|tyd
init|=
name|real_month_table
index|[
literal|0
index|]
index|[
name|split
operator|.
name|hi
index|]
operator|+
name|split
operator|.
name|lo
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|eyd
argument_list|,
name|tyd
argument_list|)
expr_stmt|;
block|}
else|else
name|TEST_ASSERT_TRUE
argument_list|(
name|eyd
operator|<
literal|0
operator|||
name|eyd
operator|>
literal|364
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_SplitYearDays2
parameter_list|(
name|void
parameter_list|)
block|{
name|int32
name|eyd
decl_stmt|;
for|for
control|(
name|eyd
operator|=
operator|-
literal|1
init|;
name|eyd
operator|<=
literal|366
condition|;
name|eyd
operator|++
control|)
block|{
name|ntpcal_split
name|split
init|=
name|ntpcal_split_yeardays
argument_list|(
name|eyd
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|lo
operator|>=
literal|0
operator|&&
name|split
operator|.
name|hi
operator|>=
literal|0
condition|)
block|{
comment|/* basic checks do not work on compunds :( */
comment|/* would like: TEST_ASSERT_TRUE(12> split.hi); */
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
literal|12
argument_list|,
name|split
operator|.
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|isGT
argument_list|(
name|real_month_days
index|[
literal|1
index|]
index|[
name|split
operator|.
name|hi
operator|+
literal|1
index|]
argument_list|,
name|split
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|int32
name|tyd
init|=
name|real_month_table
index|[
literal|1
index|]
index|[
name|split
operator|.
name|hi
index|]
operator|+
name|split
operator|.
name|lo
decl_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|eyd
argument_list|,
name|tyd
argument_list|)
expr_stmt|;
block|}
else|else
name|TEST_ASSERT_TRUE
argument_list|(
name|eyd
operator|<
literal|0
operator|||
name|eyd
operator|>
literal|365
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_RataDie1
parameter_list|(
name|void
parameter_list|)
block|{
name|int32
name|testDate
init|=
literal|1
decl_stmt|;
comment|/* 0001-01-01 (proleptic date) */
name|struct
name|calendar
name|expected
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|struct
name|calendar
name|actual
decl_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|actual
argument_list|,
name|testDate
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
operator|&
name|expected
argument_list|,
operator|&
name|actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check last day of february for first 10000 years */
end_comment

begin_function
name|void
name|test_LeapYears1
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|calendar
name|dateIn
decl_stmt|,
name|dateOut
decl_stmt|;
for|for
control|(
name|dateIn
operator|.
name|year
operator|=
literal|1
init|;
name|dateIn
operator|.
name|year
operator|<
literal|10000
condition|;
operator|++
name|dateIn
operator|.
name|year
control|)
block|{
name|dateIn
operator|.
name|month
operator|=
literal|2
expr_stmt|;
name|dateIn
operator|.
name|monthday
operator|=
literal|28
operator|+
name|leapdays
argument_list|(
name|dateIn
operator|.
name|year
argument_list|)
expr_stmt|;
name|dateIn
operator|.
name|yearday
operator|=
literal|31
operator|+
name|dateIn
operator|.
name|monthday
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|dateOut
argument_list|,
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|dateIn
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
operator|&
name|dateIn
argument_list|,
operator|&
name|dateOut
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* check first day of march for first 10000 years */
end_comment

begin_function
name|void
name|test_LeapYears2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|calendar
name|dateIn
decl_stmt|,
name|dateOut
decl_stmt|;
for|for
control|(
name|dateIn
operator|.
name|year
operator|=
literal|1
init|;
name|dateIn
operator|.
name|year
operator|<
literal|10000
condition|;
operator|++
name|dateIn
operator|.
name|year
control|)
block|{
name|dateIn
operator|.
name|month
operator|=
literal|3
expr_stmt|;
name|dateIn
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|dateIn
operator|.
name|yearday
operator|=
literal|60
operator|+
name|leapdays
argument_list|(
name|dateIn
operator|.
name|year
argument_list|)
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|dateOut
argument_list|,
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|dateIn
argument_list|)
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
operator|&
name|dateIn
argument_list|,
operator|&
name|dateOut
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Full roundtrip from 1601-01-01 to 2400-12-31  * checks sequence of rata die numbers and validates date output  * (since the input is all nominal days of the calendar in that range  * and the result of the inverse calculation must match the input no  * invalid output can occur.)  */
end_comment

begin_function
name|void
name|test_RoundTripDate
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|calendar
name|truDate
decl_stmt|,
name|expDate
init|=
block|{
literal|1600
block|,
literal|0
block|,
literal|12
block|,
literal|31
block|}
decl_stmt|;
empty_stmt|;
name|int
name|leaps
decl_stmt|;
name|int32
name|truRdn
decl_stmt|,
name|expRdn
init|=
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|expDate
argument_list|)
decl_stmt|;
while|while
condition|(
name|expDate
operator|.
name|year
operator|<
literal|2400
condition|)
block|{
name|expDate
operator|.
name|year
operator|++
expr_stmt|;
name|expDate
operator|.
name|month
operator|=
literal|0
expr_stmt|;
name|expDate
operator|.
name|yearday
operator|=
literal|0
expr_stmt|;
name|leaps
operator|=
name|leapdays
argument_list|(
name|expDate
operator|.
name|year
argument_list|)
expr_stmt|;
while|while
condition|(
name|expDate
operator|.
name|month
operator|<
literal|12
condition|)
block|{
name|expDate
operator|.
name|month
operator|++
expr_stmt|;
name|expDate
operator|.
name|monthday
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|expDate
operator|.
name|monthday
operator|<
name|real_month_days
index|[
name|leaps
index|]
index|[
name|expDate
operator|.
name|month
index|]
condition|)
block|{
name|expDate
operator|.
name|monthday
operator|++
expr_stmt|;
name|expDate
operator|.
name|yearday
operator|++
expr_stmt|;
name|expRdn
operator|++
expr_stmt|;
name|truRdn
operator|=
name|ntpcal_date_to_rd
argument_list|(
operator|&
name|expDate
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expRdn
argument_list|,
name|truRdn
argument_list|)
expr_stmt|;
name|ntpcal_rd_to_date
argument_list|(
operator|&
name|truDate
argument_list|,
name|truRdn
argument_list|)
expr_stmt|;
name|TEST_ASSERT_TRUE
argument_list|(
name|IsEqualDateCal
argument_list|(
operator|&
name|expDate
argument_list|,
operator|&
name|truDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Roundtrip testing on calyearstart */
end_comment

begin_function
name|void
name|test_RoundTripYearStart
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expys
decl_stmt|,
name|truys
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|30000000u
condition|;
name|ntp
operator|+=
literal|30000000u
control|)
block|{
name|truys
operator|=
name|calyearstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|month
operator|=
name|date
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expys
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expys
argument_list|,
name|truys
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Roundtrip testing on calmonthstart */
end_comment

begin_function
name|void
name|test_RoundTripMonthStart
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expms
decl_stmt|,
name|trums
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|2000000u
condition|;
name|ntp
operator|+=
literal|2000000u
control|)
block|{
name|trums
operator|=
name|calmonthstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|monthday
operator|=
literal|1
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expms
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expms
argument_list|,
name|trums
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Roundtrip testing on calweekstart */
end_comment

begin_function
name|void
name|test_RoundTripWeekStart
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expws
decl_stmt|,
name|truws
decl_stmt|;
name|struct
name|isodate
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|600000u
condition|;
name|ntp
operator|+=
literal|600000u
control|)
block|{
name|truws
operator|=
name|calweekstart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|isocal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|date
operator|.
name|weekday
operator|=
literal|1
expr_stmt|;
name|expws
operator|=
name|isocal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expws
argument_list|,
name|truws
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Roundtrip testing on caldaystart */
end_comment

begin_function
name|void
name|test_RoundTripDayStart
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|time_t
name|pivot
init|=
literal|0
decl_stmt|;
name|u_int32
name|ntp
decl_stmt|,
name|expds
decl_stmt|,
name|truds
decl_stmt|;
name|struct
name|calendar
name|date
decl_stmt|;
for|for
control|(
name|ntp
operator|=
literal|0
init|;
name|ntp
operator|<
literal|0xFFFFFFFFu
operator|-
literal|80000u
condition|;
name|ntp
operator|+=
literal|80000u
control|)
block|{
name|truds
operator|=
name|caldaystart
argument_list|(
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|ntpcal_ntp_to_date
argument_list|(
operator|&
name|date
argument_list|,
name|ntp
argument_list|,
operator|&
name|pivot
argument_list|)
expr_stmt|;
name|date
operator|.
name|hour
operator|=
name|date
operator|.
name|minute
operator|=
name|date
operator|.
name|second
operator|=
literal|0
expr_stmt|;
name|expds
operator|=
name|ntpcal_date_to_ntp
argument_list|(
operator|&
name|date
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|expds
argument_list|,
name|truds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------  * ISO8601 week calendar internals  *  * The ISO8601 week calendar implementation is simple in the terms of  * the math involved, but the implementation of the calculations must  * take care of a few things like overflow, floor division, and sign  * corrections.  *  * Most of the functions are straight forward, but converting from years  * to weeks and from weeks to years warrants some extra tests. These use  * an independent reference implementation of the conversion from years  * to weeks.  * ---------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* helper / reference implementation for the first week of year in the  * ISO8601 week calendar. This is based on the reference definition of  * the ISO week calendar start: The Monday closest to January,1st of the  * corresponding year in the Gregorian calendar.  */
end_comment

begin_function
specifier|static
name|int32_t
name|refimpl_WeeksInIsoYears
parameter_list|(
name|int32_t
name|years
parameter_list|)
block|{
name|int32_t
name|days
decl_stmt|,
name|weeks
decl_stmt|;
name|days
operator|=
name|ntpcal_weekday_close
argument_list|(
name|ntpcal_days_in_years
argument_list|(
name|years
argument_list|)
operator|+
literal|1
argument_list|,
name|CAL_MONDAY
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* the weekday functions operate on RDN, while we want elapsed 	 * units here -- we have to add / sub 1 in the midlle / at the 	 * end of the operation that gets us the first day of the ISO 	 * week calendar day. 	 */
name|weeks
operator|=
name|days
operator|/
literal|7
expr_stmt|;
name|days
operator|=
name|days
operator|%
literal|7
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|0
argument_list|,
name|days
argument_list|)
expr_stmt|;
comment|/* paranoia check... */
return|return
name|weeks
return|;
block|}
end_function

begin_comment
comment|/* The next tests loop over 5000yrs, but should still be very fast. If  * they are not, the calendar needs a better implementation...  */
end_comment

begin_function
name|void
name|test_IsoCalYearsToWeeks
parameter_list|(
name|void
parameter_list|)
block|{
name|int32_t
name|years
decl_stmt|;
name|int32_t
name|wref
decl_stmt|,
name|wcal
decl_stmt|;
for|for
control|(
name|years
operator|=
operator|-
literal|1000
init|;
name|years
operator|<
literal|4000
condition|;
operator|++
name|years
control|)
block|{
comment|/* get number of weeks before years (reference) */
name|wref
operator|=
name|refimpl_WeeksInIsoYears
argument_list|(
name|years
argument_list|)
expr_stmt|;
comment|/* get number of weeks before years (object-under-test) */
name|wcal
operator|=
name|isocal_weeks_in_years
argument_list|(
name|years
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
name|wref
argument_list|,
name|wcal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_IsoCalWeeksToYearStart
parameter_list|(
name|void
parameter_list|)
block|{
name|int32_t
name|years
decl_stmt|;
name|int32_t
name|wref
decl_stmt|;
name|ntpcal_split
name|ysplit
decl_stmt|;
for|for
control|(
name|years
operator|=
operator|-
literal|1000
init|;
name|years
operator|<
literal|4000
condition|;
operator|++
name|years
control|)
block|{
comment|/* get number of weeks before years (reference) */
name|wref
operator|=
name|refimpl_WeeksInIsoYears
argument_list|(
name|years
argument_list|)
expr_stmt|;
comment|/* reverse split */
name|ysplit
operator|=
name|isocal_split_eraweeks
argument_list|(
name|wref
argument_list|)
expr_stmt|;
comment|/* check invariants: same year, week 0 */
name|TEST_ASSERT_EQUAL
argument_list|(
name|years
argument_list|,
name|ysplit
operator|.
name|hi
argument_list|)
expr_stmt|;
name|TEST_ASSERT_EQUAL
argument_list|(
literal|0
argument_list|,
name|ysplit
operator|.
name|lo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_IsoCalWeeksToYearEnd
parameter_list|(
name|void
parameter_list|)
block|{
name|int32_t
name|years
decl_stmt|;
name|int32_t
name|wref
decl_stmt|;
name|ntpcal_split
name|ysplit
decl_stmt|;
for|for
control|(
name|years
operator|=
operator|-
literal|1000
init|;
name|years
operator|<
literal|4000
condition|;
operator|++
name|years
control|)
block|{
comment|/* get last week of previous year */
name|wref
operator|=
name|refimpl_WeeksInIsoYears
argument_list|(
name|years
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* reverse split */
name|ysplit
operator|=
name|isocal_split_eraweeks
argument_list|(
name|wref
argument_list|)
expr_stmt|;
comment|/* check invariants: previous year, week 51 or 52 */
name|TEST_ASSERT_EQUAL
argument_list|(
name|years
operator|-
literal|1
argument_list|,
name|ysplit
operator|.
name|hi
argument_list|)
expr_stmt|;
name|TEST_ASSERT
argument_list|(
name|ysplit
operator|.
name|lo
operator|==
literal|51
operator|||
name|ysplit
operator|.
name|lo
operator|==
literal|52
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|test_DaySecToDate
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|calendar
name|cal
decl_stmt|;
name|int32_t
name|days
decl_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
operator|-
literal|86400
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
operator|-
literal|1
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|0
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|0
operator|&&
name|cal
operator|.
name|second
operator|==
literal|0
operator|)
argument_list|,
literal|"failed for -86400"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
operator|-
literal|86399
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
operator|-
literal|1
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|0
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|0
operator|&&
name|cal
operator|.
name|second
operator|==
literal|1
operator|)
argument_list|,
literal|"failed for -86399"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
operator|-
literal|1
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|23
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|59
operator|&&
name|cal
operator|.
name|second
operator|==
literal|59
operator|)
argument_list|,
literal|"failed for -1"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
literal|0
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|0
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|0
operator|&&
name|cal
operator|.
name|second
operator|==
literal|0
operator|)
argument_list|,
literal|"failed for 0"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
literal|0
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|0
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|0
operator|&&
name|cal
operator|.
name|second
operator|==
literal|1
operator|)
argument_list|,
literal|"failed for 1"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
literal|86399
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
literal|0
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|23
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|59
operator|&&
name|cal
operator|.
name|second
operator|==
literal|59
operator|)
argument_list|,
literal|"failed for 86399"
argument_list|)
expr_stmt|;
name|days
operator|=
name|ntpcal_daysec_to_date
argument_list|(
operator|&
name|cal
argument_list|,
literal|86400
argument_list|)
expr_stmt|;
name|TEST_ASSERT_MESSAGE
argument_list|(
operator|(
name|days
operator|==
literal|1
operator|&&
name|cal
operator|.
name|hour
operator|==
literal|0
operator|&&
name|cal
operator|.
name|minute
operator|==
literal|0
operator|&&
name|cal
operator|.
name|second
operator|==
literal|0
operator|)
argument_list|,
literal|"failed for 86400"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

