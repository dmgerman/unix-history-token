begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tg.c generate WWV or IRIG signals for test  */
end_comment

begin_comment
comment|/*  * This program can generate audio signals that simulate the WWV/H  * broadcast timecode. Alternatively, it can generate the IRIG-B  * timecode commonly used to synchronize laboratory equipment. It is  * intended to test the WWV/H driver (refclock_wwv.c) and the IRIG  * driver (refclock_irig.c) in the NTP driver collection.  *  * Besides testing the drivers themselves, this program can be used to  * synchronize remote machines over audio transmission lines or program  * feeds. The program reads the time on the local machine and sets the  * initial epoch of the signal generator within one millisecond.  * Alernatively, the initial epoch can be set to an arbitrary time. This  * is useful when searching for bugs and testing for correct response to  * a leap second in UTC. Note however, the ultimate accuracy is limited  * by the intrinsic frequency error of the codec sample clock, which can  # reach well over 100 PPM.  *  * The default is to route generated signals to the line output  * jack; the s option on the command line routes these signals to the  * internal speaker as well. The v option controls the speaker volume  * over the range 0-255. The signal generator by default uses WWV  * format; the h option switches to WWVH format and the i option  * switches to IRIG-B format.  *  * Once started the program runs continuously. The default initial epoch  * for the signal generator is read from the computer system clock when  * the program starts. The y option specifies an alternate epoch using a  * string yydddhhmmss, where yy is the year of century, ddd the day of  * year, hh the hour of day and mm the minute of hour. For instance,  * 1946Z on 1 January 2006 is 060011946. The l option lights the leap  * warning bit in the WWV/H timecode, so is handy to check for correct  * behavior at the next leap second epoch. The remaining options are  * specified below under the Parse Options heading. Most of these are  * for testing.  *  * During operation the program displays the WWV/H timecode (9 digits)  * or IRIG timecode (20 digits) as each new string is constructed. The  * display is followed by the BCD binary bits as transmitted. Note that  * the transmissionorder is low-order first as the frame is processed  * left to right. For WWV/H The leap warning L preceeds the first bit.  * For IRIG the on-time marker M preceeds the first (units) bit, so its  * code is delayed one bit and the next digit (tens) needs only three  * bits.  *  * The program has been tested with the Sun Blade 1500 running Solaris  * 10, but not yet with other machines. It uses no special features and  * should be readily portable to other hardware and operating systems.  *  * $Log: tg.c,v $  * Revision 1.28  2007/02/12 23:57:45  dmw  * v0.23 2007-02-12 dmw:  * - Changed statistics to include calculated error  *   of frequency, based on number of added or removed  *   cycles over time.  *  * Revision 1.27  2007/02/09 02:28:59  dmw  * v0.22 2007-02-08 dmw:  * - Changed default for rate correction to "enabled", "-j" switch now disables.  * - Adjusted help message accordingly.  * - Added "2007" to modifications note at end of help message.  *  * Revision 1.26  2007/02/08 03:36:17  dmw  * v0.21 2007-02-07 dmw:  * - adjusted strings for shorten and lengthen to make  *   fit on smaller screen.  *  * Revision 1.25  2007/02/01 06:08:09  dmw  * v0.20 2007-02-01 dmw:  * - Added periodic display of running time along with legend on IRIG-B, allows tracking how  *   close IRIG output is to actual clock time.  *  * Revision 1.24  2007/01/31 19:24:11  dmw  * v0.19 2007-01-31 dmw:  * - Added tracking of how many seconds have been adjusted,  *   how many cycles added (actually in milliseconds), how  *   many cycles removed, print periodically if verbose is  *   active.  * - Corrected lack of lengthen or shorten of minute& hour  *   pulses for WWV format.  *  * Revision 1.23  2007/01/13 07:09:12  dmw  * v0.18 2007-01-13 dmw:  * - added -k option, which allows force of long or short  *   cycles, to test against IRIG-B decoder.  *  * Revision 1.22  2007/01/08 16:27:23  dmw  * v0.17 2007-01-08 dmw:  * - Changed -j option to **enable** rate correction, not disable.  *  * Revision 1.21  2007/01/08 06:22:36  dmw  * v0.17 2007-01-08 dmw:  * - Run stability check versus ongoing system clock (assume NTP correction)  *   and adjust time code rate to try to correct, if gets too far out of sync.  *   Disable this algorithm with -j option.  *  * Revision 1.20  2006/12/19 04:59:04  dmw  * v0.16 2006-12-18 dmw  * - Corrected print of setting of output frequency, always  *   showed 8000 samples/sec, now as specified on command line.  * - Modified to reflect new employer Norscan.  *  * Revision 1.19  2006/12/19 03:45:38  dmw  * v0.15 2006-12-18 dmw:  * - Added count of number of seconds to output then exit,  *   default zero for forever.  *  * Revision 1.18  2006/12/18 05:43:36  dmw  * v0.14 2006-12-17 dmw:  * - Corrected WWV(H) signal to leave "tick" sound off of 29th and 59th second of minute.  * - Adjusted verbose output format for WWV(H).  *  * Revision 1.17  2006/12/18 02:31:33  dmw  * v0.13 2006-12-17 dmw:  * - Put SPARC code back in, hopefully will work, but I don't have  *   a SPARC to try it on...  * - Reworked Verbose mode, different flag to initiate (x not v)  *   and actually implement turn off of verbosity when this flag used.  * - Re-claimed v flag for output level.  * - Note that you must define OSS_MODS to get OSS to compile,  *   otherwise will expect to compile using old SPARC options, as  *   it used to be.  *  * Revision 1.16  2006/10/26 19:08:43  dmw  * v0.12 2006-10-26 dmw:  * - Reversed output binary dump for IRIG, makes it easier to read the numbers.  *  * Revision 1.15  2006/10/24 15:57:09  dmw  * v0.11 2006-10-24 dmw:  * - another tweak.  *  * Revision 1.14  2006/10/24 15:55:53  dmw  * v0.11 2006-10-24 dmw:  * - Curses a fix to the fix to the fix of the usaeg.  *  * Revision 1.13  2006/10/24 15:53:25  dmw  * v0.11 (still) 2006-10-24 dmw:  * - Messed with usage message that's all.  *  * Revision 1.12  2006/10/24 15:50:05  dmw  * v0.11 2006-10-24 dmw:  * - oops, needed to note "hours" in usage of that offset.  *  * Revision 1.11  2006/10/24 15:49:09  dmw  * v0.11 2006-10-24 dmw:  * - Added ability to offset actual time sent, from the UTC time  *   as per the computer.  *  * Revision 1.10  2006/10/24 03:25:55  dmw  * v0.10 2006-10-23 dmw:  * - Corrected polarity of correction of offset when going into or out of DST.  * - Ensure that zero offset is always positive (pet peeve).  *  * Revision 1.9  2006/10/24 00:00:35  dmw  * v0.9 2006-10-23 dmw:  * - Shift time offset when DST in or out.  *  * Revision 1.8  2006/10/23 23:49:28  dmw  * v0.8 2006-10-23 dmw:  * - made offset of zero default positive.  *  * Revision 1.7  2006/10/23 23:44:13  dmw  * v0.7 2006-10-23 dmw:  * - Added unmodulated and inverted unmodulated output.  *  * Revision 1.6  2006/10/23 18:10:37  dmw  * v0.6 2006-10-23 dmw:  * - Cleaned up usage message.  * - Require at least one option, or prints usage message and exits.  *  * Revision 1.5  2006/10/23 16:58:10  dmw  * v0.5 2006-10-23 dmw:  * - Finally added a usage message.  * - Added leap second pending and DST change pending into IEEE 1344.  * - Default code type is now IRIG-B with IEEE 1344.  *  * Revision 1.4  2006/10/23 03:27:25  dmw  * v0.4 2006-10-22 dmw:  * - Added leap second addition and deletion.  * - Added DST changing forward and backward.  * - Changed date specification to more conventional year, month, and day of month  *   (rather than day of year).  *  * Revision 1.3  2006/10/22 21:04:12  dmw  * v0.2 2006-10-22 dmw:  * - Corrected format of legend line.  *  * Revision 1.2  2006/10/22 21:01:07  dmw  * v0.1 2006-10-22 dmw:  * - Added some more verbose output (as is my style)  * - Corrected frame format - there were markers in the  *   middle of frames, now correctly as "zero" bits.  * - Added header line to show fields of output.  * - Added straight binary seconds, were not implemented  *   before.  * - Added IEEE 1344 with parity.  *  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|VERSION
end_undef

begin_comment
comment|/* avoid conflict below */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SOUNDCARD_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_AUDIOIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/audioio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/audio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_comment
comment|/* for strlcat(), strlcpy() */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|VERSION
value|(0)
end_define

begin_define
define|#
directive|define
name|ISSUE
value|(23)
end_define

begin_define
define|#
directive|define
name|ISSUE_DATE
value|"2007-02-12"
end_define

begin_define
define|#
directive|define
name|SECOND
value|(8000)
end_define

begin_comment
comment|/* one second of 125-us samples */
end_comment

begin_define
define|#
directive|define
name|BUFLNG
value|(400)
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|"/dev/audio"
end_define

begin_comment
comment|/* default audio device */
end_comment

begin_define
define|#
directive|define
name|WWV
value|(0)
end_define

begin_comment
comment|/* WWV encoder */
end_comment

begin_define
define|#
directive|define
name|IRIG
value|(1)
end_define

begin_comment
comment|/* IRIG-B encoder */
end_comment

begin_define
define|#
directive|define
name|OFF
value|(0)
end_define

begin_comment
comment|/* zero amplitude */
end_comment

begin_define
define|#
directive|define
name|LOW
value|(1)
end_define

begin_comment
comment|/* low amplitude */
end_comment

begin_define
define|#
directive|define
name|HIGH
value|(2)
end_define

begin_comment
comment|/* high amplitude */
end_comment

begin_define
define|#
directive|define
name|DATA0
value|(200)
end_define

begin_comment
comment|/* WWV/H 0 pulse */
end_comment

begin_define
define|#
directive|define
name|DATA1
value|(500)
end_define

begin_comment
comment|/* WWV/H 1 pulse */
end_comment

begin_define
define|#
directive|define
name|PI
value|(800)
end_define

begin_comment
comment|/* WWV/H PI pulse */
end_comment

begin_define
define|#
directive|define
name|M2
value|(2)
end_define

begin_comment
comment|/* IRIG 0 pulse */
end_comment

begin_define
define|#
directive|define
name|M5
value|(5)
end_define

begin_comment
comment|/* IRIG 1 pulse */
end_comment

begin_define
define|#
directive|define
name|M8
value|(8)
end_define

begin_comment
comment|/* IRIG PI pulse */
end_comment

begin_define
define|#
directive|define
name|NUL
value|(0)
end_define

begin_define
define|#
directive|define
name|SECONDS_PER_MINUTE
value|(60)
end_define

begin_define
define|#
directive|define
name|SECONDS_PER_HOUR
value|(3600)
end_define

begin_define
define|#
directive|define
name|OUTPUT_DATA_STRING_LENGTH
value|(200)
end_define

begin_comment
comment|/* Attempt at unmodulated - "high" */
end_comment

begin_decl_stmt
name|int
name|u6000
index|[]
init|=
block|{
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/*  0- 9 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 10-19 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 20-29 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 30-39 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 40-49 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 50-59 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
comment|/* 60-69 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|247
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 70-79 */
end_comment

begin_comment
comment|/* Attempt at unmodulated - "low" */
end_comment

begin_decl_stmt
name|int
name|u3000
index|[]
init|=
block|{
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/*  0- 9 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 10-19 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 20-29 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 30-39 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 40-49 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 50-59 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
comment|/* 60-69 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|119
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 70-79 */
end_comment

begin_comment
comment|/*  * Companded sine table amplitude 3000 units  */
end_comment

begin_decl_stmt
name|int
name|c3000
index|[]
init|=
block|{
literal|1
block|,
literal|48
block|,
literal|63
block|,
literal|70
block|,
literal|78
block|,
literal|82
block|,
literal|85
block|,
literal|89
block|,
literal|92
block|,
literal|94
block|,
comment|/* 0-9 */
literal|96
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|103
block|,
literal|103
block|,
comment|/* 10-19 */
literal|103
block|,
literal|103
block|,
literal|103
block|,
literal|103
block|,
literal|102
block|,
literal|101
block|,
literal|101
block|,
literal|100
block|,
literal|99
block|,
literal|98
block|,
comment|/* 20-29 */
literal|96
block|,
literal|94
block|,
literal|92
block|,
literal|89
block|,
literal|85
block|,
literal|82
block|,
literal|78
block|,
literal|70
block|,
literal|63
block|,
literal|48
block|,
comment|/* 30-39 */
literal|129
block|,
literal|176
block|,
literal|191
block|,
literal|198
block|,
literal|206
block|,
literal|210
block|,
literal|213
block|,
literal|217
block|,
literal|220
block|,
literal|222
block|,
comment|/* 40-49 */
literal|224
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|231
block|,
literal|231
block|,
comment|/* 50-59 */
literal|231
block|,
literal|231
block|,
literal|231
block|,
literal|231
block|,
literal|230
block|,
literal|229
block|,
literal|229
block|,
literal|228
block|,
literal|227
block|,
literal|226
block|,
comment|/* 60-69 */
literal|224
block|,
literal|222
block|,
literal|220
block|,
literal|217
block|,
literal|213
block|,
literal|210
block|,
literal|206
block|,
literal|198
block|,
literal|191
block|,
literal|176
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 70-79 */
end_comment

begin_comment
comment|/*  * Companded sine table amplitude 6000 units  */
end_comment

begin_decl_stmt
name|int
name|c6000
index|[]
init|=
block|{
literal|1
block|,
literal|63
block|,
literal|78
block|,
literal|86
block|,
literal|93
block|,
literal|98
block|,
literal|101
block|,
literal|104
block|,
literal|107
block|,
literal|110
block|,
comment|/* 0-9 */
literal|112
block|,
literal|113
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|117
block|,
literal|118
block|,
literal|118
block|,
literal|119
block|,
literal|119
block|,
comment|/* 10-19 */
literal|119
block|,
literal|119
block|,
literal|119
block|,
literal|118
block|,
literal|118
block|,
literal|117
block|,
literal|117
block|,
literal|116
block|,
literal|115
block|,
literal|113
block|,
comment|/* 20-29 */
literal|112
block|,
literal|110
block|,
literal|107
block|,
literal|104
block|,
literal|101
block|,
literal|98
block|,
literal|93
block|,
literal|86
block|,
literal|78
block|,
literal|63
block|,
comment|/* 30-39 */
literal|129
block|,
literal|191
block|,
literal|206
block|,
literal|214
block|,
literal|221
block|,
literal|226
block|,
literal|229
block|,
literal|232
block|,
literal|235
block|,
literal|238
block|,
comment|/* 40-49 */
literal|240
block|,
literal|241
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|245
block|,
literal|246
block|,
literal|246
block|,
literal|247
block|,
literal|247
block|,
comment|/* 50-59 */
literal|247
block|,
literal|247
block|,
literal|247
block|,
literal|246
block|,
literal|246
block|,
literal|245
block|,
literal|245
block|,
literal|244
block|,
literal|243
block|,
literal|241
block|,
comment|/* 60-69 */
literal|240
block|,
literal|238
block|,
literal|235
block|,
literal|232
block|,
literal|229
block|,
literal|226
block|,
literal|221
block|,
literal|214
block|,
literal|206
block|,
literal|191
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 70-79 */
end_comment

begin_comment
comment|/*  * Decoder operations at the end of each second are driven by a state  * machine. The transition matrix consists of a dispatch table indexed  * by second number. Each entry in the table contains a case switch  * number and argument.  */
end_comment

begin_struct
struct|struct
name|progx
block|{
name|int
name|sw
decl_stmt|;
comment|/* case switch number */
name|int
name|arg
decl_stmt|;
comment|/* argument */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Case switch numbers  */
end_comment

begin_define
define|#
directive|define
name|DATA
value|(0)
end_define

begin_comment
comment|/* send data (0, 1, PI) */
end_comment

begin_define
define|#
directive|define
name|COEF
value|(1)
end_define

begin_comment
comment|/* send BCD bit */
end_comment

begin_define
define|#
directive|define
name|DEC
value|(2)
end_define

begin_comment
comment|/* decrement to next digit and send PI */
end_comment

begin_define
define|#
directive|define
name|MIN
value|(3)
end_define

begin_comment
comment|/* minute pulse */
end_comment

begin_define
define|#
directive|define
name|LEAP
value|(4)
end_define

begin_comment
comment|/* leap warning */
end_comment

begin_define
define|#
directive|define
name|DUT1
value|(5)
end_define

begin_comment
comment|/* DUT1 bits */
end_comment

begin_define
define|#
directive|define
name|DST1
value|(6)
end_define

begin_comment
comment|/* DST1 bit */
end_comment

begin_define
define|#
directive|define
name|DST2
value|(7)
end_define

begin_comment
comment|/* DST2 bit */
end_comment

begin_define
define|#
directive|define
name|DECZ
value|(8)
end_define

begin_comment
comment|/* decrement to next digit and send zero */
end_comment

begin_define
define|#
directive|define
name|DECC
value|(9)
end_define

begin_comment
comment|/* decrement to next digit and send bit */
end_comment

begin_define
define|#
directive|define
name|NODEC
value|(10)
end_define

begin_comment
comment|/* no decerement to next digit, send PI */
end_comment

begin_define
define|#
directive|define
name|DECX
value|(11)
end_define

begin_comment
comment|/* decrement to next digit, send PI, but no tick */
end_comment

begin_define
define|#
directive|define
name|DATAX
value|(12)
end_define

begin_comment
comment|/* send data (0, 1, PI), but no tick */
end_comment

begin_comment
comment|/*  * WWV/H format (100-Hz, 9 digits, 1 m frame)  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progx
index|[]
init|=
block|{
block|{
name|MIN
block|,
literal|800
block|}
block|,
comment|/* 0 minute sync pulse */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 1 */
block|{
name|DST2
block|,
literal|0
block|}
block|,
comment|/* 2 DST2 */
block|{
name|LEAP
block|,
literal|0
block|}
block|,
comment|/* 3 leap warning */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 4 1 year units */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 5 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 6 4 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 7 8 */
block|{
name|DEC
block|,
name|DATA0
block|}
block|,
comment|/* 8 */
block|{
name|DATA
block|,
name|PI
block|}
block|,
comment|/* 9 p1 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 10 1 minute units */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 11 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 12 4 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 13 8 */
block|{
name|DEC
block|,
name|DATA0
block|}
block|,
comment|/* 14 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 15 10 minute tens */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 16 20 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 17 40 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 18 80 (not used) */
block|{
name|DEC
block|,
name|PI
block|}
block|,
comment|/* 19 p2 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 20 1 hour units */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 21 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 22 4 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 23 8 */
block|{
name|DEC
block|,
name|DATA0
block|}
block|,
comment|/* 24 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 25 10 hour tens */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 26 20 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 27 40 (not used) */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 28 80 (not used) */
block|{
name|DECX
block|,
name|PI
block|}
block|,
comment|/* 29 p3 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 30 1 day units */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 31 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 32 4 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 33 8 */
block|{
name|DEC
block|,
name|DATA0
block|}
block|,
comment|/* 34 not used */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 35 10 day tens */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 36 20 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 37 40 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 38 80 */
block|{
name|DEC
block|,
name|PI
block|}
block|,
comment|/* 39 p4 */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 40 100 day hundreds */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 41 200 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 42 400 (not used) */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 43 800 (not used) */
block|{
name|DEC
block|,
name|DATA0
block|}
block|,
comment|/* 44 */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 45 */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 46 */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 47 */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 48 */
block|{
name|DATA
block|,
name|PI
block|}
block|,
comment|/* 49 p5 */
block|{
name|DUT1
block|,
literal|8
block|}
block|,
comment|/* 50 DUT1 sign */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 51 10 year tens */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 52 20 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 53 40 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 54 80 */
block|{
name|DST1
block|,
literal|0
block|}
block|,
comment|/* 55 DST1 */
block|{
name|DUT1
block|,
literal|1
block|}
block|,
comment|/* 56 0.1 DUT1 fraction */
block|{
name|DUT1
block|,
literal|2
block|}
block|,
comment|/* 57 0.2 */
block|{
name|DUT1
block|,
literal|4
block|}
block|,
comment|/* 58 0.4 */
block|{
name|DATAX
block|,
name|PI
block|}
block|,
comment|/* 59 p6 */
block|{
name|DATA
block|,
name|DATA0
block|}
block|,
comment|/* 60 leap */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG format frames (1000 Hz, 1 second for 10 frames of data)  */
end_comment

begin_comment
comment|/*  * IRIG format frame 10 - MS straight binary seconds  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progu
index|[]
init|=
block|{
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 0 0x0 0200 seconds */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 1 0x0 0400 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 2 0x0 0800 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/* 3 0x0 1000 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 4 0x0 2000 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 6 0x0 4000 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 7 0x0 8000 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/* 8 0x1 0000 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 9 0x2 0000 - but only 86,401 / 0x1 5181 seconds in a day, so always zero */
block|{
name|NODEC
block|,
name|M8
block|}
block|,
comment|/* 9 PI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG format frame 8 - MS control functions  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progv
index|[]
init|=
block|{
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/*  0 CF # 19 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/*  1 CF # 20 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/*  2 CF # 21 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/*  3 CF # 22 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/*  4 CF # 23 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/*  6 CF # 24 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/*  7 CF # 25 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/*  8 CF # 26 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/*  9 CF # 27 */
block|{
name|DEC
block|,
name|M8
block|}
block|,
comment|/* 10 PI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG format frames 7& 9 - LS control functions& LS straight binary seconds  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progw
index|[]
init|=
block|{
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/*  0  CF # 10, 0x0 0001 seconds */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/*  1  CF # 11, 0x0 0002 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/*  2  CF # 12, 0x0 0004 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/*  3  CF # 13, 0x0 0008 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/*  4  CF # 14, 0x0 0010 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/*  6  CF # 15, 0x0 0020 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/*  7  CF # 16, 0x0 0040 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/*  8  CF # 17, 0x0 0080 */
block|{
name|DECC
block|,
literal|1
block|}
block|,
comment|/*  9  CF # 18, 0x0 0100 */
block|{
name|NODEC
block|,
name|M8
block|}
block|,
comment|/* 10  PI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG format frames 2 to 6 - minutes, hours, days, hundreds days, 2 digit years (also called control functions bits 1-9)  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progy
index|[]
init|=
block|{
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 0 1 units, CF # 1 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 1 2 units, CF # 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 2 4 units, CF # 3 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 3 8 units, CF # 4 */
block|{
name|DECZ
block|,
name|M2
block|}
block|,
comment|/* 4 zero bit, CF # 5 / unused, default zero in years */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 5 10 tens, CF # 6 */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 6 20 tens, CF # 7*/
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 7 40 tens, CF # 8*/
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 8 80 tens, CF # 9*/
block|{
name|DEC
block|,
name|M8
block|}
block|,
comment|/* 9 PI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IRIG format first frame, frame 1 - seconds  */
end_comment

begin_decl_stmt
name|struct
name|progx
name|progz
index|[]
init|=
block|{
block|{
name|MIN
block|,
name|M8
block|}
block|,
comment|/* 0 PI (on-time marker for the second at zero cross of 1st cycle) */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 1 1 units */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 2 2 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 3 4 */
block|{
name|COEF
block|,
literal|8
block|}
block|,
comment|/* 4 8 */
block|{
name|DECZ
block|,
name|M2
block|}
block|,
comment|/* 5 zero bit */
block|{
name|COEF
block|,
literal|1
block|}
block|,
comment|/* 6 10 tens */
block|{
name|COEF
block|,
literal|2
block|}
block|,
comment|/* 7 20 */
block|{
name|COEF
block|,
literal|4
block|}
block|,
comment|/* 8 40 */
block|{
name|DEC
block|,
name|M8
block|}
block|,
comment|/* 9 PI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LeapState values. */
end_comment

begin_define
define|#
directive|define
name|LEAPSTATE_NORMAL
value|(0)
end_define

begin_define
define|#
directive|define
name|LEAPSTATE_DELETING
value|(1)
end_define

begin_define
define|#
directive|define
name|LEAPSTATE_INSERTING
value|(2)
end_define

begin_define
define|#
directive|define
name|LEAPSTATE_ZERO_AFTER_INSERT
value|(3)
end_define

begin_comment
comment|/*  * Forward declarations  */
end_comment

begin_function_decl
name|void
name|WWV_Second
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* send second */
end_comment

begin_function_decl
name|void
name|WWV_SecondNoTick
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* send second with no tick */
end_comment

begin_function_decl
name|void
name|digit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* encode digit */
end_comment

begin_function_decl
name|void
name|peep
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* send cycles */
end_comment

begin_function_decl
name|void
name|poop
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Generate unmodulated from similar tables */
end_comment

begin_function_decl
name|void
name|delay
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* delay samples */
end_comment

begin_function_decl
name|int
name|ConvertMonthDayToDayOfYear
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Calc day of year from year month& day */
end_comment

begin_function_decl
name|void
name|Help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Usage message */
end_comment

begin_function_decl
name|void
name|ReverseString
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Extern declarations, don't know why not in headers  */
end_comment

begin_comment
comment|//float	round ( float );
end_comment

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFLNG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer */
end_comment

begin_decl_stmt
name|int
name|bufcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer counter */
end_comment

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* audio codec file descriptor */
end_comment

begin_decl_stmt
name|int
name|tone
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* WWV sync frequency */
end_comment

begin_decl_stmt
name|int
name|HourTone
init|=
literal|1500
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* WWV hour on-time frequency */
end_comment

begin_decl_stmt
name|int
name|encode
init|=
name|IRIG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* encoder select */
end_comment

begin_decl_stmt
name|int
name|leap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* leap indicator */
end_comment

begin_decl_stmt
name|int
name|DstFlag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* winter/summer time */
end_comment

begin_decl_stmt
name|int
name|dut1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DUT1 correction (sign, magnitude) */
end_comment

begin_decl_stmt
name|int
name|utc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* option epoch */
end_comment

begin_decl_stmt
name|int
name|IrigIncludeYear
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to send year in first control functions area, between P5 and P6. */
end_comment

begin_decl_stmt
name|int
name|IrigIncludeIeee
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to send IEEE 1344 control functions extensions between P6 and P8. */
end_comment

begin_decl_stmt
name|int
name|StraightBinarySeconds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ControlFunctions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CommandName
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYS_SOUNDCARD_H
end_ifndef

begin_decl_stmt
name|int
name|level
init|=
name|AUDIO_MAX_GAIN
operator|/
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output level */
end_comment

begin_decl_stmt
name|int
name|port
init|=
name|AUDIO_LINE_OUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output port */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|TotalSecondsCorrected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TotalCyclesAdded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TotalCyclesRemoved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main program  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
comment|/* command line options */
name|char
modifier|*
modifier|*
name|argv
comment|/* poiniter to list of tokens */
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HAVE_SYS_SOUNDCARD_H
name|audio_info_t
name|info
decl_stmt|;
comment|/* Sun audio structure */
name|int
name|rval
decl_stmt|;
comment|/* For IOCTL calls */
endif|#
directive|endif
name|struct
name|timeval
name|TimeValue
decl_stmt|;
comment|/* System clock at startup */
name|time_t
name|SecondsPartOfTime
decl_stmt|;
comment|/* Sent to gmtime() for calculation of TimeStructure (can apply offset). */
name|time_t
name|BaseRealTime
decl_stmt|;
comment|/* Base realtime so can determine seconds since starting. */
name|time_t
name|NowRealTime
decl_stmt|;
comment|/* New realtime to can determine seconds as of now. */
name|unsigned
name|SecondsRunningRealTime
decl_stmt|;
comment|/* Difference between NowRealTime and BaseRealTime. */
name|unsigned
name|SecondsRunningSimulationTime
decl_stmt|;
comment|/* Time that the simulator has been running. */
name|int
name|SecondsRunningDifference
decl_stmt|;
comment|/* Difference between what real time says we have been running */
comment|/* and what simulator says we have been running - will slowly  */
comment|/* change because of clock drift. */
name|int
name|ExpectedRunningDifference
init|=
literal|0
decl_stmt|;
comment|/* Stable value that we've obtained from check at initial start-up.	*/
name|unsigned
name|StabilityCount
decl_stmt|;
comment|/* Used to check stability of difference while starting */
define|#
directive|define
name|RUN_BEFORE_STABILITY_CHECK
value|(30)
comment|// Must run this many seconds before even checking stability.
define|#
directive|define
name|MINIMUM_STABILITY_COUNT
value|(10)
comment|// Number of consecutive differences that need to be within initial stability band to say we are stable.
define|#
directive|define
name|INITIAL_STABILITY_BAND
value|( 2)
comment|// Determining initial stability for consecutive differences within +/- this value.
define|#
directive|define
name|RUNNING_STABILITY_BAND
value|( 5)
comment|// When running, stability is defined as difference within +/- this value.
name|struct
name|tm
modifier|*
name|TimeStructure
init|=
name|NULL
decl_stmt|;
comment|/* Structure returned by gmtime */
name|char
name|device
index|[
literal|200
index|]
decl_stmt|;
comment|/* audio device */
name|char
name|code
index|[
literal|200
index|]
decl_stmt|;
comment|/* timecode */
name|int
name|temp
decl_stmt|;
name|int
name|arg
init|=
literal|0
decl_stmt|;
name|int
name|sw
init|=
literal|0
decl_stmt|;
name|int
name|ptr
init|=
literal|0
decl_stmt|;
name|int
name|Year
decl_stmt|;
name|int
name|Month
decl_stmt|;
name|int
name|DayOfMonth
decl_stmt|;
name|int
name|Hour
decl_stmt|;
name|int
name|Minute
decl_stmt|;
name|int
name|Second
init|=
literal|0
decl_stmt|;
name|int
name|DayOfYear
decl_stmt|;
name|int
name|BitNumber
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYS_SOUNDCARD_H
name|int
name|AudioFormat
decl_stmt|;
name|int
name|MonoStereo
decl_stmt|;
comment|/* 0=mono, 1=stereo */
define|#
directive|define
name|MONO
value|(0)
define|#
directive|define
name|STEREO
value|(1)
name|int
name|SampleRate
decl_stmt|;
name|int
name|SampleRateDifference
decl_stmt|;
endif|#
directive|endif
name|int
name|SetSampleRate
decl_stmt|;
name|char
name|FormatCharacter
init|=
literal|'3'
decl_stmt|;
comment|/* Default is IRIG-B with IEEE 1344 extensions */
name|char
name|AsciiValue
decl_stmt|;
name|int
name|HexValue
decl_stmt|;
name|int
name|OldPtr
init|=
literal|0
decl_stmt|;
name|int
name|FrameNumber
init|=
literal|0
decl_stmt|;
comment|/* Time offset for IEEE 1344 indication. */
name|float
name|TimeOffset
init|=
literal|0.0
decl_stmt|;
name|int
name|OffsetSignBit
init|=
literal|0
decl_stmt|;
name|int
name|OffsetOnes
init|=
literal|0
decl_stmt|;
name|int
name|OffsetHalf
init|=
literal|0
decl_stmt|;
name|int
name|TimeQuality
init|=
literal|0
decl_stmt|;
comment|/* Time quality for IEEE 1344 indication. */
name|char
name|ParityString
index|[
literal|200
index|]
decl_stmt|;
comment|/* Partial output string, to calculate parity on. */
name|int
name|ParitySum
init|=
literal|0
decl_stmt|;
name|int
name|ParityValue
decl_stmt|;
name|char
modifier|*
name|StringPointer
decl_stmt|;
comment|/* Flags to indicate requested leap second addition or deletion by command line option. */
comment|/* Should be mutually exclusive - generally ensured by code which interprets command line option. */
name|int
name|InsertLeapSecond
init|=
name|FALSE
decl_stmt|;
name|int
name|DeleteLeapSecond
init|=
name|FALSE
decl_stmt|;
comment|/* Date and time of requested leap second addition or deletion. */
name|int
name|LeapYear
init|=
literal|0
decl_stmt|;
name|int
name|LeapMonth
init|=
literal|0
decl_stmt|;
name|int
name|LeapDayOfMonth
init|=
literal|0
decl_stmt|;
name|int
name|LeapHour
init|=
literal|0
decl_stmt|;
name|int
name|LeapMinute
init|=
literal|0
decl_stmt|;
name|int
name|LeapDayOfYear
init|=
literal|0
decl_stmt|;
comment|/* State flag for the insertion and deletion of leap seconds, esp. deletion, */
comment|/* where the logic gets a bit tricky. */
name|int
name|LeapState
init|=
name|LEAPSTATE_NORMAL
decl_stmt|;
comment|/* Flags for indication of leap second pending and leap secod polarity in IEEE 1344 */
name|int
name|LeapSecondPending
init|=
name|FALSE
decl_stmt|;
name|int
name|LeapSecondPolarity
init|=
name|FALSE
decl_stmt|;
comment|/* Date and time of requested switch into or out of DST by command line option. */
name|int
name|DstSwitchYear
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchMonth
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchDayOfMonth
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchHour
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchMinute
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchDayOfYear
init|=
literal|0
decl_stmt|;
comment|/* Indicate when we have been asked to switch into or out of DST by command line option. */
name|int
name|DstSwitchFlag
init|=
name|FALSE
decl_stmt|;
comment|/* To allow predict for DstPendingFlag in IEEE 1344 */
name|int
name|DstSwitchPendingYear
init|=
literal|0
decl_stmt|;
comment|/* Default value isn't valid, but I don't care. */
name|int
name|DstSwitchPendingDayOfYear
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchPendingHour
init|=
literal|0
decl_stmt|;
name|int
name|DstSwitchPendingMinute
init|=
literal|0
decl_stmt|;
comment|/* /Flag for indication of a DST switch pending in IEEE 1344 */
name|int
name|DstPendingFlag
init|=
name|FALSE
decl_stmt|;
comment|/* Attempt at unmodulated */
name|int
name|Unmodulated
init|=
name|FALSE
decl_stmt|;
name|int
name|UnmodulatedInverted
init|=
name|FALSE
decl_stmt|;
comment|/* Offset to actual time value sent. */
name|float
name|UseOffsetHoursFloat
decl_stmt|;
name|int
name|UseOffsetSecondsInt
init|=
literal|0
decl_stmt|;
name|float
name|UseOffsetSecondsFloat
decl_stmt|;
comment|/* String to allow us to put out reversed data - so can read the binary numbers. */
name|char
name|OutputDataString
index|[
name|OUTPUT_DATA_STRING_LENGTH
index|]
decl_stmt|;
comment|/* Number of seconds to send before exiting.  Default = 0 = forever. */
name|int
name|SecondsToSend
init|=
literal|0
decl_stmt|;
name|int
name|CountOfSecondsSent
init|=
literal|0
decl_stmt|;
comment|/* Counter of seconds */
comment|/* Flags to indicate whether to add or remove a cycle for time adjustment. */
name|int
name|AddCycle
init|=
name|FALSE
decl_stmt|;
comment|// We are ahead, add cycle to slow down and get back in sync.
name|int
name|RemoveCycle
init|=
name|FALSE
decl_stmt|;
comment|// We are behind, remove cycle to slow down and get back in sync.
name|int
name|RateCorrection
decl_stmt|;
comment|// Aggregate flag for passing to subroutines.
name|int
name|EnableRateCorrection
init|=
name|TRUE
decl_stmt|;
name|float
name|RatioError
decl_stmt|;
name|CommandName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|Help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Parse options 	 */
name|strlcpy
argument_list|(
name|device
argument_list|,
name|DEVICE
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|Year
operator|=
literal|0
expr_stmt|;
name|SetSampleRate
operator|=
name|SECOND
expr_stmt|;
if|#
directive|if
name|HAVE_SYS_SOUNDCARD_H
while|while
condition|(
operator|(
name|temp
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:b:c:df:g:hHi:jk:l:o:q:r:stu:xy:z?"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
else|#
directive|else
while|while
condition|(
operator|(
name|temp
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:b:c:df:g:hHi:jk:l:o:q:r:stu:v:xy:z?"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* specify audio device (/dev/audio) */
name|strlcpy
argument_list|(
name|device
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
argument_list|(
name|device
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Remove (delete) a leap second at the end of the specified minute. */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|LeapYear
argument_list|,
operator|&
name|LeapMonth
argument_list|,
operator|&
name|LeapDayOfMonth
argument_list|,
operator|&
name|LeapHour
argument_list|,
operator|&
name|LeapMinute
argument_list|)
expr_stmt|;
name|InsertLeapSecond
operator|=
name|FALSE
expr_stmt|;
name|DeleteLeapSecond
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* specify number of seconds to send output for before exiting, 0 = forever */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|SecondsToSend
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* set DST for summer (WWV/H only) / start with DST active (IRIG) */
name|DstFlag
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* select format: i=IRIG-98 (default) 2=IRIG-2004 3-IRIG+IEEE-1344 w=WWV(H) */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%c"
argument_list|,
operator|&
name|FormatCharacter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Date and time to switch back into / out of DST active. */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|DstSwitchYear
argument_list|,
operator|&
name|DstSwitchMonth
argument_list|,
operator|&
name|DstSwitchDayOfMonth
argument_list|,
operator|&
name|DstSwitchHour
argument_list|,
operator|&
name|DstSwitchMinute
argument_list|)
expr_stmt|;
name|DstSwitchFlag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'?'
case|:
name|Help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Insert (add) a leap second at the end of the specified minute. */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|LeapYear
argument_list|,
operator|&
name|LeapMonth
argument_list|,
operator|&
name|LeapDayOfMonth
argument_list|,
operator|&
name|LeapHour
argument_list|,
operator|&
name|LeapMinute
argument_list|)
expr_stmt|;
name|InsertLeapSecond
operator|=
name|TRUE
expr_stmt|;
name|DeleteLeapSecond
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|EnableRateCorrection
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|RateCorrection
argument_list|)
expr_stmt|;
name|EnableRateCorrection
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|RateCorrection
operator|<
literal|0
condition|)
block|{
name|RemoveCycle
operator|=
name|TRUE
expr_stmt|;
name|AddCycle
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n> Forcing rate correction removal of cycle...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RateCorrection
operator|>
literal|0
condition|)
block|{
name|RemoveCycle
operator|=
name|FALSE
expr_stmt|;
name|AddCycle
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n> Forcing rate correction addition of cycle...\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* use time offset from UTC */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%f"
argument_list|,
operator|&
name|UseOffsetHoursFloat
argument_list|)
expr_stmt|;
name|UseOffsetSecondsFloat
operator|=
name|UseOffsetHoursFloat
operator|*
operator|(
name|float
operator|)
name|SECONDS_PER_HOUR
expr_stmt|;
name|UseOffsetSecondsInt
operator|=
call|(
name|int
call|)
argument_list|(
name|UseOffsetSecondsFloat
operator|+
literal|0.5
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Set IEEE 1344 time offset in hours - positive or negative, to the half hour */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%f"
argument_list|,
operator|&
name|TimeOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimeOffset
operator|>=
operator|-
literal|0.2
condition|)
block|{
name|OffsetSignBit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TimeOffset
operator|>
literal|0
condition|)
block|{
name|OffsetOnes
operator|=
name|TimeOffset
expr_stmt|;
if|if
condition|(
operator|(
name|TimeOffset
operator|-
name|floor
argument_list|(
name|TimeOffset
argument_list|)
operator|)
operator|>=
literal|0.4
condition|)
name|OffsetHalf
operator|=
literal|1
expr_stmt|;
else|else
name|OffsetHalf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|OffsetOnes
operator|=
literal|0
expr_stmt|;
name|OffsetHalf
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|OffsetSignBit
operator|=
literal|1
expr_stmt|;
name|OffsetOnes
operator|=
operator|-
name|TimeOffset
expr_stmt|;
if|if
condition|(
operator|(
name|ceil
argument_list|(
name|TimeOffset
argument_list|)
operator|-
name|TimeOffset
operator|)
operator|>=
literal|0.4
condition|)
name|OffsetHalf
operator|=
literal|1
expr_stmt|;
else|else
name|OffsetHalf
operator|=
literal|0
expr_stmt|;
block|}
comment|/*printf ("\nGot TimeOffset = %3.1f, OffsetSignBit = %d, OffsetOnes = %d, OffsetHalf = %d...\n", 					TimeOffset, OffsetSignBit, OffsetOnes, OffsetHalf); 			*/
break|break;
case|case
literal|'q'
case|:
comment|/* Hex quality code 0 to 0x0F - 0 = maximum, 0x0F = no lock */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|TimeQuality
argument_list|)
expr_stmt|;
name|TimeQuality
operator|&=
literal|0x0F
expr_stmt|;
comment|/*printf ("\nGot TimeQuality = 0x%1X...\n", TimeQuality); 			*/
break|break;
case|case
literal|'r'
case|:
comment|/* sample rate (nominally 8000, integer close to 8000 I hope) */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|SetSampleRate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* set leap warning bit (WWV/H only) */
name|leap
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* select WWVH sync frequency */
name|tone
operator|=
literal|1200
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* set DUT1 offset (-7 to +7) */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|dut1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dut1
operator|<
literal|0
condition|)
name|dut1
operator|=
name|abs
argument_list|(
name|dut1
argument_list|)
expr_stmt|;
else|else
name|dut1
operator||=
literal|0x8
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|HAVE_SYS_SOUNDCARD_H
case|case
literal|'v'
case|:
comment|/* set output level (0-255) */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'x'
case|:
comment|/* Turn off verbose output. */
name|Verbose
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Set initial date and time */
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%2d%2d%2d%2d%2d%2d"
argument_list|,
operator|&
name|Year
argument_list|,
operator|&
name|Month
argument_list|,
operator|&
name|DayOfMonth
argument_list|,
operator|&
name|Hour
argument_list|,
operator|&
name|Minute
argument_list|,
operator|&
name|Second
argument_list|)
expr_stmt|;
name|utc
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Turn on Debug output (also turns on Verbose below) */
name|Debug
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Invalid option \"%c\", aborting...\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Debug
condition|)
name|Verbose
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|InsertLeapSecond
operator|||
name|DeleteLeapSecond
condition|)
block|{
name|LeapDayOfYear
operator|=
name|ConvertMonthDayToDayOfYear
argument_list|(
name|LeapYear
argument_list|,
name|LeapMonth
argument_list|,
name|LeapDayOfMonth
argument_list|)
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"\nHave request for leap second %s at year %4d day %3d at %2.2dh%2.2d....\n"
argument_list|,\
name|DeleteLeapSecond
condition|?
literal|"DELETION"
else|:
operator|(
name|InsertLeapSecond
condition|?
literal|"ADDITION"
else|:
literal|"( error ! )"
operator|)
argument_list|,
name|LeapYear
argument_list|,
name|LeapDayOfYear
argument_list|,
name|LeapHour
argument_list|,
name|LeapMinute
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DstSwitchFlag
condition|)
block|{
name|DstSwitchDayOfYear
operator|=
name|ConvertMonthDayToDayOfYear
argument_list|(
name|DstSwitchYear
argument_list|,
name|DstSwitchMonth
argument_list|,
name|DstSwitchDayOfMonth
argument_list|)
expr_stmt|;
comment|/* Figure out time of minute previous to DST switch, so can put up warning flag in IEEE 1344 */
name|DstSwitchPendingYear
operator|=
name|DstSwitchYear
expr_stmt|;
name|DstSwitchPendingDayOfYear
operator|=
name|DstSwitchDayOfYear
expr_stmt|;
name|DstSwitchPendingHour
operator|=
name|DstSwitchHour
expr_stmt|;
name|DstSwitchPendingMinute
operator|=
name|DstSwitchMinute
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|DstSwitchPendingMinute
operator|<
literal|0
condition|)
block|{
name|DstSwitchPendingMinute
operator|=
literal|59
expr_stmt|;
name|DstSwitchPendingHour
operator|--
expr_stmt|;
if|if
condition|(
name|DstSwitchPendingHour
operator|<
literal|0
condition|)
block|{
name|DstSwitchPendingHour
operator|=
literal|23
expr_stmt|;
name|DstSwitchPendingDayOfYear
operator|--
expr_stmt|;
if|if
condition|(
name|DstSwitchPendingDayOfYear
operator|<
literal|1
condition|)
block|{
name|DstSwitchPendingYear
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"\nHave DST switch request for year %4d day %3d at %2.2dh%2.2d,"
argument_list|,
name|DstSwitchYear
argument_list|,
name|DstSwitchDayOfYear
argument_list|,
name|DstSwitchHour
argument_list|,
name|DstSwitchMinute
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n    so will have warning at year %4d day %3d at %2.2dh%2.2d.\n"
argument_list|,
name|DstSwitchPendingYear
argument_list|,
name|DstSwitchPendingDayOfYear
argument_list|,
name|DstSwitchPendingHour
argument_list|,
name|DstSwitchPendingMinute
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|tolower
argument_list|(
name|FormatCharacter
argument_list|)
condition|)
block|{
case|case
literal|'i'
case|:
name|printf
argument_list|(
literal|"\nFormat is IRIG-1998 (no year coded)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|IRIG
expr_stmt|;
name|IrigIncludeYear
operator|=
name|FALSE
expr_stmt|;
name|IrigIncludeIeee
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|printf
argument_list|(
literal|"\nFormat is IRIG-2004 (BCD year coded)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|IRIG
expr_stmt|;
name|IrigIncludeYear
operator|=
name|TRUE
expr_stmt|;
name|IrigIncludeIeee
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|printf
argument_list|(
literal|"\nFormat is IRIG with IEEE-1344 (BCD year coded, and more control functions)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|IRIG
expr_stmt|;
name|IrigIncludeYear
operator|=
name|TRUE
expr_stmt|;
name|IrigIncludeIeee
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|printf
argument_list|(
literal|"\nFormat is unmodulated IRIG with IEEE-1344 (BCD year coded, and more control functions)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|IRIG
expr_stmt|;
name|IrigIncludeYear
operator|=
name|TRUE
expr_stmt|;
name|IrigIncludeIeee
operator|=
name|TRUE
expr_stmt|;
name|Unmodulated
operator|=
name|TRUE
expr_stmt|;
name|UnmodulatedInverted
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|printf
argument_list|(
literal|"\nFormat is inverted unmodulated IRIG with IEEE-1344 (BCD year coded, and more control functions)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|IRIG
expr_stmt|;
name|IrigIncludeYear
operator|=
name|TRUE
expr_stmt|;
name|IrigIncludeIeee
operator|=
name|TRUE
expr_stmt|;
name|Unmodulated
operator|=
name|TRUE
expr_stmt|;
name|UnmodulatedInverted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|printf
argument_list|(
literal|"\nFormat is WWV(H)...\n\n"
argument_list|)
expr_stmt|;
name|encode
operator|=
name|WWV
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n\nUnexpected format value of \'%c\', cannot parse, aborting...\n\n"
argument_list|,
name|FormatCharacter
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Open audio device and set options 	 */
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to open audio device \"%s\", aborting: %s\n"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_SYS_SOUNDCARD_H
comment|/* First set coding type */
name|AudioFormat
operator|=
name|AFMT_MU_LAW
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETFMT
argument_list|,
operator|&
name|AudioFormat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fatal error */
name|printf
argument_list|(
literal|"\nUnable to set output format, aborting...\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AudioFormat
operator|!=
name|AFMT_MU_LAW
condition|)
block|{
name|printf
argument_list|(
literal|"\nUnable to set output format for mu law, aborting...\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Next set number of channels */
name|MonoStereo
operator|=
name|MONO
expr_stmt|;
comment|/* Mono */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_STEREO
argument_list|,
operator|&
name|MonoStereo
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fatal error */
name|printf
argument_list|(
literal|"\nUnable to set mono/stereo, aborting...\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MonoStereo
operator|!=
name|MONO
condition|)
block|{
name|printf
argument_list|(
literal|"\nUnable to set mono/stereo for mono, aborting...\n\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now set sample rate */
name|SampleRate
operator|=
name|SetSampleRate
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|SampleRate
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Fatal error */
name|printf
argument_list|(
literal|"\nUnable to set sample rate to %d, returned %d, aborting...\n\n"
argument_list|,
name|SetSampleRate
argument_list|,
name|SampleRate
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|SampleRateDifference
operator|=
name|SampleRate
operator|-
name|SetSampleRate
expr_stmt|;
if|if
condition|(
name|SampleRateDifference
operator|<
literal|0
condition|)
name|SampleRateDifference
operator|=
operator|-
name|SampleRateDifference
expr_stmt|;
comment|/* Fixed allowable sample rate error 0.1% */
if|if
condition|(
name|SampleRateDifference
operator|>
operator|(
name|SetSampleRate
operator|/
literal|1000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nUnable to set sample rate to %d, result was %d, more than 0.1 percent, aborting...\n\n"
argument_list|,
name|SetSampleRate
argument_list|,
name|SampleRate
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* printf ("\nAttempt to set sample rate to %d, actual %d...\n\n", SetSampleRate, SampleRate); */
block|}
else|#
directive|else
name|rval
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|AUDIO_GETINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\naudio control %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|play
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|info
operator|.
name|play
operator|.
name|gain
operator|=
name|level
expr_stmt|;
name|info
operator|.
name|play
operator|.
name|sample_rate
operator|=
name|SetSampleRate
expr_stmt|;
name|info
operator|.
name|play
operator|.
name|channels
operator|=
literal|1
expr_stmt|;
name|info
operator|.
name|play
operator|.
name|precision
operator|=
literal|8
expr_stmt|;
name|info
operator|.
name|play
operator|.
name|encoding
operator|=
name|AUDIO_ENCODING_ULAW
expr_stmt|;
name|printf
argument_list|(
literal|"\nport %d gain %d rate %d chan %d prec %d encode %d\n"
argument_list|,
name|info
operator|.
name|play
operator|.
name|port
argument_list|,
name|info
operator|.
name|play
operator|.
name|gain
argument_list|,
name|info
operator|.
name|play
operator|.
name|sample_rate
argument_list|,
name|info
operator|.
name|play
operator|.
name|channels
argument_list|,
name|info
operator|.
name|play
operator|.
name|precision
argument_list|,
name|info
operator|.
name|play
operator|.
name|encoding
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|AUDIO_SETINFO
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Unless specified otherwise, read the system clock and 	 * initialize the time. 	 */
name|gettimeofday
argument_list|(
operator|&
name|TimeValue
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|// Now always read the system time to keep "real time" of operation.
name|NowRealTime
operator|=
name|BaseRealTime
operator|=
name|SecondsPartOfTime
operator|=
name|TimeValue
operator|.
name|tv_sec
expr_stmt|;
name|SecondsRunningSimulationTime
operator|=
literal|0
expr_stmt|;
comment|// Just starting simulation, running zero seconds as of now.
name|StabilityCount
operator|=
literal|0
expr_stmt|;
comment|// No stability yet.
if|if
condition|(
name|utc
condition|)
block|{
name|DayOfYear
operator|=
name|ConvertMonthDayToDayOfYear
argument_list|(
name|Year
argument_list|,
name|Month
argument_list|,
name|DayOfMonth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Apply offset to time. */
if|if
condition|(
name|UseOffsetSecondsInt
operator|>=
literal|0
condition|)
name|SecondsPartOfTime
operator|+=
operator|(
name|time_t
operator|)
name|UseOffsetSecondsInt
expr_stmt|;
else|else
name|SecondsPartOfTime
operator|-=
call|(
name|time_t
call|)
argument_list|(
operator|-
name|UseOffsetSecondsInt
argument_list|)
expr_stmt|;
name|TimeStructure
operator|=
name|gmtime
argument_list|(
operator|&
name|SecondsPartOfTime
argument_list|)
expr_stmt|;
name|Minute
operator|=
name|TimeStructure
operator|->
name|tm_min
expr_stmt|;
name|Hour
operator|=
name|TimeStructure
operator|->
name|tm_hour
expr_stmt|;
name|DayOfYear
operator|=
name|TimeStructure
operator|->
name|tm_yday
operator|+
literal|1
expr_stmt|;
name|Year
operator|=
name|TimeStructure
operator|->
name|tm_year
operator|%
literal|100
expr_stmt|;
name|Second
operator|=
name|TimeStructure
operator|->
name|tm_sec
expr_stmt|;
comment|/* 		 * Delay the first second so the generator is accurately 		 * aligned with the system clock within one sample (125 		 * microseconds ). 		 */
name|delay
argument_list|(
name|SECOND
operator|-
name|TimeValue
operator|.
name|tv_usec
operator|*
literal|8
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|StraightBinarySeconds
operator|=
name|Second
operator|+
operator|(
name|Minute
operator|*
name|SECONDS_PER_MINUTE
operator|)
operator|+
operator|(
name|Hour
operator|*
name|SECONDS_PER_HOUR
operator|)
expr_stmt|;
name|memset
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encode
condition|)
block|{
comment|/* 	 * For WWV/H and default time, carefully set the signal 	 * generator seconds number to agree with the current time. 	 */
case|case
name|WWV
case|:
name|printf
argument_list|(
literal|"WWV time signal, starting point:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Year = %02d, Day of year = %03d, Time = %02d:%02d:%02d, Minute tone = %d Hz, Hour tone = %d Hz.\n"
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|,
name|tone
argument_list|,
name|HourTone
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
argument_list|,
literal|"%01d%03d%02d%02d%01d"
argument_list|,
name|Year
operator|/
literal|10
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Year
operator|%
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"\n Year = %2.2d, Day of year = %3d, Time = %2.2d:%2.2d:%2.2d, Code = %s"
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|EnableRateCorrection
operator|)
operator|||
operator|(
name|RemoveCycle
operator|)
operator|||
operator|(
name|AddCycle
operator|)
condition|)
name|printf
argument_list|(
literal|", CountOfSecondsSent = %d, TotalCyclesAdded = %d, TotalCyclesRemoved = %d\n"
argument_list|,
name|CountOfSecondsSent
argument_list|,
name|TotalCyclesAdded
argument_list|,
name|TotalCyclesRemoved
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|BitNumber
operator|=
literal|0
init|;
name|BitNumber
operator|<=
name|Second
condition|;
name|BitNumber
operator|++
control|)
block|{
if|if
condition|(
name|progx
index|[
name|BitNumber
index|]
operator|.
name|sw
operator|==
name|DEC
condition|)
name|ptr
operator|--
expr_stmt|;
block|}
break|break;
comment|/* 	 * For IRIG the signal generator runs every second, so requires 	 * no additional alignment. 	 */
case|case
name|IRIG
case|:
name|printf
argument_list|(
literal|"IRIG-B time signal, starting point:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Year = %02d, Day of year = %03d, Time = %02d:%02d:%02d, Straight binary seconds (SBS) = %05d / 0x%04X.\n"
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|,
name|StraightBinarySeconds
argument_list|,
name|StraightBinarySeconds
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"Codes: \".\" = marker/position indicator, \"-\" = zero dummy bit, \"0\" = zero bit, \"1\" = one bit.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|EnableRateCorrection
operator|)
operator|||
operator|(
name|AddCycle
operator|)
operator|||
operator|(
name|RemoveCycle
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"       \"o\" = short zero, \"*\" = long zero, \"x\" = short one, \"+\" = long one.\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Numerical values are time order reversed in output to make it easier to read.\n"
argument_list|)
expr_stmt|;
comment|/*                 111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999 */
comment|/*       0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Legend of output codes:\n"
argument_list|)
expr_stmt|;
comment|//printf ("\n");
comment|//printf ("|  StraightBinSecs  | IEEE_1344_Control |   Year  |    Day_of_Year    |  Hours  | Minutes |Seconds |\n");
comment|//printf ("|  ---------------  | ----------------- |   ----  |    -----------    |  -----  | ------- |------- |\n");
comment|//printf ("|                   |                   |         |                   |         |         |        |\n");
block|}
break|break;
block|}
comment|/* 	 * Run the signal generator to generate new timecode strings 	 * once per minute for WWV/H and once per second for IRIG. 	 */
for|for
control|(
name|CountOfSecondsSent
operator|=
literal|0
init|;
operator|(
operator|(
name|SecondsToSend
operator|==
literal|0
operator|)
operator|||
operator|(
name|CountOfSecondsSent
operator|<
name|SecondsToSend
operator|)
operator|)
condition|;
name|CountOfSecondsSent
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|encode
operator|==
name|IRIG
operator|)
operator|&&
operator|(
operator|(
operator|(
name|Second
operator|%
literal|20
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|CountOfSecondsSent
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Year = %02d, Day of year = %03d, Time = %02d:%02d:%02d, Straight binary seconds (SBS) = %05d / 0x%04X.\n"
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|,
name|StraightBinarySeconds
argument_list|,
name|StraightBinarySeconds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|EnableRateCorrection
operator|)
operator|||
operator|(
name|RemoveCycle
operator|)
operator|||
operator|(
name|AddCycle
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" CountOfSecondsSent = %d, TotalCyclesAdded = %d, TotalCyclesRemoved = %d\n"
argument_list|,
name|CountOfSecondsSent
argument_list|,
name|TotalCyclesAdded
argument_list|,
name|TotalCyclesRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CountOfSecondsSent
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|TotalCyclesAdded
operator|!=
literal|0
operator|)
operator|||
operator|(
name|TotalCyclesRemoved
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|RatioError
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|TotalCyclesAdded
operator|-
name|TotalCyclesRemoved
argument_list|)
operator|)
operator|/
operator|(
literal|1000.0
operator|*
operator|(
name|float
operator|)
name|CountOfSecondsSent
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" Adjusted by %2.1f%%, apparent send frequency is %4.2f Hz not %d Hz.\n\n"
argument_list|,
name|RatioError
operator|*
literal|100.0
argument_list|,
operator|(
literal|1.0
operator|+
name|RatioError
operator|)
operator|*
operator|(
operator|(
name|float
operator|)
name|SetSampleRate
operator|)
argument_list|,
name|SetSampleRate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* printf ("|Seconds | Minutes |  Hours  |    Day_of_Year    |   Year  | IEEE_1344_Control |  StraightBinSecs  |\n");     		printf ("|------- | ------- |  -----  |    -----------    |   ----  | ----------------- |-------------------|\n"); 	    	printf ("|        |         |         |                   |         |                   |                   |\n");*/
name|printf
argument_list|(
literal|"|  StraightBinSecs  | IEEE_1344_Control |   Year  |    Day_of_Year    |  Hours  | Minutes |Seconds |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"|  ---------------  | ----------------- |   ----  |    -----------    |  -----  | ------- |------- |\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"|                   |                   |         |                   |         |         |        |\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RemoveCycle
condition|)
block|{
name|RateCorrection
operator|=
operator|-
literal|1
expr_stmt|;
name|TotalSecondsCorrected
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|AddCycle
condition|)
block|{
name|TotalSecondsCorrected
operator|++
expr_stmt|;
name|RateCorrection
operator|=
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|RateCorrection
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Crank the state machine to propagate carries to the 		 * year of century. Note that we delayed up to one 		 * second for alignment after reading the time, so this 		 * is the next second. 		 */
if|if
condition|(
name|LeapState
operator|==
name|LEAPSTATE_NORMAL
condition|)
block|{
comment|/* If on the second of a leap (second 59 in the specified minute), then add or delete a second */
if|if
condition|(
operator|(
name|Year
operator|==
name|LeapYear
operator|)
operator|&&
operator|(
name|DayOfYear
operator|==
name|LeapDayOfYear
operator|)
operator|&&
operator|(
name|Hour
operator|==
name|LeapHour
operator|)
operator|&&
operator|(
name|Minute
operator|==
name|LeapMinute
operator|)
condition|)
block|{
comment|/* To delete a second, which means we go from 58->60 instead of 58->59->00. */
if|if
condition|(
operator|(
name|DeleteLeapSecond
operator|)
operator|&&
operator|(
name|Second
operator|==
literal|58
operator|)
condition|)
block|{
name|LeapState
operator|=
name|LEAPSTATE_DELETING
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- Ready to delete a leap second...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete takes precedence over insert. */
comment|/* To add a second, which means we go from 59->60->00 instead of 59->00. */
if|if
condition|(
operator|(
name|InsertLeapSecond
operator|)
operator|&&
operator|(
name|Second
operator|==
literal|59
operator|)
condition|)
block|{
name|LeapState
operator|=
name|LEAPSTATE_INSERTING
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- Ready to insert a leap second...\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
switch|switch
condition|(
name|LeapState
condition|)
block|{
case|case
name|LEAPSTATE_NORMAL
case|:
name|Second
operator|=
operator|(
name|Second
operator|+
literal|1
operator|)
operator|%
literal|60
expr_stmt|;
break|break;
case|case
name|LEAPSTATE_DELETING
case|:
name|Second
operator|=
literal|0
expr_stmt|;
name|LeapState
operator|=
name|LEAPSTATE_NORMAL
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- Deleting a leap second...\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAPSTATE_INSERTING
case|:
name|Second
operator|=
literal|60
expr_stmt|;
name|LeapState
operator|=
name|LEAPSTATE_ZERO_AFTER_INSERT
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- Inserting a leap second...\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEAPSTATE_ZERO_AFTER_INSERT
case|:
name|Second
operator|=
literal|0
expr_stmt|;
name|LeapState
operator|=
name|LEAPSTATE_NORMAL
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- Inserted a leap second, now back to zero...\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n\nLeap second state invalid value of %d, aborting..."
argument_list|,
name|LeapState
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for second rollover, increment minutes and ripple upward if required. */
if|if
condition|(
name|Second
operator|==
literal|0
condition|)
block|{
name|Minute
operator|++
expr_stmt|;
if|if
condition|(
name|Minute
operator|>=
literal|60
condition|)
block|{
name|Minute
operator|=
literal|0
expr_stmt|;
name|Hour
operator|++
expr_stmt|;
block|}
comment|/* Check for activation of DST switch. */
comment|/* If DST is active, this would mean that at the appointed time, we de-activate DST, */
comment|/* which translates to going backward an hour (repeating the last hour). */
comment|/* If DST is not active, this would mean that at the appointed time, we activate DST, */
comment|/* which translates to going forward an hour (skipping the next hour). */
if|if
condition|(
name|DstSwitchFlag
condition|)
block|{
comment|/* The actual switch happens on the zero'th second of the actual minute specified. */
if|if
condition|(
operator|(
name|Year
operator|==
name|DstSwitchYear
operator|)
operator|&&
operator|(
name|DayOfYear
operator|==
name|DstSwitchDayOfYear
operator|)
operator|&&
operator|(
name|Hour
operator|==
name|DstSwitchHour
operator|)
operator|&&
operator|(
name|Minute
operator|==
name|DstSwitchMinute
operator|)
condition|)
block|{
if|if
condition|(
name|DstFlag
operator|==
literal|0
condition|)
block|{
comment|/* DST flag is zero, not in DST, going to DST, "spring ahead", so increment hour by two instead of one. */
name|Hour
operator|++
expr_stmt|;
name|DstFlag
operator|=
literal|1
expr_stmt|;
comment|/* Must adjust offset to keep consistent with UTC. */
comment|/* Here we have to increase offset by one hour.  If it goes from negative to positive, then we fix that. */
if|if
condition|(
name|OffsetSignBit
operator|==
literal|0
condition|)
block|{
comment|/* Offset is positive */
if|if
condition|(
name|OffsetOnes
operator|==
literal|0x0F
condition|)
block|{
name|OffsetSignBit
operator|=
literal|1
expr_stmt|;
name|OffsetOnes
operator|=
operator|(
name|OffsetHalf
operator|==
literal|0
operator|)
condition|?
literal|8
else|:
literal|7
expr_stmt|;
block|}
else|else
name|OffsetOnes
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Offset is negative */
if|if
condition|(
name|OffsetOnes
operator|==
literal|0
condition|)
block|{
name|OffsetSignBit
operator|=
literal|0
expr_stmt|;
name|OffsetOnes
operator|=
operator|(
name|OffsetHalf
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
name|OffsetOnes
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- DST activated, spring ahead an hour, new offset !...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DST flag is non zero, in DST, going out of DST, "fall back", so no increment of hour. */
name|Hour
operator|--
expr_stmt|;
name|DstFlag
operator|=
literal|0
expr_stmt|;
comment|/* Must adjust offset to keep consistent with UTC. */
comment|/* Here we have to reduce offset by one hour.  If it goes negative, then we fix that. */
if|if
condition|(
name|OffsetSignBit
operator|==
literal|0
condition|)
block|{
comment|/* Offset is positive */
if|if
condition|(
name|OffsetOnes
operator|==
literal|0
condition|)
block|{
name|OffsetSignBit
operator|=
literal|1
expr_stmt|;
name|OffsetOnes
operator|=
operator|(
name|OffsetHalf
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
name|OffsetOnes
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Offset is negative */
if|if
condition|(
name|OffsetOnes
operator|==
literal|0x0F
condition|)
block|{
name|OffsetSignBit
operator|=
literal|0
expr_stmt|;
name|OffsetOnes
operator|=
operator|(
name|OffsetHalf
operator|==
literal|0
operator|)
condition|?
literal|8
else|:
literal|7
expr_stmt|;
block|}
else|else
name|OffsetOnes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n<--- DST de-activated, fall back an hour!...\n"
argument_list|)
expr_stmt|;
block|}
name|DstSwitchFlag
operator|=
name|FALSE
expr_stmt|;
comment|/* One time deal, not intended to run this program past two switches... */
block|}
block|}
if|if
condition|(
name|Hour
operator|>=
literal|24
condition|)
block|{
comment|/* Modified, just in case dumb case where activating DST advances 23h59:59 -> 01h00:00 */
name|Hour
operator|=
name|Hour
operator|%
literal|24
expr_stmt|;
name|DayOfYear
operator|++
expr_stmt|;
block|}
comment|/* 			 * At year rollover check for leap second. 			 */
if|if
condition|(
name|DayOfYear
operator|>=
operator|(
name|Year
operator|&
literal|0x3
condition|?
literal|366
else|:
literal|367
operator|)
condition|)
block|{
if|if
condition|(
name|leap
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\nLeap!"
argument_list|)
expr_stmt|;
name|leap
operator|=
literal|0
expr_stmt|;
block|}
name|DayOfYear
operator|=
literal|1
expr_stmt|;
name|Year
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|encode
operator|==
name|WWV
condition|)
block|{
name|snprintf
argument_list|(
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
argument_list|,
literal|"%01d%03d%02d%02d%01d"
argument_list|,
name|Year
operator|/
literal|10
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Year
operator|%
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n Year = %2.2d, Day of year = %3d, Time = %2.2d:%2.2d:%2.2d, Code = %s"
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|EnableRateCorrection
operator|)
operator|||
operator|(
name|RemoveCycle
operator|)
operator|||
operator|(
name|AddCycle
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|", CountOfSecondsSent = %d, TotalCyclesAdded = %d, TotalCyclesRemoved = %d\n"
argument_list|,
name|CountOfSecondsSent
argument_list|,
name|TotalCyclesAdded
argument_list|,
name|TotalCyclesRemoved
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CountOfSecondsSent
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|TotalCyclesAdded
operator|!=
literal|0
operator|)
operator|||
operator|(
name|TotalCyclesRemoved
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|RatioError
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|TotalCyclesAdded
operator|-
name|TotalCyclesRemoved
argument_list|)
operator|)
operator|/
operator|(
literal|1000.0
operator|*
operator|(
name|float
operator|)
name|CountOfSecondsSent
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" Adjusted by %2.1f%%, apparent send frequency is %4.2f Hz not %d Hz.\n\n"
argument_list|,
name|RatioError
operator|*
literal|100.0
argument_list|,
operator|(
literal|1.0
operator|+
name|RatioError
operator|)
operator|*
operator|(
operator|(
name|float
operator|)
name|SetSampleRate
operator|)
argument_list|,
name|SetSampleRate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* End of "if  (Second == 0)" */
comment|/* After all that, if we are in the minute just prior to a leap second, warn of leap second pending */
comment|/* and of the polarity */
if|if
condition|(
operator|(
name|Year
operator|==
name|LeapYear
operator|)
operator|&&
operator|(
name|DayOfYear
operator|==
name|LeapDayOfYear
operator|)
operator|&&
operator|(
name|Hour
operator|==
name|LeapHour
operator|)
operator|&&
operator|(
name|Minute
operator|==
name|LeapMinute
operator|)
condition|)
block|{
name|LeapSecondPending
operator|=
name|TRUE
expr_stmt|;
name|LeapSecondPolarity
operator|=
name|DeleteLeapSecond
expr_stmt|;
block|}
else|else
block|{
name|LeapSecondPending
operator|=
name|FALSE
expr_stmt|;
name|LeapSecondPolarity
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Notification through IEEE 1344 happens during the whole minute previous to the minute specified. */
comment|/* The time of that minute has been previously calculated. */
if|if
condition|(
operator|(
name|Year
operator|==
name|DstSwitchPendingYear
operator|)
operator|&&
operator|(
name|DayOfYear
operator|==
name|DstSwitchPendingDayOfYear
operator|)
operator|&&
operator|(
name|Hour
operator|==
name|DstSwitchPendingHour
operator|)
operator|&&
operator|(
name|Minute
operator|==
name|DstSwitchPendingMinute
operator|)
condition|)
block|{
name|DstPendingFlag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|DstPendingFlag
operator|=
name|FALSE
expr_stmt|;
block|}
name|StraightBinarySeconds
operator|=
name|Second
operator|+
operator|(
name|Minute
operator|*
name|SECONDS_PER_MINUTE
operator|)
operator|+
operator|(
name|Hour
operator|*
name|SECONDS_PER_HOUR
operator|)
expr_stmt|;
if|if
condition|(
name|encode
operator|==
name|IRIG
condition|)
block|{
if|if
condition|(
name|IrigIncludeIeee
condition|)
block|{
if|if
condition|(
operator|(
name|OffsetOnes
operator|==
literal|0
operator|)
operator|&&
operator|(
name|OffsetHalf
operator|==
literal|0
operator|)
condition|)
name|OffsetSignBit
operator|=
literal|0
expr_stmt|;
name|ControlFunctions
operator|=
operator|(
name|LeapSecondPending
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00001
operator|)
operator||
operator|(
name|LeapSecondPolarity
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00002
operator|)
operator||
operator|(
name|DstPendingFlag
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00004
operator|)
operator||
operator|(
name|DstFlag
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00008
operator|)
operator||
operator|(
name|OffsetSignBit
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00010
operator|)
operator||
operator|(
operator|(
name|OffsetOnes
operator|&
literal|0x0F
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|OffsetHalf
operator|==
literal|0
condition|?
literal|0x00000
else|:
literal|0x00200
operator|)
operator||
operator|(
operator|(
name|TimeQuality
operator|&
literal|0x0F
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
comment|/* if  (Verbose) 				        printf ("\nDstFlag = %d, OffsetSignBit = %d, OffsetOnes = %d, OffsetHalf = %d, TimeQuality = 0x%1.1X ==> ControlFunctions = 0x%5.5X...", 						    DstFlag, OffsetSignBit, OffsetOnes, OffsetHalf, TimeQuality, ControlFunctions); 				*/
block|}
else|else
name|ControlFunctions
operator|=
literal|0
expr_stmt|;
comment|/* 						      YearDay HourMin Sec 			snprintf(code, sizeof(code), "%04x%04d%06d%02d%02d%02d", 				0, Year, DayOfYear, Hour, Minute, Second); 			*/
if|if
condition|(
name|IrigIncludeYear
condition|)
block|{
name|snprintf
argument_list|(
name|ParityString
argument_list|,
sizeof|sizeof
argument_list|(
name|ParityString
argument_list|)
argument_list|,
literal|"%04X%02d%04d%02d%02d%02d"
argument_list|,
name|ControlFunctions
operator|&
literal|0x7FFF
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|ParityString
argument_list|,
sizeof|sizeof
argument_list|(
name|ParityString
argument_list|)
argument_list|,
literal|"%04X%02d%04d%02d%02d%02d"
argument_list|,
name|ControlFunctions
operator|&
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IrigIncludeIeee
condition|)
block|{
name|ParitySum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|StringPointer
operator|=
name|ParityString
init|;
operator|*
name|StringPointer
operator|!=
name|NUL
condition|;
name|StringPointer
operator|++
control|)
block|{
switch|switch
condition|(
name|toupper
argument_list|(
operator|*
name|StringPointer
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'4'
case|:
case|case
literal|'8'
case|:
name|ParitySum
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'9'
case|:
case|case
literal|'A'
case|:
case|case
literal|'C'
case|:
name|ParitySum
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
case|case
literal|'B'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
name|ParitySum
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|ParitySum
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ParitySum
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
name|ParityValue
operator|=
literal|0x01
expr_stmt|;
else|else
name|ParityValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ParityValue
operator|=
literal|0
expr_stmt|;
name|ControlFunctions
operator||=
operator|(
operator|(
name|ParityValue
operator|&
literal|0x01
operator|)
operator|<<
literal|14
operator|)
expr_stmt|;
if|if
condition|(
name|IrigIncludeYear
condition|)
block|{
name|snprintf
argument_list|(
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
argument_list|,
comment|/* YearDay HourMin Sec */
literal|"%05X%05X%02d%04d%02d%02d%02d"
argument_list|,
name|StraightBinarySeconds
argument_list|,
name|ControlFunctions
argument_list|,
name|Year
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|code
argument_list|,
sizeof|sizeof
argument_list|(
name|code
argument_list|)
argument_list|,
comment|/* YearDay HourMin Sec */
literal|"%05X%05X%02d%04d%02d%02d%02d"
argument_list|,
name|StraightBinarySeconds
argument_list|,
name|ControlFunctions
argument_list|,
literal|0
argument_list|,
name|DayOfYear
argument_list|,
name|Hour
argument_list|,
name|Minute
argument_list|,
name|Second
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\nCode string: %s, ParityString = %s, ParitySum = 0x%2.2X, ParityValue = %d, DstFlag = %d...\n"
argument_list|,
name|code
argument_list|,
name|ParityString
argument_list|,
name|ParitySum
argument_list|,
name|ParityValue
argument_list|,
name|DstFlag
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|strlen
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|OldPtr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Generate data for the second 		 */
switch|switch
condition|(
name|encode
condition|)
block|{
comment|/* 		 * The IRIG second consists of 20 BCD digits of width- 		 * modulateod pulses at 2, 5 and 8 ms and modulated 50 		 * percent on the 1000-Hz carrier. 		 */
case|case
name|IRIG
case|:
comment|/* Initialize the output string */
name|OutputDataString
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|BitNumber
operator|=
literal|0
init|;
name|BitNumber
operator|<
literal|100
condition|;
name|BitNumber
operator|++
control|)
block|{
name|FrameNumber
operator|=
operator|(
name|BitNumber
operator|/
literal|10
operator|)
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|FrameNumber
condition|)
block|{
case|case
literal|1
case|:
comment|/* bits 0 to 9, first frame */
name|sw
operator|=
name|progz
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progz
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
comment|/* bits 10 to 59, second to sixth frame */
name|sw
operator|=
name|progy
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progy
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* bits 60 to 69, seventh frame */
name|sw
operator|=
name|progw
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progw
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* bits 70 to 79, eighth frame */
name|sw
operator|=
name|progv
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progv
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* bits 80 to 89, ninth frame */
name|sw
operator|=
name|progw
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progw
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* bits 90 to 99, tenth frame */
name|sw
operator|=
name|progu
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progu
index|[
name|BitNumber
operator|%
literal|10
index|]
operator|.
name|arg
expr_stmt|;
break|break;
default|default:
comment|/* , Unexpected values of FrameNumber */
name|printf
argument_list|(
literal|"\n\nUnexpected value of FrameNumber = %d, cannot parse, aborting...\n\n"
argument_list|,
name|FrameNumber
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sw
condition|)
block|{
case|case
name|DECC
case|:
comment|/* decrement pointer and send bit. */
name|ptr
operator|--
expr_stmt|;
case|case
name|COEF
case|:
comment|/* send BCD bit */
name|AsciiValue
operator|=
name|toupper
argument_list|(
name|code
index|[
name|ptr
index|]
argument_list|)
expr_stmt|;
name|HexValue
operator|=
name|isdigit
argument_list|(
name|AsciiValue
argument_list|)
condition|?
name|AsciiValue
operator|-
literal|'0'
else|:
operator|(
name|AsciiValue
operator|-
literal|'A'
operator|)
operator|+
literal|10
expr_stmt|;
comment|/* if  (Debug) { 						if  (ptr != OldPtr) { 						if  (Verbose) 						    printf("\n(%c->%X)", AsciiValue, HexValue); 						OldPtr = ptr; 						} 					} 					*/
comment|// OK, adjust all unused bits in hundreds of days.
if|if
condition|(
operator|(
name|FrameNumber
operator|==
literal|5
operator|)
operator|&&
operator|(
operator|(
name|BitNumber
operator|%
literal|10
operator|)
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|RateCorrection
operator|<
literal|0
condition|)
block|{
comment|// Need to remove cycles to catch up.
if|if
condition|(
operator|(
name|HexValue
operator|&
name|arg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M5
operator|-
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M5
operator|-
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|1
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"x"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M8
operator|-
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M8
operator|-
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|1
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"o"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of true clause for "if  (RateCorrection< 0)"
else|else
block|{
comment|// Else clause for "if  (RateCorrection< 0)"
if|if
condition|(
name|RateCorrection
operator|>
literal|0
condition|)
block|{
comment|// Need to add cycles to slow back down.
if|if
condition|(
operator|(
name|HexValue
operator|&
name|arg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M5
operator|+
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M5
operator|+
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|1
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"+"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M8
operator|+
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M8
operator|+
literal|1
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|1
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"*"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of true clause for "if  (RateCorrection> 0)"
else|else
block|{
comment|// Else clause for "if  (RateCorrection> 0)"
comment|// Rate is OK, just do what you feel!
if|if
condition|(
operator|(
name|HexValue
operator|&
name|arg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"1"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"0"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of else clause for "if  (RateCorrection> 0)"
block|}
comment|// End of else claues for "if  (RateCorrection< 0)"
block|}
comment|// End of true clause for "if  ((FrameNumber == 5)&& (BitNumber == 8))"
else|else
block|{
comment|// Else clause for "if  ((FrameNumber == 5)&& (BitNumber == 8))"
if|if
condition|(
operator|(
name|HexValue
operator|&
name|arg
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M5
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"1"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"0"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end of else clause for "if  ((FrameNumber == 5)&& (BitNumber == 8))"
break|break;
case|case
name|DECZ
case|:
comment|/* decrement pointer and send zero bit */
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|M2
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|M8
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"-"
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEC
case|:
comment|/* send marker/position indicator IM/PI bit */
name|ptr
operator|--
expr_stmt|;
case|case
name|NODEC
case|:
comment|/* send marker/position indicator IM/PI bit but no decrement pointer */
case|case
name|MIN
case|:
comment|/* send "second start" marker/position indicator IM/PI bit */
if|if
condition|(
name|Unmodulated
condition|)
block|{
name|poop
argument_list|(
name|arg
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
name|poop
argument_list|(
literal|10
operator|-
name|arg
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|,
name|UnmodulatedInverted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|arg
argument_list|,
literal|1000
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
name|peep
argument_list|(
literal|10
operator|-
name|arg
argument_list|,
literal|1000
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|OutputDataString
argument_list|,
literal|"."
argument_list|,
name|OUTPUT_DATA_STRING_LENGTH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n\nUnknown state machine value \"%d\", unable to continue, aborting...\n\n"
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ptr
operator|<
literal|0
condition|)
break|break;
block|}
name|ReverseString
argument_list|(
name|OutputDataString
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|OutputDataString
argument_list|)
expr_stmt|;
if|if
condition|(
name|RateCorrection
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" fast\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|RateCorrection
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|" slow\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 		 * The WWV/H second consists of 9 BCD digits of width- 		 * modulateod pulses 200, 500 and 800 ms at 100-Hz. 		 */
case|case
name|WWV
case|:
name|sw
operator|=
name|progx
index|[
name|Second
index|]
operator|.
name|sw
expr_stmt|;
name|arg
operator|=
name|progx
index|[
name|Second
index|]
operator|.
name|arg
expr_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
case|case
name|DATA
case|:
comment|/* send data bit */
name|WWV_Second
argument_list|(
name|arg
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|DATA0
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|DATA1
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|PI
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|DATAX
case|:
comment|/* send data bit */
name|WWV_SecondNoTick
argument_list|(
name|arg
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|DATA0
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|DATA1
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|PI
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|COEF
case|:
comment|/* send BCD bit */
if|if
condition|(
name|code
index|[
name|ptr
index|]
operator|&
name|arg
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA1
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEAP
case|:
comment|/* send leap bit */
if|if
condition|(
name|leap
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA1
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DEC
case|:
comment|/* send data bit */
name|ptr
operator|--
expr_stmt|;
name|WWV_Second
argument_list|(
name|arg
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|DATA0
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|DATA1
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|PI
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|DECX
case|:
comment|/* send data bit with no tick */
name|ptr
operator|--
expr_stmt|;
name|WWV_SecondNoTick
argument_list|(
name|arg
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|DATA0
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|DATA1
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|PI
condition|)
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|MIN
case|:
comment|/* send minute sync */
if|if
condition|(
name|Minute
operator|==
literal|0
condition|)
block|{
name|peep
argument_list|(
name|arg
argument_list|,
name|HourTone
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
if|if
condition|(
name|RateCorrection
operator|<
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|990
operator|-
name|arg
argument_list|,
name|HourTone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Shorter Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RateCorrection
operator|>
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|1010
operator|-
name|arg
argument_list|,
name|HourTone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Longer Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
literal|1000
operator|-
name|arg
argument_list|,
name|HourTone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"H"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
name|arg
argument_list|,
name|tone
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
if|if
condition|(
name|RateCorrection
operator|<
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|990
operator|-
name|arg
argument_list|,
name|tone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Shorter Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RateCorrection
operator|>
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|1010
operator|-
name|arg
argument_list|,
name|tone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Longer Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|peep
argument_list|(
literal|1000
operator|-
name|arg
argument_list|,
name|tone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"M"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DUT1
case|:
comment|/* send DUT1 bits */
if|if
condition|(
name|dut1
operator|&
name|arg
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA1
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DST1
case|:
comment|/* send DST1 bit */
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
name|DstFlag
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA1
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DST2
case|:
comment|/* send DST2 bit */
if|if
condition|(
name|DstFlag
condition|)
block|{
name|WWV_Second
argument_list|(
name|DATA1
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WWV_Second
argument_list|(
name|DATA0
argument_list|,
name|RateCorrection
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|EnableRateCorrection
condition|)
block|{
name|SecondsRunningSimulationTime
operator|++
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|TimeValue
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NowRealTime
operator|=
name|TimeValue
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|NowRealTime
operator|>=
name|BaseRealTime
condition|)
comment|// Just in case system time corrects backwards, do not blow up.
block|{
name|SecondsRunningRealTime
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|NowRealTime
operator|-
name|BaseRealTime
argument_list|)
expr_stmt|;
name|SecondsRunningDifference
operator|=
name|SecondsRunningSimulationTime
operator|-
name|SecondsRunningRealTime
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"> NowRealTime = 0x%8.8X, BaseRealtime = 0x%8.8X, SecondsRunningRealTime = 0x%8.8X, SecondsRunningSimulationTime = 0x%8.8X.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|NowRealTime
argument_list|,
operator|(
name|unsigned
operator|)
name|BaseRealTime
argument_list|,
name|SecondsRunningRealTime
argument_list|,
name|SecondsRunningSimulationTime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"> SecondsRunningDifference = 0x%8.8X, ExpectedRunningDifference = 0x%8.8X.\n"
argument_list|,
name|SecondsRunningDifference
argument_list|,
name|ExpectedRunningDifference
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SecondsRunningSimulationTime
operator|>
name|RUN_BEFORE_STABILITY_CHECK
condition|)
block|{
if|if
condition|(
name|StabilityCount
operator|<
name|MINIMUM_STABILITY_COUNT
condition|)
block|{
if|if
condition|(
name|StabilityCount
operator|==
literal|0
condition|)
block|{
name|ExpectedRunningDifference
operator|=
name|SecondsRunningDifference
expr_stmt|;
name|StabilityCount
operator|++
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Starting stability check.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Else for "if  (StabilityCount == 0)"
if|if
condition|(
operator|(
name|ExpectedRunningDifference
operator|+
name|INITIAL_STABILITY_BAND
operator|>
name|SecondsRunningDifference
operator|)
operator|&&
operator|(
name|ExpectedRunningDifference
operator|-
name|INITIAL_STABILITY_BAND
operator|<
name|SecondsRunningDifference
operator|)
condition|)
block|{
comment|// So far, still within stability band, increment count.
name|StabilityCount
operator|++
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> StabilityCount = %d.\n"
argument_list|,
name|StabilityCount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Outside of stability band, start over.
name|StabilityCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Out of stability band, start over.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of else for "if  (StabilityCount == 0)"
block|}
comment|// End of true clause for "if  (StabilityCount< MINIMUM_STABILITY_COUNT))"
else|else
block|{
comment|// Else clause for "if  (StabilityCount< MINIMUM_STABILITY_COUNT))" - OK, so we are supposed to be stable.
if|if
condition|(
name|AddCycle
condition|)
block|{
if|if
condition|(
name|ExpectedRunningDifference
operator|>=
name|SecondsRunningDifference
condition|)
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Was adding cycles, ExpectedRunningDifference>= SecondsRunningDifference, can stop it now.\n"
argument_list|)
expr_stmt|;
name|AddCycle
operator|=
name|FALSE
expr_stmt|;
name|RemoveCycle
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Was adding cycles, not done yet.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|RemoveCycle
condition|)
block|{
if|if
condition|(
name|ExpectedRunningDifference
operator|<=
name|SecondsRunningDifference
condition|)
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Was removing cycles, ExpectedRunningDifference<= SecondsRunningDifference, can stop it now.\n"
argument_list|)
expr_stmt|;
name|AddCycle
operator|=
name|FALSE
expr_stmt|;
name|RemoveCycle
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Was removing cycles, not done yet.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ExpectedRunningDifference
operator|+
name|RUNNING_STABILITY_BAND
operator|>
name|SecondsRunningDifference
operator|)
operator|&&
operator|(
name|ExpectedRunningDifference
operator|-
name|RUNNING_STABILITY_BAND
operator|<
name|SecondsRunningDifference
operator|)
condition|)
block|{
comment|// All is well, within tolerances.
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> All is well, within tolerances.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Oops, outside tolerances.  Else clause of "if  ((ExpectedRunningDifference...SecondsRunningDifference)"
if|if
condition|(
name|ExpectedRunningDifference
operator|>
name|SecondsRunningDifference
condition|)
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> ExpectedRunningDifference> SecondsRunningDifference, running behind real time.\n"
argument_list|)
expr_stmt|;
comment|// Behind real time, have to add a cycle to slow down and get back in sync.
name|AddCycle
operator|=
name|FALSE
expr_stmt|;
name|RemoveCycle
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|// Else clause of "if  (ExpectedRunningDifference< SecondsRunningDifference)"
if|if
condition|(
name|ExpectedRunningDifference
operator|<
name|SecondsRunningDifference
condition|)
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> ExpectedRunningDifference< SecondsRunningDifference, running ahead of real time.\n"
argument_list|)
expr_stmt|;
comment|// Ahead of real time, have to remove a cycle to speed up and get back in sync.
name|AddCycle
operator|=
name|TRUE
expr_stmt|;
name|RemoveCycle
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Oops, outside tolerances, but doesn't fit the profiles, how can this be?\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of else clause of "if  (ExpectedRunningDifference> SecondsRunningDifference)"
block|}
comment|// End of else clause of "if  ((ExpectedRunningDifference...SecondsRunningDifference)"
block|}
comment|// End of else clause of "if  (RemoveCycle)".
block|}
comment|// End of else clause of "if  (AddCycle)".
block|}
comment|// End of else clause for "if  (StabilityCount< MINIMUM_STABILITY_COUNT))"
block|}
comment|// End of true clause for "if  ((SecondsRunningSimulationTime> RUN_BEFORE_STABILITY_CHECK)"
block|}
comment|// End of true clause for "if  (NowRealTime>= BaseRealTime)"
else|else
block|{
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"> Hmm, time going backwards?\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// End of true clause for "if  (EnableRateCorrection)"
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n>> Completed %d seconds, exiting...\n\n"
argument_list|,
name|SecondsToSend
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Generate WWV/H 0 or 1 data pulse.  */
name|void
name|WWV_Second
parameter_list|(
name|int
name|code
parameter_list|,
comment|/* DATA0, DATA1, PI */
name|int
name|Rate
comment|/*<0 -> do a short second, 0 -> normal second,>0 -> long second */
parameter_list|)
block|{
comment|/* 	 * The WWV data pulse begins with 5 ms of 1000 Hz follwed by a 	 * guard time of 25 ms. The data pulse is 170, 570 or 770 ms at 	 * 100 Hz corresponding to 0, 1 or position indicator (PI), 	 * respectively. Note the 100-Hz data pulses are transmitted 6 	 * dB below the 1000-Hz sync pulses. Originally the data pulses 	 * were transmited 10 dB below the sync pulses, but the station 	 * engineers increased that to 6 dB because the Heath GC-1000 	 * WWV/H radio clock worked much better. 	 */
name|peep
argument_list|(
literal|5
argument_list|,
name|tone
argument_list|,
name|HIGH
argument_list|)
expr_stmt|;
comment|/* send seconds tick */
name|peep
argument_list|(
literal|25
argument_list|,
name|tone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|peep
argument_list|(
name|code
operator|-
literal|30
argument_list|,
literal|100
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
comment|/* send data */
comment|/* The quiet time is shortened or lengthened to get us back on time */
if|if
condition|(
name|Rate
operator|<
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|990
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Shorter Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Rate
operator|>
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|1010
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Longer Second: "
argument_list|)
expr_stmt|;
block|}
else|else
name|peep
argument_list|(
literal|1000
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Generate WWV/H 0 or 1 data pulse, with no tick, for 29th and 59th seconds  */
name|void
name|WWV_SecondNoTick
parameter_list|(
name|int
name|code
parameter_list|,
comment|/* DATA0, DATA1, PI */
name|int
name|Rate
comment|/*<0 -> do a short second, 0 -> normal second,>0 -> long second */
parameter_list|)
block|{
comment|/* 	 * The WWV data pulse begins with 5 ms of 1000 Hz follwed by a 	 * guard time of 25 ms. The data pulse is 170, 570 or 770 ms at 	 * 100 Hz corresponding to 0, 1 or position indicator (PI), 	 * respectively. Note the 100-Hz data pulses are transmitted 6 	 * dB below the 1000-Hz sync pulses. Originally the data pulses 	 * were transmited 10 dB below the sync pulses, but the station 	 * engineers increased that to 6 dB because the Heath GC-1000 	 * WWV/H radio clock worked much better. 	 */
name|peep
argument_list|(
literal|30
argument_list|,
name|tone
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
comment|/* send seconds non-tick */
name|peep
argument_list|(
name|code
operator|-
literal|30
argument_list|,
literal|100
argument_list|,
name|LOW
argument_list|)
expr_stmt|;
comment|/* send data */
comment|/* The quiet time is shortened or lengthened to get us back on time */
if|if
condition|(
name|Rate
operator|<
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|990
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesRemoved
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Shorter Second: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Rate
operator|>
literal|0
condition|)
block|{
name|peep
argument_list|(
literal|1010
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
name|TotalCyclesAdded
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n* Longer Second: "
argument_list|)
expr_stmt|;
block|}
else|else
name|peep
argument_list|(
literal|1000
operator|-
name|code
argument_list|,
literal|100
argument_list|,
name|OFF
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Generate cycles of 100 Hz or any multiple of 100 Hz.  */
name|void
name|peep
parameter_list|(
name|int
name|pulse
parameter_list|,
comment|/* pulse length (ms) */
name|int
name|freq
parameter_list|,
comment|/* frequency (Hz) */
name|int
name|amp
comment|/* amplitude */
parameter_list|)
block|{
name|int
name|increm
decl_stmt|;
comment|/* phase increment */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|amp
operator|==
name|OFF
operator|||
name|freq
operator|==
literal|0
condition|)
name|increm
operator|=
literal|10
expr_stmt|;
else|else
name|increm
operator|=
name|freq
operator|/
literal|100
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pulse
operator|*
literal|8
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|amp
condition|)
block|{
case|case
name|HIGH
case|:
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|c6000
index|[
name|j
index|]
expr_stmt|;
break|break;
case|case
name|LOW
case|:
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|c3000
index|[
name|j
index|]
expr_stmt|;
break|break;
default|default:
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bufcnt
operator|>=
name|BUFLNG
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFLNG
argument_list|)
expr_stmt|;
name|bufcnt
operator|=
literal|0
expr_stmt|;
block|}
name|j
operator|=
operator|(
name|j
operator|+
name|increm
operator|)
operator|%
literal|80
expr_stmt|;
block|}
block|}
comment|/*  * Generate unmodulated from similar tables.  */
name|void
name|poop
parameter_list|(
name|int
name|pulse
parameter_list|,
comment|/* pulse length (ms) */
name|int
name|freq
parameter_list|,
comment|/* frequency (Hz) */
name|int
name|amp
parameter_list|,
comment|/* amplitude */
name|int
name|inverted
comment|/* is upside down */
parameter_list|)
block|{
name|int
name|increm
decl_stmt|;
comment|/* phase increment */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|amp
operator|==
name|OFF
operator|||
name|freq
operator|==
literal|0
condition|)
name|increm
operator|=
literal|10
expr_stmt|;
else|else
name|increm
operator|=
name|freq
operator|/
literal|100
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pulse
operator|*
literal|8
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|amp
condition|)
block|{
case|case
name|HIGH
case|:
if|if
condition|(
name|inverted
condition|)
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|u3000
index|[
name|j
index|]
expr_stmt|;
else|else
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|u6000
index|[
name|j
index|]
expr_stmt|;
break|break;
case|case
name|LOW
case|:
if|if
condition|(
name|inverted
condition|)
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|u6000
index|[
name|j
index|]
expr_stmt|;
else|else
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
name|u3000
index|[
name|j
index|]
expr_stmt|;
break|break;
default|default:
name|buffer
index|[
name|bufcnt
operator|++
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bufcnt
operator|>=
name|BUFLNG
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFLNG
argument_list|)
expr_stmt|;
name|bufcnt
operator|=
literal|0
expr_stmt|;
block|}
name|j
operator|=
operator|(
name|j
operator|+
name|increm
operator|)
operator|%
literal|80
expr_stmt|;
block|}
block|}
comment|/*  * Delay for initial phasing  */
name|void
name|delay
parameter_list|(
name|int
name|Delay
comment|/* delay in samples */
parameter_list|)
block|{
name|int
name|samples
decl_stmt|;
comment|/* samples remaining */
name|samples
operator|=
name|Delay
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|BUFLNG
argument_list|)
expr_stmt|;
while|while
condition|(
name|samples
operator|>=
name|BUFLNG
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|BUFLNG
argument_list|)
expr_stmt|;
name|samples
operator|-=
name|BUFLNG
expr_stmt|;
block|}
name|write
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|samples
argument_list|)
expr_stmt|;
block|}
comment|/* Calc day of year from year month& day */
comment|/* Year - 0 means 2000, 100 means 2100. */
comment|/* Month - 1 means January, 12 means December. */
comment|/* DayOfMonth - 1 is first day of month */
name|int
name|ConvertMonthDayToDayOfYear
parameter_list|(
name|int
name|YearValue
parameter_list|,
name|int
name|MonthValue
parameter_list|,
name|int
name|DayOfMonthValue
parameter_list|)
block|{
name|int
name|ReturnValue
decl_stmt|;
name|int
name|LeapYear
decl_stmt|;
name|int
name|MonthCounter
decl_stmt|;
comment|/* Array of days in a month.  Note that here January is zero. */
comment|/* NB: have to add 1 to days in February in a leap year! */
name|int
name|DaysInMonth
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|LeapYear
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|YearValue
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|YearValue
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|YearValue
operator|%
literal|400
operator|)
operator|==
literal|0
condition|)
block|{
name|LeapYear
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|LeapYear
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\nConvertMonthDayToDayOfYear(): Year %d %s a leap year.\n"
argument_list|,
name|YearValue
operator|+
literal|2000
argument_list|,
name|LeapYear
condition|?
literal|"is"
else|:
literal|"is not"
argument_list|)
expr_stmt|;
comment|/* Day of month given us starts in this algorithm. */
name|ReturnValue
operator|=
name|DayOfMonthValue
expr_stmt|;
comment|/* Add in days in month for each month past January. */
for|for
control|(
name|MonthCounter
operator|=
literal|1
init|;
name|MonthCounter
operator|<
name|MonthValue
condition|;
name|MonthCounter
operator|++
control|)
block|{
name|ReturnValue
operator|+=
name|DaysInMonth
index|[
name|MonthCounter
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* Add a day for leap years where we are past February. */
if|if
condition|(
operator|(
name|LeapYear
operator|)
operator|&&
operator|(
name|MonthValue
operator|>
literal|2
operator|)
condition|)
block|{
name|ReturnValue
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\nConvertMonthDayToDayOfYear(): %4.4d-%2.2d-%2.2d represents day %3d of year.\n"
argument_list|,
name|YearValue
operator|+
literal|2000
argument_list|,
name|MonthValue
argument_list|,
name|DayOfMonthValue
argument_list|,
name|ReturnValue
argument_list|)
expr_stmt|;
return|return
operator|(
name|ReturnValue
operator|)
return|;
block|}
name|void
name|Help
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n\nTime Code Generation - IRIG-B or WWV, v%d.%d, %s dmw"
argument_list|,
name|VERSION
argument_list|,
name|ISSUE
argument_list|,
name|ISSUE_DATE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nRCS Info:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  $Header: /home/dmw/src/IRIG_generation/ntp-4.2.2p3/util/RCS/tg.c,v 1.28 2007/02/12 23:57:45 dmw Exp $"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nUsage: %s [option]*"
argument_list|,
name|CommandName
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nOptions: -a device_name                 Output audio device name (default /dev/audio)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -b yymmddhhmm                  Remove leap second at end of minute specified"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -c seconds_to_send             Number of seconds to send (default 0 = forever)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -d                             Start with IEEE 1344 DST active"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -f format_type                 i = Modulated IRIG-B 1998 (no year coded)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                                        2 = Modulated IRIG-B 2002 (year coded)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                                        3 = Modulated IRIG-B w/IEEE 1344 (year& control funcs) (default)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                                        4 = Unmodulated IRIG-B w/IEEE 1344 (year& control funcs)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                                        5 = Inverted unmodulated IRIG-B w/IEEE 1344 (year& control funcs)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                                        w = WWV(H)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -g yymmddhhmm                  Switch into/out of DST at beginning of minute specified"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -i yymmddhhmm                  Insert leap second at end of minute specified"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -j                             Disable time rate correction against system clock (default enabled)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -k nn                          Force rate correction for testing (+1 = add cycle, -1 = remove cycle)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -l time_offset                 Set offset of time sent to UTC as per computer, +/- float hours"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -o time_offset                 Set IEEE 1344 time offset, +/-, to 0.5 hour (default 0)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -q quality_code_hex            Set IEEE 1344 quality code (default 0)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -r sample_rate                 Audio sample rate (default 8000)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -s                             Set leap warning bit (WWV[H] only)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -t sync_frequency              WWV(H) on-time pulse tone frequency (default 1200)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -u DUT1_offset                 Set WWV(H) DUT1 offset -7 to +7 (default 0)"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_SYS_SOUNDCARD_H
name|printf
argument_list|(
literal|"\n         -v initial_output_level        Set initial output level (default %d, must be 0 to 255)"
argument_list|,
name|AUDIO_MAX_GAIN
operator|/
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n         -x                             Turn off verbose output (default on)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n         -y yymmddhhmmss                Set initial date and time as specified (default system time)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nThis software licenced under the GPL, modifications performed 2006& 2007 by Dean Weiten"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nContact: Dean Weiten, Norscan Instruments Ltd., Winnipeg, MB, Canada, ph (204)-233-9138, E-mail dmw@norscan.com"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Reverse string order for nicer print. */
name|void
name|ReverseString
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|StringLength
decl_stmt|;
name|int
name|IndexCounter
decl_stmt|;
name|int
name|CentreOfString
decl_stmt|;
name|char
name|TemporaryCharacter
decl_stmt|;
name|StringLength
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|CentreOfString
operator|=
operator|(
name|StringLength
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|IndexCounter
operator|=
name|StringLength
init|;
name|IndexCounter
operator|>=
name|CentreOfString
condition|;
name|IndexCounter
operator|--
control|)
block|{
name|TemporaryCharacter
operator|=
name|str
index|[
name|IndexCounter
operator|-
literal|1
index|]
expr_stmt|;
name|str
index|[
name|IndexCounter
operator|-
literal|1
index|]
operator|=
name|str
index|[
name|StringLength
operator|-
name|IndexCounter
index|]
expr_stmt|;
name|str
index|[
name|StringLength
operator|-
name|IndexCounter
index|]
operator|=
name|TemporaryCharacter
expr_stmt|;
block|}
block|}
end_function

end_unit

