begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Program to generate MD5 and RSA keys for NTP clients and servers  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_include
include|#
directive|include
file|<netinfo/ni.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntpd.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_string.h"
end_include

begin_include
include|#
directive|include
file|"ntp_filegen.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp_config.h"
end_include

begin_include
include|#
directive|include
file|"ntp_cmdargs.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/* PATH_MAX */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PUBKEY
end_ifdef

begin_include
include|#
directive|include
file|"ntp_crypto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_PATH_MAX
end_ifdef

begin_define
define|#
directive|define
name|PATH_MAX
value|_POSIX_PATH_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Cryptodefines  */
end_comment

begin_define
define|#
directive|define
name|MAXKEYLEN
value|1024
end_define

begin_comment
comment|/* maximum encoded key length */
end_comment

begin_define
define|#
directive|define
name|MODULUSLEN
value|512
end_define

begin_comment
comment|/* length of RSA modulus */
end_comment

begin_define
define|#
directive|define
name|PRIMELEN
value|512
end_define

begin_comment
comment|/* length of D_H prime, generator */
end_comment

begin_comment
comment|/*  * This program generates (up to) four files:  *  *	ntp.keys    containing the DES/MD5 private keys,  *	ntpkey      containing the RSA private key,  *	ntpkey_HOST containing the RSA public key  *		     where HOST is the DNS name of the generating machine,  *	ntpkey_dh   containing the parameters for the Diffie-Hellman  *		    key-agreement algorithm.  *  * The files contain cryptographic values generated by the algorithms of  * the rsaref20 package and are in printable ASCII format.  Since the  * algorythms are seeded by the system clock, each run of this program  * will produce a different outcome.  There are no options or frills of  * any sort, although a number of options would seem to be appropriate.  * Waving this program in the breeze will no doubt bring a cast of  * thousands to wiggle the options this way and that for various useful  * purposes.  *  * The names of all files begin with "ntp" and end with an extension  * consisting of the seconds value of the current NTP timestamp, which  * appears in the form ".*".  This provides a way to distinguish between  * key generations, since the host name and timestamp can be fetched by  * a client during operation.  *  * The ntp.keys.* file contains 16 MD5 keys.  Each key consists of 16  * characters randomized over the ASCII 95-character printing subset.  * The file is read by the daemon at the location specified by the keys  * configuration file command and made visible only to root.  An  * additional key consisting of a easily remembered password should be  * added by hand for use with the ntpdc program.  The file must be  * distributed by secure means to other servers and clients sharing the  * same security compartment.  *  * The key identifiers for MD5 and DES keys must be less than 65536,  * although this program uses only the identifiers from 1 to 16.  The key  * identifier for each association is specified as the key argument in  * the server or peer configuration file command.  *  * The ntpkey.* file contains the RSA private key.  It is read by the  * daemon at the location specified by the private argument of the  * crypto configuration file command and made visible only to root.  * This file is useful only to the machine that generated it and never  * shared with any other daemon or application program.  *  * The ntpkey_host.* file contains the RSA public key, where host is the  * DNS name of the host that generated it.  The file is read by the  * daemon at the location specified by the public argument to the server  * or peer configuration file command.  This file can be widely  * distributed and stored without using secure means, since the data are  * public values.  *  * The ntp_dh.* file contains two Diffie-Hellman parameters, the prime  * modulus and the generator.  The file is read by the daemon at the  * location specified by the dhparams argument of the crypto  * configuration file command.  This file can be widely distributed and  * stored without using secure means, since the data are public values.  *  * The file formats all begin with two lines.  The first line contains  * the file name and decimal timestamp, while the second contains the  * readable datestamp.  Lines beginning with # are considered comments  * and ignored by the daemon.  In the ntp.keys.* file, the next 16 lines  * contain the MD5 keys in order.  In the ntpkey.* and ntpkey_host.*  * files, the next line contains the modulus length in bits followed by  * the key as a PEM encoded string.  In the ntpkey_dh.* file, the next  * line contains the prime length in bytes followed by the prime as a  * PEM encoded string, and the next and final line contains the  * generator length in bytes followed by the generator as a PEM encoded  * string.  *  * Note: See the file ./source/rsaref.h in the rsaref20 package for  * explanation of return values, if necessary.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|config_file
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETINFO
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|netinfo_config_state
modifier|*
name|config_netinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|check_netinfo
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_NETINFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|alt_config_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPTSTR
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|config_file_storage
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|alt_config_file_storage
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_decl_stmt
name|int
name|make_dh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make D-H parameter file? */
end_comment

begin_decl_stmt
name|int
name|make_md5
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make MD5 keyfile? */
end_comment

begin_decl_stmt
name|int
name|make_rsa
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make RSA pair? */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the installation? */
end_comment

begin_decl_stmt
name|int
name|here
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put the files here (curdir)? */
end_comment

begin_decl_stmt
name|int
name|nosymlinks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Just create the (timestamped) files? */
end_comment

begin_decl_stmt
name|int
name|memorex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we live? */
end_comment

begin_decl_stmt
name|int
name|trash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Trash old files? */
end_comment

begin_decl_stmt
name|int
name|errflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f1_keysdir
init|=
name|NTP_KEYSDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f1_keys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Visible MD5 key file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f2_keys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timestamped */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f3_keys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous filename */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f1_publickey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f2_publickey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f3_publickey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f1_privatekey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f2_privatekey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f3_privatekey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f1_dhparms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f2_dhparms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|f3_dhparms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stubs and hacks so we can link with ntp_config.o */
end_comment

begin_decl_stmt
name|u_long
name|sys_automax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum session key lifetime */
end_comment

begin_decl_stmt
name|int
name|sys_bclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we set our time to broadcasts */
end_comment

begin_decl_stmt
name|int
name|sys_manycastserver
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => respond to manycast client pkts */
end_comment

begin_decl_stmt
name|u_long
name|client_limit_period
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|req_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the file with configuration info */
end_comment

begin_decl_stmt
name|keyid_t
name|ctl_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyid used for authenticating write requests */
end_comment

begin_decl_stmt
name|struct
name|interface
modifier|*
name|any_interface
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default interface */
end_comment

begin_decl_stmt
name|keyid_t
name|info_auth_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyid used to authenticate requests */
end_comment

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time (s) */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|Version
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* version declaration */
end_comment

begin_decl_stmt
name|keyid_t
name|req_keyid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request keyid */
end_comment

begin_decl_stmt
name|u_long
name|client_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|client_limit_period
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|l_fp
name|sys_revoketime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|sys_revoke
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keys revoke timeout */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging flag */
end_comment

begin_decl_stmt
name|u_char
name|sys_minpoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min poll interval (log2 s) */
end_comment

begin_decl_stmt
name|void
name|snifflink
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filep
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|newfile
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|mode_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cleanlinks
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|peer
modifier|*
name|peer_config
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|srcadr
parameter_list|,
name|struct
name|interface
modifier|*
name|dstadr
parameter_list|,
name|int
name|hmode
parameter_list|,
name|int
name|version
parameter_list|,
name|int
name|minpoll
parameter_list|,
name|int
name|maxpoll
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int
name|ttl
parameter_list|,
name|keyid_t
name|key
parameter_list|,
name|u_char
modifier|*
name|keystr
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"peer_config...\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|set_sys_var
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|u_long
name|size
parameter_list|,
name|int
name|def
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"set_sys_var...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ntp_intres
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"ntp_intres...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ctlsettrap
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|raddr
parameter_list|,
name|struct
name|interface
modifier|*
name|linter
parameter_list|,
name|int
name|traptype
parameter_list|,
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"ctlsettrap...\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUBKEY
end_ifdef

begin_function
name|void
name|crypto_config
parameter_list|(
name|int
name|item
parameter_list|,
comment|/* configuration item */
name|char
modifier|*
name|cp
comment|/* file name */
parameter_list|)
block|{
switch|switch
condition|(
name|item
condition|)
block|{
case|case
name|CRYPTO_CONF_DH
case|:
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"crypto_config: DH/<%d><%s>\n"
argument_list|,
name|item
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|f1_dhparms
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_CONF_PRIV
case|:
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"crypto_config: PRIVATEKEY/<%d><%s>\n"
argument_list|,
name|item
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|f1_privatekey
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_CONF_PUBL
case|:
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"crypto_config: PUBLICKEY/<%d><%s>\n"
argument_list|,
name|item
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|f1_publickey
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"crypto_config:<%d><%s>\n"
argument_list|,
name|item
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|interface
modifier|*
name|findinterface
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"findinterface...\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|refclock_control
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|srcadr
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|in
parameter_list|,
name|struct
name|refclockstat
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"refclock_control...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|loop_config
parameter_list|(
name|int
name|item
parameter_list|,
name|double
name|freq
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"loop_config...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|filegen_config
parameter_list|(
name|FILEGEN
modifier|*
name|gen
parameter_list|,
name|char
modifier|*
name|basename
parameter_list|,
name|u_int
name|type
parameter_list|,
name|u_int
name|flag
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"filegen_config...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|stats_config
parameter_list|(
name|int
name|item
parameter_list|,
name|char
modifier|*
name|invalue
comment|/* only one type so far */
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"stats_config...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|hack_restrict
parameter_list|(
name|int
name|op
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|resaddr
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|resmask
parameter_list|,
name|int
name|mflags
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"hack_restrict...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"kill_asyncio...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|proto_config
parameter_list|(
name|int
name|item
parameter_list|,
name|u_long
name|value
parameter_list|,
name|double
name|dvalue
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"proto_config...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|getauthkeys
parameter_list|(
name|char
modifier|*
name|keyfile
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"getauthkeys: got<%s>\n"
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
name|f1_keys
operator|=
name|strdup
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|FILEGEN
modifier|*
name|filegen_get
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"filegen_get...\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* End of stubs and hacks */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [ -c ntp.conf ] [ -g {d,m,r} ] [ -k key_file ]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       [ -d ] [ -f ] [ -h ] [ -l ] [ -n ] [ -t ]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" where:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -c /etc/ntp.conf   Location of ntp.conf file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -d     enable debug messages (can be used multiple times)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -f     force installation of generated keys.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g d   Generate D-H parameter file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g m   Generate MD5 key file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g r   Generate RSA keys\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g dmr (Can be combined)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -h     Build keys here (current directory). Implies -l\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -k key_file        Location of key file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -l     Don't make the symlinks\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -n     Don't actually do anything, just say what would be done\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -t     Trash the (old) files at the end of symlink\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getCmdOpts
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:dfg:hlnt"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'c'
case|:
name|config_file
operator|=
name|ntp_optarg
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NETINFO
name|check_netinfo
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'d'
case|:
operator|++
name|debug
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|force
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
while|while
condition|(
operator|*
name|ntp_optarg
condition|)
block|{
switch|switch
condition|(
operator|*
name|ntp_optarg
condition|)
block|{
case|case
literal|'d'
case|:
operator|++
name|make_dh
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
operator|++
name|make_md5
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|++
name|make_rsa
expr_stmt|;
break|break;
default|default:
operator|++
name|errflag
expr_stmt|;
break|break;
block|}
operator|++
name|ntp_optarg
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
operator|++
name|here
expr_stmt|;
operator|++
name|nosymlinks
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|++
name|nosymlinks
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|++
name|memorex
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|++
name|trash
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|errflag
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|errflag
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* If no file type was specified, make them all. */
if|if
condition|(
operator|!
operator|(
name|make_dh
operator||
name|make_md5
operator||
name|make_rsa
operator|)
condition|)
block|{
operator|++
name|make_dh
expr_stmt|;
operator|++
name|make_md5
expr_stmt|;
operator|++
name|make_rsa
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|snifflink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|linkdata
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_READLINK
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
name|rc
operator|=
name|readlink
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
comment|/* Fall thru */
case|case
name|ENOENT
case|:
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: readlink(%s) failed: (%d) %s\n"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|rc
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|linkdata
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX: make sure linkdata is not 0... */
endif|#
directive|endif
comment|/* not HAVE_READLINK */
return|return;
block|}
end_function

begin_function
name|int
name|filep
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|ENOENT
operator|==
name|errno
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stat(%s) failed: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|newfile
parameter_list|(
specifier|const
name|char
modifier|*
name|f1
parameter_list|,
comment|/* Visible file */
specifier|const
name|char
modifier|*
name|f2
parameter_list|,
comment|/* New timestamped file name */
name|mode_t
name|fmask
parameter_list|,
comment|/* umask for new timestamped file */
specifier|const
name|char
modifier|*
name|f3
comment|/* Previous symlink target */
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|fb
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"newfile(%s,%s,%0o,%s)\n"
argument_list|,
name|f1
argument_list|,
name|f2
argument_list|,
operator|(
name|unsigned
operator|)
name|fmask
argument_list|,
name|f3
condition|?
name|f3
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
comment|/* 	   If: 	   - no symlink support, or 	   - there is no old symlink (!f3) 	   - - file = dirname(f1) / f2 	   Otherwise: 	   - If ('/' == *f3) 	   - - file = dirname(f3) / f2 	   - else 	   - - file = dirname(f1) / dirname(f3) / f2 	   fopen(file) 	   print any error message/bail 	   return FILE 	*/
if|if
condition|(
name|here
condition|)
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s"
argument_list|,
name|f2
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|HAVE_READLINK
operator|!
name|f3
else|#
directive|else
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* file = dirname(f1) / f2 */
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|fb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s/%s"
argument_list|,
name|fb
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"case 1: file is<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			  - If ('/' == *f3) 			  - - file = dirname(f3) / f2 			  - else 			  - - file = dirname(f1) / dirname(f3) / f2 			*/
if|if
condition|(
literal|'/'
operator|!=
operator|*
name|f3
condition|)
block|{
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|fb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|++
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"case 2: file is<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fb
operator|=
literal|0
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s%s"
argument_list|,
name|fb
argument_list|,
name|f3
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|fb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s/%s"
argument_list|,
name|fb
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"case 3: file is<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	  fopen(file) 	  print any error message/bail 	  return FILE 	*/
if|if
condition|(
name|memorex
condition|)
block|{
name|printf
argument_list|(
literal|"Would write file<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mode_t
name|omask
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|fmask
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fb
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fp
return|;
block|}
end_function

begin_function
name|void
name|cleanlinks
parameter_list|(
specifier|const
name|char
modifier|*
name|f1
parameter_list|,
comment|/* Visible file */
specifier|const
name|char
modifier|*
name|f2
parameter_list|,
comment|/* New timestamped file name */
specifier|const
name|char
modifier|*
name|f3
comment|/* Previous symlink target */
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_READLINK
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|fb
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* 	  Just return if nosymlinks. 	  unlink f1 	  file = dirname(f3) / f2 	  symlink file, f1 	  If trash: 	  - if f3 begins with a /, unlink it 	  - else, unlink dirname(f1) / f3 	*/
endif|#
directive|endif
comment|/* HAVE_READLINK */
if|if
condition|(
name|nosymlinks
condition|)
return|return;
if|if
condition|(
name|memorex
condition|)
name|printf
argument_list|(
literal|"Would unlink(%s)\n"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|f1
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unlink(%s) failed: %s\n"
argument_list|,
name|f1
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* file = dirname(f3) / f2 */
if|if
condition|(
name|f3
condition|)
block|{
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s"
argument_list|,
name|f3
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|fb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|++
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fb
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|fb
operator|=
literal|0
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s%s"
argument_list|,
name|fb
argument_list|,
name|f2
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"cleanlinks 1: file is<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|memorex
condition|)
name|printf
argument_list|(
literal|"Would symlink<%s> -><%s>\n"
argument_list|,
name|f1
argument_list|,
name|fb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symlink
argument_list|(
name|fb
argument_list|,
name|f1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"symlink(%s,%s) failed: %s\n"
argument_list|,
name|fb
argument_list|,
name|f1
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	  If trash: 	  - if f3 begins with a /, unlink it 	  - else, unlink dirname(f1) / f3 	*/
if|if
condition|(
name|trash
operator|&&
name|f3
condition|)
block|{
if|if
condition|(
literal|'/'
operator|==
operator|*
name|f3
condition|)
block|{
if|if
condition|(
name|memorex
condition|)
name|printf
argument_list|(
literal|"Would unlink(%s)\n"
argument_list|,
name|f3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|f3
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unlink(%s) failed: %s\n"
argument_list|,
name|f3
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s"
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|fb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|fb
argument_list|,
sizeof|sizeof
name|fb
argument_list|,
literal|"%s/%s"
argument_list|,
name|fb
argument_list|,
name|f3
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"cleanlinks 2: file is<%s>\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|memorex
condition|)
name|printf
argument_list|(
literal|"Would unlink(%s)\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|fb
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unlink(%s) failed: %s\n"
argument_list|,
name|fb
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PUBKEY
name|R_RSA_PRIVATE_KEY
name|rsaref_private
decl_stmt|;
comment|/* RSA private key */
name|R_RSA_PUBLIC_KEY
name|rsaref_public
decl_stmt|;
comment|/* RSA public key */
name|R_RSA_PROTO_KEY
name|protokey
decl_stmt|;
comment|/* RSA prototype key */
name|R_DH_PARAMS
name|dh_params
decl_stmt|;
comment|/* Diffie-Hellman parameters */
name|R_RANDOM_STRUCT
name|randomstr
decl_stmt|;
comment|/* random structure */
name|int
name|rval
decl_stmt|;
comment|/* return value */
name|u_char
name|encoded_key
index|[
name|MAXKEYLEN
index|]
decl_stmt|;
comment|/* encoded PEM string buffer */
name|u_int
name|modulus
decl_stmt|;
comment|/* modulus length */
name|u_int
name|len
decl_stmt|;
endif|#
directive|endif
comment|/* PUBKEY */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* initialization vector */
name|u_long
name|ntptime
decl_stmt|;
comment|/* NTP timestamp */
name|char
name|hostname
index|[
literal|256
index|]
decl_stmt|;
comment|/* DNS host name */
name|u_char
name|md5key
index|[
literal|17
index|]
decl_stmt|;
comment|/* generated MD5 key */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|u_int
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mode_t
name|std_mask
decl_stmt|;
comment|/* Standard mask */
name|mode_t
name|sec_mask
init|=
literal|077
decl_stmt|;
comment|/* Secure mask */
name|char
name|pathbuf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ntptime
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
comment|/* Initialize config_file */
name|getconfig
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* ntpd/ntp_config.c */
if|if
condition|(
operator|!
name|f1_keysdir
condition|)
block|{
comment|/* Shouldn't happen... */
name|f1_keysdir
operator|=
literal|"PATH_KEYSDIR"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f1_keysdir
operator|!=
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: keysdir path<%s> doesn't begin with a /\n"
argument_list|,
name|progname
argument_list|,
name|f1_keysdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f2_keys
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"ntp.keys.%lu"
argument_list|,
name|ntptime
argument_list|)
expr_stmt|;
name|f2_keys
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1_keys
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"%s/ntp.keys"
argument_list|,
name|f1_keysdir
argument_list|)
expr_stmt|;
name|f1_keys
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f1_keys
operator|!=
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: keys path<%s> doesn't begin with a /\n"
argument_list|,
name|progname
argument_list|,
name|f1_keys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snifflink
argument_list|(
name|f1_keys
argument_list|,
operator|&
name|f3_keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f2_publickey
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"ntpkey_%s.%lu"
argument_list|,
name|hostname
argument_list|,
name|ntptime
argument_list|)
expr_stmt|;
name|f2_publickey
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1_publickey
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"%s/ntpkey_%s"
argument_list|,
name|f1_keysdir
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|f1_publickey
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f1_publickey
operator|!=
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: publickey path<%s> doesn't begin with a /\n"
argument_list|,
name|progname
argument_list|,
name|f1_publickey
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snifflink
argument_list|(
name|f1_publickey
argument_list|,
operator|&
name|f3_publickey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f2_privatekey
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"ntpkey.%lu"
argument_list|,
name|ntptime
argument_list|)
expr_stmt|;
name|f2_privatekey
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1_privatekey
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"%s/ntpkey"
argument_list|,
name|f1_keysdir
argument_list|)
expr_stmt|;
name|f1_privatekey
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f1_privatekey
operator|!=
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: privatekey path<%s> doesn't begin with a /\n"
argument_list|,
name|progname
argument_list|,
name|f1_privatekey
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snifflink
argument_list|(
name|f1_privatekey
argument_list|,
operator|&
name|f3_privatekey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f2_dhparms
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"ntpkey_dh.%lu"
argument_list|,
name|ntptime
argument_list|)
expr_stmt|;
name|f2_dhparms
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f1_dhparms
condition|)
block|{
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|,
literal|"%s/ntpkey_dh"
argument_list|,
name|f1_keysdir
argument_list|)
expr_stmt|;
name|f1_dhparms
operator|=
name|strdup
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f1_dhparms
operator|!=
literal|'/'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dhparms path<%s> doesn't begin with a /\n"
argument_list|,
name|progname
argument_list|,
name|f1_dhparms
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|snifflink
argument_list|(
name|f1_dhparms
argument_list|,
operator|&
name|f3_dhparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"After config:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keysdir    =<%s>\n"
argument_list|,
name|f1_keysdir
condition|?
name|f1_keysdir
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keys       =<%s> -><%s>\n"
argument_list|,
name|f1_keys
condition|?
name|f1_keys
else|:
literal|""
argument_list|,
name|f2_keys
condition|?
name|f2_keys
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       old =<%s>\n"
argument_list|,
name|f3_keys
condition|?
name|f3_keys
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"publickey  =<%s> -><%s>\n"
argument_list|,
name|f1_publickey
condition|?
name|f1_publickey
else|:
literal|""
argument_list|,
name|f2_publickey
condition|?
name|f2_publickey
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       old =<%s>\n"
argument_list|,
name|f3_publickey
condition|?
name|f3_publickey
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"privatekey =<%s> -><%s>\n"
argument_list|,
name|f1_privatekey
condition|?
name|f1_privatekey
else|:
literal|""
argument_list|,
name|f2_privatekey
condition|?
name|f2_privatekey
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       old =<%s>\n"
argument_list|,
name|f3_privatekey
condition|?
name|f3_privatekey
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dhparms    =<%s> -><%s>\n"
argument_list|,
name|f1_dhparms
condition|?
name|f1_dhparms
else|:
literal|""
argument_list|,
name|f2_dhparms
condition|?
name|f2_dhparms
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       old =<%s>\n"
argument_list|,
name|f3_dhparms
condition|?
name|f3_dhparms
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* 	  for each file we're going to install: 	  - make the new timestamped file 	  - if (!nosymlinks) 	  - - remove any old link 	  - - make the link 	  - - if (trash) 	  - - - remove the old file 	*/
name|std_mask
operator|=
name|umask
argument_list|(
name|sec_mask
argument_list|)
expr_stmt|;
comment|/* Get the standard mask */
operator|(
name|void
operator|)
name|umask
argument_list|(
name|std_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_md5
operator|&&
operator|(
name|force
operator|||
operator|!
name|filep
argument_list|(
name|f1_keys
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Generate 16 random MD5 keys. 		 */
name|printf
argument_list|(
literal|"Generating MD5 key file...\n"
argument_list|)
expr_stmt|;
name|str
operator|=
name|newfile
argument_list|(
name|f1_keys
argument_list|,
name|f2_keys
argument_list|,
name|sec_mask
argument_list|,
name|f3_keys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memorex
condition|)
block|{
name|srandom
argument_list|(
operator|(
name|u_int
operator|)
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# MD5 key file %s\n# %s"
argument_list|,
name|f2_keys
argument_list|,
name|ctime
argument_list|(
operator|(
specifier|const
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|temp
operator|=
name|random
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|/* 						** Harlan says Karnaugh maps 						** are not his friend, and 						** compilers can optimize 						** this most easily. 						*/
if|if
condition|(
name|temp
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|temp
operator|>
literal|0x20
operator|&&
name|temp
operator|<
literal|0x7f
condition|)
break|break;
block|}
name|md5key
index|[
name|j
index|]
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
block|}
name|md5key
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%2d M %16s	# MD5 key\n"
argument_list|,
name|i
argument_list|,
name|md5key
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|str
condition|)
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|cleanlinks
argument_list|(
name|f1_keys
argument_list|,
name|f2_keys
argument_list|,
name|f3_keys
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|make_rsa
operator|&&
operator|(
name|force
operator|||
operator|!
name|filep
argument_list|(
name|f1_publickey
argument_list|)
operator|||
operator|!
name|filep
argument_list|(
name|f1_privatekey
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Roll the RSA public/private key pair. 		 */
name|printf
argument_list|(
literal|"Generating RSA public/private key pair (%d bits)...\n"
argument_list|,
name|MODULUSLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memorex
condition|)
block|{
name|protokey
operator|.
name|bits
operator|=
name|MODULUSLEN
expr_stmt|;
name|protokey
operator|.
name|useFermat4
operator|=
literal|1
expr_stmt|;
name|R_RandomInit
argument_list|(
operator|&
name|randomstr
argument_list|)
expr_stmt|;
name|R_GetRandomBytesNeeded
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|randomstr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|random
argument_list|()
expr_stmt|;
name|R_RandomUpdate
argument_list|(
operator|&
name|randomstr
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|R_GeneratePEMKeys
argument_list|(
operator|&
name|rsaref_public
argument_list|,
operator|&
name|rsaref_private
argument_list|,
operator|&
name|protokey
argument_list|,
operator|&
name|randomstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|printf
argument_list|(
literal|"R_GeneratePEMKeys error %x\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 		 * Generate the file "ntpkey.*" containing the RSA 		 * private key in printable ASCII format. 		 */
name|str
operator|=
name|newfile
argument_list|(
name|f1_privatekey
argument_list|,
name|f2_privatekey
argument_list|,
name|sec_mask
argument_list|,
name|f3_privatekey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memorex
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rsaref_private
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rsaref_private
operator|.
name|bits
argument_list|)
expr_stmt|;
name|modulus
operator|=
operator|(
name|u_int32
operator|)
name|rsaref_private
operator|.
name|bits
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# RSA private key file %s\n# %s"
argument_list|,
name|f2_privatekey
argument_list|,
name|ctime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|R_EncodePEMBlock
argument_list|(
name|encoded_key
argument_list|,
operator|&
name|temp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|rsaref_private
operator|.
name|modulus
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|encoded_key
index|[
name|temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%d %s\n"
argument_list|,
name|modulus
argument_list|,
name|encoded_key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
condition|)
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|cleanlinks
argument_list|(
name|f1_privatekey
argument_list|,
name|f2_privatekey
argument_list|,
name|f3_privatekey
argument_list|)
expr_stmt|;
comment|/* 		 * Generate the file "ntpkey_host.*" containing the RSA 		 * public key in printable ASCII format. 		 */
name|str
operator|=
name|newfile
argument_list|(
name|f1_publickey
argument_list|,
name|f2_publickey
argument_list|,
name|std_mask
argument_list|,
name|f3_publickey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memorex
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rsaref_public
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rsaref_public
operator|.
name|bits
argument_list|)
expr_stmt|;
name|modulus
operator|=
operator|(
name|u_int32
operator|)
name|rsaref_public
operator|.
name|bits
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# RSA public key file %s\n# %s"
argument_list|,
name|f2_publickey
argument_list|,
name|ctime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|R_EncodePEMBlock
argument_list|(
name|encoded_key
argument_list|,
operator|&
name|temp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|rsaref_public
operator|.
name|modulus
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|encoded_key
index|[
name|temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%d %s\n"
argument_list|,
name|modulus
argument_list|,
name|encoded_key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
condition|)
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|cleanlinks
argument_list|(
name|f1_publickey
argument_list|,
name|f2_publickey
argument_list|,
name|f3_publickey
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PUBKEY */
ifdef|#
directive|ifdef
name|PUBKEY
if|if
condition|(
name|make_dh
operator|&&
operator|(
name|force
operator|||
operator|!
name|filep
argument_list|(
name|f1_dhparms
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Roll the prime and generator for the Diffie-Hellman key 		 * agreement algorithm. 		 */
name|printf
argument_list|(
literal|"Generating Diffie-Hellman parameters (%d bits)...\n"
argument_list|,
name|PRIMELEN
argument_list|)
expr_stmt|;
name|str
operator|=
name|newfile
argument_list|(
name|f1_dhparms
argument_list|,
name|f2_dhparms
argument_list|,
name|std_mask
argument_list|,
name|f3_dhparms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memorex
condition|)
block|{
name|R_RandomInit
argument_list|(
operator|&
name|randomstr
argument_list|)
expr_stmt|;
name|R_GetRandomBytesNeeded
argument_list|(
operator|&
name|len
argument_list|,
operator|&
name|randomstr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|random
argument_list|()
expr_stmt|;
name|R_RandomUpdate
argument_list|(
operator|&
name|randomstr
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Generate the file "ntpkey_dh.*" containing the 			 * Diffie-Hellman prime and generator in printable 			 * ASCII format. 			 */
name|len
operator|=
name|DH_PRIME_LEN
argument_list|(
name|PRIMELEN
argument_list|)
expr_stmt|;
name|dh_params
operator|.
name|prime
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|dh_params
operator|.
name|generator
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|rval
operator|=
name|R_GenerateDHParams
argument_list|(
operator|&
name|dh_params
argument_list|,
name|PRIMELEN
argument_list|,
name|PRIMELEN
operator|/
literal|2
argument_list|,
operator|&
name|randomstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|printf
argument_list|(
literal|"R_GenerateDHParams error %x\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# Diffie-Hellman parameter file %s\n# %s"
argument_list|,
name|f2_dhparms
argument_list|,
name|ctime
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|R_EncodePEMBlock
argument_list|(
name|encoded_key
argument_list|,
operator|&
name|temp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dh_params
operator|.
name|prime
argument_list|,
name|dh_params
operator|.
name|primeLen
argument_list|)
expr_stmt|;
name|encoded_key
index|[
name|temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%d %s\n"
argument_list|,
name|dh_params
operator|.
name|primeLen
argument_list|,
name|encoded_key
argument_list|)
expr_stmt|;
name|R_EncodePEMBlock
argument_list|(
name|encoded_key
argument_list|,
operator|&
name|temp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dh_params
operator|.
name|generator
argument_list|,
name|dh_params
operator|.
name|generatorLen
argument_list|)
expr_stmt|;
name|encoded_key
index|[
name|temp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%d %s\n"
argument_list|,
name|dh_params
operator|.
name|generatorLen
argument_list|,
name|encoded_key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
condition|)
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|cleanlinks
argument_list|(
name|f1_dhparms
argument_list|,
name|f2_dhparms
argument_list|,
name|f3_dhparms
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PUBKEY */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

