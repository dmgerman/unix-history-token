begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * NTP test program  *  * This program tests to see if the NTP user interface routines  * ntp_gettime() and ntp_adjtime() have been implemented in the kernel.  * If so, each of these routines is called to display current timekeeping  * data.  *  * For more information, see the README.kern file in the doc directory  * of the xntp3 distribution.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"timevalops.h"
end_include

begin_include
include|#
directive|include
file|"ntp_syscall.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NTP_SYSCALLS_STD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_DECOSF1
end_ifndef

begin_define
define|#
directive|define
name|BADCALL
value|-1
end_define

begin_comment
comment|/* this is supposed to be a bad syscall */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_DECOSF1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRUCT_NTPTIMEVAL_TIME_TV_NSEC
end_ifdef

begin_define
define|#
directive|define
name|tv_frac_sec
value|tv_nsec
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tv_frac_sec
value|tv_usec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TIMEX_MOD_BITS
define|\
value|"\20\1OFFSET\2FREQUENCY\3MAXERROR\4ESTERROR\5STATUS\6TIMECONST\ \13PLL\14FLL\15MICRO\16NANO\17CLKB\20CLKA"
end_define

begin_define
define|#
directive|define
name|TIMEX_STA_BITS
define|\
value|"\20\1PLL\2PPSFREQ\3PPSTIME\4FLL\5INS\6DEL\7UNSYNC\10FREQHOLD\ \11PPSSIGNAL\12PPSJITTER\13PPSWANDER\14PPSERROR\15CLOCKERR\ \16NANO\17MODE\20CLK"
end_define

begin_define
define|#
directive|define
name|SCALE_FREQ
value|65536
end_define

begin_comment
comment|/* frequency scale */
end_comment

begin_comment
comment|/*  * These constants are used to round the time stamps computed from  * a struct timeval to the microsecond (more or less).  This keeps  * things neat.  */
end_comment

begin_define
define|#
directive|define
name|TS_MASK
value|0xfffff000
end_define

begin_comment
comment|/* mask to usec, for time stamps */
end_comment

begin_define
define|#
directive|define
name|TS_ROUNDBIT
value|0x00000800
end_define

begin_comment
comment|/* round at this bit */
end_comment

begin_comment
comment|/*  * Function prototypes  */
end_comment

begin_function_decl
specifier|const
name|char
modifier|*
name|sprintb
parameter_list|(
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|timex_state
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIGSYS
end_ifdef

begin_function_decl
name|void
name|pll_trap
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sigaction
name|newsigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new sigaction status */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigaction
name|sigsys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current sigaction status */
end_comment

begin_decl_stmt
specifier|static
name|sigjmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* environment var. for pll_trap() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pll_control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (0) daemon, (1) kernel loop */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most recent status bits */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|flash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most recent ntp_adjtime() bits */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|optargs
index|[]
init|=
literal|"MNT:cde:f:hm:o:rs:t:"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|int
name|ntp_optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ntp_optarg
decl_stmt|;
ifdef|#
directive|ifdef
name|SUBST_ADJTIMEX
name|struct
name|timex
name|ntv
decl_stmt|;
else|#
directive|else
name|struct
name|ntptimeval
name|ntv
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timex
name|ntx
decl_stmt|,
name|_ntx
decl_stmt|;
name|int
name|times
index|[
literal|20
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|double
name|ftemp
decl_stmt|,
name|gtemp
decl_stmt|,
name|htemp
decl_stmt|;
name|long
name|time_frac
decl_stmt|;
comment|/* ntv.time.tv_frac_sec (us/ns) */
name|l_fp
name|ts
decl_stmt|;
specifier|volatile
name|unsigned
name|ts_mask
init|=
name|TS_MASK
decl_stmt|;
comment|/* defaults to 20 bits (us) */
specifier|volatile
name|unsigned
name|ts_roundbit
init|=
name|TS_ROUNDBIT
decl_stmt|;
comment|/* defaults to 20 bits (us) */
specifier|volatile
name|int
name|fdigits
init|=
literal|6
decl_stmt|;
comment|/* fractional digits for us */
name|size_t
name|c
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
name|int
name|cost
init|=
literal|0
decl_stmt|;
specifier|volatile
name|int
name|rawtime
init|=
literal|0
decl_stmt|;
name|ZERO
argument_list|(
name|ntx
argument_list|)
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|ntp_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optargs
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
ifdef|#
directive|ifdef
name|MOD_MICRO
case|case
literal|'M'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_MICRO
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MOD_NANO
case|case
literal|'N'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_NANO
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NTP_API
if|#
directive|if
name|NTP_API
operator|>
literal|3
case|case
literal|'T'
case|:
name|ntx
operator|.
name|modes
operator|=
name|MOD_TAI
expr_stmt|;
name|ntx
operator|.
name|constant
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
literal|'c'
case|:
name|cost
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_ESTERROR
expr_stmt|;
name|ntx
operator|.
name|esterror
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_FREQUENCY
expr_stmt|;
name|ntx
operator|.
name|freq
operator|=
call|(
name|long
call|)
argument_list|(
name|atof
argument_list|(
name|ntp_optarg
argument_list|)
operator|*
name|SCALE_FREQ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_MAXERROR
expr_stmt|;
name|ntx
operator|.
name|maxerror
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_OFFSET
expr_stmt|;
name|ntx
operator|.
name|offset
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rawtime
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_STATUS
expr_stmt|;
name|ntx
operator|.
name|status
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntx
operator|.
name|status
operator|<
literal|0
operator|||
name|ntx
operator|.
name|status
operator|>=
literal|0x100
condition|)
name|errflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ntx
operator|.
name|modes
operator||=
name|MOD_TIMECONST
expr_stmt|;
name|ntx
operator|.
name|constant
operator|=
name|atoi
argument_list|(
name|ntp_optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errflg
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errflg
operator|||
operator|(
name|ntp_optind
operator|!=
name|argc
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-%s]\n\n\ %s%s%s\ -c		display the time taken to call ntp_gettime (us)\n\ -e esterror	estimate of the error (us)\n\ -f frequency	Frequency error (-500 .. 500) (ppm)\n\ -h		display this help info\n\ -m maxerror	max possible error (us)\n\ -o offset	current offset (ms)\n\ -r		print the unix and NTP time raw\n\ -s status	Set the status bits\n\ -t timeconstant	log2 of PLL time constant (0 .. %d)\n"
argument_list|,
name|progname
argument_list|,
name|optargs
argument_list|,
ifdef|#
directive|ifdef
name|MOD_MICRO
literal|"-M		switch to microsecond mode\n"
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MOD_NANO
literal|"-N		switch to nanosecond mode\n"
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NTP_API
if|#
directive|if
name|NTP_API
operator|>
literal|3
literal|"-T tai_offset	set TAI offset\n"
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
name|MAXTC
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGSYS
comment|/* 	 * Test to make sure the sigaction() works in case of invalid 	 * syscall codes. 	 */
name|newsigsys
operator|.
name|sa_handler
operator|=
name|pll_trap
expr_stmt|;
name|newsigsys
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|newsigsys
argument_list|,
operator|&
name|sigsys
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"sigaction() fails to save SIGSYS trap"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SIGSYS */
ifdef|#
directive|ifdef
name|BADCALL
comment|/* 	 * Make sure the trapcatcher works. 	 */
name|pll_control
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
if|if
condition|(
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|status
operator|=
name|syscall
argument_list|(
name|BADCALL
argument_list|,
operator|&
name|ntv
argument_list|)
expr_stmt|;
comment|/* dummy parameter */
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOSYS
operator|)
condition|)
operator|--
name|pll_control
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
block|}
endif|#
directive|endif
if|if
condition|(
name|pll_control
condition|)
name|printf
argument_list|(
literal|"sigaction() failed to catch an invalid syscall\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BADCALL */
if|if
condition|(
name|cost
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGSYS
if|if
condition|(
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|COUNTOF
argument_list|(
name|times
argument_list|)
condition|;
name|c
operator|++
control|)
block|{
name|status
operator|=
name|ntp_gettime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOSYS
operator|)
condition|)
operator|--
name|pll_control
expr_stmt|;
if|if
condition|(
name|pll_control
operator|<
literal|0
condition|)
break|break;
name|times
index|[
name|c
index|]
operator|=
name|ntv
operator|.
name|time
operator|.
name|tv_frac_sec
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGSYS
block|}
endif|#
directive|endif
if|if
condition|(
name|pll_control
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[ us %06d:"
argument_list|,
name|times
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|COUNTOF
argument_list|(
name|times
argument_list|)
condition|;
name|c
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|times
index|[
name|c
index|]
operator|-
name|times
index|[
name|c
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ]\n"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SIGSYS
if|if
condition|(
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|status
operator|=
name|ntp_gettime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOSYS
operator|)
condition|)
operator|--
name|pll_control
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
block|}
endif|#
directive|endif
name|_ntx
operator|.
name|modes
operator|=
literal|0
expr_stmt|;
comment|/* Ensure nothing is set */
ifdef|#
directive|ifdef
name|SIGSYS
if|if
condition|(
name|sigsetjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|status
operator|=
name|ntp_adjtime
argument_list|(
operator|&
name|_ntx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|ENOSYS
operator|)
condition|)
operator|--
name|pll_control
expr_stmt|;
name|flash
operator|=
name|_ntx
operator|.
name|status
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
block|}
endif|#
directive|endif
if|if
condition|(
name|pll_control
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NTP user interface routines are not configured in this kernel.\n"
argument_list|)
expr_stmt|;
goto|goto
name|lexit
goto|;
block|}
comment|/* 	 * Fetch timekeeping data and display. 	 */
name|status
operator|=
name|ntp_gettime
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ntp_gettime() call fails"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ntp_gettime() returns code %d (%s)\n"
argument_list|,
name|status
argument_list|,
name|timex_state
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|time_frac
operator|=
name|ntv
operator|.
name|time
operator|.
name|tv_frac_sec
expr_stmt|;
ifdef|#
directive|ifdef
name|STA_NANO
if|if
condition|(
name|flash
operator|&
name|STA_NANO
condition|)
block|{
name|ntv
operator|.
name|time
operator|.
name|tv_frac_sec
operator|/=
literal|1000
expr_stmt|;
name|ts_mask
operator|=
literal|0xfffffffc
expr_stmt|;
comment|/* 1/2^30 */
name|ts_roundbit
operator|=
literal|0x00000002
expr_stmt|;
name|fdigits
operator|=
literal|9
expr_stmt|;
block|}
endif|#
directive|endif
name|tv
operator|.
name|tv_sec
operator|=
name|ntv
operator|.
name|time
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|ntv
operator|.
name|time
operator|.
name|tv_frac_sec
expr_stmt|;
name|TVTOTS
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|+=
name|ts_roundbit
expr_stmt|;
name|ts
operator|.
name|l_uf
operator|&=
name|ts_mask
expr_stmt|;
name|printf
argument_list|(
literal|"  time %s, (.%0*d),\n"
argument_list|,
name|prettydate
argument_list|(
operator|&
name|ts
argument_list|)
argument_list|,
name|fdigits
argument_list|,
operator|(
name|int
operator|)
name|time_frac
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  maximum error %lu us, estimated error %lu us"
argument_list|,
operator|(
name|u_long
operator|)
name|ntv
operator|.
name|maxerror
argument_list|,
operator|(
name|u_long
operator|)
name|ntv
operator|.
name|esterror
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawtime
condition|)
name|printf
argument_list|(
literal|"  ntptime=%x.%x unixtime=%x.%0*d %s"
argument_list|,
operator|(
name|u_int
operator|)
name|ts
operator|.
name|l_ui
argument_list|,
operator|(
name|u_int
operator|)
name|ts
operator|.
name|l_uf
argument_list|,
operator|(
name|int
operator|)
name|ntv
operator|.
name|time
operator|.
name|tv_sec
argument_list|,
name|fdigits
argument_list|,
operator|(
name|int
operator|)
name|time_frac
argument_list|,
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|ntv
operator|.
name|time
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NTP_API
operator|>
literal|3
name|printf
argument_list|(
literal|", TAI offset %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ntv
operator|.
name|tai
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NTP_API */
block|}
name|status
operator|=
name|ntp_adjtime
argument_list|(
operator|&
name|ntx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
operator|(
name|errno
operator|==
name|EPERM
operator|)
condition|?
literal|"Must be root to set kernel values\nntp_adjtime() call fails"
else|:
literal|"ntp_adjtime() call fails"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flash
operator|=
name|ntx
operator|.
name|status
expr_stmt|;
name|printf
argument_list|(
literal|"ntp_adjtime() returns code %d (%s)\n"
argument_list|,
name|status
argument_list|,
name|timex_state
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  modes %s,\n"
argument_list|,
name|sprintb
argument_list|(
name|ntx
operator|.
name|modes
argument_list|,
name|TIMEX_MOD_BITS
argument_list|)
argument_list|)
expr_stmt|;
name|ftemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|STA_NANO
if|if
condition|(
name|flash
operator|&
name|STA_NANO
condition|)
name|ftemp
operator|/=
literal|1000.0
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  offset %.3f"
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|ftemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|freq
operator|/
name|SCALE_FREQ
expr_stmt|;
name|printf
argument_list|(
literal|" us, frequency %.3f ppm, interval %d s,\n"
argument_list|,
name|ftemp
argument_list|,
literal|1
operator|<<
name|ntx
operator|.
name|shift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  maximum error %lu us, estimated error %lu us,\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|maxerror
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|esterror
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  status %s,\n"
argument_list|,
name|sprintb
argument_list|(
operator|(
name|u_int
operator|)
name|ntx
operator|.
name|status
argument_list|,
name|TIMEX_STA_BITS
argument_list|)
argument_list|)
expr_stmt|;
name|ftemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|tolerance
operator|/
name|SCALE_FREQ
expr_stmt|;
name|gtemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|precision
expr_stmt|;
ifdef|#
directive|ifdef
name|STA_NANO
if|if
condition|(
name|flash
operator|&
name|STA_NANO
condition|)
name|gtemp
operator|/=
literal|1000.0
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  time constant %lu, precision %.3f us, tolerance %.0f ppm,\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|constant
argument_list|,
name|gtemp
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntx
operator|.
name|shift
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ftemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|ppsfreq
operator|/
name|SCALE_FREQ
expr_stmt|;
name|gtemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|stabil
operator|/
name|SCALE_FREQ
expr_stmt|;
name|htemp
operator|=
operator|(
name|double
operator|)
name|ntx
operator|.
name|jitter
expr_stmt|;
ifdef|#
directive|ifdef
name|STA_NANO
if|if
condition|(
name|flash
operator|&
name|STA_NANO
condition|)
name|htemp
operator|/=
literal|1000.0
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"  pps frequency %.3f ppm, stability %.3f ppm, jitter %.3f us,\n"
argument_list|,
name|ftemp
argument_list|,
name|gtemp
argument_list|,
name|htemp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  intervals %lu, jitter exceeded %lu, stability exceeded %lu, errors %lu.\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|calcnt
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|jitcnt
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|stbcnt
argument_list|,
operator|(
name|u_long
operator|)
name|ntx
operator|.
name|errcnt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Put things back together the way we found them. 	 */
name|lexit
label|:
ifdef|#
directive|ifdef
name|SIGSYS
if|if
condition|(
name|sigaction
argument_list|(
name|SIGSYS
argument_list|,
operator|&
name|sigsys
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"sigaction() fails to restore SIGSYS trap"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGSYS
end_ifdef

begin_comment
comment|/*  * pll_trap - trap processor for undefined syscalls  */
end_comment

begin_function
name|void
name|pll_trap
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|pll_control
operator|--
expr_stmt|;
name|siglongjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print a value a la the %b format of the kernel's printf  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sprintb
parameter_list|(
name|u_int
name|v
parameter_list|,
specifier|const
name|char
modifier|*
name|bits
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cplim
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|any
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|bits
operator|!=
name|NULL
operator|&&
operator|*
name|bits
operator|==
literal|8
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0%o"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cplim
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
block|{
name|bits
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'('
expr_stmt|;
name|any
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|bits
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|any
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|cplim
condition|)
goto|goto
name|overrun
goto|;
block|}
name|any
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
operator|*
name|bits
operator|)
operator|>
literal|32
condition|;
name|bits
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|cplim
condition|)
goto|goto
name|overrun
goto|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
operator|*
name|bits
operator|>
literal|32
condition|;
name|bits
operator|++
control|)
continue|continue;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|')'
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|cplim
condition|)
goto|goto
name|overrun
goto|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
name|overrun
label|:
return|return
literal|"sprintb buffer too small"
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|timex_states
index|[]
init|=
block|{
literal|"OK"
block|,
literal|"INS"
block|,
literal|"DEL"
block|,
literal|"OOP"
block|,
literal|"WAIT"
block|,
literal|"ERROR"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|timex_state
parameter_list|(
name|int
name|s
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|s
operator|<
name|COUNTOF
argument_list|(
name|timex_states
argument_list|)
condition|)
return|return
name|timex_states
index|[
name|s
index|]
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"TIME-#%d"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

