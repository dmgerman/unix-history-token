begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Program to generate cryptographic keys for NTP clients and servers  *  * This program generates files "ntpkey_<type>_<hostname>.<filestamp>",  * where<type> is the file type,<hostname> is the generating host and  *<filestamp> is the NTP seconds in decimal format. The NTP programs  * expect generic names such as "ntpkey_<type>_whimsy.udel.edu" with the  * association maintained by soft links.  *  * Files are prefixed with a header giving the name and date of creation  * followed by a type-specific descriptive label and PEM-encoded data  * string compatible with programs of the OpenSSL library.  *  * Note that private keys can be password encrypted as per OpenSSL  * conventions.  *  * The file types include  *  * ntpkey_MD5key_<hostname>.<filestamp>  * 	MD5 (128-bit) keys used to compute message digests in symmetric  *	key cryptography  *  * ntpkey_RSAkey_<hostname>.<filestamp>  * ntpkey_host_<hostname> (RSA) link  *	RSA private/public host key pair used for public key signatures  *	and data encryption  *  * ntpkey_DSAkey_<hostname>.<filestamp>  * ntpkey_sign_<hostname> (RSA or DSA) link  *	DSA private/public sign key pair used for public key signatures,  *	but not data encryption  *  * ntpkey_IFFpar_<hostname>.<filestamp>  * ntpkey_iff_<hostname> (IFF server/client) link  * ntpkey_iffkey_<hostname> (IFF client) link  *	Schnorr (IFF) server/client identity parameters  *  * ntpkey_IFFkey_<hostname>.<filestamp>  *	Schnorr (IFF) client identity parameters  *  * ntpkey_GQpar_<hostname>.<filestamp>,  * ntpkey_gq_<hostname> (GQ) link  *	Guillou-Quisquater (GQ) identity parameters  *  * ntpkey_MVpar_<hostname>.<filestamp>,  *	Mu-Varadharajan (MV) server identity parameters   *  * ntpkey_MVkeyX_<hostname>.<filestamp>,  * ntpkey_mv_<hostname> (MV server) link  * ntpkey_mvkey_<hostname> (MV client) link  *	Mu-Varadharajan (MV) client identity parameters  *  * ntpkey_XXXcert_<hostname>.<filestamp>  * ntpkey_cert_<hostname> (RSA or DSA) link  *	X509v3 certificate using RSA or DSA public keys and signatures.  *	XXX is a code identifying the message digest and signature  *	encryption algorithm  *  * Available digest/signature schemes  *  * RSA:	RSA-MD2, RSA-MD5, RSA-SHA, RSA-SHA1, RSA-MDC2, EVP-RIPEMD160  * DSA:	DSA-SHA, DSA-SHA1  *  * Note: Once in a while because of some statistical fluke this program  * fails to generate and verify some cryptographic data, as indicated by  * exit status -1. In this case simply run the program again. If the  * program does complete with return code 0, the data are correct as  * verified.  *  * These cryptographic routines are characterized by the prime modulus  * size in bits. The default value of 512 bits is a compromise between  * cryptographic strength and computing time and is ordinarily  * considered adequate for this application. The routines have been  * tested with sizes of 256, 512, 1024 and 2048 bits. Not all message  * digest and signature encryption schemes work with sizes less than 512  * bits. The computing time for sizes greater than 2048 bits is  * prohibitive on all but the fastest processors. An UltraSPARC Blade  * 1000 took something over nine minutes to generate and verify the  * values with size 2048. An old SPARC IPC would take a week.  *  * The OpenSSL library used by this program expects a random seed file.  * As described in the OpenSSL documentation, the file name defaults to  * first the RANDFILE environment variable in the user's home directory  * and then .rnd in the user's home directory.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TYPES_H
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_types.h"
end_include

begin_include
include|#
directive|include
file|"l_stdlib.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|ntp_getopt
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|getopt
value|ntp_getopt
end_define

begin_define
define|#
directive|define
name|optarg
value|ntp_optarg
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|"openssl/bn.h"
end_include

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/err.h"
end_include

begin_include
include|#
directive|include
file|"openssl/rand.h"
end_include

begin_include
include|#
directive|include
file|"openssl/pem.h"
end_include

begin_include
include|#
directive|include
file|"openssl/x509v3.h"
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Cryptodefines  */
end_comment

begin_define
define|#
directive|define
name|MD5KEYS
value|16
end_define

begin_comment
comment|/* number of MD5 keys generated */
end_comment

begin_define
define|#
directive|define
name|JAN_1970
value|ULONG_CONST(2208988800)
end_define

begin_comment
comment|/* NTP seconds */
end_comment

begin_define
define|#
directive|define
name|YEAR
value|((long)60*60*24*365)
end_define

begin_comment
comment|/* one year in seconds */
end_comment

begin_define
define|#
directive|define
name|MAXFILENAME
value|256
end_define

begin_comment
comment|/* max file name length */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTNAME
value|256
end_define

begin_comment
comment|/* max host name length */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_define
define|#
directive|define
name|PLEN
value|512
end_define

begin_comment
comment|/* default prime modulus size (bits) */
end_comment

begin_comment
comment|/*  * Strings used in X509v3 extension fields  */
end_comment

begin_define
define|#
directive|define
name|KEY_USAGE
value|"digitalSignature,keyCertSign"
end_define

begin_define
define|#
directive|define
name|BASIC_CONSTRAINTS
value|"critical,CA:TRUE"
end_define

begin_define
define|#
directive|define
name|EXT_KEY_PRIVATE
value|"private"
end_define

begin_define
define|#
directive|define
name|EXT_KEY_TRUST
value|"trustRoot"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fheader
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fslink
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gen_md5
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_rsa
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_dsa
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_iff
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_gqpar
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_gqkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|EVP_PKEY
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|gen_mv
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x509
name|P
argument_list|(
operator|(
name|EVP_PKEY
operator|*
operator|,
specifier|const
name|EVP_MD
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cb
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EVP_PKEY
modifier|*
name|genkey
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|asn2ntp
name|P
argument_list|(
operator|(
name|ASN1_TIME
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Program variables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command line argument */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug, not de bug */
end_comment

begin_decl_stmt
name|int
name|rval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return status */
end_comment

begin_decl_stmt
name|u_int
name|modulus
init|=
name|PLEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prime modulus size (bits) */
end_comment

begin_decl_stmt
name|int
name|nkeys
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV keys */
end_comment

begin_decl_stmt
name|time_t
name|epoch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unix epoch (seconds) since 1970 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host name (subject name) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|trustname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trusted host name (issuer name) */
end_comment

begin_decl_stmt
name|char
name|filename
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|passwd1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input private key password */
end_comment

begin_decl_stmt
name|char
modifier|*
name|passwd2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output private key password */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_decl_stmt
name|long
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* callback counters */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function_decl
name|BOOL
name|init_randfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Don't try to follow symbolic links  */
end_comment

begin_function
name|int
name|readlink
parameter_list|(
name|char
modifier|*
name|link
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Don't try to create a symbolic link for now.  * Just move the file to the name you need.  */
end_comment

begin_function
name|int
name|symlink
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|linkname
parameter_list|)
block|{
name|DeleteFile
argument_list|(
name|linkname
argument_list|)
expr_stmt|;
name|MoveFile
argument_list|(
name|filename
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|InitWin32Sockets
parameter_list|()
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No useable winsock.dll"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * Main program  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
comment|/* command line options */
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* initialization vector */
ifdef|#
directive|ifdef
name|OPENSSL
name|X509
modifier|*
name|cert
init|=
name|NULL
decl_stmt|;
comment|/* X509 certificate */
name|EVP_PKEY
modifier|*
name|pkey_host
init|=
name|NULL
decl_stmt|;
comment|/* host key */
name|EVP_PKEY
modifier|*
name|pkey_sign
init|=
name|NULL
decl_stmt|;
comment|/* sign key */
name|EVP_PKEY
modifier|*
name|pkey_iff
init|=
name|NULL
decl_stmt|;
comment|/* IFF parameters */
name|EVP_PKEY
modifier|*
name|pkey_gq
init|=
name|NULL
decl_stmt|;
comment|/* GQ parameters */
name|EVP_PKEY
modifier|*
name|pkey_mv
init|=
name|NULL
decl_stmt|;
comment|/* MV parameters */
name|int
name|md5key
init|=
literal|0
decl_stmt|;
comment|/* generate MD5 keys */
name|int
name|hostkey
init|=
literal|0
decl_stmt|;
comment|/* generate RSA keys */
name|int
name|iffkey
init|=
literal|0
decl_stmt|;
comment|/* generate IFF parameters */
name|int
name|gqpar
init|=
literal|0
decl_stmt|;
comment|/* generate GQ parameters */
name|int
name|gqkey
init|=
literal|0
decl_stmt|;
comment|/* update GQ keys */
name|int
name|mvpar
init|=
literal|0
decl_stmt|;
comment|/* generate MV parameters */
name|int
name|mvkey
init|=
literal|0
decl_stmt|;
comment|/* update MV keys */
name|char
modifier|*
name|sign
init|=
name|NULL
decl_stmt|;
comment|/* sign key */
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* temp key */
specifier|const
name|EVP_MD
modifier|*
name|ectx
decl_stmt|;
comment|/* EVP digest */
name|char
name|hostbuf
index|[
name|MAXHOSTNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|pathbuf
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme
init|=
name|NULL
decl_stmt|;
comment|/* digest/signature scheme */
name|char
modifier|*
name|exten
init|=
name|NULL
decl_stmt|;
comment|/* private extension */
name|char
modifier|*
name|grpkey
init|=
name|NULL
decl_stmt|;
comment|/* identity extension */
name|int
name|nid
decl_stmt|;
comment|/* X509 digest/signature scheme */
name|FILE
modifier|*
name|fstr
init|=
name|NULL
decl_stmt|;
comment|/* file handle */
name|int
name|iffsw
init|=
literal|0
decl_stmt|;
comment|/* IFF key switch */
endif|#
directive|endif
comment|/* OPENSSL */
name|u_int
name|temp
decl_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* Initialize before OpenSSL checks */
name|InitWin32Sockets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|init_randfile
argument_list|()
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to initialize .rnd file\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|SSLeay
argument_list|()
operator|!=
name|OPENSSL_VERSION_NUMBER
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OpenSSL version mismatch. Built against %lx, you have %lx\n"
argument_list|,
name|OPENSSL_VERSION_NUMBER
argument_list|,
name|SSLeay
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using OpenSSL version %lx\n"
argument_list|,
name|SSLeay
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
comment|/* 	 * Process options, initialize host name and timestamp. 	 */
name|gethostname
argument_list|(
name|hostbuf
argument_list|,
name|MAXHOSTNAME
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|hostbuf
expr_stmt|;
name|trustname
operator|=
name|hostbuf
expr_stmt|;
name|passwd1
operator|=
name|hostbuf
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS_WINNT
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|epoch
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"c:deGgHIi:Mm:nPp:q:S:s:TV:v:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|temp
condition|)
block|{
comment|/* 		 * -c select public certificate type 		 */
case|case
literal|'c'
case|:
name|scheme
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -d debug 		 */
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -e write identity keys 		 */
case|case
literal|'e'
case|:
name|iffsw
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -G generate GQ parameters and keys 		 */
case|case
literal|'G'
case|:
name|gqpar
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -g update GQ keys 		 */
case|case
literal|'g'
case|:
name|gqkey
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -H generate host key (RSA) 		 */
case|case
literal|'H'
case|:
name|hostkey
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -I generate IFF parameters 		 */
case|case
literal|'I'
case|:
name|iffkey
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -i set issuer name 		 */
case|case
literal|'i'
case|:
name|trustname
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -M generate MD5 keys 		 */
case|case
literal|'M'
case|:
name|md5key
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * -m select modulus (256-2048) 		 */
case|case
literal|'m'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|modulus
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid option -m %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * -P generate PC private certificate 		 */
case|case
literal|'P'
case|:
name|exten
operator|=
name|EXT_KEY_PRIVATE
expr_stmt|;
continue|continue;
comment|/* 		 * -p output private key password 		 */
case|case
literal|'p'
case|:
name|passwd2
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -q input private key password 		 */
case|case
literal|'q'
case|:
name|passwd1
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -S generate sign key (RSA or DSA) 		 */
case|case
literal|'S'
case|:
name|sign
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -s set subject name 		 */
case|case
literal|'s'
case|:
name|hostname
operator|=
name|optarg
expr_stmt|;
continue|continue;
comment|/* 		 * -T trusted certificate (TC scheme) 		 */
case|case
literal|'T'
case|:
name|exten
operator|=
name|EXT_KEY_TRUST
expr_stmt|;
continue|continue;
comment|/* 		 * -V<keys> generate MV parameters 		 */
case|case
literal|'V'
case|:
name|mvpar
operator|++
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|nkeys
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid option -V %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * -v<key> update MV keys 		 */
case|case
literal|'v'
case|:
name|mvkey
operator|++
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|nkeys
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid option -v %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
continue|continue;
comment|/* 		 * None of the above. 		 */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Option ignored\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|passwd1
operator|!=
name|NULL
operator|&&
name|passwd2
operator|==
name|NULL
condition|)
name|passwd2
operator|=
name|passwd1
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
comment|/* 	 * Seed random number generator and grow weeds. 	 */
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
if|if
condition|(
name|RAND_file_name
argument_list|(
name|pathbuf
argument_list|,
name|MAXFILENAME
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RAND_file_name %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|temp
operator|=
name|RAND_load_file
argument_list|(
name|pathbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RAND_load_file %s not found or empty\n"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Random seed file %s %u bytes\n"
argument_list|,
name|pathbuf
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|epoch
argument_list|,
sizeof|sizeof
argument_list|(
name|epoch
argument_list|)
argument_list|,
literal|4.0
argument_list|)
expr_stmt|;
comment|/* 	 * Generate new parameters and keys as requested. These replace 	 * any values already generated. 	 */
if|if
condition|(
name|md5key
condition|)
name|gen_md5
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostkey
condition|)
name|pkey_host
operator|=
name|genkey
argument_list|(
literal|"RSA"
argument_list|,
literal|"host"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|!=
name|NULL
condition|)
name|pkey_sign
operator|=
name|genkey
argument_list|(
name|sign
argument_list|,
literal|"sign"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iffkey
condition|)
name|pkey_iff
operator|=
name|gen_iff
argument_list|(
literal|"iff"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gqpar
condition|)
name|pkey_gq
operator|=
name|gen_gqpar
argument_list|(
literal|"gq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvpar
condition|)
name|pkey_mv
operator|=
name|gen_mv
argument_list|(
literal|"mv"
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no new host key, look for an existing one. If not 	 * found, create it. 	 */
while|while
condition|(
name|pkey_host
operator|==
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
operator|!
name|iffsw
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_host_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pkey_host
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|readlink
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_host
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Host key\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using host key %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|pkey_host
operator|=
name|genkey
argument_list|(
literal|"RSA"
argument_list|,
literal|"host"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If there is no new sign key, look for an existing one. If not 	 * found, use the host key instead. 	 */
name|pkey
operator|=
name|pkey_sign
expr_stmt|;
while|while
condition|(
name|pkey_sign
operator|==
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
operator|!
name|iffsw
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_sign_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pkey_sign
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|readlink
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_sign
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sign key\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using sign key %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|pkey
operator|=
name|pkey_host
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using host key as sign key\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If there is no new IFF file, look for an existing one. 	 */
if|if
condition|(
name|pkey_iff
operator|==
name|NULL
operator|&&
name|rval
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_iff_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pkey_iff
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|readlink
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_iff
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IFF parameters\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using IFF parameters %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If there is no new GQ file, look for an existing one. 	 */
if|if
condition|(
name|pkey_gq
operator|==
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
operator|!
name|iffsw
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_gq_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pkey_gq
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|readlink
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_gq
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GQ parameters\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using GQ parameters %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If there is a GQ parameter file, create GQ private/public 	 * keys and extract the public key for the certificate. 	 */
if|if
condition|(
name|pkey_gq
operator|!=
name|NULL
operator|&&
name|rval
operator|==
literal|0
condition|)
block|{
name|gen_gqkey
argument_list|(
literal|"gq"
argument_list|,
name|pkey_gq
argument_list|)
expr_stmt|;
name|grpkey
operator|=
name|BN_bn2hex
argument_list|(
name|pkey_gq
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Generate a X509v3 certificate. 	 */
while|while
condition|(
name|scheme
operator|==
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
operator|!
name|iffsw
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_cert_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cert
operator|=
name|PEM_read_X509
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
name|readlink
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cert \n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|cert
operator|->
name|cert_info
operator|->
name|signature
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|scheme
operator|=
name|OBJ_nid2sn
argument_list|(
name|nid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using scheme %s from %s\n"
argument_list|,
name|scheme
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|scheme
operator|=
literal|"RSA-MD5"
expr_stmt|;
block|}
if|if
condition|(
name|pkey
operator|!=
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
operator|!
name|iffsw
condition|)
block|{
name|ectx
operator|=
name|EVP_get_digestbyname
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|ectx
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid digest/signature combination %s\n"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x509
argument_list|(
name|pkey
argument_list|,
name|ectx
argument_list|,
name|grpkey
argument_list|,
name|exten
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Write the IFF client parameters and keys as a DSA private key 	 * encoded in PEM. Note the private key is obscured. 	 */
if|if
condition|(
name|pkey_iff
operator|!=
name|NULL
operator|&&
name|rval
operator|==
literal|0
operator|&&
name|iffsw
condition|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
name|sptr
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_IFFkey_%s.%s"
argument_list|,
name|trustname
argument_list|,
operator|++
name|sptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing new IFF key %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|pkey_iff
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|priv_key
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the marbles. 	 */
if|if
condition|(
name|grpkey
operator|!=
name|NULL
condition|)
name|OPENSSL_free
argument_list|(
name|grpkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_host
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_sign
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey_sign
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_iff
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey_iff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_gq
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey_gq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_mv
operator|!=
name|NULL
condition|)
name|EVP_PKEY_free
argument_list|(
name|pkey_mv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Generate random MD5 key with password.  */
end_comment

begin_comment
unit|int gen_md5( 	char	*id
comment|/* file name id */
end_comment

begin_else
unit|) { 	BIGNUM	*key; 	BIGNUM	*keyid; 	FILE	*str; 	u_char	bin[16];  	fprintf(stderr, "Generating MD5 keys...\n"); 	str = fheader("MD5key", hostname); 	keyid = BN_new(); key = BN_new(); 	BN_rand(keyid, 16, -1, 0); 	BN_rand(key, 128, -1, 0); 	BN_bn2bin(key, bin); 	PEM_write_fp(str, MD5, NULL, bin); 	fclose(str); 	fslink(id, hostname); 	return (1); }
else|#
directive|else
end_else

begin_comment
comment|/*  * Generate semi-random MD5 keys compatible with NTPv3 and NTPv4  */
end_comment

begin_function
name|int
name|gen_md5
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|u_char
name|md5key
index|[
literal|16
index|]
decl_stmt|;
comment|/* MD5 key */
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
init|=
literal|0
decl_stmt|;
comment|/* Initialize to prevent warnings during compile */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating MD5 keys...\n"
argument_list|)
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
literal|"MD5key"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|epoch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MD5KEYS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|temp
operator|=
name|random
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|temp
operator|>
literal|0x20
operator|&&
name|temp
operator|<
literal|0x7f
condition|)
break|break;
block|}
name|md5key
index|[
name|j
index|]
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
block|}
name|md5key
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%2d MD5 %16s	# MD5 key\n"
argument_list|,
name|i
argument_list|,
name|md5key
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_comment
comment|/*  * Generate RSA public/private key pair  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|gen_rsa
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* RSA parameters and key pair */
name|FILE
modifier|*
name|str
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating RSA keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|RSA_generate_key
argument_list|(
name|modulus
argument_list|,
literal|3
argument_list|,
name|cb
argument_list|,
literal|"RSA"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * For signature encryption it is not necessary that the RSA 	 * parameters be strictly groomed and once in a while the 	 * modulus turns out to be non-prime. Just for grins, we check 	 * the primality. 	 */
if|if
condition|(
operator|!
name|RSA_check_key
argument_list|(
name|rsa
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid RSA key\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the RSA parameters and keys as a RSA private key 	 * encoded in PEM. 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"RSAkey"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate DSA public/private key pair  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|gen_dsa
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* DSA parameters */
name|u_char
name|seed
index|[
literal|20
index|]
decl_stmt|;
comment|/* seed for parameters */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* 	 * Generate DSA parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating DSA parameters (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
name|modulus
argument_list|,
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cb
argument_list|,
literal|"DSA"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate parameters fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Generate DSA keys. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating DSA keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSA_generate_key
argument_list|(
name|dsa
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the DSA parameters and keys as a DSA private key 	 * encoded in PEM. 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"DSAkey"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Schnorr (IFF) parameters and keys  *  * The Schnorr (IFF)identity scheme is intended for use when  * certificates are generated by some other trusted certificate  * authority and the parameters cannot be conveyed in the certificate  * itself. For this purpose, new generations of IFF values must be  * securely transmitted to all members of the group before use. There  * are two kinds of files: server/client files that include private and  * public parameters and client files that include only public  * parameters. The scheme is self contained and independent of new  * generations of host keys, sign keys and certificates.  *  * The IFF values hide in a DSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on DSA  * cryptography and described in Stimson p. 285. The p is a 512-bit  * prime, g a generator of Zp* and q a 160-bit prime that divides p - 1  * and is a qth root of 1 mod p; that is, g^q = 1 mod p. The TA rolls a  * private random group key b (0< b< q), then computes public  * v = g^(q - a). All values except the group key are known to all group  * members; the group key is known to the group servers, but not the  * group clients. Alice challenges Bob to confirm identity using the  * protocol described below.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* DSA cuckoo nest */
name|gen_iff
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* DSA parameters */
name|u_char
name|seed
index|[
literal|20
index|]
decl_stmt|;
comment|/* seed for parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|w
decl_stmt|;
comment|/* BN temp */
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * Generate DSA parameters for use as IFF parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating IFF parameters (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
name|modulus
argument_list|,
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cb
argument_list|,
literal|"IFF"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate parameters fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
empty_stmt|;
block|}
comment|/* 	 * Generate the private and public keys. The DSA parameters and 	 * these keys are distributed to all members of the group. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating IFF keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|w
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|b
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a */
name|BN_mod
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^(q - b) mod p */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^b mod p */
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_is_one
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^(q - b) g^b = 1 mod p: %s\n"
argument_list|,
name|temp
operator|==
literal|1
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|BN_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dsa
operator|->
name|priv_key
operator|=
name|BN_dup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* private key */
name|dsa
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* public key */
comment|/* 	 * Here is a trial round of the protocol. First, Alice rolls 	 * random r (0< r< q) and sends it to Bob. She needs only 	 * modulus q. 	 */
name|BN_rand
argument_list|(
name|r
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob rolls random k (0< k< q), computes y = k + b r mod q 	 * and x = g^k mod p, then sends (y, x) to Alice. He needs 	 * moduli p, q and the group key b. 	 */
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* k, 0< k< q  */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* b r mod q */
name|BN_add
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y = k + b r mod q */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* x = g^k mod p */
comment|/* 	 * Alice computes g^y v^r and verifies the result is equal to x. 	 * She needs modulus p, generator g, and the public key v, as 	 * well as her original r. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^y mod p */
name|BN_mod_exp
argument_list|(
name|w
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r */
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* product mod p */
name|temp
operator|=
name|BN_cmp
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^k = g^(k + b r) g^(q - b) r: %s\n"
argument_list|,
name|temp
operator|==
literal|0
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the IFF server parameters and keys as a DSA private key 	 * encoded in PEM. 	 * 	 * p	modulus p 	 * q	modulus q 	 * g	generator g 	 * priv_key b 	 * public_key v 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"IFFpar"
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Guillou-Quisquater (GQ) parameters and keys  *  * The Guillou-Quisquater (GQ) identity scheme is intended for use when  * the parameters, keys and certificates are generated by this program.  * The scheme uses a certificate extension field do convey the public  * key of a particular group identified by a group key known only to  * members of the group. The scheme is self contained and independent of  * new generations of host keys and sign keys.  *  * The GQ parameters hide in a RSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on RSA  * cryptography and described in Stimson p. 300 (with errors). The 512-  * bit public modulus is n = p q, where p and q are secret large primes.  * The TA rolls private random group key b as RSA exponent. These values  * are known to all group members.  *  * When rolling new certificates, a member recomputes the private and  * public keys. The private key u is a random roll, while the public key  * is the inverse obscured by the group key v = (u^-1)^b. These values  * replace the private and public keys normally generated by the RSA  * scheme. Alice challenges Bob to confirm identity using the protocol  * described below.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* RSA cuckoo nest */
name|gen_gqpar
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* GQ parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* 	 * Generate RSA parameters for use as GQ parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating GQ parameters (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|RSA_generate_key
argument_list|(
name|modulus
argument_list|,
literal|3
argument_list|,
name|cb
argument_list|,
literal|"GQ"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Generate the group key b, which is saved in the e member of 	 * the RSA structure. These values are distributed to all 	 * members of the group, but shielded from all other groups. We 	 * don't use all the parameters, but set the unused ones to a 	 * small number to minimize the file size. 	 */
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|rsa
operator|->
name|e
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* b */
name|BN_mod
argument_list|(
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|d
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|p
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|q
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|dmp1
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|dmq1
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|iqmp
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * Write the GQ parameters as a RSA private key encoded in PEM. 	 * The public and private keys are filled in later. 	 * 	 * n	modulus n 	 * e	group key b 	 * (remaining values are not used) 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"GQpar"
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update Guillou-Quisquater (GQ) parameters  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* RSA cuckoo nest */
name|gen_gqkey
parameter_list|(
name|char
modifier|*
name|id
parameter_list|,
comment|/* file name id */
name|EVP_PKEY
modifier|*
name|gqpar
comment|/* GQ parameters */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* RSA parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|y
decl_stmt|;
comment|/* BN temps */
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * Generate GQ keys. Note that the group key b is the e member 	 * of 	 * the GQ parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Updating GQ keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
comment|/* 	 * When generating his certificate, Bob rolls random private key 	 * u.  	 */
name|rsa
operator|=
name|gqpar
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|BN_rand
argument_list|(
name|u
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* u */
name|BN_mod
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_inverse
argument_list|(
name|v
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^-1 mod n */
name|BN_mod_mul
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob computes public key v = (u^-1)^b, which is saved in an 	 * extension field on his certificate. We check that u^b v = 	 * 1 mod n. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^b */
name|BN_mod_mul
argument_list|(
name|g
argument_list|,
name|g
argument_list|,
name|v
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^b (u^-1)^b */
name|temp
operator|=
name|BN_is_one
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm u^b (u^-1)^b = 1 mod n: %s\n"
argument_list|,
name|temp
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BN_copy
argument_list|(
name|rsa
operator|->
name|p
argument_list|,
name|u
argument_list|)
expr_stmt|;
comment|/* private key */
name|BN_copy
argument_list|(
name|rsa
operator|->
name|q
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* public key */
comment|/* 	 * Here is a trial run of the protocol. First, Alice rolls 	 * random r (0< r< n) and sends it to Bob. She needs only 	 * modulus n from the parameters. 	 */
name|BN_rand
argument_list|(
name|r
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob rolls random k (0< k< n), computes y = k u^r mod n and 	 * g = k^b mod n, then sends (y, g) to Alice. He needs modulus n 	 * from the parameters and his private key u.  	 */
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^r mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|k
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y = k u^r mod n */
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g = k^b mod n */
comment|/* 	 * Alice computes v^r y^b mod n and verifies the result is equal 	 * to g. She needs modulus n, generator g and group key b from 	 * the parameters and Bob's public key v = (u^-1)^b from his 	 * certificate. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|rsa
operator|->
name|q
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r mod n */
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y^b mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|v
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r y^b mod n */
name|temp
operator|=
name|BN_cmp
argument_list|(
name|y
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^k = v^r y^b mod n: %s\n"
argument_list|,
name|temp
operator|==
literal|0
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the GQ parameters and keys as a RSA private key encoded 	 * in PEM. 	 * 	 * n	modulus n 	 * e	group key b 	 * p	private key u 	 * q	public key (u^-1)^b 	 * (remaining values are not used) 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"GQpar"
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate Mu-Varadharajan (MV) parameters and keys  *  * The Mu-Varadharajan (MV) cryptosystem is useful when servers  * broadcast messages to clients, but clients never send messages to  * servers. There is one encryption key for the server and a separate  * decryption key for each client. It operates something like a  * pay-per-view satellite broadcasting system where the session key is  * encrypted by the broadcaster and the decryption keys are held in a  * tamperproof set-top box. We don't use it this way, but read on.  *  * The MV parameters and private encryption key hide in a DSA cuckoo  * structure which uses the same parameters, but generated in a  * different way. The values are used in an encryption scheme similar to  * El Gamal cryptography and a polynomial formed from the expansion of  * product terms (x - x[j]), as described in Mu, Y., and V.  * Varadharajan: Robust and Secure Broadcasting, Proc. Indocrypt 2001,  * 223-231. The paper has significant errors and serious omissions.  *  * Let q be the product of n distinct primes s'[j] (j = 1...n), where  * each s'[j] has m significant bits. Let p be a prime p = 2 * q + 1, so  * that q and each s'[j] divide p - 1 and p has M = n * m + 1  * significant bits. Let g be a generator of Zp; that is, gcd(g, p - 1)  * = 1 and g^q = 1 mod p. We do modular arithmetic over Zq and then  * project into Zp* as exponents of g. Sometimes we have to compute an  * inverse b^-1 of random b in Zq, but for that purpose we require  * gcd(b, q) = 1. We expect M to be in the 500-bit range and n  * relatively small, like 30. Associated with each s'[j] is an element  * s[j] such that s[j] s'[j] = s'[j] mod q. We find s[j] as the quotient  * (q + s'[j]) / s'[j]. These are the parameters of the scheme and they  * are expensive to compute.  *  * We set up an instance of the scheme as follows. A set of random  * values x[j] mod q (j = 1...n), are generated as the zeros of a  * polynomial of order n. The product terms (x - x[j]) are expanded to  * form coefficients a[i] mod q (i = 0...n) in powers of x. These are  * used as exponents of the generator g mod p to generate the private  * encryption key A. The pair (gbar, ghat) of public server keys and the  * pairs (xbar[j], xhat[j]) (j = 1...n) of private client keys are used  * to construct the decryption keys. The devil is in the details.  *  * This routine generates a private encryption file including the  * private encryption key E and public key (gbar, ghat). It then  * generates decryption files including the private key (xbar[j],  * xhat[j]) for each client. E is a permutation that encrypts a block  * y = E x. The jth client computes the inverse permutation E^-1 =  * gbar^xhat[j] ghat^xbar[j] and decrypts the block x = E^-1 y.  *  * The distinguishing characteristic of this scheme is the capability to  * revoke keys. Included in the calculation of E, gbar and ghat is the  * product s = prod(s'[j]) (j = 1...n) above. If the factor s'[j] is  * subsequently removed from the product and E, gbar and ghat  * recomputed, the jth client will no longer be able to compute E^-1 and  * thus unable to decrypt the block.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* DSA cuckoo nest */
name|gen_mv
parameter_list|(
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* DSA parameters */
name|DSA
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
modifier|*
name|x
decl_stmt|;
comment|/* polynomial zeros vector */
name|BIGNUM
modifier|*
modifier|*
name|a
decl_stmt|;
comment|/* polynomial coefficient vector */
name|BIGNUM
modifier|*
modifier|*
name|g
decl_stmt|;
comment|/* public key vector */
name|BIGNUM
modifier|*
modifier|*
name|s
decl_stmt|,
modifier|*
modifier|*
name|s1
decl_stmt|;
comment|/* private enabling keys */
name|BIGNUM
modifier|*
modifier|*
name|xbar
decl_stmt|,
modifier|*
modifier|*
name|xhat
decl_stmt|;
comment|/* private keys vector */
name|BIGNUM
modifier|*
name|b
decl_stmt|;
comment|/* group key */
name|BIGNUM
modifier|*
name|b1
decl_stmt|;
comment|/* inverse group key */
name|BIGNUM
modifier|*
name|ss
decl_stmt|;
comment|/* enabling key */
name|BIGNUM
modifier|*
name|biga
decl_stmt|;
comment|/* master encryption key */
name|BIGNUM
modifier|*
name|bige
decl_stmt|;
comment|/* session encryption key */
name|BIGNUM
modifier|*
name|gbar
decl_stmt|,
modifier|*
name|ghat
decl_stmt|;
comment|/* public key */
name|BIGNUM
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|w
decl_stmt|;
comment|/* BN scratch */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
name|char
name|ident
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * Generate MV parameters. 	 * 	 * The object is to generate a multiplicative group Zp* modulo a 	 * prime p and a subset Zq mod q, where q is the product of n 	 * distinct primes s'[j] (j = 1...n) and q divides p - 1. We 	 * first generate n distinct primes, which may have to be 	 * regenerated later. As a practical matter, it is tough to find 	 * more than 31 distinct primes for modulus 512 or 61 primes for 	 * modulus 1024. The latter can take several hundred iterations 	 * and several minutes on a Sun Blade 1000. 	 */
name|n
operator|=
name|nkeys
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating MV parameters for %d keys (%d bits)...\n"
argument_list|,
name|n
argument_list|,
name|modulus
operator|/
name|n
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|w
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|b1
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DSA
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
name|s1
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Birthdays %d\r"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|BN_generate_prime
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|,
name|modulus
operator|/
name|n
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_cmp
argument_list|(
name|s1
index|[
name|i
index|]
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|j
condition|)
break|break;
name|temp
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Birthday keys rejected %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the modulus q as the product of the primes. Compute 	 * the modulus p as 2 * q + 1 and test p for primality. If p 	 * is composite, replace one of the primes with a new distinct 	 * one and try again. Note that q will hardly be a secret since 	 * we have to reveal p to servers and clients. However, 	 * factoring q to find the primes should be adequately hard, as 	 * this is the same problem considered hard in RSA. Question: is 	 * it as hard to find n small prime factors totalling n bits as 	 * it is to find two large prime factors totalling n bits? 	 * Remember, the bad guy doesn't know n. 	 */
name|temp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate keys rejected %d\r"
argument_list|,
operator|++
name|temp
argument_list|)
expr_stmt|;
name|BN_one
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
name|BN_mul
argument_list|(
name|dsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_add_word
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_prime
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|BN_prime_checks
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
name|j
operator|=
name|temp
operator|%
name|n
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_generate_prime
argument_list|(
name|u
argument_list|,
name|modulus
operator|/
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_cmp
argument_list|(
name|u
argument_list|,
name|s1
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|n
condition|)
break|break;
block|}
name|BN_copy
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate keys rejected %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the generator g using a random roll such that 	 * gcd(g, p - 1) = 1 and g^q = 1. This is a generator of p, not 	 * q. 	 */
name|BN_copy
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_sub_word
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|dsa
operator|->
name|g
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
continue|continue;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * Compute s[j] such that s[j] * s'[j] = s'[j] for all j. The 	 * easy way to do this is to compute q + s'[j] and divide the 	 * result by s'[j]. Exercise for the student: prove the 	 * remainder is always zero. 	 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|s
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_add
argument_list|(
name|s
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
name|s
index|[
name|j
index|]
argument_list|,
name|u
argument_list|,
name|s
index|[
name|j
index|]
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup is now complete. Roll random polynomial roots x[j] 	 * (0< x[j]< q) for all j. While it may not be strictly 	 * necessary, Make sure each root has no factors in common with 	 * q. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating polynomial coefficients for %d roots (%d bits)\n"
argument_list|,
name|n
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|x
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|x
index|[
name|j
index|]
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|x
index|[
name|j
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Generate polynomial coefficients a[i] (i = 0...n) from the 	 * expansion of root products (x - x[j]) mod q for all j. The 	 * method is a present from Charlie Boncelet. 	 */
name|a
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_zero
argument_list|(
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|BN_copy
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|w
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|u
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate g[i] = g^a[i] mod p for all i and the generator g. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating g[i] parameters\n"
argument_list|)
expr_stmt|;
name|g
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|g
index|[
name|i
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify prod(g[i]^(a[i] x[j]^i)) = 1 for all i, j; otherwise, 	 * exit. Note the a[i] x[j]^i exponent is computed mod q, but 	 * the g[i] is computed mod p. also note the expression given in 	 * the paper is incorrect. 	 */
name|temp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_one
argument_list|(
name|u
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm prod(g[i]^(x[j]^i)) = 1 for all i, j: %s\n"
argument_list|,
name|temp
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Make private encryption key A. Keep it around for awhile, 	 * since it is expensive to compute. 	 */
name|biga
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
name|biga
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|g
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|biga
argument_list|,
name|biga
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Roll private random group key b mod q (0< b< q), where 	 * gcd(b, q) = 1 to guarantee b^1 exists, then compute b^-1 	 * mod q. If b is changed, the client keys must be recomputed. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|b
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
name|BN_mod_inverse
argument_list|(
name|b1
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Make private client keys (xbar[j], xhat[j]) for all j. Note 	 * that the keys for the jth client involve s[j], but not s'[j] 	 * or the product s = prod(s'[j]) mod q, which is the enabling 	 * key. 	 */
name|xbar
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|xhat
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BIGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|xbar
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|xhat
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_zero
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
condition|)
continue|continue;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|x
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|,
name|xbar
index|[
name|j
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|BN_mod_mul
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|,
name|xbar
index|[
name|j
index|]
argument_list|,
name|b1
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|,
name|xhat
index|[
name|j
index|]
argument_list|,
name|s
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The enabling key is initially q by construction. We can 	 * revoke client j by dividing q by s'[j]. The quotient becomes 	 * the enabling key s. Note we always have to revoke one key; 	 * otherwise, the plaintext and cryptotext would be identical. 	 */
name|ss
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_copy
argument_list|(
name|ss
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
name|ss
argument_list|,
name|u
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|s1
index|[
name|n
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Make private server encryption key E = A^s and public server 	 * keys gbar = g^s mod p and ghat = g^(s b) mod p. The (gbar, 	 * ghat) is the public key provided to the server, which uses it 	 * to compute the session encryption key and public key included 	 * in its messages. These values must be regenerated if the 	 * enabling key is changed. 	 */
name|bige
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|gbar
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ghat
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bige
argument_list|,
name|biga
argument_list|,
name|ss
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|gbar
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|ss
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|ss
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|ghat
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * We produce the key media in three steps. The first step is to 	 * generate the private values that do not depend on the 	 * enabling key. These include the server values p, q, g, b, A 	 * and the client values s'[j], xbar[j] and xhat[j] for each j. 	 * The p, xbar[j] and xhat[j] values are encoded in private 	 * files which are distributed to respective clients. The p, q, 	 * g, A and s'[j] values (will be) written to a secret file to 	 * be read back later. 	 * 	 * The secret file (will be) read back at some later time to 	 * enable/disable individual keys and generate/regenerate the 	 * enabling key s. The p, q, E, gbar and ghat values are written 	 * to a secret file to be read back later by the server. 	 * 	 * The server reads the secret file and rolls the session key 	 * k, which is used only once, then computes E^k, gbar^k and 	 * ghat^k. The E^k is the session encryption key. The encrypted 	 * data, gbar^k and ghat^k are transmtted to clients in an 	 * extension field. The client receives the message and computes 	 * x = (gbar^k)^xbar[j] (ghat^k)^xhat[j], finds the session 	 * encryption key E^k as the inverse x^-1 and decrypts the data. 	 */
name|BN_copy
argument_list|(
name|dsa
operator|->
name|g
argument_list|,
name|bige
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|priv_key
operator|=
name|BN_dup
argument_list|(
name|gbar
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|ghat
argument_list|)
expr_stmt|;
comment|/* 	 * Write the MV server parameters and keys as a DSA private key 	 * encoded in PEM. 	 * 	 * p	modulus p 	 * q	modulus q (used only to generate k) 	 * g	E mod p 	 * priv_key gbar mod p 	 * pub_key ghat mod p 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"MVpar"
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
name|id
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
comment|/* 	 * Write the parameters and private key (xbar[j], xhat[j]) for 	 * all j as a DSA private key encoded in PEM. It is used only by 	 * the designated recipient(s) who pay a suitably outrageous fee 	 * for its use. 	 */
name|sdsa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DSA
argument_list|)
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|p
operator|=
name|BN_dup
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|q
operator|=
name|BN_dup
argument_list|(
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|g
operator|=
name|BN_dup
argument_list|(
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|priv_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|pub_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_copy
argument_list|(
name|sdsa
operator|->
name|priv_key
argument_list|,
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|sdsa
operator|->
name|pub_key
argument_list|,
name|xhat
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|sdsa
operator|->
name|pub_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|sdsa
operator|->
name|priv_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|x
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|s
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Revoke key %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Write the client parameters as a DSA private key 		 * encoded in PEM. We don't make links for these. 		 * 		 * p	modulus p 		 * priv_key xbar[j] mod q 		 * pub_key xhat[j] mod q 		 * (remaining values are not used) 		 */
name|sprintf
argument_list|(
name|ident
argument_list|,
literal|"MVkey%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
name|ident
argument_list|,
name|trustname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|sdsa
argument_list|)
expr_stmt|;
name|PEM_write_PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|passwd2
condition|?
name|EVP_des_cbc
argument_list|()
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ntpkey_%s_%s.%lu\n"
argument_list|,
name|ident
argument_list|,
name|trustname
argument_list|,
name|epoch
operator|+
name|JAN_1970
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stdout
argument_list|,
name|sdsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the countries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_free
argument_list|(
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|b1
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|biga
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|bige
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|gbar
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|ghat
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|sdsa
argument_list|)
expr_stmt|;
comment|/* 	 * Free the world. 	 */
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xbar
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xhat
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate X509v3 scertificate.  *  * The certificate consists of the version number, serial number,  * validity interval, issuer name, subject name and public key. For a  * self-signed certificate, the issuer name is the same as the subject  * name and these items are signed using the subject private key. The  * validity interval extends from the current time to the same time one  * year hence. For NTP purposes, it is convenient to use the NTP seconds  * of the current time as the serial number.  */
end_comment

begin_function
name|int
name|x509
parameter_list|(
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|,
comment|/* generic signature algorithm */
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|,
comment|/* generic digest algorithm */
name|char
modifier|*
name|gqpub
parameter_list|,
comment|/* identity extension (hex string) */
name|char
modifier|*
name|exten
comment|/* private cert extension */
parameter_list|)
block|{
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_NAME
modifier|*
name|subj
decl_stmt|;
comment|/* distinguished (common) name */
name|X509_EXTENSION
modifier|*
name|ex
decl_stmt|;
comment|/* X509v3 extension */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|ASN1_INTEGER
modifier|*
name|serial
decl_stmt|;
comment|/* serial number */
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
comment|/* digest/signature scheme name */
name|char
name|pathbuf
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Generate X509 self-signed certificate. 	 * 	 * Set the certificate serial to the NTP seconds for grins. Set 	 * the version to 3. Set the subject name and issuer name to the 	 * subject name in the request. Set the initial validity to the 	 * current time and the final validity one year hence.  	 */
name|id
operator|=
name|OBJ_nid2sn
argument_list|(
name|md
operator|->
name|pkey_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating certificate %s\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|cert
operator|=
name|X509_new
argument_list|()
expr_stmt|;
name|X509_set_version
argument_list|(
name|cert
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
name|serial
operator|=
name|ASN1_INTEGER_new
argument_list|()
expr_stmt|;
name|ASN1_INTEGER_set
argument_list|(
name|serial
argument_list|,
name|epoch
operator|+
name|JAN_1970
argument_list|)
expr_stmt|;
name|X509_set_serialNumber
argument_list|(
name|cert
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|ASN1_INTEGER_free
argument_list|(
name|serial
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|X509_gmtime_adj
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|,
name|YEAR
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hostname
argument_list|,
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|trustname
argument_list|,
name|strlen
argument_list|(
name|trustname
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_set_pubkey
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Assign key fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Add X509v3 extensions if present. These represent the minimum 	 * set defined in RFC3280 less the certificate_policy extension, 	 * which is seriously obfuscated in OpenSSL. 	 */
comment|/* 	 * The basic_constraints extension CA:TRUE allows servers to 	 * sign client certficitates. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_basic_constraints
argument_list|,
name|BASIC_CONSTRAINTS
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_basic_constraints
argument_list|,
name|BASIC_CONSTRAINTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* 	 * The key_usage extension designates the purposes the key can 	 * be used for. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_key_usage
argument_list|,
name|KEY_USAGE
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_key_usage
argument_list|,
name|KEY_USAGE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* 	 * The subject_key_identifier is used for the GQ public key. 	 * This should not be controversial. 	 */
if|if
condition|(
name|gqpub
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|LN_subject_key_identifier
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_subject_key_identifier
argument_list|,
name|gqpub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The extended key usage extension is used for special purpose 	 * here. The semantics probably do not conform to the designer's 	 * intent and will likely change in future. 	 *  	 * "trustRoot" designates a root authority 	 * "private" designates a private certificate 	 */
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_ext_key_usage
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_ext_key_usage
argument_list|,
name|exten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sign and verify. 	 */
name|X509_sign
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Verify %s certificate fails\n%s\n"
argument_list|,
name|id
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Write the certificate encoded in PEM. 	 */
name|sprintf
argument_list|(
name|pathbuf
argument_list|,
literal|"%scert"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
name|pathbuf
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|PEM_write_X509
argument_list|(
name|str
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|X509_print_fp
argument_list|(
name|stdout
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|fslink
argument_list|(
literal|"cert"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* asn2ntp is not used */
end_comment

begin_comment
comment|/*  * asn2ntp - convert ASN1_TIME time structure to NTP time  */
end_comment

begin_comment
unit|u_long asn2ntp	( 	ASN1_TIME *asn1time
comment|/* pointer to ASN1_TIME structure */
end_comment

begin_comment
unit|) { 	char	*v;
comment|/* pointer to ASN1_TIME string */
end_comment

begin_comment
unit|struct	tm tm;
comment|/* time decode structure time */
end_comment

begin_comment
comment|/* 	 * Extract time string YYMMDDHHMMSSZ from ASN.1 time structure. 	 * Note that the YY, MM, DD fields start with one, the HH, MM, 	 * SS fiels start with zero and the Z character should be 'Z' 	 * for UTC. Also note that years less than 50 map to years 	 * greater than 100. Dontcha love ASN.1? 	 */
end_comment

begin_endif
unit|if (asn1time->length> 13) 		return (-1); 	v = (char *)asn1time->data; 	tm.tm_year = (v[0] - '0') * 10 + v[1] - '0'; 	if (tm.tm_year< 50) 		tm.tm_year += 100; 	tm.tm_mon = (v[2] - '0') * 10 + v[3] - '0' - 1; 	tm.tm_mday = (v[4] - '0') * 10 + v[5] - '0'; 	tm.tm_hour = (v[6] - '0') * 10 + v[7] - '0'; 	tm.tm_min = (v[8] - '0') * 10 + v[9] - '0'; 	tm.tm_sec = (v[10] - '0') * 10 + v[11] - '0'; 	tm.tm_wday = 0; 	tm.tm_yday = 0; 	tm.tm_isdst = 0; 	return (mktime(&tm) + JAN_1970); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Callback routine  */
end_comment

begin_function
name|void
name|cb
parameter_list|(
name|int
name|n1
parameter_list|,
comment|/* arg 1 */
name|int
name|n2
parameter_list|,
comment|/* arg 2 */
name|void
modifier|*
name|chr
comment|/* arg 3 */
parameter_list|)
block|{
switch|switch
condition|(
name|n1
condition|)
block|{
case|case
literal|0
case|:
name|d0
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|d1
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d2
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|d3
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t\t\t\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d3
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_comment
comment|/*  * Generate key  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|genkey
parameter_list|(
name|char
modifier|*
name|type
parameter_list|,
comment|/* key type (RSA or DSA) */
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"RSA"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gen_rsa
argument_list|(
name|id
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"DSA"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gen_dsa
argument_list|(
name|id
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid %s key type %s\n"
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate file header  */
end_comment

begin_function
name|FILE
modifier|*
name|fheader
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
comment|/* file name id */
specifier|const
name|char
modifier|*
name|name
comment|/* owner name */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"ntpkey_%s_%s.%lu"
argument_list|,
name|id
argument_list|,
name|name
argument_list|,
name|epoch
operator|+
name|JAN_1970
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Write"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# %s\n# %s"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate symbolic links  */
end_comment

begin_function
name|void
name|fslink
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
comment|/* file name id */
specifier|const
name|char
modifier|*
name|name
comment|/* owner name */
parameter_list|)
block|{
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* link name */
name|int
name|temp
decl_stmt|;
name|sprintf
argument_list|(
name|linkname
argument_list|,
literal|"ntpkey_%s_%s"
argument_list|,
name|id
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|linkname
argument_list|)
expr_stmt|;
name|temp
operator|=
name|symlink
argument_list|(
name|filename
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating new %s file and link\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s->%s\n"
argument_list|,
name|linkname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

