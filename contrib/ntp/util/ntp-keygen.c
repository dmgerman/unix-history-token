begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Program to generate cryptographic keys for ntp clients and servers  *  * This program generates password encrypted data files for use with the  * Autokey security protocol and Network Time Protocol Version 4. Files  * are prefixed with a header giving the name and date of creation  * followed by a type-specific descriptive label and PEM-encoded data  * structure compatible with programs of the OpenSSL library.  *  * All file names are like "ntpkey_<type>_<hostname>.<filestamp>", where  *<type> is the file type,<hostname> the generating host name and  *<filestamp> the generation time in NTP seconds. The NTP programs  * expect generic names such as "ntpkey_<type>_whimsy.udel.edu" with the  * association maintained by soft links. Following is a list of file  * types; the first line is the file name and the second link name.  *  * ntpkey_MD5key_<hostname>.<filestamp>  * 	MD5 (128-bit) keys used to compute message digests in symmetric  *	key cryptography  *  * ntpkey_RSAhost_<hostname>.<filestamp>  * ntpkey_host_<hostname>  *	RSA private/public host key pair used for public key signatures  *  * ntpkey_RSAsign_<hostname>.<filestamp>  * ntpkey_sign_<hostname>  *	RSA private/public sign key pair used for public key signatures  *  * ntpkey_DSAsign_<hostname>.<filestamp>  * ntpkey_sign_<hostname>  *	DSA Private/public sign key pair used for public key signatures  *  * Available digest/signature schemes  *  * RSA:	RSA-MD2, RSA-MD5, RSA-SHA, RSA-SHA1, RSA-MDC2, EVP-RIPEMD160  * DSA:	DSA-SHA, DSA-SHA1  *  * ntpkey_XXXcert_<hostname>.<filestamp>  * ntpkey_cert_<hostname>  *	X509v3 certificate using RSA or DSA public keys and signatures.  *	XXX is a code identifying the message digest and signature  *	encryption algorithm  *  * Identity schemes. The key type par is used for the challenge; the key  * type key is used for the response.  *  * ntpkey_IFFkey_<groupname>.<filestamp>  * ntpkey_iffkey_<groupname>  *	Schnorr (IFF) identity parameters and keys  *  * ntpkey_GQkey_<groupname>.<filestamp>,  * ntpkey_gqkey_<groupname>  *	Guillou-Quisquater (GQ) identity parameters and keys  *  * ntpkey_MVkeyX_<groupname>.<filestamp>,  * ntpkey_mvkey_<groupname>  *	Mu-Varadharajan (MV) identity parameters and keys  *  * Note: Once in a while because of some statistical fluke this program  * fails to generate and verify some cryptographic data, as indicated by  * exit status -1. In this case simply run the program again. If the  * program does complete with exit code 0, the data are correct as  * verified.  *  * These cryptographic routines are characterized by the prime modulus  * size in bits. The default value of 512 bits is a compromise between  * cryptographic strength and computing time and is ordinarily  * considered adequate for this application. The routines have been  * tested with sizes of 256, 512, 1024 and 2048 bits. Not all message  * digest and signature encryption schemes work with sizes less than 512  * bits. The computing time for sizes greater than 2048 bits is  * prohibitive on all but the fastest processors. An UltraSPARC Blade  * 1000 took something over nine minutes to generate and verify the  * values with size 2048. An old SPARC IPC would take a week.  *  * The OpenSSL library used by this program expects a random seed file.  * As described in the OpenSSL documentation, the file name defaults to  * first the RANDFILE environment variable in the user's home directory  * and then .rnd in the user's home directory.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"ntp.h"
end_include

begin_include
include|#
directive|include
file|"ntp_random.h"
end_include

begin_include
include|#
directive|include
file|"ntp_stdlib.h"
end_include

begin_include
include|#
directive|include
file|"ntp_assert.h"
end_include

begin_include
include|#
directive|include
file|"ntp_libopts.h"
end_include

begin_include
include|#
directive|include
file|"ntp_unixtime.h"
end_include

begin_include
include|#
directive|include
file|"ntp-keygen-opts.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL
end_ifdef

begin_include
include|#
directive|include
file|"openssl/bn.h"
end_include

begin_include
include|#
directive|include
file|"openssl/evp.h"
end_include

begin_include
include|#
directive|include
file|"openssl/err.h"
end_include

begin_include
include|#
directive|include
file|"openssl/rand.h"
end_include

begin_include
include|#
directive|include
file|"openssl/pem.h"
end_include

begin_include
include|#
directive|include
file|"openssl/x509v3.h"
end_include

begin_include
include|#
directive|include
file|<openssl/objects.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL */
end_comment

begin_include
include|#
directive|include
file|<ssl_applink.c>
end_include

begin_define
define|#
directive|define
name|_UC
parameter_list|(
name|str
parameter_list|)
value|((char *)(intptr_t)(str))
end_define

begin_comment
comment|/*  * Cryptodefines  */
end_comment

begin_define
define|#
directive|define
name|MD5KEYS
value|10
end_define

begin_comment
comment|/* number of keys generated of each type */
end_comment

begin_define
define|#
directive|define
name|MD5SIZE
value|20
end_define

begin_comment
comment|/* maximum key size */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_define
define|#
directive|define
name|PLEN
value|512
end_define

begin_comment
comment|/* default prime modulus size (bits) */
end_comment

begin_define
define|#
directive|define
name|ILEN
value|256
end_define

begin_comment
comment|/* default identity modulus size (bits) */
end_comment

begin_define
define|#
directive|define
name|MVMAX
value|100
end_define

begin_comment
comment|/* max MV parameters */
end_comment

begin_comment
comment|/*  * Strings used in X509v3 extension fields  */
end_comment

begin_define
define|#
directive|define
name|KEY_USAGE
value|"digitalSignature,keyCertSign"
end_define

begin_define
define|#
directive|define
name|BASIC_CONSTRAINTS
value|"critical,CA:TRUE"
end_define

begin_define
define|#
directive|define
name|EXT_KEY_PRIVATE
value|"private"
end_define

begin_define
define|#
directive|define
name|EXT_KEY_TRUST
value|"trustRoot"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
name|FILE
modifier|*
name|fheader
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gen_md5
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|followlink
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_function_decl
name|EVP_PKEY
modifier|*
name|gen_rsa
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|gen_dsa
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|gen_iffkey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|gen_gqkey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|gen_mvkey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gen_mvserv
parameter_list|(
name|char
modifier|*
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|x509
parameter_list|(
name|EVP_PKEY
modifier|*
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cb
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|genkey
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|EVP_PKEY
modifier|*
name|readkey
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|writekey
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_long
name|asn2ntp
parameter_list|(
name|ASN1_TIME
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Program variables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command line argument */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|lifetime
init|=
name|DAYSPERYEAR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* certificate lifetime (days) */
end_comment

begin_decl_stmt
name|int
name|nkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MV keys */
end_comment

begin_decl_stmt
name|time_t
name|epoch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unix epoch (seconds) since 1970 */
end_comment

begin_decl_stmt
name|u_int
name|fstamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NTP filestamp */
end_comment

begin_decl_stmt
name|char
name|hostbuf
index|[
name|MAXHOSTNAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host, used in cert filenames */
end_comment

begin_decl_stmt
name|char
modifier|*
name|groupname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* group name */
end_comment

begin_decl_stmt
name|char
name|certnamebuf
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|certname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* certificate subject/issuer name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|passwd1
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input private key password */
end_comment

begin_decl_stmt
name|char
modifier|*
name|passwd2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output private key password */
end_comment

begin_decl_stmt
name|char
name|filename
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_decl_stmt
name|u_int
name|modulus
init|=
name|PLEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prime modulus size (bits) */
end_comment

begin_decl_stmt
name|u_int
name|modulus2
init|=
name|ILEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* identity modulus size (bits) */
end_comment

begin_decl_stmt
name|long
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* callback counters */
end_comment

begin_decl_stmt
specifier|const
name|EVP_CIPHER
modifier|*
name|cipher
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_WINNT
end_ifdef

begin_function_decl
name|BOOL
name|init_randfile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Don't try to follow symbolic links on Windows.  Assume link == file.  */
end_comment

begin_function
name|int
name|readlink
parameter_list|(
name|char
modifier|*
name|link
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|strlen
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Don't try to create symbolic links on Windows, that is supported on  * Vista and later only.  Instead, if CreateHardLink is available (XP  * and later), hardlink the linkname to the original filename.  On  * earlier systems, user must rename file to match expected link for  * ntpd to find it.  To allow building a ntp-keygen.exe which loads on  * Windows pre-XP, runtime link to CreateHardLinkA().  */
end_comment

begin_function
name|int
name|symlink
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|linkname
parameter_list|)
block|{
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|PCREATEHARDLINKA
function_decl|)
parameter_list|(
name|__in
name|LPCSTR
name|lpFileName
parameter_list|,
name|__in
name|LPCSTR
name|lpExistingFileName
parameter_list|,
name|__reserved
name|LPSECURITY_ATTRIBUTES
name|lpSA
parameter_list|)
function_decl|;
specifier|static
name|PCREATEHARDLINKA
name|pCreateHardLinkA
decl_stmt|;
specifier|static
name|int
name|tried
decl_stmt|;
name|HMODULE
name|hDll
decl_stmt|;
name|FARPROC
name|pfn
decl_stmt|;
name|int
name|link_created
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
if|if
condition|(
operator|!
name|tried
condition|)
block|{
name|tried
operator|=
name|TRUE
expr_stmt|;
name|hDll
operator|=
name|LoadLibrary
argument_list|(
literal|"kernel32"
argument_list|)
expr_stmt|;
name|pfn
operator|=
name|GetProcAddress
argument_list|(
name|hDll
argument_list|,
literal|"CreateHardLinkA"
argument_list|)
expr_stmt|;
name|pCreateHardLinkA
operator|=
operator|(
name|PCREATEHARDLINKA
operator|)
name|pfn
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|pCreateHardLinkA
condition|)
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|link_created
operator|=
call|(
modifier|*
name|pCreateHardLinkA
call|)
argument_list|(
name|linkname
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_created
condition|)
return|return
literal|0
return|;
name|saved_errno
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
comment|/* yes we play loose */
name|mfprintf
argument_list|(
name|stderr
argument_list|,
literal|"Create hard link %s to %s failed: %m\n"
argument_list|,
name|linkname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|InitWin32Sockets
parameter_list|()
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No useable winsock.dll\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_WINNT */
end_comment

begin_comment
comment|/*  * followlink() - replace filename with its target if symlink.  *  * Some readlink() implementations do not null-terminate the result.  */
end_comment

begin_function
name|void
name|followlink
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|size_t
name|bufsiz
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|REQUIRE
argument_list|(
name|bufsiz
operator|>
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|readlink
argument_list|(
name|fname
argument_list|,
name|fname
argument_list|,
operator|(
name|int
operator|)
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
name|bufsiz
operator|-
literal|1
condition|)
name|len
operator|=
operator|(
name|int
operator|)
name|bufsiz
operator|-
literal|1
expr_stmt|;
name|fname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Main program  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
comment|/* command line options */
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* initialization vector */
name|int
name|md5key
init|=
literal|0
decl_stmt|;
comment|/* generate MD5 keys */
name|int
name|optct
decl_stmt|;
comment|/* option count */
ifdef|#
directive|ifdef
name|AUTOKEY
name|X509
modifier|*
name|cert
init|=
name|NULL
decl_stmt|;
comment|/* X509 certificate */
name|X509_EXTENSION
modifier|*
name|ext
decl_stmt|;
comment|/* X509v3 extension */
name|EVP_PKEY
modifier|*
name|pkey_host
init|=
name|NULL
decl_stmt|;
comment|/* host key */
name|EVP_PKEY
modifier|*
name|pkey_sign
init|=
name|NULL
decl_stmt|;
comment|/* sign key */
name|EVP_PKEY
modifier|*
name|pkey_iffkey
init|=
name|NULL
decl_stmt|;
comment|/* IFF sever keys */
name|EVP_PKEY
modifier|*
name|pkey_gqkey
init|=
name|NULL
decl_stmt|;
comment|/* GQ server keys */
name|EVP_PKEY
modifier|*
name|pkey_mvkey
init|=
name|NULL
decl_stmt|;
comment|/* MV trusted agen keys */
name|EVP_PKEY
modifier|*
name|pkey_mvpar
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* MV cleient keys */
name|int
name|hostkey
init|=
literal|0
decl_stmt|;
comment|/* generate RSA keys */
name|int
name|iffkey
init|=
literal|0
decl_stmt|;
comment|/* generate IFF keys */
name|int
name|gqkey
init|=
literal|0
decl_stmt|;
comment|/* generate GQ keys */
name|int
name|mvkey
init|=
literal|0
decl_stmt|;
comment|/* update MV keys */
name|int
name|mvpar
init|=
literal|0
decl_stmt|;
comment|/* generate MV parameters */
name|char
modifier|*
name|sign
init|=
name|NULL
decl_stmt|;
comment|/* sign key */
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* temp key */
specifier|const
name|EVP_MD
modifier|*
name|ectx
decl_stmt|;
comment|/* EVP digest */
name|char
name|pathbuf
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme
init|=
name|NULL
decl_stmt|;
comment|/* digest/signature scheme */
specifier|const
name|char
modifier|*
name|ciphername
init|=
name|NULL
decl_stmt|;
comment|/* to encrypt priv. key */
specifier|const
name|char
modifier|*
name|exten
init|=
name|NULL
decl_stmt|;
comment|/* private extension */
name|char
modifier|*
name|grpkey
init|=
name|NULL
decl_stmt|;
comment|/* identity extension */
name|int
name|nid
decl_stmt|;
comment|/* X509 digest/signature scheme */
name|FILE
modifier|*
name|fstr
init|=
name|NULL
decl_stmt|;
comment|/* file handle */
name|char
name|groupbuf
index|[
name|MAXHOSTNAME
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
name|BIO
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_WINNT
comment|/* Initialize before OpenSSL checks */
name|InitWin32Sockets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|init_randfile
argument_list|()
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to initialize .rnd file\n"
argument_list|)
expr_stmt|;
name|ssl_applink
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OPENSSL
name|ssl_check_version
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|ntp_crypto_srandom
argument_list|()
expr_stmt|;
comment|/* 	 * Process options, initialize host name and timestamp. 	 * gethostname() won't null-terminate if hostname is exactly the 	 * length provided for the buffer. 	 */
name|gethostname
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hostbuf
index|[
name|COUNTOF
argument_list|(
name|hostbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hostname
operator|=
name|hostbuf
expr_stmt|;
name|groupname
operator|=
name|hostbuf
expr_stmt|;
name|passwd1
operator|=
name|hostbuf
expr_stmt|;
name|passwd2
operator|=
name|NULL
expr_stmt|;
name|GETTIMEOFDAY
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|epoch
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|fstamp
operator|=
call|(
name|u_int
call|)
argument_list|(
name|epoch
operator|+
name|JAN_1970
argument_list|)
expr_stmt|;
name|optct
operator|=
name|ntpOptionProcess
argument_list|(
operator|&
name|ntp_keygenOptions
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optct
expr_stmt|;
name|argv
operator|+=
name|optct
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
if|if
condition|(
name|SSLeay
argument_list|()
operator|==
name|SSLEAY_VERSION_NUMBER
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using OpenSSL version %s\n"
argument_list|,
name|SSLeay_version
argument_list|(
name|SSLEAY_VERSION
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Built against OpenSSL %s, using version %s\n"
argument_list|,
name|OPENSSL_VERSION_TEXT
argument_list|,
name|SSLeay_version
argument_list|(
name|SSLEAY_VERSION
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|debug
operator|=
name|OPT_VALUE_SET_DEBUG_LEVEL
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|MD5KEY
argument_list|)
condition|)
name|md5key
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOKEY
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|PASSWORD
argument_list|)
condition|)
name|passwd1
operator|=
name|estrdup
argument_list|(
name|OPT_ARG
argument_list|(
name|PASSWORD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|EXPORT_PASSWD
argument_list|)
condition|)
name|passwd2
operator|=
name|estrdup
argument_list|(
name|OPT_ARG
argument_list|(
name|EXPORT_PASSWD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|HOST_KEY
argument_list|)
condition|)
name|hostkey
operator|++
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|SIGN_KEY
argument_list|)
condition|)
name|sign
operator|=
name|estrdup
argument_list|(
name|OPT_ARG
argument_list|(
name|SIGN_KEY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|GQ_PARAMS
argument_list|)
condition|)
name|gqkey
operator|++
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IFFKEY
argument_list|)
condition|)
name|iffkey
operator|++
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|MV_PARAMS
argument_list|)
condition|)
block|{
name|mvkey
operator|++
expr_stmt|;
name|nkeys
operator|=
name|OPT_VALUE_MV_PARAMS
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|MV_KEYS
argument_list|)
condition|)
block|{
name|mvpar
operator|++
expr_stmt|;
name|nkeys
operator|=
name|OPT_VALUE_MV_KEYS
expr_stmt|;
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IMBITS
argument_list|)
condition|)
name|modulus2
operator|=
name|OPT_VALUE_IMBITS
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|MODULUS
argument_list|)
condition|)
name|modulus
operator|=
name|OPT_VALUE_MODULUS
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|CERTIFICATE
argument_list|)
condition|)
name|scheme
operator|=
name|OPT_ARG
argument_list|(
name|CERTIFICATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|CIPHER
argument_list|)
condition|)
name|ciphername
operator|=
name|OPT_ARG
argument_list|(
name|CIPHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|SUBJECT_NAME
argument_list|)
condition|)
name|hostname
operator|=
name|estrdup
argument_list|(
name|OPT_ARG
argument_list|(
name|SUBJECT_NAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IDENT
argument_list|)
condition|)
name|groupname
operator|=
name|estrdup
argument_list|(
name|OPT_ARG
argument_list|(
name|IDENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|LIFETIME
argument_list|)
condition|)
name|lifetime
operator|=
name|OPT_VALUE_LIFETIME
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|PVT_CERT
argument_list|)
condition|)
name|exten
operator|=
name|EXT_KEY_PRIVATE
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|TRUSTED_CERT
argument_list|)
condition|)
name|exten
operator|=
name|EXT_KEY_TRUST
expr_stmt|;
comment|/* 	 * Remove the group name from the hostname variable used 	 * in host and sign certificate file names. 	 */
if|if
condition|(
name|hostname
operator|!=
name|hostbuf
condition|)
name|ptr
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|groupname
operator|=
name|estrdup
argument_list|(
name|ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* -s @group is equivalent to -i group, host unch. */
if|if
condition|(
name|ptr
operator|==
name|hostname
condition|)
name|hostname
operator|=
name|hostbuf
expr_stmt|;
block|}
comment|/* 	 * Derive host certificate issuer/subject names from host name 	 * and optional group.  If no groupname is provided, the issuer 	 * and subject is the hostname with no '@group', and the 	 * groupname variable is pointed to hostname for use in IFF, GQ, 	 * and MV parameters file names. 	 */
if|if
condition|(
name|groupname
operator|==
name|hostbuf
condition|)
block|{
name|certname
operator|=
name|hostname
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|certnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|certnamebuf
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|hostname
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|certname
operator|=
name|certnamebuf
expr_stmt|;
block|}
comment|/* 	 * Seed random number generator and grow weeds. 	 */
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RAND_status
argument_list|()
condition|)
block|{
if|if
condition|(
name|RAND_file_name
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RAND_file_name %s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|RAND_load_file
argument_list|(
name|pathbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RAND_load_file %s not found or empty\n"
argument_list|,
name|pathbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Random seed file %s %u bytes\n"
argument_list|,
name|pathbuf
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|RAND_add
argument_list|(
operator|&
name|epoch
argument_list|,
sizeof|sizeof
argument_list|(
name|epoch
argument_list|)
argument_list|,
literal|4.0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTOKEY */
comment|/* 	 * Create new unencrypted MD5 keys file if requested. If this 	 * option is selected, ignore all other options. 	 */
if|if
condition|(
name|md5key
condition|)
block|{
name|gen_md5
argument_list|(
literal|"md5"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTOKEY
comment|/* 	 * Load previous certificate if available. 	 */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_cert_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstr
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cert
operator|=
name|PEM_read_X509
argument_list|(
name|fstr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Extract subject name. 		 */
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|groupbuf
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
comment|/* 		 * Extract digest/signature scheme. 		 */
if|if
condition|(
name|scheme
operator|==
name|NULL
condition|)
block|{
name|nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|cert
operator|->
name|cert_info
operator|->
name|signature
operator|->
name|algorithm
argument_list|)
expr_stmt|;
name|scheme
operator|=
name|OBJ_nid2sn
argument_list|(
name|nid
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If a key_usage extension field is present, determine 		 * whether this is a trusted or private certificate. 		 */
if|if
condition|(
name|exten
operator|==
name|NULL
condition|)
block|{
name|ptr
operator|=
name|strstr
argument_list|(
name|groupbuf
argument_list|,
literal|"CN="
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|X509_get_ext_count
argument_list|(
name|cert
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ext
operator|=
name|X509_get_ext
argument_list|(
name|cert
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|OBJ_obj2nid
argument_list|(
name|ext
operator|->
name|object
argument_list|)
operator|==
name|NID_ext_key_usage
condition|)
block|{
name|bp
operator|=
name|BIO_new
argument_list|(
name|BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|X509V3_EXT_print
argument_list|(
name|bp
argument_list|,
name|ext
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BIO_gets
argument_list|(
name|bp
argument_list|,
name|pathbuf
argument_list|,
name|MAXFILENAME
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Trust Root"
argument_list|)
operator|==
literal|0
condition|)
name|exten
operator|=
name|EXT_KEY_TRUST
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pathbuf
argument_list|,
literal|"Private"
argument_list|)
operator|==
literal|0
condition|)
name|exten
operator|=
name|EXT_KEY_PRIVATE
expr_stmt|;
name|certname
operator|=
name|estrdup
argument_list|(
name|ptr
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|scheme
operator|==
name|NULL
condition|)
name|scheme
operator|=
literal|"RSA-MD5"
expr_stmt|;
if|if
condition|(
name|ciphername
operator|==
name|NULL
condition|)
name|ciphername
operator|=
literal|"des-ede3-cbc"
expr_stmt|;
name|cipher
operator|=
name|EVP_get_cipherbyname
argument_list|(
name|ciphername
argument_list|)
expr_stmt|;
if|if
condition|(
name|cipher
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown cipher %s\n"
argument_list|,
name|ciphername
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using host %s group %s\n"
argument_list|,
name|hostname
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new encrypted RSA host key file if requested; 	 * otherwise, look for an existing host key file. If not found, 	 * create a new encrypted RSA host key file. If that fails, go 	 * no further. 	 */
if|if
condition|(
name|hostkey
condition|)
name|pkey_host
operator|=
name|genkey
argument_list|(
literal|"RSA"
argument_list|,
literal|"host"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_host
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_host_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey_host
operator|=
name|readkey
argument_list|(
name|filename
argument_list|,
name|passwd1
argument_list|,
operator|&
name|fstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_host
operator|!=
name|NULL
condition|)
block|{
name|followlink
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using host key %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkey_host
operator|=
name|genkey
argument_list|(
literal|"RSA"
argument_list|,
literal|"host"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkey_host
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating host key fails\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create new encrypted RSA or DSA sign keys file if requested; 	 * otherwise, look for an existing sign key file. If not found, 	 * use the host key instead. 	 */
if|if
condition|(
name|sign
operator|!=
name|NULL
condition|)
name|pkey_sign
operator|=
name|genkey
argument_list|(
name|sign
argument_list|,
literal|"sign"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_sign
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_sign_%s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey_sign
operator|=
name|readkey
argument_list|(
name|filename
argument_list|,
name|passwd1
argument_list|,
operator|&
name|fstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_sign
operator|!=
name|NULL
condition|)
block|{
name|followlink
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using sign key %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkey_sign
operator|=
name|pkey_host
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using host key as sign key\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create new encrypted GQ server keys file if requested; 	 * otherwise, look for an exisiting file. If found, fetch the 	 * public key for the certificate. 	 */
if|if
condition|(
name|gqkey
condition|)
name|pkey_gqkey
operator|=
name|gen_gqkey
argument_list|(
literal|"gqkey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_gqkey
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_gqkey_%s"
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|pkey_gqkey
operator|=
name|readkey
argument_list|(
name|filename
argument_list|,
name|passwd1
argument_list|,
operator|&
name|fstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_gqkey
operator|!=
name|NULL
condition|)
block|{
name|followlink
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using GQ parameters %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkey_gqkey
operator|!=
name|NULL
condition|)
name|grpkey
operator|=
name|BN_bn2hex
argument_list|(
name|pkey_gqkey
operator|->
name|pkey
operator|.
name|rsa
operator|->
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * Write the nonencrypted GQ client parameters to the stdout 	 * stream. The parameter file is the server key file with the 	 * private key obscured. 	 */
if|if
condition|(
name|pkey_gqkey
operator|!=
name|NULL
operator|&&
name|HAVE_OPT
argument_list|(
name|ID_KEY
argument_list|)
condition|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_gqpar_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing GQ parameters %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|pkey_gqkey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|p
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|q
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write the encrypted GQ server keys to the stdout stream. 	 */
if|if
condition|(
name|pkey_gqkey
operator|!=
name|NULL
operator|&&
name|passwd2
operator|!=
name|NULL
condition|)
block|{
name|RSA
modifier|*
name|rsa
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_gqkey_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing GQ keys %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|pkey_gqkey
operator|->
name|pkey
operator|.
name|rsa
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create new encrypted IFF server keys file if requested; 	 * otherwise, look for existing file. 	 */
if|if
condition|(
name|iffkey
condition|)
name|pkey_iffkey
operator|=
name|gen_iffkey
argument_list|(
literal|"iffkey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_iffkey
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_iffkey_%s"
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|pkey_iffkey
operator|=
name|readkey
argument_list|(
name|filename
argument_list|,
name|passwd1
argument_list|,
operator|&
name|fstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_iffkey
operator|!=
name|NULL
condition|)
block|{
name|followlink
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using IFF keys %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Write the nonencrypted IFF client parameters to the stdout 	 * stream. The parameter file is the server key file with the 	 * private key obscured. 	 */
if|if
condition|(
name|pkey_iffkey
operator|!=
name|NULL
operator|&&
name|HAVE_OPT
argument_list|(
name|ID_KEY
argument_list|)
condition|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_iffpar_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing IFF parameters %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|pkey_iffkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|priv_key
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write the encrypted IFF server keys to the stdout stream. 	 */
if|if
condition|(
name|pkey_iffkey
operator|!=
name|NULL
operator|&&
name|passwd2
operator|!=
name|NULL
condition|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_iffkey_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing IFF keys %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|pkey_iffkey
operator|->
name|pkey
operator|.
name|dsa
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create new encrypted MV trusted-authority keys file if 	 * requested; otherwise, look for existing keys file. 	 */
if|if
condition|(
name|mvkey
condition|)
name|pkey_mvkey
operator|=
name|gen_mvkey
argument_list|(
literal|"mv"
argument_list|,
name|pkey_mvpar
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_mvkey
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_mvta_%s"
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|pkey_mvkey
operator|=
name|readkey
argument_list|(
name|filename
argument_list|,
name|passwd1
argument_list|,
operator|&
name|fstamp
argument_list|,
name|pkey_mvpar
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_mvkey
operator|!=
name|NULL
condition|)
block|{
name|followlink
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using MV keys %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Write the nonencrypted MV client parameters to the stdout 	 * stream. For the moment, we always use the client parameters 	 * associated with client key 1. 	 */
if|if
condition|(
name|pkey_mvkey
operator|!=
name|NULL
operator|&&
name|HAVE_OPT
argument_list|(
name|ID_KEY
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_mvpar_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing MV parameters %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|pkey_mvpar
index|[
literal|2
index|]
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write the encrypted MV server keys to the stdout stream. 	 */
if|if
condition|(
name|pkey_mvkey
operator|!=
name|NULL
operator|&&
name|passwd2
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_mvkey_%s.%u"
argument_list|,
name|groupname
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Writing MV keys %s to stdout\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|pkey_mvpar
index|[
literal|1
index|]
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|stdout
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|pkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Decode the digest/signature scheme and create the 	 * certificate. Do this every time we run the program. 	 */
name|ectx
operator|=
name|EVP_get_digestbyname
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|ectx
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid digest/signature combination %s\n"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|x509
argument_list|(
name|pkey_sign
argument_list|,
name|ectx
argument_list|,
name|grpkey
argument_list|,
name|exten
argument_list|,
name|certname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTOKEY */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate semi-random MD5 keys compatible with NTPv3 and NTPv4. Also,  * if OpenSSL is around, generate random SHA1 keys compatible with  * symmetric key cryptography.  */
end_comment

begin_function
name|int
name|gen_md5
parameter_list|(
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|u_char
name|md5key
index|[
name|MD5SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* MD5 key */
name|FILE
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL
name|u_char
name|keystr
index|[
name|MD5SIZE
index|]
decl_stmt|;
name|u_char
name|hexstr
index|[
literal|2
operator|*
name|MD5SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|u_char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
endif|#
directive|endif
comment|/* OPENSSL */
name|str
operator|=
name|fheader
argument_list|(
literal|"MD5key"
argument_list|,
name|id
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MD5KEYS
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MD5SIZE
condition|;
name|j
operator|++
control|)
block|{
name|int
name|temp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|ntp_crypto_random_buf
argument_list|(
operator|&
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ntp_crypto_random_buf() failed.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|temp
operator|>
literal|0x20
operator|&&
name|temp
operator|<
literal|0x7f
condition|)
break|break;
block|}
name|md5key
index|[
name|j
index|]
operator|=
operator|(
name|u_char
operator|)
name|temp
expr_stmt|;
block|}
name|md5key
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%2d MD5 %s  # MD5 key\n"
argument_list|,
name|i
argument_list|,
name|md5key
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OPENSSL
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|MD5KEYS
condition|;
name|i
operator|++
control|)
block|{
name|RAND_bytes
argument_list|(
name|keystr
argument_list|,
literal|20
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MD5SIZE
condition|;
name|j
operator|++
control|)
block|{
name|hexstr
index|[
literal|2
operator|*
name|j
index|]
operator|=
name|hex
index|[
name|keystr
index|[
name|j
index|]
operator|>>
literal|4
index|]
expr_stmt|;
name|hexstr
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|=
name|hex
index|[
name|keystr
index|[
name|j
index|]
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
name|hexstr
index|[
literal|2
operator|*
name|MD5SIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"%2d SHA1 %s  # SHA1 key\n"
argument_list|,
name|i
operator|+
name|MD5KEYS
argument_list|,
name|hexstr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OPENSSL */
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTOKEY
end_ifdef

begin_comment
comment|/*  * readkey - load cryptographic parameters and keys  *  * This routine loads a PEM-encoded file of given name and password and  * extracts the filestamp from the file name. It returns a pointer to  * the first key if valid, NULL if not.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|readkey
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
comment|/* file name */
name|char
modifier|*
name|passwd
parameter_list|,
comment|/* password */
name|u_int
modifier|*
name|estamp
parameter_list|,
comment|/* file stamp */
name|EVP_PKEY
modifier|*
modifier|*
name|evpars
comment|/* parameter list pointer */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|NULL
decl_stmt|;
comment|/* public/private key */
name|u_int
name|gstamp
decl_stmt|;
comment|/* filestamp */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* filestamp buffer) */
name|EVP_PKEY
modifier|*
name|parkey
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Open the key file. 	 */
name|str
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Read the filestamp, which is contained in the first line. 	 */
if|if
condition|(
operator|(
name|ptr
operator|=
name|fgets
argument_list|(
name|linkname
argument_list|,
name|MAXFILENAME
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Empty key file %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|ptr
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No filestamp found in %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|gstamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid filestamp found in %s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Read and decrypt PEM-encoded private keys. The first one 	 * found is returned. If others are expected, add them to the 	 * parameter list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MVMAX
operator|-
literal|1
condition|;
control|)
block|{
name|parkey
operator|=
name|PEM_read_PrivateKey
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|evpars
operator|!=
name|NULL
condition|)
block|{
name|evpars
index|[
name|i
operator|++
index|]
operator|=
name|parkey
expr_stmt|;
name|evpars
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|parkey
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
name|pkey
operator|=
name|parkey
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|parkey
operator|->
name|type
operator|==
name|EVP_PKEY_DSA
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|parkey
operator|->
name|pkey
operator|.
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parkey
operator|->
name|type
operator|==
name|EVP_PKEY_RSA
condition|)
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|parkey
operator|->
name|pkey
operator|.
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Corrupt file %s or wrong key %s\n%s\n"
argument_list|,
name|cp
argument_list|,
name|passwd
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|estamp
operator|=
name|gstamp
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate RSA public/private key pair  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|gen_rsa
parameter_list|(
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* RSA parameters and key pair */
name|FILE
modifier|*
name|str
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating RSA keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|RSA_generate_key
argument_list|(
name|modulus
argument_list|,
literal|65537
argument_list|,
name|cb
argument_list|,
name|_UC
argument_list|(
literal|"RSA"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * For signature encryption it is not necessary that the RSA 	 * parameters be strictly groomed and once in a while the 	 * modulus turns out to be non-prime. Just for grins, we check 	 * the primality. 	 */
if|if
condition|(
operator|!
name|RSA_check_key
argument_list|(
name|rsa
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid RSA key\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the RSA parameters and keys as a RSA private key 	 * encoded in PEM. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|id
argument_list|,
literal|"sign"
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|=
name|fheader
argument_list|(
literal|"RSAsign"
argument_list|,
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
name|fheader
argument_list|(
literal|"RSAhost"
argument_list|,
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate DSA public/private key pair  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|gen_dsa
parameter_list|(
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* DSA parameters */
name|u_char
name|seed
index|[
literal|20
index|]
decl_stmt|;
comment|/* seed for parameters */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* 	 * Generate DSA parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating DSA parameters (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
name|modulus
argument_list|,
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cb
argument_list|,
name|_UC
argument_list|(
literal|"DSA"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate parameters fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Generate DSA keys. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating DSA keys (%d bits)...\n"
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DSA_generate_key
argument_list|(
name|dsa
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the DSA parameters and keys as a DSA private key 	 * encoded in PEM. 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"DSAsign"
argument_list|,
name|id
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Schnorr (IFF) identity scheme  *  *								       *  ***********************************************************************  *  * The Schnorr (IFF) identity scheme is intended for use when  * certificates are generated by some other trusted certificate  * authority and the certificate cannot be used to convey public  * parameters. There are two kinds of files: encrypted server files that  * contain private and public values and nonencrypted client files that  * contain only public values. New generations of server files must be  * securely transmitted to all servers of the group; client files can be  * distributed by any means. The scheme is self contained and  * independent of new generations of host keys, sign keys and  * certificates.  *  * The IFF values hide in a DSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on DSA  * cryptography and described in Stimson p. 285. The p is a 512-bit  * prime, g a generator of Zp* and q a 160-bit prime that divides p - 1  * and is a qth root of 1 mod p; that is, g^q = 1 mod p. The TA rolls a  * private random group key b (0< b< q) and public key v = g^b, then  * sends (p, q, g, b) to the servers and (p, q, g, v) to the clients.  * Alice challenges Bob to confirm identity using the protocol described  * below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the public primes  * p, q and generator g. The TA gives private key b to Bob and public  * key v to Alice.  *  * Alice rolls new random challenge r (o< r< q) and sends to Bob in  * the IFF request message. Bob rolls new random k (0< k< q), then  * computes y = k + b r mod q and x = g^k mod p and sends (y, hash(x))  * to Alice in the response message. Besides making the response  * shorter, the hash makes it effectivey impossible for an intruder to  * solve for b by observing a number of these messages.  *   * Alice receives the response and computes g^y v^r mod p. After a bit  * of algebra, this simplifies to g^k. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  */
end_comment

begin_comment
comment|/*  * Generate Schnorr (IFF) keys.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* DSA cuckoo nest */
name|gen_iffkey
parameter_list|(
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* DSA parameters */
name|u_char
name|seed
index|[
literal|20
index|]
decl_stmt|;
comment|/* seed for parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|w
decl_stmt|;
comment|/* BN temp */
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * Generate DSA parameters for use as IFF parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating IFF keys (%d bits)...\n"
argument_list|,
name|modulus2
argument_list|)
expr_stmt|;
name|RAND_bytes
argument_list|(
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
name|modulus2
argument_list|,
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cb
argument_list|,
name|_UC
argument_list|(
literal|"IFF"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DSA generate parameters fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
empty_stmt|;
block|}
comment|/* 	 * Generate the private and public keys. The DSA parameters and 	 * private key are distributed to the servers, while all except 	 * the private key are distributed to the clients. 	 */
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|w
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|b
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a */
name|BN_mod
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^(q - b) mod p */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^b mod p */
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|BN_is_one
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^(q - b) g^b = 1 mod p: %s\n"
argument_list|,
name|temp
operator|==
literal|1
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|BN_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dsa
operator|->
name|priv_key
operator|=
name|BN_dup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* private key */
name|dsa
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* public key */
comment|/* 	 * Here is a trial round of the protocol. First, Alice rolls 	 * random nonce r mod q and sends it to Bob. She needs only 	 * q from parameters. 	 */
name|BN_rand
argument_list|(
name|r
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob rolls random nonce k mod q, computes y = k + b r mod q 	 * and x = g^k mod p, then sends (y, x) to Alice. He needs 	 * p, q and b from parameters and r from Alice. 	 */
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* k, 0< k< q  */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|priv_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* b r mod q */
name|BN_add
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y = k + b r mod q */
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|k
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* x = g^k mod p */
comment|/* 	 * Alice verifies x = g^y v^r to confirm that Bob has group key 	 * b. She needs p, q, g from parameters, (y, x) from Bob and the 	 * original r. We omit the detail here thatt only the hash of y 	 * is sent. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g^y mod p */
name|BN_mod_exp
argument_list|(
name|w
argument_list|,
name|dsa
operator|->
name|pub_key
argument_list|,
name|r
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r */
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* product mod p */
name|temp
operator|=
name|BN_cmp
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^k = g^(k + b r) g^(q - b) r: %s\n"
argument_list|,
name|temp
operator|==
literal|0
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the IFF keys as an encrypted DSA private key encoded in 	 * PEM. 	 * 	 * p	modulus p 	 * q	modulus q 	 * g	generator g 	 * priv_key b 	 * public_key v 	 * kinv	not used 	 * r	not used 	 */
name|str
operator|=
name|fheader
argument_list|(
literal|"IFFkey"
argument_list|,
name|id
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Guillou-Quisquater (GQ)        *  * identity scheme                                                     *  *								       *  ***********************************************************************  *  * The Guillou-Quisquater (GQ) identity scheme is intended for use when  * the certificate can be used to convey public parameters. The scheme  * uses a X509v3 certificate extension field do convey the public key of  * a private key known only to servers. There are two kinds of files:  * encrypted server files that contain private and public values and  * nonencrypted client files that contain only public values. New  * generations of server files must be securely transmitted to all  * servers of the group; client files can be distributed by any means.  * The scheme is self contained and independent of new generations of  * host keys and sign keys. The scheme is self contained and independent  * of new generations of host keys and sign keys.  *  * The GQ parameters hide in a RSA cuckoo structure which uses the same  * parameters. The values are used by an identity scheme based on RSA  * cryptography and described in Stimson p. 300 (with errors). The 512-  * bit public modulus is n = p q, where p and q are secret large primes.  * The TA rolls private random group key b as RSA exponent. These values  * are known to all group members.  *  * When rolling new certificates, a server recomputes the private and  * public keys. The private key u is a random roll, while the public key  * is the inverse obscured by the group key v = (u^-1)^b. These values  * replace the private and public keys normally generated by the RSA  * scheme. Alice challenges Bob to confirm identity using the protocol  * described below.  *  * How it works  *  * The scheme goes like this. Both Alice and Bob have the same modulus n  * and some random b as the group key. These values are computed and  * distributed in advance via secret means, although only the group key  * b is truly secret. Each has a private random private key u and public  * key (u^-1)^b, although not necessarily the same ones. Bob and Alice  * can regenerate the key pair from time to time without affecting  * operations. The public key is conveyed on the certificate in an  * extension field; the private key is never revealed.  *  * Alice rolls new random challenge r and sends to Bob in the GQ  * request message. Bob rolls new random k, then computes y = k u^r mod  * n and x = k^b mod n and sends (y, hash(x)) to Alice in the response  * message. Besides making the response shorter, the hash makes it  * effectivey impossible for an intruder to solve for b by observing  * a number of these messages.  *   * Alice receives the response and computes y^b v^r mod n. After a bit  * of algebra, this simplifies to k^b. If the hash of this result  * matches hash(x), Alice knows that Bob has the group key b. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  */
end_comment

begin_comment
comment|/*  * Generate Guillou-Quisquater (GQ) parameters file.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* RSA cuckoo nest */
name|gen_gqkey
parameter_list|(
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
comment|/* private key */
name|RSA
modifier|*
name|rsa
decl_stmt|;
comment|/* RSA parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|g
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|y
decl_stmt|;
comment|/* BN temps */
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * Generate RSA parameters for use as GQ parameters. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating GQ parameters (%d bits)...\n"
argument_list|,
name|modulus2
argument_list|)
expr_stmt|;
name|rsa
operator|=
name|RSA_generate_key
argument_list|(
name|modulus2
argument_list|,
literal|65537
argument_list|,
name|cb
argument_list|,
name|_UC
argument_list|(
literal|"GQ"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RSA generate keys fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|k
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
comment|/* 	 * Generate the group key b, which is saved in the e member of 	 * the RSA structure. The group key is transmitted to each group 	 * member encrypted by the member private key. 	 */
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|BN_rand
argument_list|(
name|rsa
operator|->
name|e
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* b */
name|BN_mod
argument_list|(
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * When generating his certificate, Bob rolls random private key 	 * u, then computes inverse v = u^-1.  	 */
name|BN_rand
argument_list|(
name|u
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* u */
name|BN_mod
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_inverse
argument_list|(
name|v
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^-1 mod n */
name|BN_mod_mul
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob computes public key v = (u^-1)^b, which is saved in an 	 * extension field on his certificate. We check that u^b v = 	 * 1 mod n. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|u
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^b */
name|BN_mod_mul
argument_list|(
name|g
argument_list|,
name|g
argument_list|,
name|v
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^b (u^-1)^b */
name|temp
operator|=
name|BN_is_one
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm u^b (u^-1)^b = 1 mod n: %s\n"
argument_list|,
name|temp
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BN_copy
argument_list|(
name|rsa
operator|->
name|p
argument_list|,
name|u
argument_list|)
expr_stmt|;
comment|/* private key */
name|BN_copy
argument_list|(
name|rsa
operator|->
name|q
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* public key */
comment|/* 	 * Here is a trial run of the protocol. First, Alice rolls 	 * random nonce r mod n and sends it to Bob. She needs only n 	 * from parameters. 	 */
name|BN_rand
argument_list|(
name|r
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* r */
name|BN_mod
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Bob rolls random nonce k mod n, computes y = k u^r mod n and 	 * g = k^b mod n, then sends (y, g) to Alice. He needs n, u, b 	 * from parameters and r from Alice.  	 */
name|BN_rand
argument_list|(
name|k
argument_list|,
name|BN_num_bits
argument_list|(
name|rsa
operator|->
name|n
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* k */
name|BN_mod
argument_list|(
name|k
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|rsa
operator|->
name|p
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* u^r mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|k
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y = k u^r mod n */
name|BN_mod_exp
argument_list|(
name|g
argument_list|,
name|k
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* g = k^b mod n */
comment|/* 	 * Alice verifies g = v^r y^b mod n to confirm that Bob has 	 * private key u. She needs n, g from parameters, public key v = 	 * (u^-1)^b from the certificate, (y, g) from Bob and the 	 * original r. We omit the detaul here that only the hash of g 	 * is sent. 	 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|rsa
operator|->
name|q
argument_list|,
name|r
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r mod n */
name|BN_mod_exp
argument_list|(
name|y
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|e
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* y^b mod n */
name|BN_mod_mul
argument_list|(
name|y
argument_list|,
name|v
argument_list|,
name|y
argument_list|,
name|rsa
operator|->
name|n
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* v^r y^b mod n */
name|temp
operator|=
name|BN_cmp
argument_list|(
name|y
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm g^k = v^r y^b mod n: %s\n"
argument_list|,
name|temp
operator|==
literal|0
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Write the GQ parameter file as an encrypted RSA private key 	 * encoded in PEM. 	 * 	 * n	modulus n 	 * e	group key b 	 * d	not used 	 * p	private key u 	 * q	public key (u^-1)^b 	 * dmp1	not used 	 * dmq1	not used 	 * iqmp	not used 	 */
name|BN_copy
argument_list|(
name|rsa
operator|->
name|d
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|dmp1
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|dmq1
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|rsa
operator|->
name|iqmp
argument_list|,
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
literal|"GQkey"
argument_list|,
name|id
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|pkey
argument_list|,
name|rsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|RSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|rsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  ***********************************************************************  *								       *  * The following routines implement the Mu-Varadharajan (MV) identity  *  * scheme                                                              *  *								       *  ***********************************************************************  *  * The Mu-Varadharajan (MV) cryptosystem was originally intended when  * servers broadcast messages to clients, but clients never send  * messages to servers. There is one encryption key for the server and a  * separate decryption key for each client. It operated something like a  * pay-per-view satellite broadcasting system where the session key is  * encrypted by the broadcaster and the decryption keys are held in a  * tamperproof set-top box.  *  * The MV parameters and private encryption key hide in a DSA cuckoo  * structure which uses the same parameters, but generated in a  * different way. The values are used in an encryption scheme similar to  * El Gamal cryptography and a polynomial formed from the expansion of  * product terms (x - x[j]), as described in Mu, Y., and V.  * Varadharajan: Robust and Secure Broadcasting, Proc. Indocrypt 2001,  * 223-231. The paper has significant errors and serious omissions.  *  * Let q be the product of n distinct primes s1[j] (j = 1...n), where  * each s1[j] has m significant bits. Let p be a prime p = 2 * q + 1, so  * that q and each s1[j] divide p - 1 and p has M = n * m + 1  * significant bits. Let g be a generator of Zp; that is, gcd(g, p - 1)  * = 1 and g^q = 1 mod p. We do modular arithmetic over Zq and then  * project into Zp* as exponents of g. Sometimes we have to compute an  * inverse b^-1 of random b in Zq, but for that purpose we require  * gcd(b, q) = 1. We expect M to be in the 500-bit range and n  * relatively small, like 30. These are the parameters of the scheme and  * they are expensive to compute.  *  * We set up an instance of the scheme as follows. A set of random  * values x[j] mod q (j = 1...n), are generated as the zeros of a  * polynomial of order n. The product terms (x - x[j]) are expanded to  * form coefficients a[i] mod q (i = 0...n) in powers of x. These are  * used as exponents of the generator g mod p to generate the private  * encryption key A. The pair (gbar, ghat) of public server keys and the  * pairs (xbar[j], xhat[j]) (j = 1...n) of private client keys are used  * to construct the decryption keys. The devil is in the details.  *  * This routine generates a private server encryption file including the  * private encryption key E and partial decryption keys gbar and ghat.  * It then generates public client decryption files including the public  * keys xbar[j] and xhat[j] for each client j. The partial decryption  * files are used to compute the inverse of E. These values are suitably  * blinded so secrets are not revealed.  *  * The distinguishing characteristic of this scheme is the capability to  * revoke keys. Included in the calculation of E, gbar and ghat is the  * product s = prod(s1[j]) (j = 1...n) above. If the factor s1[j] is  * subsequently removed from the product and E, gbar and ghat  * recomputed, the jth client will no longer be able to compute E^-1 and  * thus unable to decrypt the messageblock.  *  * How it works  *  * The scheme goes like this. Bob has the server values (p, E, q,  * gbar, ghat) and Alice has the client values (p, xbar, xhat).  *  * Alice rolls new random nonce r mod p and sends to Bob in the MV  * request message. Bob rolls random nonce k mod q, encrypts y = r E^k  * mod p and sends (y, gbar^k, ghat^k) to Alice.  *   * Alice receives the response and computes the inverse (E^k)^-1 from  * the partial decryption keys gbar^k, ghat^k, xbar and xhat. She then  * decrypts y and verifies it matches the original r. The signed  * response binds this knowledge to Bob's private key and the public key  * previously received in his certificate.  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* DSA cuckoo nest */
name|gen_mvkey
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
comment|/* file name id */
name|EVP_PKEY
modifier|*
modifier|*
name|evpars
comment|/* parameter list pointer */
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|,
modifier|*
name|pkey1
decl_stmt|;
comment|/* private keys */
name|DSA
modifier|*
name|dsa
decl_stmt|,
modifier|*
name|dsa2
decl_stmt|,
modifier|*
name|sdsa
decl_stmt|;
comment|/* DSA parameters */
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* BN working space */
name|BIGNUM
modifier|*
name|a
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* polynomial coefficient vector */
name|BIGNUM
modifier|*
name|g
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* public key vector */
name|BIGNUM
modifier|*
name|s1
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* private enabling keys */
name|BIGNUM
modifier|*
name|x
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* polynomial zeros vector */
name|BIGNUM
modifier|*
name|xbar
index|[
name|MVMAX
index|]
decl_stmt|,
modifier|*
name|xhat
index|[
name|MVMAX
index|]
decl_stmt|;
comment|/* private keys vector */
name|BIGNUM
modifier|*
name|b
decl_stmt|;
comment|/* group key */
name|BIGNUM
modifier|*
name|b1
decl_stmt|;
comment|/* inverse group key */
name|BIGNUM
modifier|*
name|s
decl_stmt|;
comment|/* enabling key */
name|BIGNUM
modifier|*
name|biga
decl_stmt|;
comment|/* master encryption key */
name|BIGNUM
modifier|*
name|bige
decl_stmt|;
comment|/* session encryption key */
name|BIGNUM
modifier|*
name|gbar
decl_stmt|,
modifier|*
name|ghat
decl_stmt|;
comment|/* public key */
name|BIGNUM
modifier|*
name|u
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|w
decl_stmt|;
comment|/* BN scratch */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|FILE
modifier|*
name|str
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
comment|/* 	 * Generate MV parameters. 	 * 	 * The object is to generate a multiplicative group Zp* modulo a 	 * prime p and a subset Zq mod q, where q is the product of n 	 * distinct primes s1[j] (j = 1...n) and q divides p - 1. We 	 * first generate n m-bit primes, where the product n m is in 	 * the order of 512 bits. One or more of these may have to be 	 * replaced later. As a practical matter, it is tough to find 	 * more than 31 distinct primes for 512 bits or 61 primes for 	 * 1024 bits. The latter can take several hundred iterations 	 * and several minutes on a Sun Blade 1000. 	 */
name|n
operator|=
name|nkeys
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating MV parameters for %d keys (%d bits)...\n"
argument_list|,
name|n
argument_list|,
name|modulus2
operator|/
name|n
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|u
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|v
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|w
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|b
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|b1
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|=
name|DSA_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|priv_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dsa
operator|->
name|pub_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|s1
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_generate_prime
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|,
name|modulus2
operator|/
name|n
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_cmp
argument_list|(
name|s1
index|[
name|i
index|]
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|j
condition|)
break|break;
name|temp
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Birthday keys regenerated %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the modulus q as the product of the primes. Compute 	 * the modulus p as 2 * q + 1 and test p for primality. If p 	 * is composite, replace one of the primes with a new distinct 	 * one and try again. Note that q will hardly be a secret since 	 * we have to reveal p to servers, but not clients. However, 	 * factoring q to find the primes should be adequately hard, as 	 * this is the same problem considered hard in RSA. Question: is 	 * it as hard to find n small prime factors totalling n bits as 	 * it is to find two large prime factors totalling n bits? 	 * Remember, the bad guy doesn't know n. 	 */
name|temp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_one
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
name|BN_mul
argument_list|(
name|dsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_add_word
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_prime
argument_list|(
name|dsa
operator|->
name|p
argument_list|,
name|BN_prime_checks
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
name|temp
operator|++
expr_stmt|;
name|j
operator|=
name|temp
operator|%
name|n
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_generate_prime
argument_list|(
name|u
argument_list|,
name|modulus2
operator|/
name|n
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BN_cmp
argument_list|(
name|u
argument_list|,
name|s1
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|n
condition|)
break|break;
block|}
name|BN_copy
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Defective keys regenerated %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the generator g using a random roll such that 	 * gcd(g, p - 1) = 1 and g^q = 1. This is a generator of p, not 	 * q. This may take several iterations. 	 */
name|BN_copy
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|BN_sub_word
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|dsa
operator|->
name|g
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
continue|continue;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * Setup is now complete. Roll random polynomial roots x[j] 	 * (j = 1...n) for all j. While it may not be strictly 	 * necessary, Make sure each root has no factors in common with 	 * q. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating polynomial coefficients for %d roots (%d bits)\n"
argument_list|,
name|n
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|x
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|x
index|[
name|j
index|]
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|x
index|[
name|j
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 	 * Generate polynomial coefficients a[i] (i = 0...n) from the 	 * expansion of root products (x - x[j]) mod q for all j. The 	 * method is a present from Charlie Boncelet. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_zero
argument_list|(
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|BN_copy
argument_list|(
name|u
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_sub
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|w
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|a
index|[
name|i
index|]
argument_list|,
name|u
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate g[i] = g^a[i] mod p for all i and the generator g. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|g
index|[
name|i
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|g
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify prod(g[i]^(a[i] x[j]^i)) = 1 for all i, j. Note the 	 * a[i] x[j]^i exponent is computed mod q, but the g[i] is 	 * computed mod p. also note the expression given in the paper 	 * is incorrect. 	 */
name|temp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_one
argument_list|(
name|u
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Confirm prod(g[i]^(x[j]^i)) = 1 for all i, j: %s\n"
argument_list|,
name|temp
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Make private encryption key A. Keep it around for awhile, 	 * since it is expensive to compute. 	 */
name|biga
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_one
argument_list|(
name|biga
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|g
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|biga
argument_list|,
name|biga
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Roll private random group key b mod q (0< b< q), where 	 * gcd(b, q) = 1 to guarantee b^-1 exists, then compute b^-1 	 * mod q. If b is changed, the client keys must be recomputed. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|BN_rand
argument_list|(
name|b
argument_list|,
name|BN_num_bits
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_mod
argument_list|(
name|b
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_gcd
argument_list|(
name|u
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
break|break;
block|}
name|BN_mod_inverse
argument_list|(
name|b1
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Make private client keys (xbar[j], xhat[j]) for all j. Note 	 * that the keys for the jth client do not s1[j] or the product 	 * s1[j]) (j = 1...n) which is q by construction. 	 * 	 * Compute the factor w such that w s1[j] = s1[j] for all j. The 	 * easy way to do this is to compute (q + s1[j]) / s1[j]. 	 * Exercise for the student: prove the remainder is always zero. 	 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|xbar
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|xhat
index|[
name|j
index|]
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_add
argument_list|(
name|w
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
name|w
argument_list|,
name|u
argument_list|,
name|w
argument_list|,
name|s1
index|[
name|j
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_zero
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_set_word
argument_list|(
name|v
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
condition|)
continue|continue;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|x
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_add
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|,
name|xbar
index|[
name|j
index|]
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|BN_mod_mul
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|,
name|xbar
index|[
name|j
index|]
argument_list|,
name|b1
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|,
name|x
index|[
name|j
index|]
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|,
name|xhat
index|[
name|j
index|]
argument_list|,
name|w
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We revoke client j by dividing q by s1[j]. The quotient 	 * becomes the enabling key s. Note we always have to revoke 	 * one key; otherwise, the plaintext and cryptotext would be 	 * identical. For the present there are no provisions to revoke 	 * additional keys, so we sail on with only token revocations. 	 */
name|s
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_copy
argument_list|(
name|s
argument_list|,
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|BN_div
argument_list|(
name|s
argument_list|,
name|u
argument_list|,
name|s
argument_list|,
name|s1
index|[
name|n
index|]
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * For each combination of clients to be revoked, make private 	 * encryption key E = A^s and partial decryption keys gbar = g^s 	 * and ghat = g^(s b), all mod p. The servers use these keys to 	 * compute the session encryption key and partial decryption 	 * keys. These values must be regenerated if the enabling key is 	 * changed. 	 */
name|bige
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|gbar
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ghat
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|bige
argument_list|,
name|biga
argument_list|,
name|s
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|gbar
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|s
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|v
argument_list|,
name|s
argument_list|,
name|b
argument_list|,
name|dsa
operator|->
name|q
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|ghat
argument_list|,
name|dsa
operator|->
name|g
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Notes: We produce the key media in three steps. The first 	 * step is to generate the system parameters p, q, g, b, A and 	 * the enabling keys s1[j]. Associated with each s1[j] are 	 * parameters xbar[j] and xhat[j]. All of these parameters are 	 * retained in a data structure protecteted by the trusted-agent 	 * password. The p, xbar[j] and xhat[j] paremeters are 	 * distributed to the j clients. When the client keys are to be 	 * activated, the enabled keys are multipied together to form 	 * the master enabling key s. This and the other parameters are 	 * used to compute the server encryption key E and the partial 	 * decryption keys gbar and ghat. 	 * 	 * In the identity exchange the client rolls random r and sends 	 * it to the server. The server rolls random k, which is used 	 * only once, then computes the session key E^k and partial 	 * decryption keys gbar^k and ghat^k. The server sends the 	 * encrypted r along with gbar^k and ghat^k to the client. The 	 * client completes the decryption and verifies it matches r. 	 */
comment|/* 	 * Write the MV trusted-agent parameters and keys as a DSA 	 * private key encoded in PEM. 	 * 	 * p	modulus p 	 * q	modulus q 	 * g	generator g 	 * priv_key A mod p 	 * pub_key b mod q 	 * (remaining values are not used) 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
literal|"MVta"
argument_list|,
literal|"mvta"
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating MV trusted-authority keys\n"
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|priv_key
argument_list|,
name|biga
argument_list|)
expr_stmt|;
name|BN_copy
argument_list|(
name|dsa
operator|->
name|pub_key
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|pkey
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|evpars
index|[
name|i
operator|++
index|]
operator|=
name|pkey
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Append the MV server parameters and keys as a DSA key encoded 	 * in PEM. 	 * 	 * p	modulus p 	 * q	modulus q (used only when generating k) 	 * g	bige 	 * priv_key gbar 	 * pub_key ghat 	 * (remaining values are not used) 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating MV server keys\n"
argument_list|)
expr_stmt|;
name|dsa2
operator|=
name|DSA_new
argument_list|()
expr_stmt|;
name|dsa2
operator|->
name|p
operator|=
name|BN_dup
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|dsa2
operator|->
name|q
operator|=
name|BN_dup
argument_list|(
name|dsa
operator|->
name|q
argument_list|)
expr_stmt|;
name|dsa2
operator|->
name|g
operator|=
name|BN_dup
argument_list|(
name|bige
argument_list|)
expr_stmt|;
name|dsa2
operator|->
name|priv_key
operator|=
name|BN_dup
argument_list|(
name|gbar
argument_list|)
expr_stmt|;
name|dsa2
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|ghat
argument_list|)
expr_stmt|;
name|pkey1
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|pkey1
argument_list|,
name|dsa2
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey1
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|evpars
index|[
name|i
operator|++
index|]
operator|=
name|pkey1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|dsa2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Append the MV client parameters for each client j as DSA keys 	 * encoded in PEM. 	 * 	 * p	modulus p 	 * priv_key xbar[j] mod q 	 * pub_key xhat[j] mod q 	 * (remaining values are not used) 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating %d MV client keys\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|sdsa
operator|=
name|DSA_new
argument_list|()
expr_stmt|;
name|sdsa
operator|->
name|p
operator|=
name|BN_dup
argument_list|(
name|dsa
operator|->
name|p
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|q
operator|=
name|BN_dup
argument_list|(
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|g
operator|=
name|BN_dup
argument_list|(
name|BN_value_one
argument_list|()
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|priv_key
operator|=
name|BN_dup
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sdsa
operator|->
name|pub_key
operator|=
name|BN_dup
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|pkey1
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
name|EVP_PKEY_set1_DSA
argument_list|(
name|pkey1
argument_list|,
name|sdsa
argument_list|)
expr_stmt|;
name|PEM_write_PKCS8PrivateKey
argument_list|(
name|str
argument_list|,
name|pkey1
argument_list|,
name|cipher
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|passwd1
argument_list|)
expr_stmt|;
name|evpars
index|[
name|i
operator|++
index|]
operator|=
name|pkey1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|DSA_print_fp
argument_list|(
name|stderr
argument_list|,
name|sdsa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * The product gbar^k)^xbar[j] (ghat^k)^xhat[j] and E 		 * are inverses of each other. We check that the product 		 * is one for each client except the ones that have been 		 * revoked.  		 */
name|BN_mod_exp
argument_list|(
name|v
argument_list|,
name|dsa2
operator|->
name|priv_key
argument_list|,
name|sdsa
operator|->
name|pub_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_exp
argument_list|(
name|u
argument_list|,
name|dsa2
operator|->
name|pub_key
argument_list|,
name|sdsa
operator|->
name|priv_key
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|BN_mod_mul
argument_list|(
name|u
argument_list|,
name|u
argument_list|,
name|bige
argument_list|,
name|dsa
operator|->
name|p
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BN_is_one
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Revoke key %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|evpars
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* 	 * Free the countries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|BN_free
argument_list|(
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|g
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|BN_free
argument_list|(
name|x
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|xbar
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|xhat
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|s1
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pkey
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate X509v3 certificate.  *  * The certificate consists of the version number, serial number,  * validity interval, issuer name, subject name and public key. For a  * self-signed certificate, the issuer name is the same as the subject  * name and these items are signed using the subject private key. The  * validity interval extends from the current time to the same time one  * year hence. For NTP purposes, it is convenient to use the NTP seconds  * of the current time as the serial number.  */
end_comment

begin_function
name|int
name|x509
parameter_list|(
name|EVP_PKEY
modifier|*
name|pkey
parameter_list|,
comment|/* signing key */
specifier|const
name|EVP_MD
modifier|*
name|md
parameter_list|,
comment|/* signature/digest scheme */
name|char
modifier|*
name|gqpub
parameter_list|,
comment|/* identity extension (hex string) */
specifier|const
name|char
modifier|*
name|exten
parameter_list|,
comment|/* private cert extension */
name|char
modifier|*
name|name
comment|/* subject/issuer name */
parameter_list|)
block|{
name|X509
modifier|*
name|cert
decl_stmt|;
comment|/* X509 certificate */
name|X509_NAME
modifier|*
name|subj
decl_stmt|;
comment|/* distinguished (common) name */
name|X509_EXTENSION
modifier|*
name|ex
decl_stmt|;
comment|/* X509v3 extension */
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|ASN1_INTEGER
modifier|*
name|serial
decl_stmt|;
comment|/* serial number */
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
comment|/* digest/signature scheme name */
name|char
name|pathbuf
index|[
name|MAXFILENAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * Generate X509 self-signed certificate. 	 * 	 * Set the certificate serial to the NTP seconds for grins. Set 	 * the version to 3. Set the initial validity to the current 	 * time and the finalvalidity one year hence. 	 */
name|id
operator|=
name|OBJ_nid2sn
argument_list|(
name|md
operator|->
name|pkey_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating new certificate %s %s\n"
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|cert
operator|=
name|X509_new
argument_list|()
expr_stmt|;
name|X509_set_version
argument_list|(
name|cert
argument_list|,
literal|2L
argument_list|)
expr_stmt|;
name|serial
operator|=
name|ASN1_INTEGER_new
argument_list|()
expr_stmt|;
name|ASN1_INTEGER_set
argument_list|(
name|serial
argument_list|,
operator|(
name|long
operator|)
name|epoch
operator|+
name|JAN_1970
argument_list|)
expr_stmt|;
name|X509_set_serialNumber
argument_list|(
name|cert
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|ASN1_INTEGER_free
argument_list|(
name|serial
argument_list|)
expr_stmt|;
name|X509_time_adj
argument_list|(
name|X509_get_notBefore
argument_list|(
name|cert
argument_list|)
argument_list|,
literal|0L
argument_list|,
operator|&
name|epoch
argument_list|)
expr_stmt|;
name|X509_time_adj
argument_list|(
name|X509_get_notAfter
argument_list|(
name|cert
argument_list|)
argument_list|,
name|lifetime
operator|*
name|SECSPERDAY
argument_list|,
operator|&
name|epoch
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|subj
operator|=
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|X509_NAME_add_entry_by_txt
argument_list|(
name|subj
argument_list|,
literal|"commonName"
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_set_pubkey
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Assign certificate signing key fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Add X509v3 extensions if present. These represent the minimum 	 * set defined in RFC3280 less the certificate_policy extension, 	 * which is seriously obfuscated in OpenSSL. 	 */
comment|/* 	 * The basic_constraints extension CA:TRUE allows servers to 	 * sign client certficitates. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_basic_constraints
argument_list|,
name|BASIC_CONSTRAINTS
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_basic_constraints
argument_list|,
name|_UC
argument_list|(
name|BASIC_CONSTRAINTS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* 	 * The key_usage extension designates the purposes the key can 	 * be used for. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_key_usage
argument_list|,
name|KEY_USAGE
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_key_usage
argument_list|,
name|_UC
argument_list|(
name|KEY_USAGE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|/* 	 * The subject_key_identifier is used for the GQ public key. 	 * This should not be controversial. 	 */
if|if
condition|(
name|gqpub
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|LN_subject_key_identifier
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_subject_key_identifier
argument_list|,
name|gqpub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The extended key usage extension is used for special purpose 	 * here. The semantics probably do not conform to the designer's 	 * intent and will likely change in future. 	 *  	 * "trustRoot" designates a root authority 	 * "private" designates a private certificate 	 */
if|if
condition|(
name|exten
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|LN_ext_key_usage
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|ex
operator|=
name|X509V3_EXT_conf_nid
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NID_ext_key_usage
argument_list|,
name|_UC
argument_list|(
name|exten
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_add_ext
argument_list|(
name|cert
argument_list|,
name|ex
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Add extension field fails\n%s\n"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|X509_EXTENSION_free
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sign and verify. 	 */
name|X509_sign
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|X509_verify
argument_list|(
name|cert
argument_list|,
name|pkey
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Verify %s certificate fails\n%s\n"
argument_list|,
name|id
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Write the certificate encoded in PEM. 	 */
name|snprintf
argument_list|(
name|pathbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|,
literal|"%scert"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|str
operator|=
name|fheader
argument_list|(
name|pathbuf
argument_list|,
literal|"cert"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|PEM_write_X509
argument_list|(
name|str
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|X509_print_fp
argument_list|(
name|stderr
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* asn2ntp is used only with commercial certificates */
end_comment

begin_comment
comment|/*  * asn2ntp - convert ASN1_TIME time structure to NTP time  */
end_comment

begin_comment
unit|u_long asn2ntp	( 	ASN1_TIME *asn1time
comment|/* pointer to ASN1_TIME structure */
end_comment

begin_comment
unit|) { 	char	*v;
comment|/* pointer to ASN1_TIME string */
end_comment

begin_comment
unit|struct	tm tm;
comment|/* time decode structure time */
end_comment

begin_comment
comment|/* 	 * Extract time string YYMMDDHHMMSSZ from ASN.1 time structure. 	 * Note that the YY, MM, DD fields start with one, the HH, MM, 	 * SS fiels start with zero and the Z character should be 'Z' 	 * for UTC. Also note that years less than 50 map to years 	 * greater than 100. Dontcha love ASN.1? 	 */
end_comment

begin_endif
unit|if (asn1time->length> 13) 		return (-1); 	v = (char *)asn1time->data; 	tm.tm_year = (v[0] - '0') * 10 + v[1] - '0'; 	if (tm.tm_year< 50) 		tm.tm_year += 100; 	tm.tm_mon = (v[2] - '0') * 10 + v[3] - '0' - 1; 	tm.tm_mday = (v[4] - '0') * 10 + v[5] - '0'; 	tm.tm_hour = (v[6] - '0') * 10 + v[7] - '0'; 	tm.tm_min = (v[8] - '0') * 10 + v[9] - '0'; 	tm.tm_sec = (v[10] - '0') * 10 + v[11] - '0'; 	tm.tm_wday = 0; 	tm.tm_yday = 0; 	tm.tm_isdst = 0; 	return (mktime(&tm) + JAN_1970); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Callback routine  */
end_comment

begin_function
name|void
name|cb
parameter_list|(
name|int
name|n1
parameter_list|,
comment|/* arg 1 */
name|int
name|n2
parameter_list|,
comment|/* arg 2 */
name|void
modifier|*
name|chr
comment|/* arg 3 */
parameter_list|)
block|{
switch|switch
condition|(
name|n1
condition|)
block|{
case|case
literal|0
case|:
name|d0
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|d1
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d2
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|d3
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\t\t\t\t\t\t%d %d %lu\r"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chr
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|d3
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate key  */
end_comment

begin_function
name|EVP_PKEY
modifier|*
comment|/* public/private key pair */
name|genkey
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
comment|/* key type (RSA or DSA) */
specifier|const
name|char
modifier|*
name|id
comment|/* file name id */
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"RSA"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gen_rsa
argument_list|(
name|id
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"DSA"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gen_dsa
argument_list|(
name|id
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid %s key type %s\n"
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTOKEY */
end_comment

begin_comment
comment|/*  * Generate file header and link  */
end_comment

begin_function
name|FILE
modifier|*
name|fheader
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
comment|/* file name id */
specifier|const
name|char
modifier|*
name|ulink
parameter_list|,
comment|/* linkname */
specifier|const
name|char
modifier|*
name|owner
comment|/* owner name */
parameter_list|)
block|{
name|FILE
modifier|*
name|str
decl_stmt|;
comment|/* file handle */
name|char
name|linkname
index|[
name|MAXFILENAME
index|]
decl_stmt|;
comment|/* link name */
name|int
name|temp
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ntpkey_%s_%s.%u"
argument_list|,
name|file
argument_list|,
name|owner
argument_list|,
name|fstamp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Write"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|linkname
argument_list|,
sizeof|sizeof
argument_list|(
name|linkname
argument_list|)
argument_list|,
literal|"ntpkey_%s_%s"
argument_list|,
name|ulink
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove
argument_list|(
name|linkname
argument_list|)
expr_stmt|;
comment|/* The symlink() line below matters */
name|temp
operator|=
name|symlink
argument_list|(
name|filename
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Generating new %s file and link\n"
argument_list|,
name|ulink
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s->%s\n"
argument_list|,
name|linkname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|str
argument_list|,
literal|"# %s\n# %s\n"
argument_list|,
name|filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|epoch
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

end_unit

