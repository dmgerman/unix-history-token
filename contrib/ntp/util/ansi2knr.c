begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1989, 1997, 1998, 1999 Aladdin Enterprises.  All rights reserved. */
end_comment

begin_comment
comment|/*$Id$*/
end_comment

begin_comment
comment|/* Convert ANSI C function definitions to K&R ("traditional C") syntax */
end_comment

begin_comment
comment|/* ansi2knr is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU General Public License (the "GPL") for full details.  Everyone is granted permission to copy, modify and redistribute ansi2knr, but only under the conditions described in the GPL.  A copy of this license is supposed to have been given to you along with ansi2knr so you can know your rights and responsibilities.  It should be in a file named COPYLEFT, or, if there is no file named COPYLEFT, a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  We explicitly state here what we believe is already implied by the GPL: if the ansi2knr program is distributed as a separate set of sources and a separate executable file which are aggregated on a storage medium together with another program, this in itself does not bring the other program under the GPL, nor does the mere fact that such a program or the procedures for constructing it invoke the ansi2knr executable bring any other part of the program under the GPL. */
end_comment

begin_comment
comment|/*  * Usage: 	ansi2knr [--filename FILENAME] [INPUT_FILE [OUTPUT_FILE]]  * --filename provides the file name for the #line directive in the output,  * overriding input_file (if present).  * If no input_file is supplied, input is read from stdin.  * If no output_file is supplied, output goes to stdout.  * There are no error messages.  *  * ansi2knr recognizes function definitions by seeing a non-keyword  * identifier at the left margin, followed by a left parenthesis, with a  * right parenthesis as the last character on the line, and with a left  * brace as the first token on the following line (ignoring possible  * intervening comments and/or preprocessor directives), except that a line  * consisting of only  *	identifier1(identifier2)  * will not be considered a function definition unless identifier2 is  * the word "void", and a line consisting of  *	identifier1(identifier2,<<arbitrary>>)  * will not be considered a function definition.  * ansi2knr will recognize a multi-line header provided that no intervening  * line ends with a left or right brace or a semicolon.  These algorithms  * ignore whitespace, comments, and preprocessor directives, except that  * the function name must be the first thing on the line.  The following  * constructs will confuse it:  *	- Any other construct that starts at the left margin and  *	    follows the above syntax (such as a macro or function call).  *	- Some macros that tinker with the syntax of function headers.  */
end_comment

begin_comment
comment|/*  * The original and principal author of ansi2knr is L. Peter Deutsch  *<ghost@aladdin.com>.  Other authors are noted in the change history  * that follows (in reverse chronological order): 	lpd 1999-08-17 added code to allow preprocessor directives 		wherever comments are allowed 	lpd 1999-04-12 added minor fixes from Pavel Roskin<pavel_roskin@geocities.com> for clean compilation with 		gcc -W -Wall 	lpd 1999-03-22 added hack to recognize lines consisting of 		identifier1(identifier2, xxx) as *not* being procedures 	lpd 1999-02-03 made indentation of preprocessor commands consistent 	lpd 1999-01-28 fixed two bugs: a '/' in an argument list caused an 		endless loop; quoted strings within an argument list 		confused the parser 	lpd 1999-01-24 added a check for write errors on the output, 		suggested by Jim Meyering<meyering@ascend.com> 	lpd 1998-11-09 added further hack to recognize identifier(void) 		as being a procedure 	lpd 1998-10-23 added hack to recognize lines consisting of 		identifier1(identifier2) as *not* being procedures 	lpd 1997-12-08 made input_file optional; only closes input and/or 		output file if not stdin or stdout respectively; prints 		usage message on stderr rather than stdout; adds 		--filename switch (changes suggested by<ceder@lysator.liu.se>) 	lpd 1996-01-21 added code to cope with not HAVE_CONFIG_H and with 		compilers that don't understand void, as suggested by 		Tom Lane 	lpd 1996-01-15 changed to require that the first non-comment token 		on the line following a function header be a left brace, 		to reduce sensitivity to macros, as suggested by Tom Lane<tgl@sss.pgh.pa.us> 	lpd 1995-06-22 removed #ifndefs whose sole purpose was to define 		undefined preprocessor symbols as 0; changed all #ifdefs 		for configuration symbols to #ifs 	lpd 1995-04-05 changed copyright notice to make it clear that 		including ansi2knr in a program does not bring the entire 		program under the GPL 	lpd 1994-12-18 added conditionals for systems where ctype macros 		don't handle 8-bit characters properly, suggested by 		Francois Pinard<pinard@iro.umontreal.ca>; 		removed --varargs switch (this is now the default) 	lpd 1994-10-10 removed CONFIG_BROKETS conditional 	lpd 1994-07-16 added some conditionals to help GNU `configure', 		suggested by Francois Pinard<pinard@iro.umontreal.ca>; 		properly erase prototype args in function parameters, 		contributed by Jim Avera<jima@netcom.com>; 		correct error in writeblanks (it shouldn't erase EOLs) 	lpd 1989-xx-xx original version  */
end_comment

begin_comment
comment|/* Most of the conditionals here are to make ansi2knr work with */
end_comment

begin_comment
comment|/* or without the GNU configure machinery. */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_comment
comment|/*    For properly autoconfiguring ansi2knr, use AC_CONFIG_HEADER(config.h).    This will define HAVE_CONFIG_H and so, activate the following lines.  */
end_comment

begin_if
if|#
directive|if
name|STDC_HEADERS
operator|||
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_CONFIG_H */
end_comment

begin_comment
comment|/* Otherwise do it the hard way */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|strlen
argument_list|()
decl_stmt|,
name|strncmp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_CONFIG_H */
end_comment

begin_if
if|#
directive|if
name|STDC_HEADERS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*    malloc and free should be declared in stdlib.h,    but if you've got a K&R compiler, they probably aren't.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define NULL (for *very* old compilers). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The ctype macros don't always handle 8-bit characters correctly.  * Compensate for this here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|isascii
end_ifdef

begin_undef
undef|#
directive|undef
name|HAVE_ISASCII
end_undef

begin_comment
comment|/* just in case */
end_comment

begin_define
define|#
directive|define
name|HAVE_ISASCII
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STDC_HEADERS
operator|||
operator|!
name|HAVE_ISASCII
end_if

begin_define
define|#
directive|define
name|is_ascii
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|is_ascii
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|is_space
parameter_list|(
name|c
parameter_list|)
value|(is_ascii(c)&& isspace(c))
end_define

begin_define
define|#
directive|define
name|is_alpha
parameter_list|(
name|c
parameter_list|)
value|(is_ascii(c)&& isalpha(c))
end_define

begin_define
define|#
directive|define
name|is_alnum
parameter_list|(
name|c
parameter_list|)
value|(is_ascii(c)&& isalnum(c))
end_define

begin_comment
comment|/* Scanning macros */
end_comment

begin_define
define|#
directive|define
name|isidchar
parameter_list|(
name|ch
parameter_list|)
value|(is_alnum(ch) || (ch) == '_')
end_define

begin_define
define|#
directive|define
name|isidfirstchar
parameter_list|(
name|ch
parameter_list|)
value|(is_alpha(ch) || (ch) == '_')
end_define

begin_comment
comment|/* Forward references */
end_comment

begin_function_decl
name|char
modifier|*
name|ppdirforward
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ppdirbackward
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|skipspace
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|scanstring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|writeblanks
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|test1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|convert1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The main program */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|in
init|=
name|stdin
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|stdout
decl_stmt|;
name|char
modifier|*
name|filename
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|program_name
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|output_name
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|bufsize
value|5000
comment|/* arbitrary size */
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|more
decl_stmt|;
name|char
modifier|*
name|usage
init|=
literal|"Usage: ansi2knr [--filename FILENAME] [INPUT_FILE [OUTPUT_FILE]]\n"
decl_stmt|;
comment|/* 	 * In previous versions, ansi2knr recognized a --varargs switch. 	 * If this switch was supplied, ansi2knr would attempt to convert 	 * a ... argument to va_alist and va_dcl; if this switch was not 	 * supplied, ansi2knr would simply drop any such arguments. 	 * Now, ansi2knr always does this conversion, and we only 	 * check for this switch for backward compatibility. 	 */
name|int
name|convert_varargs
init|=
literal|1
decl_stmt|;
name|int
name|output_error
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--varargs"
argument_list|)
condition|)
block|{
name|convert_varargs
operator|=
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--filename"
argument_list|)
operator|&&
name|argc
operator|>
literal|2
condition|)
block|{
name|filename
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unrecognized switch: %s\n"
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|argc
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|output_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|output_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot open output file %s\n"
argument_list|,
name|program_name
argument_list|,
name|output_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* falls through */
case|case
literal|2
case|:
name|in
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Cannot open input file %s\n"
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|==
literal|0
condition|)
name|filename
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
comment|/* falls through */
case|case
literal|1
case|:
break|break;
block|}
if|if
condition|(
name|filename
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#line 1 \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate read buffer!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|buf
operator|+
name|bufsize
operator|-
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|test
label|:
name|line
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|test1
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
comment|/* a function header */
name|convert1
argument_list|(
name|buf
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|convert_varargs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* a function */
comment|/* Check for a { at the start of the next line. */
name|more
operator|=
operator|++
name|line
expr_stmt|;
name|f
label|:
if|if
condition|(
name|line
operator|>=
name|buf
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
condition|)
comment|/* overflow check */
goto|goto
name|wl
goto|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|buf
operator|+
name|bufsize
operator|-
name|line
argument_list|)
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|wl
goto|;
switch|switch
condition|(
operator|*
name|skipspace
argument_list|(
name|ppdirforward
argument_list|(
name|more
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|'{'
case|:
comment|/* Definitely a function header. */
name|convert1
argument_list|(
name|buf
argument_list|,
name|out
argument_list|,
literal|0
argument_list|,
name|convert_varargs
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|more
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* The next line was blank or a comment: */
comment|/* keep scanning for a non-comment. */
name|line
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
goto|goto
name|f
goto|;
default|default:
comment|/* buf isn't a function header, but */
comment|/* more might be. */
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|line
operator|=
name|buf
expr_stmt|;
goto|goto
name|test
goto|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
comment|/* maybe the start of a function */
if|if
condition|(
name|line
operator|!=
name|buf
operator|+
operator|(
name|bufsize
operator|-
literal|1
operator|)
condition|)
comment|/* overflow check */
continue|continue;
comment|/* falls through */
default|default:
comment|/* not a function */
name|wl
label|:
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|!=
name|buf
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_name
condition|)
block|{
name|output_error
operator|=
name|ferror
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|output_error
operator||=
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* out == stdout */
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|output_error
operator|=
name|ferror
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error writing to %s\n"
argument_list|,
name|program_name
argument_list|,
operator|(
name|output_name
condition|?
name|output_name
else|:
literal|"stdout"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Skip forward or backward over one or more preprocessor directives.  */
end_comment

begin_function
name|char
modifier|*
name|ppdirforward
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|p
operator|==
literal|'#'
condition|;
operator|++
name|p
control|)
block|{
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ppdirbackward
parameter_list|(
name|p
parameter_list|,
name|limit
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|limit
decl_stmt|;
block|{
name|char
modifier|*
name|np
init|=
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
name|p
operator|=
operator|--
name|np
control|)
block|{
if|if
condition|(
operator|*
name|np
operator|==
literal|'\n'
operator|&&
name|np
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
operator|--
name|np
expr_stmt|;
for|for
control|(
init|;
name|np
operator|>
name|limit
operator|&&
name|np
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\r'
operator|&&
name|np
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
operator|--
name|np
control|)
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
return|return
name|np
return|;
if|if
condition|(
operator|*
name|np
operator|!=
literal|'#'
condition|)
return|return
name|p
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip over whitespace, comments, and preprocessor directives,  * in either direction.  */
end_comment

begin_function
name|char
modifier|*
name|skipspace
parameter_list|(
name|p
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dir
decl_stmt|;
comment|/* 1 for forward, -1 for backward */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|is_space
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|+=
name|dir
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|p
index|[
name|dir
index|]
operator|==
literal|'*'
operator|)
condition|)
break|break;
name|p
operator|+=
name|dir
expr_stmt|;
name|p
operator|+=
name|dir
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|p
index|[
name|dir
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
name|p
return|;
comment|/* multi-line comment?? */
name|p
operator|+=
name|dir
expr_stmt|;
block|}
name|p
operator|+=
name|dir
expr_stmt|;
name|p
operator|+=
name|dir
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Scan over a quoted string, in either direction. */
end_comment

begin_function
name|char
modifier|*
name|scanstring
parameter_list|(
name|p
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
for|for
control|(
name|p
operator|+=
name|dir
init|;
condition|;
name|p
operator|+=
name|dir
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
operator|&&
name|p
index|[
operator|-
name|dir
index|]
operator|!=
literal|'\\'
condition|)
return|return
name|p
operator|+
name|dir
return|;
block|}
end_function

begin_comment
comment|/*  * Write blanks over part of a string.  * Don't overwrite end-of-line characters.  */
end_comment

begin_function
name|int
name|writeblanks
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|start
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\r'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether the string in buf is a function definition.  * The string may contain and/or end with a newline.  * Return as follows:  *	0 - definitely not a function definition;  *	1 - definitely a function definition;  *	2 - definitely a function prototype (NOT USED);  *	-1 - may be the beginning of a function definition,  *		append another line and look again.  * The reason we don't attempt to convert function prototypes is that  * Ghostscript's declaration-generating macros look too much like  * prototypes, and confuse the algorithms.  */
end_comment

begin_function
name|int
name|test1
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|bend
decl_stmt|;
name|char
modifier|*
name|endfn
decl_stmt|;
name|int
name|contin
decl_stmt|;
if|if
condition|(
operator|!
name|isidfirstchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* no name at left margin */
name|bend
operator|=
name|skipspace
argument_list|(
name|ppdirbackward
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|buf
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|bend
condition|)
block|{
case|case
literal|';'
case|:
name|contin
operator|=
literal|0
comment|/*2*/
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|contin
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
return|return
literal|0
return|;
comment|/* not a function */
case|case
literal|'}'
case|:
return|return
literal|0
return|;
comment|/* not a function */
default|default:
name|contin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|endfn
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'('
condition|)
return|return
literal|0
return|;
comment|/* not a function */
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
return|return
literal|0
return|;
comment|/* no parameters */
comment|/* Check that the apparent function name isn't a keyword. */
comment|/* We only need to check for keywords that could be followed */
comment|/* by a left parenthesis (which, unfortunately, is most of them). */
block|{
specifier|static
name|char
modifier|*
name|words
index|[]
init|=
block|{
literal|"asm"
block|,
literal|"auto"
block|,
literal|"case"
block|,
literal|"char"
block|,
literal|"const"
block|,
literal|"double"
block|,
literal|"extern"
block|,
literal|"float"
block|,
literal|"for"
block|,
literal|"if"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"register"
block|,
literal|"return"
block|,
literal|"short"
block|,
literal|"signed"
block|,
literal|"sizeof"
block|,
literal|"static"
block|,
literal|"switch"
block|,
literal|"typedef"
block|,
literal|"unsigned"
block|,
literal|"void"
block|,
literal|"volatile"
block|,
literal|"while"
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|key
init|=
name|words
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|unsigned
name|len
init|=
name|endfn
operator|-
name|buf
decl_stmt|;
while|while
condition|(
operator|(
name|kp
operator|=
operator|*
name|key
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|kp
argument_list|)
operator|==
name|len
operator|&&
operator|!
name|strncmp
argument_list|(
name|kp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* name is a keyword */
name|key
operator|++
expr_stmt|;
block|}
block|}
block|{
name|char
modifier|*
name|id
init|=
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 		* Check for identifier1(identifier2) and not 		* identifier1(void), or identifier1(identifier2, xxxx). 		*/
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|id
expr_stmt|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|(
operator|*
name|p
operator|==
literal|')'
operator|&&
operator|(
name|len
operator|!=
literal|4
operator|||
name|strncmp
argument_list|(
name|id
argument_list|,
literal|"void"
argument_list|,
literal|4
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* not a function */
block|}
comment|/* 	 * If the last significant character was a ), we need to count 	 * parentheses, because it might be part of a formal parameter 	 * that is a procedure. 	 */
if|if
condition|(
name|contin
operator|>
literal|0
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|skipspace
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|skipspace
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
control|)
name|level
operator|+=
operator|(
operator|*
name|p
operator|==
literal|'('
condition|?
literal|1
else|:
operator|*
name|p
operator|==
literal|')'
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|contin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|contin
return|;
block|}
end_function

begin_comment
comment|/* Convert a recognized function definition or header to K&R syntax. */
end_comment

begin_function
name|int
name|convert1
parameter_list|(
name|buf
parameter_list|,
name|out
parameter_list|,
name|header
parameter_list|,
name|convert_varargs
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|int
name|header
decl_stmt|;
comment|/* Boolean */
name|int
name|convert_varargs
decl_stmt|;
comment|/* Boolean */
block|{
name|char
modifier|*
name|endfn
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * The breaks table contains pointers to the beginning and end 	 * of each argument. 	 */
name|char
modifier|*
modifier|*
name|breaks
decl_stmt|;
name|unsigned
name|num_breaks
init|=
literal|2
decl_stmt|;
comment|/* for testing */
name|char
modifier|*
modifier|*
name|btop
decl_stmt|;
name|char
modifier|*
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|vararg
init|=
literal|0
decl_stmt|;
comment|/* Pre-ANSI implementations don't agree on whether strchr */
comment|/* is called strchr or index, so we open-code it here. */
for|for
control|(
name|endfn
operator|=
name|buf
init|;
operator|*
operator|(
name|endfn
operator|++
operator|)
operator|!=
literal|'('
condition|;
control|)
empty_stmt|;
name|top
label|:
name|p
operator|=
name|endfn
expr_stmt|;
name|breaks
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|num_breaks
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|breaks
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't allocate break table, give up */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to allocate break table!\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|btop
operator|=
name|breaks
operator|+
name|num_breaks
operator|*
literal|2
operator|-
literal|2
expr_stmt|;
name|bp
operator|=
name|breaks
expr_stmt|;
comment|/* Parse the argument list */
do|do
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bp
operator|>=
name|btop
condition|)
block|{
comment|/* Filled up break table. */
comment|/* Allocate a bigger one and start over. */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|breaks
argument_list|)
expr_stmt|;
name|num_breaks
operator|<<=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
operator|*
name|bp
operator|++
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the argument */
for|for
control|(
init|;
name|end
operator|==
name|NULL
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|','
case|:
if|if
condition|(
operator|!
name|level
condition|)
name|end
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
name|level
condition|)
name|lp
operator|=
name|p
expr_stmt|;
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|level
operator|<
literal|0
condition|)
name|end
operator|=
name|p
expr_stmt|;
else|else
name|rp
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|p
operator|=
name|scanstring
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
comment|/* Erase any embedded prototype parameters. */
if|if
condition|(
name|lp
operator|&&
name|rp
condition|)
name|writeblanks
argument_list|(
name|lp
operator|+
literal|1
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* back up over terminator */
comment|/* Find the name being declared. */
comment|/* This is complicated because of procedure and */
comment|/* array modifiers. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|']'
case|:
comment|/* skip array dimension(s) */
case|case
literal|')'
case|:
comment|/* skip procedure args OR name */
block|{
name|int
name|level
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|level
condition|)
switch|switch
condition|(
operator|*
operator|--
name|p
condition|)
block|{
case|case
literal|']'
case|:
case|case
literal|')'
case|:
name|level
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|'('
case|:
name|level
operator|--
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|p
operator|>
name|buf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|p
operator|=
name|scanstring
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
operator|&&
operator|*
name|skipspace
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
literal|'*'
condition|)
block|{
comment|/* We found the name being declared */
while|while
condition|(
operator|!
name|isidfirstchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|=
name|skipspace
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
goto|goto
name|found
goto|;
block|}
break|break;
default|default:
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|convert_varargs
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|"va_alist"
expr_stmt|;
name|vararg
operator|=
name|p
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|breaks
operator|+
literal|1
condition|)
comment|/* sole argument */
name|writeblanks
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|writeblanks
argument_list|(
name|bp
index|[
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|end
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
do|;
operator|*
name|bp
operator|=
name|p
expr_stmt|;
comment|/* Make a special check for 'void' arglist */
if|if
condition|(
name|bp
operator|==
name|breaks
operator|+
literal|2
condition|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"void"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|p
operator|=
name|skipspace
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|breaks
index|[
literal|2
index|]
operator|-
literal|1
condition|)
block|{
name|bp
operator|=
name|breaks
expr_stmt|;
comment|/* yup, pretend arglist is empty */
name|writeblanks
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Put out the function name and left parenthesis. */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|endfn
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|out
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
comment|/* Put out the declaration. */
if|if
condition|(
name|header
condition|)
block|{
name|fputs
argument_list|(
literal|");"
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|breaks
index|[
literal|0
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ap
operator|=
name|breaks
operator|+
literal|1
init|;
name|ap
operator|<
name|bp
condition|;
name|ap
operator|+=
literal|2
control|)
block|{
name|p
operator|=
operator|*
name|ap
expr_stmt|;
while|while
condition|(
name|isidchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|out
argument_list|)
operator|,
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ap
operator|<
name|bp
operator|-
literal|1
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|")  "
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Put out the argument declarations */
for|for
control|(
name|ap
operator|=
name|breaks
operator|+
literal|2
init|;
name|ap
operator|<=
name|bp
condition|;
name|ap
operator|+=
literal|2
control|)
operator|(
operator|*
name|ap
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|';'
expr_stmt|;
if|if
condition|(
name|vararg
operator|!=
literal|0
condition|)
block|{
operator|*
name|vararg
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* any prior args */
name|fputs
argument_list|(
literal|"va_dcl"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* the final arg */
name|fputs
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|breaks
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|breaks
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

