begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This program can be used to calibrate the clock reading jitter of a  * particular CPU and operating system. It first tickles every element  * of an array, in order to force pages into memory, then repeatedly  * reads the system clock and, finally, writes out the time values for  * later analysis. From this you can determine the jitter and if the  * clock ever runs backwards.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"jitter.h"
end_include

begin_define
define|#
directive|define
name|NBUF
value|800002
end_define

begin_define
define|#
directive|define
name|FRAC
value|4294967296.
end_define

begin_comment
comment|/* a bbbbillion */
end_comment

begin_define
define|#
directive|define
name|JAN_1970
value|2208988800UL
end_define

begin_comment
comment|/* Unix base epoch */
end_comment

begin_define
define|#
directive|define
name|CLOCK_GETTIME
end_define

begin_comment
comment|/* Solaris hires clock */
end_comment

begin_decl_stmt
name|char
name|progname
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|sys_residual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|average
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|sys_gettime
parameter_list|(
name|l_fp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|l_fp
name|tr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|dtemp
decl_stmt|,
name|gtod
index|[
name|NBUF
index|]
decl_stmt|;
comment|/* 	 * Force pages into memory 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUF
condition|;
name|i
operator|++
control|)
name|gtod
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Construct gtod array 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUF
condition|;
name|i
operator|++
control|)
block|{
name|get_systime
argument_list|(
operator|&
name|tr
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tr
argument_list|,
name|gtod
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write out gtod array for later processing with Matlab 	 */
name|average
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUF
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|gtod
index|[
name|i
index|]
operator|=
name|gtod
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|gtod
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%13.9f\n"
argument_list|,
name|gtod
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|average
operator|+=
name|gtod
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * Sort the gtod array and display deciles 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUF
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|gtod
index|[
name|j
index|]
operator|>
name|gtod
index|[
name|i
index|]
condition|)
block|{
name|dtemp
operator|=
name|gtod
index|[
name|j
index|]
expr_stmt|;
name|gtod
index|[
name|j
index|]
operator|=
name|gtod
index|[
name|i
index|]
expr_stmt|;
name|gtod
index|[
name|i
index|]
operator|=
name|dtemp
expr_stmt|;
block|}
block|}
block|}
name|average
operator|=
name|average
operator|/
operator|(
name|NBUF
operator|-
literal|2
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Average %13.9f\n"
argument_list|,
name|average
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"First rank\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2d %13.9f\n"
argument_list|,
name|i
argument_list|,
name|gtod
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Last rank\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NBUF
operator|-
literal|12
init|;
name|i
operator|<
name|NBUF
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2d %13.9f\n"
argument_list|,
name|i
argument_list|,
name|gtod
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_systime - return system time in NTP timestamp format.  */
end_comment

begin_function
name|void
name|get_systime
parameter_list|(
name|l_fp
modifier|*
name|now
comment|/* system time */
parameter_list|)
block|{
name|double
name|dtemp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_CLOCK_GETTIME
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCLOCK
argument_list|)
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* seconds and nanoseconds */
comment|/* 	 * Convert Unix clock from seconds and nanoseconds to seconds. 	 */
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
else|#
directive|else
name|getclock
argument_list|(
name|TIMEOFDAY
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|now
operator|->
name|l_i
operator|=
name|ts
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1e9
expr_stmt|;
else|#
directive|else
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* seconds and microseconds */
comment|/* 	 * Convert Unix clock from seconds and microseconds to seconds. 	 */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|now
operator|->
name|l_i
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|JAN_1970
expr_stmt|;
name|dtemp
operator|=
name|tv
operator|.
name|tv_usec
operator|/
literal|1e6
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_CLOCK_GETTIME || HAVE_GETCLOCK */
comment|/* 	 * Renormalize to seconds past 1900 and fraction. 	 */
name|dtemp
operator|+=
name|sys_residual
expr_stmt|;
if|if
condition|(
name|dtemp
operator|>=
literal|1
condition|)
block|{
name|dtemp
operator|-=
literal|1
expr_stmt|;
name|now
operator|->
name|l_i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtemp
operator|<
operator|-
literal|1
condition|)
block|{
name|dtemp
operator|+=
literal|1
expr_stmt|;
name|now
operator|->
name|l_i
operator|--
expr_stmt|;
block|}
name|dtemp
operator|*=
name|FRAC
expr_stmt|;
name|now
operator|->
name|l_uf
operator|=
operator|(
name|u_int32
operator|)
name|dtemp
expr_stmt|;
block|}
end_function

end_unit

