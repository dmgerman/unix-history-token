begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* =========================================================================     Unity Project - A Test Framework for C     Copyright (c) 2007-14 Mike Karlesky, Mark VanderVoord, Greg Williams     [Released under MIT License. Please refer to license.txt for details] ============================================================================ */
end_comment

begin_include
include|#
directive|include
file|"unity.h"
end_include

begin_define
define|#
directive|define
name|UNITY_FAIL_AND_BAIL
value|{ Unity.CurrentTestFailed  = 1; longjmp(Unity.AbortFrame, 1); }
end_define

begin_define
define|#
directive|define
name|UNITY_IGNORE_AND_BAIL
value|{ Unity.CurrentTestIgnored = 1; longjmp(Unity.AbortFrame, 1); }
end_define

begin_comment
comment|/// return prematurely if we are already in failure or ignore state
end_comment

begin_define
define|#
directive|define
name|UNITY_SKIP_EXECUTION
value|{ if ((Unity.CurrentTestFailed != 0) || (Unity.CurrentTestIgnored != 0)) {return;} }
end_define

begin_define
define|#
directive|define
name|UNITY_PRINT_EOL
value|{ UNITY_OUTPUT_CHAR('\n'); }
end_define

begin_decl_stmt
name|struct
name|_Unity
name|Unity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrOk
index|[]
init|=
literal|"OK"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrPass
index|[]
init|=
literal|"PASS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrFail
index|[]
init|=
literal|"FAIL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrIgnore
index|[]
init|=
literal|"IGNORE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrXPASS
index|[]
init|=
literal|"XPASS"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrXFAIL
index|[]
init|=
literal|"XFAIL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNull
index|[]
init|=
literal|"NULL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrSpacer
index|[]
init|=
literal|". "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrExpected
index|[]
init|=
literal|" Expected "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrWas
index|[]
init|=
literal|" Was "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrTo
index|[]
init|=
literal|" To "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrElement
index|[]
init|=
literal|" Element "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrByte
index|[]
init|=
literal|" Byte "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrMemory
index|[]
init|=
literal|" Memory Mismatch."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrDelta
index|[]
init|=
literal|" Values Not Within Delta "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrPointless
index|[]
init|=
literal|" You Asked Me To Compare Nothing, Which Was Pointless."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNullPointerForExpected
index|[]
init|=
literal|" Expected pointer to be NULL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNullPointerForActual
index|[]
init|=
literal|" Actual pointer was NULL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNot
index|[]
init|=
literal|"Not "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrInf
index|[]
init|=
literal|"Infinity"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNegInf
index|[]
init|=
literal|"Negative Infinity"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrNaN
index|[]
init|=
literal|"NaN"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrDet
index|[]
init|=
literal|"Determinate"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrErrFloat
index|[]
init|=
literal|"Unity Floating Point Disabled"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrErrDouble
index|[]
init|=
literal|"Unity Double Precision Disabled"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrErr64
index|[]
init|=
literal|"Unity 64-bit Support Disabled"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrBreaker
index|[]
init|=
literal|"-----------------------"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsTests
index|[]
init|=
literal|" Tests: "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsFailures
index|[]
init|=
literal|" Failures "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsIgnored
index|[]
init|=
literal|" Ignored "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsXFAIL
index|[]
init|=
literal|" XFAIL "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsXPASS
index|[]
init|=
literal|" XPASS "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|UnityStrResultsPass
index|[]
init|=
literal|" PASS "
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|UNITY_EXCLUDE_FLOAT
end_ifndef

begin_comment
comment|// Dividing by these constants produces +/- infinity.
end_comment

begin_comment
comment|// The rationale is given in UnityAssertFloatIsInf's body.
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|_UF
name|f_zero
init|=
literal|0.0f
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|UNITY_EXCLUDE_DOUBLE
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|_UD
name|d_zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// compiler-generic print formatting masks
end_comment

begin_decl_stmt
specifier|const
name|_U_UINT
name|UnitySizeMask
index|[]
init|=
block|{
literal|255u
block|,
comment|// 0xFF
literal|65535u
block|,
comment|// 0xFFFF
literal|65535u
block|,
literal|4294967295u
block|,
comment|// 0xFFFFFFFF
literal|4294967295u
block|,
literal|4294967295u
block|,
literal|4294967295u
ifdef|#
directive|ifdef
name|UNITY_SUPPORT_64
block|,
literal|0xFFFFFFFFFFFFFFFF
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|UnityPrintFail
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|UnityPrintOk
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|// Pretty Printers& Test Result Output Handlers
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityPrint
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pch
init|=
name|string
decl_stmt|;
if|if
condition|(
name|pch
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|pch
condition|)
block|{
comment|// printable characters plus CR& LF are printed
if|if
condition|(
operator|(
operator|*
name|pch
operator|<=
literal|126
operator|)
operator|&&
operator|(
operator|*
name|pch
operator|>=
literal|32
operator|)
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
operator|*
name|pch
argument_list|)
expr_stmt|;
block|}
comment|//write escaped carriage returns
elseif|else
if|if
condition|(
operator|*
name|pch
operator|==
literal|13
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
block|}
comment|//write escaped line feeds
elseif|else
if|if
condition|(
operator|*
name|pch
operator|==
literal|10
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
block|}
comment|// unprintable characters are shown as codes
else|else
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|UnityPrintNumberHex
argument_list|(
operator|(
name|_U_UINT
operator|)
operator|*
name|pch
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pch
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityPrintNumberByStyle
parameter_list|(
specifier|const
name|_U_SINT
name|number
parameter_list|,
specifier|const
name|UNITY_DISPLAY_STYLE_T
name|style
parameter_list|)
block|{
if|if
condition|(
operator|(
name|style
operator|&
name|UNITY_DISPLAY_RANGE_INT
operator|)
operator|==
name|UNITY_DISPLAY_RANGE_INT
condition|)
block|{
name|UnityPrintNumber
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|style
operator|&
name|UNITY_DISPLAY_RANGE_UINT
operator|)
operator|==
name|UNITY_DISPLAY_RANGE_UINT
condition|)
block|{
name|UnityPrintNumberUnsigned
argument_list|(
operator|(
name|_U_UINT
operator|)
name|number
operator|&
name|UnitySizeMask
index|[
operator|(
operator|(
name|_U_UINT
operator|)
name|style
operator|&
operator|(
name|_U_UINT
operator|)
literal|0x0F
operator|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnityPrintNumberHex
argument_list|(
operator|(
name|_U_UINT
operator|)
name|number
argument_list|,
call|(
name|char
call|)
argument_list|(
operator|(
name|style
operator|&
literal|0x000F
operator|)
operator|<<
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|/// basically do an itoa using as little ram as possible
end_comment

begin_function
name|void
name|UnityPrintNumber
parameter_list|(
specifier|const
name|_U_SINT
name|number_to_print
parameter_list|)
block|{
name|_U_SINT
name|divisor
init|=
literal|1
decl_stmt|;
name|_U_SINT
name|next_divisor
decl_stmt|;
name|_U_UINT
name|number
decl_stmt|;
if|if
condition|(
name|number_to_print
operator|==
operator|(
literal|1l
operator|<<
operator|(
name|UNITY_LONG_WIDTH
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|//The largest representable negative number
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|number
operator|=
operator|(
literal|1ul
operator|<<
operator|(
name|UNITY_LONG_WIDTH
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|number_to_print
operator|<
literal|0
condition|)
block|{
comment|//Some other negative number
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|number
operator|=
call|(
name|_U_UINT
call|)
argument_list|(
operator|-
name|number_to_print
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Positive number
name|number
operator|=
operator|(
name|_U_UINT
operator|)
name|number_to_print
expr_stmt|;
block|}
comment|// figure out initial divisor
while|while
condition|(
name|number
operator|/
name|divisor
operator|>
literal|9
condition|)
block|{
name|next_divisor
operator|=
name|divisor
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|next_divisor
operator|>
name|divisor
condition|)
name|divisor
operator|=
name|next_divisor
expr_stmt|;
else|else
break|break;
block|}
comment|// now mod and print, then divide divisor
do|do
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
operator|(
name|number
operator|/
name|divisor
operator|%
literal|10
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|divisor
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|divisor
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|/// basically do an itoa using as little ram as possible
end_comment

begin_function
name|void
name|UnityPrintNumberUnsigned
parameter_list|(
specifier|const
name|_U_UINT
name|number
parameter_list|)
block|{
name|_U_UINT
name|divisor
init|=
literal|1
decl_stmt|;
name|_U_UINT
name|next_divisor
decl_stmt|;
comment|// figure out initial divisor
while|while
condition|(
name|number
operator|/
name|divisor
operator|>
literal|9
condition|)
block|{
name|next_divisor
operator|=
name|divisor
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|next_divisor
operator|>
name|divisor
condition|)
name|divisor
operator|=
name|next_divisor
expr_stmt|;
else|else
break|break;
block|}
comment|// now mod and print, then divide divisor
do|do
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
operator|(
name|number
operator|/
name|divisor
operator|%
literal|10
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|divisor
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|divisor
operator|>
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityPrintNumberHex
parameter_list|(
specifier|const
name|_U_UINT
name|number
parameter_list|,
specifier|const
name|char
name|nibbles_to_print
parameter_list|)
block|{
name|_U_UINT
name|nibble
decl_stmt|;
name|char
name|nibbles
init|=
name|nibbles_to_print
decl_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'x'
argument_list|)
expr_stmt|;
while|while
condition|(
name|nibbles
operator|>
literal|0
condition|)
block|{
name|nibble
operator|=
operator|(
name|number
operator|>>
operator|(
operator|--
name|nibbles
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0x0000000F
expr_stmt|;
if|if
condition|(
name|nibble
operator|<=
literal|9
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'0'
operator|+
name|nibble
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
call|(
name|char
call|)
argument_list|(
literal|'A'
operator|-
literal|10
operator|+
name|nibble
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityPrintMask
parameter_list|(
specifier|const
name|_U_UINT
name|mask
parameter_list|,
specifier|const
name|_U_UINT
name|number
parameter_list|)
block|{
name|_U_UINT
name|current_bit
init|=
operator|(
name|_U_UINT
operator|)
literal|1
operator|<<
operator|(
name|UNITY_INT_WIDTH
operator|-
literal|1
operator|)
decl_stmt|;
name|_US32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UNITY_INT_WIDTH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|current_bit
operator|&
name|mask
condition|)
block|{
if|if
condition|(
name|current_bit
operator|&
name|number
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'X'
argument_list|)
expr_stmt|;
block|}
name|current_bit
operator|=
name|current_bit
operator|>>
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNITY_FLOAT_VERBOSE
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function
name|void
name|UnityPrintFloat
parameter_list|(
name|_UF
name|number
parameter_list|)
block|{
name|char
name|TempBuffer
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|TempBuffer
argument_list|,
literal|"%.6f"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|TempBuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityPrintFail
parameter_list|(
name|void
parameter_list|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrFail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnityPrintOk
parameter_list|(
name|void
parameter_list|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrOk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
specifier|static
name|void
name|UnityTestResultsBegin
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|line
parameter_list|)
block|{
name|UnityPrint
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|UnityPrintNumber
argument_list|(
operator|(
name|_U_SINT
operator|)
name|line
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|Unity
operator|.
name|CurrentTestName
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
specifier|static
name|void
name|UnityTestResultsFailBegin
parameter_list|(
specifier|const
name|UNITY_LINE_TYPE
name|line
parameter_list|)
block|{
name|UnityTestResultsBegin
argument_list|(
name|Unity
operator|.
name|TestFile
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|Unity
operator|.
name|isExpectingFail
condition|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrXFAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnityPrint
argument_list|(
name|UnityStrFail
argument_list|)
expr_stmt|;
block|}
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityConcludeTest
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|if (Unity.isExpectingFail == 1&& Unity.CurrentTestFailed == 0) 	{ 		printf("FAIL WAS EXPECTED, BUT IT DIDN'T HAPPEN?!"); 		Unity.TestXPASSES++; 	}  	else
endif|#
directive|endif
comment|//cant be ignored and accepting fail at the same time!
if|if
condition|(
name|Unity
operator|.
name|isExpectingFail
operator|==
literal|1
operator|&&
name|Unity
operator|.
name|CurrentTestFailed
operator|==
literal|1
condition|)
block|{
name|Unity
operator|.
name|TestXFAILS
operator|++
expr_stmt|;
comment|//error message?!
if|if
condition|(
name|Unity
operator|.
name|XFAILMessage
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Unity
operator|.
name|XFAILMessage
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"| "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|Unity
operator|.
name|XFAILMessage
argument_list|)
expr_stmt|;
name|Unity
operator|.
name|XFAILMessage
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" - EXPECTED FAIL!"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Unity
operator|.
name|CurrentTestIgnored
condition|)
block|{
name|Unity
operator|.
name|TestIgnores
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
if|if
condition|(
name|Unity
operator|.
name|isExpectingFail
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsBegin
argument_list|(
name|Unity
operator|.
name|TestFile
argument_list|,
name|Unity
operator|.
name|CurrentTestLineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPass
argument_list|)
expr_stmt|;
name|Unity
operator|.
name|TestPasses
operator|++
expr_stmt|;
block|}
comment|//probably should remove the if... part
elseif|else
if|if
condition|(
name|Unity
operator|.
name|isExpectingFail
operator|==
literal|1
operator|&&
name|Unity
operator|.
name|CurrentTestFailed
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsBegin
argument_list|(
name|Unity
operator|.
name|TestFile
argument_list|,
name|Unity
operator|.
name|CurrentTestLineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrXPASS
argument_list|)
expr_stmt|;
name|Unity
operator|.
name|TestXPASSES
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" - FAIL WAS EXPECTED, BUT DIDN'T HAPPEN?!"
argument_list|)
expr_stmt|;
comment|//if (Unity.TestPasses> 0) { Unity.TestPasses--; }
block|}
block|}
else|else
block|{
name|Unity
operator|.
name|TestFailures
operator|++
expr_stmt|;
block|}
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|CurrentTestIgnored
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|isExpectingFail
operator|=
literal|0
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
specifier|static
name|void
name|UnityAddMsgIfSpecified
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrSpacer
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
specifier|static
name|void
name|UnityPrintExpectedAndActualStrings
parameter_list|(
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|NULL
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnityPrint
argument_list|(
name|UnityStrNull
argument_list|)
expr_stmt|;
block|}
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|!=
name|NULL
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UnityPrint
argument_list|(
name|UnityStrNull
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|// Assertion& Control Helpers
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
specifier|static
name|int
name|UnityCheckArraysForNull
parameter_list|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|expected
parameter_list|,
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|actual
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|//return true if they are both NULL
if|if
condition|(
operator|(
name|expected
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|actual
operator|==
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
comment|//throw error if just expected is NULL
if|if
condition|(
name|expected
operator|==
name|NULL
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrNullPointerForExpected
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
comment|//throw error if just actual is NULL
if|if
condition|(
name|actual
operator|==
name|NULL
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrNullPointerForActual
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
comment|//return false if neither is NULL
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|// Assertion Functions
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertBits
parameter_list|(
specifier|const
name|_U_SINT
name|mask
parameter_list|,
specifier|const
name|_U_SINT
name|expected
parameter_list|,
specifier|const
name|_U_SINT
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|expected
operator|)
operator|!=
operator|(
name|mask
operator|&
name|actual
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintMask
argument_list|(
operator|(
name|_U_UINT
operator|)
name|mask
argument_list|,
operator|(
name|_U_UINT
operator|)
name|expected
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintMask
argument_list|(
operator|(
name|_U_UINT
operator|)
name|mask
argument_list|,
operator|(
name|_U_UINT
operator|)
name|actual
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertEqualNumber
parameter_list|(
specifier|const
name|_U_SINT
name|expected
parameter_list|,
specifier|const
name|_U_SINT
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|UNITY_DISPLAY_STYLE_T
name|style
parameter_list|)
block|{
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
name|expected
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
name|actual
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertEqualIntArray
parameter_list|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|expected
parameter_list|,
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|actual
parameter_list|,
specifier|const
name|_UU32
name|num_elements
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|UNITY_DISPLAY_STYLE_T
name|style
parameter_list|)
block|{
name|_UU32
name|elements
init|=
name|num_elements
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US8
modifier|*
name|ptr_exp
init|=
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US8
operator|*
operator|)
name|expected
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US8
modifier|*
name|ptr_act
init|=
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US8
operator|*
operator|)
name|actual
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|elements
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPointless
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
if|if
condition|(
name|UnityCheckArraysForNull
argument_list|(
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|expected
argument_list|,
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|actual
argument_list|,
name|lineNumber
argument_list|,
name|msg
argument_list|)
operator|==
literal|1
condition|)
return|return;
comment|// If style is UNITY_DISPLAY_STYLE_INT, we'll fall into the default case rather than the INT16 or INT32 (etc) case
comment|// as UNITY_DISPLAY_STYLE_INT includes a flag for UNITY_DISPLAY_RANGE_AUTO, which the width-specific
comment|// variants do not. Therefore remove this flag.
switch|switch
condition|(
name|style
operator|&
call|(
name|UNITY_DISPLAY_STYLE_T
call|)
argument_list|(
operator|~
name|UNITY_DISPLAY_RANGE_AUTO
argument_list|)
condition|)
block|{
case|case
name|UNITY_DISPLAY_STYLE_HEX8
case|:
case|case
name|UNITY_DISPLAY_STYLE_INT8
case|:
case|case
name|UNITY_DISPLAY_STYLE_UINT8
case|:
while|while
condition|(
name|elements
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|ptr_exp
operator|!=
operator|*
name|ptr_act
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
name|ptr_exp
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
name|ptr_act
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_exp
operator|+=
literal|1
expr_stmt|;
name|ptr_act
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|UNITY_DISPLAY_STYLE_HEX16
case|:
case|case
name|UNITY_DISPLAY_STYLE_INT16
case|:
case|case
name|UNITY_DISPLAY_STYLE_UINT16
case|:
while|while
condition|(
name|elements
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US16
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
operator|!=
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US16
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US16
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US16
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_exp
operator|+=
literal|2
expr_stmt|;
name|ptr_act
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|UNITY_SUPPORT_64
case|case
name|UNITY_DISPLAY_STYLE_HEX64
case|:
case|case
name|UNITY_DISPLAY_STYLE_INT64
case|:
case|case
name|UNITY_DISPLAY_STYLE_UINT64
case|:
while|while
condition|(
name|elements
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US64
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
operator|!=
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US64
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US64
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US64
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_exp
operator|+=
literal|8
expr_stmt|;
name|ptr_act
operator|+=
literal|8
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
while|while
condition|(
name|elements
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US32
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
operator|!=
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US32
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US32
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_exp
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_US32
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ptr_act
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_exp
operator|+=
literal|4
expr_stmt|;
name|ptr_act
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNITY_EXCLUDE_FLOAT
end_ifndef

begin_function
name|void
name|UnityAssertEqualFloatArray
parameter_list|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UF
modifier|*
name|expected
parameter_list|,
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UF
modifier|*
name|actual
parameter_list|,
specifier|const
name|_UU32
name|num_elements
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UU32
name|elements
init|=
name|num_elements
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UF
modifier|*
name|ptr_expected
init|=
name|expected
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UF
modifier|*
name|ptr_actual
init|=
name|actual
decl_stmt|;
name|_UF
name|diff
decl_stmt|,
name|tol
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|elements
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPointless
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
if|if
condition|(
name|UnityCheckArraysForNull
argument_list|(
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|expected
argument_list|,
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|actual
argument_list|,
name|lineNumber
argument_list|,
name|msg
argument_list|)
operator|==
literal|1
condition|)
return|return;
while|while
condition|(
name|elements
operator|--
condition|)
block|{
name|diff
operator|=
operator|*
name|ptr_expected
operator|-
operator|*
name|ptr_actual
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0f
condition|)
name|diff
operator|=
literal|0.0f
operator|-
name|diff
expr_stmt|;
name|tol
operator|=
name|UNITY_FLOAT_PRECISION
operator|*
operator|*
name|ptr_expected
expr_stmt|;
if|if
condition|(
name|tol
operator|<
literal|0.0f
condition|)
name|tol
operator|=
literal|0.0f
operator|-
name|tol
expr_stmt|;
comment|//This first part of this condition will catch any NaN or Infinite values
if|if
condition|(
operator|(
name|diff
operator|*
literal|0.0f
operator|!=
literal|0.0f
operator|)
operator|||
operator|(
name|diff
operator|>
name|tol
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_FLOAT_VERBOSE
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
operator|*
name|ptr_expected
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
operator|*
name|ptr_actual
argument_list|)
expr_stmt|;
else|#
directive|else
name|UnityPrint
argument_list|(
name|UnityStrDelta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_expected
operator|++
expr_stmt|;
name|ptr_actual
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertFloatsWithin
parameter_list|(
specifier|const
name|_UF
name|delta
parameter_list|,
specifier|const
name|_UF
name|expected
parameter_list|,
specifier|const
name|_UF
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UF
name|diff
init|=
name|actual
operator|-
name|expected
decl_stmt|;
name|_UF
name|pos_delta
init|=
name|delta
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0f
condition|)
block|{
name|diff
operator|=
literal|0.0f
operator|-
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|pos_delta
operator|<
literal|0.0f
condition|)
block|{
name|pos_delta
operator|=
literal|0.0f
operator|-
name|pos_delta
expr_stmt|;
block|}
comment|//This first part of this condition will catch any NaN or Infinite values
if|if
condition|(
operator|(
name|diff
operator|*
literal|0.0f
operator|!=
literal|0.0f
operator|)
operator|||
operator|(
name|pos_delta
operator|<
name|diff
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_FLOAT_VERBOSE
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
name|expected
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
name|actual
argument_list|)
expr_stmt|;
else|#
directive|else
name|UnityPrint
argument_list|(
name|UnityStrDelta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertFloatSpecial
parameter_list|(
specifier|const
name|_UF
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|UNITY_FLOAT_TRAIT_T
name|style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|trait_names
index|[]
init|=
block|{
name|UnityStrInf
block|,
name|UnityStrNegInf
block|,
name|UnityStrNaN
block|,
name|UnityStrDet
block|}
decl_stmt|;
name|_U_SINT
name|should_be_trait
init|=
operator|(
operator|(
name|_U_SINT
operator|)
name|style
operator|&
literal|1
operator|)
decl_stmt|;
name|_U_SINT
name|is_trait
init|=
operator|!
name|should_be_trait
decl_stmt|;
name|_U_SINT
name|trait_index
init|=
name|style
operator|>>
literal|1
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
comment|//To determine Inf / Neg Inf, we compare to an Inf / Neg Inf value we create on the fly
comment|//We are using a variable to hold the zero value because some compilers complain about dividing by zero otherwise
case|case
name|UNITY_FLOAT_IS_INF
case|:
case|case
name|UNITY_FLOAT_IS_NOT_INF
case|:
name|is_trait
operator|=
operator|(
operator|(
literal|1.0f
operator|/
name|f_zero
operator|)
operator|==
name|actual
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|UNITY_FLOAT_IS_NEG_INF
case|:
case|case
name|UNITY_FLOAT_IS_NOT_NEG_INF
case|:
name|is_trait
operator|=
operator|(
operator|(
operator|-
literal|1.0f
operator|/
name|f_zero
operator|)
operator|==
name|actual
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
comment|//NaN is the only floating point value that does NOT equal itself. Therefore if Actual == Actual, then it is NOT NaN.
case|case
name|UNITY_FLOAT_IS_NAN
case|:
case|case
name|UNITY_FLOAT_IS_NOT_NAN
case|:
name|is_trait
operator|=
operator|(
name|actual
operator|==
name|actual
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
comment|//A determinate number is non infinite and not NaN. (therefore the opposite of the two above)
case|case
name|UNITY_FLOAT_IS_DET
case|:
case|case
name|UNITY_FLOAT_IS_NOT_DET
case|:
if|if
condition|(
operator|(
name|actual
operator|!=
name|actual
operator|)
operator|||
operator|(
operator|(
literal|1.0f
operator|/
name|f_zero
operator|)
operator|==
name|actual
operator|)
operator|||
operator|(
operator|(
operator|-
literal|1.0f
operator|/
name|f_zero
operator|)
operator|==
name|actual
operator|)
condition|)
name|is_trait
operator|=
literal|0
expr_stmt|;
else|else
name|is_trait
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|is_trait
operator|!=
name|should_be_trait
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|should_be_trait
condition|)
name|UnityPrint
argument_list|(
name|UnityStrNot
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|trait_names
index|[
name|trait_index
index|]
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_FLOAT_VERBOSE
name|UnityPrintFloat
argument_list|(
name|actual
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|should_be_trait
condition|)
name|UnityPrint
argument_list|(
name|UnityStrNot
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|trait_names
index|[
name|trait_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//not UNITY_EXCLUDE_FLOAT
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNITY_EXCLUDE_DOUBLE
end_ifndef

begin_function
name|void
name|UnityAssertEqualDoubleArray
parameter_list|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UD
modifier|*
name|expected
parameter_list|,
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UD
modifier|*
name|actual
parameter_list|,
specifier|const
name|_UU32
name|num_elements
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UU32
name|elements
init|=
name|num_elements
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UD
modifier|*
name|ptr_expected
init|=
name|expected
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|_UD
modifier|*
name|ptr_actual
init|=
name|actual
decl_stmt|;
name|_UD
name|diff
decl_stmt|,
name|tol
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|elements
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPointless
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
if|if
condition|(
name|UnityCheckArraysForNull
argument_list|(
operator|(
name|UNITY_PTR_ATTRIBUTE
name|void
operator|*
operator|)
name|expected
argument_list|,
operator|(
name|UNITY_PTR_ATTRIBUTE
name|void
operator|*
operator|)
name|actual
argument_list|,
name|lineNumber
argument_list|,
name|msg
argument_list|)
operator|==
literal|1
condition|)
return|return;
while|while
condition|(
name|elements
operator|--
condition|)
block|{
name|diff
operator|=
operator|*
name|ptr_expected
operator|-
operator|*
name|ptr_actual
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0
condition|)
name|diff
operator|=
literal|0.0
operator|-
name|diff
expr_stmt|;
name|tol
operator|=
name|UNITY_DOUBLE_PRECISION
operator|*
operator|*
name|ptr_expected
expr_stmt|;
if|if
condition|(
name|tol
operator|<
literal|0.0
condition|)
name|tol
operator|=
literal|0.0
operator|-
name|tol
expr_stmt|;
comment|//This first part of this condition will catch any NaN or Infinite values
if|if
condition|(
operator|(
name|diff
operator|*
literal|0.0
operator|!=
literal|0.0
operator|)
operator|||
operator|(
name|diff
operator|>
name|tol
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_DOUBLE_VERBOSE
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|*
name|ptr_expected
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
call|(
name|float
call|)
argument_list|(
operator|*
name|ptr_actual
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|UnityPrint
argument_list|(
name|UnityStrDelta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_expected
operator|++
expr_stmt|;
name|ptr_actual
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertDoublesWithin
parameter_list|(
specifier|const
name|_UD
name|delta
parameter_list|,
specifier|const
name|_UD
name|expected
parameter_list|,
specifier|const
name|_UD
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UD
name|diff
init|=
name|actual
operator|-
name|expected
decl_stmt|;
name|_UD
name|pos_delta
init|=
name|delta
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0
condition|)
block|{
name|diff
operator|=
literal|0.0
operator|-
name|diff
expr_stmt|;
block|}
if|if
condition|(
name|pos_delta
operator|<
literal|0.0
condition|)
block|{
name|pos_delta
operator|=
literal|0.0
operator|-
name|pos_delta
expr_stmt|;
block|}
comment|//This first part of this condition will catch any NaN or Infinite values
if|if
condition|(
operator|(
name|diff
operator|*
literal|0.0
operator|!=
literal|0.0
operator|)
operator|||
operator|(
name|pos_delta
operator|<
name|diff
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_DOUBLE_VERBOSE
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
operator|(
name|float
operator|)
name|expected
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintFloat
argument_list|(
operator|(
name|float
operator|)
name|actual
argument_list|)
expr_stmt|;
else|#
directive|else
name|UnityPrint
argument_list|(
name|UnityStrDelta
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertDoubleSpecial
parameter_list|(
specifier|const
name|_UD
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|UNITY_FLOAT_TRAIT_T
name|style
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|trait_names
index|[]
init|=
block|{
name|UnityStrInf
block|,
name|UnityStrNegInf
block|,
name|UnityStrNaN
block|,
name|UnityStrDet
block|}
decl_stmt|;
name|_U_SINT
name|should_be_trait
init|=
operator|(
operator|(
name|_U_SINT
operator|)
name|style
operator|&
literal|1
operator|)
decl_stmt|;
name|_U_SINT
name|is_trait
init|=
operator|!
name|should_be_trait
decl_stmt|;
name|_U_SINT
name|trait_index
init|=
name|style
operator|>>
literal|1
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
switch|switch
condition|(
name|style
condition|)
block|{
comment|//To determine Inf / Neg Inf, we compare to an Inf / Neg Inf value we create on the fly
comment|//We are using a variable to hold the zero value because some compilers complain about dividing by zero otherwise
case|case
name|UNITY_FLOAT_IS_INF
case|:
case|case
name|UNITY_FLOAT_IS_NOT_INF
case|:
name|is_trait
operator|=
operator|(
operator|(
literal|1.0
operator|/
name|d_zero
operator|)
operator|==
name|actual
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|UNITY_FLOAT_IS_NEG_INF
case|:
case|case
name|UNITY_FLOAT_IS_NOT_NEG_INF
case|:
name|is_trait
operator|=
operator|(
operator|(
operator|-
literal|1.0
operator|/
name|d_zero
operator|)
operator|==
name|actual
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
comment|//NaN is the only floating point value that does NOT equal itself. Therefore if Actual == Actual, then it is NOT NaN.
case|case
name|UNITY_FLOAT_IS_NAN
case|:
case|case
name|UNITY_FLOAT_IS_NOT_NAN
case|:
name|is_trait
operator|=
operator|(
name|actual
operator|==
name|actual
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
comment|//A determinate number is non infinite and not NaN. (therefore the opposite of the two above)
case|case
name|UNITY_FLOAT_IS_DET
case|:
case|case
name|UNITY_FLOAT_IS_NOT_DET
case|:
if|if
condition|(
operator|(
name|actual
operator|!=
name|actual
operator|)
operator|||
operator|(
operator|(
literal|1.0
operator|/
name|d_zero
operator|)
operator|==
name|actual
operator|)
operator|||
operator|(
operator|(
operator|-
literal|1.0
operator|/
name|d_zero
operator|)
operator|==
name|actual
operator|)
condition|)
name|is_trait
operator|=
literal|0
expr_stmt|;
else|else
name|is_trait
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|is_trait
operator|!=
name|should_be_trait
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|should_be_trait
condition|)
name|UnityPrint
argument_list|(
name|UnityStrNot
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|trait_names
index|[
name|trait_index
index|]
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNITY_DOUBLE_VERBOSE
name|UnityPrintFloat
argument_list|(
name|actual
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|should_be_trait
condition|)
name|UnityPrint
argument_list|(
name|UnityStrNot
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|trait_names
index|[
name|trait_index
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// not UNITY_EXCLUDE_DOUBLE
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertNumbersWithin
parameter_list|(
specifier|const
name|_U_SINT
name|delta
parameter_list|,
specifier|const
name|_U_SINT
name|expected
parameter_list|,
specifier|const
name|_U_SINT
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|,
specifier|const
name|UNITY_DISPLAY_STYLE_T
name|style
parameter_list|)
block|{
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
operator|(
name|style
operator|&
name|UNITY_DISPLAY_RANGE_INT
operator|)
operator|==
name|UNITY_DISPLAY_RANGE_INT
condition|)
block|{
if|if
condition|(
name|actual
operator|>
name|expected
condition|)
name|Unity
operator|.
name|CurrentTestFailed
operator|=
operator|(
operator|(
name|actual
operator|-
name|expected
operator|)
operator|>
name|delta
operator|)
expr_stmt|;
else|else
name|Unity
operator|.
name|CurrentTestFailed
operator|=
operator|(
operator|(
name|expected
operator|-
name|actual
operator|)
operator|>
name|delta
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|_U_UINT
operator|)
name|actual
operator|>
operator|(
name|_U_UINT
operator|)
name|expected
condition|)
name|Unity
operator|.
name|CurrentTestFailed
operator|=
operator|(
call|(
name|_U_UINT
call|)
argument_list|(
name|actual
operator|-
name|expected
argument_list|)
operator|>
operator|(
name|_U_UINT
operator|)
name|delta
operator|)
expr_stmt|;
else|else
name|Unity
operator|.
name|CurrentTestFailed
operator|=
operator|(
call|(
name|_U_UINT
call|)
argument_list|(
name|expected
operator|-
name|actual
argument_list|)
operator|>
operator|(
name|_U_UINT
operator|)
name|delta
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrDelta
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
name|delta
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
name|expected
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
name|actual
argument_list|,
name|style
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertEqualString
parameter_list|(
specifier|const
name|char
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
name|actual
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UU32
name|i
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
comment|// if both pointers not null compare the strings
if|if
condition|(
name|expected
operator|&&
name|actual
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|expected
index|[
name|i
index|]
operator|||
name|actual
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|expected
index|[
name|i
index|]
operator|!=
name|actual
index|[
name|i
index|]
condition|)
block|{
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// handle case of one pointers being null (if both null, test should pass)
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrintExpectedAndActualStrings
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertEqualStringArray
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|expected
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|actual
parameter_list|,
specifier|const
name|_UU32
name|num_elements
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|_UU32
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
comment|// if no elements, it's an error
if|if
condition|(
name|num_elements
operator|==
literal|0
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPointless
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
if|if
condition|(
name|UnityCheckArraysForNull
argument_list|(
operator|(
name|UNITY_PTR_ATTRIBUTE
name|void
operator|*
operator|)
name|expected
argument_list|,
operator|(
name|UNITY_PTR_ATTRIBUTE
name|void
operator|*
operator|)
name|actual
argument_list|,
name|lineNumber
argument_list|,
name|msg
argument_list|)
operator|==
literal|1
condition|)
return|return;
do|do
block|{
comment|// if both pointers not null compare the strings
if|if
condition|(
name|expected
index|[
name|j
index|]
operator|&&
name|actual
index|[
name|j
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|expected
index|[
name|j
index|]
index|[
name|i
index|]
operator|||
name|actual
index|[
name|j
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|expected
index|[
name|j
index|]
index|[
name|i
index|]
operator|!=
name|actual
index|[
name|j
index|]
index|[
name|i
index|]
condition|)
block|{
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// handle case of one pointers being null (if both null, test should pass)
if|if
condition|(
name|expected
index|[
name|j
index|]
operator|!=
name|actual
index|[
name|j
index|]
condition|)
block|{
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_elements
operator|>
literal|1
condition|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|j
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
block|}
name|UnityPrintExpectedAndActualStrings
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|expected
index|[
name|j
index|]
operator|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|actual
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|j
operator|<
name|num_elements
condition|)
do|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityAssertEqualMemory
parameter_list|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|expected
parameter_list|,
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
modifier|*
name|actual
parameter_list|,
specifier|const
name|_UU32
name|length
parameter_list|,
specifier|const
name|_UU32
name|num_elements
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|lineNumber
parameter_list|)
block|{
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|unsigned
name|char
modifier|*
name|ptr_exp
init|=
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|expected
decl_stmt|;
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|unsigned
name|char
modifier|*
name|ptr_act
init|=
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|actual
decl_stmt|;
name|_UU32
name|elements
init|=
name|num_elements
decl_stmt|;
name|_UU32
name|bytes
decl_stmt|;
name|UNITY_SKIP_EXECUTION
expr_stmt|;
if|if
condition|(
operator|(
name|elements
operator|==
literal|0
operator|)
operator|||
operator|(
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrPointless
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
if|if
condition|(
name|UnityCheckArraysForNull
argument_list|(
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|expected
argument_list|,
operator|(
name|UNITY_PTR_ATTRIBUTE
specifier|const
name|void
operator|*
operator|)
name|actual
argument_list|,
name|lineNumber
argument_list|,
name|msg
argument_list|)
operator|==
literal|1
condition|)
return|return;
while|while
condition|(
name|elements
operator|--
condition|)
block|{
comment|/////////////////////////////////////
name|bytes
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|bytes
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|ptr_exp
operator|!=
operator|*
name|ptr_act
condition|)
block|{
name|UnityTestResultsFailBegin
argument_list|(
name|lineNumber
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_elements
operator|>
literal|1
condition|)
block|{
name|UnityPrint
argument_list|(
name|UnityStrElement
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|num_elements
operator|-
name|elements
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
block|}
name|UnityPrint
argument_list|(
name|UnityStrByte
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|(
name|length
operator|-
name|bytes
operator|-
literal|1
operator|)
argument_list|,
name|UNITY_DISPLAY_STYLE_UINT
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrExpected
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
name|ptr_exp
argument_list|,
name|UNITY_DISPLAY_STYLE_HEX8
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrWas
argument_list|)
expr_stmt|;
name|UnityPrintNumberByStyle
argument_list|(
operator|*
name|ptr_act
argument_list|,
name|UNITY_DISPLAY_STYLE_HEX8
argument_list|)
expr_stmt|;
name|UnityAddMsgIfSpecified
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
name|ptr_exp
operator|+=
literal|1
expr_stmt|;
name|ptr_act
operator|+=
literal|1
expr_stmt|;
block|}
comment|/////////////////////////////////////
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_comment
comment|// Control Functions
end_comment

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityFail
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|line
parameter_list|)
block|{
name|UNITY_SKIP_EXECUTION
expr_stmt|;
name|UnityTestResultsBegin
argument_list|(
name|Unity
operator|.
name|TestFile
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UnityPrintFail
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|UnityPrint
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|UNITY_FAIL_AND_BAIL
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityIgnore
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|line
parameter_list|)
block|{
name|UNITY_SKIP_EXECUTION
expr_stmt|;
name|UnityTestResultsBegin
argument_list|(
name|Unity
operator|.
name|TestFile
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrIgnore
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|UNITY_IGNORE_AND_BAIL
expr_stmt|;
block|}
end_function

begin_comment
comment|//----------------------------------------------
end_comment

begin_function
name|void
name|UnityExpectFail
parameter_list|()
block|{
name|Unity
operator|.
name|isExpectingFail
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnityExpectFailMessage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|UNITY_LINE_TYPE
name|line
parameter_list|)
block|{
name|Unity
operator|.
name|isExpectingFail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|Unity
operator|.
name|XFAILMessage
operator|=
name|msg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNITY_WEAK_ATTRIBUTE
argument_list|)
end_if

begin_function_decl
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tearDown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|UNITY_WEAK_ATTRIBUTE
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|UNITY_WEAK_ATTRIBUTE
name|void
name|tearDown
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|UNITY_WEAK_PRAGMA
argument_list|)
end_elif

begin_pragma
pragma|#
directive|pragma
name|weak
name|setUp
end_pragma

begin_function_decl
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_pragma
pragma|#
directive|pragma
name|weak
name|tearDown
end_pragma

begin_function_decl
name|void
name|tearDown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|setUp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tearDown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityDefaultTestRun
parameter_list|(
name|UnityTestFunction
name|Func
parameter_list|,
specifier|const
name|char
modifier|*
name|FuncName
parameter_list|,
specifier|const
name|int
name|FuncLineNum
parameter_list|)
block|{
name|Unity
operator|.
name|CurrentTestName
operator|=
name|FuncName
expr_stmt|;
name|Unity
operator|.
name|CurrentTestLineNumber
operator|=
operator|(
name|UNITY_LINE_TYPE
operator|)
name|FuncLineNum
expr_stmt|;
name|Unity
operator|.
name|NumberOfTests
operator|++
expr_stmt|;
if|if
condition|(
name|TEST_PROTECT
argument_list|()
condition|)
block|{
name|setUp
argument_list|()
expr_stmt|;
name|Func
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TEST_PROTECT
argument_list|()
operator|&&
operator|!
operator|(
name|Unity
operator|.
name|CurrentTestIgnored
operator|)
condition|)
block|{
name|tearDown
argument_list|()
expr_stmt|;
block|}
name|UnityConcludeTest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|void
name|UnityBegin
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|Unity
operator|.
name|TestFile
operator|=
name|filename
expr_stmt|;
name|Unity
operator|.
name|CurrentTestName
operator|=
name|NULL
expr_stmt|;
name|Unity
operator|.
name|CurrentTestLineNumber
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|NumberOfTests
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestFailures
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestIgnores
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|CurrentTestIgnored
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestXFAILS
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|isExpectingFail
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestPasses
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestXPASSES
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|XFAILMessage
operator|=
name|NULL
expr_stmt|;
name|UNITY_OUTPUT_START
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

begin_function
name|int
name|UnityEnd
parameter_list|(
name|void
parameter_list|)
block|{
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrBreaker
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|NumberOfTests
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsTests
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|TestPasses
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsPass
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|TestXFAILS
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsXFAIL
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|TestFailures
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsFailures
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|TestXPASSES
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsXPASS
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UnityPrintNumber
argument_list|(
call|(
name|_U_SINT
call|)
argument_list|(
name|Unity
operator|.
name|TestIgnores
argument_list|)
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
name|UnityStrResultsIgnored
argument_list|)
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
name|UNITY_PRINT_EOL
expr_stmt|;
if|if
condition|(
name|Unity
operator|.
name|TestFailures
operator|==
literal|0U
operator|&&
name|Unity
operator|.
name|TestXPASSES
operator|==
literal|0U
condition|)
block|{
name|UnityPrintOk
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UnityPrintFail
argument_list|()
expr_stmt|;
block|}
name|UNITY_PRINT_EOL
expr_stmt|;
name|UNITY_OUTPUT_COMPLETE
argument_list|()
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|Unity
operator|.
name|TestFailures
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//-----------------------------------------------
end_comment

end_unit

