begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//- Copyright (c) 2010 James Grenning and Contributed to Unity Project
end_comment

begin_comment
comment|/* ==========================================     Unity Project - A Test Framework for C     Copyright (c) 2007 Mike Karlesky, Mark VanderVoord, Greg Williams     [Released under MIT License. Please refer to license.txt for details] ========================================== */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"unity_fixture.h"
end_include

begin_include
include|#
directive|include
file|"unity_internals.h"
end_include

begin_decl_stmt
name|UNITY_FIXTURE_T
name|UnityFixture
decl_stmt|;
end_decl_stmt

begin_comment
comment|//If you decide to use the function pointer approach.
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|outputChar
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|putchar
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|announceTestRun
parameter_list|(
name|unsigned
name|int
name|runNumber
parameter_list|)
block|{
name|UnityPrint
argument_list|(
literal|"Unity test run "
argument_list|)
expr_stmt|;
name|UnityPrintNumber
argument_list|(
name|runNumber
operator|+
literal|1
argument_list|)
expr_stmt|;
name|UnityPrint
argument_list|(
literal|" of "
argument_list|)
expr_stmt|;
name|UnityPrintNumber
argument_list|(
name|UnityFixture
operator|.
name|RepeatCount
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|UnityMain
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|void
function_decl|(
modifier|*
name|runAllTests
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|int
name|result
init|=
name|UnityGetCommandLineOptions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|UnityFixture
operator|.
name|RepeatCount
condition|;
name|r
operator|++
control|)
block|{
name|UnityBegin
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|announceTestRun
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|runAllTests
argument_list|()
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|UnityEnd
argument_list|()
expr_stmt|;
block|}
return|return
name|UnityFailureCount
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|selected
parameter_list|(
specifier|const
name|char
modifier|*
name|filter
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|strstr
argument_list|(
name|name
argument_list|,
name|filter
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|testSelected
parameter_list|(
specifier|const
name|char
modifier|*
name|test
parameter_list|)
block|{
return|return
name|selected
argument_list|(
name|UnityFixture
operator|.
name|NameFilter
argument_list|,
name|test
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|groupSelected
parameter_list|(
specifier|const
name|char
modifier|*
name|group
parameter_list|)
block|{
return|return
name|selected
argument_list|(
name|UnityFixture
operator|.
name|GroupFilter
argument_list|,
name|group
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|runTestCase
parameter_list|(
name|void
parameter_list|)
block|{  }
end_function

begin_function
name|void
name|UnityTestRunner
parameter_list|(
name|unityfunction
modifier|*
name|setup
parameter_list|,
name|unityfunction
modifier|*
name|testBody
parameter_list|,
name|unityfunction
modifier|*
name|teardown
parameter_list|,
specifier|const
name|char
modifier|*
name|printableName
parameter_list|,
specifier|const
name|char
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|testSelected
argument_list|(
name|name
argument_list|)
operator|&&
name|groupSelected
argument_list|(
name|group
argument_list|)
condition|)
block|{
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|TestFile
operator|=
name|file
expr_stmt|;
name|Unity
operator|.
name|CurrentTestName
operator|=
name|printableName
expr_stmt|;
name|Unity
operator|.
name|CurrentTestLineNumber
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|UnityFixture
operator|.
name|Verbose
condition|)
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
else|else
name|UnityPrint
argument_list|(
name|printableName
argument_list|)
expr_stmt|;
name|Unity
operator|.
name|NumberOfTests
operator|++
expr_stmt|;
name|UnityMalloc_StartTest
argument_list|()
expr_stmt|;
name|UnityPointer_Init
argument_list|()
expr_stmt|;
name|runTestCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|TEST_PROTECT
argument_list|()
condition|)
block|{
name|setup
argument_list|()
expr_stmt|;
name|testBody
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TEST_PROTECT
argument_list|()
condition|)
block|{
name|teardown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TEST_PROTECT
argument_list|()
condition|)
block|{
name|UnityPointer_UndoAllSets
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Unity
operator|.
name|CurrentTestFailed
condition|)
name|UnityMalloc_EndTest
argument_list|()
expr_stmt|;
block|}
name|UnityConcludeFixtureTest
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|UnityIgnoreTest
parameter_list|(
specifier|const
name|char
modifier|*
name|printableName
parameter_list|)
block|{
name|Unity
operator|.
name|NumberOfTests
operator|++
expr_stmt|;
name|Unity
operator|.
name|CurrentTestIgnored
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|UnityFixture
operator|.
name|Verbose
condition|)
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
else|else
name|UnityPrint
argument_list|(
name|printableName
argument_list|)
expr_stmt|;
name|UnityConcludeFixtureTest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|//-------------------------------------------------
end_comment

begin_comment
comment|//Malloc and free stuff
end_comment

begin_comment
comment|//
end_comment

begin_define
define|#
directive|define
name|MALLOC_DONT_FAIL
value|-1
end_define

begin_decl_stmt
specifier|static
name|int
name|malloc_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|malloc_fail_countdown
init|=
name|MALLOC_DONT_FAIL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|UnityMalloc_StartTest
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_count
operator|=
literal|0
expr_stmt|;
name|malloc_fail_countdown
operator|=
name|MALLOC_DONT_FAIL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnityMalloc_EndTest
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_fail_countdown
operator|=
name|MALLOC_DONT_FAIL
expr_stmt|;
if|if
condition|(
name|malloc_count
operator|!=
literal|0
condition|)
block|{
name|TEST_FAIL_MESSAGE
argument_list|(
literal|"This test leaks!"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|UnityMalloc_MakeMallocFailAfterCount
parameter_list|(
name|int
name|countdown
parameter_list|)
block|{
name|malloc_fail_countdown
operator|=
name|countdown
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|malloc
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|free
end_ifdef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|calloc
end_ifdef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|realloc
end_ifdef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|GuardBytes
block|{
name|size_t
name|size
decl_stmt|;
name|char
name|guard
index|[
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
index|]
decl_stmt|;
block|}
name|Guard
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|end
init|=
literal|"END"
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|unity_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|mem
decl_stmt|;
name|Guard
modifier|*
name|guard
decl_stmt|;
if|if
condition|(
name|malloc_fail_countdown
operator|!=
name|MALLOC_DONT_FAIL
condition|)
block|{
if|if
condition|(
name|malloc_fail_countdown
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|malloc_fail_countdown
operator|--
expr_stmt|;
block|}
name|malloc_count
operator|++
expr_stmt|;
name|guard
operator|=
operator|(
name|Guard
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|Guard
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|guard
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|mem
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|guard
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mem
index|[
name|size
index|]
argument_list|,
name|end
argument_list|,
name|strlen
argument_list|(
name|end
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|mem
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isOverrun
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|Guard
modifier|*
name|guard
init|=
operator|(
name|Guard
operator|*
operator|)
name|mem
decl_stmt|;
name|char
modifier|*
name|memAsChar
init|=
operator|(
name|char
operator|*
operator|)
name|mem
decl_stmt|;
name|guard
operator|--
expr_stmt|;
return|return
name|strcmp
argument_list|(
operator|&
name|memAsChar
index|[
name|guard
operator|->
name|size
index|]
argument_list|,
name|end
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_memory
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|Guard
modifier|*
name|guard
init|=
operator|(
name|Guard
operator|*
operator|)
name|mem
decl_stmt|;
name|guard
operator|--
expr_stmt|;
name|malloc_count
operator|--
expr_stmt|;
name|free
argument_list|(
name|guard
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unity_free
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|overrun
init|=
name|isOverrun
argument_list|(
name|mem
argument_list|)
decl_stmt|;
comment|//strcmp(&memAsChar[guard->size], end) != 0;
name|release_memory
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|overrun
condition|)
block|{
name|TEST_FAIL_MESSAGE
argument_list|(
literal|"Buffer overrun detected during free()"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|unity_calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|mem
init|=
name|unity_malloc
argument_list|(
name|num
operator|*
name|size
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|unity_realloc
parameter_list|(
name|void
modifier|*
name|oldMem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|Guard
modifier|*
name|guard
init|=
operator|(
name|Guard
operator|*
operator|)
name|oldMem
decl_stmt|;
comment|//    char* memAsChar = (char*)oldMem;
name|void
modifier|*
name|newMem
decl_stmt|;
if|if
condition|(
name|oldMem
operator|==
literal|0
condition|)
return|return
name|unity_malloc
argument_list|(
name|size
argument_list|)
return|;
name|guard
operator|--
expr_stmt|;
if|if
condition|(
name|isOverrun
argument_list|(
name|oldMem
argument_list|)
condition|)
block|{
name|release_memory
argument_list|(
name|oldMem
argument_list|)
expr_stmt|;
name|TEST_FAIL_MESSAGE
argument_list|(
literal|"Buffer overrun detected during realloc()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|release_memory
argument_list|(
name|oldMem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|guard
operator|->
name|size
operator|>=
name|size
condition|)
return|return
name|oldMem
return|;
name|newMem
operator|=
name|unity_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newMem
argument_list|,
name|oldMem
argument_list|,
name|guard
operator|->
name|size
argument_list|)
expr_stmt|;
name|unity_free
argument_list|(
name|oldMem
argument_list|)
expr_stmt|;
return|return
name|newMem
return|;
block|}
end_function

begin_comment
comment|//--------------------------------------------------------
end_comment

begin_comment
comment|//Automatic pointer restoration functions
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_PointerPair
block|{
name|struct
name|_PointerPair
modifier|*
name|next
decl_stmt|;
name|void
modifier|*
modifier|*
name|pointer
decl_stmt|;
name|void
modifier|*
name|old_value
decl_stmt|;
block|}
name|PointerPair
typedef|;
end_typedef

begin_enum
enum|enum
block|{
name|MAX_POINTERS
init|=
literal|50
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|PointerPair
name|pointer_store
index|[
name|MAX_POINTERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pointer_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|UnityPointer_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|pointer_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnityPointer_Set
parameter_list|(
name|void
modifier|*
modifier|*
name|pointer
parameter_list|,
name|void
modifier|*
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|pointer_index
operator|>=
name|MAX_POINTERS
condition|)
name|TEST_FAIL_MESSAGE
argument_list|(
literal|"Too many pointers set"
argument_list|)
expr_stmt|;
name|pointer_store
index|[
name|pointer_index
index|]
operator|.
name|pointer
operator|=
name|pointer
expr_stmt|;
name|pointer_store
index|[
name|pointer_index
index|]
operator|.
name|old_value
operator|=
operator|*
name|pointer
expr_stmt|;
operator|*
name|pointer
operator|=
name|newValue
expr_stmt|;
name|pointer_index
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|UnityPointer_UndoAllSets
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|pointer_index
operator|>
literal|0
condition|)
block|{
name|pointer_index
operator|--
expr_stmt|;
operator|*
operator|(
name|pointer_store
index|[
name|pointer_index
index|]
operator|.
name|pointer
operator|)
operator|=
name|pointer_store
index|[
name|pointer_index
index|]
operator|.
name|old_value
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|UnityFailureCount
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|Unity
operator|.
name|TestFailures
return|;
block|}
end_function

begin_function
name|int
name|UnityGetCommandLineOptions
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|UnityFixture
operator|.
name|Verbose
operator|=
literal|0
expr_stmt|;
name|UnityFixture
operator|.
name|GroupFilter
operator|=
literal|0
expr_stmt|;
name|UnityFixture
operator|.
name|NameFilter
operator|=
literal|0
expr_stmt|;
name|UnityFixture
operator|.
name|RepeatCount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|UnityFixture
operator|.
name|Verbose
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-g"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
return|return
literal|1
return|;
name|UnityFixture
operator|.
name|GroupFilter
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
return|return
literal|1
return|;
name|UnityFixture
operator|.
name|NameFilter
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|UnityFixture
operator|.
name|RepeatCount
operator|=
literal|2
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|argc
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|)
operator|>=
literal|'0'
operator|&&
operator|*
operator|(
name|argv
index|[
name|i
index|]
operator|)
operator|<=
literal|'9'
condition|)
block|{
name|UnityFixture
operator|.
name|RepeatCount
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// ignore unknown parameter
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|UnityConcludeFixtureTest
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|Unity
operator|.
name|CurrentTestIgnored
condition|)
block|{
if|if
condition|(
name|UnityFixture
operator|.
name|Verbose
condition|)
block|{
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|Unity
operator|.
name|TestIgnores
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
if|if
condition|(
name|UnityFixture
operator|.
name|Verbose
condition|)
block|{
name|UnityPrint
argument_list|(
literal|" PASS"
argument_list|)
expr_stmt|;
name|UNITY_OUTPUT_CHAR
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Unity
operator|.
name|CurrentTestFailed
condition|)
block|{
name|Unity
operator|.
name|TestFailures
operator|++
expr_stmt|;
block|}
name|Unity
operator|.
name|CurrentTestFailed
operator|=
literal|0
expr_stmt|;
name|Unity
operator|.
name|CurrentTestIgnored
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

