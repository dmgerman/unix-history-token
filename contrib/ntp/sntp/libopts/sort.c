begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * \file sort.c  *  *  This module implements argument sorting.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|tSuccess
name|must_arg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|maybe_arg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|short_opt_ck
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  "must_arg" and "maybe_arg" are really similar.  The biggest  *  difference is that "may" will consume the next argument only if it  *  does not start with a hyphen and "must" will consume it, hyphen or not.  */
end_comment

begin_function
specifier|static
name|tSuccess
name|must_arg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
block|{
comment|/*      *  An option argument is required.  Long options can either have      *  a separate command line argument, or an argument attached by      *  the '=' character.  Figure out which.      */
switch|switch
condition|(
name|pOS
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  See if an arg string follows the flag character.  If not,          *  the next arg must be the option argument.          */
if|if
condition|(
operator|*
name|arg_txt
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  See if an arg string has already been assigned (glued on          *  with an `=' character).  If not, the next is the opt arg.          */
if|if
condition|(
name|pOS
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
return|return
name|SUCCESS
return|;
break|break;
default|default:
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>=
name|opts
operator|->
name|origArgCt
condition|)
return|return
name|FAILURE
return|;
name|opt_txt
index|[
operator|(
operator|*
name|opt_idx
operator|)
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|tSuccess
name|maybe_arg
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
block|{
comment|/*      *  An option argument is optional.      */
switch|switch
condition|(
name|pOS
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  IF nothing is glued on after the current flag character,          *  THEN see if there is another argument.  If so and if it          *  does *NOT* start with a hyphen, then it is the option arg.          */
if|if
condition|(
operator|*
name|arg_txt
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  Look for an argument if we don't already have one (glued on          *  with a `=' character)          */
if|if
condition|(
name|pOS
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
return|return
name|SUCCESS
return|;
break|break;
default|default:
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>=
name|opts
operator|->
name|origArgCt
condition|)
return|return
name|PROBLEM
return|;
name|arg_txt
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg_txt
operator|!=
literal|'-'
condition|)
name|opt_txt
index|[
operator|(
operator|*
name|opt_idx
operator|)
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  Process a string of short options glued together.  If the last one  *  does or may take an argument, the do the argument processing and leave.  */
end_comment

begin_function
specifier|static
name|tSuccess
name|short_opt_ck
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
modifier|*
name|arg_txt
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|opt_txt
parameter_list|,
name|uint32_t
modifier|*
name|opt_idx
parameter_list|)
block|{
while|while
condition|(
operator|*
name|arg_txt
operator|!=
name|NUL
condition|)
block|{
if|if
condition|(
name|FAILED
argument_list|(
name|opt_find_short
argument_list|(
name|opts
argument_list|,
operator|(
name|uint8_t
operator|)
operator|*
name|arg_txt
argument_list|,
name|pOS
argument_list|)
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/*          *  See if we can have an arg.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
name|arg_txt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
comment|/*              *  Take an argument if it is not attached and it does not              *  start with a hyphen.              */
if|if
condition|(
name|arg_txt
index|[
literal|1
index|]
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
name|arg_txt
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg_txt
operator|!=
literal|'-'
condition|)
name|opt_txt
index|[
operator|(
operator|*
name|opt_idx
operator|)
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
comment|/*              *  IF we need another argument, be sure it is there and              *  take it.              */
if|if
condition|(
name|arg_txt
index|[
literal|1
index|]
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>=
name|opts
operator|->
name|origArgCt
condition|)
return|return
name|FAILURE
return|;
name|opt_txt
index|[
operator|(
operator|*
name|opt_idx
operator|)
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  If the program wants sorted options (separated operands and options),  *  then this routine will to the trick.  */
end_comment

begin_function
name|LOCAL
name|void
name|optionSort
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|opt_txt
decl_stmt|;
name|char
modifier|*
modifier|*
name|ppzOpds
decl_stmt|;
name|uint32_t
name|optsIdx
init|=
literal|0
decl_stmt|;
name|uint32_t
name|opdsIdx
init|=
literal|0
decl_stmt|;
name|tOptState
name|os
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
comment|/*      *  Disable for POSIX conformance, or if there are no operands.      */
if|if
condition|(
operator|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
name|NAMED_OPTS
argument_list|(
name|opts
argument_list|)
condition|)
return|return;
comment|/*      *  Make sure we can allocate two full-sized arg vectors.      */
name|opt_txt
operator|=
name|malloc
argument_list|(
name|opts
operator|->
name|origArgCt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_txt
operator|==
name|NULL
condition|)
goto|goto
name|exit_no_mem
goto|;
name|ppzOpds
operator|=
name|malloc
argument_list|(
name|opts
operator|->
name|origArgCt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppzOpds
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|opt_txt
argument_list|)
expr_stmt|;
goto|goto
name|exit_no_mem
goto|;
block|}
name|opts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/*      *  Now, process all the options from our current position onward.      *  (This allows interspersed options and arguments for the few      *  non-standard programs that require it.)      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|arg_txt
decl_stmt|;
name|tSuccess
name|res
decl_stmt|;
comment|/*          *  If we're out of arguments, we're done.  Join the option and          *  operand lists into the original argument vector.          */
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|>=
name|opts
operator|->
name|origArgCt
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|joinLists
goto|;
block|}
name|arg_txt
operator|=
name|opts
operator|->
name|origArgVect
index|[
name|opts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg_txt
operator|!=
literal|'-'
condition|)
block|{
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|arg_txt
index|[
literal|1
index|]
condition|)
block|{
case|case
name|NUL
case|:
comment|/*              *  A single hyphen is an operand.              */
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
comment|/*              *  Two consecutive hypens.  Put them on the options list and then              *  _always_ force the remainder of the arguments to be operands.              */
if|if
condition|(
name|arg_txt
index|[
literal|2
index|]
operator|==
name|NUL
condition|)
block|{
name|opt_txt
index|[
name|optsIdx
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
goto|goto
name|restOperands
goto|;
block|}
name|res
operator|=
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|arg_txt
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*              *  If short options are not allowed, then do long              *  option processing.  Otherwise the character must be a              *  short (i.e. single character) option.              */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|opt_find_long
argument_list|(
name|opts
argument_list|,
name|arg_txt
operator|+
literal|1
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|opt_find_short
argument_list|(
name|opts
argument_list|,
operator|(
name|uint8_t
operator|)
name|arg_txt
index|[
literal|1
index|]
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
comment|/*          *  We've found an option.  Add the argument to the option list.          *  Next, we have to see if we need to pull another argument to be          *  used as the option argument.          */
name|opt_txt
index|[
name|optsIdx
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|os
operator|.
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
comment|/*              *  No option argument.  If we have a short option here,              *  then scan for short options until we get to the end              *  of the argument string.              */
if|if
condition|(
operator|(
name|os
operator|.
name|optType
operator|==
name|TOPT_SHORT
operator|)
operator|&&
name|FAILED
argument_list|(
name|short_opt_ck
argument_list|(
name|opts
argument_list|,
name|arg_txt
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|opt_txt
argument_list|,
operator|&
name|optsIdx
argument_list|)
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|os
operator|.
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
switch|switch
condition|(
name|maybe_arg
argument_list|(
name|opts
argument_list|,
name|arg_txt
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|opt_txt
argument_list|,
operator|&
name|optsIdx
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
goto|goto
name|freeTemps
goto|;
case|case
name|PROBLEM
case|:
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|joinLists
goto|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|must_arg
argument_list|(
name|opts
argument_list|,
name|arg_txt
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|opt_txt
argument_list|,
operator|&
name|optsIdx
argument_list|)
condition|)
block|{
case|case
name|PROBLEM
case|:
case|case
name|FAILURE
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
block|}
block|}
comment|/* for (;;) */
name|restOperands
label|:
while|while
condition|(
name|opts
operator|->
name|curOptIdx
operator|<
name|opts
operator|->
name|origArgCt
condition|)
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|opts
operator|->
name|origArgVect
index|[
operator|(
name|opts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
name|joinLists
label|:
if|if
condition|(
name|optsIdx
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|opts
operator|->
name|origArgVect
operator|+
literal|1
argument_list|,
name|opt_txt
argument_list|,
operator|(
name|size_t
operator|)
name|optsIdx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdsIdx
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|opts
operator|->
name|origArgVect
operator|+
literal|1
operator|+
name|optsIdx
argument_list|,
name|ppzOpds
argument_list|,
operator|(
name|size_t
operator|)
name|opdsIdx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|freeTemps
label|:
name|free
argument_list|(
name|opt_txt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppzOpds
argument_list|)
expr_stmt|;
return|return;
name|exit_no_mem
label|:
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/sort.c */
end_comment

end_unit

