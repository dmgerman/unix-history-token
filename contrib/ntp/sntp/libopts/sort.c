begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  sort.c  $Id: sort.c,v 4.10 2007/04/28 22:19:23 bkorb Exp $  * Time-stamp:      "2006-10-18 11:29:04 bkorb"  *  *  This module implements argument sorting.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|tSuccess
name|mustHandleArg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|mayHandleArg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tSuccess
name|checkShortOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  "mustHandleArg" and "mayHandleArg" are really similar.  The biggest  *  difference is that "may" will consume the next argument only if it  *  does not start with a hyphen and "must" will consume it, hyphen or not.  */
end_comment

begin_function
specifier|static
name|tSuccess
name|mustHandleArg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
block|{
comment|/*      *  An option argument is required.  Long options can either have      *  a separate command line argument, or an argument attached by      *  the '=' character.  Figure out which.      */
switch|switch
condition|(
name|pOS
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  See if an arg string follows the flag character.  If not,          *  the next arg must be the option argument.          */
if|if
condition|(
operator|*
name|pzArg
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  See if an arg string has already been assigned (glued on          *  with an `=' character).  If not, the next is the opt arg.          */
if|if
condition|(
name|pOS
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
return|return
name|SUCCESS
return|;
break|break;
default|default:
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
return|return
name|FAILURE
return|;
name|ppzOpts
index|[
operator|(
operator|*
name|pOptsIdx
operator|)
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|tSuccess
name|mayHandleArg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
block|{
comment|/*      *  An option argument is optional.      */
switch|switch
condition|(
name|pOS
operator|->
name|optType
condition|)
block|{
case|case
name|TOPT_SHORT
case|:
comment|/*          *  IF nothing is glued on after the current flag character,          *  THEN see if there is another argument.  If so and if it          *  does *NOT* start with a hyphen, then it is the option arg.          */
if|if
condition|(
operator|*
name|pzArg
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
break|break;
case|case
name|TOPT_LONG
case|:
comment|/*          *  Look for an argument if we don't already have one (glued on          *  with a `=' character)          */
if|if
condition|(
name|pOS
operator|->
name|pzOptArg
operator|!=
name|NULL
condition|)
return|return
name|SUCCESS
return|;
break|break;
default|default:
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
return|return
name|PROBLEM
return|;
name|pzArg
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pzArg
operator|!=
literal|'-'
condition|)
name|ppzOpts
index|[
operator|(
operator|*
name|pOptsIdx
operator|)
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  Process a string of short options glued together.  If the last one  *  does or may take an argument, the do the argument processing and leave.  */
end_comment

begin_function
specifier|static
name|tSuccess
name|checkShortOpts
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|char
modifier|*
name|pzArg
parameter_list|,
name|tOptState
modifier|*
name|pOS
parameter_list|,
name|char
modifier|*
modifier|*
name|ppzOpts
parameter_list|,
name|int
modifier|*
name|pOptsIdx
parameter_list|)
block|{
while|while
condition|(
operator|*
name|pzArg
operator|!=
name|NUL
condition|)
block|{
if|if
condition|(
name|FAILED
argument_list|(
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
operator|*
name|pzArg
argument_list|,
name|pOS
argument_list|)
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/*          *  See if we can have an arg.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
name|pzArg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pOS
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
comment|/*              *  Take an argument if it is not attached and it does not              *  start with a hyphen.              */
if|if
condition|(
name|pzArg
index|[
literal|1
index|]
operator|!=
name|NUL
condition|)
return|return
name|SUCCESS
return|;
name|pzArg
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pzArg
operator|!=
literal|'-'
condition|)
name|ppzOpts
index|[
operator|(
operator|*
name|pOptsIdx
operator|)
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
block|{
comment|/*              *  IF we need another argument, be sure it is there and              *  take it.              */
if|if
condition|(
name|pzArg
index|[
literal|1
index|]
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
return|return
name|FAILURE
return|;
name|ppzOpts
index|[
operator|(
operator|*
name|pOptsIdx
operator|)
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  If the program wants sorted options (separated operands and options),  *  then this routine will to the trick.  */
end_comment

begin_function
name|LOCAL
name|void
name|optionSort
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ppzOpts
decl_stmt|;
name|char
modifier|*
modifier|*
name|ppzOpds
decl_stmt|;
name|int
name|optsIdx
init|=
literal|0
decl_stmt|;
name|int
name|opdsIdx
init|=
literal|0
decl_stmt|;
name|tOptState
name|os
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
comment|/*      *  Disable for POSIX conformance, or if there are no operands.      */
if|if
condition|(
operator|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
name|NAMED_OPTS
argument_list|(
name|pOpts
argument_list|)
condition|)
return|return;
comment|/*      *  Make sure we can allocate two full-sized arg vectors.      */
name|ppzOpts
operator|=
name|malloc
argument_list|(
name|pOpts
operator|->
name|origArgCt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppzOpts
operator|==
name|NULL
condition|)
goto|goto
name|exit_no_mem
goto|;
name|ppzOpds
operator|=
name|malloc
argument_list|(
name|pOpts
operator|->
name|origArgCt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppzOpds
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ppzOpts
argument_list|)
expr_stmt|;
goto|goto
name|exit_no_mem
goto|;
block|}
name|pOpts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|pOpts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/*      *  Now, process all the options from our current position onward.      *  (This allows interspersed options and arguments for the few      *  non-standard programs that require it.)      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|pzArg
decl_stmt|;
name|tSuccess
name|res
decl_stmt|;
comment|/*          *  If we're out of arguments, we're done.  Join the option and          *  operand lists into the original argument vector.          */
if|if
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|>=
name|pOpts
operator|->
name|origArgCt
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|joinLists
goto|;
block|}
name|pzArg
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
name|pOpts
operator|->
name|curOptIdx
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|pzArg
operator|!=
literal|'-'
condition|)
block|{
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|pzArg
index|[
literal|1
index|]
condition|)
block|{
case|case
name|NUL
case|:
comment|/*              *  A single hyphen is an operand.              */
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
comment|/*              *  Two consecutive hypens.  Put them on the options list and then              *  _always_ force the remainder of the arguments to be operands.              */
if|if
condition|(
name|pzArg
index|[
literal|2
index|]
operator|==
name|NUL
condition|)
block|{
name|ppzOpts
index|[
name|optsIdx
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
goto|goto
name|restOperands
goto|;
block|}
name|res
operator|=
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pzArg
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*              *  If short options are not allowed, then do long              *  option processing.  Otherwise the character must be a              *  short (i.e. single character) option.              */
if|if
condition|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHORTOPT
operator|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|longOptionFind
argument_list|(
name|pOpts
argument_list|,
name|pzArg
operator|+
literal|1
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|shortOptionFind
argument_list|(
name|pOpts
argument_list|,
operator|(
name|tAoUC
operator|)
name|pzArg
index|[
literal|1
index|]
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|FAILED
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
comment|/*          *  We've found an option.  Add the argument to the option list.          *  Next, we have to see if we need to pull another argument to be          *  used as the option argument.          */
name|ppzOpts
index|[
name|optsIdx
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|os
operator|.
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NONE
condition|)
block|{
comment|/*              *  No option argument.  If we have a short option here,              *  then scan for short options until we get to the end              *  of the argument string.              */
if|if
condition|(
operator|(
name|os
operator|.
name|optType
operator|==
name|TOPT_SHORT
operator|)
operator|&&
name|FAILED
argument_list|(
name|checkShortOpts
argument_list|(
name|pOpts
argument_list|,
name|pzArg
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|ppzOpts
argument_list|,
operator|&
name|optsIdx
argument_list|)
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|os
operator|.
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ARG_OPTIONAL
condition|)
block|{
switch|switch
condition|(
name|mayHandleArg
argument_list|(
name|pOpts
argument_list|,
name|pzArg
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|ppzOpts
argument_list|,
operator|&
name|optsIdx
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
goto|goto
name|freeTemps
goto|;
case|case
name|PROBLEM
case|:
name|errno
operator|=
literal|0
expr_stmt|;
goto|goto
name|joinLists
goto|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|mustHandleArg
argument_list|(
name|pOpts
argument_list|,
name|pzArg
operator|+
literal|2
argument_list|,
operator|&
name|os
argument_list|,
name|ppzOpts
argument_list|,
operator|&
name|optsIdx
argument_list|)
condition|)
block|{
case|case
name|PROBLEM
case|:
case|case
name|FAILURE
case|:
name|errno
operator|=
name|EIO
expr_stmt|;
goto|goto
name|freeTemps
goto|;
block|}
block|}
block|}
comment|/* for (;;) */
name|restOperands
label|:
while|while
condition|(
name|pOpts
operator|->
name|curOptIdx
operator|<
name|pOpts
operator|->
name|origArgCt
condition|)
name|ppzOpds
index|[
name|opdsIdx
operator|++
index|]
operator|=
name|pOpts
operator|->
name|origArgVect
index|[
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|)
operator|++
index|]
expr_stmt|;
name|joinLists
label|:
if|if
condition|(
name|optsIdx
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|pOpts
operator|->
name|origArgVect
operator|+
literal|1
argument_list|,
name|ppzOpts
argument_list|,
name|optsIdx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdsIdx
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
name|pOpts
operator|->
name|origArgVect
operator|+
literal|1
operator|+
name|optsIdx
argument_list|,
name|ppzOpds
argument_list|,
name|opdsIdx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|freeTemps
label|:
name|free
argument_list|(
name|ppzOpts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppzOpds
argument_list|)
expr_stmt|;
return|return;
name|exit_no_mem
label|:
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/sort.c */
end_comment

end_unit

