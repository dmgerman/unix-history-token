begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file putshell.c  *  *  This module will interpret the options set in the tOptions  *  structure and print them to standard out in a fashion that  *  will allow them to be interpreted by the Bourne or Korn shells.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|size_t
name|string_size
parameter_list|(
name|char
specifier|const
modifier|*
name|scan
parameter_list|,
name|size_t
name|nl_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|print_quoted_apostrophes
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_quot_str
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_enumeration
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_membership
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_stacked_arg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_reordering
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/**  * Count the number of bytes required to represent a string as a  * compilable string.  *  * @param[in] scan    the text to be rewritten as a C program text string.  * @param[in] nl_len  the number of bytes used for each embedded newline.  *  * @returns the count, including the terminating NUL byte.  */
end_comment

begin_function
specifier|static
name|size_t
name|string_size
parameter_list|(
name|char
specifier|const
modifier|*
name|scan
parameter_list|,
name|size_t
name|nl_len
parameter_list|)
block|{
comment|/*      *  Start by counting the start and end quotes, plus the NUL.      */
name|size_t
name|res_ln
init|=
literal|3
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|scan
operator|++
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|' '
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'~'
operator|)
condition|)
block|{
comment|/*              * a backslash allowance for double quotes and baskslashes              */
name|res_ln
operator|+=
operator|(
operator|(
name|ch
operator|==
literal|'"'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\\'
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
comment|/*          *  When not a normal character, then count the characters          *  required to represent whatever it is.          */
else|else
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|res_ln
return|;
case|case
name|NL
case|:
name|res_ln
operator|+=
name|nl_len
expr_stmt|;
break|break;
case|case
name|HT
case|:
case|case
name|BEL
case|:
case|case
name|BS
case|:
case|case
name|FF
case|:
case|case
name|CR
case|:
case|case
name|VT
case|:
name|res_ln
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|res_ln
operator|+=
literal|4
expr_stmt|;
comment|/* text len for \xNN */
block|}
block|}
block|}
end_function

begin_comment
comment|/*=export_func  optionQuoteString  * private:  *  * what:  Print a string as quoted text suitable for a C compiler.  * arg:   + char const * + text  + a block of text to quote +  * arg:   + char const * + nl    + line splice text         +  *  * ret_type:  char const *  * ret_desc:  the allocated input string as a quoted string  *  * doc:  *  This is for internal use by autogen and autoopts.  *  It takes an input string and produces text the C compiler can process  *  to produce an exact copy of the original string.  *  The caller must deallocate the result.  Standard C strings and  *  K&R strings are distinguished by the "nl" string. =*/
end_comment

begin_function
name|char
specifier|const
modifier|*
name|optionQuoteString
parameter_list|(
name|char
specifier|const
modifier|*
name|text
parameter_list|,
name|char
specifier|const
modifier|*
name|nl
parameter_list|)
block|{
name|size_t
name|nl_len
init|=
name|strlen
argument_list|(
name|nl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|res
init|=
name|out
operator|=
name|AGALOC
argument_list|(
name|string_size
argument_list|(
name|text
argument_list|,
name|nl_len
argument_list|)
argument_list|,
literal|"quot str"
argument_list|)
decl_stmt|;
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|ch
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|text
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|' '
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'~'
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'"'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\\'
operator|)
condition|)
comment|/*                  *  We must escape these characters in the output string                  */
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
literal|'\\'
expr_stmt|;
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|ch
condition|)
block|{
define|#
directive|define
name|add_esc_ch
parameter_list|(
name|_ch
parameter_list|)
value|{ *(out++) = '\\'; *(out++) = (_ch); }
case|case
name|BEL
case|:
name|add_esc_ch
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS
case|:
name|add_esc_ch
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
break|break;
case|case
name|HT
case|:
name|add_esc_ch
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
break|break;
case|case
name|VT
case|:
name|add_esc_ch
argument_list|(
literal|'v'
argument_list|)
expr_stmt|;
break|break;
case|case
name|FF
case|:
name|add_esc_ch
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CR
case|:
name|add_esc_ch
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF
case|:
comment|/*              *  Place contiguous new-lines on a single line.              *  The current character is a NL, check the next one.              */
while|while
condition|(
operator|*
operator|++
name|text
operator|==
name|NL
condition|)
name|add_esc_ch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
comment|/*              *  Insert a splice before starting next line              */
if|if
condition|(
operator|*
name|text
operator|!=
name|NUL
condition|)
block|{
name|memcpy
argument_list|(
name|out
argument_list|,
name|nl
argument_list|,
name|nl_len
argument_list|)
expr_stmt|;
name|out
operator|+=
name|nl_len
expr_stmt|;
continue|continue;
comment|/* text is already at the next character */
block|}
name|add_esc_ch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|NUL
case|:
comment|/*              *  End of string.  Terminate the quoted output.  If necessary,              *  deallocate the text string.  Return the scan resumption point.              */
operator|*
operator|(
name|out
operator|++
operator|)
operator|=
literal|'"'
expr_stmt|;
operator|*
name|out
operator|=
name|NUL
expr_stmt|;
return|return
name|res
return|;
default|default:
comment|/*              *  sprintf is safe here, because we already computed              *  the amount of space we will be using.              */
name|sprintf
argument_list|(
name|out
argument_list|,
name|MK_STR_OCT_FMT
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|4
expr_stmt|;
block|}
name|text
operator|++
expr_stmt|;
undef|#
directive|undef
name|add_esc_ch
block|}
block|}
end_function

begin_comment
comment|/**  *  Print out escaped apostorophes.  *  *  @param[in] str  the apostrophies to print  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|print_quoted_apostrophes
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|==
name|APOSTROPHE
condition|)
block|{
name|fputs
argument_list|(
name|QUOT_APOS
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/**  *  Print a single quote (apostrophe quoted) string.  *  Other than somersaults for apostrophes, nothing else needs quoting.  *  *  @param[in] str  the string to print  */
end_comment

begin_function
specifier|static
name|void
name|print_quot_str
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
block|{
comment|/*      *  Handle empty strings to make the rest of the logic simpler.      */
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
name|NUL
operator|)
condition|)
block|{
name|fputs
argument_list|(
name|EMPTY_ARG
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  Emit any single quotes/apostrophes at the start of the string and      *  bail if that is all we need to do.      */
name|str
operator|=
name|print_quoted_apostrophes
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NUL
condition|)
return|return;
comment|/*      *  Start the single quote string      */
name|fputc
argument_list|(
name|APOSTROPHE
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
specifier|const
modifier|*
name|pz
init|=
name|strchr
argument_list|(
name|str
argument_list|,
name|APOSTROPHE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
break|break;
comment|/*          *  Emit the string up to the single quote (apostrophe) we just found.          */
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|str
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pz
operator|-
name|str
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/*          * Close the current string, emit the apostrophes and re-open the          * string (IFF there is more text to print).          */
name|fputc
argument_list|(
name|APOSTROPHE
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|str
operator|=
name|print_quoted_apostrophes
argument_list|(
name|pz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
name|NUL
condition|)
return|return;
name|fputc
argument_list|(
name|APOSTROPHE
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*      *  If we broke out of the loop, we must still emit the remaining text      *  and then close the single quote string.      */
name|fputs
argument_list|(
name|str
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|APOSTROPHE
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_enumeration
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|uintptr_t
name|e_val
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
decl_stmt|;
name|printf
argument_list|(
name|OPT_VAL_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
comment|/*      *  Convert value to string, print that and restore numeric value.      */
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
name|pOD
operator|)
expr_stmt|;
name|printf
argument_list|(
name|QUOT_ARG_FMT
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argEnum
operator|=
name|e_val
expr_stmt|;
name|printf
argument_list|(
name|OPT_END_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_membership
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|svstr
init|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
decl_stmt|;
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|val
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
call|(
name|int
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|pOD
operator|->
name|optCookie
argument_list|)
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|~
literal|0UL
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
name|OPTPROC_RETURN_VALNAME
operator|,
name|pOD
operator|)
expr_stmt|;
name|pz
operator|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
while|while
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"readonly %s_"
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|pz
operator|=
name|SPN_PLUS_N_SPACE_CHARS
argument_list|(
name|pz
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|*
operator|(
name|pz
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|IS_LOWER_CASE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|toupper
argument_list|(
name|ch
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_UPPER_CASE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_PLUS_N_SPACE_CHAR
argument_list|(
name|ch
argument_list|)
condition|)
goto|goto
name|name_done
goto|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|NUL
condition|)
block|{
name|pz
operator|--
expr_stmt|;
goto|goto
name|name_done
goto|;
block|}
else|else
name|fputc
argument_list|(
literal|'_'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|name_done
label|:
empty_stmt|;
name|printf
argument_list|(
name|SHOW_VAL_FMT
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
block|}
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|svstr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_stacked_arg
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|,
name|tOptDesc
modifier|*
name|pOD
parameter_list|)
block|{
name|tArgList
modifier|*
name|pAL
init|=
operator|(
name|tArgList
operator|*
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|ppz
init|=
name|pAL
operator|->
name|apzArgs
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|printf
argument_list|(
name|zOptCookieCt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|ct
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
name|ARG_BY_NUM_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
name|print_quot_str
argument_list|(
operator|*
operator|(
name|ppz
operator|++
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|EXPORT_ARG_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * emit the arguments as readily parsed text.  * The program options are set by emitting the shell "set" command.  *  * @param[in] opts  the program options structure  */
end_comment

begin_function
specifier|static
name|void
name|print_reordering
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|unsigned
name|int
name|ix
decl_stmt|;
name|fputs
argument_list|(
name|set_dash
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
name|opts
operator|->
name|curOptIdx
init|;
name|ix
operator|<
name|opts
operator|->
name|origArgCt
condition|;
name|ix
operator|++
control|)
block|{
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_quot_str
argument_list|(
name|opts
operator|->
name|origArgVect
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|init_optct
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionPutShell  * what:  write a portable shell script to parse options  * private:  * arg:   tOptions*, pOpts, the program options descriptor  * doc:   This routine will emit portable shell script text for parsing  *        the options described in the option definitions. =*/
end_comment

begin_function
name|void
name|optionPutShell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|optIx
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
name|zOptCtFmt
argument_list|,
name|pOpts
operator|->
name|curOptIdx
operator|-
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|optIx
decl_stmt|;
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_OUTPUT_MASK
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/*          *  Equivalence classes are hard to deal with.  Where the          *  option data wind up kind of squishes around.  For the purposes          *  of emitting shell state, they are not recommended, but we'll          *  do something.  I guess we'll emit the equivalenced-to option          *  at the point in time when the base option is found.          */
if|if
condition|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
continue|continue;
comment|/* equivalence to a different option */
comment|/*          *  Equivalenced to a different option.  Process the current option          *  as the equivalenced-to option.  Keep the persistent state bits,          *  but copy over the set-state bits.          */
if|if
condition|(
name|pOD
operator|->
name|optActualIndex
operator|!=
name|optIx
condition|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOD
operator|->
name|optActualIndex
decl_stmt|;
name|p
operator|->
name|optArg
operator|=
name|pOD
operator|->
name|optArg
expr_stmt|;
name|p
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|p
operator|->
name|fOptState
operator||=
name|pOD
operator|->
name|fOptState
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|printf
argument_list|(
name|zEquivMode
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|p
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|pOD
operator|=
name|p
expr_stmt|;
block|}
comment|/*          *  If the argument type is a set membership bitmask, then we always          *  emit the thing.  We do this because it will always have some sort          *  of bitmask value and we need to emit the bit values.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
block|{
name|print_membership
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  IF the option was either specified or it wakes up enabled,          *  then we will emit information.  Otherwise, skip it.          *  The idea is that if someone defines an option to initialize          *  enabled, we should tell our shell script that it is enabled.          */
if|if
condition|(
name|UNUSED_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
comment|/*          *  Handle stacked arguments          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optCookie
operator|!=
name|NULL
operator|)
condition|)
block|{
name|print_stacked_arg
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument has been disabled,          *  Then set its value to the disablement string          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
name|zOptDisabl
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|pz_DisablePfx
operator|!=
name|NULL
operator|)
condition|?
name|pOD
operator|->
name|pz_DisablePfx
else|:
literal|"false"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NUMERIC
condition|)
block|{
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|int
operator|)
name|pOD
operator|->
name|optArg
operator|.
name|argInt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is an enumeration, then it is much          *  like a text value, except we call the callback function          *  to emit the value corresponding to the "optArg" number.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_ENUMERATION
condition|)
block|{
name|print_enumeration
argument_list|(
name|pOpts
argument_list|,
name|pOD
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_BOOLEAN
condition|)
block|{
name|printf
argument_list|(
name|zFullOptFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argBool
operator|==
literal|0
operator|)
condition|?
literal|"false"
else|:
literal|"true"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  IF the option has an empty value,          *  THEN we set the argument to the occurrence count.          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
index|[
literal|0
index|]
operator|==
name|NUL
operator|)
condition|)
block|{
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pOD
operator|->
name|optOccCt
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*          *  This option has a text value          */
name|printf
argument_list|(
name|OPT_VAL_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|print_quot_str
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|OPT_END_FMT
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|optIx
operator|<
name|pOpts
operator|->
name|presetOptCt
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|<
name|pOpts
operator|->
name|origArgCt
operator|)
condition|)
name|print_reordering
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/putshell.c */
end_comment

end_unit

