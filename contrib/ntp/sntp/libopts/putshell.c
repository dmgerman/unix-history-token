begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  $Id: putshell.c,v 4.18 2007/02/04 17:44:12 bkorb Exp $  * Time-stamp:      "2007-01-13 10:29:39 bkorb"  *  *  This module will interpret the options set in the tOptions  *  structure and print them to standard out in a fashion that  *  will allow them to be interpreted by the Bourne or Korn shells.  */
end_comment

begin_comment
comment|/*  *  Automated Options copyright 1992-2007 Bruce Korb  *  *  Automated Options is free software.  *  You may redistribute it and/or modify it under the terms of the  *  GNU General Public License, as published by the Free Software  *  Foundation; either version 2, or (at your option) any later version.  *  *  Automated Options is distributed in the hope that it will be useful,  *  but WITHOUT ANY WARRANTY; without even the implied warranty of  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  *  GNU General Public License for more details.  *  *  You should have received a copy of the GNU General Public License  *  along with Automated Options.  See the file "COPYING".  If not,  *  write to:  The Free Software Foundation, Inc.,  *             51 Franklin Street, Fifth Floor,  *             Boston, MA  02110-1301, USA.  *  * As a special exception, Bruce Korb gives permission for additional  * uses of the text contained in his release of AutoOpts.  *  * The exception is that, if you link the AutoOpts library with other  * files to produce an executable, this does not by itself cause the  * resulting executable to be covered by the GNU General Public License.  * Your use of that executable is in no way restricted on account of  * linking the AutoOpts library code into it.  *  * This exception does not however invalidate any other reasons why  * the executable file might be covered by the GNU General Public License.  *  * This exception applies only to the code released by Bruce Korb under  * the name AutoOpts.  If you copy code from other sources under the  * General Public License into a copy of AutoOpts, as the General Public  * License permits, the exception does not apply to the code that you add  * in this way.  To avoid misleading anyone as to the status of such  * modified files, you must delete this exception notice from them.  *  * If you write modifications of your own for AutoOpts, it is your choice  * whether to permit this exception to apply to your modifications.  * If you do not wish that, delete this exception notice.  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/* static forward declarations maintained by :mkfwd */
end_comment

begin_function_decl
specifier|static
name|void
name|putQuotedStr
parameter_list|(
name|tCC
modifier|*
name|pzStr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*  *  Make sure embedded single quotes come out okay.  The initial quote has  *  been emitted and the closing quote will be upon return.  */
end_comment

begin_function
specifier|static
name|void
name|putQuotedStr
parameter_list|(
name|tCC
modifier|*
name|pzStr
parameter_list|)
block|{
comment|/*      *  Handle empty strings to make the rest of the logic simpler.      */
if|if
condition|(
operator|(
name|pzStr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|pzStr
operator|==
name|NUL
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      *  Emit any single quotes/apostrophes at the start of the string and      *  bail if that is all we need to do.      */
while|while
condition|(
operator|*
name|pzStr
operator|==
literal|'\''
condition|)
block|{
name|fputs
argument_list|(
literal|"\\'"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|pzStr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pzStr
operator|==
name|NUL
condition|)
return|return;
comment|/*      *  Start the single quote string      */
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tCC
modifier|*
name|pz
init|=
name|strchr
argument_list|(
name|pzStr
argument_list|,
literal|'\''
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|==
name|NULL
condition|)
break|break;
comment|/*          *  Emit the string up to the single quote (apostrophe) we just found.          */
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|pzStr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|pz
operator|-
name|pzStr
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|pzStr
operator|=
name|pz
expr_stmt|;
comment|/*          *  Emit an escaped apostrophe for every one we find.          *  If that ends the string, do not re-open the single quotes.          */
while|while
condition|(
operator|*
operator|++
name|pzStr
operator|==
literal|'\''
condition|)
name|fputs
argument_list|(
literal|"\\'"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pzStr
operator|==
name|NUL
condition|)
return|return;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*      *  If we broke out of the loop, we must still emit the remaining text      *  and then close the single quote string.      */
name|fputs
argument_list|(
name|pzStr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func  optionPutShell  * what:  write a portable shell script to parse options  * private:  * arg:   tOptions*, pOpts, the program options descriptor  * doc:   This routine will emit portable shell script text for parsing  *        the options described in the option definitions. =*/
end_comment

begin_function
name|void
name|optionPutShell
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|int
name|optIx
init|=
literal|0
decl_stmt|;
name|tSCC
name|zOptCtFmt
index|[]
init|=
literal|"OPTION_CT=%d\nexport OPTION_CT\n"
decl_stmt|;
name|tSCC
name|zOptNumFmt
index|[]
init|=
literal|"%1$s_%2$s=%3$d # 0x%3$X\nexport %1$s_%2$s\n"
decl_stmt|;
name|tSCC
name|zOptDisabl
index|[]
init|=
literal|"%1$s_%2$s=%3$s\nexport %1$s_%2$s\n"
decl_stmt|;
name|tSCC
name|zOptValFmt
index|[]
init|=
literal|"%s_%s="
decl_stmt|;
name|tSCC
name|zOptEnd
index|[]
init|=
literal|"\nexport %s_%s\n"
decl_stmt|;
name|tSCC
name|zFullOptFmt
index|[]
init|=
literal|"%1$s_%2$s='%3$s'\nexport %1$s_%2$s\n"
decl_stmt|;
name|tSCC
name|zEquivMode
index|[]
init|=
literal|"%1$s_%2$s_MODE='%3$s'\nexport %1$s_%2$s_MODE\n"
decl_stmt|;
name|printf
argument_list|(
name|zOptCtFmt
argument_list|,
name|pOpts
operator|->
name|curOptIdx
operator|-
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|optIx
decl_stmt|;
if|if
condition|(
name|SKIP_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
comment|/*          *  Equivalence classes are hard to deal with.  Where the          *  option data wind up kind of squishes around.  For the purposes          *  of emitting shell state, they are not recommended, but we'll          *  do something.  I guess we'll emit the equivalenced-to option          *  at the point in time when the base option is found.          */
if|if
condition|(
name|pOD
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
continue|continue;
comment|/* equivalence to a different option */
comment|/*          *  Equivalenced to a different option.  Process the current option          *  as the equivalenced-to option.  Keep the persistent state bits,          *  but copy over the set-state bits.          */
if|if
condition|(
name|pOD
operator|->
name|optActualIndex
operator|!=
name|optIx
condition|)
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
operator|+
name|pOD
operator|->
name|optActualIndex
decl_stmt|;
name|p
operator|->
name|optArg
operator|=
name|pOD
operator|->
name|optArg
expr_stmt|;
name|p
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|p
operator|->
name|fOptState
operator||=
name|pOD
operator|->
name|fOptState
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|printf
argument_list|(
name|zEquivMode
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|p
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|pOD
operator|=
name|p
expr_stmt|;
block|}
comment|/*          *  If the argument type is a set membership bitmask, then we always          *  emit the thing.  We do this because it will always have some sort          *  of bitmask value and we need to emit the bit values.          */
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_MEMBERSHIP
condition|)
block|{
name|char
specifier|const
modifier|*
name|pz
decl_stmt|;
name|uintptr_t
name|val
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
call|(
name|int
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|pOD
operator|->
name|optCookie
argument_list|)
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optCookie
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|~
literal|0UL
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
operator|(
name|tOptions
operator|*
operator|)
literal|2UL
operator|,
name|pOD
operator|)
expr_stmt|;
comment|/*              *  We are building the typeset list.  The list returned starts with              *  'none + ' for use by option saving stuff.  We must ignore that.              */
name|pz
operator|=
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|+
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|pz
operator|!=
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"typeset -x -i %s_"
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|pz
operator|+=
name|strspn
argument_list|(
name|pz
argument_list|,
literal|" +\t\n\f"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
init|=
operator|*
operator|(
name|pz
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|toupper
argument_list|(
name|ch
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'+'
operator|)
condition|)
goto|goto
name|name_done
goto|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|NUL
condition|)
block|{
name|pz
operator|--
expr_stmt|;
goto|goto
name|name_done
goto|;
block|}
else|else
name|fputc
argument_list|(
literal|'_'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|name_done
label|:
empty_stmt|;
name|printf
argument_list|(
literal|"=%1$lu # 0x%1$lX\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
block|}
name|AGFREE
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
name|pOD
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
continue|continue;
block|}
comment|/*          *  IF the option was either specified or it wakes up enabled,          *  then we will emit information.  Otherwise, skip it.          *  The idea is that if someone defines an option to initialize          *  enabled, we should tell our shell script that it is enabled.          */
if|if
condition|(
name|UNUSED_OPT
argument_list|(
name|pOD
argument_list|)
operator|&&
name|DISABLED_OPT
argument_list|(
name|pOD
argument_list|)
condition|)
continue|continue;
comment|/*          *  Handle stacked arguments          */
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
operator|)
operator|&&
operator|(
name|pOD
operator|->
name|optCookie
operator|!=
name|NULL
operator|)
condition|)
block|{
name|tSCC
name|zOptCookieCt
index|[]
init|=
literal|"%1$s_%2$s_CT=%3$d\nexport %1$s_%2$s_CT\n"
decl_stmt|;
name|tArgList
modifier|*
name|pAL
init|=
operator|(
name|tArgList
operator|*
operator|)
name|pOD
operator|->
name|optCookie
decl_stmt|;
name|tCC
modifier|*
modifier|*
name|ppz
init|=
name|pAL
operator|->
name|apzArgs
decl_stmt|;
name|int
name|ct
init|=
name|pAL
operator|->
name|useCt
decl_stmt|;
name|printf
argument_list|(
name|zOptCookieCt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|ct
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
block|{
name|tSCC
name|numarg_z
index|[]
init|=
literal|"%s_%s_%d="
decl_stmt|;
name|tSCC
name|end_z
index|[]
init|=
literal|"\nexport %s_%s_%d\n"
decl_stmt|;
name|printf
argument_list|(
name|numarg_z
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
name|putQuotedStr
argument_list|(
operator|*
operator|(
name|ppz
operator|++
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|end_z
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pAL
operator|->
name|useCt
operator|-
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          *  If the argument has been disabled,          *  Then set its value to the disablement string          */
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_DISABLED
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|zOptDisabl
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|pz_DisablePfx
operator|!=
name|NULL
operator|)
condition|?
name|pOD
operator|->
name|pz_DisablePfx
else|:
literal|"false"
argument_list|)
expr_stmt|;
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
elseif|else
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_NUMERIC
condition|)
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|int
operator|)
name|pOD
operator|->
name|optArg
operator|.
name|argInt
argument_list|)
expr_stmt|;
comment|/*          *  If the argument type is an enumeration, then it is much          *  like a text value, except we call the callback function          *  to emit the value corresponding to the "optArg" number.          */
elseif|else
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_ENUMERATION
condition|)
block|{
name|printf
argument_list|(
name|zOptValFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|pOD
operator|->
name|pOptProc
operator|)
operator|)
operator|(
operator|(
name|tOptions
operator|*
operator|)
literal|1UL
operator|,
name|pOD
operator|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zOptEnd
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
comment|/*          *  If the argument type is numeric, the last arg pointer          *  is really the VALUE of the string that was pointed to.          */
elseif|else
if|if
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
operator|==
name|OPARG_TYPE_BOOLEAN
condition|)
name|printf
argument_list|(
name|zFullOptFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argBool
operator|==
literal|0
operator|)
condition|?
literal|"false"
else|:
literal|"true"
argument_list|)
expr_stmt|;
comment|/*          *  IF the option has an empty value,          *  THEN we set the argument to the occurrence count.          */
elseif|else
if|if
condition|(
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
index|[
literal|0
index|]
operator|==
name|NUL
operator|)
condition|)
name|printf
argument_list|(
name|zOptNumFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|,
name|pOD
operator|->
name|optOccCt
argument_list|)
expr_stmt|;
comment|/*          *  This option has a text value          */
else|else
block|{
name|printf
argument_list|(
name|zOptValFmt
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
name|putQuotedStr
argument_list|(
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|zOptEnd
argument_list|,
name|pOpts
operator|->
name|pzPROGNAME
argument_list|,
name|pOD
operator|->
name|pz_NAME
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|optIx
operator|<
name|pOpts
operator|->
name|presetOptCt
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|pOpts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pOpts
operator|->
name|curOptIdx
operator|<
name|pOpts
operator|->
name|origArgCt
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"set --"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|optIx
operator|=
name|pOpts
operator|->
name|curOptIdx
init|;
name|optIx
operator|<
name|pOpts
operator|->
name|origArgCt
condition|;
name|optIx
operator|++
control|)
block|{
name|char
modifier|*
name|pzArg
init|=
name|pOpts
operator|->
name|origArgVect
index|[
name|optIx
index|]
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|pzArg
argument_list|,
literal|'\''
argument_list|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|" '%s'"
argument_list|,
name|pzArg
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
literal|" '"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
operator|(
name|pzArg
operator|++
operator|)
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\''
case|:
name|fputs
argument_list|(
literal|"'\\''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUL
case|:
goto|goto
name|arg_done
goto|;
default|default:
name|fputc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|arg_done
label|:
empty_stmt|;
name|fputc
argument_list|(
literal|'\''
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\nOPTION_CT=0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/putshell.c */
end_comment

end_unit

