begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file initialize.c  *  *  initialize the libopts data structures.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|tSuccess
name|do_presets
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/**  *  Make sure the option descriptor is there and that we understand it.  *  This should be called from any user entry point where one needs to  *  worry about validity.  (Some entry points are free to assume that  *  the call is not the first to the library and, thus, that this has  *  already been called.)  *  *  Upon successful completion, pzProgName and pzProgPath are set.  *  *  @param[in,out] opts   program options descriptor  *  @param[in]     pname  name of program, from argv[]  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|validate_struct
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|char
specifier|const
modifier|*
name|pname
parameter_list|)
block|{
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|zno_opt_arg
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
name|print_exit
operator|=
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_SHELL_OUTPUT
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/*      *  IF the client has enabled translation and the translation procedure      *  is available, then go do it.      */
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|opts
operator|->
name|pTransProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|option_xlateable_txt
operator|.
name|field_ct
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/*          *  If option names are not to be translated at all, then do not do          *  it for configuration parsing either.  (That is the bit that really          *  gets tested anyway.)          */
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_XLAT_MASK
operator|)
operator|==
name|OPTPROC_NXLAT_OPT
condition|)
name|opts
operator|->
name|fOptSet
operator||=
name|OPTPROC_NXLAT_OPT_CFG
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pTransProc
call|)
argument_list|()
expr_stmt|;
block|}
comment|/*      *  IF the struct version is not the current, and also      *     either too large (?!) or too small,      *  THEN emit error message and fail-exit      */
if|if
condition|(
operator|(
name|opts
operator|->
name|structVersion
operator|!=
name|OPTIONS_STRUCT_VERSION
operator|)
operator|&&
operator|(
operator|(
name|opts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
operator|)
operator|||
operator|(
name|opts
operator|->
name|structVersion
operator|<
name|OPTIONS_MINIMUM_VERSION
operator|)
operator|)
condition|)
block|{
specifier|static
name|char
specifier|const
name|ao_ver_string
index|[]
init|=
name|STR
argument_list|(
name|AO_CURRENT
argument_list|)
literal|":"
name|STR
argument_list|(
name|AO_REVISION
argument_list|)
literal|":"
name|STR
argument_list|(
name|AO_AGE
argument_list|)
literal|"\n"
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zwrong_ver
argument_list|,
name|pname
argument_list|,
name|NUM_TO_VER
argument_list|(
name|opts
operator|->
name|structVersion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|structVersion
operator|>
name|OPTIONS_STRUCT_VERSION
condition|)
name|fputs
argument_list|(
name|ztoo_new
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|ztoo_old
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|ao_ver_string
argument_list|,
sizeof|sizeof
argument_list|(
name|ao_ver_string
argument_list|)
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
comment|/*      *  If the program name hasn't been set, then set the name and the path      *  and the set of equivalent characters.      */
if|if
condition|(
name|opts
operator|->
name|pzProgName
operator|==
name|NULL
condition|)
block|{
name|char
specifier|const
modifier|*
name|pz
init|=
name|strrchr
argument_list|(
name|pname
argument_list|,
name|DIRCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
name|opts
operator|->
name|pzProgName
operator|=
name|pz
operator|+
literal|1
expr_stmt|;
else|else
name|opts
operator|->
name|pzProgName
operator|=
name|pname
expr_stmt|;
name|pz
operator|=
name|pathfind
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pname
argument_list|,
literal|"rx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pz
operator|!=
name|NULL
condition|)
name|pname
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|pz
expr_stmt|;
name|opts
operator|->
name|pzProgPath
operator|=
name|pname
expr_stmt|;
comment|/*          *  when comparing long names, these are equivalent          */
name|strequate
argument_list|(
name|zSepChars
argument_list|)
expr_stmt|;
block|}
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  DO PRESETS  *  *  The next several routines do the immediate action pass on the command  *  line options, then the environment variables, then the config files in  *  reverse order.  Once done with that, the order is reversed and all  *  the config files and environment variables are processed again, this  *  time only processing the non-immediate action options.  do_presets()  *  will then return for optionProcess() to do the final pass on the command  *  line arguments.  */
end_comment

begin_comment
comment|/**  *  scan the command line for immediate action options.  *  This is only called the first time through.  *  While this procedure is active, the OPTPROC_IMMEDIATE is true.  *  *  @param pOpts   program options descriptor  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|immediate_opts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tSuccess
name|res
decl_stmt|;
name|opts
operator|->
name|fOptSet
operator||=
name|OPTPROC_IMMEDIATE
expr_stmt|;
name|opts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
comment|/* start by skipping program name */
name|opts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
comment|/*      *  Examine all the options from the start.  We process any options that      *  are marked for immediate processing.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|opt_st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|PRESET
argument_list|)
decl_stmt|;
name|res
operator|=
name|next_opt
argument_list|(
name|opts
argument_list|,
operator|&
name|opt_st
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|failed_option
goto|;
case|case
name|PROBLEM
case|:
name|res
operator|=
name|SUCCESS
expr_stmt|;
goto|goto
name|leave
goto|;
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this is an immediate-attribute option, then do it.          */
if|if
condition|(
operator|!
name|DO_IMMEDIATELY
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handle_opt
argument_list|(
name|opts
argument_list|,
operator|&
name|opt_st
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|failed_option
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|leave
label|:
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_IMMEDIATE
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  *  check for preset values from a config files or envrionment variables  *  * @param[in,out] opts  the structure with the option names to check  */
end_comment

begin_function
specifier|static
name|tSuccess
name|do_presets
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|immediate_opts
argument_list|(
name|opts
argument_list|)
argument_list|)
condition|)
return|return
name|FAILURE
return|;
comment|/*      *  IF this option set has a --save-opts option, then it also      *  has a --load-opts option.  See if a command line option has disabled      *  option presetting.      */
if|if
condition|(
operator|(
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
name|NO_EQUIVALENT
operator|)
operator|&&
operator|(
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|!=
literal|0
operator|)
condition|)
block|{
name|od
operator|=
name|opts
operator|->
name|pOptDesc
operator|+
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DISABLED_OPT
argument_list|(
name|od
argument_list|)
condition|)
return|return
name|SUCCESS
return|;
block|}
comment|/*      *  Until we return from this procedure, disable non-presettable opts      */
name|opts
operator|->
name|fOptSet
operator||=
name|OPTPROC_PRESETTING
expr_stmt|;
comment|/*      *  IF there are no config files,      *  THEN do any environment presets and leave.      */
if|if
condition|(
name|opts
operator|->
name|papzHomeList
operator|==
name|NULL
condition|)
block|{
name|env_presets
argument_list|(
name|opts
argument_list|,
name|ENV_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|env_presets
argument_list|(
name|opts
argument_list|,
name|ENV_IMM
argument_list|)
expr_stmt|;
comment|/*          *  Check to see if environment variables have disabled presetting.          */
if|if
condition|(
operator|(
name|od
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|DISABLED_OPT
argument_list|(
name|od
argument_list|)
condition|)
name|intern_file_load
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/*          *  ${PROGRAM_LOAD_OPTS} value of "no" cannot disable other environment          *  variable options.  Only the loading of .rc files.          */
name|env_presets
argument_list|(
name|opts
argument_list|,
name|ENV_NON_IMM
argument_list|)
expr_stmt|;
block|}
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_PRESETTING
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * AutoOpts initialization  *  * @param[in,out] opts  the structure to initialize  * @param[in]     a_ct  program argument count  * @param[in]     a_v   program argument vector  */
end_comment

begin_function
name|LOCAL
name|bool
name|ao_initialize
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|a_ct
parameter_list|,
name|char
modifier|*
modifier|*
name|a_v
parameter_list|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_INITDONE
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
name|opts
operator|->
name|origArgCt
operator|=
operator|(
name|unsigned
name|int
operator|)
name|a_ct
expr_stmt|;
name|opts
operator|->
name|origArgVect
operator|=
name|a_v
expr_stmt|;
name|opts
operator|->
name|fOptSet
operator||=
name|OPTPROC_INITDONE
expr_stmt|;
if|if
condition|(
name|HAS_pzPkgDataDir
argument_list|(
name|opts
argument_list|)
condition|)
name|program_pkgdatadir
operator|=
name|opts
operator|->
name|pzPkgDataDir
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|do_presets
argument_list|(
name|opts
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/*      *  IF option name conversion was suppressed but it is not suppressed      *  for the command line, then it's time to translate option names.      *  Usage text will not get retranslated.      */
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_TRANSLATE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|opts
operator|->
name|pTransProc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_NO_XLAT_MASK
operator|)
operator|==
name|OPTPROC_NXLAT_OPT_CFG
operator|)
condition|)
block|{
name|opts
operator|->
name|fOptSet
operator|&=
operator|~
name|OPTPROC_NXLAT_OPT_CFG
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pTransProc
call|)
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_REORDER
operator|)
operator|!=
literal|0
condition|)
name|optionSort
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/initialize.c */
end_comment

end_unit

