begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file cook.c  *  *  This file contains the routines that deal with processing quoted strings  *  into an internal format.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/* = = = START-STATIC-FORWARD = = = */
end_comment

begin_function_decl
specifier|static
name|bool
name|contiguous_quote
parameter_list|(
name|char
modifier|*
modifier|*
name|pps
parameter_list|,
name|char
modifier|*
name|pq
parameter_list|,
name|int
modifier|*
name|lnct_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* = = = END-STATIC-FORWARD = = = */
end_comment

begin_comment
comment|/*=export_func  ao_string_cook_escape_char  * private:  *  * what:  escape-process a string fragment  * arg:   + char const * + pzScan  + points to character after the escape +  * arg:   + char *       + pRes    + Where to put the result byte +  * arg:   + unsigned int + nl_ch   + replacement char if scanned char is \n +  *  * ret-type: unsigned int  * ret-desc: The number of bytes consumed processing the escaped character.  *  * doc:  *  *  This function converts "t" into "\t" and all your other favorite  *  escapes, including numeric ones:  hex and ocatal, too.  *  The returned result tells the caller how far to advance the  *  scan pointer (passed in).  The default is to just pass through the  *  escaped character and advance the scan by one.  *  *  Some applications need to keep an escaped newline, others need to  *  suppress it.  This is accomplished by supplying a '\n' replacement  *  character that is different from \n, if need be.  For example, use  *  0x7F and never emit a 0x7F.  *  * err:  @code{NULL} is returned if the string is mal-formed. =*/
end_comment

begin_function
name|unsigned
name|int
name|ao_string_cook_escape_char
parameter_list|(
name|char
specifier|const
modifier|*
name|pzIn
parameter_list|,
name|char
modifier|*
name|pRes
parameter_list|,
name|uint_t
name|nl
parameter_list|)
block|{
name|unsigned
name|int
name|res
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
operator|*
name|pRes
operator|=
operator|*
name|pzIn
operator|++
condition|)
block|{
case|case
name|NUL
case|:
comment|/* NUL - end of input string */
return|return
literal|0
return|;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|*
name|pzIn
operator|!=
name|NL
condition|)
return|return
literal|1
return|;
name|res
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|NL
case|:
comment|/* NL  - emit newline        */
operator|*
name|pRes
operator|=
operator|(
name|char
operator|)
name|nl
expr_stmt|;
return|return
name|res
return|;
case|case
literal|'a'
case|:
operator|*
name|pRes
operator|=
literal|'\a'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|pRes
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|pRes
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|pRes
operator|=
name|NL
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|pRes
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|pRes
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|pRes
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
comment|/* HEX Escape       */
if|if
condition|(
name|IS_HEX_DIGIT_CHAR
argument_list|(
operator|*
name|pzIn
argument_list|)
condition|)
block|{
name|char
name|z
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|ct
init|=
literal|0
decl_stmt|;
do|do
block|{
name|z
index|[
name|ct
index|]
operator|=
name|pzIn
index|[
name|ct
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ct
operator|>=
literal|2
condition|)
break|break;
block|}
do|while
condition|(
name|IS_HEX_DIGIT_CHAR
argument_list|(
name|pzIn
index|[
name|ct
index|]
argument_list|)
condition|)
do|;
name|z
index|[
name|ct
index|]
operator|=
name|NUL
expr_stmt|;
operator|*
name|pRes
operator|=
operator|(
name|char
operator|)
name|strtoul
argument_list|(
name|z
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
name|ct
operator|+
literal|1
return|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
comment|/*          *  IF the character copied was an octal digit,          *  THEN set the output character to an octal value.          *  The 3 octal digit result might exceed 0xFF, so check it.          */
name|char
name|z
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|int
name|ct
init|=
literal|0
decl_stmt|;
name|z
index|[
name|ct
operator|++
index|]
operator|=
operator|*
operator|--
name|pzIn
expr_stmt|;
while|while
condition|(
name|IS_OCT_DIGIT_CHAR
argument_list|(
name|pzIn
index|[
name|ct
index|]
argument_list|)
condition|)
block|{
name|z
index|[
name|ct
index|]
operator|=
name|pzIn
index|[
name|ct
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|ct
operator|>=
literal|3
condition|)
break|break;
block|}
name|z
index|[
name|ct
index|]
operator|=
name|NUL
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|z
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xFF
condition|)
name|val
operator|=
literal|0xFF
expr_stmt|;
operator|*
name|pRes
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
return|return
name|ct
return|;
block|}
default|default:
comment|/* quoted character is result character */
empty_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  A quoted string has been found.  *  Find the end of it and compress any escape sequences.  */
end_comment

begin_function
specifier|static
name|bool
name|contiguous_quote
parameter_list|(
name|char
modifier|*
modifier|*
name|pps
parameter_list|,
name|char
modifier|*
name|pq
parameter_list|,
name|int
modifier|*
name|lnct_p
parameter_list|)
block|{
name|char
modifier|*
name|ps
init|=
operator|*
name|pps
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|IS_WHITESPACE_CHAR
argument_list|(
operator|*
name|ps
argument_list|)
condition|)
if|if
condition|(
operator|*
operator|(
name|ps
operator|++
operator|)
operator|==
name|NL
condition|)
operator|(
operator|*
name|lnct_p
operator|)
operator|++
expr_stmt|;
comment|/*          *  IF the next character is a quote character,          *  THEN we will concatenate the strings.          */
switch|switch
condition|(
operator|*
name|ps
condition|)
block|{
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
operator|*
name|pq
operator|=
operator|*
operator|(
name|ps
operator|++
operator|)
expr_stmt|;
comment|/* assign new quote character and return */
operator|*
name|pps
operator|=
name|ps
expr_stmt|;
return|return
name|true
return|;
case|case
literal|'/'
case|:
comment|/*              *  Allow for a comment embedded in the concatenated string.              */
switch|switch
condition|(
name|ps
index|[
literal|1
index|]
condition|)
block|{
default|default:
operator|*
name|pps
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
case|case
literal|'/'
case|:
comment|/*                  *  Skip to end of line                  */
name|ps
operator|=
name|strchr
argument_list|(
name|ps
argument_list|,
name|NL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
operator|*
name|pps
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'*'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|strstr
argument_list|(
name|ps
operator|+
literal|2
argument_list|,
literal|"*/"
argument_list|)
decl_stmt|;
comment|/*                  *  Skip to terminating star slash                  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
operator|*
name|pps
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
while|while
condition|(
name|ps
operator|<
name|p
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|ps
operator|++
operator|)
operator|==
name|NL
condition|)
operator|(
operator|*
name|lnct_p
operator|)
operator|++
expr_stmt|;
block|}
name|ps
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
block|}
continue|continue;
default|default:
comment|/*              *  The next non-whitespace character is not a quote.              *  The series of quoted strings has come to an end.              */
operator|*
name|pps
operator|=
name|ps
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*=export_func  ao_string_cook  * private:  *  * what:  concatenate and escape-process strings  * arg:   + char * + pzScan  + The *MODIFIABLE* input buffer +  * arg:   + int *  + lnct_p  + The (possibly NULL) pointer to a line count +  *  * ret-type: char *  * ret-desc: The address of the text following the processed strings.  *           The return value is NULL if the strings are ill-formed.  *  * doc:  *  *  A series of one or more quoted strings are concatenated together.  *  If they are quoted with double quotes (@code{"}), then backslash  *  escapes are processed per the C programming language.  If they are  *  single quote strings, then the backslashes are honored only when they  *  precede another backslash or a single quote character.  *  * err:  @code{NULL} is returned if the string(s) is/are mal-formed. =*/
end_comment

begin_function
name|char
modifier|*
name|ao_string_cook
parameter_list|(
name|char
modifier|*
name|pzScan
parameter_list|,
name|int
modifier|*
name|lnct_p
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
name|char
name|q
init|=
operator|*
name|pzScan
decl_stmt|;
comment|/*      *  It is a quoted string.  Process the escape sequence characters      *  (in the set "abfnrtv") and make sure we find a closing quote.      */
name|char
modifier|*
name|pzD
init|=
name|pzScan
operator|++
decl_stmt|;
name|char
modifier|*
name|pzS
init|=
name|pzScan
decl_stmt|;
if|if
condition|(
name|lnct_p
operator|==
name|NULL
condition|)
name|lnct_p
operator|=
operator|&
name|l
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/*          *  IF the next character is the quote character, THEN we may end the          *  string.  We end it unless the next non-blank character *after* the          *  string happens to also be a quote.  If it is, then we will change          *  our quote character to the new quote character and continue          *  condensing text.          */
while|while
condition|(
operator|*
name|pzS
operator|==
name|q
condition|)
block|{
operator|*
name|pzD
operator|=
name|NUL
expr_stmt|;
comment|/* This is probably the end of the line */
if|if
condition|(
operator|!
name|contiguous_quote
argument_list|(
operator|&
name|pzS
argument_list|,
operator|&
name|q
argument_list|,
name|lnct_p
argument_list|)
condition|)
return|return
name|pzS
return|;
block|}
comment|/*          *  We are inside a quoted string.  Copy text.          */
switch|switch
condition|(
operator|*
operator|(
name|pzD
operator|++
operator|)
operator|=
operator|*
operator|(
name|pzS
operator|++
operator|)
condition|)
block|{
case|case
name|NUL
case|:
return|return
name|NULL
return|;
case|case
name|NL
case|:
operator|(
operator|*
name|lnct_p
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/*              *  IF we are escaping a new line,              *  THEN drop both the escape and the newline from              *       the result string.              */
if|if
condition|(
operator|*
name|pzS
operator|==
name|NL
condition|)
block|{
name|pzS
operator|++
expr_stmt|;
name|pzD
operator|--
expr_stmt|;
operator|(
operator|*
name|lnct_p
operator|)
operator|++
expr_stmt|;
block|}
comment|/*              *  ELSE IF the quote character is '"' or '`',              *  THEN we do the full escape character processing              */
elseif|else
if|if
condition|(
name|q
operator|!=
literal|'\''
condition|)
block|{
name|unsigned
name|int
name|ct
decl_stmt|;
name|ct
operator|=
name|ao_string_cook_escape_char
argument_list|(
name|pzS
argument_list|,
name|pzD
operator|-
literal|1
argument_list|,
operator|(
name|uint_t
operator|)
name|NL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|pzS
operator|+=
name|ct
expr_stmt|;
block|}
comment|/* if (q != '\'')                  */
comment|/*              *  OTHERWISE, we only process "\\", "\'" and "\#" sequences.              *  The latter only to easily hide preprocessing directives.              */
else|else
switch|switch
condition|(
operator|*
name|pzS
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'#'
case|:
name|pzD
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|pzS
operator|++
expr_stmt|;
block|}
block|}
comment|/* switch (*(pzD++) = *(pzS++))    */
block|}
comment|/* for (;;)                        */
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/cook.c */
end_comment

end_unit

