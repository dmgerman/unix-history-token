begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file alias.c  *  * Handle options that are aliases for another option.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This routine will forward an option alias to the correct option code.  *  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|too_many_occurrences
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|od
parameter_list|)
block|{
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|eqv
init|=
operator|(
name|od
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
operator|)
condition|?
name|zequiv
else|:
name|zNil
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|ztoo_often_fmt
argument_list|,
name|opts
operator|->
name|pzProgName
argument_list|)
expr_stmt|;
if|if
condition|(
name|od
operator|->
name|optMaxCt
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zat_most
argument_list|,
name|od
operator|->
name|optMaxCt
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zonly_one
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/*=export_func  optionAlias  * private:  *  * what:  relay an option to its alias  * arg:   + tOptions *   + opts   + program options descriptor  +  * arg:   + tOptDesc *   + old_od + the descriptor for this arg +  * arg:   + unsigned int + alias  + the aliased-to option index +  * ret-type: int  *  * doc:  *  Handle one option as if it had been specified as another.  Exactly.  *  Returns "-1" if the aliased-to option has appeared too many times. =*/
end_comment

begin_function
name|int
name|optionAlias
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptDesc
modifier|*
name|old_od
parameter_list|,
name|unsigned
name|int
name|alias
parameter_list|)
block|{
name|tOptDesc
modifier|*
name|new_od
decl_stmt|;
if|if
condition|(
name|opts
operator|<=
name|OPTPROC_EMIT_LIMIT
condition|)
return|return
literal|0
return|;
name|new_od
operator|=
name|opts
operator|->
name|pOptDesc
operator|+
name|alias
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|opts
operator|->
name|optCt
operator|<=
name|alias
condition|)
block|{
name|fputs
argument_list|(
name|zbad_alias_id
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/*      *  Copy over the option instance flags      */
name|new_od
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|new_od
operator|->
name|fOptState
operator||=
operator|(
name|old_od
operator|->
name|fOptState
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
name|new_od
operator|->
name|optArg
operator|.
name|argString
operator|=
name|old_od
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
comment|/*      *  Keep track of count only for DEFINED (command line) options.      *  IF we have too many, build up an error message and bail.      */
if|if
condition|(
operator|(
name|new_od
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|&&
operator|(
operator|++
name|new_od
operator|->
name|optOccCt
operator|>
name|new_od
operator|->
name|optMaxCt
operator|)
condition|)
return|return
name|too_many_occurrences
argument_list|(
name|opts
argument_list|,
name|new_od
argument_list|)
return|;
comment|/*      *  Clear the state bits and counters      */
name|old_od
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|old_od
operator|->
name|optOccCt
operator|=
literal|0
expr_stmt|;
comment|/*      *  If there is a procedure to call, call it      */
if|if
condition|(
name|new_od
operator|->
name|pOptProc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|new_od
operator|->
name|pOptProc
call|)
argument_list|(
name|opts
argument_list|,
name|new_od
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/alias.c */
end_comment

end_unit

