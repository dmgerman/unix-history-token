begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * \file restore.c  *  *  This module's routines will save the current option state to memory  *  and restore it.  If saved prior to the initial optionProcess call,  *  then the initial state will be restored.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/*  *  optionFixupSavedOpts  Really, it just wipes out option state for  *  options that are troublesome to copy.  viz., stacked strings and  *  hierarcicaly valued option args.  We do duplicate string args that  *  have been marked as allocated though.  */
end_comment

begin_function
specifier|static
name|void
name|fixupSavedOptionArgs
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
name|tOptDesc
modifier|*
name|pOD
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
comment|/*      *  Make sure that allocated stuff is only referenced in the      *  archived copy of the data.      */
for|for
control|(
init|;
name|ct
operator|--
operator|>
literal|0
condition|;
name|pOD
operator|++
control|)
block|{
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|pOD
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_STRING
case|:
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
condition|)
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|q
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|AGDUPSTR
argument_list|(
name|q
operator|->
name|optArg
operator|.
name|argString
argument_list|,
name|pOD
operator|->
name|optArg
operator|.
name|argString
argument_list|,
literal|"arg"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
block|{
name|tOptDesc
modifier|*
name|q
init|=
name|p
operator|->
name|pOptDesc
operator|+
operator|(
name|pOD
operator|-
name|pOpts
operator|->
name|pOptDesc
operator|)
decl_stmt|;
name|q
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*=export_func optionSaveState  *  * what:  saves the option state to memory  * arg:   tOptions *, pOpts, program options descriptor  *  * doc:  *  *  This routine will allocate enough memory to save the current option  *  processing state.  If this routine has been called before, that memory  *  will be reused.  You may only save one copy of the option state.  This  *  routine may be called before optionProcess(3AO).  If you do call it  *  before the first call to optionProcess, then you may also change the  *  contents of argc/argv after you call optionRestore(3AO)  *  *  In fact, more strongly put: it is safest to only use this function  *  before having processed any options.  In particular, the saving and  *  restoring of stacked string arguments and hierarchical values is  *  disabled.  The values are not saved.  *  * err:   If it fails to allocate the memory,  *        it will print a message to stderr and exit.  *        Otherwise, it will always succeed. =*/
end_comment

begin_function
name|void
name|optionSaveState
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|size_t
name|sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|pOpts
argument_list|)
operator|+
operator|(
operator|(
name|size_t
operator|)
name|pOpts
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
operator|)
decl_stmt|;
name|p
operator|=
name|AGALOC
argument_list|(
name|sz
argument_list|,
literal|"saved option state"
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pSavedState
operator|=
name|p
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|pOpts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|pOpts
operator|->
name|pOptDesc
argument_list|,
operator|(
name|size_t
operator|)
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|fixupSavedOptionArgs
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*=export_func optionRestore  *  * what:  restore option state from memory copy  * arg:   tOptions *, pOpts, program options descriptor  *  * doc:  Copy back the option state from saved memory.  *       The allocated memory is left intact, so this routine can be  *       called repeatedly without having to call optionSaveState again.  *       If you are restoring a state that was saved before the first call  *       to optionProcess(3AO), then you may change the contents of the  *       argc/argv parameters to optionProcess.  *  * err:  If you have not called @code{optionSaveState} before, a diagnostic is  *       printed to @code{stderr} and exit is called. =*/
end_comment

begin_function
name|void
name|optionRestore
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|char
specifier|const
modifier|*
name|pzName
init|=
name|pOpts
operator|->
name|pzProgName
decl_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
block|{
name|pzName
operator|=
name|pOpts
operator|->
name|pzPROGNAME
expr_stmt|;
if|if
condition|(
name|pzName
operator|==
name|NULL
condition|)
name|pzName
operator|=
name|zNil
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNoState
argument_list|,
name|pzName
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|pOpts
operator|->
name|pSavedState
operator|=
name|NULL
expr_stmt|;
name|optionFree
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
operator|->
name|pOptDesc
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pSavedState
operator|=
name|p
expr_stmt|;
name|fixupSavedOptionArgs
argument_list|(
name|pOpts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
end_comment

begin_comment
comment|/*=export_func optionFree  *  * what:  free allocated option processing memory  * arg:   tOptions *, pOpts, program options descriptor  *  * doc:   AutoOpts sometimes allocates memory and puts pointers to it in the  *        option state structures.  This routine deallocates all such memory.  *  * err:   As long as memory has not been corrupted,  *        this routine is always successful. =*/
end_comment

begin_function
name|void
name|optionFree
parameter_list|(
name|tOptions
modifier|*
name|pOpts
parameter_list|)
block|{
name|free_saved_state
label|:
block|{
name|tOptDesc
modifier|*
name|p
init|=
name|pOpts
operator|->
name|pOptDesc
decl_stmt|;
name|int
name|ct
init|=
name|pOpts
operator|->
name|optCt
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
block|{
name|AGFREE
argument_list|(
name|p
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fOptState
operator|&=
operator|~
name|OPTST_ALLOC_ARG
expr_stmt|;
block|}
switch|switch
condition|(
name|OPTST_GET_ARGTYPE
argument_list|(
name|p
operator|->
name|fOptState
argument_list|)
condition|)
block|{
case|case
name|OPARG_TYPE_STRING
case|:
ifdef|#
directive|ifdef
name|WITH_LIBREGEX
if|if
condition|(
operator|(
name|p
operator|->
name|fOptState
operator|&
name|OPTST_STACKED
operator|)
operator|&&
operator|(
name|p
operator|->
name|optCookie
operator|!=
name|NULL
operator|)
condition|)
block|{
name|p
operator|->
name|optArg
operator|.
name|argString
operator|=
literal|".*"
expr_stmt|;
name|optionUnstackArg
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* leak memory */
empty_stmt|;
endif|#
directive|endif
break|break;
case|case
name|OPARG_TYPE_HIERARCHY
case|:
if|if
condition|(
name|p
operator|->
name|optCookie
operator|!=
name|NULL
condition|)
name|unload_arg_list
argument_list|(
name|p
operator|->
name|optCookie
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|optCookie
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|++
operator|,
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|pOpts
operator|->
name|pSavedState
operator|!=
name|NULL
condition|)
block|{
name|tOptions
modifier|*
name|p
init|=
operator|(
name|tOptions
operator|*
operator|)
name|pOpts
operator|->
name|pSavedState
decl_stmt|;
name|memcpy
argument_list|(
name|pOpts
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pOpts
operator|->
name|pOptDesc
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|p
operator|->
name|optCt
operator|*
sizeof|sizeof
argument_list|(
name|tOptDesc
argument_list|)
argument_list|)
expr_stmt|;
name|AGFREE
argument_list|(
name|pOpts
operator|->
name|pSavedState
argument_list|)
expr_stmt|;
name|pOpts
operator|->
name|pSavedState
operator|=
name|NULL
expr_stmt|;
goto|goto
name|free_saved_state
goto|;
block|}
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/restore.c */
end_comment

end_unit

