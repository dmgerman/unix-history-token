begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file streqvcmp.c  *  *  String Equivalence Comparison  *  *  These routines allow any character to be mapped to any other  *  character before comparison.  In processing long option names,  *  the characters "-", "_" and "^" all need to be equivalent  *  (because they are treated so by different development environments).  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  *  * This array is designed for mapping upper and lower case letter  * together for a case independent comparison.  The mappings are  * based upon ascii character sequences.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|charmap
index|[]
init|=
block|{
name|NUL
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|'\a'
block|,
literal|'\b'
block|,
literal|'\t'
block|,
name|NL
block|,
literal|'\v'
block|,
literal|'\f'
block|,
literal|'\r'
block|,
literal|0x0E
block|,
literal|0x0F
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1A
block|,
literal|0x1B
block|,
literal|0x1C
block|,
literal|0x1D
block|,
literal|0x1E
block|,
literal|0x1F
block|,
literal|' '
block|,
literal|'!'
block|,
literal|'"'
block|,
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|'&'
block|,
literal|'\''
block|,
literal|'('
block|,
literal|')'
block|,
literal|'*'
block|,
literal|'+'
block|,
literal|','
block|,
literal|'-'
block|,
literal|'.'
block|,
literal|'/'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|':'
block|,
literal|';'
block|,
literal|'<'
block|,
literal|'='
block|,
literal|'>'
block|,
literal|'?'
block|,
literal|'@'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'['
block|,
literal|'\\'
block|,
literal|']'
block|,
literal|'^'
block|,
literal|'_'
block|,
literal|'`'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'{'
block|,
literal|'|'
block|,
literal|'}'
block|,
literal|'~'
block|,
literal|0x7f
block|,
literal|0x80
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8A
block|,
literal|0x8B
block|,
literal|0x8C
block|,
literal|0x8D
block|,
literal|0x8E
block|,
literal|0x8F
block|,
literal|0x90
block|,
literal|0x91
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x9A
block|,
literal|0x9B
block|,
literal|0x9C
block|,
literal|0x9D
block|,
literal|0x9E
block|,
literal|0x9F
block|,
literal|0xA0
block|,
literal|0xA1
block|,
literal|0xA2
block|,
literal|0xA3
block|,
literal|0xA4
block|,
literal|0xA5
block|,
literal|0xA6
block|,
literal|0xA7
block|,
literal|0xA8
block|,
literal|0xA9
block|,
literal|0xAA
block|,
literal|0xAB
block|,
literal|0xAC
block|,
literal|0xAD
block|,
literal|0xAE
block|,
literal|0xAF
block|,
literal|0xB0
block|,
literal|0xB1
block|,
literal|0xB2
block|,
literal|0xB3
block|,
literal|0xB4
block|,
literal|0xB5
block|,
literal|0xB6
block|,
literal|0xB7
block|,
literal|0xB8
block|,
literal|0xB9
block|,
literal|0xBA
block|,
literal|0xBB
block|,
literal|0xBC
block|,
literal|0xBD
block|,
literal|0xBE
block|,
literal|0xBF
block|,
literal|0xC0
block|,
literal|0xC1
block|,
literal|0xC2
block|,
literal|0xC3
block|,
literal|0xC4
block|,
literal|0xC5
block|,
literal|0xC6
block|,
literal|0xC7
block|,
literal|0xC8
block|,
literal|0xC9
block|,
literal|0xCA
block|,
literal|0xCB
block|,
literal|0xCC
block|,
literal|0xCD
block|,
literal|0xCE
block|,
literal|0xCF
block|,
literal|0xD0
block|,
literal|0xD1
block|,
literal|0xD2
block|,
literal|0xD3
block|,
literal|0xD4
block|,
literal|0xD5
block|,
literal|0xD6
block|,
literal|0xD7
block|,
literal|0xD8
block|,
literal|0xD9
block|,
literal|0xDA
block|,
literal|0xDB
block|,
literal|0xDC
block|,
literal|0xDD
block|,
literal|0xDE
block|,
literal|0xDF
block|,
literal|0xE0
block|,
literal|0xE1
block|,
literal|0xE2
block|,
literal|0xE3
block|,
literal|0xE4
block|,
literal|0xE5
block|,
literal|0xE6
block|,
literal|0xE7
block|,
literal|0xE8
block|,
literal|0xE9
block|,
literal|0xEA
block|,
literal|0xEB
block|,
literal|0xEC
block|,
literal|0xED
block|,
literal|0xEE
block|,
literal|0xEF
block|,
literal|0xF0
block|,
literal|0xF1
block|,
literal|0xF2
block|,
literal|0xF3
block|,
literal|0xF4
block|,
literal|0xF5
block|,
literal|0xF6
block|,
literal|0xF7
block|,
literal|0xF8
block|,
literal|0xF9
block|,
literal|0xFA
block|,
literal|0xFB
block|,
literal|0xFC
block|,
literal|0xFD
block|,
literal|0xFE
block|,
literal|0xFF
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*=export_func strneqvcmp  *  * what: compare two strings with an equivalence mapping  *  * arg:  + char const* + str1 + first string +  * arg:  + char const* + str2 + second string +  * arg:  + int         + ct   + compare length +  *  * ret_type:  int  * ret_desc:  the difference between two differing characters  *  * doc:  *  * Using a character mapping, two strings are compared for "equivalence".  * Each input character is mapped to a comparison character and the  * mapped-to characters are compared for the two NUL terminated input strings.  * The comparison is limited to @code{ct} bytes.  * This function name is mapped to option_strneqvcmp so as to not conflict  * with the POSIX name space.  *  * err:  none checked.  Caller responsible for seg faults. =*/
end_comment

begin_function
name|int
name|strneqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
name|s1
parameter_list|,
name|char
specifier|const
modifier|*
name|s2
parameter_list|,
name|int
name|ct
parameter_list|)
block|{
for|for
control|(
init|;
name|ct
operator|>
literal|0
condition|;
operator|--
name|ct
control|)
block|{
name|unsigned
name|char
name|u1
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s1
operator|++
decl_stmt|;
name|unsigned
name|char
name|u2
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s2
operator|++
decl_stmt|;
name|int
name|dif
decl_stmt|;
if|if
condition|(
name|u1
operator|==
name|u2
condition|)
block|{
if|if
condition|(
name|u1
operator|==
name|NUL
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
name|dif
operator|=
name|charmap
index|[
name|u1
index|]
operator|-
name|charmap
index|[
name|u2
index|]
expr_stmt|;
if|if
condition|(
name|dif
operator|!=
literal|0
condition|)
return|return
name|dif
return|;
if|if
condition|(
name|u1
operator|==
name|NUL
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*=export_func streqvcmp  *  * what: compare two strings with an equivalence mapping  *  * arg:  + char const* + str1 + first string +  * arg:  + char const* + str2 + second string +  *  * ret_type:  int  * ret_desc:  the difference between two differing characters  *  * doc:  *  * Using a character mapping, two strings are compared for "equivalence".  * Each input character is mapped to a comparison character and the  * mapped-to characters are compared for the two NUL terminated input strings.  * This function name is mapped to option_streqvcmp so as to not conflict  * with the POSIX name space.  *  * err:  none checked.  Caller responsible for seg faults. =*/
end_comment

begin_function
name|int
name|streqvcmp
parameter_list|(
name|char
specifier|const
modifier|*
name|s1
parameter_list|,
name|char
specifier|const
modifier|*
name|s2
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|char
name|u1
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s1
operator|++
decl_stmt|;
name|unsigned
name|char
name|u2
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s2
operator|++
decl_stmt|;
name|int
name|dif
decl_stmt|;
if|if
condition|(
name|u1
operator|==
name|u2
condition|)
block|{
if|if
condition|(
name|u1
operator|==
name|NUL
condition|)
return|return
literal|0
return|;
continue|continue;
block|}
name|dif
operator|=
name|charmap
index|[
name|u1
index|]
operator|-
name|charmap
index|[
name|u2
index|]
expr_stmt|;
if|if
condition|(
name|dif
operator|!=
literal|0
condition|)
return|return
name|dif
return|;
if|if
condition|(
name|u1
operator|==
name|NUL
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func streqvmap  *  * what: Set the character mappings for the streqv functions  *  * arg:  + char + from + Input character +  * arg:  + char + to   + Mapped-to character +  * arg:  + int  + ct   + compare length +  *  * doc:  *  * Set the character mapping.  If the count (@code{ct}) is set to zero, then  * the map is cleared by setting all entries in the map to their index  * value.  Otherwise, the "@code{From}" character is mapped to the "@code{To}"  * character.  If @code{ct} is greater than 1, then @code{From} and @code{To}  * are incremented and the process repeated until @code{ct} entries have been  * set. For example,  * @example  *    streqvmap('a', 'A', 26);  * @end example  * @noindent  * will alter the mapping so that all English lower case letters  * will map to upper case.  *  * This function name is mapped to option_streqvmap so as to not conflict  * with the POSIX name space.  *  * err:  none. =*/
end_comment

begin_function
name|void
name|streqvmap
parameter_list|(
name|char
name|from
parameter_list|,
name|char
name|to
parameter_list|,
name|int
name|ct
parameter_list|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|ct
operator|=
sizeof|sizeof
argument_list|(
name|charmap
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|charmap
index|[
name|ct
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ct
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ct
operator|>=
literal|0
condition|)
do|;
block|}
else|else
block|{
name|unsigned
name|int
name|i_to
init|=
operator|(
name|int
operator|)
name|to
operator|&
literal|0xFF
decl_stmt|;
name|unsigned
name|int
name|i_from
init|=
operator|(
name|int
operator|)
name|from
operator|&
literal|0xFF
decl_stmt|;
do|do
block|{
name|charmap
index|[
name|i_from
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|i_to
expr_stmt|;
name|i_from
operator|++
expr_stmt|;
name|i_to
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i_from
operator|>=
sizeof|sizeof
argument_list|(
name|charmap
argument_list|)
operator|)
operator|||
operator|(
name|i_to
operator|>=
sizeof|sizeof
argument_list|(
name|charmap
argument_list|)
operator|)
condition|)
break|break;
block|}
do|while
condition|(
operator|--
name|ct
operator|>
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func strequate  *  * what: map a list of characters to the same value  *  * arg:  + char const* + ch_list + characters to equivalence +  *  * doc:  *  * Each character in the input string get mapped to the first character  * in the string.  * This function name is mapped to option_strequate so as to not conflict  * with the POSIX name space.  *  * err:  none. =*/
end_comment

begin_function
name|void
name|strequate
parameter_list|(
name|char
specifier|const
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|s
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
name|NUL
operator|)
condition|)
block|{
name|unsigned
name|char
name|equiv
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NUL
condition|)
name|charmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|s
operator|++
operator|)
index|]
operator|=
name|equiv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*=export_func strtransform  *  * what: convert a string into its mapped-to value  *  * arg:  + char*       + dest + output string +  * arg:  + char const* + src  + input string +  *  * doc:  *  * Each character in the input string is mapped and the mapped-to  * character is put into the output.  * This function name is mapped to option_strtransform so as to not conflict  * with the POSIX name space.  *  * The source and destination may be the same.  *  * err:  none. =*/
end_comment

begin_function
name|void
name|strtransform
parameter_list|(
name|char
modifier|*
name|d
parameter_list|,
name|char
specifier|const
modifier|*
name|s
parameter_list|)
block|{
do|do
block|{
operator|*
operator|(
name|d
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|charmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
name|s
operator|++
operator|)
operator|!=
name|NUL
condition|)
do|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/streqvcmp.c */
end_comment

end_unit

