begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * @file text_mmap.c  *  * Map a text file, ensuring the text always has an ending NUL byte.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_ANONYMOUS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAP_ANON
end_ifdef

begin_define
define|#
directive|define
name|MAP_ANONYMOUS
value|MAP_ANON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_DEV_ZERO
argument_list|)
end_if

begin_comment
comment|/*       * We must have either /dev/zero or anonymous mapping for       * this to work.       */
end_comment

begin_undef
undef|#
directive|undef
name|HAVE_MMAP
end_undef

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_SC_PAGESIZE
end_ifdef

begin_define
define|#
directive|define
name|GETPAGESIZE
parameter_list|()
value|sysconf(_SC_PAGESIZE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GETPAGESIZE
parameter_list|()
value|getpagesize()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Some weird systems require that a specifically invalid FD number  *  get passed in as an argument value.  Which value is that?  Well,  *  as everybody knows, if open(2) fails, it returns -1, so that must  *  be the value.  :)  */
end_comment

begin_define
define|#
directive|define
name|AO_INVALID_FD
value|-1
end_define

begin_define
define|#
directive|define
name|FILE_WRITABLE
parameter_list|(
name|_prt
parameter_list|,
name|_flg
parameter_list|)
define|\
value|(   (_prt& PROT_WRITE) \&& ((_flg& (MAP_SHARED|MAP_PRIVATE)) == MAP_SHARED))
end_define

begin_define
define|#
directive|define
name|MAP_FAILED_PTR
value|((void*)MAP_FAILED)
end_define

begin_comment
comment|/**  * Load the contents of a text file.  There are two separate implementations,  * depending up on whether mmap(3) is available.  *  *  If not available, malloc the file length plus one byte.  Read it in  *  and NUL terminate.  *  *  If available, first check to see if the text file size is a multiple of a  *  page size.  If it is, map the file size plus an extra page from either  *  anonymous memory or from /dev/zero.  Then map the file text on top of the  *  first pages of the anonymous/zero pages.  Otherwise, just map the file  *  because there will be NUL bytes provided at the end.  *  * @param mapinfo a structure holding everything we need to know  *        about the mapping.  *  * @param pzFile name of the file, for error reporting.  */
end_comment

begin_function
specifier|static
name|void
name|load_text_file
parameter_list|(
name|tmap_info_t
modifier|*
name|mapinfo
parameter_list|,
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
name|mapinfo
operator|->
name|txt_data
operator|=
name|AGALOC
argument_list|(
name|mapinfo
operator|->
name|txt_size
operator|+
literal|1
argument_list|,
literal|"file text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|txt_data
operator|==
name|NULL
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
block|{
name|size_t
name|sz
init|=
name|mapinfo
operator|->
name|txt_size
decl_stmt|;
name|char
modifier|*
name|pz
init|=
name|mapinfo
operator|->
name|txt_data
decl_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|ssize_t
name|rdct
init|=
name|read
argument_list|(
name|mapinfo
operator|->
name|txt_fd
argument_list|,
name|pz
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdct
operator|<=
literal|0
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|fserr_warn
argument_list|(
literal|"libopts"
argument_list|,
literal|"read"
argument_list|,
name|pzFile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mapinfo
operator|->
name|txt_data
argument_list|)
expr_stmt|;
return|return;
block|}
name|pz
operator|+=
name|rdct
expr_stmt|;
name|sz
operator|-=
name|rdct
expr_stmt|;
block|}
operator|*
name|pz
operator|=
name|NUL
expr_stmt|;
block|}
name|mapinfo
operator|->
name|txt_errno
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* HAVE mmap */
name|size_t
specifier|const
name|pgsz
init|=
operator|(
name|size_t
operator|)
name|GETPAGESIZE
argument_list|()
decl_stmt|;
name|void
modifier|*
name|map_addr
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|pzFile
expr_stmt|;
name|mapinfo
operator|->
name|txt_full_size
operator|=
operator|(
name|mapinfo
operator|->
name|txt_size
operator|+
name|pgsz
operator|)
operator|&
operator|~
operator|(
name|pgsz
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|txt_full_size
operator|==
operator|(
name|mapinfo
operator|->
name|txt_size
operator|+
name|pgsz
operator|)
condition|)
block|{
comment|/*          * The text is a multiple of a page boundary.  We must map an          * extra page so the text ends with a NUL.          */
if|#
directive|if
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
name|map_addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|mapinfo
operator|->
name|txt_full_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_ANONYMOUS
operator||
name|MAP_PRIVATE
argument_list|,
name|AO_INVALID_FD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|mapinfo
operator|->
name|txt_zero_fd
operator|=
name|open
argument_list|(
literal|"/dev/zero"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|txt_zero_fd
operator|==
name|AO_INVALID_FD
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|map_addr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|mapinfo
operator|->
name|txt_full_size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|mapinfo
operator|->
name|txt_zero_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|map_addr
operator|==
name|MAP_FAILED_PTR
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|mapinfo
operator|->
name|txt_flags
operator||=
name|MAP_FIXED
expr_stmt|;
block|}
name|mapinfo
operator|->
name|txt_data
operator|=
name|mmap
argument_list|(
name|map_addr
argument_list|,
name|mapinfo
operator|->
name|txt_size
argument_list|,
name|mapinfo
operator|->
name|txt_prot
argument_list|,
name|mapinfo
operator|->
name|txt_flags
argument_list|,
name|mapinfo
operator|->
name|txt_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|txt_data
operator|==
name|MAP_FAILED_PTR
condition|)
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MMAP */
block|}
end_function

begin_comment
comment|/**  * Make sure all the parameters are correct:  we have a file name that  * is a text file that we can read.  *  * @param fname the text file to map  * @param prot  the memory protections requested (read/write/etc.)  * @param flags mmap flags  * @param mapinfo a structure holding everything we need to know  *        about the mapping.  */
end_comment

begin_function
specifier|static
name|void
name|validate_mmap
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|flags
parameter_list|,
name|tmap_info_t
modifier|*
name|mapinfo
parameter_list|)
block|{
name|memset
argument_list|(
name|mapinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mapinfo
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
name|mapinfo
operator|->
name|txt_zero_fd
operator|=
name|AO_INVALID_FD
expr_stmt|;
endif|#
directive|endif
name|mapinfo
operator|->
name|txt_fd
operator|=
name|AO_INVALID_FD
expr_stmt|;
name|mapinfo
operator|->
name|txt_prot
operator|=
name|prot
expr_stmt|;
name|mapinfo
operator|->
name|txt_flags
operator|=
name|flags
expr_stmt|;
comment|/*      *  Map mmap flags and protections into open flags and do the open.      */
block|{
comment|/*          *  See if we will be updating the file.  If we can alter the memory          *  and if we share the data and we are *not* copy-on-writing the data,          *  then our updates will show in the file, so we must open with          *  write access.          */
name|int
name|o_flag
init|=
name|FILE_WRITABLE
argument_list|(
name|prot
argument_list|,
name|flags
argument_list|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
decl_stmt|;
comment|/*          *  If you're not sharing the file and you are writing to it,          *  then don't let anyone else have access to the file.          */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|MAP_SHARED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
condition|)
name|o_flag
operator||=
name|O_EXCL
expr_stmt|;
name|mapinfo
operator|->
name|txt_fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|o_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapinfo
operator|->
name|txt_fd
operator|<
literal|0
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|mapinfo
operator|->
name|txt_fd
operator|=
name|AO_INVALID_FD
expr_stmt|;
return|return;
block|}
block|}
comment|/*      *  Make sure we can stat the regular file.  Save the file size.      */
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|mapinfo
operator|->
name|txt_fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|mapinfo
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|close
argument_list|(
name|mapinfo
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapinfo
operator|->
name|txt_size
operator|=
operator|(
name|size_t
operator|)
name|sb
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|mapinfo
operator|->
name|txt_fd
operator|==
name|AO_INVALID_FD
condition|)
name|mapinfo
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Close any files opened by the mapping.  *  * @param mi a structure holding everything we need to know about the map.  */
end_comment

begin_function
specifier|static
name|void
name|close_mmap_files
parameter_list|(
name|tmap_info_t
modifier|*
name|mi
parameter_list|)
block|{
if|if
condition|(
name|mi
operator|->
name|txt_fd
operator|==
name|AO_INVALID_FD
condition|)
return|return;
name|close
argument_list|(
name|mi
operator|->
name|txt_fd
argument_list|)
expr_stmt|;
name|mi
operator|->
name|txt_fd
operator|=
name|AO_INVALID_FD
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAP_ANONYMOUS
argument_list|)
if|if
condition|(
name|mi
operator|->
name|txt_zero_fd
operator|==
name|AO_INVALID_FD
condition|)
return|return;
name|close
argument_list|(
name|mi
operator|->
name|txt_zero_fd
argument_list|)
expr_stmt|;
name|mi
operator|->
name|txt_zero_fd
operator|=
name|AO_INVALID_FD
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*=export_func  text_mmap  * private:  *  * what:  map a text file with terminating NUL  *  * arg:   char const*,  pzFile,  name of the file to map  * arg:   int,          prot,    mmap protections (see mmap(2))  * arg:   int,          flags,   mmap flags (see mmap(2))  * arg:   tmap_info_t*, mapinfo, returned info about the mapping  *  * ret-type:   void*  * ret-desc:   The mmaped data address  *  * doc:  *  * This routine will mmap a file into memory ensuring that there is at least  * one @file{NUL} character following the file data.  It will return the  * address where the file contents have been mapped into memory.  If there is a  * problem, then it will return @code{MAP_FAILED} and set @code{errno}  * appropriately.  *  * The named file does not exist, @code{stat(2)} will set @code{errno} as it  * will.  If the file is not a regular file, @code{errno} will be  * @code{EINVAL}.  At that point, @code{open(2)} is attempted with the access  * bits set appropriately for the requested @code{mmap(2)} protections and flag  * bits.  On failure, @code{errno} will be set according to the documentation  * for @code{open(2)}.  If @code{mmap(2)} fails, @code{errno} will be set as  * that routine sets it.  If @code{text_mmap} works to this point, a valid  * address will be returned, but there may still be ``issues''.  *  * If the file size is not an even multiple of the system page size, then  * @code{text_map} will return at this point and @code{errno} will be zero.  * Otherwise, an anonymous map is attempted.  If not available, then an attempt  * is made to @code{mmap(2)} @file{/dev/zero}.  If any of these fail, the  * address of the file's data is returned, bug @code{no} @file{NUL} characters  * are mapped after the end of the data.  *  * see: mmap(2), open(2), stat(2)  *  * err: Any error code issued by mmap(2), open(2), stat(2) is possible.  *      Additionally, if the specified file is not a regular file, then  *      errno will be set to @code{EINVAL}.  *  * example:  * #include<mylib.h>  * tmap_info_t mi;  * int no_nul;  * void* data = text_mmap("file", PROT_WRITE, MAP_PRIVATE,&mi);  * if (data == MAP_FAILED) return;  * no_nul = (mi.txt_size == mi.txt_full_size);  *<< use the data>>  * text_munmap(&mi); =*/
end_comment

begin_function
name|void
modifier|*
name|text_mmap
parameter_list|(
name|char
specifier|const
modifier|*
name|pzFile
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|flags
parameter_list|,
name|tmap_info_t
modifier|*
name|mi
parameter_list|)
block|{
name|validate_mmap
argument_list|(
name|pzFile
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|mi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|txt_errno
operator|!=
literal|0
condition|)
return|return
name|MAP_FAILED_PTR
return|;
name|load_text_file
argument_list|(
name|mi
argument_list|,
name|pzFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|txt_errno
operator|==
literal|0
condition|)
return|return
name|mi
operator|->
name|txt_data
return|;
name|close_mmap_files
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|errno
operator|=
name|mi
operator|->
name|txt_errno
expr_stmt|;
name|mi
operator|->
name|txt_data
operator|=
name|MAP_FAILED_PTR
expr_stmt|;
return|return
name|mi
operator|->
name|txt_data
return|;
block|}
end_function

begin_comment
comment|/*=export_func  text_munmap  * private:  *  * what:  unmap the data mapped in by text_mmap  *  * arg:   tmap_info_t*, mapinfo, info about the mapping  *  * ret-type:   int  * ret-desc:   -1 or 0.  @code{errno} will have the error code.  *  * doc:  *  * This routine will unmap the data mapped in with @code{text_mmap} and close  * the associated file descriptors opened by that function.  *  * see: munmap(2), close(2)  *  * err: Any error code issued by munmap(2) or close(2) is possible. =*/
end_comment

begin_function
name|int
name|text_munmap
parameter_list|(
name|tmap_info_t
modifier|*
name|mi
parameter_list|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|mi
operator|->
name|txt_data
argument_list|,
name|mi
operator|->
name|txt_full_size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* don't HAVE_MMAP */
comment|/*      *  IF the memory is writable *AND* it is not private (copy-on-write)      *     *AND* the memory is "sharable" (seen by other processes)      *  THEN rewrite the data.  Emulate mmap visibility.      */
if|if
condition|(
name|FILE_WRITABLE
argument_list|(
name|mi
operator|->
name|txt_prot
argument_list|,
name|mi
operator|->
name|txt_flags
argument_list|)
operator|&&
operator|(
name|lseek
argument_list|(
name|mi
operator|->
name|txt_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|write
argument_list|(
name|mi
operator|->
name|txt_fd
argument_list|,
name|mi
operator|->
name|txt_data
argument_list|,
name|mi
operator|->
name|txt_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mi
operator|->
name|txt_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MMAP */
name|mi
operator|->
name|txt_errno
operator|=
name|errno
expr_stmt|;
name|close_mmap_files
argument_list|(
name|mi
argument_list|)
expr_stmt|;
return|return
name|mi
operator|->
name|txt_errno
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/text_mmap.c */
end_comment

end_unit

