begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * \file autoopts.c  *  *  This file contains all of the routines that must be linked into  *  an executable to use the generated option processing.  The optional  *  routines are in separately compiled modules so that they will not  *  necessarily be linked in.  *  * @addtogroup autoopts  * @{  */
end_comment

begin_comment
comment|/*  *  This file is part of AutoOpts, a companion to AutoGen.  *  AutoOpts is free software.  *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved  *  *  AutoOpts is available under any one of two licenses.  The license  *  in use must be one of these two and the choice is under the control  *  of the user of the license.  *  *   The GNU Lesser General Public License, version 3 or later  *      See the files "COPYING.lgplv3" and "COPYING.gplv3"  *  *   The Modified Berkeley Software Distribution License  *      See the file "COPYING.mbsd"  *  *  These files have the following sha256 sums:  *  *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3  *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd  */
end_comment

begin_comment
comment|/**  * The number of tab characters to skip when printing continuation lines.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tab_skip_ct
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PATHFIND
end_ifndef

begin_define
define|#
directive|define
name|pathfind
parameter_list|(
name|_p
parameter_list|,
name|_n
parameter_list|,
name|_m
parameter_list|)
value|option_pathfind(_p, _n, _m)
end_define

begin_include
include|#
directive|include
file|"compat/pathfind.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SNPRINTF
end_ifndef

begin_define
define|#
directive|define
name|vsnprintf
value|option_vsnprintf
end_define

begin_define
define|#
directive|define
name|snprintf
value|option_snprintf
end_define

begin_include
include|#
directive|include
file|"compat/snprintf.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRDUP
end_ifndef

begin_define
define|#
directive|define
name|strdup
parameter_list|(
name|_s
parameter_list|)
value|option_strdup(_s)
end_define

begin_include
include|#
directive|include
file|"compat/strdup.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRCHR
end_ifndef

begin_define
define|#
directive|define
name|strrchr
parameter_list|(
name|_s
parameter_list|,
name|_c
parameter_list|)
value|option_strrchr(_s, _c)
end_define

begin_define
define|#
directive|define
name|strchr
parameter_list|(
name|_s
parameter_list|,
name|_c
parameter_list|)
value|option_strchr(_s, _c)
end_define

begin_include
include|#
directive|include
file|"compat/strchr.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|LOCAL
name|void
modifier|*
name|ao_malloc
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|malloc
argument_list|(
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zalloc_fail
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_define
define|#
directive|define
name|malloc
parameter_list|(
name|_s
parameter_list|)
value|ao_malloc(_s)
end_define

begin_function
name|LOCAL
name|void
modifier|*
name|ao_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
operator|(
name|p
operator|==
name|NULL
operator|)
condition|?
name|malloc
argument_list|(
name|sz
argument_list|)
else|:
name|realloc
argument_list|(
name|p
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zrealloc_fail
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_define
define|#
directive|define
name|realloc
parameter_list|(
name|_p
parameter_list|,
name|_s
parameter_list|)
value|ao_realloc(_p,_s)
end_define

begin_function
name|LOCAL
name|char
modifier|*
name|ao_strdup
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|res
init|=
name|strdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zalloc_fail
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|strdup
end_undef

begin_define
define|#
directive|define
name|strdup
parameter_list|(
name|_p
parameter_list|)
value|ao_strdup(_p)
end_define

begin_comment
comment|/**  *  handle an option.  *  *  This routine handles equivalencing, sets the option state flags and  *  invokes the handler procedure, if any.  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|handle_opt
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
comment|/*      *  Save a copy of the option procedure pointer.      *  If this is an equivalence class option, we still want this proc.      */
name|tOptDesc
modifier|*
name|od
init|=
name|o_st
operator|->
name|pOD
decl_stmt|;
name|tOptProc
modifier|*
name|opt_proc
init|=
name|od
operator|->
name|pOptProc
decl_stmt|;
if|if
condition|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_ALLOC_ARG
condition|)
name|AGFREE
argument_list|(
name|od
operator|->
name|optArg
operator|.
name|argString
argument_list|)
expr_stmt|;
name|od
operator|->
name|optArg
operator|.
name|argString
operator|=
name|o_st
operator|->
name|pzOptArg
expr_stmt|;
comment|/*      *  IF we are presetting options, then we will ignore any un-presettable      *  options.  They are the ones either marked as such.      */
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_PRESETTING
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_NO_INIT
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|PROBLEM
return|;
comment|/*      *  IF this is an equivalence class option,      *  THEN      *      Save the option value that got us to this option      *      entry.  (It may not be od->optChar[0], if this is an      *      equivalence entry.)      *      set the pointer to the equivalence class base      */
if|if
condition|(
name|od
operator|->
name|optEquivIndex
operator|!=
name|NO_EQUIVALENT
condition|)
block|{
name|tOptDesc
modifier|*
name|eqv_od
init|=
name|opts
operator|->
name|pOptDesc
operator|+
name|od
operator|->
name|optEquivIndex
decl_stmt|;
comment|/*          * IF the current option state has not been defined (set on the          *    command line), THEN we will allow continued resetting of          *    the value.  Once "defined", then it must not change.          */
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*              *  The equivalenced-to option has been found on the command              *  line before.  Make sure new occurrences are the same type.              *              *  IF this option has been previously equivalenced and              *     it was not the same equivalenced-to option,              *  THEN we have a usage problem.              */
if|if
condition|(
name|eqv_od
operator|->
name|optActualIndex
operator|!=
name|od
operator|->
name|optIndex
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zmultiway_bug
argument_list|,
name|eqv_od
operator|->
name|pz_Name
argument_list|,
name|od
operator|->
name|pz_Name
argument_list|,
operator|(
name|opts
operator|->
name|pOptDesc
operator|+
name|eqv_od
operator|->
name|optActualIndex
operator|)
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/*              *  Set the equivalenced-to actual option index to no-equivalent              *  so that we set all the entries below.  This option may either              *  never have been selected before, or else it was selected by              *  some sort of "presetting" mechanism.              */
name|eqv_od
operator|->
name|optActualIndex
operator|=
name|NO_EQUIVALENT
expr_stmt|;
block|}
if|if
condition|(
name|eqv_od
operator|->
name|optActualIndex
operator|!=
name|od
operator|->
name|optIndex
condition|)
block|{
comment|/*              *  First time through, copy over the state              *  and add in the equivalence flag              */
name|eqv_od
operator|->
name|optActualValue
operator|=
name|od
operator|->
name|optValue
expr_stmt|;
name|eqv_od
operator|->
name|optActualIndex
operator|=
name|od
operator|->
name|optIndex
expr_stmt|;
name|o_st
operator|->
name|flags
operator||=
name|OPTST_EQUIVALENCE
expr_stmt|;
block|}
comment|/*          *  Copy the most recent option argument.  set membership state          *  is kept in 'eqv_od->optCookie'.  Do not overwrite.          */
name|eqv_od
operator|->
name|optArg
operator|.
name|argString
operator|=
name|od
operator|->
name|optArg
operator|.
name|argString
expr_stmt|;
name|od
operator|=
name|eqv_od
expr_stmt|;
block|}
else|else
block|{
name|od
operator|->
name|optActualValue
operator|=
name|od
operator|->
name|optValue
expr_stmt|;
name|od
operator|->
name|optActualIndex
operator|=
name|od
operator|->
name|optIndex
expr_stmt|;
block|}
name|od
operator|->
name|fOptState
operator|&=
name|OPTST_PERSISTENT_MASK
expr_stmt|;
name|od
operator|->
name|fOptState
operator||=
operator|(
name|o_st
operator|->
name|flags
operator|&
operator|~
name|OPTST_PERSISTENT_MASK
operator|)
expr_stmt|;
comment|/*      *  Keep track of count only for DEFINED (command line) options.      *  IF we have too many, build up an error message and bail.      */
if|if
condition|(
operator|(
name|od
operator|->
name|fOptState
operator|&
name|OPTST_DEFINED
operator|)
operator|&&
operator|(
operator|++
name|od
operator|->
name|optOccCt
operator|>
name|od
operator|->
name|optMaxCt
operator|)
condition|)
return|return
name|too_many_occurrences
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
return|;
comment|/*      *  If provided a procedure to call, call it      */
if|if
condition|(
name|opt_proc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|opt_proc
call|)
argument_list|(
name|opts
argument_list|,
name|od
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  Find the option descriptor and option argument (if any) for the  *  next command line argument.  DO NOT modify the descriptor.  Put  *  all the state in the state argument so that the option can be skipped  *  without consequence (side effect).  *  * @param opts the program option descriptor  * @param o_st  the state of the next found option  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|next_opt
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|tOptState
modifier|*
name|o_st
parameter_list|)
block|{
block|{
name|tSuccess
name|res
init|=
name|find_opt
argument_list|(
name|opts
argument_list|,
name|o_st
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|o_st
operator|->
name|flags
operator|&
name|OPTST_DEFINED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|o_st
operator|->
name|pOD
operator|->
name|fOptState
operator|&
name|OPTST_NO_COMMAND
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|zNotCmdOpt
argument_list|,
name|o_st
operator|->
name|pOD
operator|->
name|pz_Name
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
return|return
name|get_opt_arg
argument_list|(
name|opts
argument_list|,
name|o_st
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Process all the options from our current position onward.  (This allows  * interspersed options and arguments for the few non-standard programs that  * require it.)  Thus, do not rewind option indexes because some programs  * choose to re-invoke after a non-option.  *  *  @param[in,out] opts   program options descriptor  *  @returns SUCCESS or FAILURE  */
end_comment

begin_function
name|LOCAL
name|tSuccess
name|regular_opts
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|)
block|{
comment|/* assert:  opts->fOptSet& OPTPROC_IMMEDIATE == 0 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|tOptState
name|opt_st
init|=
name|OPTSTATE_INITIALIZER
argument_list|(
name|DEFINED
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|next_opt
argument_list|(
name|opts
argument_list|,
operator|&
name|opt_st
argument_list|)
condition|)
block|{
case|case
name|FAILURE
case|:
goto|goto
name|failed_option
goto|;
case|case
name|PROBLEM
case|:
return|return
name|SUCCESS
return|;
comment|/* no more args */
case|case
name|SUCCESS
case|:
break|break;
block|}
comment|/*          *  IF this is an immediate action option,          *  THEN skip it (unless we are supposed to do it a second time).          */
if|if
condition|(
operator|!
name|DO_NORMALLY
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DO_SECOND_TIME
argument_list|(
name|opt_st
operator|.
name|flags
argument_list|)
condition|)
continue|continue;
name|opt_st
operator|.
name|pOD
operator|->
name|optOccCt
operator|--
expr_stmt|;
comment|/* don't count this repetition */
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|handle_opt
argument_list|(
name|opts
argument_list|,
operator|&
name|opt_st
argument_list|)
argument_list|)
condition|)
break|break;
block|}
name|failed_option
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
name|FAILURE
return|;
block|}
end_function

begin_comment
comment|/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  *  *  THESE ROUTINES ARE CALLABLE FROM THE GENERATED OPTION PROCESSING CODE  */
end_comment

begin_comment
comment|/*=--subblock=arg=arg_type,arg_name,arg_desc =*/
end_comment

begin_comment
comment|/*=*  * library:  opts  * header:   your-opts.h  *  * lib_description:  *  *  These are the routines that libopts users may call directly from their  *  code.  There are several other routines that can be called by code  *  generated by the libopts option templates, but they are not to be  *  called from any other user code.  The @file{options.h} header is  *  fairly clear about this, too. =*/
end_comment

begin_comment
comment|/*=export_func optionProcess  *  * what: this is the main option processing routine  *  * arg:  + tOptions* + opts  + program options descriptor +  * arg:  + int       + a_ct  + program arg count  +  * arg:  + char**    + a_v   + program arg vector +  *  * ret_type:  int  * ret_desc:  the count of the arguments processed  *  * doc:  *  * This is the main entry point for processing options.  It is intended  * that this procedure be called once at the beginning of the execution of  * a program.  Depending on options selected earlier, it is sometimes  * necessary to stop and restart option processing, or to select completely  * different sets of options.  This can be done easily, but you generally  * do not want to do this.  *  * The number of arguments processed always includes the program name.  * If one of the arguments is "--", then it is counted and the processing  * stops.  If an error was encountered and errors are to be tolerated, then  * the returned value is the index of the argument causing the error.  * A hyphen by itself ("-") will also cause processing to stop and will  * @emph{not} be counted among the processed arguments.  A hyphen by itself  * is treated as an operand.  Encountering an operand stops option  * processing.  *  * err:  Errors will cause diagnostics to be printed.  @code{exit(3)} may  *       or may not be called.  It depends upon whether or not the options  *       were generated with the "allow-errors" attribute, or if the  *       ERRSKIP_OPTERR or ERRSTOP_OPTERR macros were invoked. =*/
end_comment

begin_function
name|int
name|optionProcess
parameter_list|(
name|tOptions
modifier|*
name|opts
parameter_list|,
name|int
name|a_ct
parameter_list|,
name|char
modifier|*
modifier|*
name|a_v
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|validate_struct
argument_list|(
name|opts
argument_list|,
name|a_v
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|ao_bug
argument_list|(
name|zbad_data_msg
argument_list|)
expr_stmt|;
comment|/*      *  Establish the real program name, the program full path,      *  and do all the presetting the first time thru only.      */
if|if
condition|(
operator|!
name|ao_initialize
argument_list|(
name|opts
argument_list|,
name|a_ct
argument_list|,
name|a_v
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*      *  IF we are (re)starting,      *  THEN reset option location      */
if|if
condition|(
name|opts
operator|->
name|curOptIdx
operator|<=
literal|0
condition|)
block|{
name|opts
operator|->
name|curOptIdx
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pzCurOpt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SUCCESSFUL
argument_list|(
name|regular_opts
argument_list|(
name|opts
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|opts
operator|->
name|origArgCt
return|;
comment|/*      *  IF    there were no errors      *    AND we have RC/INI files      *    AND there is a request to save the files      *  THEN do that now before testing for conflicts.      *       (conflicts are ignored in preset options)      */
switch|switch
condition|(
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
condition|)
block|{
case|case
literal|0
case|:
case|case
name|NO_EQUIVALENT
case|:
break|break;
default|default:
block|{
name|tOptDesc
modifier|*
name|od
init|=
name|opts
operator|->
name|pOptDesc
operator|+
name|opts
operator|->
name|specOptIdx
operator|.
name|save_opts
decl_stmt|;
if|if
condition|(
name|SELECTED_OPT
argument_list|(
name|od
argument_list|)
condition|)
block|{
name|optionSaveFile
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|option_exits
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      *  IF we are checking for errors,      *  THEN look for too few occurrences of required options      */
if|if
condition|(
operator|(
operator|(
name|opts
operator|->
name|fOptSet
operator|&
name|OPTPROC_ERRSTOP
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|is_consistent
argument_list|(
name|opts
argument_list|)
operator|)
condition|)
call|(
modifier|*
name|opts
operator|->
name|pUsageProc
call|)
argument_list|(
name|opts
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|opts
operator|->
name|curOptIdx
return|;
block|}
end_function

begin_comment
comment|/** @}  *  * Local Variables:  * mode: C  * c-file-style: "stroustrup"  * indent-tabs-mode: nil  * End:  * end of autoopts/autoopts.c */
end_comment

end_unit

