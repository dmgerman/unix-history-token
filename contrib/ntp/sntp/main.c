begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<event2/util.h>
end_include

begin_include
include|#
directive|include
file|<event2/event.h>
end_include

begin_include
include|#
directive|include
file|"ntp_workimpl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WORK_THREAD
end_ifdef

begin_include
include|#
directive|include
file|<event2/thread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"ntp_libopts.h"
end_include

begin_include
include|#
directive|include
file|"kod_management.h"
end_include

begin_include
include|#
directive|include
file|"networking.h"
end_include

begin_include
include|#
directive|include
file|"utilities.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"libntp.h"
end_include

begin_decl_stmt
name|int
name|shutting_down
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time_derived
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time_adjusted
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_pending_dns
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_pending_ntp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ai_fam_pref
init|=
name|AF_UNSPEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntpver
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|steplimit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SOCKET
name|sock4
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket for IPv4 */
end_comment

begin_decl_stmt
name|SOCKET
name|sock6
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket for IPv6 */
end_comment

begin_comment
comment|/* ** BCAST *must* listen on port 123 (by default), so we can only ** use the UCST sockets (above) if they too are using port 123 */
end_comment

begin_decl_stmt
name|SOCKET
name|bsock4
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Broadcast Socket for IPv4 */
end_comment

begin_decl_stmt
name|SOCKET
name|bsock6
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Broadcast Socket for IPv6 */
end_comment

begin_decl_stmt
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event
modifier|*
name|ev_sock4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event
modifier|*
name|ev_sock6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event
modifier|*
name|ev_worker_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event
modifier|*
name|ev_xmt_timer
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dns_ctx
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|CTX_BCST
value|0x0001
define|#
directive|define
name|CTX_UCST
value|0x0002
define|#
directive|define
name|CTX_xCST
value|0x0003
define|#
directive|define
name|CTX_CONC
value|0x0004
define|#
directive|define
name|CTX_unused
value|0xfffd
name|int
name|key_id
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|key
modifier|*
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sent_pkt_tag
name|sent_pkt
typedef|;
end_typedef

begin_struct
struct|struct
name|sent_pkt_tag
block|{
name|sent_pkt
modifier|*
name|link
decl_stmt|;
name|struct
name|dns_ctx
modifier|*
name|dctx
decl_stmt|;
name|sockaddr_u
name|addr
decl_stmt|;
name|time_t
name|stime
decl_stmt|;
name|int
name|done
decl_stmt|;
name|struct
name|pkt
name|x_pkt
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|xmt_ctx_tag
name|xmt_ctx
typedef|;
end_typedef

begin_struct
struct|struct
name|xmt_ctx_tag
block|{
name|xmt_ctx
modifier|*
name|link
decl_stmt|;
name|SOCKET
name|sock
decl_stmt|;
name|time_t
name|sched
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|timeval
name|gap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xmt_ctx
modifier|*
name|xmt_q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
modifier|*
name|keys
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|response_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|response_tv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|start_tv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check the timeout at least once per second */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|wakeup_tv
init|=
block|{
literal|0
block|,
literal|888888
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sent_pkt
modifier|*
name|fam_listheads
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|v4_pkts_list
value|(fam_listheads[0])
end_define

begin_define
define|#
directive|define
name|v6_pkts_list
value|(fam_listheads[1])
end_define

begin_union
specifier|static
union|union
block|{
name|struct
name|pkt
name|pkt
decl_stmt|;
name|char
name|buf
index|[
name|LEN_PKT_NOMAC
operator|+
name|NTP_MAXEXTEN
operator|+
name|MAX_MAC_LEN
index|]
decl_stmt|;
block|}
name|rbuf
union|;
end_union

begin_define
define|#
directive|define
name|r_pkt
value|rbuf.pkt
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DROPROOT
end_ifdef

begin_decl_stmt
name|int
name|droproot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* intres imports these */
end_comment

begin_decl_stmt
name|int
name|root_dropped
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_long
name|current_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* libntp/authkeys.c */
end_comment

begin_function_decl
name|void
name|open_sockets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|handle_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sntp_addremove_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|is_pipe
parameter_list|,
name|int
name|remove_it
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|worker_timeout
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|worker_resp_cb
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sntp_name_resolved
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|queue_xmt
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|struct
name|dns_ctx
modifier|*
name|dctx
parameter_list|,
name|sent_pkt
modifier|*
name|spkt
parameter_list|,
name|u_int
name|xmt_delay
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xmt_timer_cb
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xmt
parameter_list|(
name|xmt_ctx
modifier|*
name|xctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_kod
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|timeout_query
parameter_list|(
name|sent_pkt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|timeout_queries
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sock_cb
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|check_exit_conditions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sntp_libevent_log_cb
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|set_li_vn_mode
parameter_list|(
name|struct
name|pkt
modifier|*
name|spkt
parameter_list|,
name|char
name|leap
parameter_list|,
name|char
name|version
parameter_list|,
name|char
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|set_time
parameter_list|(
name|double
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dec_pending_ntp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|sockaddr_u
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|libevent_version_ok
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|gettimeofday_cached
parameter_list|(
name|struct
name|event_base
modifier|*
name|b
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The actual main function.  */
end_comment

begin_function
name|int
name|sntp_main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|sntpVersion
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|exitcode
decl_stmt|;
name|int
name|optct
decl_stmt|;
name|struct
name|event_config
modifier|*
name|evcfg
decl_stmt|;
comment|/* Initialize logging system - sets up progname */
name|sntp_init_logging
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|libevent_version_ok
argument_list|()
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
name|init_lib
argument_list|()
expr_stmt|;
name|init_auth
argument_list|()
expr_stmt|;
name|optct
operator|=
name|ntpOptionProcess
argument_list|(
operator|&
name|sntpOptions
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optct
expr_stmt|;
name|argv
operator|+=
name|optct
expr_stmt|;
name|debug
operator|=
name|OPT_VALUE_SET_DEBUG_LEVEL
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"init_lib() done, %s%s\n"
operator|,
operator|(
name|ipv4_works
operator|)
condition|?
literal|"ipv4_works "
else|:
literal|""
operator|,
operator|(
name|ipv6_works
operator|)
condition|?
literal|"ipv6_works "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|ntpver
operator|=
name|OPT_VALUE_NTPVERSION
expr_stmt|;
name|steplimit
operator|=
name|OPT_VALUE_STEPLIMIT
operator|/
literal|1e3
expr_stmt|;
name|gap
operator|.
name|tv_usec
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|OPT_VALUE_GAP
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|gap
operator|.
name|tv_usec
operator|=
name|min
argument_list|(
name|gap
operator|.
name|tv_usec
argument_list|,
literal|999999
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|LOGFILE
argument_list|)
condition|)
name|open_logfile
argument_list|(
name|OPT_ARG
argument_list|(
name|LOGFILE
argument_list|)
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|sntpVersion
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|argc
operator|&&
operator|!
name|HAVE_OPT
argument_list|(
name|BROADCAST
argument_list|)
operator|&&
operator|!
name|HAVE_OPT
argument_list|(
name|CONCURRENT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Must supply at least one of -b hostname, -c hostname, or hostname.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Eventually, we probably want: 	** - separate bcst and ucst timeouts (why?) 	** - multiple --timeout values in the commandline 	*/
name|response_timeout
operator|=
name|OPT_VALUE_TIMEOUT
expr_stmt|;
name|response_tv
operator|.
name|tv_sec
operator|=
name|response_timeout
expr_stmt|;
name|response_tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* IPv6 available? */
if|if
condition|(
name|isc_net_probeipv6
argument_list|()
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ai_fam_pref
operator|=
name|AF_INET
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"No ipv6 support available, forcing ipv4\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check for options -4 and -6 */
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV4
argument_list|)
condition|)
name|ai_fam_pref
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|IPV6
argument_list|)
condition|)
name|ai_fam_pref
operator|=
name|AF_INET6
expr_stmt|;
block|}
comment|/* TODO: Parse config file if declared */
comment|/* 	** Init the KOD system. 	** For embedded systems with no writable filesystem, 	** -K /dev/null can be used to disable KoD storage. 	*/
name|kod_init_kod_db
argument_list|(
name|OPT_ARG
argument_list|(
name|KOD
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|// HMS: Should we use arg-defalt for this too?
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|KEYFILE
argument_list|)
condition|)
name|auth_init
argument_list|(
name|OPT_ARG
argument_list|(
name|KEYFILE
argument_list|)
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
comment|/* 	** Considering employing a variable that prevents functions of doing 	** anything until everything is initialized properly 	** 	** HMS: What exactly does the above mean? 	*/
name|event_set_log_callback
argument_list|(
operator|&
name|sntp_libevent_log_cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|event_enable_debug_mode
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WORK_THREAD
name|evthread_use_pthreads
argument_list|()
expr_stmt|;
comment|/* we use libevent from main thread only, locks should be academic */
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|evthread_enable_lock_debuging
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|evcfg
operator|=
name|event_config_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|evcfg
condition|)
block|{
name|printf
argument_list|(
literal|"%s: event_config_new() failed!\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifndef|#
directive|ifndef
name|HAVE_SOCKETPAIR
name|event_config_require_features
argument_list|(
name|evcfg
argument_list|,
name|EV_FEATURE_FDS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* all libevent calls are from main thread */
comment|/* event_config_set_flag(evcfg, EVENT_BASE_FLAG_NOLOCK); */
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|evcfg
argument_list|)
expr_stmt|;
name|event_config_free
argument_list|(
name|evcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|base
condition|)
block|{
name|printf
argument_list|(
literal|"%s: event_base_new() failed!\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* wire into intres resolver */
name|worker_per_query
operator|=
name|TRUE
expr_stmt|;
name|addremove_io_fd
operator|=
operator|&
name|sntp_addremove_fd
expr_stmt|;
name|open_sockets
argument_list|()
expr_stmt|;
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|BROADCAST
argument_list|)
condition|)
block|{
name|int
name|cn
init|=
name|STACKCT_OPT
argument_list|(
name|BROADCAST
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
init|=
name|STACKLST_OPT
argument_list|(
name|BROADCAST
argument_list|)
decl_stmt|;
while|while
condition|(
name|cn
operator|--
operator|>
literal|0
condition|)
block|{
name|handle_lookup
argument_list|(
operator|*
name|cp
argument_list|,
name|CTX_BCST
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HAVE_OPT
argument_list|(
name|CONCURRENT
argument_list|)
condition|)
block|{
name|int
name|cn
init|=
name|STACKCT_OPT
argument_list|(
name|CONCURRENT
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
init|=
name|STACKLST_OPT
argument_list|(
name|CONCURRENT
argument_list|)
decl_stmt|;
while|while
condition|(
name|cn
operator|--
operator|>
literal|0
condition|)
block|{
name|handle_lookup
argument_list|(
operator|*
name|cp
argument_list|,
name|CTX_UCST
operator||
name|CTX_CONC
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|handle_lookup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|CTX_UCST
argument_list|)
expr_stmt|;
name|gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|start_tv
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|time_adjusted
operator|&&
operator|(
name|ENABLED_OPT
argument_list|(
name|STEP
argument_list|)
operator|||
name|ENABLED_OPT
argument_list|(
name|SLEW
argument_list|)
operator|)
condition|)
name|exitcode
operator|=
literal|1
expr_stmt|;
else|else
name|exitcode
operator|=
literal|0
expr_stmt|;
return|return
name|exitcode
return|;
block|}
end_function

begin_comment
comment|/* ** open sockets and make them non-blocking */
end_comment

begin_function
name|void
name|open_sockets
parameter_list|(
name|void
parameter_list|)
block|{
name|sockaddr_u
name|name
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|sock4
condition|)
block|{
name|sock4
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|sock4
condition|)
block|{
comment|/* error getting a socket */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: socket(PF_INET) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make it non-blocking */
name|make_socket_nonblocking
argument_list|(
name|sock4
argument_list|)
expr_stmt|;
comment|/* Let's try using a wildcard... */
name|ZERO
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|name
argument_list|)
operator|=
name|AF_INET
expr_stmt|;
name|SET_ADDR4N
argument_list|(
operator|&
name|name
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|name
argument_list|,
operator|(
name|HAVE_OPT
argument_list|(
name|USERESERVEDPORT
argument_list|)
condition|?
literal|123
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|bind
argument_list|(
name|sock4
argument_list|,
operator|&
name|name
operator|.
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: bind(sock4) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Register an NTP callback for recv/timeout */
name|ev_sock4
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|sock4
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
operator|&
name|sock_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ev_sock4
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: event_new(base, sock4) failed!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_add
argument_list|(
name|ev_sock4
argument_list|,
operator|&
name|wakeup_tv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We may not always have IPv6... */
if|if
condition|(
operator|-
literal|1
operator|==
name|sock6
operator|&&
name|ipv6_works
condition|)
block|{
name|sock6
operator|=
name|socket
argument_list|(
name|PF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|sock6
operator|&&
name|ipv6_works
condition|)
block|{
comment|/* error getting a socket */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: socket(PF_INET6) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make it non-blocking */
name|make_socket_nonblocking
argument_list|(
name|sock6
argument_list|)
expr_stmt|;
comment|/* Let's try using a wildcard... */
name|ZERO
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|AF
argument_list|(
operator|&
name|name
argument_list|)
operator|=
name|AF_INET6
expr_stmt|;
name|SET_ADDR6N
argument_list|(
operator|&
name|name
argument_list|,
name|in6addr_any
argument_list|)
expr_stmt|;
name|SET_PORT
argument_list|(
operator|&
name|name
argument_list|,
operator|(
name|HAVE_OPT
argument_list|(
name|USERESERVEDPORT
argument_list|)
condition|?
literal|123
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|bind
argument_list|(
name|sock6
argument_list|,
operator|&
name|name
operator|.
name|sa
argument_list|,
name|SOCKLEN
argument_list|(
operator|&
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: bind(sock6) failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Register an NTP callback for recv/timeout */
name|ev_sock6
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|sock6
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
operator|&
name|sock_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ev_sock6
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open_sockets: event_new(base, sock6) failed!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_add
argument_list|(
name|ev_sock6
argument_list|,
operator|&
name|wakeup_tv
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* ** handle_lookup */
end_comment

begin_function
name|void
name|handle_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* Local copy is OK */
name|struct
name|dns_ctx
modifier|*
name|ctx
decl_stmt|;
name|long
name|l
decl_stmt|;
name|char
modifier|*
name|name_copy
decl_stmt|;
name|size_t
name|name_sz
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"handle_lookup(%s,%#x)\n"
operator|,
name|name
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|ZERO
argument_list|(
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|ai_fam_pref
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
operator||
name|Z_AI_NUMERICSERV
expr_stmt|;
comment|/* 	** Unless we specify a socktype, we'll get at least two 	** entries for each address: one for TCP and one for 	** UDP. That's not what we want. 	*/
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|name_sz
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|octets
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
operator|+
name|name_sz
expr_stmt|;
comment|// Space for a ctx and the name
name|ctx
operator|=
name|emalloc_zero
argument_list|(
name|octets
argument_list|)
expr_stmt|;
comment|// ctx at ctx[0]
name|name_copy
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ctx
operator|+
literal|1
operator|)
expr_stmt|;
comment|// Put the name at ctx[1]
name|memcpy
argument_list|(
name|name_copy
argument_list|,
name|name
argument_list|,
name|name_sz
argument_list|)
expr_stmt|;
comment|// copy the name to ctx[1]
name|ctx
operator|->
name|name
operator|=
name|name_copy
expr_stmt|;
comment|// point to it...
name|ctx
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ctx
operator|->
name|timeout
operator|=
name|response_tv
expr_stmt|;
comment|/* The following should arguably be passed in... */
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|AUTHENTICATION
argument_list|)
operator|&&
name|atoint
argument_list|(
name|OPT_ARG
argument_list|(
name|AUTHENTICATION
argument_list|)
argument_list|,
operator|&
name|l
argument_list|)
condition|)
block|{
name|ctx
operator|->
name|key_id
operator|=
name|l
expr_stmt|;
name|get_key
argument_list|(
name|ctx
operator|->
name|key_id
argument_list|,
operator|&
name|ctx
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|key_id
operator|=
operator|-
literal|1
expr_stmt|;
name|ctx
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|n_pending_dns
expr_stmt|;
name|getaddrinfo_sometime
argument_list|(
name|name
argument_list|,
literal|"123"
argument_list|,
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
operator|&
name|sntp_name_resolved
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** DNS Callback: ** - For each IP: ** - - open a socket ** - - increment n_pending_ntp ** - - send a request if this is a Unicast callback ** - - queue wait for response ** - decrement n_pending_dns */
end_comment

begin_function
name|void
name|sntp_name_resolved
parameter_list|(
name|int
name|rescode
parameter_list|,
name|int
name|gai_errno
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|service
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|dns_ctx
modifier|*
name|dctx
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|SOCKET
name|sock
decl_stmt|;
name|u_int
name|xmt_delay_v4
decl_stmt|;
name|u_int
name|xmt_delay_v6
decl_stmt|;
name|u_int
name|xmt_delay
decl_stmt|;
name|size_t
name|octets
decl_stmt|;
name|xmt_delay_v4
operator|=
literal|0
expr_stmt|;
name|xmt_delay_v6
operator|=
literal|0
expr_stmt|;
name|dctx
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|rescode
condition|)
block|{
ifdef|#
directive|ifdef
name|EAI_SYSTEM
if|if
condition|(
name|EAI_SYSTEM
operator|==
name|rescode
condition|)
block|{
name|errno
operator|=
name|gai_errno
expr_stmt|;
name|mfprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s lookup error %m\n"
argument_list|,
name|dctx
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s lookup error %s\n"
argument_list|,
name|dctx
operator|->
name|name
argument_list|,
name|gai_strerror
argument_list|(
name|rescode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s [%s]\n"
operator|,
name|dctx
operator|->
name|name
operator|,
operator|(
name|addr
operator|->
name|ai_canonname
operator|!=
name|NULL
operator|)
condition|?
name|addr
operator|->
name|ai_canonname
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|addr
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|check_kod
argument_list|(
name|ai
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sock
operator|=
name|sock4
expr_stmt|;
name|xmt_delay
operator|=
name|xmt_delay_v4
expr_stmt|;
name|xmt_delay_v4
operator|++
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|!
name|ipv6_works
condition|)
continue|continue;
name|sock
operator|=
name|sock6
expr_stmt|;
name|xmt_delay
operator|=
name|xmt_delay_v6
expr_stmt|;
name|xmt_delay_v6
operator|++
expr_stmt|;
break|break;
default|default:
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sntp_name_resolved: unexpected ai_family: %d"
argument_list|,
name|ai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			** We're waiting for a response for either unicast 			** or broadcast, so... 			*/
operator|++
name|n_pending_ntp
expr_stmt|;
comment|/* If this is for a unicast IP, queue a request */
if|if
condition|(
name|dctx
operator|->
name|flags
operator|&
name|CTX_UCST
condition|)
block|{
name|spkt
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|spkt
argument_list|)
argument_list|)
expr_stmt|;
name|spkt
operator|->
name|dctx
operator|=
name|dctx
expr_stmt|;
name|octets
operator|=
name|min
argument_list|(
name|ai
operator|->
name|ai_addrlen
argument_list|,
sizeof|sizeof
argument_list|(
name|spkt
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|spkt
operator|->
name|addr
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|queue_xmt
argument_list|(
name|sock
argument_list|,
name|dctx
argument_list|,
name|spkt
argument_list|,
name|xmt_delay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* n_pending_dns really should be>0 here... */
operator|--
name|n_pending_dns
expr_stmt|;
name|check_exit_conditions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** queue_xmt */
end_comment

begin_function
name|void
name|queue_xmt
parameter_list|(
name|SOCKET
name|sock
parameter_list|,
name|struct
name|dns_ctx
modifier|*
name|dctx
parameter_list|,
name|sent_pkt
modifier|*
name|spkt
parameter_list|,
name|u_int
name|xmt_delay
parameter_list|)
block|{
name|sockaddr_u
modifier|*
name|dest
decl_stmt|;
name|sent_pkt
modifier|*
modifier|*
name|pkt_listp
decl_stmt|;
name|sent_pkt
modifier|*
name|match
decl_stmt|;
name|xmt_ctx
modifier|*
name|xctx
decl_stmt|;
name|struct
name|timeval
name|start_cb
decl_stmt|;
name|struct
name|timeval
name|delay
decl_stmt|;
name|dest
operator|=
operator|&
name|spkt
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|IS_IPV6
argument_list|(
name|dest
argument_list|)
condition|)
name|pkt_listp
operator|=
operator|&
name|v6_pkts_list
expr_stmt|;
else|else
name|pkt_listp
operator|=
operator|&
name|v4_pkts_list
expr_stmt|;
comment|/* reject attempts to add address already listed */
for|for
control|(
name|match
operator|=
operator|*
name|pkt_listp
init|;
name|match
operator|!=
name|NULL
condition|;
name|match
operator|=
name|match
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ADDR_PORT_EQ
argument_list|(
operator|&
name|spkt
operator|->
name|addr
argument_list|,
operator|&
name|match
operator|->
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|,
name|match
operator|->
name|dctx
operator|->
name|name
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s %s duplicate address from %s ignored.\n"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|match
operator|->
name|addr
argument_list|)
argument_list|,
name|match
operator|->
name|dctx
operator|->
name|name
argument_list|,
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s %s, duplicate address ignored.\n"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|match
operator|->
name|addr
argument_list|)
argument_list|,
name|match
operator|->
name|dctx
operator|->
name|name
argument_list|)
expr_stmt|;
name|dec_pending_ntp
argument_list|(
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|,
operator|&
name|spkt
operator|->
name|addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|spkt
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|LINK_SLIST
argument_list|(
operator|*
name|pkt_listp
argument_list|,
name|spkt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|xctx
operator|=
name|emalloc_zero
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xctx
argument_list|)
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|sock
operator|=
name|sock
expr_stmt|;
name|xctx
operator|->
name|spkt
operator|=
name|spkt
expr_stmt|;
name|gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|start_cb
argument_list|)
expr_stmt|;
name|xctx
operator|->
name|sched
operator|=
name|start_cb
operator|.
name|tv_sec
operator|+
operator|(
literal|2
operator|*
name|xmt_delay
operator|)
expr_stmt|;
name|LINK_SORT_SLIST
argument_list|(
name|xmt_q
argument_list|,
name|xctx
argument_list|,
operator|(
name|xctx
operator|->
name|sched
operator|<
name|L_S_S_CUR
argument_list|()
operator|->
name|sched
operator|)
argument_list|,
name|link
argument_list|,
name|xmt_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmt_q
operator|==
name|xctx
condition|)
block|{
comment|/* 		 * The new entry is the first scheduled.  The timer is 		 * either not active or is set for the second xmt 		 * context in xmt_q. 		 */
if|if
condition|(
name|NULL
operator|==
name|ev_xmt_timer
condition|)
name|ev_xmt_timer
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|INVALID_SOCKET
argument_list|,
name|EV_TIMEOUT
argument_list|,
operator|&
name|xmt_timer_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ev_xmt_timer
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"queue_xmt: event_new(base, -1, EV_TIMEOUT) failed!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ZERO
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|xctx
operator|->
name|sched
operator|>
name|start_cb
operator|.
name|tv_sec
condition|)
name|delay
operator|.
name|tv_sec
operator|=
name|xctx
operator|->
name|sched
operator|-
name|start_cb
operator|.
name|tv_sec
expr_stmt|;
name|event_add
argument_list|(
name|ev_xmt_timer
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"queue_xmt: xmt timer for %u usec\n"
operator|,
operator|(
name|u_int
operator|)
name|delay
operator|.
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** xmt_timer_cb */
end_comment

begin_function
name|void
name|xmt_timer_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|timeval
name|start_cb
decl_stmt|;
name|struct
name|timeval
name|delay
decl_stmt|;
name|xmt_ctx
modifier|*
name|x
decl_stmt|;
name|UNUSED_ARG
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
name|EV_TIMEOUT
operator|==
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|xmt_q
operator|||
name|shutting_down
condition|)
return|return;
name|gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|start_cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmt_q
operator|->
name|sched
operator|<=
name|start_cb
operator|.
name|tv_sec
condition|)
block|{
name|UNLINK_HEAD_SLIST
argument_list|(
name|x
argument_list|,
name|xmt_q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"xmt_timer_cb: at .%6.6u -> %s\n"
operator|,
operator|(
name|u_int
operator|)
name|start_cb
operator|.
name|tv_usec
operator|,
name|stoa
argument_list|(
operator|&
name|x
operator|->
name|spkt
operator|->
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|xmt
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|xmt_q
condition|)
return|return;
block|}
if|if
condition|(
name|xmt_q
operator|->
name|sched
operator|<=
name|start_cb
operator|.
name|tv_sec
condition|)
block|{
name|event_add
argument_list|(
name|ev_xmt_timer
argument_list|,
operator|&
name|gap
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"xmt_timer_cb: at .%6.6u gap %6.6u\n"
operator|,
operator|(
name|u_int
operator|)
name|start_cb
operator|.
name|tv_usec
operator|,
operator|(
name|u_int
operator|)
name|gap
operator|.
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delay
operator|.
name|tv_sec
operator|=
name|xmt_q
operator|->
name|sched
operator|-
name|start_cb
operator|.
name|tv_sec
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|event_add
argument_list|(
name|ev_xmt_timer
argument_list|,
operator|&
name|delay
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"xmt_timer_cb: at .%6.6u next %ld seconds\n"
operator|,
operator|(
name|u_int
operator|)
name|start_cb
operator|.
name|tv_usec
operator|,
operator|(
name|long
operator|)
name|delay
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** xmt() */
end_comment

begin_function
name|void
name|xmt
parameter_list|(
name|xmt_ctx
modifier|*
name|xctx
parameter_list|)
block|{
name|SOCKET
name|sock
init|=
name|xctx
operator|->
name|sock
decl_stmt|;
name|struct
name|dns_ctx
modifier|*
name|dctx
init|=
name|xctx
operator|->
name|spkt
operator|->
name|dctx
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt
init|=
name|xctx
operator|->
name|spkt
decl_stmt|;
name|sockaddr_u
modifier|*
name|dst
init|=
operator|&
name|spkt
operator|->
name|addr
decl_stmt|;
name|struct
name|timeval
name|tv_xmt
decl_stmt|;
name|struct
name|pkt
name|x_pkt
decl_stmt|;
name|size_t
name|pkt_len
decl_stmt|;
name|int
name|sent
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|gettimeofday
argument_list|(
operator|&
name|tv_xmt
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"xmt: gettimeofday() failed: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tv_xmt
operator|.
name|tv_sec
operator|+=
name|JAN_1970
expr_stmt|;
name|pkt_len
operator|=
name|generate_pkt
argument_list|(
operator|&
name|x_pkt
argument_list|,
operator|&
name|tv_xmt
argument_list|,
name|dctx
operator|->
name|key_id
argument_list|,
name|dctx
operator|->
name|key
argument_list|)
expr_stmt|;
name|sent
operator|=
name|sendpkt
argument_list|(
name|sock
argument_list|,
name|dst
argument_list|,
operator|&
name|x_pkt
argument_list|,
name|pkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
comment|/* Save the packet we sent... */
name|memcpy
argument_list|(
operator|&
name|spkt
operator|->
name|x_pkt
argument_list|,
operator|&
name|x_pkt
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|spkt
operator|->
name|x_pkt
argument_list|)
argument_list|,
name|pkt_len
argument_list|)
argument_list|)
expr_stmt|;
name|spkt
operator|->
name|stime
operator|=
name|tv_xmt
operator|.
name|tv_sec
operator|-
name|JAN_1970
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"xmt: %lx.%6.6u %s %s\n"
operator|,
operator|(
name|u_long
operator|)
name|tv_xmt
operator|.
name|tv_sec
operator|,
operator|(
name|u_int
operator|)
name|tv_xmt
operator|.
name|tv_usec
operator|,
name|dctx
operator|->
name|name
operator|,
name|stoa
argument_list|(
name|dst
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dec_pending_ntp
argument_list|(
name|dctx
operator|->
name|name
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * timeout_queries() -- give up on unrequited NTP queries  */
end_comment

begin_function
name|void
name|timeout_queries
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|start_cb
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|sent_pkt
modifier|*
name|head
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt_next
decl_stmt|;
name|long
name|age
decl_stmt|;
name|int
name|didsomething
init|=
literal|0
decl_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"timeout_queries: called to check %u items\n"
operator|,
operator|(
name|unsigned
operator|)
name|COUNTOF
argument_list|(
name|fam_listheads
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|start_cb
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|COUNTOF
argument_list|(
name|fam_listheads
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|head
operator|=
name|fam_listheads
index|[
name|idx
index|]
expr_stmt|;
for|for
control|(
name|spkt
operator|=
name|head
init|;
name|spkt
operator|!=
name|NULL
condition|;
name|spkt
operator|=
name|spkt_next
control|)
block|{
name|char
name|xcst
decl_stmt|;
name|didsomething
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|spkt
operator|->
name|dctx
operator|->
name|flags
operator|&
name|CTX_xCST
condition|)
block|{
case|case
name|CTX_BCST
case|:
name|xcst
operator|=
literal|'B'
expr_stmt|;
break|break;
case|case
name|CTX_UCST
case|:
name|xcst
operator|=
literal|'U'
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
operator|!
literal|"spkt->dctx->flags neither UCST nor BCST"
argument_list|)
expr_stmt|;
break|break;
block|}
name|spkt_next
operator|=
name|spkt
operator|->
name|link
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|spkt
operator|->
name|stime
operator|||
name|spkt
operator|->
name|done
condition|)
continue|continue;
name|age
operator|=
name|start_cb
operator|.
name|tv_sec
operator|-
name|spkt
operator|->
name|stime
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"%s %s %cCST age %ld\n"
operator|,
name|stoa
argument_list|(
operator|&
name|spkt
operator|->
name|addr
argument_list|)
operator|,
name|spkt
operator|->
name|dctx
operator|->
name|name
operator|,
name|xcst
operator|,
name|age
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>
name|response_timeout
condition|)
name|timeout_query
argument_list|(
name|spkt
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Do we care about didsomething?
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"timeout_queries: didsomething is %d, age is %ld\n"
operator|,
name|didsomething
operator|,
call|(
name|long
call|)
argument_list|(
name|start_cb
operator|.
name|tv_sec
operator|-
name|start_tv
operator|.
name|tv_sec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_cb
operator|.
name|tv_sec
operator|-
name|start_tv
operator|.
name|tv_sec
operator|>
name|response_timeout
condition|)
block|{
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"timeout_queries: bail!\n"
operator|)
argument_list|)
expr_stmt|;
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shutting_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dec_pending_ntp
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|sockaddr_u
modifier|*
name|server
parameter_list|)
block|{
if|if
condition|(
name|n_pending_ntp
operator|>
literal|0
condition|)
block|{
operator|--
name|n_pending_ntp
expr_stmt|;
name|check_exit_conditions
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
literal|0
operator|==
name|n_pending_ntp
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"n_pending_ntp was zero before decrement for %s\n"
operator|,
name|hostnameaddr
argument_list|(
name|name
argument_list|,
name|server
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|timeout_query
parameter_list|(
name|sent_pkt
modifier|*
name|spkt
parameter_list|)
block|{
name|sockaddr_u
modifier|*
name|server
decl_stmt|;
name|char
name|xcst
decl_stmt|;
switch|switch
condition|(
name|spkt
operator|->
name|dctx
operator|->
name|flags
operator|&
name|CTX_xCST
condition|)
block|{
case|case
name|CTX_BCST
case|:
name|xcst
operator|=
literal|'B'
expr_stmt|;
break|break;
case|case
name|CTX_UCST
case|:
name|xcst
operator|=
literal|'U'
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
operator|!
literal|"spkt->dctx->flags neither UCST nor BCST"
argument_list|)
expr_stmt|;
break|break;
block|}
name|spkt
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|server
operator|=
operator|&
name|spkt
operator|->
name|addr
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s no %cCST response after %d seconds"
argument_list|,
name|hostnameaddr
argument_list|(
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|,
name|server
argument_list|)
argument_list|,
name|xcst
argument_list|,
name|response_timeout
argument_list|)
expr_stmt|;
name|dec_pending_ntp
argument_list|(
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* ** check_kod */
end_comment

begin_function
name|int
name|check_kod
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|struct
name|kod_entry
modifier|*
name|reason
decl_stmt|;
comment|/* Is there a KoD on file for this address? */
name|hostname
operator|=
name|addrinfo_to_str
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"check_kod: checking<%s>\n"
operator|,
name|hostname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_entry
argument_list|(
name|hostname
argument_list|,
operator|&
name|reason
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"prior KoD for %s, skipping.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reason
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Socket readable/timeout Callback: ** Read in the packet ** Unicast: ** - close socket ** - decrement n_pending_ntp ** - If packet is good, set the time and "exit" ** Broadcast: ** - If packet is good, set the time and "exit" */
end_comment

begin_function
name|void
name|sock_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|sockaddr_u
name|sender
decl_stmt|;
name|sockaddr_u
modifier|*
name|psau
decl_stmt|;
name|sent_pkt
modifier|*
modifier|*
name|p_pktlist
decl_stmt|;
name|sent_pkt
modifier|*
name|spkt
decl_stmt|;
name|int
name|rpktl
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|INSIST
argument_list|(
name|sock4
operator|==
name|fd
operator|||
name|sock6
operator|==
name|fd
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"sock_cb: event on sock%s:%s%s%s%s\n"
operator|,
operator|(
name|fd
operator|==
name|sock6
operator|)
condition|?
literal|"6"
else|:
literal|"4"
operator|,
operator|(
name|what
operator|&
name|EV_TIMEOUT
operator|)
condition|?
literal|" timeout"
else|:
literal|""
operator|,
operator|(
name|what
operator|&
name|EV_READ
operator|)
condition|?
literal|" read"
else|:
literal|""
operator|,
operator|(
name|what
operator|&
name|EV_WRITE
operator|)
condition|?
literal|" write"
else|:
literal|""
operator|,
operator|(
name|what
operator|&
name|EV_SIGNAL
operator|)
condition|?
literal|" signal"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|EV_READ
operator|&
name|what
operator|)
condition|)
block|{
if|if
condition|(
name|EV_TIMEOUT
operator|&
name|what
condition|)
name|timeout_queries
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Read in the packet */
name|rpktl
operator|=
name|recvdata
argument_list|(
name|fd
argument_list|,
operator|&
name|sender
argument_list|,
operator|&
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpktl
operator|<
literal|0
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"recvfrom error %m"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sock6
operator|==
name|fd
condition|)
name|p_pktlist
operator|=
operator|&
name|v6_pkts_list
expr_stmt|;
else|else
name|p_pktlist
operator|=
operator|&
name|v4_pkts_list
expr_stmt|;
for|for
control|(
name|spkt
operator|=
operator|*
name|p_pktlist
init|;
name|spkt
operator|!=
name|NULL
condition|;
name|spkt
operator|=
name|spkt
operator|->
name|link
control|)
block|{
name|psau
operator|=
operator|&
name|spkt
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|SOCK_EQ
argument_list|(
operator|&
name|sender
argument_list|,
name|psau
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|NULL
operator|==
name|spkt
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Packet from unexpected source %s dropped"
argument_list|,
name|sptoa
argument_list|(
operator|&
name|sender
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sock_cb: %s %s\n"
operator|,
name|spkt
operator|->
name|dctx
operator|->
name|name
operator|,
name|sptoa
argument_list|(
operator|&
name|sender
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|rpktl
operator|=
name|process_pkt
argument_list|(
operator|&
name|r_pkt
argument_list|,
operator|&
name|sender
argument_list|,
name|rpktl
argument_list|,
name|MODE_SERVER
argument_list|,
operator|&
name|spkt
operator|->
name|x_pkt
argument_list|,
literal|"sock_cb"
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"sock_cb: process_pkt returned %d\n"
operator|,
name|rpktl
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a Unicast packet, one down ... */
if|if
condition|(
operator|!
name|spkt
operator|->
name|done
operator|&&
operator|(
name|CTX_UCST
operator|&
name|spkt
operator|->
name|dctx
operator|->
name|flags
operator|)
condition|)
block|{
name|dec_pending_ntp
argument_list|(
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|,
operator|&
name|spkt
operator|->
name|addr
argument_list|)
expr_stmt|;
name|spkt
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the packet is good, set the time and we're all done */
name|rc
operator|=
name|handle_pkt
argument_list|(
name|rpktl
argument_list|,
operator|&
name|r_pkt
argument_list|,
operator|&
name|spkt
operator|->
name|addr
argument_list|,
name|spkt
operator|->
name|dctx
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|rc
condition|)
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"sock_cb: handle_pkt() returned %d\n"
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
name|check_exit_conditions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check_exit_conditions()  *  * If sntp has a reply, ask the event loop to stop after this round of  * callbacks, unless --wait was used.  */
end_comment

begin_function
name|void
name|check_exit_conditions
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
literal|0
operator|==
name|n_pending_ntp
operator|&&
literal|0
operator|==
name|n_pending_dns
operator|)
operator|||
operator|(
name|time_derived
operator|&&
operator|!
name|HAVE_OPT
argument_list|(
name|WAIT
argument_list|)
operator|)
condition|)
block|{
name|event_base_loopexit
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shutting_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|TRACE
argument_list|(
literal|2
argument_list|,
operator|(
literal|"%d NTP and %d name queries pending\n"
operator|,
name|n_pending_ntp
operator|,
name|n_pending_dns
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * sntp_addremove_fd() is invoked by the intres blocking worker code  * to read from a pipe, or to stop same.  */
end_comment

begin_function
name|void
name|sntp_addremove_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|is_pipe
parameter_list|,
name|int
name|remove_it
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|;
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKETPAIR
if|if
condition|(
name|is_pipe
condition|)
block|{
comment|/* sntp only asks for EV_FEATURE_FDS without HAVE_SOCKETPAIR */
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fatal: pipes not supported on systems with socketpair()"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|c
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|blocking_children_alloc
condition|;
name|idx
operator|++
control|)
block|{
name|c
operator|=
name|blocking_children
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|c
condition|)
continue|continue;
if|if
condition|(
name|fd
operator|==
name|c
operator|->
name|resp_read_pipe
condition|)
break|break;
block|}
if|if
condition|(
name|idx
operator|==
name|blocking_children_alloc
condition|)
return|return;
if|if
condition|(
name|remove_it
condition|)
block|{
name|ev
operator|=
name|c
operator|->
name|resp_read_ctx
expr_stmt|;
name|c
operator|->
name|resp_read_ctx
operator|=
name|NULL
expr_stmt|;
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|ev
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
operator|&
name|worker_resp_cb
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ev
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sntp_addremove_fd: event_new(base, fd) failed!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|->
name|resp_read_ctx
operator|=
name|ev
expr_stmt|;
name|event_add
argument_list|(
name|ev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called by forked intres child to close open descriptors */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WORK_FORK
end_ifdef

begin_function
name|void
name|kill_asyncio
parameter_list|(
name|int
name|startfd
parameter_list|)
block|{
if|if
condition|(
name|INVALID_SOCKET
operator|!=
name|sock4
condition|)
block|{
name|closesocket
argument_list|(
name|sock4
argument_list|)
expr_stmt|;
name|sock4
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
if|if
condition|(
name|INVALID_SOCKET
operator|!=
name|sock6
condition|)
block|{
name|closesocket
argument_list|(
name|sock6
argument_list|)
expr_stmt|;
name|sock6
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
if|if
condition|(
name|INVALID_SOCKET
operator|!=
name|bsock4
condition|)
block|{
name|closesocket
argument_list|(
name|sock4
argument_list|)
expr_stmt|;
name|sock4
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
if|if
condition|(
name|INVALID_SOCKET
operator|!=
name|bsock6
condition|)
block|{
name|closesocket
argument_list|(
name|sock6
argument_list|)
expr_stmt|;
name|sock6
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * worker_resp_cb() is invoked when resp_read_pipe is readable.  */
end_comment

begin_function
name|void
name|worker_resp_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
comment|/* blocking_child * */
parameter_list|)
block|{
name|blocking_child
modifier|*
name|c
decl_stmt|;
name|DEBUG_INSIST
argument_list|(
name|EV_READ
operator|&
name|what
argument_list|)
expr_stmt|;
name|c
operator|=
name|ctx
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
name|fd
operator|==
name|c
operator|->
name|resp_read_pipe
argument_list|)
expr_stmt|;
name|process_blocking_resp
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * intres_timeout_req(s) is invoked in the parent to schedule an idle  * timeout to fire in s seconds, if not reset earlier by a call to  * intres_timeout_req(0), which clears any pending timeout.  When the  * timeout expires, worker_idle_timer_fired() is invoked (again, in the  * parent).  *  * sntp and ntpd each provide implementations adapted to their timers.  */
end_comment

begin_function
name|void
name|intres_timeout_req
parameter_list|(
name|u_int
name|seconds
comment|/* 0 cancels */
parameter_list|)
block|{
name|struct
name|timeval
name|tv_to
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ev_worker_timeout
condition|)
block|{
name|ev_worker_timeout
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
operator||
name|EV_PERSIST
argument_list|,
operator|&
name|worker_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DEBUG_INSIST
argument_list|(
name|NULL
operator|!=
name|ev_worker_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_del
argument_list|(
name|ev_worker_timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|seconds
condition|)
return|return;
name|tv_to
operator|.
name|tv_sec
operator|=
name|seconds
expr_stmt|;
name|tv_to
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|event_add
argument_list|(
name|ev_worker_timeout
argument_list|,
operator|&
name|tv_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|worker_timeout
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|UNUSED_ARG
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|UNUSED_ARG
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|DEBUG_REQUIRE
argument_list|(
name|EV_TIMEOUT
operator|&
name|what
argument_list|)
expr_stmt|;
name|worker_idle_timer_fired
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sntp_libevent_log_cb
parameter_list|(
name|int
name|severity
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
switch|switch
condition|(
name|severity
condition|)
block|{
default|default:
case|case
name|_EVENT_LOG_DEBUG
case|:
name|level
operator|=
name|LOG_DEBUG
expr_stmt|;
break|break;
case|case
name|_EVENT_LOG_MSG
case|:
name|level
operator|=
name|LOG_NOTICE
expr_stmt|;
break|break;
case|case
name|_EVENT_LOG_WARN
case|:
name|level
operator|=
name|LOG_WARNING
expr_stmt|;
break|break;
case|case
name|_EVENT_LOG_ERR
case|:
name|level
operator|=
name|LOG_ERR
expr_stmt|;
break|break;
block|}
name|msyslog
argument_list|(
name|level
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|generate_pkt
parameter_list|(
name|struct
name|pkt
modifier|*
name|x_pkt
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv_xmt
parameter_list|,
name|int
name|key_id
parameter_list|,
name|struct
name|key
modifier|*
name|pkt_key
parameter_list|)
block|{
name|l_fp
name|xmt_fp
decl_stmt|;
name|int
name|pkt_len
decl_stmt|;
name|int
name|mac_size
decl_stmt|;
name|pkt_len
operator|=
name|LEN_PKT_NOMAC
expr_stmt|;
name|ZERO
argument_list|(
operator|*
name|x_pkt
argument_list|)
expr_stmt|;
name|TVTOTS
argument_list|(
name|tv_xmt
argument_list|,
operator|&
name|xmt_fp
argument_list|)
expr_stmt|;
name|HTONL_FP
argument_list|(
operator|&
name|xmt_fp
argument_list|,
operator|&
name|x_pkt
operator|->
name|xmt
argument_list|)
expr_stmt|;
name|x_pkt
operator|->
name|stratum
operator|=
name|STRATUM_TO_PKT
argument_list|(
name|STRATUM_UNSPEC
argument_list|)
expr_stmt|;
name|x_pkt
operator|->
name|ppoll
operator|=
literal|8
expr_stmt|;
comment|/* FIXME! Modus broadcast + adr. check -> bdr. pkt */
name|set_li_vn_mode
argument_list|(
name|x_pkt
argument_list|,
name|LEAP_NOTINSYNC
argument_list|,
name|ntpver
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_key
operator|!=
name|NULL
condition|)
block|{
name|x_pkt
operator|->
name|exten
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|key_id
argument_list|)
expr_stmt|;
name|mac_size
operator|=
literal|20
expr_stmt|;
comment|/* max room for MAC */
name|mac_size
operator|=
name|make_mac
argument_list|(
operator|(
name|char
operator|*
operator|)
name|x_pkt
argument_list|,
name|pkt_len
argument_list|,
name|mac_size
argument_list|,
name|pkt_key
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x_pkt
operator|->
name|exten
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_size
operator|>
literal|0
condition|)
name|pkt_len
operator|+=
name|mac_size
operator|+
literal|4
expr_stmt|;
block|}
return|return
name|pkt_len
return|;
block|}
end_function

begin_function
name|int
name|handle_pkt
parameter_list|(
name|int
name|rpktl
parameter_list|,
name|struct
name|pkt
modifier|*
name|rpkt
parameter_list|,
name|sockaddr_u
modifier|*
name|host
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|char
name|disptxt
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|addrtxt
decl_stmt|;
name|struct
name|timeval
name|tv_dst
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|sw_case
decl_stmt|;
name|int
name|digits
decl_stmt|;
name|int
name|stratum
decl_stmt|;
name|char
modifier|*
name|ref
decl_stmt|;
name|char
modifier|*
name|ts_str
decl_stmt|;
name|double
name|offset
decl_stmt|;
name|double
name|precision
decl_stmt|;
name|double
name|synch_distance
decl_stmt|;
name|char
modifier|*
name|p_SNTP_PRETEND_TIME
decl_stmt|;
name|time_t
name|pretend_time
decl_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|==
literal|8
name|long
name|long
name|ll
decl_stmt|;
else|#
directive|else
name|long
name|l
decl_stmt|;
endif|#
directive|endif
name|ts_str
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rpktl
operator|>
literal|0
condition|)
name|sw_case
operator|=
literal|1
expr_stmt|;
else|else
name|sw_case
operator|=
name|rpktl
expr_stmt|;
switch|switch
condition|(
name|sw_case
condition|)
block|{
case|case
name|SERVER_UNUSEABLE
case|:
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|PACKET_UNUSEABLE
case|:
break|break;
case|case
name|SERVER_AUTH_FAIL
case|:
break|break;
case|case
name|KOD_DEMOBILIZE
case|:
comment|/* Received a DENY or RESTR KOD packet */
name|addrtxt
operator|=
name|stoa
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|ref
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|rpkt
operator|->
name|refid
expr_stmt|;
name|add_entry
argument_list|(
name|addrtxt
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|msyslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"KOD code %c%c%c%c from %s %s"
argument_list|,
name|ref
index|[
literal|0
index|]
argument_list|,
name|ref
index|[
literal|1
index|]
argument_list|,
name|ref
index|[
literal|2
index|]
argument_list|,
name|ref
index|[
literal|3
index|]
argument_list|,
name|addrtxt
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
break|break;
case|case
name|KOD_RATE
case|:
comment|/* 		** Hmm... 		** We should probably call add_entry() with an 		** expiration timestamp of several seconds in the future, 		** and back-off even more if we get more RATE responses. 		*/
break|break;
case|case
literal|1
case|:
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"handle_pkt: %d bytes from %s %s\n"
operator|,
name|rpktl
operator|,
name|stoa
argument_list|(
name|host
argument_list|)
operator|,
name|hostname
operator|)
argument_list|)
expr_stmt|;
name|gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|tv_dst
argument_list|)
expr_stmt|;
name|p_SNTP_PRETEND_TIME
operator|=
name|getenv
argument_list|(
literal|"SNTP_PRETEND_TIME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SNTP_PRETEND_TIME
condition|)
block|{
name|pretend_time
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SIZEOF_TIME_T
operator|==
literal|4
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|p_SNTP_PRETEND_TIME
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|l
argument_list|)
condition|)
name|pretend_time
operator|=
operator|(
name|time_t
operator|)
name|l
expr_stmt|;
elif|#
directive|elif
name|SIZEOF_TIME_T
operator|==
literal|8
if|if
condition|(
literal|1
operator|==
name|sscanf
argument_list|(
name|p_SNTP_PRETEND_TIME
argument_list|,
literal|"%lld"
argument_list|,
operator|&
name|ll
argument_list|)
condition|)
name|pretend_time
operator|=
operator|(
name|time_t
operator|)
name|ll
expr_stmt|;
else|#
directive|else
include|#
directive|include
file|"GRONK: unexpected value for SIZEOF_TIME_T"
endif|#
directive|endif
if|if
condition|(
literal|0
operator|!=
name|pretend_time
condition|)
name|tv_dst
operator|.
name|tv_sec
operator|=
name|pretend_time
expr_stmt|;
block|}
name|offset_calculation
argument_list|(
name|rpkt
argument_list|,
name|rpktl
argument_list|,
operator|&
name|tv_dst
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|precision
argument_list|,
operator|&
name|synch_distance
argument_list|)
expr_stmt|;
name|time_derived
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
operator|(
name|precision
operator|*=
literal|10.
operator|)
operator|<
literal|1.
condition|;
operator|++
name|digits
control|)
comment|/* empty */
empty_stmt|;
if|if
condition|(
name|digits
operator|>
literal|6
condition|)
name|digits
operator|=
literal|6
expr_stmt|;
name|ts_str
operator|=
name|tv_to_str
argument_list|(
operator|&
name|tv_dst
argument_list|)
expr_stmt|;
name|stratum
operator|=
name|rpkt
operator|->
name|stratum
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|stratum
condition|)
name|stratum
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|synch_distance
operator|>
literal|0.
condition|)
block|{
name|cnt
operator|=
name|snprintf
argument_list|(
name|disptxt
argument_list|,
sizeof|sizeof
argument_list|(
name|disptxt
argument_list|)
argument_list|,
literal|" +/- %f"
argument_list|,
name|synch_distance
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|cnt
operator|>=
sizeof|sizeof
argument_list|(
name|disptxt
argument_list|)
condition|)
name|snprintf
argument_list|(
name|disptxt
argument_list|,
sizeof|sizeof
argument_list|(
name|disptxt
argument_list|)
argument_list|,
literal|"ERROR %d>= %d"
argument_list|,
name|cnt
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|disptxt
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|disptxt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|msyslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %+.*f%s %s s%d%s"
argument_list|,
name|ts_str
argument_list|,
name|digits
argument_list|,
name|offset
argument_list|,
name|disptxt
argument_list|,
name|hostnameaddr
argument_list|(
name|hostname
argument_list|,
name|host
argument_list|)
argument_list|,
name|stratum
argument_list|,
operator|(
name|time_adjusted
operator|)
condition|?
literal|" [excess]"
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ts_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_SNTP_PRETEND_TIME
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|time_adjusted
operator|&&
operator|(
name|ENABLED_OPT
argument_list|(
name|STEP
argument_list|)
operator|||
name|ENABLED_OPT
argument_list|(
name|SLEW
argument_list|)
operator|)
condition|)
return|return
name|set_time
argument_list|(
name|offset
argument_list|)
return|;
return|return
name|EX_OK
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|offset_calculation
parameter_list|(
name|struct
name|pkt
modifier|*
name|rpkt
parameter_list|,
name|int
name|rpktl
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv_dst
parameter_list|,
name|double
modifier|*
name|offset
parameter_list|,
name|double
modifier|*
name|precision
parameter_list|,
name|double
modifier|*
name|synch_distance
parameter_list|)
block|{
name|l_fp
name|p_rec
decl_stmt|,
name|p_xmt
decl_stmt|,
name|p_ref
decl_stmt|,
name|p_org
decl_stmt|,
name|tmp
decl_stmt|,
name|dst
decl_stmt|;
name|u_fp
name|p_rdly
decl_stmt|,
name|p_rdsp
decl_stmt|;
name|double
name|t21
decl_stmt|,
name|t34
decl_stmt|,
name|delta
decl_stmt|;
comment|/* Convert timestamps from network to host byte order */
name|p_rdly
operator|=
name|NTOHS_FP
argument_list|(
name|rpkt
operator|->
name|rootdelay
argument_list|)
expr_stmt|;
name|p_rdsp
operator|=
name|NTOHS_FP
argument_list|(
name|rpkt
operator|->
name|rootdisp
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|reftime
argument_list|,
operator|&
name|p_ref
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|org
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|rec
argument_list|,
operator|&
name|p_rec
argument_list|)
expr_stmt|;
name|NTOHL_FP
argument_list|(
operator|&
name|rpkt
operator|->
name|xmt
argument_list|,
operator|&
name|p_xmt
argument_list|)
expr_stmt|;
operator|*
name|precision
operator|=
name|LOGTOD
argument_list|(
name|rpkt
operator|->
name|precision
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"offset_calculation: LOGTOD(rpkt->precision): %f\n"
operator|,
operator|*
name|precision
operator|)
argument_list|)
expr_stmt|;
comment|/* Compute offset etc. */
name|tmp
operator|=
name|p_rec
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|p_org
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tmp
argument_list|,
name|t21
argument_list|)
expr_stmt|;
name|TVTOTS
argument_list|(
name|tv_dst
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|.
name|l_ui
operator|+=
name|JAN_1970
expr_stmt|;
name|tmp
operator|=
name|p_xmt
expr_stmt|;
name|L_SUB
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
name|LFPTOD
argument_list|(
operator|&
name|tmp
argument_list|,
name|t34
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
operator|(
name|t21
operator|+
name|t34
operator|)
operator|/
literal|2.
expr_stmt|;
name|delta
operator|=
name|t21
operator|-
name|t34
expr_stmt|;
comment|// synch_distance is:
comment|// (peer->delay + peer->rootdelay) / 2 + peer->disp
comment|// + peer->rootdisp + clock_phi * (current_time - peer->update)
comment|// + peer->jitter;
comment|//
comment|// and peer->delay = fabs(peer->offset - p_offset) * 2;
comment|// and peer->offset needs history, so we're left with
comment|// p_offset = (t21 + t34) / 2.;
comment|// peer->disp = 0; (we have no history to augment this)
comment|// clock_phi = 15e-6;
comment|// peer->jitter = LOGTOD(sys_precision); (we have no history to augment this)
comment|// and ntp_proto.c:set_sys_tick_precision() should get us sys_precision.
comment|//
comment|// so our answer seems to be:
comment|//
comment|// (fabs(t21 + t34) + peer->rootdelay) / 3.
comment|// + 0 (peer->disp)
comment|// + peer->rootdisp
comment|// + 15e-6 (clock_phi)
comment|// + LOGTOD(sys_precision)
name|INSIST
argument_list|(
name|FPTOD
argument_list|(
name|p_rdly
argument_list|)
operator|>=
literal|0.
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
operator|*
name|synch_distance
operator|=
operator|(
name|fabs
argument_list|(
name|t21
operator|+
name|t34
argument_list|)
operator|+
name|FPTOD
argument_list|(
name|p_rdly
argument_list|)
operator|)
operator|/
literal|3.
operator|+
literal|0.
operator|+
name|FPTOD
argument_list|(
name|p_rdsp
argument_list|)
operator|+
literal|15e-6
operator|+
literal|0.
comment|/* LOGTOD(sys_precision) when we can get it */
expr_stmt|;
name|INSIST
argument_list|(
operator|*
name|synch_distance
operator|>=
literal|0.
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|synch_distance
operator|=
operator|(
name|FPTOD
argument_list|(
name|p_rdly
argument_list|)
operator|+
name|FPTOD
argument_list|(
name|p_rdsp
argument_list|)
operator|)
operator|/
literal|2.0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"sntp rootdelay: %f\n"
argument_list|,
name|FPTOD
argument_list|(
name|p_rdly
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp rootdisp: %f\n"
argument_list|,
name|FPTOD
argument_list|(
name|p_rdsp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp syncdist: %f\n"
argument_list|,
operator|*
name|synch_distance
argument_list|)
expr_stmt|;
name|pkt_output
argument_list|(
name|rpkt
argument_list|,
name|rpktl
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp offset_calculation: rpkt->reftime:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|p_ref
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp offset_calculation: rpkt->org:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|p_org
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp offset_calculation: rpkt->rec:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|p_rec
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sntp offset_calculation: rpkt->xmt:\n"
argument_list|)
expr_stmt|;
name|l_fp_output
argument_list|(
operator|&
name|p_xmt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TRACE
argument_list|(
literal|3
argument_list|,
operator|(
literal|"sntp offset_calculation:\trec - org t21: %.6f\n"
literal|"\txmt - dst t34: %.6f\tdelta: %.6f\toffset: %.6f\n"
operator|,
name|t21
operator|,
name|t34
operator|,
name|delta
operator|,
operator|*
name|offset
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Compute the 8 bits for li_vn_mode */
end_comment

begin_function
name|void
name|set_li_vn_mode
parameter_list|(
name|struct
name|pkt
modifier|*
name|spkt
parameter_list|,
name|char
name|leap
parameter_list|,
name|char
name|version
parameter_list|,
name|char
name|mode
parameter_list|)
block|{
if|if
condition|(
name|leap
operator|>
literal|3
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"set_li_vn_mode: leap> 3, using max. 3"
argument_list|)
expr_stmt|;
name|leap
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|version
operator|>
literal|7
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"set_li_vn_mode: version< 0 or> 7, using 4"
argument_list|)
expr_stmt|;
name|version
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|>
literal|7
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"set_li_vn_mode: mode> 7, using client mode 3"
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|3
expr_stmt|;
block|}
name|spkt
operator|->
name|li_vn_mode
operator|=
name|leap
operator|<<
literal|6
expr_stmt|;
name|spkt
operator|->
name|li_vn_mode
operator||=
name|version
operator|<<
literal|3
expr_stmt|;
name|spkt
operator|->
name|li_vn_mode
operator||=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** set_time applies 'offset' to the local clock. */
end_comment

begin_function
name|int
name|set_time
parameter_list|(
name|double
name|offset
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|time_adjusted
condition|)
return|return
name|EX_OK
return|;
comment|/* 	** If we can step but we cannot slew, then step. 	** If we can step or slew and and |offset|> steplimit, then step. 	*/
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|STEP
argument_list|)
operator|&&
operator|(
operator|!
name|ENABLED_OPT
argument_list|(
name|SLEW
argument_list|)
operator|||
operator|(
name|ENABLED_OPT
argument_list|(
name|SLEW
argument_list|)
operator|&&
operator|(
name|fabs
argument_list|(
name|offset
argument_list|)
operator|>
name|steplimit
operator|)
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|step_systime
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* If there was a problem, can we rely on errno? */
if|if
condition|(
literal|1
operator|==
name|rc
condition|)
name|time_adjusted
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|time_adjusted
operator|)
condition|?
name|EX_OK
else|:
literal|1
return|;
comment|/* 		** In case of error, what should we use? 		** EX_UNAVAILABLE? 		** EX_OSERR? 		** EX_NOPERM? 		*/
block|}
if|if
condition|(
name|ENABLED_OPT
argument_list|(
name|SLEW
argument_list|)
condition|)
block|{
name|rc
operator|=
name|adj_systime
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* If there was a problem, can we rely on errno? */
if|if
condition|(
literal|1
operator|==
name|rc
condition|)
name|time_adjusted
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|time_adjusted
operator|)
condition|?
name|EX_OK
else|:
literal|1
return|;
comment|/* 		** In case of error, what should we use? 		** EX_UNAVAILABLE? 		** EX_OSERR? 		** EX_NOPERM? 		*/
block|}
return|return
name|EX_SOFTWARE
return|;
block|}
end_function

begin_function
name|int
name|libevent_version_ok
parameter_list|(
name|void
parameter_list|)
block|{
name|ev_uint32_t
name|v_compile_maj
decl_stmt|;
name|ev_uint32_t
name|v_run_maj
decl_stmt|;
name|v_compile_maj
operator|=
name|LIBEVENT_VERSION_NUMBER
operator|&
literal|0xffff0000
expr_stmt|;
name|v_run_maj
operator|=
name|event_get_version_number
argument_list|()
operator|&
literal|0xffff0000
expr_stmt|;
if|if
condition|(
name|v_compile_maj
operator|!=
name|v_run_maj
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Incompatible libevent versions: have %s, built with %s\n"
argument_list|,
name|event_get_version
argument_list|()
argument_list|,
name|LIBEVENT_VERSION
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * gettimeofday_cached()  *  * Clones the event_base_gettimeofday_cached() interface but ensures the  * times are always on the gettimeofday() 1970 scale.  Older libevent 2  * sometimes used gettimeofday(), sometimes the since-system-start  * clock_gettime(CLOCK_MONOTONIC), depending on the platform.  *  * It is not cleanly possible to tell which timescale older libevent is  * using.  *  * The strategy involves 1 hour thresholds chosen to be far longer than  * the duration of a round of libevent callbacks, which share a cached  * start-of-round time.  First compare the last cached time with the  * current gettimeofday() time.  If they are within one hour, libevent  * is using the proper timescale so leave the offset 0.  Otherwise,  * compare libevent's cached time and the current time on the monotonic  * scale.  If they are within an hour, libevent is using the monotonic  * scale so calculate the offset to add to such times to bring them to  * gettimeofday()'s scale.  */
end_comment

begin_function
name|int
name|gettimeofday_cached
parameter_list|(
name|struct
name|event_base
modifier|*
name|b
parameter_list|,
name|struct
name|timeval
modifier|*
name|caller_tv
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_EVENT_HAVE_CLOCK_GETTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLOCK_MONOTONIC
argument_list|)
specifier|static
name|struct
name|event_base
modifier|*
name|cached_b
decl_stmt|;
specifier|static
name|struct
name|timeval
name|cached
decl_stmt|;
specifier|static
name|struct
name|timeval
name|adj_cached
decl_stmt|;
specifier|static
name|struct
name|timeval
name|offset
decl_stmt|;
specifier|static
name|int
name|offset_ready
decl_stmt|;
name|struct
name|timeval
name|latest
decl_stmt|;
name|struct
name|timeval
name|systemt
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timeval
name|mono
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|int
name|cgt_rc
decl_stmt|;
name|int
name|gtod_rc
decl_stmt|;
name|event_base_gettimeofday_cached
argument_list|(
name|b
argument_list|,
operator|&
name|latest
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|cached_b
operator|&&
operator|!
name|memcmp
argument_list|(
operator|&
name|latest
argument_list|,
operator|&
name|cached
argument_list|,
sizeof|sizeof
argument_list|(
name|latest
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|caller_tv
operator|=
name|adj_cached
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cached
operator|=
name|latest
expr_stmt|;
name|cached_b
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|!
name|offset_ready
condition|)
block|{
name|cgt_rc
operator|=
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|gtod_rc
operator|=
name|gettimeofday
argument_list|(
operator|&
name|systemt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|gtod_rc
condition|)
block|{
name|msyslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: gettimeofday() error %m"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
name|sub_tval
argument_list|(
name|systemt
argument_list|,
name|latest
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"system minus cached %+ld.%06ld\n"
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|cgt_rc
operator|||
name|labs
argument_list|(
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_sec
argument_list|)
operator|<
literal|3600
condition|)
block|{
comment|/* 			 * Either use_monotonic == 0, or this libevent 			 * has been repaired.  Leave offset at zero. 			 */
block|}
else|else
block|{
name|mono
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|mono
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|diff
operator|=
name|sub_tval
argument_list|(
name|latest
argument_list|,
name|mono
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"cached minus monotonic %+ld.%06ld\n"
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_sec
argument_list|,
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|labs
argument_list|(
operator|(
name|long
operator|)
name|diff
operator|.
name|tv_sec
argument_list|)
operator|<
literal|3600
condition|)
block|{
comment|/* older libevent2 using monotonic */
name|offset
operator|=
name|sub_tval
argument_list|(
name|systemt
argument_list|,
name|mono
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|1
argument_list|,
operator|(
literal|"%s: Offsetting libevent CLOCK_MONOTONIC times  by %+ld.%06ld\n"
operator|,
literal|"gettimeofday_cached"
operator|,
operator|(
name|long
operator|)
name|offset
operator|.
name|tv_sec
operator|,
operator|(
name|long
operator|)
name|offset
operator|.
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|offset_ready
operator|=
name|TRUE
expr_stmt|;
block|}
name|adj_cached
operator|=
name|add_tval
argument_list|(
name|cached
argument_list|,
name|offset
argument_list|)
expr_stmt|;
operator|*
name|caller_tv
operator|=
name|adj_cached
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
name|event_base_gettimeofday_cached
argument_list|(
name|b
argument_list|,
name|caller_tv
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

