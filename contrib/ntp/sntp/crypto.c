begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"crypto.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"isc/string.h"
end_include

begin_include
include|#
directive|include
file|"libssl_compat.h"
end_include

begin_decl_stmt
name|struct
name|key
modifier|*
name|key_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|key_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|make_mac
parameter_list|(
specifier|const
name|void
modifier|*
name|pkt_data
parameter_list|,
name|int
name|pkt_size
parameter_list|,
name|int
name|mac_size
parameter_list|,
specifier|const
name|struct
name|key
modifier|*
name|cmp_key
parameter_list|,
name|void
modifier|*
name|digest
parameter_list|)
block|{
name|u_int
name|len
init|=
name|mac_size
decl_stmt|;
name|int
name|key_type
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|cmp_key
operator|->
name|key_len
operator|>
literal|64
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pkt_size
operator|%
literal|4
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|INIT_SSL
argument_list|()
expr_stmt|;
name|key_type
operator|=
name|keytype_from_text
argument_list|(
name|cmp_key
operator|->
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|EVP_MD_CTX_new
argument_list|()
expr_stmt|;
name|EVP_DigestInit
argument_list|(
name|ctx
argument_list|,
name|EVP_get_digestbynid
argument_list|(
name|key_type
argument_list|)
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|ctx
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|cmp_key
operator|->
name|key_seq
argument_list|,
operator|(
name|u_int
operator|)
name|cmp_key
operator|->
name|key_len
argument_list|)
expr_stmt|;
name|EVP_DigestUpdate
argument_list|(
name|ctx
argument_list|,
name|pkt_data
argument_list|,
operator|(
name|u_int
operator|)
name|pkt_size
argument_list|)
expr_stmt|;
name|EVP_DigestFinal
argument_list|(
name|ctx
argument_list|,
name|digest
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_comment
comment|/* Generates a md5 digest of the key specified in keyid concatenated with the   * ntp packet (exluding the MAC) and compares this digest to the digest in  * the packet's MAC. If they're equal this function returns 1 (packet is   * authentic) or else 0 (not authentic).  */
end_comment

begin_function
name|int
name|auth_md5
parameter_list|(
specifier|const
name|void
modifier|*
name|pkt_data
parameter_list|,
name|int
name|pkt_size
parameter_list|,
name|int
name|mac_size
parameter_list|,
specifier|const
name|struct
name|key
modifier|*
name|cmp_key
parameter_list|)
block|{
name|int
name|hash_len
decl_stmt|;
name|int
name|authentic
decl_stmt|;
name|char
name|digest
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pkt_ptr
decl_stmt|;
if|if
condition|(
name|mac_size
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
condition|)
return|return
literal|0
return|;
name|pkt_ptr
operator|=
name|pkt_data
expr_stmt|;
name|hash_len
operator|=
name|make_mac
argument_list|(
name|pkt_ptr
argument_list|,
name|pkt_size
argument_list|,
sizeof|sizeof
argument_list|(
name|digest
argument_list|)
argument_list|,
name|cmp_key
argument_list|,
name|digest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_len
condition|)
block|{
name|authentic
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* isc_tsmemcmp will be better when its easy to link 		 * with.  sntp is a 1-shot program, so snooping for 		 * timing attacks is Harder. 		 */
name|authentic
operator|=
operator|!
name|memcmp
argument_list|(
name|digest
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|pkt_data
operator|+
name|pkt_size
operator|+
literal|4
argument_list|,
name|hash_len
argument_list|)
expr_stmt|;
block|}
return|return
name|authentic
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hex_val
parameter_list|(
name|unsigned
name|char
name|x
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
literal|'0'
operator|<=
name|x
operator|&&
name|x
operator|<=
literal|'9'
condition|)
name|val
operator|=
name|x
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'a'
operator|<=
name|x
operator|&&
name|x
operator|<=
literal|'f'
condition|)
name|val
operator|=
name|x
operator|-
literal|'a'
operator|+
literal|0xa
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
name|x
operator|&&
name|x
operator|<=
literal|'F'
condition|)
name|val
operator|=
name|x
operator|-
literal|'A'
operator|+
literal|0xA
expr_stmt|;
else|else
name|val
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Load keys from the specified keyfile into the key structures.  * Returns -1 if the reading failed, otherwise it returns the   * number of keys it read  */
end_comment

begin_function
name|int
name|auth_init
parameter_list|(
specifier|const
name|char
modifier|*
name|keyfile
parameter_list|,
name|struct
name|key
modifier|*
modifier|*
name|keys
parameter_list|)
block|{
name|FILE
modifier|*
name|keyf
init|=
name|fopen
argument_list|(
name|keyfile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|key
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|scan_cnt
decl_stmt|,
name|line_cnt
init|=
literal|0
decl_stmt|;
name|char
name|kbuf
index|[
literal|200
index|]
decl_stmt|;
name|char
name|keystring
index|[
literal|129
index|]
decl_stmt|;
if|if
condition|(
name|keyf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sntp auth_init: Couldn't open key file %s for reading!\n"
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|keyf
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"sntp auth_init: Key file %s is empty!\n"
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|keyf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|key_cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|keyf
argument_list|)
condition|)
block|{
name|char
modifier|*
name|octothorpe
decl_stmt|;
name|struct
name|key
modifier|*
name|act
decl_stmt|;
name|int
name|goodline
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|fgets
argument_list|(
name|kbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|kbuf
argument_list|)
argument_list|,
name|keyf
argument_list|)
condition|)
continue|continue;
name|kbuf
index|[
sizeof|sizeof
argument_list|(
name|kbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|octothorpe
operator|=
name|strchr
argument_list|(
name|kbuf
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|octothorpe
condition|)
operator|*
name|octothorpe
operator|=
literal|'\0'
expr_stmt|;
name|act
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|scan_cnt
operator|=
name|sscanf
argument_list|(
name|kbuf
argument_list|,
literal|"%d %9s %128s"
argument_list|,
operator|&
name|act
operator|->
name|key_id
argument_list|,
name|act
operator|->
name|type
argument_list|,
name|keystring
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_cnt
operator|==
literal|3
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|keystring
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|20
condition|)
block|{
name|act
operator|->
name|key_len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|act
operator|->
name|key_seq
argument_list|,
name|keystring
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|goodline
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|goodline
operator|=
literal|0
expr_stmt|;
comment|/* it's bad */
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
name|goodline
operator|=
literal|1
expr_stmt|;
name|act
operator|->
name|key_len
operator|=
name|len
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|+=
literal|2
control|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|hex_val
argument_list|(
name|keystring
index|[
name|j
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|hex_val
argument_list|(
name|keystring
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|goodline
operator|=
literal|0
expr_stmt|;
comment|/* it's bad */
break|break;
block|}
name|act
operator|->
name|key_seq
index|[
name|j
operator|>>
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|goodline
condition|)
block|{
name|act
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prev
condition|)
operator|*
name|keys
operator|=
name|act
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|act
expr_stmt|;
name|prev
operator|=
name|act
expr_stmt|;
name|key_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|msyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"auth_init: scanf %d items, skipping line %d."
argument_list|,
name|scan_cnt
argument_list|,
name|line_cnt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|act
argument_list|)
expr_stmt|;
block|}
name|line_cnt
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|keyf
argument_list|)
expr_stmt|;
name|key_ptr
operator|=
operator|*
name|keys
expr_stmt|;
return|return
name|key_cnt
return|;
block|}
end_function

begin_comment
comment|/* Looks for the key with keyid key_id and sets the d_key pointer to the   * address of the key. If no matching key is found the pointer is not touched.  */
end_comment

begin_function
name|void
name|get_key
parameter_list|(
name|int
name|key_id
parameter_list|,
name|struct
name|key
modifier|*
modifier|*
name|d_key
parameter_list|)
block|{
name|struct
name|key
modifier|*
name|itr_key
decl_stmt|;
if|if
condition|(
name|key_cnt
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|itr_key
operator|=
name|key_ptr
init|;
name|itr_key
condition|;
name|itr_key
operator|=
name|itr_key
operator|->
name|next
control|)
block|{
if|if
condition|(
name|itr_key
operator|->
name|key_id
operator|==
name|key_id
condition|)
block|{
operator|*
name|d_key
operator|=
name|itr_key
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_function

end_unit

