begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Copyright (C) 1996, 2000 N.M. Maclaren     Copyright (C) 1996, 2000 The University of Cambridge  This includes all of the code needed to handle Berkeley sockets.  It is way outside current POSIX, unfortunately.  It should be easy to convert to a system that uses another mechanism.  It does not currently use socklen_t, because the only system that the author uses that has it is Linux. */
end_comment

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_include
include|#
directive|include
file|"internet.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|SOCKET
end_define

begin_include
include|#
directive|include
file|"kludges.h"
end_include

begin_undef
undef|#
directive|undef
name|SOCKET
end_undef

begin_comment
comment|/* The code needs to set some variables during the open, for use by later functions. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initial
init|=
literal|1
decl_stmt|,
name|descriptors
index|[
name|MAX_SOCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IPV6
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_storage
name|here
index|[
name|MAX_SOCKETS
index|]
decl_stmt|,
name|there
index|[
name|MAX_SOCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|here
index|[
name|MAX_SOCKETS
index|]
decl_stmt|,
name|there
index|[
name|MAX_SOCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* There needs to be some disgusting grobble for handling timeouts, that is identical to the grobble in internet.c. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|jump_buffer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|jump_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|longjmp
argument_list|(
name|jump_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_alarm
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|k
operator|=
name|errno
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
operator|==
name|SIG_ERR
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to reset signal handler"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
name|k
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_in_hex
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.2x"
argument_list|,
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IPV6
end_ifdef

begin_function
name|void
name|display_sock_in_hex
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|sock
parameter_list|)
block|{
name|int
name|family
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|family
operator|=
name|sock
operator|->
name|ss_family
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sock
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin
operator|->
name|sin_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sock
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|display_sock_in_hex
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|sock
parameter_list|)
block|{
name|int
name|family
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|family
operator|=
name|sock
operator|->
name|sin_family
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sock
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|sin
operator|->
name|sin_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IPV6
end_ifdef

begin_function
name|void
name|open_socket
parameter_list|(
name|int
name|which
parameter_list|,
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|timespan
parameter_list|)
block|{
comment|/* Locate the specified NTP server, set up a couple of addresses and open a socket. */
name|int
name|port
decl_stmt|,
name|k
decl_stmt|,
name|sl
decl_stmt|;
name|struct
name|sockaddr_storage
name|address
decl_stmt|,
name|anywhere
decl_stmt|,
name|everywhere
decl_stmt|;
comment|/* Initialise and find out the server and port number.  Note that the port number is in network format. */
if|if
condition|(
name|initial
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAX_SOCKETS
condition|;
operator|++
name|k
control|)
name|descriptors
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|initial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
operator|||
name|descriptors
index|[
name|which
index|]
operator|>=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range or already open"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for the socket addresses\n"
argument_list|)
expr_stmt|;
name|find_address
argument_list|(
operator|&
name|address
argument_list|,
operator|&
name|anywhere
argument_list|,
operator|&
name|everywhere
argument_list|,
operator|&
name|port
argument_list|,
name|hostname
argument_list|,
name|timespan
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internet address: address="
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
operator|&
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" anywhere="
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
operator|&
name|anywhere
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" everywhere="
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
operator|&
name|everywhere
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Set up our own and the target addresses.  Note that the target address will be reset before use in server mode. */
name|memset
argument_list|(
operator|&
name|here
index|[
name|which
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
expr_stmt|;
name|here
index|[
name|which
index|]
operator|=
name|anywhere
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|operation
operator|==
name|op_listen
operator|||
name|operation
operator|==
name|op_server
operator|)
condition|)
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|here
index|[
name|which
index|]
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|there
index|[
name|which
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
expr_stmt|;
name|there
index|[
name|which
index|]
operator|=
operator|(
name|operation
operator|==
name|op_broadcast
condition|?
name|everywhere
else|:
name|address
operator|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Initial sockets: here="
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
operator|&
name|here
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" there="
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
operator|&
name|there
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a local UDP socket and configure it. */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|there
index|[
name|which
index|]
operator|)
operator|->
name|sin_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
name|sl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|sl
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|descriptors
index|[
name|which
index|]
operator|=
name|socket
argument_list|(
name|here
index|[
name|which
index|]
operator|.
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|bind
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|here
index|[
name|which
index|]
argument_list|,
name|sl
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to allocate socket for NTP"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_broadcast
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|setsockopt
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|k
argument_list|,
sizeof|sizeof
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to set permission to broadcast"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|open_socket
parameter_list|(
name|int
name|which
parameter_list|,
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|timespan
parameter_list|)
block|{
comment|/* Locate the specified NTP server, set up a couple of addresses and open a socket. */
name|int
name|port
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|in_addr
name|address
decl_stmt|,
name|anywhere
decl_stmt|,
name|everywhere
decl_stmt|;
comment|/* Initialise and find out the server and port number.  Note that the port number is in network format. */
if|if
condition|(
name|initial
condition|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|MAX_SOCKETS
condition|;
operator|++
name|k
control|)
name|descriptors
index|[
name|k
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|initial
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
operator|||
name|descriptors
index|[
name|which
index|]
operator|>=
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range or already open"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for the socket addresses\n"
argument_list|)
expr_stmt|;
name|find_address
argument_list|(
operator|&
name|address
argument_list|,
operator|&
name|anywhere
argument_list|,
operator|&
name|everywhere
argument_list|,
operator|&
name|port
argument_list|,
name|hostname
argument_list|,
name|timespan
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internet address: address="
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" anywhere="
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|anywhere
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" everywhere="
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|everywhere
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Set up our own and the target addresses.  Note that the target address will be reset before use in server mode. */
name|memset
argument_list|(
operator|&
name|here
index|[
name|which
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|here
index|[
name|which
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|here
index|[
name|which
index|]
operator|.
name|sin_port
operator|=
operator|(
name|operation
operator|==
name|op_listen
operator|||
name|operation
operator|==
name|op_server
condition|?
name|port
else|:
literal|0
operator|)
expr_stmt|;
name|here
index|[
name|which
index|]
operator|.
name|sin_addr
operator|=
name|anywhere
expr_stmt|;
name|memset
argument_list|(
operator|&
name|there
index|[
name|which
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|there
index|[
name|which
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|there
index|[
name|which
index|]
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|there
index|[
name|which
index|]
operator|.
name|sin_addr
operator|=
operator|(
name|operation
operator|==
name|op_broadcast
condition|?
name|everywhere
else|:
name|address
operator|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Initial sockets: here="
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|here
index|[
name|which
index|]
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'/'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|here
index|[
name|which
index|]
operator|.
name|sin_port
argument_list|,
sizeof|sizeof
argument_list|(
name|here
index|[
name|which
index|]
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" there="
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|there
index|[
name|which
index|]
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'/'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|display_in_hex
argument_list|(
operator|&
name|there
index|[
name|which
index|]
operator|.
name|sin_port
argument_list|,
sizeof|sizeof
argument_list|(
name|there
index|[
name|which
index|]
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate a local UDP socket and configure it. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|descriptors
index|[
name|which
index|]
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|bind
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|here
index|[
name|which
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|here
index|[
name|which
index|]
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to allocate socket for NTP"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|op_broadcast
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|setsockopt
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|k
argument_list|,
sizeof|sizeof
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to set permission to broadcast"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|extern
name|void
name|write_socket
parameter_list|(
name|int
name|which
parameter_list|,
name|void
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* Any errors in doing this are fatal - including blocking.  Yes, this leaves a server vulnerable to a denial of service attack. */
name|int
name|k
decl_stmt|,
name|sl
decl_stmt|;
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|there
index|[
name|which
index|]
operator|)
operator|->
name|sin_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|sl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_IPV6
case|case
name|AF_INET6
case|:
name|sl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|sl
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
operator|||
name|descriptors
index|[
name|which
index|]
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range or not open"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|sendto
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|packet
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|there
index|[
name|which
index|]
argument_list|,
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|length
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to send NTP packet"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|int
name|read_socket
parameter_list|(
name|int
name|which
parameter_list|,
name|void
modifier|*
name|packet
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|waiting
parameter_list|)
block|{
comment|/* Read a packet and return its length or -1 for failure.  Only incorrect length and timeout are not fatal. */
ifdef|#
directive|ifdef
name|HAVE_IPV6
name|struct
name|sockaddr_storage
name|scratch
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
name|scratch
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
endif|#
directive|endif
name|int
name|n
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Under normal circumstances, set up a timeout. */
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
operator|||
name|descriptors
index|[
name|which
index|]
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range or not open"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|jump_buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Receive timed out\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: receive timed out after %d seconds\n"
argument_list|,
name|argv0
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|jump_handler
argument_list|)
operator|==
name|SIG_ERR
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to set up signal handler"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|waiting
argument_list|)
expr_stmt|;
block|}
comment|/* Get the packet and clear the timeout, if any.  */
if|if
condition|(
name|operation
operator|==
name|op_server
condition|)
name|memcpy
argument_list|(
name|ptr
operator|=
operator|&
name|there
index|[
name|which
index|]
argument_list|,
operator|&
name|here
index|[
name|which
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ptr
operator|=
operator|&
name|scratch
argument_list|,
operator|&
name|there
index|[
name|which
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|recvfrom
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|packet
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ptr
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting
operator|>
literal|0
condition|)
name|clear_alarm
argument_list|()
expr_stmt|;
comment|/* Now issue some low-level diagnostics. */
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to receive NTP packet from server"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Packet of length %d received from "
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|display_sock_in_hex
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|k
return|;
block|}
end_function

begin_function
specifier|extern
name|int
name|flush_socket
parameter_list|(
name|int
name|which
parameter_list|)
block|{
comment|/* Get rid of any outstanding input, because it may have been hanging around for a while.  Ignore packet length oddities and return the number of packets skipped. */
ifdef|#
directive|ifdef
name|HAVE_IPV6
name|struct
name|sockaddr_storage
name|scratch
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
name|scratch
decl_stmt|;
endif|#
directive|endif
name|int
name|n
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
comment|/* The code is the obvious. */
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
operator|||
name|descriptors
index|[
name|which
index|]
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range or not open"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Flushing outstanding packets\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fcntl
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to set non-blocking mode"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|recvfrom
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|buffer
argument_list|,
literal|256
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|scratch
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
break|break;
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to flush socket"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|++
name|count
expr_stmt|;
name|total
operator|+=
name|k
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to restore blocking mode"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Flushed %d packets totalling %d bytes\n"
argument_list|,
name|count
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|close_socket
parameter_list|(
name|int
name|which
parameter_list|)
block|{
comment|/* There is little point in shielding this with a timeout, because any hangs are unlikely to be interruptible.  It can get called when the sockets haven't been opened, so ignore that case. */
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|MAX_SOCKETS
condition|)
name|fatal
argument_list|(
literal|0
argument_list|,
literal|"socket index out of range"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptors
index|[
name|which
index|]
operator|<
literal|0
condition|)
return|return;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|descriptors
index|[
name|which
index|]
argument_list|)
condition|)
name|fatal
argument_list|(
literal|1
argument_list|,
literal|"unable to close NTP socket"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

