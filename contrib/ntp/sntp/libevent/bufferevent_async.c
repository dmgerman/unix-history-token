begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SO_UPDATE_CONNECT_CONTEXT
end_ifndef

begin_comment
comment|/* Mingw is sometimes missing this */
end_comment

begin_define
define|#
directive|define
name|SO_UPDATE_CONNECT_CONTEXT
value|0x7010
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|be_async_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_async_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|be_async_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_async_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|short
parameter_list|,
name|enum
name|bufferevent_flush_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|be_async_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|enum
name|bufferevent_ctrl_op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|bufferevent_async
block|{
name|struct
name|bufferevent_private
name|bev
decl_stmt|;
name|struct
name|event_overlapped
name|connect_overlapped
decl_stmt|;
name|struct
name|event_overlapped
name|read_overlapped
decl_stmt|;
name|struct
name|event_overlapped
name|write_overlapped
decl_stmt|;
name|size_t
name|read_in_progress
decl_stmt|;
name|size_t
name|write_in_progress
decl_stmt|;
name|unsigned
name|ok
range|:
literal|1
decl_stmt|;
name|unsigned
name|read_added
range|:
literal|1
decl_stmt|;
name|unsigned
name|write_added
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|bufferevent_ops
name|bufferevent_ops_async
init|=
block|{
literal|"socket_async"
block|,
name|evutil_offsetof
argument_list|(
expr|struct
name|bufferevent_async
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
block|,
name|be_async_enable
block|,
name|be_async_disable
block|,
name|NULL
block|,
comment|/* Unlink */
name|be_async_destruct
block|,
name|bufferevent_generic_adj_timeouts_
block|,
name|be_async_flush
block|,
name|be_async_ctrl
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_async
modifier|*
name|upcast
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
decl_stmt|;
if|if
condition|(
name|bev
operator|->
name|be_ops
operator|!=
operator|&
name|bufferevent_ops_async
condition|)
return|return
name|NULL
return|;
name|bev_a
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_async
argument_list|,
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
return|return
name|bev_a
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_async
modifier|*
name|upcast_connect
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
decl_stmt|;
name|bev_a
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|eo
argument_list|,
expr|struct
name|bufferevent_async
argument_list|,
name|connect_overlapped
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|BEV_IS_ASYNC
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bev_a
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_async
modifier|*
name|upcast_read
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
decl_stmt|;
name|bev_a
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|eo
argument_list|,
expr|struct
name|bufferevent_async
argument_list|,
name|read_overlapped
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|BEV_IS_ASYNC
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bev_a
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|bufferevent_async
modifier|*
name|upcast_write
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
decl_stmt|;
name|bev_a
operator|=
name|EVUTIL_UPCAST
argument_list|(
name|eo
argument_list|,
expr|struct
name|bufferevent_async
argument_list|,
name|write_overlapped
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|BEV_IS_ASYNC
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bev_a
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_del_write
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
if|if
condition|(
name|beva
operator|->
name|write_added
condition|)
block|{
name|beva
operator|->
name|write_added
operator|=
literal|0
expr_stmt|;
name|event_base_del_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_del_read
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
if|if
condition|(
name|beva
operator|->
name|read_added
condition|)
block|{
name|beva
operator|->
name|read_added
operator|=
literal|0
expr_stmt|;
name|event_base_del_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_add_write
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
if|if
condition|(
operator|!
name|beva
operator|->
name|write_added
condition|)
block|{
name|beva
operator|->
name|write_added
operator|=
literal|1
expr_stmt|;
name|event_base_add_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_add_read
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
if|if
condition|(
operator|!
name|beva
operator|->
name|read_added
condition|)
block|{
name|beva
operator|->
name|read_added
operator|=
literal|1
expr_stmt|;
name|event_base_add_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_consider_writing
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|size_t
name|at_most
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
comment|/* Don't write if there's a write in progress, or we do not 	 * want to write, or when there's nothing left to write. */
if|if
condition|(
name|beva
operator|->
name|write_in_progress
operator|||
name|beva
operator|->
name|bev
operator|.
name|connecting
condition|)
return|return;
if|if
condition|(
operator|!
name|beva
operator|->
name|ok
operator|||
operator|!
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_WRITE
operator|)
operator|||
operator|!
name|evbuffer_get_length
argument_list|(
name|bev
operator|->
name|output
argument_list|)
condition|)
block|{
name|bev_async_del_write
argument_list|(
name|beva
argument_list|)
expr_stmt|;
return|return;
block|}
name|at_most
operator|=
name|evbuffer_get_length
argument_list|(
name|bev
operator|->
name|output
argument_list|)
expr_stmt|;
comment|/* This is safe so long as bufferevent_get_write_max never returns 	 * more than INT_MAX.  That's true for now. XXXX */
name|limit
operator|=
operator|(
name|int
operator|)
name|bufferevent_get_write_max_
argument_list|(
operator|&
name|beva
operator|->
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_most
operator|>=
operator|(
name|size_t
operator|)
name|limit
operator|&&
name|limit
operator|>=
literal|0
condition|)
name|at_most
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|beva
operator|->
name|bev
operator|.
name|write_suspended
condition|)
block|{
name|bev_async_del_write
argument_list|(
name|beva
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  XXXX doesn't respect low-water mark very well. */
name|bufferevent_incref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_launch_write_
argument_list|(
name|bev
operator|->
name|output
argument_list|,
name|at_most
argument_list|,
operator|&
name|beva
operator|->
name|write_overlapped
argument_list|)
condition|)
block|{
name|bufferevent_decref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|beva
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|BEV_EVENT_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beva
operator|->
name|write_in_progress
operator|=
name|at_most
expr_stmt|;
name|bufferevent_decrement_write_buckets_
argument_list|(
operator|&
name|beva
operator|->
name|bev
argument_list|,
name|at_most
argument_list|)
expr_stmt|;
name|bev_async_add_write
argument_list|(
name|beva
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bev_async_consider_reading
parameter_list|(
name|struct
name|bufferevent_async
modifier|*
name|beva
parameter_list|)
block|{
name|size_t
name|cur_size
decl_stmt|;
name|size_t
name|read_high
decl_stmt|;
name|size_t
name|at_most
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|beva
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
comment|/* Don't read if there is a read in progress, or we do not 	 * want to read. */
if|if
condition|(
name|beva
operator|->
name|read_in_progress
operator|||
name|beva
operator|->
name|bev
operator|.
name|connecting
condition|)
return|return;
if|if
condition|(
operator|!
name|beva
operator|->
name|ok
operator|||
operator|!
operator|(
name|bev
operator|->
name|enabled
operator|&
name|EV_READ
operator|)
condition|)
block|{
name|bev_async_del_read
argument_list|(
name|beva
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't read if we're full */
name|cur_size
operator|=
name|evbuffer_get_length
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
name|read_high
operator|=
name|bev
operator|->
name|wm_read
operator|.
name|high
expr_stmt|;
if|if
condition|(
name|read_high
condition|)
block|{
if|if
condition|(
name|cur_size
operator|>=
name|read_high
condition|)
block|{
name|bev_async_del_read
argument_list|(
name|beva
argument_list|)
expr_stmt|;
return|return;
block|}
name|at_most
operator|=
name|read_high
operator|-
name|cur_size
expr_stmt|;
block|}
else|else
block|{
name|at_most
operator|=
literal|16384
expr_stmt|;
comment|/* FIXME totally magic. */
block|}
comment|/* XXXX This over-commits. */
comment|/* XXXX see also not above on cast on bufferevent_get_write_max_() */
name|limit
operator|=
operator|(
name|int
operator|)
name|bufferevent_get_read_max_
argument_list|(
operator|&
name|beva
operator|->
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_most
operator|>=
operator|(
name|size_t
operator|)
name|limit
operator|&&
name|limit
operator|>=
literal|0
condition|)
name|at_most
operator|=
name|limit
expr_stmt|;
if|if
condition|(
name|beva
operator|->
name|bev
operator|.
name|read_suspended
condition|)
block|{
name|bev_async_del_read
argument_list|(
name|beva
argument_list|)
expr_stmt|;
return|return;
block|}
name|bufferevent_incref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_launch_read_
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|at_most
argument_list|,
operator|&
name|beva
operator|->
name|read_overlapped
argument_list|)
condition|)
block|{
name|beva
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|BEV_EVENT_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufferevent_decref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|beva
operator|->
name|read_in_progress
operator|=
name|at_most
expr_stmt|;
name|bufferevent_decrement_read_buckets_
argument_list|(
operator|&
name|beva
operator|->
name|bev
argument_list|,
name|at_most
argument_list|)
expr_stmt|;
name|bev_async_add_read
argument_list|(
name|beva
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|be_async_outbuf_callback
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
comment|/* If we added data to the outbuf and were not writing before, 	 * we may want to write now. */
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbinfo
operator|->
name|n_added
condition|)
name|bev_async_consider_writing
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_async_inbuf_callback
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_cb_info
modifier|*
name|cbinfo
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|arg
decl_stmt|;
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
comment|/* If we drained data from the inbuf and were not reading before, 	 * we may want to read now */
name|bufferevent_incref_and_lock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbinfo
operator|->
name|n_deleted
condition|)
name|bev_async_consider_reading
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_async_enable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|buf
parameter_list|,
name|short
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bev_async
operator|->
name|ok
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bev_async
operator|->
name|bev
operator|.
name|connecting
condition|)
block|{
comment|/* Don't launch anything during connection attempts. */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|what
operator|&
name|EV_READ
condition|)
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|EV_WRITE
condition|)
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* If we newly enable reading or writing, and we aren't reading or 	   writing already, consider launching a new read or write. */
if|if
condition|(
name|what
operator|&
name|EV_READ
condition|)
name|bev_async_consider_reading
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|&
name|EV_WRITE
condition|)
name|bev_async_consider_writing
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_async_disable
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|what
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
comment|/* XXXX If we disable reading or writing, we may want to consider 	 * canceling any in-progress read or write operation, though it might 	 * not work. */
if|if
condition|(
name|what
operator|&
name|EV_READ
condition|)
block|{
name|BEV_DEL_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_async_del_read
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what
operator|&
name|EV_WRITE
condition|)
block|{
name|BEV_DEL_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_async_del_write
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|be_async_destruct
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev_p
init|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|evutil_socket_t
name|fd
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|upcast
argument_list|(
name|bev
argument_list|)
operator|->
name|write_in_progress
operator|&&
operator|!
name|upcast
argument_list|(
name|bev
argument_list|)
operator|->
name|read_in_progress
argument_list|)
expr_stmt|;
name|bev_async_del_read
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
name|bev_async_del_write
argument_list|(
name|bev_async
argument_list|)
expr_stmt|;
name|fd
operator|=
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|(
name|evutil_socket_t
operator|)
name|INVALID_SOCKET
operator|&&
operator|(
name|bev_p
operator|->
name|options
operator|&
name|BEV_OPT_CLOSE_ON_FREE
operator|)
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|evbuffer_overlapped_set_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|INVALID_SOCKET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GetQueuedCompletionStatus doesn't reliably yield WSA error codes, so  * we use WSAGetOverlappedResult to translate. */
end_comment

begin_function
specifier|static
name|void
name|bev_async_set_wsa_error
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|)
block|{
name|DWORD
name|bytes
decl_stmt|,
name|flags
decl_stmt|;
name|evutil_socket_t
name|fd
decl_stmt|;
name|fd
operator|=
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
name|WSAGetOverlappedResult
argument_list|(
name|fd
argument_list|,
operator|&
name|eo
operator|->
name|overlapped
argument_list|,
operator|&
name|bytes
argument_list|,
name|FALSE
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_async_flush
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|short
name|what
parameter_list|,
name|enum
name|bufferevent_flush_mode
name|mode
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_complete
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|nbytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
init|=
name|upcast_connect
argument_list|(
name|eo
argument_list|)
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|evutil_socket_t
name|sock
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bev_a
operator|->
name|bev
operator|.
name|connecting
argument_list|)
expr_stmt|;
name|bev_a
operator|->
name|bev
operator|.
name|connecting
operator|=
literal|0
expr_stmt|;
name|sock
operator|=
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev_a
operator|->
name|bev
operator|.
name|bev
operator|.
name|input
argument_list|)
expr_stmt|;
comment|/* XXXX Handle error? */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_UPDATE_CONNECT_CONTEXT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|bufferevent_async_set_connected_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
else|else
name|bev_async_set_wsa_error
argument_list|(
name|bev
argument_list|,
name|eo
argument_list|)
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|ok
condition|?
name|BEV_EVENT_CONNECTED
else|:
name|BEV_EVENT_ERROR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_base_del_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_complete
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|nbytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
init|=
name|upcast_read
argument_list|(
name|eo
argument_list|)
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|short
name|what
init|=
name|BEV_EVENT_READING
decl_stmt|;
name|ev_ssize_t
name|amount_unread
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bev_a
operator|->
name|read_in_progress
argument_list|)
expr_stmt|;
name|amount_unread
operator|=
name|bev_a
operator|->
name|read_in_progress
operator|-
name|nbytes
expr_stmt|;
name|evbuffer_commit_read_
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bev_a
operator|->
name|read_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|amount_unread
condition|)
name|bufferevent_decrement_read_buckets_
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
argument_list|,
operator|-
name|amount_unread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|bev_async_set_wsa_error
argument_list|(
name|bev
argument_list|,
name|eo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_a
operator|->
name|ok
condition|)
block|{
if|if
condition|(
name|ok
operator|&&
name|nbytes
condition|)
block|{
name|BEV_RESET_GENERIC_READ_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bev
argument_list|,
name|EV_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bev_async_consider_reading
argument_list|(
name|bev_a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|what
operator||=
name|BEV_EVENT_ERROR
expr_stmt|;
name|bev_a
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nbytes
condition|)
block|{
name|what
operator||=
name|BEV_EVENT_EOF
expr_stmt|;
name|bev_a
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_complete
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|eo
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|nbytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
init|=
name|upcast_write
argument_list|(
name|eo
argument_list|)
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
decl_stmt|;
name|short
name|what
init|=
name|BEV_EVENT_WRITING
decl_stmt|;
name|ev_ssize_t
name|amount_unwritten
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bev_a
operator|->
name|write_in_progress
argument_list|)
expr_stmt|;
name|amount_unwritten
operator|=
name|bev_a
operator|->
name|write_in_progress
operator|-
name|nbytes
expr_stmt|;
name|evbuffer_commit_write_
argument_list|(
name|bev
operator|->
name|output
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bev_a
operator|->
name|write_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|amount_unwritten
condition|)
name|bufferevent_decrement_write_buckets_
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
argument_list|,
operator|-
name|amount_unwritten
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|bev_async_set_wsa_error
argument_list|(
name|bev
argument_list|,
name|eo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bev_a
operator|->
name|ok
condition|)
block|{
if|if
condition|(
name|ok
operator|&&
name|nbytes
condition|)
block|{
name|BEV_RESET_GENERIC_WRITE_TIMEOUT
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bufferevent_trigger_nolock_
argument_list|(
name|bev
argument_list|,
name|EV_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bev_async_consider_writing
argument_list|(
name|bev_a
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|what
operator||=
name|BEV_EVENT_ERROR
expr_stmt|;
name|bev_a
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nbytes
condition|)
block|{
name|what
operator||=
name|BEV_EVENT_EOF
expr_stmt|;
name|bev_a
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
name|bufferevent_run_eventcb_
argument_list|(
name|bev
argument_list|,
name|what
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bufferevent_decref_and_unlock_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|bufferevent_async_new_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
decl_stmt|;
name|struct
name|event_iocp_port
modifier|*
name|iocp
decl_stmt|;
name|options
operator||=
name|BEV_OPT_THREADSAFE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iocp
operator|=
name|event_base_get_iocp_
argument_list|(
name|base
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|event_iocp_port_associate_
argument_list|(
name|iocp
argument_list|,
name|fd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|GetLastError
argument_list|()
decl_stmt|;
comment|/* We may have alrady associated this fd with a port. 		 * Let's hope it's this port, and that the error code 		 * for doing this neer changes. */
if|if
condition|(
name|err
operator|!=
name|ERROR_INVALID_PARAMETER
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bev_a
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_async
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|bev
operator|=
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|input
operator|=
name|evbuffer_overlapped_new_
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
name|mm_free
argument_list|(
name|bev_a
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|output
operator|=
name|evbuffer_overlapped_new_
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
name|evbuffer_free
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|bev_a
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|bufferevent_init_common_
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
argument_list|,
name|base
argument_list|,
operator|&
name|bufferevent_ops_async
argument_list|,
name|options
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|evbuffer_add_cb
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|be_async_inbuf_callback
argument_list|,
name|bev
argument_list|)
expr_stmt|;
name|evbuffer_add_cb
argument_list|(
name|bev
operator|->
name|output
argument_list|,
name|be_async_outbuf_callback
argument_list|,
name|bev
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|bev_a
operator|->
name|connect_overlapped
argument_list|,
name|connect_complete
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|bev_a
operator|->
name|read_overlapped
argument_list|,
name|read_complete
argument_list|)
expr_stmt|;
name|event_overlapped_init_
argument_list|(
operator|&
name|bev_a
operator|->
name|write_overlapped
argument_list|,
name|write_complete
argument_list|)
expr_stmt|;
name|bufferevent_init_generic_timeout_cbs_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bev_a
operator|->
name|ok
operator|=
name|fd
operator|>=
literal|0
expr_stmt|;
return|return
name|bev
return|;
name|err
label|:
name|bufferevent_free
argument_list|(
operator|&
name|bev_a
operator|->
name|bev
operator|.
name|bev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_async_set_connected_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|bev_async
operator|->
name|ok
operator|=
literal|1
expr_stmt|;
name|bufferevent_init_generic_timeout_cbs_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
comment|/* Now's a good time to consider reading/writing */
name|be_async_enable
argument_list|(
name|bev
argument_list|,
name|bev
operator|->
name|enabled
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_async_can_connect_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|ext
init|=
name|event_get_win32_extension_fns_
argument_list|()
decl_stmt|;
if|if
condition|(
name|BEV_IS_ASYNC
argument_list|(
name|bev
argument_list|)
operator|&&
name|event_base_get_iocp_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
operator|&&
name|ext
operator|&&
name|ext
operator|->
name|ConnectEx
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_async_connect_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|socklen
parameter_list|)
block|{
name|BOOL
name|rc
decl_stmt|;
name|struct
name|bufferevent_async
modifier|*
name|bev_async
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|ext
init|=
name|event_get_win32_extension_fns_
argument_list|()
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ext
operator|&&
name|ext
operator|->
name|ConnectEx
operator|&&
name|fd
operator|>=
literal|0
operator|&&
name|sa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* ConnectEx() requires that the socket be bound to an address 	 * with bind() before using, otherwise it will fail. We attempt 	 * to issue a bind() here, taking into account that the error 	 * code is set to WSAEINVAL when the socket is already bound. */
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
decl_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
decl_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
block|}
else|else
block|{
comment|/* Well, the user will have to bind() */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|WSAGetLastError
argument_list|()
operator|!=
name|WSAEINVAL
condition|)
return|return
operator|-
literal|1
return|;
name|event_base_add_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
name|bufferevent_incref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ext
operator|->
name|ConnectEx
argument_list|(
name|fd
argument_list|,
name|sa
argument_list|,
name|socklen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|bev_async
operator|->
name|connect_overlapped
operator|.
name|overlapped
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|WSAGetLastError
argument_list|()
operator|==
name|ERROR_IO_PENDING
condition|)
return|return
literal|0
return|;
name|event_base_del_virtual_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
name|bufferevent_decref_
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|be_async_ctrl
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|enum
name|bufferevent_ctrl_op
name|op
parameter_list|,
name|union
name|bufferevent_ctrl_data
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BEV_CTRL_GET_FD
case|:
name|data
operator|->
name|fd
operator|=
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BEV_CTRL_SET_FD
case|:
block|{
name|struct
name|event_iocp_port
modifier|*
name|iocp
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|fd
operator|==
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|iocp
operator|=
name|event_base_get_iocp_
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|event_iocp_port_associate_
argument_list|(
name|iocp
argument_list|,
name|data
operator|->
name|fd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|evbuffer_overlapped_set_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|data
operator|->
name|fd
argument_list|)
expr_stmt|;
name|evbuffer_overlapped_set_fd_
argument_list|(
name|bev
operator|->
name|output
argument_list|,
name|data
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|BEV_CTRL_CANCEL_ALL
case|:
block|{
name|struct
name|bufferevent_async
modifier|*
name|bev_a
init|=
name|upcast
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|evutil_socket_t
name|fd
init|=
name|evbuffer_overlapped_get_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|(
name|evutil_socket_t
operator|)
name|INVALID_SOCKET
operator|&&
operator|(
name|bev_a
operator|->
name|bev
operator|.
name|options
operator|&
name|BEV_OPT_CLOSE_ON_FREE
operator|)
condition|)
block|{
name|closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|evbuffer_overlapped_set_fd_
argument_list|(
name|bev
operator|->
name|input
argument_list|,
name|INVALID_SOCKET
argument_list|)
expr_stmt|;
block|}
name|bev_a
operator|->
name|ok
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|BEV_CTRL_GET_UNDERLYING
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

end_unit

