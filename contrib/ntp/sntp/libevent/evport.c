begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Submitted by David Pacheco (dp.spambait@gmail.com)  *  * Copyright 2006-2007 Niels Provos  * Copyright 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY SUN MICROSYSTEMS, INC. ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2007 Sun Microsystems. All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * evport.c: event backend using Solaris 10 event ports. See port_create(3C).  * This implementation is loosely modeled after the one used for select(2) (in  * select.c).  *  * The outstanding events are tracked in a data structure called evport_data.  * Each entry in the ed_fds array corresponds to a file descriptor, and contains  * pointers to the read and write events that correspond to that fd. (That is,  * when the file is readable, the "read" event should handle it, etc.)  *  * evport_add and evport_del update this data structure. evport_dispatch uses it  * to determine where to callback when an event occurs (which it gets from  * port_getn).  *  * Helper functions are used: grow() grows the file descriptor array as  * necessary when large fd's come in. reassociate() takes care of maintaining  * the proper file-descriptor/event-port associations.  *  * As in the select(2) implementation, signals are handled by evsignal.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENT_PORTS
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<port.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"evsignal-internal.h"
end_include

begin_include
include|#
directive|include
file|"evmap-internal.h"
end_include

begin_define
define|#
directive|define
name|INITIAL_EVENTS_PER_GETN
value|8
end_define

begin_define
define|#
directive|define
name|MAX_EVENTS_PER_GETN
value|4096
end_define

begin_comment
comment|/*  * Per-file-descriptor information about what events we're subscribed to. These  * fields are NULL if no event is subscribed to either of them.  */
end_comment

begin_struct
struct|struct
name|fd_info
block|{
comment|/* combinations of EV_READ and EV_WRITE */
name|short
name|fdi_what
decl_stmt|;
comment|/* Index of this fd within ed_pending, plus 1.  Zero if this fd is 	 * not in ed_pending.  (The +1 is a hack so that memset(0) will set 	 * it to a nil index. */
name|int
name|pending_idx_plus_1
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FDI_HAS_READ
parameter_list|(
name|fdi
parameter_list|)
value|((fdi)->fdi_what& EV_READ)
end_define

begin_define
define|#
directive|define
name|FDI_HAS_WRITE
parameter_list|(
name|fdi
parameter_list|)
value|((fdi)->fdi_what& EV_WRITE)
end_define

begin_define
define|#
directive|define
name|FDI_HAS_EVENTS
parameter_list|(
name|fdi
parameter_list|)
value|(FDI_HAS_READ(fdi) || FDI_HAS_WRITE(fdi))
end_define

begin_define
define|#
directive|define
name|FDI_TO_SYSEVENTS
parameter_list|(
name|fdi
parameter_list|)
value|(FDI_HAS_READ(fdi) ? POLLIN : 0) | \     (FDI_HAS_WRITE(fdi) ? POLLOUT : 0)
end_define

begin_struct
struct|struct
name|evport_data
block|{
name|int
name|ed_port
decl_stmt|;
comment|/* event port for system events  */
comment|/* How many elements of ed_pending should we look at? */
name|int
name|ed_npending
decl_stmt|;
comment|/* How many elements are allocated in ed_pending and pevtlist? */
name|int
name|ed_maxevents
decl_stmt|;
comment|/* fdi's that we need to reassoc */
name|int
modifier|*
name|ed_pending
decl_stmt|;
comment|/* storage space for incoming events. */
name|port_event_t
modifier|*
name|ed_pevtlist
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
modifier|*
name|evport_init
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evport_add
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evport_del
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evport_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evport_dealloc
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|grow
parameter_list|(
name|struct
name|evport_data
modifier|*
parameter_list|,
name|int
name|min_events
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|eventop
name|evportops
init|=
block|{
literal|"evport"
block|,
name|evport_init
block|,
name|evport_add
block|,
name|evport_del
block|,
name|evport_dispatch
block|,
name|evport_dealloc
block|,
literal|1
block|,
comment|/* need reinit */
literal|0
block|,
comment|/* features */
sizeof|sizeof
argument_list|(
expr|struct
name|fd_info
argument_list|)
block|,
comment|/* fdinfo length */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the event port implementation.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|evport_init
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|evport_data
modifier|*
name|evpd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|evpd
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evport_data
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|evpd
operator|->
name|ed_port
operator|=
name|port_create
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|mm_free
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|grow
argument_list|(
name|evpd
argument_list|,
name|INITIAL_EVENTS_PER_GETN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|evpd
operator|->
name|ed_port
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|evpd
operator|->
name|ed_npending
operator|=
literal|0
expr_stmt|;
name|evsig_init_
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|evpd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|grow
parameter_list|(
name|struct
name|evport_data
modifier|*
name|data
parameter_list|,
name|int
name|min_events
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|;
name|int
modifier|*
name|new_pending
decl_stmt|;
name|port_event_t
modifier|*
name|new_pevtlist
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|ed_maxevents
condition|)
block|{
name|newsize
operator|=
name|data
operator|->
name|ed_maxevents
expr_stmt|;
do|do
block|{
name|newsize
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|newsize
operator|<
name|min_events
condition|)
do|;
block|}
else|else
block|{
name|newsize
operator|=
name|min_events
expr_stmt|;
block|}
name|new_pending
operator|=
name|mm_realloc
argument_list|(
name|data
operator|->
name|ed_pending
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pending
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|ed_pending
operator|=
name|new_pending
expr_stmt|;
name|new_pevtlist
operator|=
name|mm_realloc
argument_list|(
name|data
operator|->
name|ed_pevtlist
argument_list|,
sizeof|sizeof
argument_list|(
name|port_event_t
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pevtlist
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|ed_pevtlist
operator|=
name|new_pevtlist
expr_stmt|;
name|data
operator|->
name|ed_maxevents
operator|=
name|newsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CHECK_INVARIANTS
end_ifdef

begin_comment
comment|/*  * Checks some basic properties about the evport_data structure. Because it  * checks all file descriptors, this function can be expensive when the maximum  * file descriptor ever used is rather large.  */
end_comment

begin_function
specifier|static
name|void
name|check_evportop
parameter_list|(
name|struct
name|evport_data
modifier|*
name|evpd
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evpd
operator|->
name|ed_port
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verifies very basic integrity of a given port_event.  */
end_comment

begin_function
specifier|static
name|void
name|check_event
parameter_list|(
name|port_event_t
modifier|*
name|pevt
parameter_list|)
block|{
comment|/* 	 * We've only registered for PORT_SOURCE_FD events. The only 	 * other thing we can legitimately receive is PORT_SOURCE_ALERT, 	 * but since we're not using port_alert either, we can assume 	 * PORT_SOURCE_FD. 	 */
name|EVUTIL_ASSERT
argument_list|(
name|pevt
operator|->
name|portev_source
operator|==
name|PORT_SOURCE_FD
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|check_evportop
parameter_list|(
name|epop
parameter_list|)
end_define

begin_define
define|#
directive|define
name|check_event
parameter_list|(
name|pevt
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHECK_INVARIANTS */
end_comment

begin_comment
comment|/*  * (Re)associates the given file descriptor with the event port. The OS events  * are specified (implicitly) from the fd_info struct.  */
end_comment

begin_function
specifier|static
name|int
name|reassociate
parameter_list|(
name|struct
name|evport_data
modifier|*
name|epdp
parameter_list|,
name|struct
name|fd_info
modifier|*
name|fdip
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|int
name|sysevents
init|=
name|FDI_TO_SYSEVENTS
argument_list|(
name|fdip
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysevents
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|port_associate
argument_list|(
name|epdp
operator|->
name|ed_port
argument_list|,
name|PORT_SOURCE_FD
argument_list|,
name|fd
argument_list|,
name|sysevents
argument_list|,
name|fdip
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"port_associate"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|check_evportop
argument_list|(
name|epdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main event loop - polls port_getn for some number of events, and processes  * them.  */
end_comment

begin_function
specifier|static
name|int
name|evport_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|res
decl_stmt|;
name|struct
name|evport_data
modifier|*
name|epdp
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|port_event_t
modifier|*
name|pevtlist
init|=
name|epdp
operator|->
name|ed_pevtlist
decl_stmt|;
comment|/* 	 * port_getn will block until it has at least nevents events. It will 	 * also return how many it's given us (which may be more than we asked 	 * for, as long as it's less than our maximum (ed_maxevents)) in 	 * nevents. 	 */
name|int
name|nevents
init|=
literal|1
decl_stmt|;
comment|/* 	 * We have to convert a struct timeval to a struct timespec 	 * (only difference is nanoseconds vs. microseconds). If no time-based 	 * events are active, we should wait for I/O (and tv == NULL). 	 */
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timespec
modifier|*
name|ts_p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tv
operator|!=
name|NULL
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|=
name|tv
operator|->
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|tv
operator|->
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|ts_p
operator|=
operator|&
name|ts
expr_stmt|;
block|}
comment|/* 	 * Before doing anything else, we need to reassociate the events we hit 	 * last time which need reassociation. See comment at the end of the 	 * loop below. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epdp
operator|->
name|ed_npending
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|fd_info
modifier|*
name|fdi
init|=
name|NULL
decl_stmt|;
specifier|const
name|int
name|fd
init|=
name|epdp
operator|->
name|ed_pending
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We might have cleared out this event; we need 			 * to be sure that it's still set. */
name|fdi
operator|=
name|evmap_io_get_fdinfo_
argument_list|(
operator|&
name|base
operator|->
name|io
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdi
operator|!=
name|NULL
operator|&&
name|FDI_HAS_EVENTS
argument_list|(
name|fdi
argument_list|)
condition|)
block|{
name|reassociate
argument_list|(
name|epdp
argument_list|,
name|fdi
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* epdp->ed_pending[i] = -1; */
name|fdi
operator|->
name|pending_idx_plus_1
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|port_getn
argument_list|(
name|epdp
operator|->
name|ed_port
argument_list|,
name|pevtlist
argument_list|,
name|epdp
operator|->
name|ed_maxevents
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|nevents
argument_list|,
name|ts_p
argument_list|)
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ETIME
condition|)
block|{
if|if
condition|(
name|nevents
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|event_warn
argument_list|(
literal|"port_getn"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: port_getn reports %d events"
operator|,
name|__func__
operator|,
name|nevents
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nevents
condition|;
operator|++
name|i
control|)
block|{
name|port_event_t
modifier|*
name|pevt
init|=
operator|&
name|pevtlist
index|[
name|i
index|]
decl_stmt|;
name|int
name|fd
init|=
operator|(
name|int
operator|)
name|pevt
operator|->
name|portev_object
decl_stmt|;
name|struct
name|fd_info
modifier|*
name|fdi
init|=
name|pevt
operator|->
name|portev_user
decl_stmt|;
comment|/*EVUTIL_ASSERT(evmap_io_get_fdinfo_(&base->io, fd) == fdi);*/
name|check_evportop
argument_list|(
name|epdp
argument_list|)
expr_stmt|;
name|check_event
argument_list|(
name|pevt
argument_list|)
expr_stmt|;
name|epdp
operator|->
name|ed_pending
index|[
name|i
index|]
operator|=
name|fd
expr_stmt|;
name|fdi
operator|->
name|pending_idx_plus_1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Figure out what kind of event it was 		 * (because we have to pass this to the callback) 		 */
name|res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pevt
operator|->
name|portev_events
operator|&
operator|(
name|POLLERR
operator||
name|POLLHUP
operator|)
condition|)
block|{
name|res
operator|=
name|EV_READ
operator||
name|EV_WRITE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pevt
operator|->
name|portev_events
operator|&
name|POLLIN
condition|)
name|res
operator||=
name|EV_READ
expr_stmt|;
if|if
condition|(
name|pevt
operator|->
name|portev_events
operator|&
name|POLLOUT
condition|)
name|res
operator||=
name|EV_WRITE
expr_stmt|;
block|}
comment|/* 		 * Check for the error situations or a hangup situation 		 */
if|if
condition|(
name|pevt
operator|->
name|portev_events
operator|&
operator|(
name|POLLERR
operator||
name|POLLHUP
operator||
name|POLLNVAL
operator|)
condition|)
name|res
operator||=
name|EV_READ
operator||
name|EV_WRITE
expr_stmt|;
name|evmap_io_active_
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
comment|/* end of all events gotten */
name|epdp
operator|->
name|ed_npending
operator|=
name|nevents
expr_stmt|;
if|if
condition|(
name|nevents
operator|==
name|epdp
operator|->
name|ed_maxevents
operator|&&
name|epdp
operator|->
name|ed_maxevents
operator|<
name|MAX_EVENTS_PER_GETN
condition|)
block|{
comment|/* we used all the space this time.  We should be ready 		 * for more events next time around. */
name|grow
argument_list|(
name|epdp
argument_list|,
name|epdp
operator|->
name|ed_maxevents
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|check_evportop
argument_list|(
name|epdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adds the given event (so that you will be notified when it happens via  * the callback function).  */
end_comment

begin_function
specifier|static
name|int
name|evport_add
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|evport_data
modifier|*
name|evpd
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|fd_info
modifier|*
name|fdi
init|=
name|p
decl_stmt|;
name|check_evportop
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
name|fdi
operator|->
name|fdi_what
operator||=
name|events
expr_stmt|;
return|return
name|reassociate
argument_list|(
name|evpd
argument_list|,
name|fdi
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes the given event from the list of events to wait for.  */
end_comment

begin_function
specifier|static
name|int
name|evport_del
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|evport_data
modifier|*
name|evpd
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|fd_info
modifier|*
name|fdi
init|=
name|p
decl_stmt|;
name|int
name|associated
init|=
operator|!
name|fdi
operator|->
name|pending_idx_plus_1
decl_stmt|;
name|check_evportop
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
name|fdi
operator|->
name|fdi_what
operator|&=
operator|~
operator|(
name|events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|associated
condition|)
block|{
if|if
condition|(
operator|!
name|FDI_HAS_EVENTS
argument_list|(
name|fdi
argument_list|)
operator|&&
name|port_dissociate
argument_list|(
name|evpd
operator|->
name|ed_port
argument_list|,
name|PORT_SOURCE_FD
argument_list|,
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Ignore EBADFD error the fd could have been closed 			 * before event_del() was called. 			 */
if|if
condition|(
name|errno
operator|!=
name|EBADFD
condition|)
block|{
name|event_warn
argument_list|(
literal|"port_dissociate"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|FDI_HAS_EVENTS
argument_list|(
name|fdi
argument_list|)
condition|)
block|{
return|return
operator|(
name|reassociate
argument_list|(
name|evpd
argument_list|,
name|fdi
argument_list|,
name|fd
argument_list|)
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fdi
operator|->
name|fdi_what
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|int
name|i
init|=
name|fdi
operator|->
name|pending_idx_plus_1
operator|-
literal|1
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evpd
operator|->
name|ed_pending
index|[
name|i
index|]
operator|==
name|fd
argument_list|)
expr_stmt|;
name|evpd
operator|->
name|ed_pending
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|fdi
operator|->
name|pending_idx_plus_1
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evport_dealloc
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|evport_data
modifier|*
name|evpd
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|evsig_dealloc_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|evpd
operator|->
name|ed_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|evpd
operator|->
name|ed_pending
condition|)
name|mm_free
argument_list|(
name|evpd
operator|->
name|ed_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|evpd
operator|->
name|ed_pevtlist
condition|)
name|mm_free
argument_list|(
name|evpd
operator|->
name|ed_pevtlist
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|evpd
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EVENT__HAVE_EVENT_PORTS */
end_comment

end_unit

