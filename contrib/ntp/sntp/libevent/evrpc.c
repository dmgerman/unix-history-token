begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/rpc.h"
end_include

begin_include
include|#
directive|include
file|"event2/rpc_struct.h"
end_include

begin_include
include|#
directive|include
file|"evrpc-internal.h"
end_include

begin_include
include|#
directive|include
file|"event2/http.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/tag.h"
end_include

begin_include
include|#
directive|include
file|"event2/http_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/http_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_function
name|struct
name|evrpc_base
modifier|*
name|evrpc_init
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http_server
parameter_list|)
block|{
name|struct
name|evrpc_base
modifier|*
name|base
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_base
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* we rely on the tagging sub system */
name|evtag_init
argument_list|()
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|registered_rpcs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|input_hooks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|output_hooks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|paused_requests
argument_list|)
expr_stmt|;
name|base
operator|->
name|http_server
operator|=
name|http_server
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evrpc_free
parameter_list|(
name|struct
name|evrpc_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|evrpc
modifier|*
name|rpc
decl_stmt|;
name|struct
name|evrpc_hook
modifier|*
name|hook
decl_stmt|;
name|struct
name|evrpc_hook_ctx
modifier|*
name|pause
decl_stmt|;
name|int
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|rpc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|registered_rpcs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|evrpc_unregister_rpc
argument_list|(
name|base
argument_list|,
name|rpc
operator|->
name|uri
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pause
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|paused_requests
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|paused_requests
argument_list|,
name|pause
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|hook
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|input_hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|evrpc_remove_hook
argument_list|(
name|base
argument_list|,
name|EVRPC_INPUT
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|hook
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|output_hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|evrpc_remove_hook
argument_list|(
name|base
argument_list|,
name|EVRPC_OUTPUT
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|evrpc_add_hook
parameter_list|(
name|void
modifier|*
name|vbase
parameter_list|,
name|enum
name|EVRPC_HOOK_TYPE
name|hook_type
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|struct
name|evbuffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|struct
name|evrpc_hooks_
modifier|*
name|base
init|=
name|vbase
decl_stmt|;
name|struct
name|evrpc_hook_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|struct
name|evrpc_hook
modifier|*
name|hook
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|hook_type
condition|)
block|{
case|case
name|EVRPC_INPUT
case|:
name|head
operator|=
operator|&
name|base
operator|->
name|in_hooks
expr_stmt|;
break|break;
case|case
name|EVRPC_OUTPUT
case|:
name|head
operator|=
operator|&
name|base
operator|->
name|out_hooks
expr_stmt|;
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_type
operator|==
name|EVRPC_INPUT
operator|||
name|hook_type
operator|==
name|EVRPC_OUTPUT
argument_list|)
expr_stmt|;
block|}
name|hook
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_hook
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|hook
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hook
operator|->
name|process
operator|=
name|cb
expr_stmt|;
name|hook
operator|->
name|process_arg
operator|=
name|cb_arg
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|hook
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evrpc_remove_hook_internal
parameter_list|(
name|struct
name|evrpc_hook_list
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|evrpc_hook
modifier|*
name|hook
init|=
name|NULL
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|head
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|hook
operator|==
name|handle
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|hook
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove the hook specified by the handle  */
end_comment

begin_function
name|int
name|evrpc_remove_hook
parameter_list|(
name|void
modifier|*
name|vbase
parameter_list|,
name|enum
name|EVRPC_HOOK_TYPE
name|hook_type
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|evrpc_hooks_
modifier|*
name|base
init|=
name|vbase
decl_stmt|;
name|struct
name|evrpc_hook_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|hook_type
condition|)
block|{
case|case
name|EVRPC_INPUT
case|:
name|head
operator|=
operator|&
name|base
operator|->
name|in_hooks
expr_stmt|;
break|break;
case|case
name|EVRPC_OUTPUT
case|:
name|head
operator|=
operator|&
name|base
operator|->
name|out_hooks
expr_stmt|;
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_type
operator|==
name|EVRPC_INPUT
operator|||
name|hook_type
operator|==
name|EVRPC_OUTPUT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|evrpc_remove_hook_internal
argument_list|(
name|head
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evrpc_process_hooks
parameter_list|(
name|struct
name|evrpc_hook_list
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|)
block|{
name|struct
name|evrpc_hook
modifier|*
name|hook
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|head
argument_list|,
argument|next
argument_list|)
block|{
name|int
name|res
init|=
name|hook
operator|->
name|process
argument_list|(
name|ctx
argument_list|,
name|req
argument_list|,
name|evbuf
argument_list|,
name|hook
operator|->
name|process_arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|EVRPC_CONTINUE
condition|)
return|return
operator|(
name|res
operator|)
return|;
block|}
return|return
operator|(
name|EVRPC_CONTINUE
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|evrpc_pool_schedule
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evrpc_request_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Registers a new RPC with the HTTP server.   The evrpc object is expected  * to have been filled in via the EVRPC_REGISTER_OBJECT macro which in turn  * calls this function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|evrpc_construct_uri
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
name|char
modifier|*
name|constructed_uri
decl_stmt|;
name|size_t
name|constructed_uri_len
decl_stmt|;
name|constructed_uri_len
operator|=
name|strlen
argument_list|(
name|EVRPC_URI_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|uri
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|constructed_uri
operator|=
name|mm_malloc
argument_list|(
name|constructed_uri_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|event_err
argument_list|(
literal|1
argument_list|,
literal|"%s: failed to register rpc at %s"
argument_list|,
name|__func__
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|constructed_uri
argument_list|,
name|EVRPC_URI_PREFIX
argument_list|,
name|strlen
argument_list|(
name|EVRPC_URI_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|constructed_uri
operator|+
name|strlen
argument_list|(
name|EVRPC_URI_PREFIX
argument_list|)
argument_list|,
name|uri
argument_list|,
name|strlen
argument_list|(
name|uri
argument_list|)
argument_list|)
expr_stmt|;
name|constructed_uri
index|[
name|constructed_uri_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|constructed_uri
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_register_rpc
parameter_list|(
name|struct
name|evrpc_base
modifier|*
name|base
parameter_list|,
name|struct
name|evrpc
modifier|*
name|rpc
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|char
modifier|*
name|constructed_uri
init|=
name|evrpc_construct_uri
argument_list|(
name|rpc
operator|->
name|uri
argument_list|)
decl_stmt|;
name|rpc
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|rpc
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|rpc
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|registered_rpcs
argument_list|,
name|rpc
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evhttp_set_cb
argument_list|(
name|base
operator|->
name|http_server
argument_list|,
name|constructed_uri
argument_list|,
name|evrpc_request_cb
argument_list|,
name|rpc
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|constructed_uri
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_unregister_rpc
parameter_list|(
name|struct
name|evrpc_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|registered_uri
init|=
name|NULL
decl_stmt|;
name|struct
name|evrpc
modifier|*
name|rpc
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* find the right rpc; linear search might be slow */
name|TAILQ_FOREACH
argument_list|(
argument|rpc
argument_list|,
argument|&base->registered_rpcs
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rpc
operator|->
name|uri
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rpc
operator|==
name|NULL
condition|)
block|{
comment|/* We did not find an RPC with this name */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|registered_rpcs
argument_list|,
name|rpc
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|registered_uri
operator|=
name|evrpc_construct_uri
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* remove the http server callback */
name|r
operator|=
name|evhttp_del_cb
argument_list|(
name|base
operator|->
name|http_server
argument_list|,
name|registered_uri
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|registered_uri
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpc
operator|->
name|uri
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|rpc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|evrpc_pause_request
parameter_list|(
name|void
modifier|*
name|vbase
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evrpc_request_cb_closure
parameter_list|(
name|void
modifier|*
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|evrpc_request_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evrpc
modifier|*
name|rpc
init|=
name|arg
decl_stmt|;
name|struct
name|evrpc_req_generic
modifier|*
name|rpc_state
init|=
name|NULL
decl_stmt|;
comment|/* let's verify the outside parameters */
if|if
condition|(
name|req
operator|->
name|type
operator|!=
name|EVHTTP_REQ_POST
operator|||
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
name|rpc_state
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_req_generic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|rpc_state
operator|->
name|rpc
operator|=
name|rpc
expr_stmt|;
name|rpc_state
operator|->
name|http_req
operator|=
name|req
expr_stmt|;
name|rpc_state
operator|->
name|rpc_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rpc
operator|->
name|base
operator|->
name|input_hooks
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|hook_res
decl_stmt|;
name|evrpc_hook_associate_meta_
argument_list|(
operator|&
name|rpc_state
operator|->
name|hook_meta
argument_list|,
name|req
operator|->
name|evcon
argument_list|)
expr_stmt|;
comment|/* 		 * allow hooks to modify the outgoing request 		 */
name|hook_res
operator|=
name|evrpc_process_hooks
argument_list|(
operator|&
name|rpc
operator|->
name|base
operator|->
name|input_hooks
argument_list|,
name|rpc_state
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hook_res
condition|)
block|{
case|case
name|EVRPC_TERMINATE
case|:
goto|goto
name|error
goto|;
case|case
name|EVRPC_PAUSE
case|:
name|evrpc_pause_request
argument_list|(
name|rpc
operator|->
name|base
argument_list|,
name|rpc_state
argument_list|,
name|evrpc_request_cb_closure
argument_list|)
expr_stmt|;
return|return;
case|case
name|EVRPC_CONTINUE
case|:
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
operator|||
name|hook_res
operator|==
name|EVRPC_CONTINUE
operator|||
name|hook_res
operator|==
name|EVRPC_PAUSE
argument_list|)
expr_stmt|;
block|}
block|}
name|evrpc_request_cb_closure
argument_list|(
name|rpc_state
argument_list|,
name|EVRPC_CONTINUE
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|evrpc_reqstate_free_
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_SERVUNAVAIL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_request_cb_closure
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
name|hook_res
parameter_list|)
block|{
name|struct
name|evrpc_req_generic
modifier|*
name|rpc_state
init|=
name|arg
decl_stmt|;
name|struct
name|evrpc
modifier|*
name|rpc
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|rpc
operator|=
name|rpc_state
operator|->
name|rpc
expr_stmt|;
name|req
operator|=
name|rpc_state
operator|->
name|http_req
expr_stmt|;
if|if
condition|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
condition|)
goto|goto
name|error
goto|;
comment|/* let's check that we can parse the request */
name|rpc_state
operator|->
name|request
operator|=
name|rpc
operator|->
name|request_new
argument_list|(
name|rpc
operator|->
name|request_new_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|->
name|request
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|rpc
operator|->
name|request_unmarshal
argument_list|(
name|rpc_state
operator|->
name|request
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* we failed to parse the request; that's a bummer */
goto|goto
name|error
goto|;
block|}
comment|/* at this point, we have a well formed request, prepare the reply */
name|rpc_state
operator|->
name|reply
operator|=
name|rpc
operator|->
name|reply_new
argument_list|(
name|rpc
operator|->
name|reply_new_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|->
name|reply
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* give the rpc to the user; they can deal with it */
name|rpc
operator|->
name|cb
argument_list|(
name|rpc_state
argument_list|,
name|rpc
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|evrpc_reqstate_free_
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_SERVUNAVAIL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|evrpc_reqstate_free_
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
name|rpc_state
parameter_list|)
block|{
name|struct
name|evrpc
modifier|*
name|rpc
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|rpc_state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rpc
operator|=
name|rpc_state
operator|->
name|rpc
expr_stmt|;
comment|/* clean up all memory */
if|if
condition|(
name|rpc_state
operator|->
name|hook_meta
operator|!=
name|NULL
condition|)
name|evrpc_hook_context_free_
argument_list|(
name|rpc_state
operator|->
name|hook_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|->
name|request
operator|!=
name|NULL
condition|)
name|rpc
operator|->
name|request_free
argument_list|(
name|rpc_state
operator|->
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|->
name|reply
operator|!=
name|NULL
condition|)
name|rpc
operator|->
name|reply_free
argument_list|(
name|rpc_state
operator|->
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc_state
operator|->
name|rpc_data
operator|!=
name|NULL
condition|)
name|evbuffer_free
argument_list|(
name|rpc_state
operator|->
name|rpc_data
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|evrpc_request_done_closure
parameter_list|(
name|void
modifier|*
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|evrpc_request_done
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
name|rpc_state
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
name|struct
name|evrpc
modifier|*
name|rpc
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|req
operator|=
name|rpc_state
operator|->
name|http_req
expr_stmt|;
name|rpc
operator|=
name|rpc_state
operator|->
name|rpc
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|reply_complete
argument_list|(
name|rpc_state
operator|->
name|reply
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* the reply was not completely filled in.  error out */
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|rpc_state
operator|->
name|rpc_data
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
goto|goto
name|error
goto|;
block|}
comment|/* serialize the reply */
name|rpc
operator|->
name|reply_marshal
argument_list|(
name|rpc_state
operator|->
name|rpc_data
argument_list|,
name|rpc_state
operator|->
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|rpc
operator|->
name|base
operator|->
name|output_hooks
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|hook_res
decl_stmt|;
name|evrpc_hook_associate_meta_
argument_list|(
operator|&
name|rpc_state
operator|->
name|hook_meta
argument_list|,
name|req
operator|->
name|evcon
argument_list|)
expr_stmt|;
comment|/* do hook based tweaks to the request */
name|hook_res
operator|=
name|evrpc_process_hooks
argument_list|(
operator|&
name|rpc
operator|->
name|base
operator|->
name|output_hooks
argument_list|,
name|rpc_state
argument_list|,
name|req
argument_list|,
name|rpc_state
operator|->
name|rpc_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hook_res
condition|)
block|{
case|case
name|EVRPC_TERMINATE
case|:
goto|goto
name|error
goto|;
case|case
name|EVRPC_PAUSE
case|:
if|if
condition|(
name|evrpc_pause_request
argument_list|(
name|rpc
operator|->
name|base
argument_list|,
name|rpc_state
argument_list|,
name|evrpc_request_done_closure
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
return|return;
case|case
name|EVRPC_CONTINUE
case|:
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
operator|||
name|hook_res
operator|==
name|EVRPC_CONTINUE
operator|||
name|hook_res
operator|==
name|EVRPC_PAUSE
argument_list|)
expr_stmt|;
block|}
block|}
name|evrpc_request_done_closure
argument_list|(
name|rpc_state
argument_list|,
name|EVRPC_CONTINUE
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|evrpc_reqstate_free_
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_SERVUNAVAIL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
modifier|*
name|evrpc_get_request
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
name|req
parameter_list|)
block|{
return|return
name|req
operator|->
name|request
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|evrpc_get_reply
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
name|req
parameter_list|)
block|{
return|return
name|req
operator|->
name|reply
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_request_done_closure
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
name|hook_res
parameter_list|)
block|{
name|struct
name|evrpc_req_generic
modifier|*
name|rpc_state
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|req
operator|=
name|rpc_state
operator|->
name|http_req
expr_stmt|;
if|if
condition|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
condition|)
goto|goto
name|error
goto|;
comment|/* on success, we are going to transmit marshaled binary data */
if|if
condition|(
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Type"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Type"
argument_list|,
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
block|}
name|evhttp_send_reply
argument_list|(
name|req
argument_list|,
name|HTTP_OK
argument_list|,
literal|"OK"
argument_list|,
name|rpc_state
operator|->
name|rpc_data
argument_list|)
expr_stmt|;
name|evrpc_reqstate_free_
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
return|return;
name|error
label|:
name|evrpc_reqstate_free_
argument_list|(
name|rpc_state
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_SERVUNAVAIL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Client implementation of RPC site */
end_comment

begin_function_decl
specifier|static
name|int
name|evrpc_schedule_request
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|connection
parameter_list|,
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|evrpc_pool
modifier|*
name|evrpc_pool_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_pool
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|paused_requests
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|input_hooks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|output_hooks
argument_list|)
expr_stmt|;
name|pool
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|pool
operator|->
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|pool
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_request_wrapper_free
parameter_list|(
name|struct
name|evrpc_request_wrapper
modifier|*
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|->
name|hook_meta
operator|!=
name|NULL
condition|)
name|evrpc_hook_context_free_
argument_list|(
name|request
operator|->
name|hook_meta
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|request
operator|->
name|name
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evrpc_pool_free
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|connection
decl_stmt|;
name|struct
name|evrpc_request_wrapper
modifier|*
name|request
decl_stmt|;
name|struct
name|evrpc_hook_ctx
modifier|*
name|pause
decl_stmt|;
name|struct
name|evrpc_hook
modifier|*
name|hook
decl_stmt|;
name|int
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|request
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|,
name|request
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evrpc_request_wrapper_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pause
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|paused_requests
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|paused_requests
argument_list|,
name|pause
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|pause
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|connection
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|,
name|connection
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evhttp_connection_free
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|hook
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|input_hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|evrpc_remove_hook
argument_list|(
name|pool
argument_list|,
name|EVRPC_INPUT
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|hook
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|output_hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|evrpc_remove_hook
argument_list|(
name|pool
argument_list|,
name|EVRPC_OUTPUT
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a connection to the RPC pool.   A request scheduled on the pool  * may use any available connection.  */
end_comment

begin_function
name|void
name|evrpc_pool_add_connection
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|,
name|struct
name|evhttp_connection
modifier|*
name|connection
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|connection
operator|->
name|http_server
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|,
name|connection
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 	 * associate an event base with this connection 	 */
if|if
condition|(
name|pool
operator|->
name|base
operator|!=
name|NULL
condition|)
name|evhttp_connection_set_base
argument_list|(
name|connection
argument_list|,
name|pool
operator|->
name|base
argument_list|)
expr_stmt|;
comment|/* 	 * unless a timeout was specifically set for a connection, 	 * the connection inherits the timeout from the pool. 	 */
if|if
condition|(
operator|!
name|evutil_timerisset
argument_list|(
operator|&
name|connection
operator|->
name|timeout
argument_list|)
condition|)
name|evhttp_connection_set_timeout
argument_list|(
name|connection
argument_list|,
name|pool
operator|->
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	 * if we have any requests pending, schedule them with the new 	 * connections. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|request
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|)
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|,
name|request
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evrpc_schedule_request
argument_list|(
name|connection
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evrpc_pool_remove_connection
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|,
name|struct
name|evhttp_connection
modifier|*
name|connection
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|,
name|connection
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evrpc_pool_set_timeout
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|,
name|int
name|timeout_in_secs
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|evcon
argument_list|,
argument|&pool->connections
argument_list|,
argument|next
argument_list|)
block|{
name|evhttp_connection_set_timeout
argument_list|(
name|evcon
argument_list|,
name|timeout_in_secs
argument_list|)
expr_stmt|;
block|}
name|pool
operator|->
name|timeout
operator|=
name|timeout_in_secs
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|evrpc_reply_done
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evrpc_request_timeout
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Finds a connection object associated with the pool that is currently  * idle and can be used to make a request.  */
end_comment

begin_function
specifier|static
name|struct
name|evhttp_connection
modifier|*
name|evrpc_pool_find_connection
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|connection
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|connection
argument_list|,
argument|&pool->connections
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|connection
operator|->
name|requests
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|connection
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prototypes responsible for evrpc scheduling and hooking  */
end_comment

begin_function_decl
specifier|static
name|void
name|evrpc_schedule_request_closure
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We assume that the ctx is no longer queued on the pool.  */
end_comment

begin_function
specifier|static
name|int
name|evrpc_schedule_request
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|connection
parameter_list|,
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|ctx
operator|->
name|pool
decl_stmt|;
name|struct
name|evrpc_status
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|evhttp_request_new
argument_list|(
name|evrpc_reply_done
argument_list|,
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* serialize the request data into the output buffer */
name|ctx
operator|->
name|request_marshal
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|,
name|ctx
operator|->
name|request
argument_list|)
expr_stmt|;
comment|/* we need to know the connection that we might have to abort */
name|ctx
operator|->
name|evcon
operator|=
name|connection
expr_stmt|;
comment|/* if we get paused we also need to know the request */
name|ctx
operator|->
name|req
operator|=
name|req
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|output_hooks
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|hook_res
decl_stmt|;
name|evrpc_hook_associate_meta_
argument_list|(
operator|&
name|ctx
operator|->
name|hook_meta
argument_list|,
name|connection
argument_list|)
expr_stmt|;
comment|/* apply hooks to the outgoing request */
name|hook_res
operator|=
name|evrpc_process_hooks
argument_list|(
operator|&
name|pool
operator|->
name|output_hooks
argument_list|,
name|ctx
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|output_buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hook_res
condition|)
block|{
case|case
name|EVRPC_TERMINATE
case|:
goto|goto
name|error
goto|;
case|case
name|EVRPC_PAUSE
case|:
comment|/* we need to be explicitly resumed */
if|if
condition|(
name|evrpc_pause_request
argument_list|(
name|pool
argument_list|,
name|ctx
argument_list|,
name|evrpc_schedule_request_closure
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVRPC_CONTINUE
case|:
comment|/* we can just continue */
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
operator|||
name|hook_res
operator|==
name|EVRPC_CONTINUE
operator|||
name|hook_res
operator|==
name|EVRPC_PAUSE
argument_list|)
expr_stmt|;
block|}
block|}
name|evrpc_schedule_request_closure
argument_list|(
name|ctx
argument_list|,
name|EVRPC_CONTINUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|memset
argument_list|(
operator|&
name|status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_UNSTARTED
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|cb
call|)
argument_list|(
operator|&
name|status
argument_list|,
name|ctx
operator|->
name|request
argument_list|,
name|ctx
operator|->
name|reply
argument_list|,
name|ctx
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|evrpc_request_wrapper_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_schedule_request_closure
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
name|hook_res
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_connection
modifier|*
name|connection
init|=
name|ctx
operator|->
name|evcon
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|ctx
operator|->
name|req
decl_stmt|;
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|ctx
operator|->
name|pool
decl_stmt|;
name|struct
name|evrpc_status
name|status
decl_stmt|;
name|char
modifier|*
name|uri
init|=
name|NULL
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
condition|)
goto|goto
name|error
goto|;
name|uri
operator|=
name|evrpc_construct_uri
argument_list|(
name|ctx
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|pool
operator|->
name|timeout
operator|>
literal|0
condition|)
block|{
comment|/* 		 * a timeout after which the whole rpc is going to be aborted. 		 */
name|struct
name|timeval
name|tv
decl_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|pool
operator|->
name|timeout
expr_stmt|;
name|evtimer_add
argument_list|(
operator|&
name|ctx
operator|->
name|ev_timeout
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
comment|/* start the request over the connection */
name|res
operator|=
name|evhttp_make_request
argument_list|(
name|connection
argument_list|,
name|req
argument_list|,
name|EVHTTP_REQ_POST
argument_list|,
name|uri
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
return|return;
name|error
label|:
name|memset
argument_list|(
operator|&
name|status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_UNSTARTED
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|cb
call|)
argument_list|(
operator|&
name|status
argument_list|,
name|ctx
operator|->
name|request
argument_list|,
name|ctx
operator|->
name|reply
argument_list|,
name|ctx
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|evrpc_request_wrapper_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* we just queue the paused request on the pool under the req object */
end_comment

begin_function
specifier|static
name|int
name|evrpc_pause_request
parameter_list|(
name|void
modifier|*
name|vbase
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
parameter_list|)
block|{
name|struct
name|evrpc_hooks_
modifier|*
name|base
init|=
name|vbase
decl_stmt|;
name|struct
name|evrpc_hook_ctx
modifier|*
name|pause
init|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pause
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pause
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pause
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|pause
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|pause_requests
argument_list|,
name|pause
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_resume_request
parameter_list|(
name|void
modifier|*
name|vbase
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
name|res
parameter_list|)
block|{
name|struct
name|evrpc_hooks_
modifier|*
name|base
init|=
name|vbase
decl_stmt|;
name|struct
name|evrpc_pause_list
modifier|*
name|head
init|=
operator|&
name|base
operator|->
name|pause_requests
decl_stmt|;
name|struct
name|evrpc_hook_ctx
modifier|*
name|pause
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pause
argument_list|,
argument|head
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|pause
operator|->
name|ctx
operator|==
name|ctx
condition|)
break|break;
block|}
if|if
condition|(
name|pause
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
call|(
modifier|*
name|pause
operator|->
name|cb
call|)
argument_list|(
name|pause
operator|->
name|ctx
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|pause
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|pause
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_make_request
parameter_list|(
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|ctx
operator|->
name|pool
decl_stmt|;
comment|/* initialize the event structure for this rpc */
name|evtimer_assign
argument_list|(
operator|&
name|ctx
operator|->
name|ev_timeout
argument_list|,
name|pool
operator|->
name|base
argument_list|,
name|evrpc_request_timeout
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* we better have some available connections on the pool */
name|EVUTIL_ASSERT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|connections
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * if no connection is available, we queue the request on the pool, 	 * the next time a connection is empty, the rpc will be send on that. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|,
name|ctx
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evrpc_pool_schedule
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evrpc_request_wrapper
modifier|*
name|evrpc_make_request_ctx
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|reply
parameter_list|,
specifier|const
name|char
modifier|*
name|rpcname
parameter_list|,
name|void
function_decl|(
modifier|*
name|req_marshal
function_decl|)
parameter_list|(
name|struct
name|evbuffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_clear
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|rpl_unmarshal
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|evbuffer
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evrpc_status
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|evrpc_request_wrapper
operator|*
operator|)
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_request_wrapper
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ctx
operator|->
name|hook_meta
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|evcon
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|name
operator|=
name|mm_strdup
argument_list|(
name|rpcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ctx
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|ctx
operator|->
name|cb_arg
operator|=
name|cbarg
expr_stmt|;
name|ctx
operator|->
name|request
operator|=
name|request
expr_stmt|;
name|ctx
operator|->
name|reply
operator|=
name|reply
expr_stmt|;
name|ctx
operator|->
name|request_marshal
operator|=
name|req_marshal
expr_stmt|;
name|ctx
operator|->
name|reply_clear
operator|=
name|rpl_clear
expr_stmt|;
name|ctx
operator|->
name|reply_unmarshal
operator|=
name|rpl_unmarshal
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|evrpc_reply_done_closure
parameter_list|(
name|void
modifier|*
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|evrpc_reply_done
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|ctx
operator|->
name|pool
decl_stmt|;
name|int
name|hook_res
init|=
name|EVRPC_CONTINUE
decl_stmt|;
comment|/* cancel any timeout we might have scheduled */
name|event_del
argument_list|(
operator|&
name|ctx
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|req
operator|=
name|req
expr_stmt|;
comment|/* we need to get the reply now */
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|evrpc_reply_done_closure
argument_list|(
name|ctx
argument_list|,
name|EVRPC_CONTINUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|input_hooks
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|evrpc_hook_associate_meta_
argument_list|(
operator|&
name|ctx
operator|->
name|hook_meta
argument_list|,
name|ctx
operator|->
name|evcon
argument_list|)
expr_stmt|;
comment|/* apply hooks to the incoming request */
name|hook_res
operator|=
name|evrpc_process_hooks
argument_list|(
operator|&
name|pool
operator|->
name|input_hooks
argument_list|,
name|ctx
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hook_res
condition|)
block|{
case|case
name|EVRPC_TERMINATE
case|:
case|case
name|EVRPC_CONTINUE
case|:
break|break;
case|case
name|EVRPC_PAUSE
case|:
comment|/* 			 * if we get paused we also need to know the 			 * request.  unfortunately, the underlying 			 * layer is going to free it.  we need to 			 * request ownership explicitly 			 */
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
name|evhttp_request_own
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|evrpc_pause_request
argument_list|(
name|pool
argument_list|,
name|ctx
argument_list|,
name|evrpc_reply_done_closure
argument_list|)
expr_stmt|;
return|return;
default|default:
name|EVUTIL_ASSERT
argument_list|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
operator|||
name|hook_res
operator|==
name|EVRPC_CONTINUE
operator|||
name|hook_res
operator|==
name|EVRPC_PAUSE
argument_list|)
expr_stmt|;
block|}
block|}
name|evrpc_reply_done_closure
argument_list|(
name|ctx
argument_list|,
name|hook_res
argument_list|)
expr_stmt|;
comment|/* http request is being freed by underlying layer */
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_reply_done_closure
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|enum
name|EVRPC_HOOK_RESULT
name|hook_res
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|ctx
operator|->
name|req
decl_stmt|;
name|struct
name|evrpc_pool
modifier|*
name|pool
init|=
name|ctx
operator|->
name|pool
decl_stmt|;
name|struct
name|evrpc_status
name|status
decl_stmt|;
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|memset
argument_list|(
operator|&
name|status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|http_req
operator|=
name|req
expr_stmt|;
comment|/* we need to get the reply now */
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook_res
operator|==
name|EVRPC_TERMINATE
condition|)
block|{
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_HOOKABORTED
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|ctx
operator|->
name|reply_unmarshal
argument_list|(
name|ctx
operator|->
name|reply
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_BADPAYLOAD
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* clear everything that we might have written previously */
name|ctx
operator|->
name|reply_clear
argument_list|(
name|ctx
operator|->
name|reply
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ctx
operator|->
name|cb
call|)
argument_list|(
operator|&
name|status
argument_list|,
name|ctx
operator|->
name|request
argument_list|,
name|ctx
operator|->
name|reply
argument_list|,
name|ctx
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|evrpc_request_wrapper_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* the http layer owned the original request structure, but if we 	 * got paused, we asked for ownership and need to free it here. */
if|if
condition|(
name|req
operator|!=
name|NULL
operator|&&
name|evhttp_request_is_owned
argument_list|(
name|req
argument_list|)
condition|)
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* see if we can schedule another request */
name|evrpc_pool_schedule
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_pool_schedule
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|)
decl_stmt|;
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
comment|/* if no requests are pending, we have no work */
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|evcon
operator|=
name|evrpc_pool_find_connection
argument_list|(
name|pool
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|requests
argument_list|,
name|ctx
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evrpc_schedule_request
argument_list|(
name|evcon
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_request_timeout
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|ctx
operator|->
name|evcon
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * frees potential meta data associated with a request.  */
end_comment

begin_function
specifier|static
name|void
name|evrpc_meta_data_free
parameter_list|(
name|struct
name|evrpc_meta_list
modifier|*
name|meta_data
parameter_list|)
block|{
name|struct
name|evrpc_meta
modifier|*
name|entry
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|meta_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|TAILQ_FIRST
argument_list|(
name|meta_data
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|meta_data
argument_list|,
name|entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|entry
operator|->
name|key
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|entry
operator|->
name|data
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|evrpc_hook_meta
modifier|*
name|evrpc_hook_meta_new_
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|evrpc_hook_meta
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_hook_meta
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ctx
operator|->
name|meta_data
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|evcon
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_hook_associate_meta_
parameter_list|(
name|struct
name|evrpc_hook_meta
modifier|*
modifier|*
name|pctx
parameter_list|,
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evrpc_hook_meta
modifier|*
name|ctx
init|=
operator|*
name|pctx
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
operator|*
name|pctx
operator|=
name|ctx
operator|=
name|evrpc_hook_meta_new_
argument_list|()
expr_stmt|;
name|ctx
operator|->
name|evcon
operator|=
name|evcon
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evrpc_hook_context_free_
parameter_list|(
name|struct
name|evrpc_hook_meta
modifier|*
name|ctx
parameter_list|)
block|{
name|evrpc_meta_data_free
argument_list|(
operator|&
name|ctx
operator|->
name|meta_data
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds meta data */
end_comment

begin_function
name|void
name|evrpc_hook_add_meta
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|data_size
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|req
init|=
name|ctx
decl_stmt|;
name|struct
name|evrpc_hook_meta
modifier|*
name|store
init|=
name|NULL
decl_stmt|;
name|struct
name|evrpc_meta
modifier|*
name|meta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|store
operator|=
name|req
operator|->
name|hook_meta
operator|)
operator|==
name|NULL
condition|)
name|store
operator|=
name|req
operator|->
name|hook_meta
operator|=
name|evrpc_hook_meta_new_
argument_list|()
expr_stmt|;
name|meta
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc_meta
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|meta
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|meta
operator|->
name|key
operator|=
name|mm_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|meta
operator|->
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|meta
operator|->
name|data_size
operator|=
name|data_size
expr_stmt|;
name|meta
operator|->
name|data
operator|=
name|mm_malloc
argument_list|(
name|data_size
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|meta
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|store
operator|->
name|meta_data
argument_list|,
name|meta
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evrpc_hook_find_meta
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|data_size
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|req
init|=
name|ctx
decl_stmt|;
name|struct
name|evrpc_meta
modifier|*
name|meta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|hook_meta
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|meta
argument_list|,
argument|&req->hook_meta->meta_data
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|meta
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|data
operator|=
name|meta
operator|->
name|data
expr_stmt|;
operator|*
name|data_size
operator|=
name|meta
operator|->
name|data_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_connection
modifier|*
name|evrpc_hook_get_connection
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|evrpc_request_wrapper
modifier|*
name|req
init|=
name|ctx
decl_stmt|;
return|return
operator|(
name|req
operator|->
name|hook_meta
operator|!=
name|NULL
condition|?
name|req
operator|->
name|hook_meta
operator|->
name|evcon
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_send_request_generic
parameter_list|(
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|reply
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evrpc_status
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|,
specifier|const
name|char
modifier|*
name|rpcname
parameter_list|,
name|void
function_decl|(
modifier|*
name|req_marshal
function_decl|)
parameter_list|(
name|struct
name|evbuffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_clear
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|rpl_unmarshal
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|evbuffer
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|evrpc_status
name|status
decl_stmt|;
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|evrpc_make_request_ctx
argument_list|(
name|pool
argument_list|,
name|request
argument_list|,
name|reply
argument_list|,
name|rpcname
argument_list|,
name|req_marshal
argument_list|,
name|rpl_clear
argument_list|,
name|rpl_unmarshal
argument_list|,
name|cb
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
name|evrpc_make_request
argument_list|(
name|ctx
argument_list|)
operator|)
return|;
name|error
label|:
name|memset
argument_list|(
operator|&
name|status
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|.
name|error
operator|=
name|EVRPC_STATUS_ERR_UNSTARTED
expr_stmt|;
operator|(
operator|*
operator|(
name|cb
operator|)
operator|)
operator|(
operator|&
name|status
operator|,
name|request
operator|,
name|reply
operator|,
name|cb_arg
operator|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Takes a request object and fills it in with the right magic */
end_comment

begin_function
specifier|static
name|struct
name|evrpc
modifier|*
name|evrpc_register_object
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|req_new
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|req_new_arg
parameter_list|,
name|void
function_decl|(
modifier|*
name|req_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|req_unmarshal
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|evbuffer
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|rpl_new
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|rpl_new_arg
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|rpl_complete
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_marshal
function_decl|)
parameter_list|(
name|struct
name|evbuffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|evrpc
modifier|*
name|rpc
init|=
operator|(
expr|struct
name|evrpc
operator|*
operator|)
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evrpc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rpc
operator|->
name|uri
operator|=
name|mm_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|uri
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|rpc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rpc
operator|->
name|request_new
operator|=
name|req_new
expr_stmt|;
name|rpc
operator|->
name|request_new_arg
operator|=
name|req_new_arg
expr_stmt|;
name|rpc
operator|->
name|request_free
operator|=
name|req_free
expr_stmt|;
name|rpc
operator|->
name|request_unmarshal
operator|=
name|req_unmarshal
expr_stmt|;
name|rpc
operator|->
name|reply_new
operator|=
name|rpl_new
expr_stmt|;
name|rpc
operator|->
name|reply_new_arg
operator|=
name|rpl_new_arg
expr_stmt|;
name|rpc
operator|->
name|reply_free
operator|=
name|rpl_free
expr_stmt|;
name|rpc
operator|->
name|reply_complete
operator|=
name|rpl_complete
expr_stmt|;
name|rpc
operator|->
name|reply_marshal
operator|=
name|rpl_marshal
expr_stmt|;
return|return
operator|(
name|rpc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evrpc_register_generic
parameter_list|(
name|struct
name|evrpc_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|evrpc_req_generic
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|req_new
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|req_new_arg
parameter_list|,
name|void
function_decl|(
modifier|*
name|req_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|req_unmarshal
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|evbuffer
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|rpl_new
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|rpl_new_arg
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|rpl_complete
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|rpl_marshal
function_decl|)
parameter_list|(
name|struct
name|evbuffer
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|evrpc
modifier|*
name|rpc
init|=
name|evrpc_register_object
argument_list|(
name|name
argument_list|,
name|req_new
argument_list|,
name|req_new_arg
argument_list|,
name|req_free
argument_list|,
name|req_unmarshal
argument_list|,
name|rpl_new
argument_list|,
name|rpl_new_arg
argument_list|,
name|rpl_free
argument_list|,
name|rpl_complete
argument_list|,
name|rpl_marshal
argument_list|)
decl_stmt|;
if|if
condition|(
name|rpc
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|evrpc_register_rpc
argument_list|(
name|base
argument_list|,
name|rpc
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|evrpc_req_generic
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|callback
argument_list|,
name|cbarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** accessors for obscure and undocumented functionality */
end_comment

begin_function
name|struct
name|evrpc_pool
modifier|*
name|evrpc_request_get_pool
parameter_list|(
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|pool
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evrpc_request_set_pool
parameter_list|(
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|,
name|struct
name|evrpc_pool
modifier|*
name|pool
parameter_list|)
block|{
name|ctx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evrpc_request_set_cb
parameter_list|(
name|struct
name|evrpc_request_wrapper
modifier|*
name|ctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evrpc_status
modifier|*
parameter_list|,
name|void
modifier|*
name|request
parameter_list|,
name|void
modifier|*
name|reply
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|ctx
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|ctx
operator|->
name|cb_arg
operator|=
name|cb_arg
expr_stmt|;
block|}
end_function

end_unit

