begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT_INTERNAL_H_INCLUDED_
end_ifndef

begin_define
define|#
directive|define
name|EVENT_INTERNAL_H_INCLUDED_
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"event2/event-config.h"
include|#
directive|include
file|"evconfig-private.h"
include|#
directive|include
file|<time.h>
include|#
directive|include
file|<sys/queue.h>
include|#
directive|include
file|"event2/event_struct.h"
include|#
directive|include
file|"minheap-internal.h"
include|#
directive|include
file|"evsignal-internal.h"
include|#
directive|include
file|"mm-internal.h"
include|#
directive|include
file|"defer-internal.h"
comment|/* map union members back */
comment|/* mutually exclusive */
define|#
directive|define
name|ev_signal_next
value|ev_.ev_signal.ev_signal_next
define|#
directive|define
name|ev_io_next
value|ev_.ev_io.ev_io_next
define|#
directive|define
name|ev_io_timeout
value|ev_.ev_io.ev_timeout
comment|/* used only by signals */
define|#
directive|define
name|ev_ncalls
value|ev_.ev_signal.ev_ncalls
define|#
directive|define
name|ev_pncalls
value|ev_.ev_signal.ev_pncalls
define|#
directive|define
name|ev_pri
value|ev_evcallback.evcb_pri
define|#
directive|define
name|ev_flags
value|ev_evcallback.evcb_flags
define|#
directive|define
name|ev_closure
value|ev_evcallback.evcb_closure
define|#
directive|define
name|ev_callback
value|ev_evcallback.evcb_cb_union.evcb_callback
define|#
directive|define
name|ev_arg
value|ev_evcallback.evcb_arg
comment|/** @name Event closure codes      Possible values for evcb_closure in struct event_callback      @{  */
comment|/** A regular event. Uses the evcb_callback callback */
define|#
directive|define
name|EV_CLOSURE_EVENT
value|0
comment|/** A signal event. Uses the evcb_callback callback */
define|#
directive|define
name|EV_CLOSURE_EVENT_SIGNAL
value|1
comment|/** A persistent non-signal event. Uses the evcb_callback callback */
define|#
directive|define
name|EV_CLOSURE_EVENT_PERSIST
value|2
comment|/** A simple callback. Uses the evcb_selfcb callback. */
define|#
directive|define
name|EV_CLOSURE_CB_SELF
value|3
comment|/** A finalizing callback. Uses the evcb_cbfinalize callback. */
define|#
directive|define
name|EV_CLOSURE_CB_FINALIZE
value|4
comment|/** A finalizing event. Uses the evcb_evfinalize callback. */
define|#
directive|define
name|EV_CLOSURE_EVENT_FINALIZE
value|5
comment|/** A finalizing event that should get freed after. Uses the evcb_evfinalize  * callback. */
define|#
directive|define
name|EV_CLOSURE_EVENT_FINALIZE_FREE
value|6
comment|/** @} */
comment|/** Structure to define the backend of a given event_base. */
struct|struct
name|eventop
block|{
comment|/** The name of this backend. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/** Function to set up an event_base to use this backend.  It should 	 * create a new structure holding whatever information is needed to 	 * run the backend, and return it.  The returned pointer will get 	 * stored by event_init into the event_base.evbase field.  On failure, 	 * this function should return NULL. */
name|void
modifier|*
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/** Enable reading/writing on a given fd or signal.  'events' will be 	 * the events that we're trying to enable: one or more of EV_READ, 	 * EV_WRITE, EV_SIGNAL, and EV_ET.  'old' will be those events that 	 * were enabled on this fd previously.  'fdinfo' will be a structure 	 * associated with the fd by the evmap; its size is defined by the 	 * fdinfo field below.  It will be set to 0 the first time the fd is 	 * added.  The function should return 0 on success and -1 on error. 	 */
name|int
function_decl|(
modifier|*
name|add
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|fdinfo
parameter_list|)
function_decl|;
comment|/** As "add", except 'events' contains the events we mean to disable. */
name|int
function_decl|(
modifier|*
name|del
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|fdinfo
parameter_list|)
function_decl|;
comment|/** Function to implement the core of an event loop.  It must see which 	    added events are ready, and cause event_active to be called for each 	    active event (usually via event_io_active or such).  It should 	    return 0 on success and -1 on error. 	 */
name|int
function_decl|(
modifier|*
name|dispatch
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/** Function to clean up and free our data from the event_base. */
name|void
function_decl|(
modifier|*
name|dealloc
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/** Flag: set if we need to reinitialize the event base after we fork. 	 */
name|int
name|need_reinit
decl_stmt|;
comment|/** Bit-array of supported event_method_features that this backend can 	 * provide. */
name|enum
name|event_method_feature
name|features
decl_stmt|;
comment|/** Length of the extra information we should record for each fd that 	    has one or more active events.  This information is recorded 	    as part of the evmap entry for each fd, and passed as an argument 	    to the add and del functions above. 	 */
name|size_t
name|fdinfo_len
decl_stmt|;
block|}
struct|;
ifdef|#
directive|ifdef
name|_WIN32
comment|/* If we're on win32, then file descriptors are not nice low densely packed    integers.  Instead, they are pointer-like windows handles, and we want to    use a hashtable instead of an array to map fds to events. */
define|#
directive|define
name|EVMAP_USE_HT
endif|#
directive|endif
comment|/* #define HT_CACHE_HASH_VALS */
ifdef|#
directive|ifdef
name|EVMAP_USE_HT
define|#
directive|define
name|HT_NO_CACHE_HASH_VALUES
include|#
directive|include
file|"ht-internal.h"
struct_decl|struct
name|event_map_entry
struct_decl|;
name|HT_HEAD
argument_list|(
name|event_io_map
argument_list|,
name|event_map_entry
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|event_io_map
value|event_signal_map
endif|#
directive|endif
comment|/* Used to map signal numbers to a list of events.  If EVMAP_USE_HT is not    defined, this structure is also used as event_io_map, which maps fds to a    list of events. */
struct|struct
name|event_signal_map
block|{
comment|/* An array of evmap_io * or of evmap_signal *; empty entries are 	 * set to NULL. */
name|void
modifier|*
modifier|*
name|entries
decl_stmt|;
comment|/* The number of entries available in entries */
name|int
name|nentries
decl_stmt|;
block|}
struct|;
comment|/* A list of events waiting on a given 'common' timeout value.  Ordinarily,  * events waiting for a timeout wait on a minheap.  Sometimes, however, a  * queue can be faster.  **/
struct|struct
name|common_timeout_list
block|{
comment|/* List of events currently waiting in the queue. */
name|struct
name|event_list
name|events
decl_stmt|;
comment|/* 'magic' timeval used to indicate the duration of events in this 	 * queue. */
name|struct
name|timeval
name|duration
decl_stmt|;
comment|/* Event that triggers whenever one of the events in the queue is 	 * ready to activate */
name|struct
name|event
name|timeout_event
decl_stmt|;
comment|/* The event_base that this timeout list is part of */
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
block|}
struct|;
comment|/** Mask used to get the real tv_usec value from a common timeout. */
define|#
directive|define
name|COMMON_TIMEOUT_MICROSECONDS_MASK
value|0x000fffff
struct_decl|struct
name|event_change
struct_decl|;
comment|/* List of 'changes' since the last call to eventop.dispatch.  Only maintained  * if the backend is using changesets. */
struct|struct
name|event_changelist
block|{
name|struct
name|event_change
modifier|*
name|changes
decl_stmt|;
name|int
name|n_changes
decl_stmt|;
name|int
name|changes_size
decl_stmt|;
block|}
struct|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
comment|/* Global internal flag: set to one if debug mode is on. */
specifier|extern
name|int
name|event_debug_mode_on_
decl_stmt|;
define|#
directive|define
name|EVENT_DEBUG_MODE_IS_ON
parameter_list|()
value|(event_debug_mode_on_)
else|#
directive|else
define|#
directive|define
name|EVENT_DEBUG_MODE_IS_ON
parameter_list|()
value|(0)
endif|#
directive|endif
name|TAILQ_HEAD
argument_list|(
name|evcallback_list
argument_list|,
name|event_callback
argument_list|)
expr_stmt|;
comment|/* Sets up an event for processing once */
struct|struct
name|event_once
block|{
name|LIST_ENTRY
argument_list|(
argument|event_once
argument_list|)
name|next_once
expr_stmt|;
name|struct
name|event
name|ev
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
struct|struct
name|event_base
block|{
comment|/** Function pointers and other data to describe this event_base's 	 * backend. */
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
decl_stmt|;
comment|/** Pointer to backend-specific data. */
name|void
modifier|*
name|evbase
decl_stmt|;
comment|/** List of changes to tell backend about at next dispatch.  Only used 	 * by the O(1) backends. */
name|struct
name|event_changelist
name|changelist
decl_stmt|;
comment|/** Function pointers used to describe the backend that this event_base 	 * uses for signals */
specifier|const
name|struct
name|eventop
modifier|*
name|evsigsel
decl_stmt|;
comment|/** Data to implement the common signal handelr code. */
name|struct
name|evsig_info
name|sig
decl_stmt|;
comment|/** Number of virtual events */
name|int
name|virtual_event_count
decl_stmt|;
comment|/** Maximum number of virtual events active */
name|int
name|virtual_event_count_max
decl_stmt|;
comment|/** Number of total events added to this event_base */
name|int
name|event_count
decl_stmt|;
comment|/** Maximum number of total events added to this event_base */
name|int
name|event_count_max
decl_stmt|;
comment|/** Number of total events active in this event_base */
name|int
name|event_count_active
decl_stmt|;
comment|/** Maximum number of total events active in this event_base */
name|int
name|event_count_active_max
decl_stmt|;
comment|/** Set if we should terminate the loop once we're done processing 	 * events. */
name|int
name|event_gotterm
decl_stmt|;
comment|/** Set if we should terminate the loop immediately */
name|int
name|event_break
decl_stmt|;
comment|/** Set if we should start a new instance of the loop immediately. */
name|int
name|event_continue
decl_stmt|;
comment|/** The currently running priority of events */
name|int
name|event_running_priority
decl_stmt|;
comment|/** Set if we're running the event_base_loop function, to prevent 	 * reentrant invocation. */
name|int
name|running_loop
decl_stmt|;
comment|/** Set to the number of deferred_cbs we've made 'active' in the 	 * loop.  This is a hack to prevent starvation; it would be smarter 	 * to just use event_config_set_max_dispatch_interval's max_callbacks 	 * feature */
name|int
name|n_deferreds_queued
decl_stmt|;
comment|/* Active event management. */
comment|/** An array of nactivequeues queues for active event_callbacks (ones 	 * that have triggered, and whose callbacks need to be called).  Low 	 * priority numbers are more important, and stall higher ones. 	 */
name|struct
name|evcallback_list
modifier|*
name|activequeues
decl_stmt|;
comment|/** The length of the activequeues array */
name|int
name|nactivequeues
decl_stmt|;
comment|/** A list of event_callbacks that should become active the next time 	 * we process events, but not this time. */
name|struct
name|evcallback_list
name|active_later_queue
decl_stmt|;
comment|/* common timeout logic */
comment|/** An array of common_timeout_list* for all of the common timeout 	 * values we know. */
name|struct
name|common_timeout_list
modifier|*
modifier|*
name|common_timeout_queues
decl_stmt|;
comment|/** The number of entries used in common_timeout_queues */
name|int
name|n_common_timeouts
decl_stmt|;
comment|/** The total size of common_timeout_queues. */
name|int
name|n_common_timeouts_allocated
decl_stmt|;
comment|/** Mapping from file descriptors to enabled (added) events */
name|struct
name|event_io_map
name|io
decl_stmt|;
comment|/** Mapping from signal numbers to enabled (added) events. */
name|struct
name|event_signal_map
name|sigmap
decl_stmt|;
comment|/** Priority queue of events with timeouts. */
name|struct
name|min_heap
name|timeheap
decl_stmt|;
comment|/** Stored timeval: used to avoid calling gettimeofday/clock_gettime 	 * too often. */
name|struct
name|timeval
name|tv_cache
decl_stmt|;
name|struct
name|evutil_monotonic_timer
name|monotonic_timer
decl_stmt|;
comment|/** Difference between internal time (maybe from clock_gettime) and 	 * gettimeofday. */
name|struct
name|timeval
name|tv_clock_diff
decl_stmt|;
comment|/** Second in which we last updated tv_clock_diff, in monotonic time. */
name|time_t
name|last_updated_clock_diff
decl_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
comment|/* threading support */
comment|/** The thread currently running the event_loop for this base */
name|unsigned
name|long
name|th_owner_id
decl_stmt|;
comment|/** A lock to prevent conflicting accesses to this event_base */
name|void
modifier|*
name|th_base_lock
decl_stmt|;
comment|/** A condition that gets signalled when we're done processing an 	 * event with waiters on it. */
name|void
modifier|*
name|current_event_cond
decl_stmt|;
comment|/** Number of threads blocking on current_event_cond. */
name|int
name|current_event_waiters
decl_stmt|;
endif|#
directive|endif
comment|/** The event whose callback is executing right now */
name|struct
name|event_callback
modifier|*
name|current_event
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
comment|/** IOCP support structure, if IOCP is enabled. */
name|struct
name|event_iocp_port
modifier|*
name|iocp
decl_stmt|;
endif|#
directive|endif
comment|/** Flags that this base was configured with */
name|enum
name|event_base_config_flag
name|flags
decl_stmt|;
name|struct
name|timeval
name|max_dispatch_time
decl_stmt|;
name|int
name|max_dispatch_callbacks
decl_stmt|;
name|int
name|limit_callbacks_after_prio
decl_stmt|;
comment|/* Notify main thread to wake up break, etc. */
comment|/** True if the base already has a pending notify, and we don't need 	 * to add any more. */
name|int
name|is_notify_pending
decl_stmt|;
comment|/** A socketpair used by some th_notify functions to wake up the main 	 * thread. */
name|evutil_socket_t
name|th_notify_fd
index|[
literal|2
index|]
decl_stmt|;
comment|/** An event used by some th_notify functions to wake up the main 	 * thread. */
name|struct
name|event
name|th_notify
decl_stmt|;
comment|/** A function used to wake up the main thread from another thread. */
name|int
function_decl|(
modifier|*
name|th_notify_fn
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/** Saved seed for weak random number generator. Some backends use 	 * this to produce fairness among sockets. Protected by th_base_lock. */
name|struct
name|evutil_weakrand_state
name|weakrand_seed
decl_stmt|;
comment|/** List of event_onces that have not yet fired. */
name|LIST_HEAD
argument_list|(
argument|once_event_list
argument_list|,
argument|event_once
argument_list|)
name|once_events
expr_stmt|;
block|}
struct|;
struct|struct
name|event_config_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|event_config_entry
argument_list|)
name|next
expr_stmt|;
specifier|const
name|char
modifier|*
name|avoid_method
decl_stmt|;
block|}
struct|;
comment|/** Internal structure: describes the configuration we want for an event_base  * that we're about to allocate. */
struct|struct
name|event_config
block|{
name|TAILQ_HEAD
argument_list|(
argument|event_configq
argument_list|,
argument|event_config_entry
argument_list|)
name|entries
expr_stmt|;
name|int
name|n_cpus_hint
decl_stmt|;
name|struct
name|timeval
name|max_dispatch_interval
decl_stmt|;
name|int
name|max_dispatch_callbacks
decl_stmt|;
name|int
name|limit_callbacks_after_prio
decl_stmt|;
name|enum
name|event_method_feature
name|require_features
decl_stmt|;
name|enum
name|event_base_config_flag
name|flags
decl_stmt|;
block|}
struct|;
comment|/* Internal use only: Functions that might be missing from<sys/queue.h> */
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_SYS_QUEUE_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EVENT__HAVE_TAILQFOREACH
argument_list|)
ifndef|#
directive|ifndef
name|TAILQ_FIRST
define|#
directive|define
name|TAILQ_FIRST
parameter_list|(
name|head
parameter_list|)
value|((head)->tqh_first)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TAILQ_END
define|#
directive|define
name|TAILQ_END
parameter_list|(
name|head
parameter_list|)
value|NULL
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TAILQ_NEXT
define|#
directive|define
name|TAILQ_NEXT
parameter_list|(
name|elm
parameter_list|,
name|field
parameter_list|)
value|((elm)->field.tqe_next)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TAILQ_FOREACH
define|#
directive|define
name|TAILQ_FOREACH
parameter_list|(
name|var
parameter_list|,
name|head
parameter_list|,
name|field
parameter_list|)
define|\
value|for ((var) = TAILQ_FIRST(head);					\ 	     (var) != TAILQ_END(head);					\ 	     (var) = TAILQ_NEXT(var, field))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TAILQ_INSERT_BEFORE
define|#
directive|define
name|TAILQ_INSERT_BEFORE
parameter_list|(
name|listelm
parameter_list|,
name|elm
parameter_list|,
name|field
parameter_list|)
value|do {			\ 	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\ 	(elm)->field.tqe_next = (listelm);				\ 	*(listelm)->field.tqe_prev = (elm);				\ 	(listelm)->field.tqe_prev =&(elm)->field.tqe_next;		\ } while (0)
endif|#
directive|endif
endif|#
directive|endif
comment|/* TAILQ_FOREACH */
define|#
directive|define
name|N_ACTIVE_CALLBACKS
parameter_list|(
name|base
parameter_list|)
define|\
value|((base)->event_count_active)
name|int
name|evsig_set_handler_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|evsignal
parameter_list|,
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
name|int
name|evsig_restore_handler_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|evsignal
parameter_list|)
function_decl|;
name|int
name|event_add_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
name|int
name|tv_is_absolute
parameter_list|)
function_decl|;
comment|/** Argument for event_del_nolock_. Tells event_del not to block on the event  * if it's running in another thread. */
define|#
directive|define
name|EVENT_DEL_NOBLOCK
value|0
comment|/** Argument for event_del_nolock_. Tells event_del to block on the event  * if it's running in another thread, regardless of its value for EV_FINALIZE  */
define|#
directive|define
name|EVENT_DEL_BLOCK
value|1
comment|/** Argument for event_del_nolock_. Tells event_del to block on the event  * if it is running in another thread and it doesn't have EV_FINALIZE set.  */
define|#
directive|define
name|EVENT_DEL_AUTOBLOCK
value|2
comment|/** Argument for event_del_nolock_. Tells event_del to procede even if the  * event is set up for finalization rather for regular use.*/
define|#
directive|define
name|EVENT_DEL_EVEN_IF_FINALIZING
value|3
name|int
name|event_del_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|blocking
parameter_list|)
function_decl|;
name|int
name|event_remove_timer_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
name|void
name|event_active_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|,
name|short
name|count
parameter_list|)
function_decl|;
name|int
name|event_callback_activate_
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
name|int
name|event_callback_activate_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
name|int
name|event_callback_cancel_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
function_decl|;
name|void
name|event_callback_finalize_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|event_callback_finalize_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|int
name|event_callback_finalize_many_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|n_cbs
parameter_list|,
name|struct
name|event_callback
modifier|*
modifier|*
name|evcb
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|event_active_later_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|)
function_decl|;
name|void
name|event_active_later_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|)
function_decl|;
name|void
name|event_callback_activate_later_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
function_decl|;
name|int
name|event_callback_cancel_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|int
name|even_if_finalizing
parameter_list|)
function_decl|;
name|void
name|event_callback_init_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|)
function_decl|;
comment|/* FIXME document. */
name|void
name|event_base_add_virtual_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
name|void
name|event_base_del_virtual_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/** For debugging: unless assertions are disabled, verify the referential     integrity of the internal data structures of 'base'.  This operation can     be expensive.      Returns on success; aborts on failure. */
name|void
name|event_base_assert_ok_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
name|void
name|event_base_assert_ok_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/* Helper function: Call 'fn' exactly once every inserted or active event in  * the event_base 'base'.  *  * If fn returns 0, continue on to the next event. Otherwise, return the same  * value that fn returned.  *  * Requires that 'base' be locked.  */
name|int
name|event_base_foreach_event_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|event_base_foreach_event_cb
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EVENT_INTERNAL_H_INCLUDED_ */
end_comment

end_unit

