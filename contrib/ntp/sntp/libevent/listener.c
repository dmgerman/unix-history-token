begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos, Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_comment
comment|/* Minimum required for InitializeCriticalSectionAndSpinCount */
end_comment

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0403
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_include
include|#
directive|include
file|<mswsock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/listener.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|evconnlistener_ops
block|{
name|int
function_decl|(
modifier|*
name|enable
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|disable
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|destroy
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|shutdown
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
name|evutil_socket_t
function_decl|(
modifier|*
name|getfd
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
name|struct
name|event_base
modifier|*
function_decl|(
modifier|*
name|getbase
function_decl|)
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|evconnlistener
block|{
specifier|const
name|struct
name|evconnlistener_ops
modifier|*
name|ops
decl_stmt|;
name|void
modifier|*
name|lock
decl_stmt|;
name|evconnlistener_cb
name|cb
decl_stmt|;
name|evconnlistener_errorcb
name|errorcb
decl_stmt|;
name|void
modifier|*
name|user_data
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|short
name|refcnt
decl_stmt|;
name|int
name|accept4_flags
decl_stmt|;
name|unsigned
name|enabled
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|evconnlistener_event
block|{
name|struct
name|evconnlistener
name|base
decl_stmt|;
name|struct
name|event
name|listener
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_struct
struct|struct
name|evconnlistener_iocp
block|{
name|struct
name|evconnlistener
name|base
decl_stmt|;
name|evutil_socket_t
name|fd
decl_stmt|;
name|struct
name|event_base
modifier|*
name|event_base
decl_stmt|;
name|struct
name|event_iocp_port
modifier|*
name|port
decl_stmt|;
name|short
name|n_accepting
decl_stmt|;
name|unsigned
name|shutting_down
range|:
literal|1
decl_stmt|;
name|unsigned
name|event_added
range|:
literal|1
decl_stmt|;
name|struct
name|accepting_socket
modifier|*
modifier|*
name|accepting
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LOCK
parameter_list|(
name|listener
parameter_list|)
value|EVLOCK_LOCK((listener)->lock, 0)
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|(
name|listener
parameter_list|)
value|EVLOCK_UNLOCK((listener)->lock, 0)
end_define

begin_function_decl
name|struct
name|evconnlistener
modifier|*
name|evconnlistener_new_async
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evconnlistener_cb
name|cb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|int
name|backlog
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXXX export this? */
end_comment

begin_function_decl
specifier|static
name|int
name|event_listener_enable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|event_listener_disable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_listener_destroy
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|evutil_socket_t
name|event_listener_getfd
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|event_base
modifier|*
name|event_listener_getbase
parameter_list|(
name|struct
name|evconnlistener
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void listener_incref_and_lock(struct evconnlistener *listener) { 	LOCK(listener); 	++listener->refcnt; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|listener_decref_and_unlock
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|listener
parameter_list|)
block|{
name|int
name|refcnt
init|=
operator|--
name|listener
operator|->
name|refcnt
decl_stmt|;
if|if
condition|(
name|refcnt
operator|==
literal|0
condition|)
block|{
name|listener
operator|->
name|ops
operator|->
name|destroy
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|listener
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|UNLOCK
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|evconnlistener_ops
name|evconnlistener_event_ops
init|=
block|{
name|event_listener_enable
block|,
name|event_listener_disable
block|,
name|event_listener_destroy
block|,
name|NULL
block|,
comment|/* shutdown */
name|event_listener_getfd
block|,
name|event_listener_getbase
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|listener_read_cb
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|evconnlistener
modifier|*
name|evconnlistener_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evconnlistener_cb
name|cb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|int
name|backlog
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|base
operator|&&
name|event_base_get_iocp_
argument_list|(
name|base
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|ext
init|=
name|event_get_win32_extension_fns_
argument_list|()
decl_stmt|;
if|if
condition|(
name|ext
operator|->
name|AcceptEx
operator|&&
name|ext
operator|->
name|GetAcceptExSockaddrs
condition|)
return|return
name|evconnlistener_new_async
argument_list|(
name|base
argument_list|,
name|cb
argument_list|,
name|ptr
argument_list|,
name|flags
argument_list|,
name|backlog
argument_list|,
name|fd
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|backlog
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|backlog
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
literal|128
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
name|lev
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evconnlistener_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lev
condition|)
return|return
name|NULL
return|;
name|lev
operator|->
name|base
operator|.
name|ops
operator|=
operator|&
name|evconnlistener_event_ops
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|cb
operator|=
name|cb
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|user_data
operator|=
name|ptr
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|refcnt
operator|=
literal|1
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|accept4_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LEV_OPT_LEAVE_SOCKETS_BLOCKING
operator|)
condition|)
name|lev
operator|->
name|base
operator|.
name|accept4_flags
operator||=
name|EVUTIL_SOCK_NONBLOCK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LEV_OPT_CLOSE_ON_EXEC
condition|)
name|lev
operator|->
name|base
operator|.
name|accept4_flags
operator||=
name|EVUTIL_SOCK_CLOEXEC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LEV_OPT_THREADSAFE
condition|)
block|{
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|lev
operator|->
name|base
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
block|}
name|event_assign
argument_list|(
operator|&
name|lev
operator|->
name|listener
argument_list|,
name|base
argument_list|,
name|fd
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|listener_read_cb
argument_list|,
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LEV_OPT_DISABLED
operator|)
condition|)
name|evconnlistener_enable
argument_list|(
operator|&
name|lev
operator|->
name|base
argument_list|)
expr_stmt|;
return|return
operator|&
name|lev
operator|->
name|base
return|;
block|}
end_function

begin_function
name|struct
name|evconnlistener
modifier|*
name|evconnlistener_new_bind
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evconnlistener_cb
name|cb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|int
name|backlog
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|socklen
parameter_list|)
block|{
name|struct
name|evconnlistener
modifier|*
name|listener
decl_stmt|;
name|evutil_socket_t
name|fd
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|family
init|=
name|sa
condition|?
name|sa
operator|->
name|sa_family
else|:
name|AF_UNSPEC
decl_stmt|;
name|int
name|socktype
init|=
name|SOCK_STREAM
operator||
name|EVUTIL_SOCK_NONBLOCK
decl_stmt|;
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|flags
operator|&
name|LEV_OPT_CLOSE_ON_EXEC
condition|)
name|socktype
operator||=
name|EVUTIL_SOCK_CLOEXEC
expr_stmt|;
name|fd
operator|=
name|evutil_socket_
argument_list|(
name|family
argument_list|,
name|socktype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|flags
operator|&
name|LEV_OPT_REUSEABLE
condition|)
block|{
if|if
condition|(
name|evutil_make_listen_socket_reuseable
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|LEV_OPT_DEFERRED_ACCEPT
condition|)
block|{
if|if
condition|(
name|evutil_make_tcp_listen_socket_deferred
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|sa
condition|)
block|{
if|if
condition|(
name|bind
argument_list|(
name|fd
argument_list|,
name|sa
argument_list|,
name|socklen
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
name|listener
operator|=
name|evconnlistener_new
argument_list|(
name|base
argument_list|,
name|cb
argument_list|,
name|ptr
argument_list|,
name|flags
argument_list|,
name|backlog
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|listener
condition|)
goto|goto
name|err
goto|;
return|return
name|listener
return|;
name|err
label|:
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|evconnlistener_free
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|lev
operator|->
name|cb
operator|=
name|NULL
expr_stmt|;
name|lev
operator|->
name|errorcb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|ops
operator|->
name|shutdown
condition|)
name|lev
operator|->
name|ops
operator|->
name|shutdown
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_listener_destroy
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev_e
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_event
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|event_del
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|flags
operator|&
name|LEV_OPT_CLOSE_ON_FREE
condition|)
name|evutil_closesocket
argument_list|(
name|event_get_fd
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evconnlistener_enable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|lev
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|cb
condition|)
name|r
operator|=
name|lev
operator|->
name|ops
operator|->
name|enable
argument_list|(
name|lev
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
literal|0
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|evconnlistener_disable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|lev
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|lev
operator|->
name|ops
operator|->
name|disable
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|event_listener_enable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev_e
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_event
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|event_add
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|event_listener_disable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev_e
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_event
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|event_del
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
return|;
block|}
end_function

begin_function
name|evutil_socket_t
name|evconnlistener_get_fd
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|evutil_socket_t
name|fd
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|fd
operator|=
name|lev
operator|->
name|ops
operator|->
name|getfd
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_function
specifier|static
name|evutil_socket_t
name|event_listener_getfd
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev_e
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_event
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|event_get_fd
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|evconnlistener_get_base
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|base
operator|=
name|lev
operator|->
name|ops
operator|->
name|getbase
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|event_base
modifier|*
name|event_listener_getbase
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_event
modifier|*
name|lev_e
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_event
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|event_get_base
argument_list|(
operator|&
name|lev_e
operator|->
name|listener
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|evconnlistener_set_cb
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|,
name|evconnlistener_cb
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|enable
init|=
literal|0
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|enabled
operator|&&
operator|!
name|lev
operator|->
name|cb
condition|)
name|enable
operator|=
literal|1
expr_stmt|;
name|lev
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|lev
operator|->
name|user_data
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|evconnlistener_enable
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evconnlistener_set_error_cb
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|,
name|evconnlistener_errorcb
name|errorcb
parameter_list|)
block|{
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|lev
operator|->
name|errorcb
operator|=
name|errorcb
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|listener_read_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|evconnlistener
modifier|*
name|lev
init|=
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
name|evconnlistener_cb
name|cb
decl_stmt|;
name|evconnlistener_errorcb
name|errorcb
decl_stmt|;
name|void
modifier|*
name|user_data
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|ev_socklen_t
name|socklen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|evutil_socket_t
name|new_fd
init|=
name|evutil_accept4_
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|socklen
argument_list|,
name|lev
operator|->
name|accept4_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_fd
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|socklen
operator|==
literal|0
condition|)
block|{
comment|/* This can happen with some older linux kernels in 			 * response to nmap. */
name|evutil_closesocket
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lev
operator|->
name|cb
operator|==
name|NULL
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|new_fd
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|lev
operator|->
name|refcnt
expr_stmt|;
name|cb
operator|=
name|lev
operator|->
name|cb
expr_stmt|;
name|user_data
operator|=
name|lev
operator|->
name|user_data
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|cb
argument_list|(
name|lev
argument_list|,
name|new_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|(
name|int
operator|)
name|socklen
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|refcnt
operator|==
literal|1
condition|)
block|{
name|int
name|freed
init|=
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|freed
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|lev
operator|->
name|refcnt
expr_stmt|;
block|}
name|err
operator|=
name|evutil_socket_geterror
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_ERR_ACCEPT_RETRIABLE
argument_list|(
name|err
argument_list|)
condition|)
block|{
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lev
operator|->
name|errorcb
operator|!=
name|NULL
condition|)
block|{
operator|++
name|lev
operator|->
name|refcnt
expr_stmt|;
name|errorcb
operator|=
name|lev
operator|->
name|errorcb
expr_stmt|;
name|user_data
operator|=
name|lev
operator|->
name|user_data
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|errorcb
argument_list|(
name|lev
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"Error from accept() call"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_struct
struct|struct
name|accepting_socket
block|{
name|CRITICAL_SECTION
name|lock
decl_stmt|;
name|struct
name|event_overlapped
name|overlapped
decl_stmt|;
name|SOCKET
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|event_callback
name|deferred
decl_stmt|;
name|struct
name|evconnlistener_iocp
modifier|*
name|lev
decl_stmt|;
name|ev_uint8_t
name|buflen
decl_stmt|;
name|ev_uint8_t
name|family
decl_stmt|;
name|unsigned
name|free_on_cb
range|:
literal|1
decl_stmt|;
name|char
name|addrbuf
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|accepted_socket_cb
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|o
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|n
parameter_list|,
name|int
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|accepted_socket_invoke_user_cb
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|iocp_listener_event_add
parameter_list|(
name|struct
name|evconnlistener_iocp
modifier|*
name|lev
parameter_list|)
block|{
if|if
condition|(
name|lev
operator|->
name|event_added
condition|)
return|return;
name|lev
operator|->
name|event_added
operator|=
literal|1
expr_stmt|;
name|event_base_add_virtual_
argument_list|(
name|lev
operator|->
name|event_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iocp_listener_event_del
parameter_list|(
name|struct
name|evconnlistener_iocp
modifier|*
name|lev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lev
operator|->
name|event_added
condition|)
return|return;
name|lev
operator|->
name|event_added
operator|=
literal|0
expr_stmt|;
name|event_base_del_virtual_
argument_list|(
name|lev
operator|->
name|event_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|accepting_socket
modifier|*
name|new_accepting_socket
parameter_list|(
name|struct
name|evconnlistener_iocp
modifier|*
name|lev
parameter_list|,
name|int
name|family
parameter_list|)
block|{
name|struct
name|accepting_socket
modifier|*
name|res
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|buflen
decl_stmt|;
if|if
condition|(
name|family
operator|==
name|AF_INET
condition|)
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
name|buflen
operator|=
operator|(
name|addrlen
operator|+
literal|16
operator|)
operator|*
literal|2
expr_stmt|;
name|res
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|accepting_socket
argument_list|)
operator|-
literal|1
operator|+
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
name|NULL
return|;
name|event_overlapped_init_
argument_list|(
operator|&
name|res
operator|->
name|overlapped
argument_list|,
name|accepted_socket_cb
argument_list|)
expr_stmt|;
name|res
operator|->
name|s
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|res
operator|->
name|lev
operator|=
name|lev
expr_stmt|;
name|res
operator|->
name|buflen
operator|=
name|buflen
expr_stmt|;
name|res
operator|->
name|family
operator|=
name|family
expr_stmt|;
name|event_deferred_cb_init_
argument_list|(
operator|&
name|res
operator|->
name|deferred
argument_list|,
name|event_base_get_npriorities
argument_list|(
name|lev
operator|->
name|event_base
argument_list|)
operator|/
literal|2
argument_list|,
name|accepted_socket_invoke_user_cb
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|InitializeCriticalSectionAndSpinCount
argument_list|(
operator|&
name|res
operator|->
name|lock
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_and_unlock_accepting_socket
parameter_list|(
name|struct
name|accepting_socket
modifier|*
name|as
parameter_list|)
block|{
comment|/* requires lock. */
if|if
condition|(
name|as
operator|->
name|s
operator|!=
name|INVALID_SOCKET
condition|)
name|closesocket
argument_list|(
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DeleteCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|start_accepting
parameter_list|(
name|struct
name|accepting_socket
modifier|*
name|as
parameter_list|)
block|{
comment|/* requires lock */
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|ext
init|=
name|event_get_win32_extension_fns_
argument_list|()
decl_stmt|;
name|DWORD
name|pending
init|=
literal|0
decl_stmt|;
name|SOCKET
name|s
init|=
name|socket
argument_list|(
name|as
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|as
operator|->
name|lev
operator|->
name|base
operator|.
name|enabled
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
goto|goto
name|report_err
goto|;
block|}
comment|/* XXXX It turns out we need to do this again later.  Does this call 	 * have any effect? */
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_UPDATE_ACCEPT_CONTEXT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|as
operator|->
name|lev
operator|->
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|as
operator|->
name|lev
operator|->
name|fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|as
operator|->
name|lev
operator|->
name|base
operator|.
name|flags
operator|&
name|LEV_OPT_LEAVE_SOCKETS_BLOCKING
operator|)
condition|)
name|evutil_make_socket_nonblocking
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_iocp_port_associate_
argument_list|(
name|as
operator|->
name|lev
operator|->
name|port
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|as
operator|->
name|s
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|AcceptEx
argument_list|(
name|as
operator|->
name|lev
operator|->
name|fd
argument_list|,
name|s
argument_list|,
name|as
operator|->
name|addrbuf
argument_list|,
literal|0
argument_list|,
name|as
operator|->
name|buflen
operator|/
literal|2
argument_list|,
name|as
operator|->
name|buflen
operator|/
literal|2
argument_list|,
operator|&
name|pending
argument_list|,
operator|&
name|as
operator|->
name|overlapped
operator|.
name|overlapped
argument_list|)
condition|)
block|{
comment|/* Immediate success! */
name|accepted_socket_cb
argument_list|(
operator|&
name|as
operator|->
name|overlapped
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ERROR_IO_PENDING
condition|)
block|{
goto|goto
name|report_err
goto|;
block|}
block|}
return|return
literal|0
return|;
name|report_err
label|:
name|as
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|event_deferred_cb_schedule_
argument_list|(
name|as
operator|->
name|lev
operator|->
name|event_base
argument_list|,
operator|&
name|as
operator|->
name|deferred
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_accepting
parameter_list|(
name|struct
name|accepting_socket
modifier|*
name|as
parameter_list|)
block|{
comment|/* requires lock. */
name|SOCKET
name|s
init|=
name|as
operator|->
name|s
decl_stmt|;
name|as
operator|->
name|s
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|accepted_socket_invoke_user_cb
parameter_list|(
name|struct
name|event_callback
modifier|*
name|dcb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|accepting_socket
modifier|*
name|as
init|=
name|arg
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa_local
init|=
name|NULL
decl_stmt|,
modifier|*
name|sa_remote
init|=
name|NULL
decl_stmt|;
name|int
name|socklen_local
init|=
literal|0
decl_stmt|,
name|socklen_remote
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|ext
init|=
name|event_get_win32_extension_fns_
argument_list|()
decl_stmt|;
name|struct
name|evconnlistener
modifier|*
name|lev
init|=
operator|&
name|as
operator|->
name|lev
operator|->
name|base
decl_stmt|;
name|evutil_socket_t
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|evconnlistener_cb
name|cb
init|=
name|NULL
decl_stmt|;
name|evconnlistener_errorcb
name|errorcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ext
operator|->
name|GetAcceptExSockaddrs
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|free_on_cb
condition|)
block|{
name|free_and_unlock_accepting_socket
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|lev
operator|->
name|refcnt
expr_stmt|;
name|error
operator|=
name|as
operator|->
name|error
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|as
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|errorcb
operator|=
name|lev
operator|->
name|errorcb
expr_stmt|;
block|}
else|else
block|{
name|ext
operator|->
name|GetAcceptExSockaddrs
argument_list|(
name|as
operator|->
name|addrbuf
argument_list|,
literal|0
argument_list|,
name|as
operator|->
name|buflen
operator|/
literal|2
argument_list|,
name|as
operator|->
name|buflen
operator|/
literal|2
argument_list|,
operator|&
name|sa_local
argument_list|,
operator|&
name|socklen_local
argument_list|,
operator|&
name|sa_remote
argument_list|,
operator|&
name|socklen_remote
argument_list|)
expr_stmt|;
name|sock
operator|=
name|as
operator|->
name|s
expr_stmt|;
name|cb
operator|=
name|lev
operator|->
name|cb
expr_stmt|;
name|as
operator|->
name|s
operator|=
name|INVALID_SOCKET
expr_stmt|;
comment|/* We need to call this so getsockname, getpeername, and 		 * shutdown work correctly on the accepted socket. */
comment|/* XXXX handle error? */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_UPDATE_ACCEPT_CONTEXT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|as
operator|->
name|lev
operator|->
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|as
operator|->
name|lev
operator|->
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|lev
operator|->
name|user_data
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorcb
condition|)
block|{
name|WSASetLastError
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|errorcb
argument_list|(
name|lev
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
condition|)
block|{
name|cb
argument_list|(
name|lev
argument_list|,
name|sock
argument_list|,
name|sa_remote
argument_list|,
name|socklen_remote
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
if|if
condition|(
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
condition|)
return|return;
name|EnterCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
name|start_accepting
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|accepted_socket_cb
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|o
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_ssize_t
name|n
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|accepting_socket
modifier|*
name|as
init|=
name|EVUTIL_UPCAST
argument_list|(
name|o
argument_list|,
expr|struct
name|accepting_socket
argument_list|,
name|overlapped
argument_list|)
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|as
operator|->
name|lev
operator|->
name|base
argument_list|)
expr_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
comment|/* XXXX Don't do this if some EV_MT flag is set. */
name|event_deferred_cb_schedule_
argument_list|(
name|as
operator|->
name|lev
operator|->
name|event_base
argument_list|,
operator|&
name|as
operator|->
name|deferred
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|as
operator|->
name|free_on_cb
condition|)
block|{
name|struct
name|evconnlistener
modifier|*
name|lev
init|=
operator|&
name|as
operator|->
name|lev
operator|->
name|base
decl_stmt|;
name|free_and_unlock_accepting_socket
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|listener_decref_and_unlock
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|as
operator|->
name|s
operator|==
name|INVALID_SOCKET
condition|)
block|{
comment|/* This is okay; we were disabled by iocp_listener_disable. */
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Some error on accept that we couldn't actually handle. */
name|BOOL
name|ok
decl_stmt|;
name|DWORD
name|transfer
init|=
literal|0
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|event_sock_warn
argument_list|(
name|as
operator|->
name|s
argument_list|,
literal|"Unexpected error on AcceptEx"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|WSAGetOverlappedResult
argument_list|(
name|as
operator|->
name|s
argument_list|,
operator|&
name|o
operator|->
name|overlapped
argument_list|,
operator|&
name|transfer
argument_list|,
name|FALSE
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
comment|/* well, that was confusing! */
name|as
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as
operator|->
name|error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
block|}
name|event_deferred_cb_schedule_
argument_list|(
name|as
operator|->
name|lev
operator|->
name|event_base
argument_list|,
operator|&
name|as
operator|->
name|deferred
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|as
operator|->
name|lev
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iocp_listener_enable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|evconnlistener_iocp
modifier|*
name|lev_iocp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_iocp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|iocp_listener_event_add
argument_list|(
name|lev_iocp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lev_iocp
operator|->
name|n_accepting
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|accepting_socket
modifier|*
name|as
init|=
name|lev_iocp
operator|->
name|accepting
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|as
condition|)
continue|continue;
name|EnterCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|as
operator|->
name|free_on_cb
operator|&&
name|as
operator|->
name|s
operator|==
name|INVALID_SOCKET
condition|)
name|start_accepting
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iocp_listener_disable_impl
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|,
name|int
name|shutdown
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|evconnlistener_iocp
modifier|*
name|lev_iocp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_iocp
argument_list|,
name|base
argument_list|)
decl_stmt|;
name|LOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|iocp_listener_event_del
argument_list|(
name|lev_iocp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lev_iocp
operator|->
name|n_accepting
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|accepting_socket
modifier|*
name|as
init|=
name|lev_iocp
operator|->
name|accepting
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|as
condition|)
continue|continue;
name|EnterCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|as
operator|->
name|free_on_cb
operator|&&
name|as
operator|->
name|s
operator|!=
name|INVALID_SOCKET
condition|)
block|{
if|if
condition|(
name|shutdown
condition|)
name|as
operator|->
name|free_on_cb
operator|=
literal|1
expr_stmt|;
name|stop_accepting
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
name|LeaveCriticalSection
argument_list|(
operator|&
name|as
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutdown
operator|&&
name|lev
operator|->
name|flags
operator|&
name|LEV_OPT_CLOSE_ON_FREE
condition|)
name|evutil_closesocket
argument_list|(
name|lev_iocp
operator|->
name|fd
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iocp_listener_disable
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
return|return
name|iocp_listener_disable_impl
argument_list|(
name|lev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iocp_listener_destroy
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_iocp
modifier|*
name|lev_iocp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_iocp
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lev_iocp
operator|->
name|shutting_down
condition|)
block|{
name|lev_iocp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|iocp_listener_disable_impl
argument_list|(
name|lev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|evutil_socket_t
name|iocp_listener_getfd
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_iocp
modifier|*
name|lev_iocp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_iocp
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|lev_iocp
operator|->
name|fd
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|event_base
modifier|*
name|iocp_listener_getbase
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|evconnlistener_iocp
modifier|*
name|lev_iocp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|lev
argument_list|,
expr|struct
name|evconnlistener_iocp
argument_list|,
name|base
argument_list|)
decl_stmt|;
return|return
name|lev_iocp
operator|->
name|event_base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|evconnlistener_ops
name|evconnlistener_iocp_ops
init|=
block|{
name|iocp_listener_enable
block|,
name|iocp_listener_disable
block|,
name|iocp_listener_destroy
block|,
name|iocp_listener_destroy
block|,
comment|/* shutdown */
name|iocp_listener_getfd
block|,
name|iocp_listener_getbase
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX define some way to override this. */
end_comment

begin_define
define|#
directive|define
name|N_SOCKETS_PER_LISTENER
value|4
end_define

begin_function
name|struct
name|evconnlistener
modifier|*
name|evconnlistener_new_async
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evconnlistener_cb
name|cb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|int
name|backlog
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|int
name|socklen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|struct
name|evconnlistener_iocp
modifier|*
name|lev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|flags
operator||=
name|LEV_OPT_THREADSAFE
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|||
operator|!
name|event_base_get_iocp_
argument_list|(
name|base
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* XXXX duplicate code */
if|if
condition|(
name|backlog
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|backlog
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
literal|128
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|socklen
argument_list|)
condition|)
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|lev
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evconnlistener_iocp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lev
condition|)
block|{
name|event_warn
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|lev
operator|->
name|base
operator|.
name|ops
operator|=
operator|&
name|evconnlistener_iocp_ops
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|cb
operator|=
name|cb
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|user_data
operator|=
name|ptr
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|refcnt
operator|=
literal|1
expr_stmt|;
name|lev
operator|->
name|base
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
name|lev
operator|->
name|port
operator|=
name|event_base_get_iocp_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|lev
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|lev
operator|->
name|event_base
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|event_iocp_port_associate_
argument_list|(
name|lev
operator|->
name|port
argument_list|,
name|fd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err_free_lev
goto|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|lev
operator|->
name|base
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|lev
operator|->
name|n_accepting
operator|=
name|N_SOCKETS_PER_LISTENER
expr_stmt|;
name|lev
operator|->
name|accepting
operator|=
name|mm_calloc
argument_list|(
name|lev
operator|->
name|n_accepting
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|accepting_socket
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lev
operator|->
name|accepting
condition|)
block|{
name|event_warn
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
goto|goto
name|err_delete_lock
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lev
operator|->
name|n_accepting
condition|;
operator|++
name|i
control|)
block|{
name|lev
operator|->
name|accepting
index|[
name|i
index|]
operator|=
name|new_accepting_socket
argument_list|(
name|lev
argument_list|,
name|ss
operator|.
name|ss_family
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lev
operator|->
name|accepting
index|[
name|i
index|]
condition|)
block|{
name|event_warnx
argument_list|(
literal|"Couldn't create accepting socket"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_accepting
goto|;
block|}
if|if
condition|(
name|cb
operator|&&
name|start_accepting
argument_list|(
name|lev
operator|->
name|accepting
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|event_warnx
argument_list|(
literal|"Couldn't start accepting on socket"
argument_list|)
expr_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|lev
operator|->
name|accepting
index|[
name|i
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_and_unlock_accepting_socket
argument_list|(
name|lev
operator|->
name|accepting
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|err_free_accepting
goto|;
block|}
operator|++
name|lev
operator|->
name|base
operator|.
name|refcnt
expr_stmt|;
block|}
name|iocp_listener_event_add
argument_list|(
name|lev
argument_list|)
expr_stmt|;
return|return
operator|&
name|lev
operator|->
name|base
return|;
name|err_free_accepting
label|:
name|mm_free
argument_list|(
name|lev
operator|->
name|accepting
argument_list|)
expr_stmt|;
comment|/* XXXX free the other elements. */
name|err_delete_lock
label|:
name|EVTHREAD_FREE_LOCK
argument_list|(
name|lev
operator|->
name|base
operator|.
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|err_free_lev
label|:
name|mm_free
argument_list|(
name|lev
argument_list|)
expr_stmt|;
name|err
label|:
comment|/* Don't close the fd, it is caller's responsibility. */
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

