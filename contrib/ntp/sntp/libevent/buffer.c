begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_VASPRINTF
end_ifdef

begin_comment
comment|/* If we have vasprintf, we need to define _GNU_SOURCE before we include  * stdio.h.  This comes from evconfig-private.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_UIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_MMAN_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SENDFILE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/sendfile.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"evbuffer-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_comment
comment|/* some systems do not have MAP_FAILED */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FAILED
end_ifndef

begin_define
define|#
directive|define
name|MAP_FAILED
value|((void *)-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* send file support */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_SYS_SENDFILE_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_SENDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_SENDFILE
value|1
end_define

begin_define
define|#
directive|define
name|SENDFILE_IS_LINUX
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_SENDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_SENDFILE
value|1
end_define

begin_define
define|#
directive|define
name|SENDFILE_IS_FREEBSD
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_SENDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_SENDFILE
value|1
end_define

begin_define
define|#
directive|define
name|SENDFILE_IS_MACOSX
value|1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_SENDFILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sun__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__svr4__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_SENDFILE
value|1
end_define

begin_define
define|#
directive|define
name|SENDFILE_IS_SOLARIS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Mask of user-selectable callback flags. */
end_comment

begin_define
define|#
directive|define
name|EVBUFFER_CB_USER_FLAGS
value|0xffff
end_define

begin_comment
comment|/* Mask of all internal-use-only flags. */
end_comment

begin_define
define|#
directive|define
name|EVBUFFER_CB_INTERNAL_FLAGS
value|0xffff0000
end_define

begin_comment
comment|/* Flag set if the callback is using the cb_obsolete function pointer  */
end_comment

begin_define
define|#
directive|define
name|EVBUFFER_CB_OBSOLETE
value|0x00040000
end_define

begin_comment
comment|/* evbuffer_chain support */
end_comment

begin_define
define|#
directive|define
name|CHAIN_SPACE_PTR
parameter_list|(
name|ch
parameter_list|)
value|((ch)->buffer + (ch)->misalign + (ch)->off)
end_define

begin_define
define|#
directive|define
name|CHAIN_SPACE_LEN
parameter_list|(
name|ch
parameter_list|)
value|((ch)->flags& EVBUFFER_IMMUTABLE ? \ 	    0 : (ch)->buffer_len - ((ch)->misalign + (ch)->off))
end_define

begin_define
define|#
directive|define
name|CHAIN_PINNED
parameter_list|(
name|ch
parameter_list|)
value|(((ch)->flags& EVBUFFER_MEM_PINNED_ANY) != 0)
end_define

begin_define
define|#
directive|define
name|CHAIN_PINNED_R
parameter_list|(
name|ch
parameter_list|)
value|(((ch)->flags& EVBUFFER_MEM_PINNED_R) != 0)
end_define

begin_comment
comment|/* evbuffer_ptr support */
end_comment

begin_define
define|#
directive|define
name|PTR_NOT_FOUND
parameter_list|(
name|ptr
parameter_list|)
value|do {			\ 	(ptr)->pos = -1;					\ 	(ptr)->internal_.chain = NULL;		\ 	(ptr)->internal_.pos_in_chain = 0;	\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|evbuffer_chain_align
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evbuffer_chain_should_realign
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|,
name|size_t
name|datalen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evbuffer_deferred_callback
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evbuffer_ptr_memcmp
parameter_list|(
specifier|const
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
specifier|const
name|char
modifier|*
name|mem
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|evbuffer_chain
modifier|*
name|evbuffer_expand_singlechain
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|datlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evbuffer_ptr_subtract
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
name|size_t
name|howfar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evbuffer_file_segment_materialize
parameter_list|(
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|evbuffer_chain_incref
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|evbuffer_chain
modifier|*
name|evbuffer_chain_new
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|size_t
name|to_alloc
decl_stmt|;
name|size
operator|+=
name|EVBUFFER_CHAIN_SIZE
expr_stmt|;
comment|/* get the next largest memory that can hold the buffer */
name|to_alloc
operator|=
name|MIN_BUFFER_SIZE
expr_stmt|;
while|while
condition|(
name|to_alloc
operator|<
name|size
condition|)
name|to_alloc
operator|<<=
literal|1
expr_stmt|;
comment|/* we get everything in one chunk */
if|if
condition|(
operator|(
name|chain
operator|=
name|mm_malloc
argument_list|(
name|to_alloc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|chain
argument_list|,
literal|0
argument_list|,
name|EVBUFFER_CHAIN_SIZE
argument_list|)
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|to_alloc
operator|-
name|EVBUFFER_CHAIN_SIZE
expr_stmt|;
comment|/* this way we can manipulate the buffer to different addresses, 	 * which is required for mmap for example. 	 */
name|chain
operator|->
name|buffer
operator|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
name|u_char
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|chain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|evbuffer_chain_free
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|->
name|refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|chain
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
comment|/* chain is still referenced by other chains */
return|return;
block|}
if|if
condition|(
name|CHAIN_PINNED
argument_list|(
name|chain
argument_list|)
condition|)
block|{
comment|/* will get freed once no longer dangling */
name|chain
operator|->
name|refcnt
operator|++
expr_stmt|;
name|chain
operator|->
name|flags
operator||=
name|EVBUFFER_DANGLING
expr_stmt|;
return|return;
block|}
comment|/* safe to release chain, it's either a referencing 	 * chain or all references to it have been freed */
if|if
condition|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_REFERENCE
condition|)
block|{
name|struct
name|evbuffer_chain_reference
modifier|*
name|info
init|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_chain_reference
argument_list|,
name|chain
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|cleanupfn
condition|)
call|(
modifier|*
name|info
operator|->
name|cleanupfn
call|)
argument_list|(
name|chain
operator|->
name|buffer
argument_list|,
name|chain
operator|->
name|buffer_len
argument_list|,
name|info
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_FILESEGMENT
condition|)
block|{
name|struct
name|evbuffer_chain_file_segment
modifier|*
name|info
init|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_chain_file_segment
argument_list|,
name|chain
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|segment
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|info
operator|->
name|segment
operator|->
name|is_mapping
condition|)
name|UnmapViewOfFile
argument_list|(
name|chain
operator|->
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|evbuffer_file_segment_free
argument_list|(
name|info
operator|->
name|segment
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_MULTICAST
condition|)
block|{
name|struct
name|evbuffer_multicast_parent
modifier|*
name|info
init|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_multicast_parent
argument_list|,
name|chain
argument_list|)
decl_stmt|;
comment|/* referencing chain is being freed, decrease 		 * refcounts of source chain and associated 		 * evbuffer (which get freed once both reach 		 * zero) */
name|EVUTIL_ASSERT
argument_list|(
name|info
operator|->
name|source
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|info
operator|->
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|info
operator|->
name|source
argument_list|)
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|info
operator|->
name|parent
argument_list|)
expr_stmt|;
name|evbuffer_decref_and_unlock_
argument_list|(
name|info
operator|->
name|source
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evbuffer_free_all_chains
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_function
specifier|static
name|int
name|evbuffer_chains_all_empty
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
if|if
condition|(
name|chain
operator|->
name|off
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* The definition is needed for EVUTIL_ASSERT, which uses sizeof to avoid "unused variable" warnings. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|evbuffer_chains_all_empty
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Free all trailing chains in 'buf' that are neither pinned nor empty, prior  * to replacing them all with a new chain.  Return a pointer to the place  * where the new chain will go.  *  * Internal; requires lock.  The caller must fix up buf->last and buf->first  * as needed; they might have been freed.  */
end_comment

begin_function
specifier|static
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|evbuffer_free_trailing_empty_chains
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|ch
init|=
name|buf
operator|->
name|last_with_datap
decl_stmt|;
comment|/* Find the first victim chain.  It might be *last_with_datap */
while|while
condition|(
operator|(
operator|*
name|ch
operator|)
operator|&&
operator|(
operator|(
operator|*
name|ch
operator|)
operator|->
name|off
operator|!=
literal|0
operator|||
name|CHAIN_PINNED
argument_list|(
operator|*
name|ch
argument_list|)
operator|)
condition|)
name|ch
operator|=
operator|&
operator|(
operator|*
name|ch
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|ch
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|evbuffer_chains_all_empty
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_free_all_chains
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Add a single chain 'chain' to the end of 'buf', freeing trailing empty  * chains as necessary.  Requires lock.  Does not schedule callbacks.  */
end_comment

begin_function
specifier|static
name|void
name|evbuffer_chain_insert
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|==
name|NULL
condition|)
block|{
comment|/* There are no chains data on the buffer at all. */
name|EVUTIL_ASSERT
argument_list|(
name|buf
operator|->
name|last_with_datap
operator|==
operator|&
name|buf
operator|->
name|first
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|buf
operator|->
name|first
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|->
name|first
operator|=
name|buf
operator|->
name|last
operator|=
name|chain
expr_stmt|;
block|}
else|else
block|{
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|chp
decl_stmt|;
name|chp
operator|=
name|evbuffer_free_trailing_empty_chains
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|chp
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|off
condition|)
name|buf
operator|->
name|last_with_datap
operator|=
name|chp
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|chain
expr_stmt|;
block|}
name|buf
operator|->
name|total_len
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|evbuffer_chain
modifier|*
name|evbuffer_chain_insert_new
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
if|if
condition|(
operator|(
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_function
name|void
name|evbuffer_chain_pin_
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|chain
operator|->
name|flags
operator|&
name|flag
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_chain_unpin_
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|chain
operator|->
name|flags
operator|&
name|flag
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|->
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_DANGLING
condition|)
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|evbuffer_chain_incref
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
operator|++
name|chain
operator|->
name|refcnt
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evbuffer
modifier|*
name|evbuffer_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|buffer
operator|->
name|last_with_datap
operator|=
operator|&
name|buffer
operator|->
name|first
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_set_flags
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_uint64_t
name|flags
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|flags
operator||=
operator|(
name|ev_uint32_t
operator|)
name|flags
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_clear_flags
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_uint64_t
name|flags
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ev_uint32_t
operator|)
name|flags
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|evbuffer_incref_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|++
name|buf
operator|->
name|refcnt
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_incref_and_lock_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|++
name|buf
operator|->
name|refcnt
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evbuffer_defer_callbacks
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|cb_queue
operator|=
name|base
expr_stmt|;
name|buffer
operator|->
name|deferred_cbs
operator|=
literal|1
expr_stmt|;
name|event_deferred_cb_init_
argument_list|(
operator|&
name|buffer
operator|->
name|deferred
argument_list|,
name|event_base_get_npriorities
argument_list|(
name|base
argument_list|)
operator|/
literal|2
argument_list|,
name|evbuffer_deferred_callback
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_enable_locking
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EVENT__DISABLE_THREAD_SUPPORT
return|return
operator|-
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|buf
operator|->
name|lock
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|lock
condition|)
block|{
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
operator|-
literal|1
return|;
name|buf
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|buf
operator|->
name|own_lock
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
name|buf
operator|->
name|own_lock
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|evbuffer_set_parent_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|parent
operator|=
name|bev
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evbuffer_run_callbacks
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|running_deferred
parameter_list|)
block|{
name|struct
name|evbuffer_cb_entry
modifier|*
name|cbent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|evbuffer_cb_info
name|info
decl_stmt|;
name|size_t
name|new_size
decl_stmt|;
name|ev_uint32_t
name|mask
decl_stmt|,
name|masked_val
decl_stmt|;
name|int
name|clear
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|running_deferred
condition|)
block|{
name|mask
operator|=
name|EVBUFFER_CB_NODEFER
operator||
name|EVBUFFER_CB_ENABLED
expr_stmt|;
name|masked_val
operator|=
name|EVBUFFER_CB_ENABLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffer
operator|->
name|deferred_cbs
condition|)
block|{
name|mask
operator|=
name|EVBUFFER_CB_NODEFER
operator||
name|EVBUFFER_CB_ENABLED
expr_stmt|;
name|masked_val
operator|=
name|EVBUFFER_CB_NODEFER
operator||
name|EVBUFFER_CB_ENABLED
expr_stmt|;
comment|/* Don't zero-out n_add/n_del, since the deferred callbacks 		   will want to see them. */
name|clear
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
name|EVBUFFER_CB_ENABLED
expr_stmt|;
name|masked_val
operator|=
name|EVBUFFER_CB_ENABLED
expr_stmt|;
block|}
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|n_add_for_cb
operator|=
name|buffer
operator|->
name|n_del_for_cb
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buffer
operator|->
name|n_add_for_cb
operator|==
literal|0
operator|&&
name|buffer
operator|->
name|n_del_for_cb
operator|==
literal|0
condition|)
return|return;
name|new_size
operator|=
name|buffer
operator|->
name|total_len
expr_stmt|;
name|info
operator|.
name|orig_size
operator|=
name|new_size
operator|+
name|buffer
operator|->
name|n_del_for_cb
operator|-
name|buffer
operator|->
name|n_add_for_cb
expr_stmt|;
name|info
operator|.
name|n_added
operator|=
name|buffer
operator|->
name|n_add_for_cb
expr_stmt|;
name|info
operator|.
name|n_deleted
operator|=
name|buffer
operator|->
name|n_del_for_cb
expr_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
name|buffer
operator|->
name|n_add_for_cb
operator|=
literal|0
expr_stmt|;
name|buffer
operator|->
name|n_del_for_cb
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|cbent
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
init|;
name|cbent
operator|!=
name|LIST_END
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
condition|;
name|cbent
operator|=
name|next
control|)
block|{
comment|/* Get the 'next' pointer now in case this callback decides 		 * to remove itself or something. */
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|cbent
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cbent
operator|->
name|flags
operator|&
name|mask
operator|)
operator|!=
name|masked_val
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cbent
operator|->
name|flags
operator|&
name|EVBUFFER_CB_OBSOLETE
operator|)
condition|)
name|cbent
operator|->
name|cb
operator|.
name|cb_obsolete
argument_list|(
name|buffer
argument_list|,
name|info
operator|.
name|orig_size
argument_list|,
name|new_size
argument_list|,
name|cbent
operator|->
name|cbarg
argument_list|)
expr_stmt|;
else|else
name|cbent
operator|->
name|cb
operator|.
name|cb_func
argument_list|(
name|buffer
argument_list|,
operator|&
name|info
argument_list|,
name|cbent
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evbuffer_invoke_callbacks_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
condition|)
block|{
name|buffer
operator|->
name|n_add_for_cb
operator|=
name|buffer
operator|->
name|n_del_for_cb
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buffer
operator|->
name|deferred_cbs
condition|)
block|{
if|if
condition|(
name|event_deferred_cb_schedule_
argument_list|(
name|buffer
operator|->
name|cb_queue
argument_list|,
operator|&
name|buffer
operator|->
name|deferred
argument_list|)
condition|)
block|{
name|evbuffer_incref_and_lock_
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|parent
condition|)
name|bufferevent_incref_
argument_list|(
name|buffer
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|evbuffer_run_callbacks
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evbuffer_deferred_callback
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buffer
init|=
name|arg
decl_stmt|;
comment|/* XXXX It would be better to run these callbacks without holding the 	 * lock */
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|parent
operator|=
name|buffer
operator|->
name|parent
expr_stmt|;
name|evbuffer_run_callbacks
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_decref_and_unlock_
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|bufferevent_decref_
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evbuffer_remove_all_callbacks
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|evbuffer_cb_entry
modifier|*
name|cbent
decl_stmt|;
while|while
condition|(
operator|(
name|cbent
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
operator|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|cbent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|cbent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evbuffer_decref_and_unlock_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|buffer
operator|->
name|refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|buffer
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|chain
operator|=
name|buffer
operator|->
name|first
init|;
name|chain
operator|!=
name|NULL
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|evbuffer_remove_all_callbacks
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|deferred_cbs
condition|)
name|event_deferred_cb_cancel_
argument_list|(
name|buffer
operator|->
name|cb_queue
argument_list|,
operator|&
name|buffer
operator|->
name|deferred
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|own_lock
condition|)
name|EVTHREAD_FREE_LOCK
argument_list|(
name|buffer
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_free
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|evbuffer_decref_and_unlock_
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_lock
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_unlock
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|evbuffer_get_length
parameter_list|(
specifier|const
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|size_t
name|result
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|buffer
operator|->
name|total_len
operator|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|size_t
name|evbuffer_get_contiguous_space
parameter_list|(
specifier|const
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|size_t
name|result
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
name|result
operator|=
operator|(
name|chain
operator|!=
name|NULL
condition|?
name|chain
operator|->
name|off
else|:
literal|0
operator|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|size_t
name|evbuffer_add_iovec
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_iovec
modifier|*
name|vec
parameter_list|,
name|int
name|n_vec
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|size_t
name|to_alloc
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|res
operator|=
name|to_alloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_vec
condition|;
name|n
operator|++
control|)
block|{
name|to_alloc
operator|+=
name|vec
index|[
name|n
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
if|if
condition|(
name|evbuffer_expand_fast_
argument_list|(
name|buf
argument_list|,
name|to_alloc
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_vec
condition|;
name|n
operator|++
control|)
block|{
comment|/* XXX each 'add' call here does a bunch of setup that's 		 * obviated by evbuffer_expand_fast_, and some cleanup that we 		 * would like to do only once.  Instead we should just extract 		 * the part of the code that's needed. */
if|if
condition|(
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|vec
index|[
name|n
index|]
operator|.
name|iov_base
argument_list|,
name|vec
index|[
name|n
index|]
operator|.
name|iov_len
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|res
operator|+=
name|vec
index|[
name|n
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_reserve_space
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_ssize_t
name|size
parameter_list|,
name|struct
name|evbuffer_iovec
modifier|*
name|vec
parameter_list|,
name|int
name|n_vecs
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|n_vecs
operator|<
literal|1
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|n_vecs
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|chain
operator|=
name|evbuffer_expand_singlechain
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|CHAIN_SPACE_PTR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|size
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>=
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|evbuffer_expand_fast_
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|n_vecs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|n
operator|=
name|evbuffer_read_setup_vecs_
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|vec
argument_list|,
name|n_vecs
argument_list|,
operator|&
name|chainp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|advance_last_with_data
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|buf
operator|->
name|last_with_datap
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|)
operator|->
name|next
operator|&&
operator|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|)
operator|->
name|next
operator|->
name|off
condition|)
block|{
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
operator|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|)
operator|->
name|next
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_commit_space
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_iovec
modifier|*
name|vec
parameter_list|,
name|int
name|n_vecs
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
modifier|*
name|firstchainp
decl_stmt|,
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|added
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|n_vecs
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|n_vecs
operator|==
literal|1
operator|&&
operator|(
name|buf
operator|->
name|last
operator|&&
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|==
operator|(
name|void
operator|*
operator|)
name|CHAIN_SPACE_PTR
argument_list|(
name|buf
operator|->
name|last
argument_list|)
operator|)
condition|)
block|{
comment|/* The user only got or used one chain; it might not 		 * be the first one with space in it. */
if|if
condition|(
operator|(
name|size_t
operator|)
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|>
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|buf
operator|->
name|last
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|buf
operator|->
name|last
operator|->
name|off
operator|+=
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
name|added
operator|=
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|added
condition|)
name|advance_last_with_data
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|okay
goto|;
block|}
comment|/* Advance 'firstchain' to the first chain with space in it. */
name|firstchainp
operator|=
name|buf
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|firstchainp
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|CHAIN_SPACE_LEN
argument_list|(
operator|*
name|firstchainp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|firstchainp
operator|=
operator|&
operator|(
operator|*
name|firstchainp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|chain
operator|=
operator|*
name|firstchainp
expr_stmt|;
comment|/* pass 1: make sure that the pointers and lengths of vecs[] are in 	 * bounds before we try to commit anything. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vecs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|chain
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|vec
index|[
name|i
index|]
operator|.
name|iov_base
operator|!=
operator|(
name|void
operator|*
operator|)
name|CHAIN_SPACE_PTR
argument_list|(
name|chain
argument_list|)
operator|||
operator|(
name|size_t
operator|)
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
operator|>
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
comment|/* pass 2: actually adjust all the chains. */
name|chainp
operator|=
name|firstchainp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vecs
condition|;
operator|++
name|i
control|)
block|{
operator|(
operator|*
name|chainp
operator|)
operator|->
name|off
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|added
operator|+=
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|vec
index|[
name|i
index|]
operator|.
name|iov_len
condition|)
block|{
name|buf
operator|->
name|last_with_datap
operator|=
name|chainp
expr_stmt|;
block|}
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|okay
label|:
name|buf
operator|->
name|total_len
operator|+=
name|added
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|added
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|HAS_PINNED_R
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|last
operator|&&
name|CHAIN_PINNED_R
argument_list|(
name|buf
operator|->
name|last
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ZERO_CHAIN
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|last_with_datap
operator|=
operator|&
operator|(
name|dst
operator|)
operator|->
name|first
expr_stmt|;
name|dst
operator|->
name|total_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepares the contents of src to be moved to another buffer by removing  * read-pinned chains. The first pinned chain is saved in first, and the  * last in last. If src has no read-pinned chains, first and last are set  * to NULL. */
end_comment

begin_function
specifier|static
name|int
name|PRESERVE_PINNED
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|first
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
modifier|*
name|pinned
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PINNED_R
argument_list|(
name|src
argument_list|)
condition|)
block|{
operator|*
name|first
operator|=
operator|*
name|last
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pinned
operator|=
name|src
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
operator|!
name|CHAIN_PINNED_R
argument_list|(
operator|*
name|pinned
argument_list|)
condition|)
name|pinned
operator|=
operator|&
operator|(
operator|*
name|pinned
operator|)
operator|->
name|next
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|CHAIN_PINNED_R
argument_list|(
operator|*
name|pinned
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
operator|*
name|first
operator|=
operator|*
name|pinned
expr_stmt|;
operator|*
name|last
operator|=
name|src
operator|->
name|last
expr_stmt|;
comment|/* If there's data in the first pinned chain, we need to allocate 	 * a new chain and copy the data over. */
if|if
condition|(
name|chain
operator|->
name|off
condition|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|tmp
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|pinned
operator|==
name|src
operator|->
name|last_with_datap
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|chain
operator|->
name|off
expr_stmt|;
operator|*
name|src
operator|->
name|last_with_datap
operator|=
name|tmp
expr_stmt|;
name|src
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
name|chain
operator|->
name|misalign
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
name|chain
operator|->
name|off
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|src
operator|->
name|last
operator|=
operator|*
name|src
operator|->
name|last_with_datap
expr_stmt|;
operator|*
name|pinned
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|RESTORE_PINNED
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
name|pinned
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
name|last
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pinned
condition|)
block|{
name|ZERO_CHAIN
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return;
block|}
name|src
operator|->
name|first
operator|=
name|pinned
expr_stmt|;
name|src
operator|->
name|last
operator|=
name|last
expr_stmt|;
name|src
operator|->
name|last_with_datap
operator|=
operator|&
name|src
operator|->
name|first
expr_stmt|;
name|src
operator|->
name|total_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|COPY_CHAIN
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|->
name|first
operator|=
name|src
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|last_with_datap
operator|==
operator|&
name|src
operator|->
name|first
condition|)
name|dst
operator|->
name|last_with_datap
operator|=
operator|&
name|dst
operator|->
name|first
expr_stmt|;
else|else
name|dst
operator|->
name|last_with_datap
operator|=
name|src
operator|->
name|last_with_datap
expr_stmt|;
name|dst
operator|->
name|last
operator|=
name|src
operator|->
name|last
expr_stmt|;
name|dst
operator|->
name|total_len
operator|=
name|src
operator|->
name|total_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|APPEND_CHAIN
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|->
name|last
operator|->
name|next
operator|=
name|src
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|last_with_datap
operator|==
operator|&
name|src
operator|->
name|first
condition|)
name|dst
operator|->
name|last_with_datap
operator|=
operator|&
name|dst
operator|->
name|last
operator|->
name|next
expr_stmt|;
else|else
name|dst
operator|->
name|last_with_datap
operator|=
name|src
operator|->
name|last_with_datap
expr_stmt|;
name|dst
operator|->
name|last
operator|=
name|src
operator|->
name|last
expr_stmt|;
name|dst
operator|->
name|total_len
operator|+=
name|src
operator|->
name|total_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|APPEND_CHAIN_MULTICAST
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|tmp
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|src
operator|->
name|first
decl_stmt|;
name|struct
name|evbuffer_multicast_parent
modifier|*
name|extra
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|chain
operator|->
name|off
operator|||
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_DANGLING
condition|)
block|{
comment|/* skip empty chains */
continue|continue;
block|}
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_multicast_parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|extra
operator|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_multicast_parent
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* reference evbuffer containing source chain so it 		 * doesn't get released while the chain is still 		 * being referenced to */
name|evbuffer_incref_
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|extra
operator|->
name|source
operator|=
name|src
expr_stmt|;
comment|/* reference source chain which now becomes immutable */
name|evbuffer_chain_incref
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|extra
operator|->
name|parent
operator|=
name|chain
expr_stmt|;
name|chain
operator|->
name|flags
operator||=
name|EVBUFFER_IMMUTABLE
expr_stmt|;
name|tmp
operator|->
name|buffer_len
operator|=
name|chain
operator|->
name|buffer_len
expr_stmt|;
name|tmp
operator|->
name|misalign
operator|=
name|chain
operator|->
name|misalign
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|chain
operator|->
name|off
expr_stmt|;
name|tmp
operator|->
name|flags
operator||=
name|EVBUFFER_MULTICAST
operator||
name|EVBUFFER_IMMUTABLE
expr_stmt|;
name|tmp
operator|->
name|buffer
operator|=
name|chain
operator|->
name|buffer
expr_stmt|;
name|evbuffer_chain_insert
argument_list|(
name|dst
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|PREPEND_CHAIN
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|)
block|{
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src
operator|->
name|last
operator|->
name|next
operator|=
name|dst
operator|->
name|first
expr_stmt|;
name|dst
operator|->
name|first
operator|=
name|src
operator|->
name|first
expr_stmt|;
name|dst
operator|->
name|total_len
operator|+=
name|src
operator|->
name|total_len
expr_stmt|;
if|if
condition|(
operator|*
name|dst
operator|->
name|last_with_datap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|src
operator|->
name|last_with_datap
operator|==
operator|&
operator|(
name|src
operator|)
operator|->
name|first
condition|)
name|dst
operator|->
name|last_with_datap
operator|=
operator|&
name|dst
operator|->
name|first
expr_stmt|;
else|else
name|dst
operator|->
name|last_with_datap
operator|=
name|src
operator|->
name|last_with_datap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst
operator|->
name|last_with_datap
operator|==
operator|&
name|dst
operator|->
name|first
condition|)
block|{
name|dst
operator|->
name|last_with_datap
operator|=
operator|&
name|src
operator|->
name|last
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|evbuffer_add_buffer
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|outbuf
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|inbuf
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|pinned
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|size_t
name|in_total_len
decl_stmt|,
name|out_total_len
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|in_total_len
operator|=
name|inbuf
operator|->
name|total_len
expr_stmt|;
name|out_total_len
operator|=
name|outbuf
operator|->
name|total_len
expr_stmt|;
if|if
condition|(
name|in_total_len
operator|==
literal|0
operator|||
name|outbuf
operator|==
name|inbuf
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|outbuf
operator|->
name|freeze_end
operator|||
name|inbuf
operator|->
name|freeze_start
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|PRESERVE_PINNED
argument_list|(
name|inbuf
argument_list|,
operator|&
name|pinned
argument_list|,
operator|&
name|last
argument_list|)
operator|<
literal|0
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|out_total_len
operator|==
literal|0
condition|)
block|{
comment|/* There might be an empty chain at the start of outbuf; free 		 * it. */
name|evbuffer_free_all_chains
argument_list|(
name|outbuf
operator|->
name|first
argument_list|)
expr_stmt|;
name|COPY_CHAIN
argument_list|(
name|outbuf
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|APPEND_CHAIN
argument_list|(
name|outbuf
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
block|}
name|RESTORE_PINNED
argument_list|(
name|inbuf
argument_list|,
name|pinned
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|n_del_for_cb
operator|+=
name|in_total_len
expr_stmt|;
name|outbuf
operator|->
name|n_add_for_cb
operator|+=
name|in_total_len
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_buffer_reference
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|outbuf
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|inbuf
parameter_list|)
block|{
name|size_t
name|in_total_len
decl_stmt|,
name|out_total_len
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|in_total_len
operator|=
name|inbuf
operator|->
name|total_len
expr_stmt|;
name|out_total_len
operator|=
name|outbuf
operator|->
name|total_len
expr_stmt|;
name|chain
operator|=
name|inbuf
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|in_total_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|outbuf
operator|->
name|freeze_end
operator|||
name|outbuf
operator|==
name|inbuf
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|chain
operator|->
name|flags
operator|&
operator|(
name|EVBUFFER_FILESEGMENT
operator||
name|EVBUFFER_SENDFILE
operator||
name|EVBUFFER_MULTICAST
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* chain type can not be referenced */
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|out_total_len
operator|==
literal|0
condition|)
block|{
comment|/* There might be an empty chain at the start of outbuf; free 		 * it. */
name|evbuffer_free_all_chains
argument_list|(
name|outbuf
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
name|APPEND_CHAIN_MULTICAST
argument_list|(
name|outbuf
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
name|outbuf
operator|->
name|n_add_for_cb
operator|+=
name|in_total_len
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_prepend_buffer
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|outbuf
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|inbuf
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|pinned
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|size_t
name|in_total_len
decl_stmt|,
name|out_total_len
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|in_total_len
operator|=
name|inbuf
operator|->
name|total_len
expr_stmt|;
name|out_total_len
operator|=
name|outbuf
operator|->
name|total_len
expr_stmt|;
if|if
condition|(
operator|!
name|in_total_len
operator|||
name|inbuf
operator|==
name|outbuf
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|outbuf
operator|->
name|freeze_start
operator|||
name|inbuf
operator|->
name|freeze_start
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|PRESERVE_PINNED
argument_list|(
name|inbuf
argument_list|,
operator|&
name|pinned
argument_list|,
operator|&
name|last
argument_list|)
operator|<
literal|0
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|out_total_len
operator|==
literal|0
condition|)
block|{
comment|/* There might be an empty chain at the start of outbuf; free 		 * it. */
name|evbuffer_free_all_chains
argument_list|(
name|outbuf
operator|->
name|first
argument_list|)
expr_stmt|;
name|COPY_CHAIN
argument_list|(
name|outbuf
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PREPEND_CHAIN
argument_list|(
name|outbuf
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
block|}
name|RESTORE_PINNED
argument_list|(
name|inbuf
argument_list|,
name|pinned
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|n_del_for_cb
operator|+=
name|in_total_len
expr_stmt|;
name|outbuf
operator|->
name|n_add_for_cb
operator|+=
name|in_total_len
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK2
argument_list|(
name|inbuf
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_drain
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|size_t
name|remaining
decl_stmt|,
name|old_len
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|buf
operator|->
name|total_len
expr_stmt|;
if|if
condition|(
name|old_len
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|buf
operator|->
name|freeze_start
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|len
operator|>=
name|old_len
operator|&&
operator|!
name|HAS_PINNED_R
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|len
operator|=
name|old_len
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|buf
operator|->
name|first
init|;
name|chain
operator|!=
name|NULL
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|ZERO_CHAIN
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>=
name|old_len
condition|)
name|len
operator|=
name|old_len
expr_stmt|;
name|buf
operator|->
name|total_len
operator|-=
name|len
expr_stmt|;
name|remaining
operator|=
name|len
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|buf
operator|->
name|first
init|;
name|remaining
operator|>=
name|chain
operator|->
name|off
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|remaining
operator|-=
name|chain
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|chain
operator|==
operator|*
name|buf
operator|->
name|last_with_datap
condition|)
block|{
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
expr_stmt|;
block|}
if|if
condition|(
operator|&
name|chain
operator|->
name|next
operator|==
name|buf
operator|->
name|last_with_datap
condition|)
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|CHAIN_PINNED_R
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|remaining
operator|==
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|->
name|misalign
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
name|chain
operator|->
name|off
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|first
operator|=
name|chain
expr_stmt|;
name|chain
operator|->
name|misalign
operator|+=
name|remaining
expr_stmt|;
name|chain
operator|->
name|off
operator|-=
name|remaining
expr_stmt|;
block|}
name|buf
operator|->
name|n_del_for_cb
operator|+=
name|len
expr_stmt|;
comment|/* Tell someone about changes in this buffer */
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Reads data from an event buffer and drains the bytes read */
end_comment

begin_function
name|int
name|evbuffer_remove
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|data_out
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|ev_ssize_t
name|n
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|n
operator|=
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|data_out
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|evbuffer_drain
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|n
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|evbuffer_copyout
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|data_out
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
return|return
name|evbuffer_copyout_from
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|data_out
argument_list|,
name|datlen
argument_list|)
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|evbuffer_copyout_from
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
name|void
modifier|*
name|data_out
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
comment|/*XXX fails badly on sendfile case. */
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|data_out
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
name|ev_ssize_t
name|result
init|=
literal|0
decl_stmt|;
name|size_t
name|pos_in_chain
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
block|{
name|chain
operator|=
name|pos
operator|->
name|internal_
operator|.
name|chain
expr_stmt|;
name|pos_in_chain
operator|=
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
if|if
condition|(
name|datlen
operator|+
name|pos
operator|->
name|pos
operator|>
name|buf
operator|->
name|total_len
condition|)
name|datlen
operator|=
name|buf
operator|->
name|total_len
operator|-
name|pos
operator|->
name|pos
expr_stmt|;
block|}
else|else
block|{
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datlen
operator|>
name|buf
operator|->
name|total_len
condition|)
name|datlen
operator|=
name|buf
operator|->
name|total_len
expr_stmt|;
block|}
if|if
condition|(
name|datlen
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|buf
operator|->
name|freeze_start
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nread
operator|=
name|datlen
expr_stmt|;
while|while
condition|(
name|datlen
operator|&&
name|datlen
operator|>=
name|chain
operator|->
name|off
operator|-
name|pos_in_chain
condition|)
block|{
name|size_t
name|copylen
init|=
name|chain
operator|->
name|off
operator|-
name|pos_in_chain
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|pos_in_chain
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|data
operator|+=
name|copylen
expr_stmt|;
name|datlen
operator|-=
name|copylen
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|||
name|datlen
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|datlen
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|pos_in_chain
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|nread
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* reads data from the src buffer to the dst buffer, avoids memcpy as  * possible. */
end_comment

begin_comment
comment|/*  XXXX should return ev_ssize_t */
end_comment

begin_function
name|int
name|evbuffer_remove_buffer
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|src
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|dst
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
comment|/*XXX We should have an option to force this to be zero-copy.*/
comment|/*XXX can fail badly on sendfile case. */
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|size_t
name|nread
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|EVBUFFER_LOCK2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|chain
operator|=
name|previous
operator|=
name|src
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|datlen
operator|==
literal|0
operator|||
name|dst
operator|==
name|src
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dst
operator|->
name|freeze_end
operator|||
name|src
operator|->
name|freeze_start
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* short-cut if there is no more data buffered */
if|if
condition|(
name|datlen
operator|>=
name|src
operator|->
name|total_len
condition|)
block|{
name|datlen
operator|=
name|src
operator|->
name|total_len
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|int
operator|)
name|datlen
expr_stmt|;
comment|/*XXXX should return ev_ssize_t*/
goto|goto
name|done
goto|;
block|}
comment|/* removes chains if possible */
while|while
condition|(
name|chain
operator|->
name|off
operator|<=
name|datlen
condition|)
block|{
comment|/* We can't remove the last with data from src unless we 		 * remove all chains, in which case we would have done the if 		 * block above */
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|!=
operator|*
name|src
operator|->
name|last_with_datap
argument_list|)
expr_stmt|;
name|nread
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
name|datlen
operator|-=
name|chain
operator|->
name|off
expr_stmt|;
name|previous
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|last_with_datap
operator|==
operator|&
name|chain
operator|->
name|next
condition|)
name|src
operator|->
name|last_with_datap
operator|=
operator|&
name|src
operator|->
name|first
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|nread
condition|)
block|{
comment|/* we can remove the chain */
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|chp
decl_stmt|;
name|chp
operator|=
name|evbuffer_free_trailing_empty_chains
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
name|dst
operator|->
name|first
operator|=
name|src
operator|->
name|first
expr_stmt|;
block|}
else|else
block|{
operator|*
name|chp
operator|=
name|src
operator|->
name|first
expr_stmt|;
block|}
name|dst
operator|->
name|last
operator|=
name|previous
expr_stmt|;
name|previous
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|src
operator|->
name|first
operator|=
name|chain
expr_stmt|;
name|advance_last_with_data
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|->
name|total_len
operator|+=
name|nread
expr_stmt|;
name|dst
operator|->
name|n_add_for_cb
operator|+=
name|nread
expr_stmt|;
block|}
comment|/* we know that there is more data in the src buffer than 	 * we want to read, so we manually drain the chain */
name|evbuffer_add
argument_list|(
name|dst
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|chain
operator|->
name|misalign
operator|+=
name|datlen
expr_stmt|;
name|chain
operator|->
name|off
operator|-=
name|datlen
expr_stmt|;
name|nread
operator|+=
name|datlen
expr_stmt|;
comment|/* You might think we would want to increment dst->n_add_for_cb 	 * here too.  But evbuffer_add above already took care of that. 	 */
name|src
operator|->
name|total_len
operator|-=
name|nread
expr_stmt|;
name|src
operator|->
name|n_del_for_cb
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|nread
condition|)
block|{
name|evbuffer_invoke_callbacks_
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|int
operator|)
name|nread
expr_stmt|;
comment|/*XXXX should change return type */
name|done
label|:
name|EVBUFFER_UNLOCK2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|evbuffer_pullup
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_ssize_t
name|size
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|last_with_data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|ev_ssize_t
name|remaining
decl_stmt|;
name|int
name|removed_last_with_data
init|=
literal|0
decl_stmt|;
name|int
name|removed_last_with_datap
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
name|buf
operator|->
name|total_len
expr_stmt|;
comment|/* if size> buf->total_len, we cannot guarantee to the user that she 	 * is going to have a long enough buffer afterwards; so we return 	 * NULL */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
operator|(
name|size_t
operator|)
name|size
operator|>
name|buf
operator|->
name|total_len
condition|)
goto|goto
name|done
goto|;
comment|/* No need to pull up anything; the first size bytes are 	 * already here. */
if|if
condition|(
name|chain
operator|->
name|off
operator|>=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
name|result
operator|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Make sure that none of the chains we need to copy from is pinned. */
name|remaining
operator|=
name|size
operator|-
name|chain
operator|->
name|off
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|remaining
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|chain
operator|->
name|next
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|CHAIN_PINNED
argument_list|(
name|tmp
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|tmp
operator|->
name|off
operator|>=
operator|(
name|size_t
operator|)
name|remaining
condition|)
break|break;
name|remaining
operator|-=
name|tmp
operator|->
name|off
expr_stmt|;
block|}
if|if
condition|(
name|CHAIN_PINNED
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|size_t
name|old_off
init|=
name|chain
operator|->
name|off
decl_stmt|;
if|if
condition|(
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
operator|<
name|size
operator|-
name|chain
operator|->
name|off
condition|)
block|{
comment|/* not enough room at end of chunk. */
goto|goto
name|done
goto|;
block|}
name|buffer
operator|=
name|CHAIN_SPACE_PTR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|chain
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|size
expr_stmt|;
name|size
operator|-=
name|old_off
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chain
operator|->
name|buffer_len
operator|-
name|chain
operator|->
name|misalign
operator|>=
operator|(
name|size_t
operator|)
name|size
condition|)
block|{
comment|/* already have enough space in the first chain */
name|size_t
name|old_off
init|=
name|chain
operator|->
name|off
decl_stmt|;
name|buffer
operator|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
expr_stmt|;
name|tmp
operator|=
name|chain
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|size
expr_stmt|;
name|size
operator|-=
name|old_off
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|buffer
operator|=
name|tmp
operator|->
name|buffer
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|first
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* TODO(niels): deal with buffers that point to NULL like sendfile */
comment|/* Copy and free every chunk that will be entirely pulled into tmp */
name|last_with_data
operator|=
operator|*
name|buf
operator|->
name|last_with_datap
expr_stmt|;
for|for
control|(
init|;
name|chain
operator|!=
name|NULL
operator|&&
operator|(
name|size_t
operator|)
name|size
operator|>=
name|chain
operator|->
name|off
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
name|size
operator|-=
name|chain
operator|->
name|off
expr_stmt|;
name|buffer
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|last_with_data
condition|)
name|removed_last_with_data
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|&
name|chain
operator|->
name|next
operator|==
name|buf
operator|->
name|last_with_datap
condition|)
name|removed_last_with_datap
operator|=
literal|1
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|chain
operator|->
name|misalign
operator|+=
name|size
expr_stmt|;
name|chain
operator|->
name|off
operator|-=
name|size
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|->
name|next
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|removed_last_with_data
condition|)
block|{
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|removed_last_with_datap
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|first
operator|->
name|next
operator|&&
name|buf
operator|->
name|first
operator|->
name|next
operator|->
name|off
condition|)
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
operator|->
name|next
expr_stmt|;
else|else
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|tmp
operator|->
name|buffer
operator|+
name|tmp
operator|->
name|misalign
operator|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Reads a line terminated by either '\r\n', '\n\r' or '\r' or '\n'.  * The returned buffer needs to be freed by the called.  */
end_comment

begin_function
name|char
modifier|*
name|evbuffer_readline
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
return|return
name|evbuffer_readln
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
name|EVBUFFER_EOL_ANY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ev_ssize_t
name|evbuffer_strchr
parameter_list|(
name|struct
name|evbuffer_ptr
modifier|*
name|it
parameter_list|,
specifier|const
name|char
name|chr
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|it
operator|->
name|internal_
operator|.
name|chain
decl_stmt|;
name|size_t
name|i
init|=
name|it
operator|->
name|internal_
operator|.
name|pos_in_chain
decl_stmt|;
while|while
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|memchr
argument_list|(
name|buffer
operator|+
name|i
argument_list|,
name|chr
argument_list|,
name|chain
operator|->
name|off
operator|-
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|it
operator|->
name|internal_
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|it
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
name|cp
operator|-
name|buffer
expr_stmt|;
name|it
operator|->
name|pos
operator|+=
operator|(
name|cp
operator|-
name|buffer
operator|-
name|i
operator|)
expr_stmt|;
return|return
name|it
operator|->
name|pos
return|;
block|}
name|it
operator|->
name|pos
operator|+=
name|chain
operator|->
name|off
operator|-
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|find_eol_char
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
define|#
directive|define
name|CHUNK_SZ
value|128
comment|/* Lots of benchmarking found this approach to be faster in practice 	 * than doing two memchrs over the whole buffer, doin a memchr on each 	 * char of the buffer, or trying to emulate memchr by hand. */
name|char
modifier|*
name|s_end
decl_stmt|,
modifier|*
name|cr
decl_stmt|,
modifier|*
name|lf
decl_stmt|;
name|s_end
operator|=
name|s
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|s_end
condition|)
block|{
name|size_t
name|chunk
init|=
operator|(
name|s
operator|+
name|CHUNK_SZ
operator|<
name|s_end
operator|)
condition|?
name|CHUNK_SZ
else|:
operator|(
name|s_end
operator|-
name|s
operator|)
decl_stmt|;
name|cr
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'\r'
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|lf
operator|=
name|memchr
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
condition|)
block|{
if|if
condition|(
name|lf
operator|&&
name|lf
operator|<
name|cr
condition|)
return|return
name|lf
return|;
return|return
name|cr
return|;
block|}
elseif|else
if|if
condition|(
name|lf
condition|)
block|{
return|return
name|lf
return|;
block|}
name|s
operator|+=
name|CHUNK_SZ
expr_stmt|;
block|}
return|return
name|NULL
return|;
undef|#
directive|undef
name|CHUNK_SZ
block|}
end_function

begin_function
specifier|static
name|ev_ssize_t
name|evbuffer_find_eol_char
parameter_list|(
name|struct
name|evbuffer_ptr
modifier|*
name|it
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|it
operator|->
name|internal_
operator|.
name|chain
decl_stmt|;
name|size_t
name|i
init|=
name|it
operator|->
name|internal_
operator|.
name|pos_in_chain
decl_stmt|;
while|while
condition|(
name|chain
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|find_eol_char
argument_list|(
name|buffer
operator|+
name|i
argument_list|,
name|chain
operator|->
name|off
operator|-
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|it
operator|->
name|internal_
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|it
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
name|cp
operator|-
name|buffer
expr_stmt|;
name|it
operator|->
name|pos
operator|+=
operator|(
name|cp
operator|-
name|buffer
operator|)
operator|-
name|i
expr_stmt|;
return|return
name|it
operator|->
name|pos
return|;
block|}
name|it
operator|->
name|pos
operator|+=
name|chain
operator|->
name|off
operator|-
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|evbuffer_strspn
parameter_list|(
name|struct
name|evbuffer_ptr
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|chrset
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|ptr
operator|->
name|internal_
operator|.
name|chain
decl_stmt|;
name|size_t
name|i
init|=
name|ptr
operator|->
name|internal_
operator|.
name|pos_in_chain
decl_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|chain
operator|->
name|off
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|chrset
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|==
operator|*
name|p
operator|++
condition|)
goto|goto
name|next
goto|;
block|}
name|ptr
operator|->
name|internal_
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|ptr
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
name|i
expr_stmt|;
name|ptr
operator|->
name|pos
operator|+=
name|count
expr_stmt|;
return|return
name|count
return|;
name|next
label|:
operator|++
name|count
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|chain
operator|->
name|next
condition|)
block|{
name|ptr
operator|->
name|internal_
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|ptr
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
name|i
expr_stmt|;
name|ptr
operator|->
name|pos
operator|+=
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|evbuffer_getchr
parameter_list|(
name|struct
name|evbuffer_ptr
modifier|*
name|it
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|it
operator|->
name|internal_
operator|.
name|chain
decl_stmt|;
name|size_t
name|off
init|=
name|it
operator|->
name|internal_
operator|.
name|pos_in_chain
decl_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|chain
operator|->
name|buffer
index|[
name|chain
operator|->
name|misalign
operator|+
name|off
index|]
return|;
block|}
end_function

begin_function
name|struct
name|evbuffer_ptr
name|evbuffer_search_eol
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|evbuffer_ptr
modifier|*
name|start
parameter_list|,
name|size_t
modifier|*
name|eol_len_out
parameter_list|,
name|enum
name|evbuffer_eol_style
name|eol_style
parameter_list|)
block|{
name|struct
name|evbuffer_ptr
name|it
decl_stmt|,
name|it2
decl_stmt|;
name|size_t
name|extra_drain
init|=
literal|0
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Avoid locking in trivial edge cases */
if|if
condition|(
name|start
operator|&&
name|start
operator|->
name|internal_
operator|.
name|chain
operator|==
name|NULL
condition|)
block|{
name|PTR_NOT_FOUND
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_len_out
condition|)
operator|*
name|eol_len_out
operator|=
name|extra_drain
expr_stmt|;
return|return
name|it
return|;
block|}
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|it
argument_list|,
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|it
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|internal_
operator|.
name|chain
operator|=
name|buffer
operator|->
name|first
expr_stmt|;
name|it
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
block|}
comment|/* the eol_style determines our first stop character and how many 	 * characters we are going to drain afterwards. */
switch|switch
condition|(
name|eol_style
condition|)
block|{
case|case
name|EVBUFFER_EOL_ANY
case|:
if|if
condition|(
name|evbuffer_find_eol_char
argument_list|(
operator|&
name|it
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|memcpy
argument_list|(
operator|&
name|it2
argument_list|,
operator|&
name|it
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|extra_drain
operator|=
name|evbuffer_strspn
argument_list|(
operator|&
name|it2
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVBUFFER_EOL_CRLF_STRICT
case|:
block|{
name|it
operator|=
name|evbuffer_search
argument_list|(
name|buffer
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|,
operator|&
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|pos
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|extra_drain
operator|=
literal|2
expr_stmt|;
break|break;
block|}
case|case
name|EVBUFFER_EOL_CRLF
case|:
block|{
name|ev_ssize_t
name|start_pos
init|=
name|it
operator|.
name|pos
decl_stmt|;
comment|/* Look for a LF ... */
if|if
condition|(
name|evbuffer_strchr
argument_list|(
operator|&
name|it
argument_list|,
literal|'\n'
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|extra_drain
operator|=
literal|1
expr_stmt|;
comment|/* ... optionally preceeded by a CR. */
if|if
condition|(
name|it
operator|.
name|pos
operator|==
name|start_pos
condition|)
break|break;
comment|/* If the first character is \n, don't back up */
comment|/* This potentially does an extra linear walk over the first 		 * few chains.  Probably, that's not too expensive unless you 		 * have a really pathological setup. */
name|memcpy
argument_list|(
operator|&
name|it2
argument_list|,
operator|&
name|it
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_ptr_subtract
argument_list|(
name|buffer
argument_list|,
operator|&
name|it2
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|evbuffer_getchr
argument_list|(
operator|&
name|it2
argument_list|)
operator|==
literal|'\r'
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|it
argument_list|,
operator|&
name|it2
argument_list|,
sizeof|sizeof
argument_list|(
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|extra_drain
operator|=
literal|2
expr_stmt|;
block|}
break|break;
block|}
case|case
name|EVBUFFER_EOL_LF
case|:
if|if
condition|(
name|evbuffer_strchr
argument_list|(
operator|&
name|it
argument_list|,
literal|'\n'
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|extra_drain
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EVBUFFER_EOL_NUL
case|:
if|if
condition|(
name|evbuffer_strchr
argument_list|(
operator|&
name|it
argument_list|,
literal|'\0'
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|extra_drain
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|ok
operator|=
literal|1
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|PTR_NOT_FOUND
argument_list|(
operator|&
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_len_out
condition|)
operator|*
name|eol_len_out
operator|=
name|extra_drain
expr_stmt|;
return|return
name|it
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|evbuffer_readln
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|n_read_out
parameter_list|,
name|enum
name|evbuffer_eol_style
name|eol_style
parameter_list|)
block|{
name|struct
name|evbuffer_ptr
name|it
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|n_to_copy
init|=
literal|0
decl_stmt|,
name|extra_drain
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|freeze_start
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|it
operator|=
name|evbuffer_search_eol
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
operator|&
name|extra_drain
argument_list|,
name|eol_style
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|pos
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|n_to_copy
operator|=
name|it
operator|.
name|pos
expr_stmt|;
if|if
condition|(
operator|(
name|line
operator|=
name|mm_malloc
argument_list|(
name|n_to_copy
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|evbuffer_remove
argument_list|(
name|buffer
argument_list|,
name|line
argument_list|,
name|n_to_copy
argument_list|)
expr_stmt|;
name|line
index|[
name|n_to_copy
index|]
operator|=
literal|'\0'
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|buffer
argument_list|,
name|extra_drain
argument_list|)
expr_stmt|;
name|result
operator|=
name|line
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_read_out
condition|)
operator|*
name|n_read_out
operator|=
name|result
condition|?
name|n_to_copy
else|:
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EVBUFFER_CHAIN_MAX_AUTO_SIZE
value|4096
end_define

begin_comment
comment|/* Adds data to an event buffer */
end_comment

begin_function
name|int
name|evbuffer_add
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|data_in
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
name|data_in
decl_stmt|;
name|size_t
name|remain
decl_stmt|,
name|to_alloc
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|chain
operator|=
name|buf
operator|->
name|last
expr_stmt|;
comment|/* If there are no chains allocated for this buffer, allocate one 	 * big enough to hold all the data. */
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
goto|goto
name|done
goto|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_IMMUTABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|remain
operator|=
call|(
name|size_t
call|)
argument_list|(
name|chain
operator|->
name|buffer_len
operator|-
name|chain
operator|->
name|misalign
operator|-
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
operator|>=
name|datlen
condition|)
block|{
comment|/* there's enough space to hold all the data in the 			 * current last chain */
name|memcpy
argument_list|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
argument_list|,
name|data
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|chain
operator|->
name|off
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|datlen
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CHAIN_PINNED
argument_list|(
name|chain
argument_list|)
operator|&&
name|evbuffer_chain_should_realign
argument_list|(
name|chain
argument_list|,
name|datlen
argument_list|)
condition|)
block|{
comment|/* we can fit the data into the misalignment */
name|evbuffer_chain_align
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|off
argument_list|,
name|data
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|chain
operator|->
name|off
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|datlen
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* we cannot write any data to the last chain */
name|remain
operator|=
literal|0
expr_stmt|;
block|}
comment|/* we need to add another chain */
name|to_alloc
operator|=
name|chain
operator|->
name|buffer_len
expr_stmt|;
if|if
condition|(
name|to_alloc
operator|<=
name|EVBUFFER_CHAIN_MAX_AUTO_SIZE
operator|/
literal|2
condition|)
name|to_alloc
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|datlen
operator|>
name|to_alloc
condition|)
name|to_alloc
operator|=
name|datlen
expr_stmt|;
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|to_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|remain
condition|)
block|{
name|memcpy
argument_list|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
argument_list|,
name|data
argument_list|,
name|remain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|off
operator|+=
name|remain
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|remain
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|remain
expr_stmt|;
block|}
name|data
operator|+=
name|remain
expr_stmt|;
name|datlen
operator|-=
name|remain
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|,
name|data
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|datlen
expr_stmt|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|datlen
expr_stmt|;
name|out
label|:
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_prepend
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_start
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
goto|goto
name|done
goto|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* we cannot touch immutable buffers */
if|if
condition|(
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_IMMUTABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If this chain is empty, we can treat it as 		 * 'empty at the beginning' rather than 'empty at the end' */
if|if
condition|(
name|chain
operator|->
name|off
operator|==
literal|0
condition|)
name|chain
operator|->
name|misalign
operator|=
name|chain
operator|->
name|buffer_len
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
operator|>=
name|datlen
condition|)
block|{
comment|/* we have enough space to fit everything */
name|memcpy
argument_list|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|-
name|datlen
argument_list|,
name|data
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|chain
operator|->
name|off
operator|+=
name|datlen
expr_stmt|;
name|chain
operator|->
name|misalign
operator|-=
name|datlen
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|datlen
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|chain
operator|->
name|misalign
condition|)
block|{
comment|/* we can only fit some of the data. */
name|memcpy
argument_list|(
name|chain
operator|->
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|datlen
operator|-
name|chain
operator|->
name|misalign
argument_list|,
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
argument_list|)
expr_stmt|;
name|chain
operator|->
name|off
operator|+=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|datlen
operator|-=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|chain
operator|->
name|misalign
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* we need to add another chain */
if|if
condition|(
operator|(
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|buf
operator|->
name|first
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last_with_datap
operator|==
operator|&
name|buf
operator|->
name|first
condition|)
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|tmp
operator|->
name|off
operator|=
name|datlen
expr_stmt|;
name|tmp
operator|->
name|misalign
operator|=
name|tmp
operator|->
name|buffer_len
operator|-
name|datlen
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|buffer
operator|+
name|tmp
operator|->
name|misalign
argument_list|,
name|data
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|datlen
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
operator|(
name|size_t
operator|)
name|chain
operator|->
name|misalign
expr_stmt|;
name|out
label|:
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/** Helper: realigns the memory in chain->buffer so that misalign is 0. */
end_comment

begin_function
specifier|static
name|void
name|evbuffer_chain_align
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_IMMUTABLE
operator|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_MEM_PINNED_ANY
operator|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|chain
operator|->
name|buffer
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
name|chain
operator|->
name|misalign
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_TO_COPY_IN_EXPAND
value|4096
end_define

begin_define
define|#
directive|define
name|MAX_TO_REALIGN_IN_EXPAND
value|2048
end_define

begin_comment
comment|/** Helper: return true iff we should realign chain to fit datalen bytes of     data in it. */
end_comment

begin_function
specifier|static
name|int
name|evbuffer_chain_should_realign
parameter_list|(
name|struct
name|evbuffer_chain
modifier|*
name|chain
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
return|return
name|chain
operator|->
name|buffer_len
operator|-
name|chain
operator|->
name|off
operator|>=
name|datlen
operator|&&
operator|(
name|chain
operator|->
name|off
operator|<
name|chain
operator|->
name|buffer_len
operator|/
literal|2
operator|)
operator|&&
operator|(
name|chain
operator|->
name|off
operator|<=
name|MAX_TO_REALIGN_IN_EXPAND
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Expands the available space in the event buffer to at least datlen, all in  * a single chunk.  Return that chunk. */
end_comment

begin_function
specifier|static
name|struct
name|evbuffer_chain
modifier|*
name|evbuffer_expand_singlechain
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|chainp
operator|=
name|buf
operator|->
name|last_with_datap
expr_stmt|;
comment|/* XXX If *chainp is no longer writeable, but has enough space in its 	 * misalign, this might be a bad idea: we could still use *chainp, not 	 * (*chainp)->next. */
if|if
condition|(
operator|*
name|chainp
operator|&&
name|CHAIN_SPACE_LEN
argument_list|(
operator|*
name|chainp
argument_list|)
operator|==
literal|0
condition|)
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
expr_stmt|;
comment|/* 'chain' now points to the first chain with writable space (if any) 	 * We will either use it, realign it, replace it, or resize it. */
name|chain
operator|=
operator|*
name|chainp
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
operator|||
operator|(
name|chain
operator|->
name|flags
operator|&
operator|(
name|EVBUFFER_IMMUTABLE
operator||
name|EVBUFFER_MEM_PINNED_ANY
operator|)
operator|)
condition|)
block|{
comment|/* We can't use the last_with_data chain at all.  Just add a 		 * new one that's big enough. */
goto|goto
name|insert_new
goto|;
block|}
comment|/* If we can fit all the data, then we don't have to do anything */
if|if
condition|(
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
operator|>=
name|datlen
condition|)
block|{
name|result
operator|=
name|chain
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
comment|/* If the chain is completely empty, just replace it by adding a new 	 * empty chain. */
if|if
condition|(
name|chain
operator|->
name|off
operator|==
literal|0
condition|)
block|{
goto|goto
name|insert_new
goto|;
block|}
comment|/* If the misalignment plus the remaining space fulfills our data 	 * needs, we could just force an alignment to happen.  Afterwards, we 	 * have enough space.  But only do this if we're saving a lot of space 	 * and not moving too much data.  Otherwise the space savings are 	 * probably offset by the time lost in copying. 	 */
if|if
condition|(
name|evbuffer_chain_should_realign
argument_list|(
name|chain
argument_list|,
name|datlen
argument_list|)
condition|)
block|{
name|evbuffer_chain_align
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|chain
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
comment|/* At this point, we can either resize the last chunk with space in 	 * it, use the next chunk after it, or   If we add a new chunk, we waste 	 * CHAIN_SPACE_LEN(chain) bytes in the former last chunk.  If we 	 * resize, we have to copy chain->off bytes. 	 */
comment|/* Would expanding this chunk be affordable and worthwhile? */
if|if
condition|(
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
operator|<
name|chain
operator|->
name|buffer_len
operator|/
literal|8
operator|||
name|chain
operator|->
name|off
operator|>
name|MAX_TO_COPY_IN_EXPAND
condition|)
block|{
comment|/* It's not worth resizing this chain. Can the next one be 		 * used? */
if|if
condition|(
name|chain
operator|->
name|next
operator|&&
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
operator|->
name|next
argument_list|)
operator|>=
name|datlen
condition|)
block|{
comment|/* Yes, we can just use the next chain (which should 			 * be empty. */
name|result
operator|=
name|chain
operator|->
name|next
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
else|else
block|{
comment|/* No; append a new chain (which will free all 			 * terminal empty chains.) */
goto|goto
name|insert_new
goto|;
block|}
block|}
else|else
block|{
comment|/* Okay, we're going to try to resize this chain: Not doing so 		 * would waste at least 1/8 of its current allocation, and we 		 * can do so without having to copy more than 		 * MAX_TO_COPY_IN_EXPAND bytes. */
comment|/* figure out how much space we need */
name|size_t
name|length
init|=
name|chain
operator|->
name|off
operator|+
name|datlen
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|tmp
init|=
name|evbuffer_chain_new
argument_list|(
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* copy the data over that we had so far */
name|tmp
operator|->
name|off
operator|=
name|chain
operator|->
name|off
expr_stmt|;
name|memcpy
argument_list|(
name|tmp
operator|->
name|buffer
argument_list|,
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
comment|/* fix up the list */
name|EVUTIL_ASSERT
argument_list|(
operator|*
name|chainp
operator|==
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
operator|*
name|chainp
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last
operator|==
name|chain
condition|)
name|buf
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
goto|goto
name|ok
goto|;
block|}
name|insert_new
label|:
name|result
operator|=
name|evbuffer_chain_insert_new
argument_list|(
name|buf
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
goto|goto
name|err
goto|;
name|ok
label|:
name|EVUTIL_ASSERT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|CHAIN_SPACE_LEN
argument_list|(
name|result
argument_list|)
operator|>=
name|datlen
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Make sure that datlen bytes are available for writing in the last n  * chains.  Never copies or moves data. */
end_comment

begin_function
name|int
name|evbuffer_expand_fast_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|datlen
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|buf
operator|->
name|last
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|size_t
name|avail
decl_stmt|;
name|int
name|used
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|n
operator|>=
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
operator|||
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_IMMUTABLE
operator|)
condition|)
block|{
comment|/* There is no last chunk, or we can't touch the last chunk. 		 * Just add a new chunk. */
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|used
operator|=
literal|0
expr_stmt|;
comment|/* number of chains we're using space in. */
name|avail
operator|=
literal|0
expr_stmt|;
comment|/* how much space they have. */
comment|/* How many bytes can we stick at the end of buffer as it is?  Iterate 	 * over the chains at the end of the buffer, tring to see how much 	 * space we have in the first n. */
for|for
control|(
name|chain
operator|=
operator|*
name|buf
operator|->
name|last_with_datap
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
if|if
condition|(
name|chain
operator|->
name|off
condition|)
block|{
name|size_t
name|space
init|=
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|==
operator|*
name|buf
operator|->
name|last_with_datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|avail
operator|+=
name|space
expr_stmt|;
operator|++
name|used
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No data in chain; realign it. */
name|chain
operator|->
name|misalign
operator|=
literal|0
expr_stmt|;
name|avail
operator|+=
name|chain
operator|->
name|buffer_len
expr_stmt|;
operator|++
name|used
expr_stmt|;
block|}
if|if
condition|(
name|avail
operator|>=
name|datlen
condition|)
block|{
comment|/* There is already enough space.  Just return */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|used
operator|==
name|n
condition|)
break|break;
block|}
comment|/* There wasn't enough space in the first n chains with space in 	 * them. Either add a new chain with enough space, or replace all 	 * empty chains with one that has enough space, depending on n. */
if|if
condition|(
name|used
operator|<
name|n
condition|)
block|{
comment|/* The loop ran off the end of the chains before it hit n 		 * chains; we can add another. */
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
operator|-
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
comment|/* (we would only set last_with_data if we added the first 		 * chain. But if the buffer had no chains, we would have 		 * just allocated a new chain earlier) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Nuke _all_ the empty chains. */
name|int
name|rmv_all
init|=
literal|0
decl_stmt|;
comment|/* True iff we removed last_with_data. */
name|chain
operator|=
operator|*
name|buf
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
operator|!
name|chain
operator|->
name|off
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|==
name|buf
operator|->
name|first
argument_list|)
expr_stmt|;
name|rmv_all
operator|=
literal|1
expr_stmt|;
name|avail
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|avail
operator|=
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|chain
operator|->
name|off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_chain_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|evbuffer_chain_new
argument_list|(
name|datlen
operator|-
name|avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rmv_all
condition|)
block|{
name|ZERO_CHAIN
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|last
operator|=
operator|*
name|buf
operator|->
name|last_with_datap
expr_stmt|;
operator|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rmv_all
condition|)
block|{
name|buf
operator|->
name|first
operator|=
name|buf
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
name|buf
operator|->
name|last_with_datap
operator|=
operator|&
name|buf
operator|->
name|first
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|buf
operator|->
name|last_with_datap
operator|)
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|evbuffer_expand
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|datlen
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|chain
operator|=
name|evbuffer_expand_singlechain
argument_list|(
name|buf
argument_list|,
name|datlen
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|chain
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reads data from a file descriptor into a buffer.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_SYS_UIO_H
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_IOVEC_IMPL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_UIO_H
end_ifdef

begin_comment
comment|/* number of iovec we use for writev, fragmentation is going to determine  * how much we end up writing */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_WRITE_IOVEC
value|128
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UIO_MAXIOV
argument_list|)
operator|&&
name|UIO_MAXIOV
operator|<
name|DEFAULT_WRITE_IOVEC
end_if

begin_define
define|#
directive|define
name|NUM_WRITE_IOVEC
value|UIO_MAXIOV
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|IOV_MAX
argument_list|)
operator|&&
name|IOV_MAX
operator|<
name|DEFAULT_WRITE_IOVEC
end_elif

begin_define
define|#
directive|define
name|NUM_WRITE_IOVEC
value|IOV_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_WRITE_IOVEC
value|DEFAULT_WRITE_IOVEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IOV_TYPE
value|struct iovec
end_define

begin_define
define|#
directive|define
name|IOV_PTR_FIELD
value|iov_base
end_define

begin_define
define|#
directive|define
name|IOV_LEN_FIELD
value|iov_len
end_define

begin_define
define|#
directive|define
name|IOV_LEN_TYPE
value|size_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUM_WRITE_IOVEC
value|16
end_define

begin_define
define|#
directive|define
name|IOV_TYPE
value|WSABUF
end_define

begin_define
define|#
directive|define
name|IOV_PTR_FIELD
value|buf
end_define

begin_define
define|#
directive|define
name|IOV_LEN_FIELD
value|len
end_define

begin_define
define|#
directive|define
name|IOV_LEN_TYPE
value|unsigned long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_READ_IOVEC
value|4
end_define

begin_define
define|#
directive|define
name|EVBUFFER_MAX_READ
value|4096
end_define

begin_comment
comment|/** Helper function to figure out which space to use for reading data into     an evbuffer.  Internal use only.      @param buf The buffer to read into     @param howmuch How much we want to read.     @param vecs An array of two or more iovecs or WSABUFs.     @param n_vecs_avail The length of vecs     @param chainp A pointer to a variable to hold the first chain we're       reading into.     @param exact Boolean: if true, we do not provide more than 'howmuch'       space in the vectors, even if more space is available.     @return The number of buffers we're using.  */
end_comment

begin_function
name|int
name|evbuffer_read_setup_vecs_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_ssize_t
name|howmuch
parameter_list|,
name|struct
name|evbuffer_iovec
modifier|*
name|vecs
parameter_list|,
name|int
name|n_vecs_avail
parameter_list|,
name|struct
name|evbuffer_chain
modifier|*
modifier|*
modifier|*
name|chainp
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|firstchainp
decl_stmt|;
name|size_t
name|so_far
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|howmuch
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|so_far
operator|=
literal|0
expr_stmt|;
comment|/* Let firstchain be the first chain with any space on it */
name|firstchainp
operator|=
name|buf
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
name|CHAIN_SPACE_LEN
argument_list|(
operator|*
name|firstchainp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|firstchainp
operator|=
operator|&
operator|(
operator|*
name|firstchainp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|chain
operator|=
operator|*
name|firstchainp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vecs_avail
operator|&&
name|so_far
operator|<
operator|(
name|size_t
operator|)
name|howmuch
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|avail
init|=
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
decl_stmt|;
if|if
condition|(
name|avail
operator|>
operator|(
name|howmuch
operator|-
name|so_far
operator|)
operator|&&
name|exact
condition|)
name|avail
operator|=
name|howmuch
operator|-
name|so_far
expr_stmt|;
name|vecs
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|CHAIN_SPACE_PTR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|vecs
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|avail
expr_stmt|;
name|so_far
operator|+=
name|avail
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|chainp
operator|=
name|firstchainp
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_n_bytes_readable_on_socket
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WIN32
argument_list|)
name|unsigned
name|long
name|lng
init|=
name|EVBUFFER_MAX_READ
decl_stmt|;
if|if
condition|(
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|lng
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|int
operator|)
name|lng
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|FIONREAD
argument_list|)
name|int
name|n
init|=
name|EVBUFFER_MAX_READ
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|n
return|;
else|#
directive|else
return|return
name|EVBUFFER_MAX_READ
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* TODO(niels): should this function return ev_ssize_t and take ev_ssize_t  * as howmuch? */
end_comment

begin_function
name|int
name|evbuffer_read
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|int
name|howmuch
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
name|int
name|nvecs
decl_stmt|,
name|i
decl_stmt|,
name|remaining
decl_stmt|;
else|#
directive|else
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|n
operator|=
name|get_n_bytes_readable_on_socket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>
name|EVBUFFER_MAX_READ
condition|)
name|n
operator|=
name|EVBUFFER_MAX_READ
expr_stmt|;
if|if
condition|(
name|howmuch
operator|<
literal|0
operator|||
name|howmuch
operator|>
name|n
condition|)
name|howmuch
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
comment|/* Since we can use iovecs, we're willing to use the last 	 * NUM_READ_IOVEC chains. */
if|if
condition|(
name|evbuffer_expand_fast_
argument_list|(
name|buf
argument_list|,
name|howmuch
argument_list|,
name|NUM_READ_IOVEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|IOV_TYPE
name|vecs
index|[
name|NUM_READ_IOVEC
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|EVBUFFER_IOVEC_IS_NATIVE_
name|nvecs
operator|=
name|evbuffer_read_setup_vecs_
argument_list|(
name|buf
argument_list|,
name|howmuch
argument_list|,
name|vecs
argument_list|,
name|NUM_READ_IOVEC
argument_list|,
operator|&
name|chainp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* We aren't using the native struct iovec.  Therefore, 		   we are on win32. */
name|struct
name|evbuffer_iovec
name|ev_vecs
index|[
name|NUM_READ_IOVEC
index|]
decl_stmt|;
name|nvecs
operator|=
name|evbuffer_read_setup_vecs_
argument_list|(
name|buf
argument_list|,
name|howmuch
argument_list|,
name|ev_vecs
argument_list|,
literal|2
argument_list|,
operator|&
name|chainp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
operator|++
name|i
control|)
name|WSABUF_FROM_EVBUFFER_IOV
argument_list|(
operator|&
name|vecs
index|[
name|i
index|]
argument_list|,
operator|&
name|ev_vecs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
block|{
name|DWORD
name|bytesRead
decl_stmt|;
name|DWORD
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|WSARecv
argument_list|(
name|fd
argument_list|,
name|vecs
argument_list|,
name|nvecs
argument_list|,
operator|&
name|bytesRead
argument_list|,
operator|&
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* The read failed. It might be a close, 				 * or it might be an error. */
if|if
condition|(
name|WSAGetLastError
argument_list|()
operator|==
name|WSAECONNABORTED
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|n
operator|=
name|bytesRead
expr_stmt|;
block|}
else|#
directive|else
name|n
operator|=
name|readv
argument_list|(
name|fd
argument_list|,
name|vecs
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/*!USE_IOVEC_IMPL*/
comment|/* If we don't have FIONREAD, we might waste some space here */
comment|/* XXX we _will_ waste some space here if there is any space left 	 * over on buf->last. */
if|if
condition|(
operator|(
name|chain
operator|=
name|evbuffer_expand_singlechain
argument_list|(
name|buf
argument_list|,
name|howmuch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* We can append new data at this point */
name|p
operator|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|chain
operator|->
name|off
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|howmuch
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|howmuch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_IOVEC_IMPL */
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
name|remaining
operator|=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
operator|++
name|i
control|)
block|{
name|ev_ssize_t
name|space
init|=
operator|(
name|ev_ssize_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
operator|*
name|chainp
argument_list|)
decl_stmt|;
if|if
condition|(
name|space
operator|<
name|remaining
condition|)
block|{
operator|(
operator|*
name|chainp
operator|)
operator|->
name|off
operator|+=
name|space
expr_stmt|;
name|remaining
operator|-=
operator|(
name|int
operator|)
name|space
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|chainp
operator|)
operator|->
name|off
operator|+=
name|remaining
expr_stmt|;
name|buf
operator|->
name|last_with_datap
operator|=
name|chainp
expr_stmt|;
break|break;
block|}
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
expr_stmt|;
block|}
else|#
directive|else
name|chain
operator|->
name|off
operator|+=
name|n
expr_stmt|;
name|advance_last_with_data
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
operator|->
name|total_len
operator|+=
name|n
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|n
expr_stmt|;
comment|/* Tell someone about changes in this buffer */
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
name|n
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
end_ifdef

begin_function
specifier|static
specifier|inline
name|int
name|evbuffer_write_iovec
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|ev_ssize_t
name|howmuch
parameter_list|)
block|{
name|IOV_TYPE
name|iov
index|[
name|NUM_WRITE_IOVEC
index|]
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|buffer
operator|->
name|first
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|howmuch
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* XXX make this top out at some maximal data length?  if the 	 * buffer has (say) 1MB in it, split over 128 chains, there's 	 * no way it all gets written in one go. */
while|while
condition|(
name|chain
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|NUM_WRITE_IOVEC
operator|&&
name|howmuch
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_SENDFILE
comment|/* we cannot write the file info via writev */
if|if
condition|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_SENDFILE
condition|)
break|break;
endif|#
directive|endif
name|iov
index|[
name|i
index|]
operator|.
name|IOV_PTR_FIELD
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|howmuch
operator|>=
name|chain
operator|->
name|off
condition|)
block|{
comment|/* XXXcould be problematic when windows supports mmap*/
name|iov
index|[
name|i
operator|++
index|]
operator|.
name|IOV_LEN_FIELD
operator|=
operator|(
name|IOV_LEN_TYPE
operator|)
name|chain
operator|->
name|off
expr_stmt|;
name|howmuch
operator|-=
name|chain
operator|->
name|off
expr_stmt|;
block|}
else|else
block|{
comment|/* XXXcould be problematic when windows supports mmap*/
name|iov
index|[
name|i
operator|++
index|]
operator|.
name|IOV_LEN_FIELD
operator|=
operator|(
name|IOV_LEN_TYPE
operator|)
name|howmuch
expr_stmt|;
break|break;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|_WIN32
block|{
name|DWORD
name|bytesSent
decl_stmt|;
if|if
condition|(
name|WSASend
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
name|i
argument_list|,
operator|&
name|bytesSent
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|bytesSent
expr_stmt|;
block|}
else|#
directive|else
name|n
operator|=
name|writev
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SENDFILE
end_ifdef

begin_function
specifier|static
specifier|inline
name|int
name|evbuffer_write_sendfile
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evutil_socket_t
name|dest_fd
parameter_list|,
name|ev_ssize_t
name|howmuch
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|buffer
operator|->
name|first
decl_stmt|;
name|struct
name|evbuffer_chain_file_segment
modifier|*
name|info
init|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_chain_file_segment
argument_list|,
name|chain
argument_list|)
decl_stmt|;
specifier|const
name|int
name|source_fd
init|=
name|info
operator|->
name|segment
operator|->
name|fd
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SENDFILE_IS_MACOSX
argument_list|)
operator|||
name|defined
argument_list|(
name|SENDFILE_IS_FREEBSD
argument_list|)
name|int
name|res
decl_stmt|;
name|ev_off_t
name|len
init|=
name|chain
operator|->
name|off
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|SENDFILE_IS_LINUX
argument_list|)
operator|||
name|defined
argument_list|(
name|SENDFILE_IS_SOLARIS
argument_list|)
name|ev_ssize_t
name|res
decl_stmt|;
name|ev_off_t
name|offset
init|=
name|chain
operator|->
name|misalign
decl_stmt|;
endif|#
directive|endif
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SENDFILE_IS_MACOSX
argument_list|)
name|res
operator|=
name|sendfile
argument_list|(
name|source_fd
argument_list|,
name|dest_fd
argument_list|,
name|chain
operator|->
name|misalign
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
operator|&&
operator|!
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|errno
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|len
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|SENDFILE_IS_FREEBSD
argument_list|)
name|res
operator|=
name|sendfile
argument_list|(
name|source_fd
argument_list|,
name|dest_fd
argument_list|,
name|chain
operator|->
name|misalign
argument_list|,
name|chain
operator|->
name|off
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
operator|&&
operator|!
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|errno
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|len
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|SENDFILE_IS_LINUX
argument_list|)
comment|/* TODO(niels): implement splice */
name|res
operator|=
name|sendfile
argument_list|(
name|dest_fd
argument_list|,
name|source_fd
argument_list|,
operator|&
name|offset
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
operator|&&
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* if this is EAGAIN or EINTR return 0; otherwise, -1 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|SENDFILE_IS_SOLARIS
argument_list|)
block|{
specifier|const
name|off_t
name|offset_orig
init|=
name|offset
decl_stmt|;
name|res
operator|=
name|sendfile
argument_list|(
name|dest_fd
argument_list|,
name|source_fd
argument_list|,
operator|&
name|offset
argument_list|,
name|chain
operator|->
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
operator|&&
name|EVUTIL_ERR_RW_RETRIABLE
argument_list|(
name|errno
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
operator|-
name|offset_orig
condition|)
return|return
name|offset
operator|-
name|offset_orig
return|;
comment|/* if this is EAGAIN or EINTR and no bytes were 			 * written, return 0 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|evbuffer_write_atmost
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|ev_ssize_t
name|howmuch
parameter_list|)
block|{
name|int
name|n
init|=
operator|-
literal|1
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|freeze_start
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|howmuch
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|howmuch
operator|>
name|buffer
operator|->
name|total_len
condition|)
name|howmuch
operator|=
name|buffer
operator|->
name|total_len
expr_stmt|;
if|if
condition|(
name|howmuch
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_SENDFILE
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|buffer
operator|->
name|first
decl_stmt|;
if|if
condition|(
name|chain
operator|!=
name|NULL
operator|&&
operator|(
name|chain
operator|->
name|flags
operator|&
name|EVBUFFER_SENDFILE
operator|)
condition|)
name|n
operator|=
name|evbuffer_write_sendfile
argument_list|(
name|buffer
argument_list|,
name|fd
argument_list|,
name|howmuch
argument_list|)
expr_stmt|;
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_IOVEC_IMPL
name|n
operator|=
name|evbuffer_write_iovec
argument_list|(
name|buffer
argument_list|,
name|fd
argument_list|,
name|howmuch
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* XXX(nickm) Don't disable this code until we know if 		 * the WSARecv code above works. */
name|void
modifier|*
name|p
init|=
name|evbuffer_pullup
argument_list|(
name|buffer
argument_list|,
name|howmuch
argument_list|)
decl_stmt|;
name|n
operator|=
name|send
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|howmuch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|void
modifier|*
name|p
init|=
name|evbuffer_pullup
argument_list|(
name|buffer
argument_list|,
name|howmuch
argument_list|)
decl_stmt|;
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|howmuch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SENDFILE
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|evbuffer_drain
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_write
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
return|return
name|evbuffer_write_atmost
argument_list|(
name|buffer
argument_list|,
name|fd
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|char
modifier|*
name|evbuffer_find
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|what
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|search
decl_stmt|;
name|struct
name|evbuffer_ptr
name|ptr
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|evbuffer_search
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|what
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|.
name|pos
operator|<
literal|0
condition|)
block|{
name|search
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|search
operator|=
name|evbuffer_pullup
argument_list|(
name|buffer
argument_list|,
name|ptr
operator|.
name|pos
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
condition|)
name|search
operator|+=
name|ptr
operator|.
name|pos
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Subract<b>howfar</b> from the position of<b>pos</b> within  *<b>buf</b>. Returns 0 on success, -1 on failure.  *  * This isn't exposed yet, because of potential inefficiency issues.  * Maybe it should be. */
end_comment

begin_function
specifier|static
name|int
name|evbuffer_ptr_subtract
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
name|size_t
name|howfar
parameter_list|)
block|{
if|if
condition|(
name|howfar
operator|>
operator|(
name|size_t
operator|)
name|pos
operator|->
name|pos
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pos
operator|->
name|internal_
operator|.
name|chain
operator|&&
name|howfar
operator|<=
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
condition|)
block|{
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|-=
name|howfar
expr_stmt|;
name|pos
operator|->
name|pos
operator|-=
name|howfar
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|const
name|size_t
name|newpos
init|=
name|pos
operator|->
name|pos
operator|-
name|howfar
decl_stmt|;
comment|/* Here's the inefficient part: it walks over the 		 * chains until we hit newpos. */
return|return
name|evbuffer_ptr_set
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|newpos
argument_list|,
name|EVBUFFER_PTR_SET
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|evbuffer_ptr_set
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
name|size_t
name|position
parameter_list|,
name|enum
name|evbuffer_ptr_how
name|how
parameter_list|)
block|{
name|size_t
name|left
init|=
name|position
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|NULL
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|EVBUFFER_PTR_SET
case|:
name|chain
operator|=
name|buf
operator|->
name|first
expr_stmt|;
name|pos
operator|->
name|pos
operator|=
name|position
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EVBUFFER_PTR_ADD
case|:
comment|/* this avoids iterating over all previous chains if 		   we just want to advance the position */
name|chain
operator|=
name|pos
operator|->
name|internal_
operator|.
name|chain
expr_stmt|;
name|pos
operator|->
name|pos
operator|+=
name|position
expr_stmt|;
name|position
operator|=
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|chain
operator|&&
name|position
operator|+
name|left
operator|>=
name|chain
operator|->
name|off
condition|)
block|{
name|left
operator|-=
name|chain
operator|->
name|off
operator|-
name|position
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chain
condition|)
block|{
name|pos
operator|->
name|internal_
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
name|position
operator|+
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
comment|/* The first byte in the (nonexistent) chain after the last chain */
name|pos
operator|->
name|internal_
operator|.
name|chain
operator|=
name|NULL
expr_stmt|;
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|PTR_NOT_FOUND
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**    Compare the bytes in buf at position pos to the len bytes in mem.  Return    less than 0, 0, or greater than 0 as memcmp.  */
end_comment

begin_function
specifier|static
name|int
name|evbuffer_ptr_memcmp
parameter_list|(
specifier|const
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|pos
parameter_list|,
specifier|const
name|char
modifier|*
name|mem
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|size_t
name|position
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ASSERT_EVBUFFER_LOCKED
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|pos
operator|+
name|len
operator|>
name|buf
operator|->
name|total_len
condition|)
return|return
operator|-
literal|1
return|;
name|chain
operator|=
name|pos
operator|->
name|internal_
operator|.
name|chain
expr_stmt|;
name|position
operator|=
name|pos
operator|->
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|chain
condition|)
block|{
name|size_t
name|n_comparable
decl_stmt|;
if|if
condition|(
name|len
operator|+
name|position
operator|>
name|chain
operator|->
name|off
condition|)
name|n_comparable
operator|=
name|chain
operator|->
name|off
operator|-
name|position
expr_stmt|;
else|else
name|n_comparable
operator|=
name|len
expr_stmt|;
name|r
operator|=
name|memcmp
argument_list|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|position
argument_list|,
name|mem
argument_list|,
name|n_comparable
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|mem
operator|+=
name|n_comparable
expr_stmt|;
name|len
operator|-=
name|n_comparable
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|evbuffer_ptr
name|evbuffer_search
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|start
parameter_list|)
block|{
return|return
name|evbuffer_search_range
argument_list|(
name|buffer
argument_list|,
name|what
argument_list|,
name|len
argument_list|,
name|start
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|evbuffer_ptr
name|evbuffer_search_range
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|start
parameter_list|,
specifier|const
name|struct
name|evbuffer_ptr
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|evbuffer_ptr
name|pos
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|last_chain
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|first
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pos
argument_list|,
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|pos
operator|.
name|internal_
operator|.
name|chain
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|pos
operator|.
name|internal_
operator|.
name|chain
operator|=
name|buffer
operator|->
name|first
expr_stmt|;
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
name|last_chain
operator|=
name|end
operator|->
name|internal_
operator|.
name|chain
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
name|len
operator|>
name|EV_SSIZE_MAX
condition|)
goto|goto
name|done
goto|;
name|first
operator|=
name|what
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|start_at
init|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
decl_stmt|;
name|p
operator|=
name|memchr
argument_list|(
name|start_at
argument_list|,
name|first
argument_list|,
name|chain
operator|->
name|off
operator|-
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pos
operator|.
name|pos
operator|+=
name|p
operator|-
name|start_at
expr_stmt|;
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|+=
name|p
operator|-
name|start_at
expr_stmt|;
if|if
condition|(
operator|!
name|evbuffer_ptr_memcmp
argument_list|(
name|buffer
argument_list|,
operator|&
name|pos
argument_list|,
name|what
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|end
operator|&&
name|pos
operator|.
name|pos
operator|+
operator|(
name|ev_ssize_t
operator|)
name|len
operator|>
name|end
operator|->
name|pos
condition|)
goto|goto
name|not_found
goto|;
else|else
goto|goto
name|done
goto|;
block|}
operator|++
name|pos
operator|.
name|pos
expr_stmt|;
operator|++
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
if|if
condition|(
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|==
name|chain
operator|->
name|off
condition|)
block|{
name|chain
operator|=
name|pos
operator|.
name|internal_
operator|.
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chain
operator|==
name|last_chain
condition|)
goto|goto
name|not_found
goto|;
name|pos
operator|.
name|pos
operator|+=
name|chain
operator|->
name|off
operator|-
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
name|chain
operator|=
name|pos
operator|.
name|internal_
operator|.
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|pos
operator|.
name|internal_
operator|.
name|pos_in_chain
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|not_found
label|:
name|PTR_NOT_FOUND
argument_list|(
operator|&
name|pos
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_peek
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|ev_ssize_t
name|len
parameter_list|,
name|struct
name|evbuffer_ptr
modifier|*
name|start_at
parameter_list|,
name|struct
name|evbuffer_iovec
modifier|*
name|vec
parameter_list|,
name|int
name|n_vec
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|ev_ssize_t
name|len_so_far
init|=
literal|0
decl_stmt|;
comment|/* Avoid locking in trivial edge cases */
if|if
condition|(
name|start_at
operator|&&
name|start_at
operator|->
name|internal_
operator|.
name|chain
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_at
condition|)
block|{
name|chain
operator|=
name|start_at
operator|->
name|internal_
operator|.
name|chain
expr_stmt|;
name|len_so_far
operator|=
name|chain
operator|->
name|off
operator|-
name|start_at
operator|->
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
name|idx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_vec
operator|>
literal|0
condition|)
block|{
name|vec
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|+
name|start_at
operator|->
name|internal_
operator|.
name|pos_in_chain
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|len_so_far
expr_stmt|;
block|}
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|chain
operator|=
name|buffer
operator|->
name|first
expr_stmt|;
block|}
if|if
condition|(
name|n_vec
operator|==
literal|0
operator|&&
name|len
operator|<
literal|0
condition|)
block|{
comment|/* If no vectors are provided and they asked for "everything", 		 * pretend they asked for the actual available amount. */
name|len
operator|=
name|buffer
operator|->
name|total_len
operator|-
name|len_so_far
expr_stmt|;
block|}
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|len
operator|>=
literal|0
operator|&&
name|len_so_far
operator|>=
name|len
condition|)
break|break;
if|if
condition|(
name|idx
operator|<
name|n_vec
condition|)
block|{
name|vec
index|[
name|idx
index|]
operator|.
name|iov_base
operator|=
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
expr_stmt|;
name|vec
index|[
name|idx
index|]
operator|.
name|iov_len
operator|=
name|chain
operator|->
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
break|break;
block|}
operator|++
name|idx
expr_stmt|;
name|len_so_far
operator|+=
name|chain
operator|->
name|off
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_vprintf
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|va_list
name|aq
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* make sure that at least some space is available */
if|if
condition|(
operator|(
name|chain
operator|=
name|evbuffer_expand_singlechain
argument_list|(
name|buf
argument_list|,
literal|64
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|#
directive|if
literal|0
block|size_t used = chain->misalign + chain->off; 		buffer = (char *)chain->buffer + chain->misalign + chain->off; 		EVUTIL_ASSERT(chain->buffer_len>= used); 		space = chain->buffer_len - used;
endif|#
directive|endif
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|CHAIN_SPACE_PTR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|space
operator|=
operator|(
name|size_t
operator|)
name|CHAIN_SPACE_LEN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|va_copy
define|#
directive|define
name|va_copy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
value|memcpy(&(dst),&(src), sizeof(va_list))
endif|#
directive|endif
name|va_copy
argument_list|(
name|aq
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|sz
operator|=
name|evutil_vsnprintf
argument_list|(
name|buffer
argument_list|,
name|space
argument_list|,
name|fmt
argument_list|,
name|aq
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|aq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|sz
operator|<
name|space
condition|)
block|{
name|chain
operator|->
name|off
operator|+=
name|sz
expr_stmt|;
name|buf
operator|->
name|total_len
operator|+=
name|sz
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|sz
expr_stmt|;
name|advance_last_with_data
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
name|sz
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|chain
operator|=
name|evbuffer_expand_singlechain
argument_list|(
name|buf
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* NOTREACHED */
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_printf
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|res
operator|=
name|evbuffer_add_vprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_reference
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|outbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|datlen
parameter_list|,
name|evbuffer_ref_cleanup_cb
name|cleanupfn
parameter_list|,
name|void
modifier|*
name|extra
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|evbuffer_chain_reference
modifier|*
name|info
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_chain_reference
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|chain
operator|->
name|flags
operator||=
name|EVBUFFER_REFERENCE
operator||
name|EVBUFFER_IMMUTABLE
expr_stmt|;
name|chain
operator|->
name|buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|datlen
expr_stmt|;
name|chain
operator|->
name|off
operator|=
name|datlen
expr_stmt|;
name|info
operator|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_chain_reference
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|info
operator|->
name|cleanupfn
operator|=
name|cleanupfn
expr_stmt|;
name|info
operator|->
name|extra
operator|=
name|extra
expr_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|->
name|freeze_end
condition|)
block|{
comment|/* don't call chain_free; we do not want to actually invoke 		 * the cleanup function */
name|mm_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|evbuffer_chain_insert
argument_list|(
name|outbuf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|outbuf
operator|->
name|n_add_for_cb
operator|+=
name|datlen
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* TODO(niels): we may want to add to automagically convert to mmap, in  * case evbuffer_remove() or evbuffer_pullup() are being used.  */
end_comment

begin_function
name|struct
name|evbuffer_file_segment
modifier|*
name|evbuffer_file_segment_new
parameter_list|(
name|int
name|fd
parameter_list|,
name|ev_off_t
name|offset
parameter_list|,
name|ev_off_t
name|length
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
init|=
name|mm_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_file_segment
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
return|return
name|NULL
return|;
name|seg
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|seg
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|seg
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|seg
operator|->
name|file_offset
operator|=
name|offset
expr_stmt|;
name|seg
operator|->
name|cleanup_cb
operator|=
name|NULL
expr_stmt|;
name|seg
operator|->
name|cleanup_cb_arg
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
ifndef|#
directive|ifndef
name|lseek
define|#
directive|define
name|lseek
value|_lseeki64
endif|#
directive|endif
ifndef|#
directive|ifndef
name|fstat
define|#
directive|define
name|fstat
value|_fstat
endif|#
directive|endif
ifndef|#
directive|ifndef
name|stat
define|#
directive|define
name|stat
value|_stat
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|length
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
name|seg
operator|->
name|length
operator|=
name|length
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SENDFILE
argument_list|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EVBUF_FS_DISABLE_SENDFILE
operator|)
condition|)
block|{
name|seg
operator|->
name|can_sendfile
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|evbuffer_file_segment_materialize
argument_list|(
name|seg
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SENDFILE
argument_list|)
name|done
label|:
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EVBUF_FS_DISABLE_LOCKING
operator|)
condition|)
block|{
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|seg
return|;
name|err
label|:
name|mm_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_MMAP
end_ifdef

begin_function
specifier|static
name|long
name|get_page_size
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SC_PAGE_SIZE
return|return
name|sysconf
argument_list|(
name|SC_PAGE_SIZE
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
return|return
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DOCDOC */
end_comment

begin_comment
comment|/* Requires lock */
end_comment

begin_function
specifier|static
name|int
name|evbuffer_file_segment_materialize
parameter_list|(
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
parameter_list|)
block|{
specifier|const
name|unsigned
name|flags
init|=
name|seg
operator|->
name|flags
decl_stmt|;
specifier|const
name|int
name|fd
init|=
name|seg
operator|->
name|fd
decl_stmt|;
specifier|const
name|ev_off_t
name|length
init|=
name|seg
operator|->
name|length
decl_stmt|;
specifier|const
name|ev_off_t
name|offset
init|=
name|seg
operator|->
name|file_offset
decl_stmt|;
if|if
condition|(
name|seg
operator|->
name|contents
condition|)
return|return
literal|0
return|;
comment|/* already materialized */
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_MMAP
argument_list|)
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EVBUF_FS_DISABLE_MMAP
operator|)
condition|)
block|{
name|off_t
name|offset_rounded
init|=
literal|0
decl_stmt|,
name|offset_leftover
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|mapped
decl_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
comment|/* mmap implementations don't generally like us 			 * to have an offset that isn't a round  */
name|long
name|page_size
init|=
name|get_page_size
argument_list|()
decl_stmt|;
if|if
condition|(
name|page_size
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|offset_leftover
operator|=
name|offset
operator|%
name|page_size
expr_stmt|;
name|offset_rounded
operator|=
name|offset
operator|-
name|offset_leftover
expr_stmt|;
block|}
name|mapped
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|length
operator|+
name|offset_leftover
argument_list|,
name|PROT_READ
argument_list|,
ifdef|#
directive|ifdef
name|MAP_NOCACHE
name|MAP_NOCACHE
operator||
comment|/* ??? */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAP_FILE
name|MAP_FILE
operator||
endif|#
directive|endif
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
name|offset_rounded
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped
operator|==
name|MAP_FAILED
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: mmap(%d, %d, %zu) failed"
argument_list|,
name|__func__
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|offset
operator|+
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|seg
operator|->
name|mapping
operator|=
name|mapped
expr_stmt|;
name|seg
operator|->
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|mapped
operator|+
name|offset_leftover
expr_stmt|;
name|seg
operator|->
name|mmap_offset
operator|=
literal|0
expr_stmt|;
name|seg
operator|->
name|is_mapping
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|EVBUF_FS_DISABLE_MMAP
operator|)
condition|)
block|{
name|intptr_t
name|h
init|=
name|_get_osfhandle
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|HANDLE
name|m
decl_stmt|;
name|ev_uint64_t
name|total_size
init|=
name|length
operator|+
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|HANDLE
operator|)
name|h
operator|==
name|INVALID_HANDLE_VALUE
condition|)
goto|goto
name|err
goto|;
name|m
operator|=
name|CreateFileMapping
argument_list|(
operator|(
name|HANDLE
operator|)
name|h
argument_list|,
name|NULL
argument_list|,
name|PAGE_READONLY
argument_list|,
operator|(
name|total_size
operator|>>
literal|32
operator|)
argument_list|,
name|total_size
operator|&
literal|0xfffffffful
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|INVALID_HANDLE_VALUE
condition|)
block|{
comment|/* Does h leak? */
name|seg
operator|->
name|mapping_handle
operator|=
name|m
expr_stmt|;
name|seg
operator|->
name|mmap_offset
operator|=
name|offset
expr_stmt|;
name|seg
operator|->
name|is_mapping
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
block|{
name|ev_off_t
name|start_pos
init|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|,
name|pos
decl_stmt|;
name|ev_off_t
name|read_so_far
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|int
name|e
decl_stmt|;
name|ev_ssize_t
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mem
operator|=
name|mm_malloc
argument_list|(
name|length
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|start_pos
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
while|while
condition|(
name|read_so_far
operator|<
name|length
condition|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|mem
operator|+
name|read_so_far
argument_list|,
name|length
operator|-
name|read_so_far
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
name|read_so_far
operator|+=
name|n
expr_stmt|;
block|}
name|e
operator|=
name|errno
expr_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
name|start_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|(
name|n
operator|==
literal|0
operator|&&
name|length
operator|>
name|read_so_far
operator|)
condition|)
block|{
name|mm_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|mem
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|seg
operator|->
name|contents
operator|=
name|mem
expr_stmt|;
block|}
name|done
label|:
return|return
literal|0
return|;
name|err
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|evbuffer_file_segment_add_cleanup_cb
parameter_list|(
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
parameter_list|,
name|evbuffer_file_segment_cleanup_cb
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|seg
operator|->
name|refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|seg
operator|->
name|cleanup_cb
operator|=
name|cb
expr_stmt|;
name|seg
operator|->
name|cleanup_cb_arg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_file_segment_free
parameter_list|(
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
parameter_list|)
block|{
name|int
name|refcnt
decl_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refcnt
operator|=
operator|--
name|seg
operator|->
name|refcnt
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcnt
operator|>
literal|0
condition|)
return|return;
name|EVUTIL_ASSERT
argument_list|(
name|refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|->
name|is_mapping
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|CloseHandle
argument_list|(
name|seg
operator|->
name|mapping_handle
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_MMAP
argument_list|)
name|off_t
name|offset_leftover
decl_stmt|;
name|offset_leftover
operator|=
name|seg
operator|->
name|file_offset
operator|%
name|get_page_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|seg
operator|->
name|mapping
argument_list|,
name|seg
operator|->
name|length
operator|+
name|offset_leftover
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|event_warn
argument_list|(
literal|"%s: munmap failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|seg
operator|->
name|contents
condition|)
block|{
name|mm_free
argument_list|(
name|seg
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seg
operator|->
name|flags
operator|&
name|EVBUF_FS_CLOSE_ON_FREE
operator|)
operator|&&
name|seg
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|seg
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|->
name|cleanup_cb
condition|)
block|{
call|(
modifier|*
name|seg
operator|->
name|cleanup_cb
call|)
argument_list|(
operator|(
expr|struct
name|evbuffer_file_segment
specifier|const
operator|*
operator|)
name|seg
argument_list|,
name|seg
operator|->
name|flags
argument_list|,
name|seg
operator|->
name|cleanup_cb_arg
argument_list|)
expr_stmt|;
name|seg
operator|->
name|cleanup_cb
operator|=
name|NULL
expr_stmt|;
name|seg
operator|->
name|cleanup_cb_arg
operator|=
name|NULL
expr_stmt|;
block|}
name|EVTHREAD_FREE_LOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_file_segment
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
parameter_list|,
name|ev_off_t
name|offset
parameter_list|,
name|ev_off_t
name|length
parameter_list|)
block|{
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|struct
name|evbuffer_chain_file_segment
modifier|*
name|extra
decl_stmt|;
name|int
name|can_use_sendfile
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|EVLOCK_LOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|flags
operator|&
name|EVBUFFER_FLAG_DRAINS_TO_FD
condition|)
block|{
name|can_use_sendfile
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seg
operator|->
name|contents
condition|)
block|{
if|if
condition|(
name|evbuffer_file_segment_materialize
argument_list|(
name|seg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|EVLOCK_UNLOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
operator|++
name|seg
operator|->
name|refcnt
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|seg
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|>
name|seg
operator|->
name|length
condition|)
goto|goto
name|err
goto|;
name|length
operator|=
name|seg
operator|->
name|length
operator|-
name|offset
expr_stmt|;
block|}
comment|/* Can we actually add this? */
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|seg
operator|->
name|length
condition|)
goto|goto
name|err
goto|;
name|chain
operator|=
name|evbuffer_chain_new
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_chain_file_segment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
goto|goto
name|err
goto|;
name|extra
operator|=
name|EVBUFFER_CHAIN_EXTRA
argument_list|(
expr|struct
name|evbuffer_chain_file_segment
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|flags
operator||=
name|EVBUFFER_IMMUTABLE
operator||
name|EVBUFFER_FILESEGMENT
expr_stmt|;
if|if
condition|(
name|can_use_sendfile
operator|&&
name|seg
operator|->
name|can_sendfile
condition|)
block|{
name|chain
operator|->
name|flags
operator||=
name|EVBUFFER_SENDFILE
expr_stmt|;
name|chain
operator|->
name|misalign
operator|=
name|seg
operator|->
name|file_offset
operator|+
name|offset
expr_stmt|;
name|chain
operator|->
name|off
operator|=
name|length
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|chain
operator|->
name|misalign
operator|+
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg
operator|->
name|is_mapping
condition|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|ev_uint64_t
name|total_offset
init|=
name|seg
operator|->
name|mmap_offset
operator|+
name|offset
decl_stmt|;
name|ev_uint64_t
name|offset_rounded
init|=
literal|0
decl_stmt|,
name|offset_remaining
init|=
literal|0
decl_stmt|;
name|LPVOID
name|data
decl_stmt|;
if|if
condition|(
name|total_offset
condition|)
block|{
name|SYSTEM_INFO
name|si
decl_stmt|;
name|memset
argument_list|(
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cargo cult */
name|GetSystemInfo
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|offset_remaining
operator|=
name|total_offset
operator|%
name|si
operator|.
name|dwAllocationGranularity
expr_stmt|;
name|offset_rounded
operator|=
name|total_offset
operator|-
name|offset_remaining
expr_stmt|;
block|}
name|data
operator|=
name|MapViewOfFile
argument_list|(
name|seg
operator|->
name|mapping_handle
argument_list|,
name|FILE_MAP_READ
argument_list|,
name|offset_rounded
operator|>>
literal|32
argument_list|,
name|offset_rounded
operator|&
literal|0xfffffffful
argument_list|,
name|length
operator|+
name|offset_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|chain
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|chain
operator|->
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|length
operator|+
name|offset_remaining
expr_stmt|;
name|chain
operator|->
name|misalign
operator|=
name|offset_remaining
expr_stmt|;
name|chain
operator|->
name|off
operator|=
name|length
expr_stmt|;
else|#
directive|else
name|chain
operator|->
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|seg
operator|->
name|contents
operator|+
name|offset
operator|)
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|length
expr_stmt|;
name|chain
operator|->
name|off
operator|=
name|length
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|chain
operator|->
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|seg
operator|->
name|contents
operator|+
name|offset
operator|)
expr_stmt|;
name|chain
operator|->
name|buffer_len
operator|=
name|length
expr_stmt|;
name|chain
operator|->
name|off
operator|=
name|length
expr_stmt|;
block|}
name|extra
operator|->
name|segment
operator|=
name|seg
expr_stmt|;
name|buf
operator|->
name|n_add_for_cb
operator|+=
name|length
expr_stmt|;
name|evbuffer_chain_insert
argument_list|(
name|buf
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_file_segment_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_add_file
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|int
name|fd
parameter_list|,
name|ev_off_t
name|offset
parameter_list|,
name|ev_off_t
name|length
parameter_list|)
block|{
name|struct
name|evbuffer_file_segment
modifier|*
name|seg
decl_stmt|;
name|unsigned
name|flags
init|=
name|EVBUF_FS_CLOSE_ON_FREE
decl_stmt|;
name|int
name|r
decl_stmt|;
name|seg
operator|=
name|evbuffer_file_segment_new
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
return|return
operator|-
literal|1
return|;
name|r
operator|=
name|evbuffer_add_file_segment
argument_list|(
name|buf
argument_list|,
name|seg
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|evbuffer_file_segment_free
argument_list|(
name|seg
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|evbuffer_setcb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evbuffer_cb
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|)
condition|)
name|evbuffer_remove_all_callbacks
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
block|{
name|struct
name|evbuffer_cb_entry
modifier|*
name|ent
init|=
name|evbuffer_add_cb
argument_list|(
name|buffer
argument_list|,
name|NULL
argument_list|,
name|cbarg
argument_list|)
decl_stmt|;
name|ent
operator|->
name|cb
operator|.
name|cb_obsolete
operator|=
name|cb
expr_stmt|;
name|ent
operator|->
name|flags
operator||=
name|EVBUFFER_CB_OBSOLETE
expr_stmt|;
block|}
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evbuffer_cb_entry
modifier|*
name|evbuffer_add_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evbuffer_cb_func
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|evbuffer_cb_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_cb_entry
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|e
operator|->
name|cb
operator|.
name|cb_func
operator|=
name|cb
expr_stmt|;
name|e
operator|->
name|cbarg
operator|=
name|cbarg
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|EVBUFFER_CB_ENABLED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|buffer
operator|->
name|callbacks
argument_list|,
name|e
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_remove_cb_entry
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|evbuffer_cb_entry
modifier|*
name|ent
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_remove_cb
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|evbuffer_cb_func
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|evbuffer_cb_entry
modifier|*
name|cbent
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cbent
argument_list|,
argument|&buffer->callbacks
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cb
operator|==
name|cbent
operator|->
name|cb
operator|.
name|cb_func
operator|&&
name|cbarg
operator|==
name|cbent
operator|->
name|cbarg
condition|)
block|{
name|result
operator|=
name|evbuffer_remove_cb_entry
argument_list|(
name|buffer
argument_list|,
name|cbent
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_cb_set_flags
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|evbuffer_cb_entry
modifier|*
name|cb
parameter_list|,
name|ev_uint32_t
name|flags
parameter_list|)
block|{
comment|/* the user isn't allowed to mess with these. */
name|flags
operator|&=
operator|~
name|EVBUFFER_CB_INTERNAL_FLAGS
expr_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cb
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_cb_clear_flags
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|evbuffer_cb_entry
modifier|*
name|cb
parameter_list|,
name|ev_uint32_t
name|flags
parameter_list|)
block|{
comment|/* the user isn't allowed to mess with these. */
name|flags
operator|&=
operator|~
name|EVBUFFER_CB_INTERNAL_FLAGS
expr_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|cb
operator|->
name|flags
operator|&=
operator|~
name|flags
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_freeze
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|buffer
operator|->
name|freeze_start
operator|=
literal|1
expr_stmt|;
else|else
name|buffer
operator|->
name|freeze_end
operator|=
literal|1
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_unfreeze
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
condition|)
name|buffer
operator|->
name|freeze_start
operator|=
literal|0
expr_stmt|;
else|else
name|buffer
operator|->
name|freeze_end
operator|=
literal|0
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void evbuffer_cb_suspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb) { 	if (!(cb->flags& EVBUFFER_CB_SUSPENDED)) { 		cb->size_before_suspend = evbuffer_get_length(buffer); 		cb->flags |= EVBUFFER_CB_SUSPENDED; 	} }  void evbuffer_cb_unsuspend(struct evbuffer *buffer, struct evbuffer_cb_entry *cb) { 	if ((cb->flags& EVBUFFER_CB_SUSPENDED)) { 		unsigned call = (cb->flags& EVBUFFER_CB_CALL_ON_UNSUSPEND); 		size_t sz = cb->size_before_suspend; 		cb->flags&= ~(EVBUFFER_CB_SUSPENDED| 			       EVBUFFER_CB_CALL_ON_UNSUSPEND); 		cb->size_before_suspend = 0; 		if (call&& (cb->flags& EVBUFFER_CB_ENABLED)) { 			cb->cb(buffer, sz, evbuffer_get_length(buffer), cb->cbarg); 		} 	} }
endif|#
directive|endif
end_endif

begin_function
name|int
name|evbuffer_get_callbacks_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|,
name|struct
name|event_callback
modifier|*
modifier|*
name|cbs
parameter_list|,
name|int
name|max_cbs
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|deferred_cbs
condition|)
block|{
if|if
condition|(
name|max_cbs
operator|<
literal|1
condition|)
block|{
name|r
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cbs
index|[
literal|0
index|]
operator|=
operator|&
name|buffer
operator|->
name|deferred
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
block|}
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

end_unit

