begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCCOM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_ARPA_INET_H
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETDB_H
end_ifdef

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|timeout_pending
end_undef

begin_undef
undef|#
directive|undef
name|timeout_initialized
end_undef

begin_include
include|#
directive|include
file|"strlcpy-internal.h"
end_include

begin_include
include|#
directive|include
file|"event2/http.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/http_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/http_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/listener.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"http-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__HAVE_GETNAMEINFO
end_ifndef

begin_define
define|#
directive|define
name|NI_MAXSERV
value|32
end_define

begin_define
define|#
directive|define
name|NI_MAXHOST
value|1025
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NI_NUMERICHOST
end_ifndef

begin_define
define|#
directive|define
name|NI_NUMERICHOST
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NI_NUMERICSERV
end_ifndef

begin_define
define|#
directive|define
name|NI_NUMERICSERV
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fake_getnameinfo
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|size_t
name|salen
parameter_list|,
name|char
modifier|*
name|host
parameter_list|,
name|size_t
name|hostlen
parameter_list|,
name|char
modifier|*
name|serv
parameter_list|,
name|size_t
name|servlen
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
if|if
condition|(
name|serv
operator|!=
name|NULL
condition|)
block|{
name|char
name|tmpserv
index|[
literal|16
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|tmpserv
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpserv
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|serv
argument_list|,
name|tmpserv
argument_list|,
name|servlen
argument_list|)
operator|>=
name|servlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|host
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|NI_NUMERICHOST
condition|)
block|{
if|if
condition|(
name|strlcpy
argument_list|(
name|host
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|hostlen
argument_list|)
operator|>=
name|hostlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|strlcpy
argument_list|(
name|host
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|hostlen
argument_list|)
operator|>=
name|hostlen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REQ_VERSION_BEFORE
parameter_list|(
name|req
parameter_list|,
name|major_v
parameter_list|,
name|minor_v
parameter_list|)
define|\
value|((req)->major< (major_v) ||					\ 	    ((req)->major == (major_v)&& (req)->minor< (minor_v)))
end_define

begin_define
define|#
directive|define
name|REQ_VERSION_ATLEAST
parameter_list|(
name|req
parameter_list|,
name|major_v
parameter_list|,
name|minor_v
parameter_list|)
define|\
value|((req)->major> (major_v) ||					\ 	    ((req)->major == (major_v)&& (req)->minor>= (minor_v)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|evutil_socket_t
name|bind_socket_ai
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
parameter_list|,
name|int
name|reuse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|evutil_socket_t
name|bind_socket
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|ev_uint16_t
parameter_list|,
name|int
name|reuse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|name_from_addr
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|ev_socklen_t
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evhttp_associate_new_request_with_connection
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_connection_start_detectclose
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_connection_stop_detectclose
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_request_dispatch
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_read_firstline
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_read_header
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evhttp_add_header_internal
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|evhttp_response_phrase_internal
parameter_list|(
name|int
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_get_request
parameter_list|(
name|struct
name|evhttp
modifier|*
parameter_list|,
name|evutil_socket_t
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|ev_socklen_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_write_buffer
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_make_header
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|struct
name|evhttp_request
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* callbacks for bufferevent */
end_comment

begin_function_decl
specifier|static
name|void
name|evhttp_read_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_write_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|evhttp_error_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evhttp_find_vhost
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evhttp
modifier|*
modifier|*
name|outhttp
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__HAVE_STRSEP
end_ifndef

begin_comment
comment|/* strsep replacement for platforms that lack it.  Only works if  * del is one character long. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strsep
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|del
parameter_list|)
block|{
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|strlen
argument_list|(
name|del
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
operator|*
name|s
condition|)
return|return
name|NULL
return|;
name|tok
operator|=
operator|*
name|s
expr_stmt|;
name|d
operator|=
name|strstr
argument_list|(
name|tok
argument_list|,
name|del
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|s
operator|=
name|d
operator|+
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
return|return
name|tok
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|size_t
name|html_replace
parameter_list|(
specifier|const
name|char
name|ch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|escaped
parameter_list|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'<'
case|:
operator|*
name|escaped
operator|=
literal|"&lt;"
expr_stmt|;
return|return
literal|4
return|;
case|case
literal|'>'
case|:
operator|*
name|escaped
operator|=
literal|"&gt;"
expr_stmt|;
return|return
literal|4
return|;
case|case
literal|'"'
case|:
operator|*
name|escaped
operator|=
literal|"&quot;"
expr_stmt|;
return|return
literal|6
return|;
case|case
literal|'\''
case|:
operator|*
name|escaped
operator|=
literal|"&#039;"
expr_stmt|;
return|return
literal|6
return|;
case|case
literal|'&'
case|:
operator|*
name|escaped
operator|=
literal|"&amp;"
expr_stmt|;
return|return
literal|5
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Replaces<,>, ", ' and& with&lt;,&gt;,&quot;,  *&#039; and&amp; correspondingly.  *  * The returned string needs to be freed by the caller.  */
end_comment

begin_function
name|char
modifier|*
name|evhttp_htmlescape
parameter_list|(
specifier|const
name|char
modifier|*
name|html
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|new_size
init|=
literal|0
decl_stmt|,
name|old_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|escaped_html
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|html
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|old_size
operator|=
name|strlen
argument_list|(
name|html
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_size
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|replaced
init|=
name|NULL
decl_stmt|;
specifier|const
name|size_t
name|replace_size
init|=
name|html_replace
argument_list|(
name|html
index|[
name|i
index|]
argument_list|,
operator|&
name|replaced
argument_list|)
decl_stmt|;
if|if
condition|(
name|replace_size
operator|>
name|EV_SIZE_MAX
operator|-
name|new_size
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: html_replace overflow"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_size
operator|+=
name|replace_size
expr_stmt|;
block|}
if|if
condition|(
name|new_size
operator|==
name|EV_SIZE_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|escaped_html
operator|=
name|mm_malloc
argument_list|(
name|new_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|escaped_html
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: malloc(%lu)"
argument_list|,
name|__func__
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|new_size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|old_size
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|replaced
init|=
operator|&
name|html
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|size_t
name|len
init|=
name|html_replace
argument_list|(
name|html
index|[
name|i
index|]
argument_list|,
operator|&
name|replaced
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|replaced
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|escaped_html
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Given an evhttp_cmd_type, returns a constant string containing the  * equivalent HTTP command, or NULL if the evhttp_command_type is  * unrecognized. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|evhttp_method
parameter_list|(
name|enum
name|evhttp_cmd_type
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EVHTTP_REQ_GET
case|:
name|method
operator|=
literal|"GET"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_POST
case|:
name|method
operator|=
literal|"POST"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_HEAD
case|:
name|method
operator|=
literal|"HEAD"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_PUT
case|:
name|method
operator|=
literal|"PUT"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_DELETE
case|:
name|method
operator|=
literal|"DELETE"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_OPTIONS
case|:
name|method
operator|=
literal|"OPTIONS"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_TRACE
case|:
name|method
operator|=
literal|"TRACE"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_CONNECT
case|:
name|method
operator|=
literal|"CONNECT"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_PATCH
case|:
name|method
operator|=
literal|"PATCH"
expr_stmt|;
break|break;
default|default:
name|method
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|method
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Determines if a response should have a body.  * Follows the rules in RFC 2616 section 4.3.  * @return 1 if the response MUST have a body; 0 if the response MUST NOT have  *     a body.  */
end_comment

begin_function
specifier|static
name|int
name|evhttp_response_needs_body
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|response_code
operator|!=
name|HTTP_NOCONTENT
operator|&&
name|req
operator|->
name|response_code
operator|!=
name|HTTP_NOTMODIFIED
operator|&&
operator|(
name|req
operator|->
name|response_code
operator|<
literal|100
operator|||
name|req
operator|->
name|response_code
operator|>=
literal|200
operator|)
operator|&&
name|req
operator|->
name|type
operator|!=
name|EVHTTP_REQ_HEAD
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Helper: called after we've added some data to an evcon's bufferevent's  * output buffer.  Sets the evconn's writing-is-done callback, and puts  * the bufferevent into writing mode.  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_write_buffer
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: preparing to write buffer\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Set call back */
name|evcon
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|evcon
operator|->
name|cb_arg
operator|=
name|arg
expr_stmt|;
comment|/* Disable the read callback: we don't actually care about data; 	 * we only care about close detection.  (We don't disable reading, 	 * since we *do* want to learn about any close events.) */
name|bufferevent_setcb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|NULL
argument_list|,
comment|/*read*/
name|evhttp_write_cb
argument_list|,
name|evhttp_error_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_send_continue_done
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_send_continue
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|,
literal|"HTTP/%d.%d 100 Continue\r\n\r\n"
argument_list|,
name|req
operator|->
name|major
argument_list|,
name|req
operator|->
name|minor
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|cb
operator|=
name|evhttp_send_continue_done
expr_stmt|;
name|evcon
operator|->
name|cb_arg
operator|=
name|NULL
expr_stmt|;
name|bufferevent_setcb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evhttp_read_cb
argument_list|,
name|evhttp_write_cb
argument_list|,
name|evhttp_error_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Helper: returns true iff evconn is in any connected state. */
end_comment

begin_function
specifier|static
name|int
name|evhttp_connected
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
switch|switch
condition|(
name|evcon
operator|->
name|state
condition|)
block|{
case|case
name|EVCON_DISCONNECTED
case|:
case|case
name|EVCON_CONNECTING
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EVCON_IDLE
case|:
case|case
name|EVCON_READING_FIRSTLINE
case|:
case|case
name|EVCON_READING_HEADERS
case|:
case|case
name|EVCON_READING_BODY
case|:
case|case
name|EVCON_READING_TRAILER
case|:
case|case
name|EVCON_WRITING
case|:
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create the headers needed for an outgoing HTTP request, adds them to  * the request's header list, and writes the request line to the  * connection's output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_make_header_request
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|method
decl_stmt|;
name|evhttp_remove_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Proxy-Connection"
argument_list|)
expr_stmt|;
comment|/* Generate request line */
name|method
operator|=
name|evhttp_method
argument_list|(
name|req
operator|->
name|type
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|,
literal|"%s %s HTTP/%d.%d\r\n"
argument_list|,
name|method
argument_list|,
name|req
operator|->
name|uri
argument_list|,
name|req
operator|->
name|major
argument_list|,
name|req
operator|->
name|minor
argument_list|)
expr_stmt|;
comment|/* Add the content length on a post or put request if missing */
if|if
condition|(
operator|(
name|req
operator|->
name|type
operator|==
name|EVHTTP_REQ_POST
operator|||
name|req
operator|->
name|type
operator|==
name|EVHTTP_REQ_PUT
operator|)
operator|&&
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Length"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|size
index|[
literal|22
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|,
name|EV_SIZE_FMT
argument_list|,
name|EV_SIZE_ARG
argument_list|(
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Length"
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Return true if the list of headers in 'headers', intepreted with respect  * to flags, means that we should send a "connection: close" when the request  * is done. */
end_comment

begin_function
specifier|static
name|int
name|evhttp_is_connection_close
parameter_list|(
name|int
name|flags
parameter_list|,
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|EVHTTP_PROXY_REQUEST
condition|)
block|{
comment|/* proxy connection */
specifier|const
name|char
modifier|*
name|connection
init|=
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Proxy-Connection"
argument_list|)
decl_stmt|;
return|return
operator|(
name|connection
operator|==
name|NULL
operator|||
name|evutil_ascii_strcasecmp
argument_list|(
name|connection
argument_list|,
literal|"keep-alive"
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|connection
init|=
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Connection"
argument_list|)
decl_stmt|;
return|return
operator|(
name|connection
operator|!=
name|NULL
operator|&&
name|evutil_ascii_strcasecmp
argument_list|(
name|connection
argument_list|,
literal|"close"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true iff 'headers' contains 'Connection: keep-alive' */
end_comment

begin_function
specifier|static
name|int
name|evhttp_is_connection_keepalive
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|connection
init|=
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Connection"
argument_list|)
decl_stmt|;
return|return
operator|(
name|connection
operator|!=
name|NULL
operator|&&
name|evutil_ascii_strncasecmp
argument_list|(
name|connection
argument_list|,
literal|"keep-alive"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a correct "Date" header to headers, unless it already has one. */
end_comment

begin_function
specifier|static
name|void
name|evhttp_maybe_add_date_header
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
if|if
condition|(
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Date"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|date
index|[
literal|50
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|struct
name|tm
name|cur
decl_stmt|;
endif|#
directive|endif
name|struct
name|tm
modifier|*
name|cur_p
decl_stmt|;
name|time_t
name|t
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|cur_p
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|gmtime_r
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|cur
argument_list|)
expr_stmt|;
name|cur_p
operator|=
operator|&
name|cur
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strftime
argument_list|(
name|date
argument_list|,
sizeof|sizeof
argument_list|(
name|date
argument_list|)
argument_list|,
literal|"%a, %d %b %Y %H:%M:%S GMT"
argument_list|,
name|cur_p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|evhttp_add_header
argument_list|(
name|headers
argument_list|,
literal|"Date"
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a "Content-Length" header with value 'content_length' to headers,  * unless it already has a content-length or transfer-encoding header. */
end_comment

begin_function
specifier|static
name|void
name|evhttp_maybe_add_content_length_header
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
name|size_t
name|content_length
parameter_list|)
block|{
if|if
condition|(
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Transfer-Encoding"
argument_list|)
operator|==
name|NULL
operator|&&
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Content-Length"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|len
index|[
literal|22
index|]
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|EV_SIZE_FMT
argument_list|,
name|EV_SIZE_ARG
argument_list|(
name|content_length
argument_list|)
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|headers
argument_list|,
literal|"Content-Length"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create the headers needed for an HTTP reply in req->output_headers,  * and write the first HTTP response for req line to evcon.  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_make_header_response
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|int
name|is_keepalive
init|=
name|evhttp_is_connection_keepalive
argument_list|(
name|req
operator|->
name|input_headers
argument_list|)
decl_stmt|;
name|evbuffer_add_printf
argument_list|(
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|,
literal|"HTTP/%d.%d %d %s\r\n"
argument_list|,
name|req
operator|->
name|major
argument_list|,
name|req
operator|->
name|minor
argument_list|,
name|req
operator|->
name|response_code
argument_list|,
name|req
operator|->
name|response_code_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|major
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|minor
operator|>=
literal|1
condition|)
name|evhttp_maybe_add_date_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
comment|/* 		 * if the protocol is 1.0; and the connection was keep-alive 		 * we need to add a keep-alive header, too. 		 */
if|if
condition|(
name|req
operator|->
name|minor
operator|==
literal|0
operator|&&
name|is_keepalive
condition|)
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Connection"
argument_list|,
literal|"keep-alive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|minor
operator|>=
literal|1
operator|||
name|is_keepalive
operator|)
operator|&&
name|evhttp_response_needs_body
argument_list|(
name|req
argument_list|)
condition|)
block|{
comment|/* 			 * we need to add the content length if the 			 * user did not give it, this is required for 			 * persistent connections to work. 			 */
name|evhttp_maybe_add_content_length_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Potentially add headers for unidentified content. */
if|if
condition|(
name|evhttp_response_needs_body
argument_list|(
name|req
argument_list|)
condition|)
block|{
if|if
condition|(
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Type"
argument_list|)
operator|==
name|NULL
operator|&&
name|evcon
operator|->
name|http_server
operator|->
name|default_content_type
condition|)
block|{
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Type"
argument_list|,
name|evcon
operator|->
name|http_server
operator|->
name|default_content_type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the request asked for a close, we send a close, too */
if|if
condition|(
name|evhttp_is_connection_close
argument_list|(
name|req
operator|->
name|flags
argument_list|,
name|req
operator|->
name|input_headers
argument_list|)
condition|)
block|{
name|evhttp_remove_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Connection"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_PROXY_REQUEST
operator|)
condition|)
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Connection"
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|evhttp_remove_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Proxy-Connection"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** Generate all headers appropriate for sending the http request in req (or  * the response, if we're sending a response), and write them to evcon's  * bufferevent. Also writes all data from req->output_buffer */
end_comment

begin_function
specifier|static
name|void
name|evhttp_make_header
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
init|=
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
decl_stmt|;
comment|/* 	 * Depending if this is a HTTP request or response, we might need to 	 * add some new headers or remove existing headers. 	 */
if|if
condition|(
name|req
operator|->
name|kind
operator|==
name|EVHTTP_REQUEST
condition|)
block|{
name|evhttp_make_header_request
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evhttp_make_header_response
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|header
argument_list|,
argument|req->output_headers
argument_list|,
argument|next
argument_list|)
block|{
name|evbuffer_add_printf
argument_list|(
name|output
argument_list|,
literal|"%s: %s\r\n"
argument_list|,
name|header
operator|->
name|key
argument_list|,
name|header
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|evbuffer_add
argument_list|(
name|output
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * For a request, we add the POST data, for a reply, this 		 * is the regular data. 		 */
comment|/* XXX We might want to support waiting (a limited amount of 		   time) for a continue status line from the server before 		   sending POST/PUT message bodies. */
name|evbuffer_add_buffer
argument_list|(
name|output
argument_list|,
name|req
operator|->
name|output_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_max_headers_size
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|ev_ssize_t
name|new_max_headers_size
parameter_list|)
block|{
if|if
condition|(
name|new_max_headers_size
operator|<
literal|0
condition|)
name|evcon
operator|->
name|max_headers_size
operator|=
name|EV_SIZE_MAX
expr_stmt|;
else|else
name|evcon
operator|->
name|max_headers_size
operator|=
name|new_max_headers_size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_max_body_size
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|ev_ssize_t
name|new_max_body_size
parameter_list|)
block|{
if|if
condition|(
name|new_max_body_size
operator|<
literal|0
condition|)
name|evcon
operator|->
name|max_body_size
operator|=
name|EV_UINT64_MAX
expr_stmt|;
else|else
name|evcon
operator|->
name|max_body_size
operator|=
name|new_max_body_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_connection_incoming_fail
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|enum
name|evhttp_request_error
name|error
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EVREQ_HTTP_TIMEOUT
case|:
case|case
name|EVREQ_HTTP_EOF
case|:
comment|/* 		 * these are cases in which we probably should just 		 * close the connection and not send a reply.  this 		 * case may happen when a browser keeps a persistent 		 * connection open and we timeout on the read.  when 		 * the request is still being used for sending, we 		 * need to disassociated it from the connection here. 		 */
if|if
condition|(
operator|!
name|req
operator|->
name|userdone
condition|)
block|{
comment|/* remove it so that it will not be freed */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|req
operator|->
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* indicate that this request no longer has a 			 * connection object 			 */
name|req
operator|->
name|evcon
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|EVREQ_HTTP_INVALID_HEADER
case|:
case|case
name|EVREQ_HTTP_BUFFER_ERROR
case|:
case|case
name|EVREQ_HTTP_REQUEST_CANCEL
case|:
case|case
name|EVREQ_HTTP_DATA_TOO_LONG
case|:
default|default:
comment|/* xxx: probably should just error on default */
comment|/* the callback looks at the uri to determine errors */
if|if
condition|(
name|req
operator|->
name|uri
condition|)
block|{
name|mm_free
argument_list|(
name|req
operator|->
name|uri
argument_list|)
expr_stmt|;
name|req
operator|->
name|uri
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|uri_elems
condition|)
block|{
name|evhttp_uri_free
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
name|req
operator|->
name|uri_elems
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * the callback needs to send a reply, once the reply has 		 * been send, the connection should get freed. 		 */
call|(
modifier|*
name|req
operator|->
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called when evcon has experienced a (non-recoverable? -NM) error, as  * given in error. If it's an outgoing connection, reset the connection,  * retry any pending requests, and inform the user.  If it's incoming,  * delegates to evhttp_connection_incoming_fail(). */
end_comment

begin_function
name|void
name|evhttp_connection_fail_
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|enum
name|evhttp_request_error
name|error
parameter_list|)
block|{
specifier|const
name|int
name|errsave
init|=
name|EVUTIL_SOCKET_ERROR
argument_list|()
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|cb_arg
decl_stmt|;
name|void
function_decl|(
modifier|*
name|error_cb
function_decl|)
parameter_list|(
name|enum
name|evhttp_request_error
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|error_cb_arg
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|flags
operator|&
name|EVHTTP_CON_INCOMING
condition|)
block|{
comment|/* 		 * for incoming requests, there are two different 		 * failure cases.  it's either a network level error 		 * or an http layer error. for problems on the network 		 * layer like timeouts we just drop the connections. 		 * For HTTP problems, we might have to send back a 		 * reply before the connection can be freed. 		 */
if|if
condition|(
name|evhttp_connection_incoming_fail
argument_list|(
name|req
argument_list|,
name|error
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
name|error_cb
operator|=
name|req
operator|->
name|error_cb
expr_stmt|;
name|error_cb_arg
operator|=
name|req
operator|->
name|cb_arg
expr_stmt|;
comment|/* when the request was canceled, the callback is not executed */
if|if
condition|(
name|error
operator|!=
name|EVREQ_HTTP_REQUEST_CANCEL
condition|)
block|{
comment|/* save the callback for later; the cb might free our object */
name|cb
operator|=
name|req
operator|->
name|cb
expr_stmt|;
name|cb_arg
operator|=
name|req
operator|->
name|cb_arg
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|=
name|NULL
expr_stmt|;
name|cb_arg
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* do not fail all requests; the next request is going to get 	 * send over a new connection.   when a user cancels a request, 	 * all other pending requests should be processed as normal 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* reset the connection */
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
comment|/* We are trying the next request that was queued on us */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|!=
name|NULL
condition|)
name|evhttp_connection_connect_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
comment|/* The call to evhttp_connection_reset_ overwrote errno. 	 * Let's restore the original errno, so that the user's 	 * callback can have a better idea of what the error was. 	 */
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|errsave
argument_list|)
expr_stmt|;
comment|/* inform the user */
if|if
condition|(
name|error_cb
operator|!=
name|NULL
condition|)
name|error_cb
argument_list|(
name|error
argument_list|,
name|error_cb_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|cb
call|)
argument_list|(
name|NULL
argument_list|,
name|cb_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bufferevent callback: invoked when any data has been written from an  * http connection's bufferevent */
end_comment

begin_function
specifier|static
name|void
name|evhttp_write_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|arg
decl_stmt|;
comment|/* Activate our call back */
if|if
condition|(
name|evcon
operator|->
name|cb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|evcon
operator|->
name|cb
call|)
argument_list|(
name|evcon
argument_list|,
name|evcon
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Advance the connection state.  * - If this is an outgoing connection, we've just processed the response;  *   idle or close the connection.  * - If this is an incoming connection, we've just processed the request;  *   respond.  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_connection_done
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
name|int
name|con_outgoing
init|=
name|evcon
operator|->
name|flags
operator|&
name|EVHTTP_CON_OUTGOING
decl_stmt|;
if|if
condition|(
name|con_outgoing
condition|)
block|{
comment|/* idle or close the connection */
name|int
name|need_close
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|req
operator|->
name|evcon
operator|=
name|NULL
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_IDLE
expr_stmt|;
name|need_close
operator|=
name|evhttp_is_connection_close
argument_list|(
name|req
operator|->
name|flags
argument_list|,
name|req
operator|->
name|input_headers
argument_list|)
operator|||
name|evhttp_is_connection_close
argument_list|(
name|req
operator|->
name|flags
argument_list|,
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
comment|/* check if we got asked to close the connection */
if|if
condition|(
name|need_close
condition|)
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have more requests; reset the connection 			 * and deal with the next request. 			 */
if|if
condition|(
operator|!
name|evhttp_connected
argument_list|(
name|evcon
argument_list|)
condition|)
name|evhttp_connection_connect_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
else|else
name|evhttp_request_dispatch
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|need_close
condition|)
block|{
comment|/* 			 * The connection is going to be persistent, but we 			 * need to detect if the other side closes it. 			 */
name|evhttp_connection_start_detectclose
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * incoming connection - we need to leave the request on the 		 * connection so that we can reply to it. 		 */
name|evcon
operator|->
name|state
operator|=
name|EVCON_WRITING
expr_stmt|;
block|}
comment|/* notify the user of the request */
call|(
modifier|*
name|req
operator|->
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
comment|/* if this was an outgoing request, we own and it's done. so free it. 	 * unless the callback specifically requested to own the request. 	 */
if|if
condition|(
name|con_outgoing
operator|&&
operator|(
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_USER_OWNED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handles reading from a chunked request.  *   return ALL_DATA_READ:  *     all data has been read  *   return MORE_DATA_EXPECTED:  *     more data is expected  *   return DATA_CORRUPTED:  *     data is corrupted  *   return REQUEST_CANCELED:  *     request was canceled by the user calling evhttp_cancel_request  *   return DATA_TOO_LONG:  *     ran over the maximum limit  */
end_comment

begin_function
specifier|static
name|enum
name|message_read_status
name|evhttp_handle_chunked_read
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|req
operator|==
name|NULL
operator|||
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
name|DATA_CORRUPTED
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|buflen
decl_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
comment|/* evbuffer_get_length returns size_t, but len variable is ssize_t, 		 * check for overflow conditions */
if|if
condition|(
name|buflen
operator|>
name|EV_SSIZE_MAX
condition|)
block|{
return|return
name|DATA_CORRUPTED
return|;
block|}
if|if
condition|(
name|req
operator|->
name|ntoread
operator|<
literal|0
condition|)
block|{
comment|/* Read chunk size */
name|ev_int64_t
name|ntoread
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|evbuffer_readln
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
comment|/* the last chunk is on a new line? */
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ntoread
operator|=
name|evutil_strtoll
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|*
name|endp
operator|!=
literal|' '
operator|)
operator|||
name|ntoread
operator|<
literal|0
operator|)
expr_stmt|;
name|mm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* could not get chunk size */
return|return
operator|(
name|DATA_CORRUPTED
operator|)
return|;
block|}
comment|/* ntoread is signed int64, body_size is unsigned size_t, check for under/overflow conditions */
if|if
condition|(
operator|(
name|ev_uint64_t
operator|)
name|ntoread
operator|>
name|EV_SIZE_MAX
operator|-
name|req
operator|->
name|body_size
condition|)
block|{
return|return
name|DATA_CORRUPTED
return|;
block|}
if|if
condition|(
name|req
operator|->
name|body_size
operator|+
operator|(
name|size_t
operator|)
name|ntoread
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_body_size
condition|)
block|{
comment|/* failed body length test */
name|event_debug
argument_list|(
operator|(
literal|"Request body is too long"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DATA_TOO_LONG
operator|)
return|;
block|}
name|req
operator|->
name|body_size
operator|+=
operator|(
name|size_t
operator|)
name|ntoread
expr_stmt|;
name|req
operator|->
name|ntoread
operator|=
name|ntoread
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ntoread
operator|==
literal|0
condition|)
block|{
comment|/* Last chunk */
return|return
operator|(
name|ALL_DATA_READ
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* req->ntoread is signed int64, len is ssize_t, based on arch, 		 * ssize_t could only be 32b, check for these conditions */
if|if
condition|(
name|req
operator|->
name|ntoread
operator|>
name|EV_SSIZE_MAX
condition|)
block|{
return|return
name|DATA_CORRUPTED
return|;
block|}
comment|/* don't have enough to complete a chunk; wait for more */
if|if
condition|(
name|req
operator|->
name|ntoread
operator|>
literal|0
operator|&&
name|buflen
operator|<
operator|(
name|ev_uint64_t
operator|)
name|req
operator|->
name|ntoread
condition|)
return|return
operator|(
name|MORE_DATA_EXPECTED
operator|)
return|;
comment|/* Completed chunk */
name|evbuffer_remove_buffer
argument_list|(
name|buf
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|,
operator|(
name|size_t
operator|)
name|req
operator|->
name|ntoread
argument_list|)
expr_stmt|;
name|req
operator|->
name|ntoread
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|chunk_cb
operator|!=
name|NULL
condition|)
block|{
name|req
operator|->
name|flags
operator||=
name|EVHTTP_REQ_DEFER_FREE
expr_stmt|;
call|(
modifier|*
name|req
operator|->
name|chunk_cb
call|)
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|,
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|flags
operator|&=
operator|~
name|EVHTTP_REQ_DEFER_FREE
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_REQ_NEEDS_FREE
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|REQUEST_CANCELED
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|MORE_DATA_EXPECTED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_read_trailer
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|evhttp_parse_headers_
argument_list|(
name|req
argument_list|,
name|buf
argument_list|)
condition|)
block|{
case|case
name|DATA_CORRUPTED
case|:
case|case
name|DATA_TOO_LONG
case|:
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_DATA_TOO_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALL_DATA_READ
case|:
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
break|break;
case|case
name|MORE_DATA_EXPECTED
case|:
case|case
name|REQUEST_CANCELED
case|:
comment|/* ??? */
default|default:
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_read_body
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|chunked
condition|)
block|{
switch|switch
condition|(
name|evhttp_handle_chunked_read
argument_list|(
name|req
argument_list|,
name|buf
argument_list|)
condition|)
block|{
case|case
name|ALL_DATA_READ
case|:
comment|/* finished last chunk */
name|evcon
operator|->
name|state
operator|=
name|EVCON_READING_TRAILER
expr_stmt|;
name|evhttp_read_trailer
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return;
case|case
name|DATA_CORRUPTED
case|:
case|case
name|DATA_TOO_LONG
case|:
comment|/* corrupted data */
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_DATA_TOO_LONG
argument_list|)
expr_stmt|;
return|return;
case|case
name|REQUEST_CANCELED
case|:
comment|/* request canceled */
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
case|case
name|MORE_DATA_EXPECTED
case|:
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|ntoread
operator|<
literal|0
condition|)
block|{
comment|/* Read until connection close. */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|req
operator|->
name|body_size
operator|+
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
name|req
operator|->
name|body_size
condition|)
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_INVALID_HEADER
argument_list|)
expr_stmt|;
return|return;
block|}
name|req
operator|->
name|body_size
operator|+=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_add_buffer
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|chunk_cb
operator|!=
name|NULL
operator|||
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
operator|>=
operator|(
name|size_t
operator|)
name|req
operator|->
name|ntoread
condition|)
block|{
comment|/* XXX: the above get_length comparison has to be fixed for overflow conditions! */
comment|/* We've postponed moving the data until now, but we're 		 * about to use it. */
name|size_t
name|n
init|=
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
name|size_t
operator|)
name|req
operator|->
name|ntoread
condition|)
name|n
operator|=
operator|(
name|size_t
operator|)
name|req
operator|->
name|ntoread
expr_stmt|;
name|req
operator|->
name|ntoread
operator|-=
name|n
expr_stmt|;
name|req
operator|->
name|body_size
operator|+=
name|n
expr_stmt|;
name|evbuffer_remove_buffer
argument_list|(
name|buf
argument_list|,
name|req
operator|->
name|input_buffer
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|body_size
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_body_size
operator|||
operator|(
operator|!
name|req
operator|->
name|chunked
operator|&&
name|req
operator|->
name|ntoread
operator|>=
literal|0
operator|&&
operator|(
name|size_t
operator|)
name|req
operator|->
name|ntoread
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_body_size
operator|)
condition|)
block|{
comment|/* XXX: The above casted comparison must checked for overflow */
comment|/* failed body length test */
name|event_debug
argument_list|(
operator|(
literal|"Request body is too long"
operator|)
argument_list|)
expr_stmt|;
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_DATA_TOO_LONG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|req
operator|->
name|chunk_cb
operator|!=
name|NULL
condition|)
block|{
name|req
operator|->
name|flags
operator||=
name|EVHTTP_REQ_DEFER_FREE
expr_stmt|;
call|(
modifier|*
name|req
operator|->
name|chunk_cb
call|)
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|req
operator|->
name|flags
operator|&=
operator|~
name|EVHTTP_REQ_DEFER_FREE
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|,
name|evbuffer_get_length
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_REQ_NEEDS_FREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|req
operator|->
name|ntoread
operator|==
literal|0
condition|)
block|{
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Completed content length */
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read more! */
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|get_deferred_queue
parameter_list|(
name|evcon
parameter_list|)
define|\
value|((evcon)->base)
end_define

begin_comment
comment|/*  * Gets called when more data becomes available  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_read_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
comment|/* Cancel if it's pending. */
name|event_deferred_cb_cancel_
argument_list|(
name|get_deferred_queue
argument_list|(
name|evcon
argument_list|)
argument_list|,
operator|&
name|evcon
operator|->
name|read_more_deferred_cb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|evcon
operator|->
name|state
condition|)
block|{
case|case
name|EVCON_READING_FIRSTLINE
case|:
name|evhttp_read_firstline
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in 		 * evhttp_read_body */
break|break;
case|case
name|EVCON_READING_HEADERS
case|:
name|evhttp_read_header
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in 		 * evhttp_read_body */
break|break;
case|case
name|EVCON_READING_BODY
case|:
name|evhttp_read_body
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in 		 * evhttp_read_body */
break|break;
case|case
name|EVCON_READING_TRAILER
case|:
name|evhttp_read_trailer
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVCON_IDLE
case|:
block|{
ifdef|#
directive|ifdef
name|USE_DEBUG
name|struct
name|evbuffer
modifier|*
name|input
decl_stmt|;
name|size_t
name|total_len
decl_stmt|;
name|input
operator|=
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
name|total_len
operator|=
name|evbuffer_get_length
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"%s: read "
name|EV_SIZE_FMT
literal|" bytes in EVCON_IDLE state,"
literal|" resetting connection"
operator|,
name|__func__
operator|,
name|EV_SIZE_ARG
argument_list|(
name|total_len
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EVCON_DISCONNECTED
case|:
case|case
name|EVCON_CONNECTING
case|:
case|case
name|EVCON_WRITING
case|:
default|default:
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: illegal connection state %d"
argument_list|,
name|__func__
argument_list|,
name|evcon
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_deferred_read_cb
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|data
decl_stmt|;
name|evhttp_read_cb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_write_connectioncb
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* This is after writing the request to the server */
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_WRITING
argument_list|)
expr_stmt|;
comment|/* We are done writing our header and are now expecting the response */
name|req
operator|->
name|kind
operator|=
name|EVHTTP_RESPONSE
expr_stmt|;
name|evhttp_start_read_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean up a connection object  */
end_comment

begin_function
name|void
name|evhttp_connection_free
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
comment|/* notify interested parties that this connection is going down */
if|if
condition|(
name|evcon
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|evhttp_connected
argument_list|(
name|evcon
argument_list|)
operator|&&
name|evcon
operator|->
name|closecb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|evcon
operator|->
name|closecb
call|)
argument_list|(
name|evcon
argument_list|,
name|evcon
operator|->
name|closecb_arg
argument_list|)
expr_stmt|;
block|}
comment|/* remove all requests that might be queued on this 	 * connection.  for server connections, this should be empty. 	 * because it gets dequeued either in evhttp_connection_done or 	 * evhttp_connection_fail_. 	 */
while|while
condition|(
operator|(
name|req
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evcon
operator|->
name|http_server
operator|!=
name|NULL
condition|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|evcon
operator|->
name|http_server
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|connections
argument_list|,
name|evcon
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_initialized
argument_list|(
operator|&
name|evcon
operator|->
name|retry_ev
argument_list|)
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|evcon
operator|->
name|retry_ev
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|evcon
operator|->
name|retry_ev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|evcon
operator|->
name|bufev
operator|!=
name|NULL
condition|)
name|bufferevent_free
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
name|event_deferred_cb_cancel_
argument_list|(
name|get_deferred_queue
argument_list|(
name|evcon
argument_list|)
argument_list|,
operator|&
name|evcon
operator|->
name|read_more_deferred_cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|shutdown
argument_list|(
name|evcon
operator|->
name|fd
argument_list|,
name|EVUTIL_SHUT_WR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bufferevent_get_options_
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
operator|&
name|BEV_OPT_CLOSE_ON_FREE
operator|)
condition|)
block|{
name|evutil_closesocket
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|evcon
operator|->
name|bind_address
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|evcon
operator|->
name|bind_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|address
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|evcon
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|conn_address
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|evcon
operator|->
name|conn_address
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_local_address
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_DISCONNECTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|bind_address
condition|)
name|mm_free
argument_list|(
name|evcon
operator|->
name|bind_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|evcon
operator|->
name|bind_address
operator|=
name|mm_strdup
argument_list|(
name|address
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_local_port
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_DISCONNECTED
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|bind_port
operator|=
name|port
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_request_dispatch
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
comment|/* this should not usually happy but it's possible */
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return;
comment|/* delete possible close detection events */
name|evhttp_connection_stop_detectclose
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
comment|/* we assume that the connection is connected already */
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_IDLE
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_WRITING
expr_stmt|;
comment|/* Create the header from the store arguments */
name|evhttp_make_header
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|evhttp_write_buffer
argument_list|(
name|evcon
argument_list|,
name|evhttp_write_connectioncb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset our connection state: disables reading/writing, closes our fd (if * any), clears out buffers, and puts us in state DISCONNECTED. */
end_comment

begin_function
name|void
name|evhttp_connection_reset_
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|tmp
decl_stmt|;
comment|/* XXXX This is not actually an optimal fix.  Instead we ought to have 	   an API for "stop connecting", or use bufferevent_setfd to turn off 	   connecting.  But for Libevent 2.0, this seems like a minimal change 	   least likely to disrupt the rest of the bufferevent and http code.  	   Why is this here?  If the fd is set in the bufferevent, and the 	   bufferevent is connecting, then you can't actually stop the 	   bufferevent from trying to connect with bufferevent_disable().  The 	   connect will never trigger, since we close the fd, but the timeout 	   might.  That caused an assertion failure in evhttp_connection_fail_. 	*/
name|bufferevent_disable_hard_
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
operator||
name|EV_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* inform interested parties about connection close */
if|if
condition|(
name|evhttp_connected
argument_list|(
name|evcon
argument_list|)
operator|&&
name|evcon
operator|->
name|closecb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|evcon
operator|->
name|closecb
call|)
argument_list|(
name|evcon
argument_list|,
name|evcon
operator|->
name|closecb_arg
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|evcon
operator|->
name|fd
argument_list|,
name|EVUTIL_SHUT_WR
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* we need to clean up any buffered data */
name|tmp
operator|=
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|tmp
argument_list|,
name|evbuffer_get_length
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|tmp
argument_list|,
name|evbuffer_get_length
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_DISCONNECTED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_connection_start_detectclose
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|evcon
operator|->
name|flags
operator||=
name|EVHTTP_CON_CLOSEDETECT
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_connection_stop_detectclose
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|evcon
operator|->
name|flags
operator|&=
operator|~
name|EVHTTP_CON_CLOSEDETECT
expr_stmt|;
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_connection_retry
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|arg
decl_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_DISCONNECTED
expr_stmt|;
name|evhttp_connection_connect_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_connection_cb_cleanup
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evcon_requestq
name|requests
decl_stmt|;
if|if
condition|(
name|evcon
operator|->
name|retry_max
operator|<
literal|0
operator|||
name|evcon
operator|->
name|retry_cnt
operator|<
name|evcon
operator|->
name|retry_max
condition|)
block|{
name|struct
name|timeval
name|tv_retry
init|=
name|evcon
operator|->
name|initial_retry_timeout
decl_stmt|;
name|int
name|i
decl_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|evcon
operator|->
name|retry_ev
argument_list|,
name|evcon
operator|->
name|base
argument_list|,
name|evhttp_connection_retry
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
comment|/* XXXX handle failure from evhttp_add_event */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|evcon
operator|->
name|retry_cnt
condition|;
operator|++
name|i
control|)
block|{
name|tv_retry
operator|.
name|tv_usec
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|tv_retry
operator|.
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|tv_retry
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
name|tv_retry
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
block|}
name|tv_retry
operator|.
name|tv_sec
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|tv_retry
operator|.
name|tv_sec
operator|>
literal|3600
condition|)
block|{
name|tv_retry
operator|.
name|tv_sec
operator|=
literal|3600
expr_stmt|;
name|tv_retry
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|event_add
argument_list|(
operator|&
name|evcon
operator|->
name|retry_ev
argument_list|,
operator|&
name|tv_retry
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|retry_cnt
operator|++
expr_stmt|;
return|return;
block|}
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
comment|/* 	 * User callback can do evhttp_make_request() on the same 	 * evcon so new request will be added to evcon->requests.  To 	 * avoid freeing it prematurely we iterate over the copy of 	 * the queue. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|requests
argument_list|)
expr_stmt|;
while|while
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|evhttp_request
modifier|*
name|request
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|request
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|requests
argument_list|,
name|request
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* for now, we just signal all requests by executing their callbacks */
while|while
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|requests
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|evhttp_request
modifier|*
name|request
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|requests
argument_list|)
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|requests
argument_list|,
name|request
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|request
operator|->
name|evcon
operator|=
name|NULL
expr_stmt|;
comment|/* we might want to set an error here */
name|request
operator|->
name|cb
argument_list|(
name|request
argument_list|,
name|request
operator|->
name|cb_arg
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_error_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
if|if
condition|(
name|evcon
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
name|evcon
operator|->
name|fd
operator|=
name|bufferevent_getfd
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|evcon
operator|->
name|state
condition|)
block|{
case|case
name|EVCON_CONNECTING
case|:
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_TIMEOUT
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: connection timeout for \"%s:%d\" on "
name|EV_SOCK_FMT
operator|,
name|__func__
operator|,
name|evcon
operator|->
name|address
operator|,
name|evcon
operator|->
name|port
operator|,
name|EV_SOCK_ARG
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|evhttp_connection_cb_cleanup
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|EVCON_READING_BODY
case|:
if|if
condition|(
operator|!
name|req
operator|->
name|chunked
operator|&&
name|req
operator|->
name|ntoread
operator|<
literal|0
operator|&&
name|what
operator|==
operator|(
name|BEV_EVENT_READING
operator||
name|BEV_EVENT_EOF
operator|)
condition|)
block|{
comment|/* EOF on read can be benign */
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|EVCON_DISCONNECTED
case|:
case|case
name|EVCON_IDLE
case|:
case|case
name|EVCON_READING_FIRSTLINE
case|:
case|case
name|EVCON_READING_HEADERS
case|:
case|case
name|EVCON_READING_TRAILER
case|:
case|case
name|EVCON_WRITING
case|:
default|default:
break|break;
block|}
comment|/* when we are in close detect mode, a read error means that 	 * the other side closed their connection. 	 */
if|if
condition|(
name|evcon
operator|->
name|flags
operator|&
name|EVHTTP_CON_CLOSEDETECT
condition|)
block|{
name|evcon
operator|->
name|flags
operator|&=
operator|~
name|EVHTTP_CON_CLOSEDETECT
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|http_server
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* For connections from the client, we just 		 * reset the connection so that it becomes 		 * disconnected. 		 */
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_IDLE
argument_list|)
expr_stmt|;
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|what
operator|&
name|BEV_EVENT_TIMEOUT
condition|)
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_TIMEOUT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|&
operator|(
name|BEV_EVENT_EOF
operator||
name|BEV_EVENT_ERROR
operator|)
condition|)
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_EOF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|what
operator|==
name|BEV_EVENT_CONNECTED
condition|)
block|{ 	}
else|else
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_BUFFER_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Event callback for asynchronous connection attempt.  */
end_comment

begin_function
specifier|static
name|void
name|evhttp_connection_cb
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bufev
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ev_socklen_t
name|errsz
init|=
sizeof|sizeof
argument_list|(
name|error
argument_list|)
decl_stmt|;
name|socklen_t
name|conn_address_len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|evcon
operator|->
name|conn_address
argument_list|)
decl_stmt|;
if|if
condition|(
name|evcon
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
name|evcon
operator|->
name|fd
operator|=
name|bufferevent_getfd
argument_list|(
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|what
operator|&
name|BEV_EVENT_CONNECTED
operator|)
condition|)
block|{
comment|/* some operating systems return ECONNREFUSED immediately 		 * when connecting to a local address.  the cleanup is going 		 * to reschedule this function call. 		 */
ifndef|#
directive|ifndef
name|_WIN32
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
name|evhttp_error_cb
argument_list|(
name|bufev
argument_list|,
name|what
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evcon
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: bufferevent_getfd returned -1"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Check if the connection completed */
if|if
condition|(
name|getsockopt
argument_list|(
name|evcon
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|error
argument_list|,
operator|&
name|errsz
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: getsockopt for \"%s:%d\" on "
name|EV_SOCK_FMT
operator|,
name|__func__
operator|,
name|evcon
operator|->
name|address
operator|,
name|evcon
operator|->
name|port
operator|,
name|EV_SOCK_ARG
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: connect failed for \"%s:%d\" on "
name|EV_SOCK_FMT
literal|": %s"
operator|,
name|__func__
operator|,
name|evcon
operator|->
name|address
operator|,
name|evcon
operator|->
name|port
operator|,
name|EV_SOCK_ARG
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
operator|,
name|evutil_socket_error_to_string
argument_list|(
name|error
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* We are connected to the server now */
name|event_debug
argument_list|(
operator|(
literal|"%s: connected to \"%s:%d\" on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|evcon
operator|->
name|address
operator|,
name|evcon
operator|->
name|port
operator|,
name|EV_SOCK_ARG
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the retry count as we were successful in connecting */
name|evcon
operator|->
name|retry_cnt
operator|=
literal|0
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_IDLE
expr_stmt|;
if|if
condition|(
operator|!
name|evcon
operator|->
name|conn_address
condition|)
block|{
name|evcon
operator|->
name|conn_address
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|evcon
operator|->
name|conn_address
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getpeername
argument_list|(
name|evcon
operator|->
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|evcon
operator|->
name|conn_address
argument_list|,
operator|&
name|conn_address_len
argument_list|)
condition|)
block|{
name|mm_free
argument_list|(
name|evcon
operator|->
name|conn_address
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|conn_address
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* reset the bufferevent cbs */
name|bufferevent_setcb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evhttp_read_cb
argument_list|,
name|evhttp_write_cb
argument_list|,
name|evhttp_error_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evutil_timerisset
argument_list|(
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|timeval
name|read_tv
init|=
block|{
name|HTTP_READ_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|timeval
name|write_tv
init|=
block|{
name|HTTP_WRITE_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
operator|&
name|read_tv
argument_list|,
operator|&
name|write_tv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
operator|&
name|evcon
operator|->
name|timeout
argument_list|,
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* try to start requests that have queued up on this connection */
name|evhttp_request_dispatch
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
name|cleanup
label|:
name|evhttp_connection_cb_cleanup
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if we got a valid response code.  */
end_comment

begin_function
specifier|static
name|int
name|evhttp_valid_response_code
parameter_list|(
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_parse_http_version
parameter_list|(
specifier|const
name|char
modifier|*
name|version
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|n
init|=
name|sscanf
argument_list|(
name|version
argument_list|,
literal|"HTTP/%d.%d%c"
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
operator|||
name|major
operator|>
literal|1
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: bad version %s on message %p from %s"
operator|,
name|__func__
operator|,
name|version
operator|,
name|req
operator|,
name|req
operator|->
name|remote_host
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|req
operator|->
name|major
operator|=
name|major
expr_stmt|;
name|req
operator|->
name|minor
operator|=
name|minor
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the status line of a web server */
end_comment

begin_function
specifier|static
name|int
name|evhttp_parse_response_line
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|protocol
decl_stmt|;
name|char
modifier|*
name|number
decl_stmt|;
specifier|const
name|char
modifier|*
name|readable
init|=
literal|""
decl_stmt|;
name|protocol
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|number
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|readable
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|evhttp_parse_http_version
argument_list|(
name|protocol
argument_list|,
name|req
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|req
operator|->
name|response_code
operator|=
name|atoi
argument_list|(
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evhttp_valid_response_code
argument_list|(
name|req
operator|->
name|response_code
argument_list|)
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: bad response code \"%s\""
operator|,
name|__func__
operator|,
name|number
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|response_code_line
operator|=
name|mm_strdup
argument_list|(
name|readable
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the first line of a HTTP request */
end_comment

begin_function
specifier|static
name|int
name|evhttp_parse_request_line
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|method
decl_stmt|;
name|char
modifier|*
name|uri
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme
decl_stmt|;
name|size_t
name|method_len
decl_stmt|;
name|enum
name|evhttp_cmd_type
name|type
decl_stmt|;
comment|/* Parse the request line */
name|method
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|uri
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|version
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|method_len
operator|=
operator|(
name|uri
operator|-
name|method
operator|)
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|EVHTTP_REQ_UNKNOWN_
expr_stmt|;
comment|/* First line */
switch|switch
condition|(
name|method_len
condition|)
block|{
case|case
literal|3
case|:
comment|/* The length of the method string is 3, meaning it can only be one of two methods: GET or PUT */
comment|/* Since both GET and PUT share the same character 'T' at the end, 		 * if the string doesn't have 'T', we can immediately determine this 		 * is an invalid HTTP method */
if|if
condition|(
name|method
index|[
literal|2
index|]
operator|!=
literal|'T'
condition|)
block|{
break|break;
block|}
switch|switch
condition|(
operator|*
name|method
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* This first byte is 'G', so make sure the next byte is 			 * 'E', if it isn't then this isn't a valid method */
if|if
condition|(
name|method
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_GET
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
comment|/* First byte is P, check second byte for 'U', if not, 			 * we know it's an invalid method */
if|if
condition|(
name|method
index|[
literal|1
index|]
operator|==
literal|'U'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_PUT
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|4
case|:
comment|/* The method length is 4 bytes, leaving only the methods "POST" and "HEAD" */
switch|switch
condition|(
operator|*
name|method
condition|)
block|{
case|case
literal|'P'
case|:
if|if
condition|(
name|method
index|[
literal|3
index|]
operator|==
literal|'T'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'S'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_POST
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|method
index|[
literal|3
index|]
operator|==
literal|'D'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'A'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_HEAD
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|5
case|:
comment|/* Method length is 5 bytes, which can only encompass PATCH and TRACE */
switch|switch
condition|(
operator|*
name|method
condition|)
block|{
case|case
literal|'P'
case|:
if|if
condition|(
name|method
index|[
literal|4
index|]
operator|==
literal|'H'
operator|&&
name|method
index|[
literal|3
index|]
operator|==
literal|'C'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'T'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_PATCH
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|method
index|[
literal|4
index|]
operator|==
literal|'E'
operator|&&
name|method
index|[
literal|3
index|]
operator|==
literal|'C'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'A'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_TRACE
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|6
case|:
comment|/* Method length is 6, only valid method 6 bytes in length is DELEte */
comment|/* If the first byte isn't 'D' then it's invalid */
if|if
condition|(
operator|*
name|method
operator|!=
literal|'D'
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|method
index|[
literal|5
index|]
operator|==
literal|'E'
operator|&&
name|method
index|[
literal|4
index|]
operator|==
literal|'T'
operator|&&
name|method
index|[
literal|3
index|]
operator|==
literal|'E'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'L'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_DELETE
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
comment|/* Method length is 7, only valid methods are "OPTIONS" and "CONNECT" */
switch|switch
condition|(
operator|*
name|method
condition|)
block|{
case|case
literal|'O'
case|:
if|if
condition|(
name|method
index|[
literal|6
index|]
operator|==
literal|'S'
operator|&&
name|method
index|[
literal|5
index|]
operator|==
literal|'N'
operator|&&
name|method
index|[
literal|4
index|]
operator|==
literal|'O'
operator|&&
name|method
index|[
literal|3
index|]
operator|==
literal|'I'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'T'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'P'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_OPTIONS
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|method
index|[
literal|6
index|]
operator|==
literal|'T'
operator|&&
name|method
index|[
literal|5
index|]
operator|==
literal|'C'
operator|&&
name|method
index|[
literal|4
index|]
operator|==
literal|'E'
operator|&&
name|method
index|[
literal|3
index|]
operator|==
literal|'N'
operator|&&
name|method
index|[
literal|2
index|]
operator|==
literal|'N'
operator|&&
name|method
index|[
literal|1
index|]
operator|==
literal|'O'
condition|)
block|{
name|type
operator|=
name|EVHTTP_REQ_CONNECT
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* switch */
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|==
name|EVHTTP_REQ_UNKNOWN_
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: bad method %s on request %p from %s"
operator|,
name|__func__
operator|,
name|method
operator|,
name|req
operator|,
name|req
operator|->
name|remote_host
operator|)
argument_list|)
expr_stmt|;
comment|/* No error yet; we'll give a better error later when                  * we see that req->type is unsupported. */
block|}
name|req
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|evhttp_parse_http_version
argument_list|(
name|version
argument_list|,
name|req
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|req
operator|->
name|uri
operator|=
name|mm_strdup
argument_list|(
name|uri
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: mm_strdup"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|uri_elems
operator|=
name|evhttp_uri_parse_with_flags
argument_list|(
name|req
operator|->
name|uri
argument_list|,
name|EVHTTP_URI_NONCONFORMANT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* If we have an absolute-URI, check to see if it is an http request 	   for a known vhost or server alias. If we don't know about this 	   host, we consider it a proxy request. */
name|scheme
operator|=
name|evhttp_uri_get_scheme
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|evhttp_uri_get_host
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheme
operator|&&
operator|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"http"
argument_list|)
operator|||
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|)
operator|&&
name|hostname
operator|&&
operator|!
name|evhttp_find_vhost
argument_list|(
name|req
operator|->
name|evcon
operator|->
name|http_server
argument_list|,
name|NULL
argument_list|,
name|hostname
argument_list|)
condition|)
name|req
operator|->
name|flags
operator||=
name|EVHTTP_PROXY_REQUEST
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_find_header
parameter_list|(
specifier|const
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|header
argument_list|,
argument|headers
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|evutil_ascii_strcasecmp
argument_list|(
name|header
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|header
operator|->
name|value
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_clear_headers
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
decl_stmt|;
for|for
control|(
name|header
operator|=
name|TAILQ_FIRST
argument_list|(
name|headers
argument_list|)
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|TAILQ_FIRST
argument_list|(
name|headers
argument_list|)
control|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|headers
argument_list|,
name|header
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
operator|->
name|key
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
operator|->
name|value
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns 0,  if the header was successfully removed.  * Returns -1, if the header could not be found.  */
end_comment

begin_function
name|int
name|evhttp_remove_header
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|header
argument_list|,
argument|headers
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|evutil_ascii_strcasecmp
argument_list|(
name|header
operator|->
name|key
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Free and remove the header that we found */
name|TAILQ_REMOVE
argument_list|(
name|headers
argument_list|,
name|header
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
operator|->
name|key
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
operator|->
name|value
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_header_is_valid_value
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|value
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"\r\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* we really expect only one new line */
name|p
operator|+=
name|strspn
argument_list|(
name|p
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
comment|/* we expect a space or tab for continuation */
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_add_header
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: key: %s val: %s\n"
operator|,
name|__func__
operator|,
name|key
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|key
argument_list|,
literal|'\r'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|key
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* drop illegal headers */
name|event_debug
argument_list|(
operator|(
literal|"%s: dropping illegal header key\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|evhttp_header_is_valid_value
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: dropping illegal header value\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|evhttp_add_header_internal
argument_list|(
name|headers
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_add_header_internal
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evkeyval
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|header
operator|->
name|key
operator|=
name|mm_strdup
argument_list|(
name|key
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|header
operator|->
name|value
operator|=
name|mm_strdup
argument_list|(
name|value
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|header
operator|->
name|key
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|headers
argument_list|,
name|header
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parses header lines from a request or a response into the specified  * request object given an event buffer.  *  * Returns  *   DATA_CORRUPTED      on error  *   MORE_DATA_EXPECTED  when we need to read more headers  *   ALL_DATA_READ       when all headers have been read.  */
end_comment

begin_function
name|enum
name|message_read_status
name|evhttp_parse_firstline_
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|message_read_status
name|status
init|=
name|ALL_DATA_READ
decl_stmt|;
name|size_t
name|line_length
decl_stmt|;
comment|/* XXX try */
name|line
operator|=
name|evbuffer_readln
argument_list|(
name|buffer
argument_list|,
operator|&
name|line_length
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|evcon
operator|!=
name|NULL
operator|&&
name|evbuffer_get_length
argument_list|(
name|buffer
argument_list|)
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_headers_size
condition|)
return|return
operator|(
name|DATA_TOO_LONG
operator|)
return|;
else|else
return|return
operator|(
name|MORE_DATA_EXPECTED
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|evcon
operator|!=
name|NULL
operator|&&
name|line_length
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_headers_size
condition|)
block|{
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|DATA_TOO_LONG
operator|)
return|;
block|}
name|req
operator|->
name|headers_size
operator|=
name|line_length
expr_stmt|;
switch|switch
condition|(
name|req
operator|->
name|kind
condition|)
block|{
case|case
name|EVHTTP_REQUEST
case|:
if|if
condition|(
name|evhttp_parse_request_line
argument_list|(
name|req
argument_list|,
name|line
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
name|DATA_CORRUPTED
expr_stmt|;
break|break;
case|case
name|EVHTTP_RESPONSE
case|:
if|if
condition|(
name|evhttp_parse_response_line
argument_list|(
name|req
argument_list|,
name|line
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
name|DATA_CORRUPTED
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|DATA_CORRUPTED
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_append_to_last_header
parameter_list|(
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|evkeyval
modifier|*
name|header
init|=
name|TAILQ_LAST
argument_list|(
name|headers
argument_list|,
name|evkeyvalq
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newval
decl_stmt|;
name|size_t
name|old_len
decl_stmt|,
name|line_len
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_len
operator|=
name|strlen
argument_list|(
name|header
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Strip space from start and end of line. */
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|)
operator|++
name|line
expr_stmt|;
name|evutil_rtrim_lws_
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line_len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|newval
operator|=
name|mm_realloc
argument_list|(
name|header
operator|->
name|value
argument_list|,
name|old_len
operator|+
name|line_len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|newval
index|[
name|old_len
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|newval
operator|+
name|old_len
operator|+
literal|1
argument_list|,
name|line
argument_list|,
name|line_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|header
operator|->
name|value
operator|=
name|newval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|message_read_status
name|evhttp_parse_headers_
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|buffer
parameter_list|)
block|{
name|enum
name|message_read_status
name|errcode
init|=
name|DATA_CORRUPTED
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|enum
name|message_read_status
name|status
init|=
name|MORE_DATA_EXPECTED
decl_stmt|;
name|struct
name|evkeyvalq
modifier|*
name|headers
init|=
name|req
operator|->
name|input_headers
decl_stmt|;
name|size_t
name|line_length
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|evbuffer_readln
argument_list|(
name|buffer
argument_list|,
operator|&
name|line_length
argument_list|,
name|EVBUFFER_EOL_CRLF
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|skey
decl_stmt|,
modifier|*
name|svalue
decl_stmt|;
name|req
operator|->
name|headers_size
operator|+=
name|line_length
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|evcon
operator|!=
name|NULL
operator|&&
name|req
operator|->
name|headers_size
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_headers_size
condition|)
block|{
name|errcode
operator|=
name|DATA_TOO_LONG
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
block|{
comment|/* Last header - Done */
name|status
operator|=
name|ALL_DATA_READ
expr_stmt|;
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check if this is a continuation line */
if|if
condition|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|evhttp_append_to_last_header
argument_list|(
name|headers
argument_list|,
name|line
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Processing of header lines */
name|svalue
operator|=
name|line
expr_stmt|;
name|skey
operator|=
name|strsep
argument_list|(
operator|&
name|svalue
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|svalue
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|svalue
operator|+=
name|strspn
argument_list|(
name|svalue
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|evutil_rtrim_lws_
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|evhttp_add_header
argument_list|(
name|headers
argument_list|,
name|skey
argument_list|,
name|svalue
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error
goto|;
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|MORE_DATA_EXPECTED
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|evcon
operator|!=
name|NULL
operator|&&
name|req
operator|->
name|headers_size
operator|+
name|evbuffer_get_length
argument_list|(
name|buffer
argument_list|)
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_headers_size
condition|)
return|return
operator|(
name|DATA_TOO_LONG
operator|)
return|;
block|}
return|return
operator|(
name|status
operator|)
return|;
name|error
label|:
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|errcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_get_body_length
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evkeyvalq
modifier|*
name|headers
init|=
name|req
operator|->
name|input_headers
decl_stmt|;
specifier|const
name|char
modifier|*
name|content_length
decl_stmt|;
specifier|const
name|char
modifier|*
name|connection
decl_stmt|;
name|content_length
operator|=
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Content-Length"
argument_list|)
expr_stmt|;
name|connection
operator|=
name|evhttp_find_header
argument_list|(
name|headers
argument_list|,
literal|"Connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_length
operator|==
name|NULL
operator|&&
name|connection
operator|==
name|NULL
condition|)
name|req
operator|->
name|ntoread
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|content_length
operator|==
name|NULL
operator|&&
name|evutil_ascii_strcasecmp
argument_list|(
name|connection
argument_list|,
literal|"Close"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Bad combination, we don't know when it will end */
name|event_warnx
argument_list|(
literal|"%s: we got no content length, but the "
literal|"server wants to keep the connection open: %s."
argument_list|,
name|__func__
argument_list|,
name|connection
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|content_length
operator|==
name|NULL
condition|)
block|{
name|req
operator|->
name|ntoread
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|ev_int64_t
name|ntoread
init|=
name|evutil_strtoll
argument_list|(
name|content_length
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|content_length
operator|==
literal|'\0'
operator|||
operator|*
name|endp
operator|!=
literal|'\0'
operator|||
name|ntoread
operator|<
literal|0
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: illegal content length: %s"
operator|,
name|__func__
operator|,
name|content_length
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|req
operator|->
name|ntoread
operator|=
name|ntoread
expr_stmt|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: bytes to read: "
name|EV_I64_FMT
literal|" (in buffer "
name|EV_SIZE_FMT
literal|")\n"
operator|,
name|__func__
operator|,
name|EV_I64_ARG
argument_list|(
name|req
operator|->
name|ntoread
argument_list|)
operator|,
name|EV_SIZE_ARG
argument_list|(
name|evbuffer_get_length
argument_list|(
name|bufferevent_get_input
argument_list|(
name|req
operator|->
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_method_may_have_body
parameter_list|(
name|enum
name|evhttp_cmd_type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EVHTTP_REQ_POST
case|:
case|case
name|EVHTTP_REQ_PUT
case|:
case|case
name|EVHTTP_REQ_PATCH
case|:
return|return
literal|1
return|;
case|case
name|EVHTTP_REQ_TRACE
case|:
return|return
literal|0
return|;
comment|/* XXX May any of the below methods have a body? */
case|case
name|EVHTTP_REQ_GET
case|:
case|case
name|EVHTTP_REQ_HEAD
case|:
case|case
name|EVHTTP_REQ_DELETE
case|:
case|case
name|EVHTTP_REQ_OPTIONS
case|:
case|case
name|EVHTTP_REQ_CONNECT
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_get_body
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|xfer_enc
decl_stmt|;
comment|/* If this is a request without a body, then we are done */
if|if
condition|(
name|req
operator|->
name|kind
operator|==
name|EVHTTP_REQUEST
operator|&&
operator|!
name|evhttp_method_may_have_body
argument_list|(
name|req
operator|->
name|type
argument_list|)
condition|)
block|{
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
name|evcon
operator|->
name|state
operator|=
name|EVCON_READING_BODY
expr_stmt|;
name|xfer_enc
operator|=
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|input_headers
argument_list|,
literal|"Transfer-Encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer_enc
operator|!=
name|NULL
operator|&&
name|evutil_ascii_strcasecmp
argument_list|(
name|xfer_enc
argument_list|,
literal|"chunked"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|req
operator|->
name|chunked
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|ntoread
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|evhttp_get_body_length
argument_list|(
name|req
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_INVALID_HEADER
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|req
operator|->
name|kind
operator|==
name|EVHTTP_REQUEST
operator|&&
name|req
operator|->
name|ntoread
operator|<
literal|1
condition|)
block|{
comment|/* An incoming request with no content-length and no 			 * transfer-encoding has no body. */
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Should we send a 100 Continue status line? */
if|if
condition|(
name|req
operator|->
name|kind
operator|==
name|EVHTTP_REQUEST
operator|&&
name|REQ_VERSION_ATLEAST
argument_list|(
name|req
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|expect
decl_stmt|;
name|expect
operator|=
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|input_headers
argument_list|,
literal|"Expect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expect
condition|)
block|{
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|expect
argument_list|,
literal|"100-continue"
argument_list|)
condition|)
block|{
comment|/* XXX It would be nice to do some sanity 				   checking here. Does the resource exist? 				   Should the resource accept post requests? If 				   no, we should respond with an error. For 				   now, just optimistically tell the client to 				   send their message body. */
if|if
condition|(
name|req
operator|->
name|ntoread
operator|>
literal|0
condition|)
block|{
comment|/* ntoread is ev_int64_t, max_body_size is ev_uint64_t */
if|if
condition|(
operator|(
name|req
operator|->
name|evcon
operator|->
name|max_body_size
operator|<=
name|EV_INT64_MAX
operator|)
operator|&&
operator|(
name|ev_uint64_t
operator|)
name|req
operator|->
name|ntoread
operator|>
name|req
operator|->
name|evcon
operator|->
name|max_body_size
condition|)
block|{
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_ENTITYTOOLARGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|evbuffer_get_length
argument_list|(
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|)
condition|)
name|evhttp_send_continue
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_EXPECTATIONFAILED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|evhttp_read_body
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in evhttp_read_body */
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_read_firstline
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|enum
name|message_read_status
name|res
decl_stmt|;
name|res
operator|=
name|evhttp_parse_firstline_
argument_list|(
name|req
argument_list|,
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|DATA_CORRUPTED
operator|||
name|res
operator|==
name|DATA_TOO_LONG
condition|)
block|{
comment|/* Error while reading, terminate */
name|event_debug
argument_list|(
operator|(
literal|"%s: bad header lines on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|EV_SOCK_ARG
argument_list|(
name|evcon
operator|->
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_INVALID_HEADER
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|MORE_DATA_EXPECTED
condition|)
block|{
comment|/* Need more header lines */
return|return;
block|}
name|evcon
operator|->
name|state
operator|=
name|EVCON_READING_HEADERS
expr_stmt|;
name|evhttp_read_header
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_read_header
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|enum
name|message_read_status
name|res
decl_stmt|;
name|evutil_socket_t
name|fd
init|=
name|evcon
operator|->
name|fd
decl_stmt|;
name|res
operator|=
name|evhttp_parse_headers_
argument_list|(
name|req
argument_list|,
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|DATA_CORRUPTED
operator|||
name|res
operator|==
name|DATA_TOO_LONG
condition|)
block|{
comment|/* Error while reading, terminate */
name|event_debug
argument_list|(
operator|(
literal|"%s: bad header lines on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_INVALID_HEADER
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|MORE_DATA_EXPECTED
condition|)
block|{
comment|/* Need more header lines */
return|return;
block|}
comment|/* Disable reading for now */
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
comment|/* Callback can shut down connection with negative return value */
if|if
condition|(
name|req
operator|->
name|header_cb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|req
operator|->
name|header_cb
call|)
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|cb_arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_EOF
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Done reading headers, do the real work */
switch|switch
condition|(
name|req
operator|->
name|kind
condition|)
block|{
case|case
name|EVHTTP_REQUEST
case|:
name|event_debug
argument_list|(
operator|(
literal|"%s: checking for post data on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|evhttp_get_body
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in evhttp_get_body */
break|break;
case|case
name|EVHTTP_RESPONSE
case|:
comment|/* Start over if we got a 100 Continue response. */
if|if
condition|(
name|req
operator|->
name|response_code
operator|==
literal|100
condition|)
block|{
name|evhttp_start_read_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|evhttp_response_needs_body
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: skipping body for code %d\n"
operator|,
name|__func__
operator|,
name|req
operator|->
name|response_code
operator|)
argument_list|)
expr_stmt|;
name|evhttp_connection_done
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: start of read body for %s on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|req
operator|->
name|remote_host
operator|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|evhttp_get_body
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* note the request may have been freed in 			 * evhttp_get_body */
block|}
break|break;
default|default:
name|event_warnx
argument_list|(
literal|"%s: bad header on "
name|EV_SOCK_FMT
argument_list|,
name|__func__
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_INVALID_HEADER
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* request may have been freed above */
block|}
end_function

begin_comment
comment|/*  * Creates a TCP connection to the specified port and executes a callback  * when finished.  Failure or success is indicate by the passed connection  * object.  *  * Although this interface accepts a hostname, it is intended to take  * only numeric hostnames so that non-blocking DNS resolution can  * happen elsewhere.  */
end_comment

begin_function
name|struct
name|evhttp_connection
modifier|*
name|evhttp_connection_new
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
return|return
operator|(
name|evhttp_connection_base_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|address
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_connection
modifier|*
name|evhttp_connection_base_bufferevent_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_base
modifier|*
name|dnsbase
parameter_list|,
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|NULL
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"Attempting connection to %s:%d\n"
operator|,
name|address
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|evcon
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_connection
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|evcon
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|evcon
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|evcon
operator|->
name|max_headers_size
operator|=
name|EV_SIZE_MAX
expr_stmt|;
name|evcon
operator|->
name|max_body_size
operator|=
name|EV_SIZE_MAX
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|retry_cnt
operator|=
name|evcon
operator|->
name|retry_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|evcon
operator|->
name|address
operator|=
name|mm_strdup
argument_list|(
name|address
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|bev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bev
operator|=
name|bufferevent_socket_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: bufferevent_socket_new failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|bufferevent_setcb
argument_list|(
name|bev
argument_list|,
name|evhttp_read_cb
argument_list|,
name|evhttp_write_cb
argument_list|,
name|evhttp_error_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|bufev
operator|=
name|bev
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_DISCONNECTED
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|initial_retry_timeout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|evcon
operator|->
name|initial_retry_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
block|{
name|evcon
operator|->
name|base
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|bufferevent_get_base
argument_list|(
name|bev
argument_list|)
operator|!=
name|base
condition|)
name|bufferevent_base_set
argument_list|(
name|base
argument_list|,
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
block|}
name|event_deferred_cb_init_
argument_list|(
operator|&
name|evcon
operator|->
name|read_more_deferred_cb
argument_list|,
name|bufferevent_get_priority
argument_list|(
name|bev
argument_list|)
argument_list|,
name|evhttp_deferred_read_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|dns_base
operator|=
name|dnsbase
expr_stmt|;
return|return
operator|(
name|evcon
operator|)
return|;
name|error
label|:
if|if
condition|(
name|evcon
operator|!=
name|NULL
condition|)
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent
modifier|*
name|evhttp_connection_get_bufferevent
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
return|return
name|evcon
operator|->
name|bufev
return|;
block|}
end_function

begin_function
name|struct
name|evhttp
modifier|*
name|evhttp_connection_get_server
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
return|return
name|evcon
operator|->
name|http_server
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_connection
modifier|*
name|evhttp_connection_base_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|evdns_base
modifier|*
name|dnsbase
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
return|return
name|evhttp_connection_base_bufferevent_new
argument_list|(
name|base
argument_list|,
name|dnsbase
argument_list|,
name|NULL
argument_list|,
name|address
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_base
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|base
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_DISCONNECTED
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|bufferevent_base_set
argument_list|(
name|base
argument_list|,
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_timeout
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|int
name|timeout_in_secs
parameter_list|)
block|{
if|if
condition|(
name|timeout_in_secs
operator|==
operator|-
literal|1
condition|)
name|evhttp_connection_set_timeout_tv
argument_list|(
name|evcon
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|timeout_in_secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|evhttp_connection_set_timeout_tv
argument_list|(
name|evcon
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_timeout_tv
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|tv
condition|)
block|{
name|evcon
operator|->
name|timeout
operator|=
operator|*
name|tv
expr_stmt|;
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
operator|&
name|evcon
operator|->
name|timeout
argument_list|,
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|timeval
name|read_tv
init|=
block|{
name|HTTP_READ_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|struct
name|timeval
name|write_tv
init|=
block|{
name|HTTP_WRITE_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
operator|&
name|read_tv
argument_list|,
operator|&
name|write_tv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_initial_retry_tv
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|tv
condition|)
block|{
name|evcon
operator|->
name|initial_retry_timeout
operator|=
operator|*
name|tv
expr_stmt|;
block|}
else|else
block|{
name|evutil_timerclear
argument_list|(
operator|&
name|evcon
operator|->
name|initial_retry_timeout
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|initial_retry_timeout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_retries
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|int
name|retry_max
parameter_list|)
block|{
name|evcon
operator|->
name|retry_max
operator|=
name|retry_max
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_set_closecb
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|evcon
operator|->
name|closecb
operator|=
name|cb
expr_stmt|;
name|evcon
operator|->
name|closecb_arg
operator|=
name|cbarg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_connection_get_peer
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|char
modifier|*
modifier|*
name|address
parameter_list|,
name|ev_uint16_t
modifier|*
name|port
parameter_list|)
block|{
operator|*
name|address
operator|=
name|evcon
operator|->
name|address
expr_stmt|;
operator|*
name|port
operator|=
name|evcon
operator|->
name|port
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|sockaddr
modifier|*
name|evhttp_connection_get_addr
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|evcon
operator|->
name|conn_address
return|;
block|}
end_function

begin_function
name|int
name|evhttp_connection_connect_
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|int
name|old_state
init|=
name|evcon
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|evcon
operator|->
name|state
operator|==
name|EVCON_CONNECTING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|evhttp_connection_reset_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|evcon
operator|->
name|flags
operator|&
name|EVHTTP_CON_INCOMING
operator|)
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|flags
operator||=
name|EVHTTP_CON_OUTGOING
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|bind_address
operator|||
name|evcon
operator|->
name|bind_port
condition|)
block|{
name|evcon
operator|->
name|fd
operator|=
name|bind_socket
argument_list|(
name|evcon
operator|->
name|bind_address
argument_list|,
name|evcon
operator|->
name|bind_port
argument_list|,
literal|0
comment|/*reuse*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: failed to bind to \"%s\""
operator|,
name|__func__
operator|,
name|evcon
operator|->
name|bind_address
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bufferevent_setfd
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evcon
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_setfd
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set up a callback for successful connection setup */
name|bufferevent_setcb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|NULL
comment|/* evhttp_read_cb */
argument_list|,
name|NULL
comment|/* evhttp_write_cb */
argument_list|,
name|evhttp_connection_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evutil_timerisset
argument_list|(
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|timeval
name|conn_tv
init|=
block|{
name|HTTP_CONNECT_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|NULL
argument_list|,
operator|&
name|conn_tv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_set_timeouts
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|NULL
argument_list|,
operator|&
name|evcon
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* make sure that we get a write callback */
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_CONNECTING
expr_stmt|;
if|if
condition|(
name|bufferevent_socket_connect_hostname
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evcon
operator|->
name|dns_base
argument_list|,
name|AF_UNSPEC
argument_list|,
name|evcon
operator|->
name|address
argument_list|,
name|evcon
operator|->
name|port
argument_list|)
operator|<
literal|0
condition|)
block|{
name|evcon
operator|->
name|state
operator|=
name|old_state
expr_stmt|;
name|event_sock_warn
argument_list|(
name|evcon
operator|->
name|fd
argument_list|,
literal|"%s: connection to \"%s\" failed"
argument_list|,
name|__func__
argument_list|,
name|evcon
operator|->
name|address
argument_list|)
expr_stmt|;
comment|/* some operating systems return ECONNREFUSED immediately 		 * when connecting to a local address.  the cleanup is going 		 * to reschedule this function call. 		 */
name|evhttp_connection_cb_cleanup
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Starts an HTTP request on the provided evhttp_connection object.  * If the connection object is not connected to the web server already,  * this will start the connection.  */
end_comment

begin_function
name|int
name|evhttp_make_request
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|enum
name|evhttp_cmd_type
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
comment|/* We are making a request */
name|req
operator|->
name|kind
operator|=
name|EVHTTP_REQUEST
expr_stmt|;
name|req
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|uri
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|uri
operator|=
name|mm_strdup
argument_list|(
name|uri
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set the protocol version if it is not supplied */
if|if
condition|(
operator|!
name|req
operator|->
name|major
operator|&&
operator|!
name|req
operator|->
name|minor
condition|)
block|{
name|req
operator|->
name|major
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|minor
operator|=
literal|1
expr_stmt|;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|evcon
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|req
operator|->
name|evcon
operator|=
name|evcon
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_REQ_OWN_CONNECTION
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* If the connection object is not connected; make it so */
if|if
condition|(
operator|!
name|evhttp_connected
argument_list|(
name|evcon
argument_list|)
condition|)
block|{
name|int
name|res
init|=
name|evhttp_connection_connect_
argument_list|(
name|evcon
argument_list|)
decl_stmt|;
comment|/* evhttp_connection_fail_(), which is called through 		 * evhttp_connection_connect_(), assumes that req lies in 		 * evcon->requests.  Thus, enqueue the request in advance and 		 * remove it in the error case. */
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* 	 * If it's connected already and we are the first in the queue, 	 * then we can dispatch this request immediately.  Otherwise, it 	 * will be dispatched once the pending requests are completed. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|==
name|req
condition|)
name|evhttp_request_dispatch
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_cancel_request
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|req
operator|->
name|evcon
decl_stmt|;
if|if
condition|(
name|evcon
operator|!=
name|NULL
condition|)
block|{
comment|/* We need to remove it from the connection */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|==
name|req
condition|)
block|{
comment|/* it's currently being worked on, so reset 			 * the connection. 			 */
name|evhttp_connection_fail_
argument_list|(
name|evcon
argument_list|,
name|EVREQ_HTTP_REQUEST_CANCEL
argument_list|)
expr_stmt|;
comment|/* connection fail freed the request */
return|return;
block|}
else|else
block|{
comment|/* otherwise, we can just remove it from the 			 * queue 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reads data from file descriptor into request structure  * Request structure needs to be set up correctly.  */
end_comment

begin_function
name|void
name|evhttp_start_read_
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
comment|/* Set up an event to read the headers */
name|bufferevent_disable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_WRITE
argument_list|)
expr_stmt|;
name|bufferevent_enable
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|EV_READ
argument_list|)
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_READING_FIRSTLINE
expr_stmt|;
comment|/* Reset the bufferevent callbacks */
name|bufferevent_setcb
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|evhttp_read_cb
argument_list|,
name|evhttp_write_cb
argument_list|,
name|evhttp_error_cb
argument_list|,
name|evcon
argument_list|)
expr_stmt|;
comment|/* If there's still data pending, process it next time through the 	 * loop.  Don't do it now; that could get recusive. */
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|bufferevent_get_input
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
argument_list|)
condition|)
block|{
name|event_deferred_cb_schedule_
argument_list|(
name|get_deferred_queue
argument_list|(
name|evcon
argument_list|)
argument_list|,
operator|&
name|evcon
operator|->
name|read_more_deferred_cb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_send_done
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|need_close
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|on_complete_cb
operator|!=
name|NULL
condition|)
block|{
name|req
operator|->
name|on_complete_cb
argument_list|(
name|req
argument_list|,
name|req
operator|->
name|on_complete_cb_arg
argument_list|)
expr_stmt|;
block|}
name|need_close
operator|=
operator|(
name|REQ_VERSION_BEFORE
argument_list|(
name|req
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|evhttp_is_connection_keepalive
argument_list|(
name|req
operator|->
name|input_headers
argument_list|)
operator|)
operator|||
name|evhttp_is_connection_close
argument_list|(
name|req
operator|->
name|flags
argument_list|,
name|req
operator|->
name|input_headers
argument_list|)
operator|||
name|evhttp_is_connection_close
argument_list|(
name|req
operator|->
name|flags
argument_list|,
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_REQ_OWN_CONNECTION
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_close
condition|)
block|{
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we have a persistent connection; try to accept another request. */
if|if
condition|(
name|evhttp_associate_new_request_with_connection
argument_list|(
name|evcon
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns an error page.  */
end_comment

begin_function
name|void
name|evhttp_send_error
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|int
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
define|#
directive|define
name|ERR_FORMAT
value|"<HTML><HEAD>\n" \ 	    "<TITLE>%d %s</TITLE>\n" \ 	    "</HEAD><BODY>\n" \ 	    "<H1>%s</H1>\n" \ 	    "</BODY></HTML>\n"
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* if we cannot allocate memory; we just drop the connection */
name|evhttp_connection_free
argument_list|(
name|req
operator|->
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reason
operator|==
name|NULL
condition|)
block|{
name|reason
operator|=
name|evhttp_response_phrase_internal
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|evhttp_response_code_
argument_list|(
name|req
argument_list|,
name|error
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
name|ERR_FORMAT
argument_list|,
name|error
argument_list|,
name|reason
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|evhttp_send_page_
argument_list|(
name|req
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERR_FORMAT
block|}
end_function

begin_comment
comment|/* Requires that headers and response code are already set up */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|evhttp_send
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|databuf
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|req
operator|->
name|evcon
decl_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
block|{
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|)
operator|==
name|req
argument_list|)
expr_stmt|;
comment|/* we expect no more calls form the user on this request */
name|req
operator|->
name|userdone
operator|=
literal|1
expr_stmt|;
comment|/* xxx: not sure if we really should expose the data buffer this way */
if|if
condition|(
name|databuf
operator|!=
name|NULL
condition|)
name|evbuffer_add_buffer
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
comment|/* Adds headers to the response */
name|evhttp_make_header
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|evhttp_write_buffer
argument_list|(
name|evcon
argument_list|,
name|evhttp_send_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_send_reply
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|databuf
parameter_list|)
block|{
name|evhttp_response_code_
argument_list|(
name|req
argument_list|,
name|code
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|evhttp_send
argument_list|(
name|req
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_send_reply_start
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|evhttp_response_code_
argument_list|(
name|req
argument_list|,
name|code
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Length"
argument_list|)
operator|==
name|NULL
operator|&&
name|REQ_VERSION_ATLEAST
argument_list|(
name|req
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|evhttp_response_needs_body
argument_list|(
name|req
argument_list|)
condition|)
block|{
comment|/* 		 * prefer HTTP/1.1 chunked encoding to closing the connection; 		 * note RFC 2616 section 4.4 forbids it with Content-Length: 		 * and it's not necessary then anyway. 		 */
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Transfer-Encoding"
argument_list|,
literal|"chunked"
argument_list|)
expr_stmt|;
name|req
operator|->
name|chunked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|req
operator|->
name|chunked
operator|=
literal|0
expr_stmt|;
block|}
name|evhttp_make_header
argument_list|(
name|req
operator|->
name|evcon
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|evhttp_write_buffer
argument_list|(
name|req
operator|->
name|evcon
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_send_reply_chunk_with_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|databuf
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|req
operator|->
name|evcon
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
decl_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
return|return;
name|output
operator|=
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|databuf
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|evhttp_response_needs_body
argument_list|(
name|req
argument_list|)
condition|)
return|return;
if|if
condition|(
name|req
operator|->
name|chunked
condition|)
block|{
name|evbuffer_add_printf
argument_list|(
name|output
argument_list|,
literal|"%x\r\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|evbuffer_get_length
argument_list|(
name|databuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|evbuffer_add_buffer
argument_list|(
name|output
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|chunked
condition|)
block|{
name|evbuffer_add
argument_list|(
name|output
argument_list|,
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|evhttp_write_buffer
argument_list|(
name|evcon
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_send_reply_chunk
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|databuf
parameter_list|)
block|{
name|evhttp_send_reply_chunk_with_cb
argument_list|(
name|req
argument_list|,
name|databuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_send_reply_end
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
init|=
name|req
operator|->
name|evcon
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output
decl_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
block|{
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
name|output
operator|=
name|bufferevent_get_output
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|)
expr_stmt|;
comment|/* we expect no more calls form the user on this request */
name|req
operator|->
name|userdone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|chunked
condition|)
block|{
name|evbuffer_add
argument_list|(
name|output
argument_list|,
literal|"0\r\n\r\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|evhttp_write_buffer
argument_list|(
name|req
operator|->
name|evcon
argument_list|,
name|evhttp_send_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|req
operator|->
name|chunked
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evbuffer_get_length
argument_list|(
name|output
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* let the connection know that we are done with the request */
name|evhttp_send_done
argument_list|(
name|evcon
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* make the callback execute after all data has been written */
name|evcon
operator|->
name|cb
operator|=
name|evhttp_send_done
expr_stmt|;
name|evcon
operator|->
name|cb_arg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|informational_phrases
index|[]
init|=
block|{
comment|/* 100 */
literal|"Continue"
block|,
comment|/* 101 */
literal|"Switching Protocols"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|success_phrases
index|[]
init|=
block|{
comment|/* 200 */
literal|"OK"
block|,
comment|/* 201 */
literal|"Created"
block|,
comment|/* 202 */
literal|"Accepted"
block|,
comment|/* 203 */
literal|"Non-Authoritative Information"
block|,
comment|/* 204 */
literal|"No Content"
block|,
comment|/* 205 */
literal|"Reset Content"
block|,
comment|/* 206 */
literal|"Partial Content"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|redirection_phrases
index|[]
init|=
block|{
comment|/* 300 */
literal|"Multiple Choices"
block|,
comment|/* 301 */
literal|"Moved Permanently"
block|,
comment|/* 302 */
literal|"Found"
block|,
comment|/* 303 */
literal|"See Other"
block|,
comment|/* 304 */
literal|"Not Modified"
block|,
comment|/* 305 */
literal|"Use Proxy"
block|,
comment|/* 307 */
literal|"Temporary Redirect"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|client_error_phrases
index|[]
init|=
block|{
comment|/* 400 */
literal|"Bad Request"
block|,
comment|/* 401 */
literal|"Unauthorized"
block|,
comment|/* 402 */
literal|"Payment Required"
block|,
comment|/* 403 */
literal|"Forbidden"
block|,
comment|/* 404 */
literal|"Not Found"
block|,
comment|/* 405 */
literal|"Method Not Allowed"
block|,
comment|/* 406 */
literal|"Not Acceptable"
block|,
comment|/* 407 */
literal|"Proxy Authentication Required"
block|,
comment|/* 408 */
literal|"Request Time-out"
block|,
comment|/* 409 */
literal|"Conflict"
block|,
comment|/* 410 */
literal|"Gone"
block|,
comment|/* 411 */
literal|"Length Required"
block|,
comment|/* 412 */
literal|"Precondition Failed"
block|,
comment|/* 413 */
literal|"Request Entity Too Large"
block|,
comment|/* 414 */
literal|"Request-URI Too Large"
block|,
comment|/* 415 */
literal|"Unsupported Media Type"
block|,
comment|/* 416 */
literal|"Requested range not satisfiable"
block|,
comment|/* 417 */
literal|"Expectation Failed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|server_error_phrases
index|[]
init|=
block|{
comment|/* 500 */
literal|"Internal Server Error"
block|,
comment|/* 501 */
literal|"Not Implemented"
block|,
comment|/* 502 */
literal|"Bad Gateway"
block|,
comment|/* 503 */
literal|"Service Unavailable"
block|,
comment|/* 504 */
literal|"Gateway Time-out"
block|,
comment|/* 505 */
literal|"HTTP Version not supported"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|response_class
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|num_responses
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|responses
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|MEMBERSOF
end_ifndef

begin_define
define|#
directive|define
name|MEMBERSOF
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|response_class
name|response_classes
index|[]
init|=
block|{
comment|/* 1xx */
block|{
literal|"Informational"
block|,
name|MEMBERSOF
argument_list|(
name|informational_phrases
argument_list|)
block|,
name|informational_phrases
block|}
block|,
comment|/* 2xx */
block|{
literal|"Success"
block|,
name|MEMBERSOF
argument_list|(
name|success_phrases
argument_list|)
block|,
name|success_phrases
block|}
block|,
comment|/* 3xx */
block|{
literal|"Redirection"
block|,
name|MEMBERSOF
argument_list|(
name|redirection_phrases
argument_list|)
block|,
name|redirection_phrases
block|}
block|,
comment|/* 4xx */
block|{
literal|"Client Error"
block|,
name|MEMBERSOF
argument_list|(
name|client_error_phrases
argument_list|)
block|,
name|client_error_phrases
block|}
block|,
comment|/* 5xx */
block|{
literal|"Server Error"
block|,
name|MEMBERSOF
argument_list|(
name|server_error_phrases
argument_list|)
block|,
name|server_error_phrases
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|evhttp_response_phrase_internal
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|int
name|klass
init|=
name|code
operator|/
literal|100
operator|-
literal|1
decl_stmt|;
name|int
name|subcode
init|=
name|code
operator|%
literal|100
decl_stmt|;
comment|/* Unknown class - can't do any better here */
if|if
condition|(
name|klass
operator|<
literal|0
operator|||
name|klass
operator|>=
operator|(
name|int
operator|)
name|MEMBERSOF
argument_list|(
name|response_classes
argument_list|)
condition|)
return|return
literal|"Unknown Status Class"
return|;
comment|/* Unknown sub-code, return class name at least */
if|if
condition|(
name|subcode
operator|>=
operator|(
name|int
operator|)
name|response_classes
index|[
name|klass
index|]
operator|.
name|num_responses
condition|)
return|return
name|response_classes
index|[
name|klass
index|]
operator|.
name|name
return|;
return|return
name|response_classes
index|[
name|klass
index|]
operator|.
name|responses
index|[
name|subcode
index|]
return|;
block|}
end_function

begin_function
name|void
name|evhttp_response_code_
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|req
operator|->
name|kind
operator|=
name|EVHTTP_RESPONSE
expr_stmt|;
name|req
operator|->
name|response_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|response_code_line
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|response_code_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|NULL
condition|)
name|reason
operator|=
name|evhttp_response_phrase_internal
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|req
operator|->
name|response_code_line
operator|=
name|mm_strdup
argument_list|(
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|response_code_line
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX what else can we do? */
block|}
block|}
end_function

begin_function
name|void
name|evhttp_send_page_
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|struct
name|evbuffer
modifier|*
name|databuf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|req
operator|->
name|major
operator|||
operator|!
name|req
operator|->
name|minor
condition|)
block|{
name|req
operator|->
name|major
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|minor
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|kind
operator|!=
name|EVHTTP_RESPONSE
condition|)
name|evhttp_response_code_
argument_list|(
name|req
argument_list|,
literal|200
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
name|evhttp_clear_headers
argument_list|(
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Content-Type"
argument_list|,
literal|"text/html"
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|req
operator|->
name|output_headers
argument_list|,
literal|"Connection"
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|evhttp_send
argument_list|(
name|req
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|uri_chars
index|[
literal|256
index|]
init|=
block|{
comment|/* 0 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 64 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 128 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 192 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHAR_IS_UNRESERVED
parameter_list|(
name|c
parameter_list|)
define|\
value|(uri_chars[(unsigned char)(c)])
end_define

begin_comment
comment|/*  * Helper functions to encode/decode a string for inclusion in a URI.  * The returned string must be freed by the caller.  */
end_comment

begin_function
name|char
modifier|*
name|evhttp_uriencode
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|ev_ssize_t
name|len
parameter_list|,
name|int
name|space_as_plus
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|buf
init|=
name|evbuffer_new
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
name|end
operator|=
name|uri
operator|+
name|len
expr_stmt|;
else|else
name|end
operator|=
name|uri
operator|+
name|strlen
argument_list|(
name|uri
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|uri
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|CHAR_IS_UNRESERVED
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
name|space_as_plus
condition|)
block|{
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
literal|"%%%02X"
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|evbuffer_add
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NUL-terminator. */
name|result
operator|=
name|mm_malloc
argument_list|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|evbuffer_remove
argument_list|(
name|buf
argument_list|,
name|result
argument_list|,
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|evhttp_encode_uri
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|evhttp_uriencode
argument_list|(
name|str
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * @param decode_plus_ctl: if 1, we decode plus into space.  If 0, we don't.  *     If -1, when true we transform plus to space only after we've seen  *     a ?.  -1 is deprecated.  * @return the number of bytes written to 'ret'.  */
end_comment

begin_function
name|int
name|evhttp_decode_uri_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|size_t
name|length
parameter_list|,
name|char
modifier|*
name|ret
parameter_list|,
name|int
name|decode_plus_ctl
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|decode_plus
init|=
operator|(
name|decode_plus_ctl
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|uri
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|decode_plus_ctl
operator|<
literal|0
condition|)
name|decode_plus
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
operator|&&
name|decode_plus
condition|)
block|{
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|+
literal|2
operator|)
operator|<
name|length
operator|&&
name|c
operator|==
literal|'%'
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|uri
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|uri
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
condition|)
block|{
name|char
name|tmp
index|[
literal|3
index|]
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|uri
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|uri
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|(
name|char
operator|)
name|strtol
argument_list|(
name|tmp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
name|ret
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ret
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_function

begin_comment
comment|/* deprecated */
end_comment

begin_function
name|char
modifier|*
name|evhttp_decode_uri
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mm_malloc
argument_list|(
name|strlen
argument_list|(
name|uri
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: malloc(%lu)"
argument_list|,
name|__func__
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|uri
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|evhttp_decode_uri_internal
argument_list|(
name|uri
argument_list|,
name|strlen
argument_list|(
name|uri
argument_list|)
argument_list|,
name|ret
argument_list|,
operator|-
literal|1
comment|/*always_decode_plus*/
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|evhttp_uridecode
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|int
name|decode_plus
parameter_list|,
name|size_t
modifier|*
name|size_out
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mm_malloc
argument_list|(
name|strlen
argument_list|(
name|uri
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: malloc(%lu)"
argument_list|,
name|__func__
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|uri
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|evhttp_decode_uri_internal
argument_list|(
name|uri
argument_list|,
name|strlen
argument_list|(
name|uri
argument_list|)
argument_list|,
name|ret
argument_list|,
operator|!
operator|!
name|decode_plus
comment|/*always_decode_plus*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_out
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|size_out
operator|=
operator|(
name|size_t
operator|)
name|n
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function to parse out arguments in a query.  * The arguments are separated by key and value.  */
end_comment

begin_function
specifier|static
name|int
name|evhttp_parse_query_impl
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|,
name|int
name|is_whole_uri
parameter_list|)
block|{
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|argument
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|query_part
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|evhttp_uri
modifier|*
name|uri
init|=
name|NULL
decl_stmt|;
name|TAILQ_INIT
argument_list|(
name|headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_whole_uri
condition|)
block|{
name|uri
operator|=
name|evhttp_uri_parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uri
condition|)
goto|goto
name|error
goto|;
name|query_part
operator|=
name|evhttp_uri_get_query
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query_part
operator|=
name|str
expr_stmt|;
block|}
comment|/* No arguments - we are done */
if|if
condition|(
operator|!
name|query_part
operator|||
operator|!
name|strlen
argument_list|(
name|query_part
argument_list|)
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|line
operator|=
name|mm_strdup
argument_list|(
name|query_part
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
name|argument
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|decoded_value
decl_stmt|;
name|argument
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|value
operator|=
name|argument
expr_stmt|;
name|key
operator|=
name|strsep
argument_list|(
operator|&
name|value
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
operator|*
name|key
operator|==
literal|'\0'
condition|)
block|{
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|decoded_value
operator|=
name|mm_malloc
argument_list|(
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: mm_malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|evhttp_decode_uri_internal
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|decoded_value
argument_list|,
literal|1
comment|/*always_decode_plus*/
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"Query Param: %s -> %s\n"
operator|,
name|key
operator|,
name|decoded_value
operator|)
argument_list|)
expr_stmt|;
name|evhttp_add_header_internal
argument_list|(
name|headers
argument_list|,
name|key
argument_list|,
name|decoded_value
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|decoded_value
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
name|error
label|:
name|evhttp_clear_headers
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|line
condition|)
name|mm_free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
condition|)
name|evhttp_uri_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|evhttp_parse_query
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
return|return
name|evhttp_parse_query_impl
argument_list|(
name|uri
argument_list|,
name|headers
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_parse_query_str
parameter_list|(
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|struct
name|evkeyvalq
modifier|*
name|headers
parameter_list|)
block|{
return|return
name|evhttp_parse_query_impl
argument_list|(
name|uri
argument_list|,
name|headers
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|evhttp_cb
modifier|*
name|evhttp_dispatch_callback
parameter_list|(
name|struct
name|httpcbq
modifier|*
name|callbacks
parameter_list|,
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|evhttp_cb
modifier|*
name|cb
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|translated
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Test for different URLs */
name|path
operator|=
name|evhttp_uri_get_path
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
name|offset
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|translated
operator|=
name|mm_malloc
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|evhttp_decode_uri_internal
argument_list|(
name|path
argument_list|,
name|offset
argument_list|,
name|translated
argument_list|,
literal|0
comment|/* decode_plus */
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cb
argument_list|,
argument|callbacks
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cb
operator|->
name|what
argument_list|,
name|translated
argument_list|)
condition|)
block|{
name|mm_free
argument_list|(
name|translated
argument_list|)
expr_stmt|;
return|return
operator|(
name|cb
operator|)
return|;
block|}
block|}
name|mm_free
argument_list|(
name|translated
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|prefix_suffix_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ignorecase
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|pattern
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
operator|*
name|name
operator|==
literal|'\0'
return|;
case|case
literal|'*'
case|:
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|prefix_suffix_match
argument_list|(
name|pattern
argument_list|,
name|name
argument_list|,
name|ignorecase
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|++
name|name
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|c
operator|!=
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|!
name|ignorecase
operator|||
name|EVUTIL_TOLOWER_
argument_list|(
name|c
argument_list|)
operator|!=
name|EVUTIL_TOLOWER_
argument_list|(
operator|*
name|name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|++
name|name
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*    Search the vhost hierarchy beginning with http for a server alias    matching hostname.  If a match is found, and outhttp is non-null,    outhttp is set to the matching http object and 1 is returned. */
end_comment

begin_function
specifier|static
name|int
name|evhttp_find_alias
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evhttp
modifier|*
modifier|*
name|outhttp
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|evhttp_server_alias
modifier|*
name|alias
decl_stmt|;
name|struct
name|evhttp
modifier|*
name|vhost
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|alias
argument_list|,
argument|&http->aliases
argument_list|,
argument|next
argument_list|)
block|{
comment|/* XXX Do we need to handle IP addresses? */
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|alias
operator|->
name|alias
argument_list|,
name|hostname
argument_list|)
condition|)
block|{
if|if
condition|(
name|outhttp
condition|)
operator|*
name|outhttp
operator|=
name|http
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* XXX It might be good to avoid recursion here, but I don't 	   see a way to do that w/o a list. */
name|TAILQ_FOREACH
argument_list|(
argument|vhost
argument_list|,
argument|&http->virtualhosts
argument_list|,
argument|next_vhost
argument_list|)
block|{
if|if
condition|(
name|evhttp_find_alias
argument_list|(
name|vhost
argument_list|,
name|outhttp
argument_list|,
name|hostname
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    Attempts to find the best http object to handle a request for a hostname.    All aliases for the root http object and vhosts are searched for an exact    match. Then, the vhost hierarchy is traversed again for a matching    pattern.     If an alias or vhost is matched, 1 is returned, and outhttp, if non-null,    is set with the best matching http object. If there are no matches, the    root http object is stored in outhttp and 0 is returned. */
end_comment

begin_function
specifier|static
name|int
name|evhttp_find_vhost
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evhttp
modifier|*
modifier|*
name|outhttp
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|vhost
decl_stmt|;
name|struct
name|evhttp
modifier|*
name|oldhttp
decl_stmt|;
name|int
name|match_found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|evhttp_find_alias
argument_list|(
name|http
argument_list|,
name|outhttp
argument_list|,
name|hostname
argument_list|)
condition|)
return|return
literal|1
return|;
do|do
block|{
name|oldhttp
operator|=
name|http
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vhost
argument_list|,
argument|&http->virtualhosts
argument_list|,
argument|next_vhost
argument_list|)
block|{
if|if
condition|(
name|prefix_suffix_match
argument_list|(
name|vhost
operator|->
name|vhost_pattern
argument_list|,
name|hostname
argument_list|,
literal|1
comment|/* ignorecase */
argument_list|)
condition|)
block|{
name|http
operator|=
name|vhost
expr_stmt|;
name|match_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|oldhttp
operator|!=
name|http
condition|)
do|;
if|if
condition|(
name|outhttp
condition|)
operator|*
name|outhttp
operator|=
name|http
expr_stmt|;
return|return
name|match_found
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_handle_request
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|arg
decl_stmt|;
name|struct
name|evhttp_cb
modifier|*
name|cb
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* we have a new request on which the user needs to take action */
name|req
operator|->
name|userdone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|type
operator|==
literal|0
operator|||
name|req
operator|->
name|uri
operator|==
name|NULL
condition|)
block|{
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_BADREQUEST
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|http
operator|->
name|allowed_methods
operator|&
name|req
operator|->
name|type
operator|)
operator|==
literal|0
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"Rejecting disallowed method %x (allowed: %x)\n"
operator|,
operator|(
name|unsigned
operator|)
name|req
operator|->
name|type
operator|,
operator|(
name|unsigned
operator|)
name|http
operator|->
name|allowed_methods
operator|)
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_NOTIMPLEMENTED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* handle potential virtual hosts */
name|hostname
operator|=
name|evhttp_request_get_host
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|!=
name|NULL
condition|)
block|{
name|evhttp_find_vhost
argument_list|(
name|http
argument_list|,
operator|&
name|http
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cb
operator|=
name|evhttp_dispatch_callback
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|,
name|req
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|cb
operator|->
name|cb
call|)
argument_list|(
name|req
argument_list|,
name|cb
operator|->
name|cbarg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Generic call back */
if|if
condition|(
name|http
operator|->
name|gencb
condition|)
block|{
call|(
modifier|*
name|http
operator|->
name|gencb
call|)
argument_list|(
name|req
argument_list|,
name|http
operator|->
name|gencbarg
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* We need to send a 404 here */
define|#
directive|define
name|ERR_FORMAT
value|"<html><head>" \ 		    "<title>404 Not Found</title>" \ 		    "</head><body>" \ 		    "<h1>Not Found</h1>" \ 		    "<p>The requested URL %s was not found on this server.</p>"\ 		    "</body></html>\n"
name|char
modifier|*
name|escaped_html
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|escaped_html
operator|=
name|evhttp_htmlescape
argument_list|(
name|req
operator|->
name|uri
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|evhttp_connection_free
argument_list|(
name|req
operator|->
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|escaped_html
argument_list|)
expr_stmt|;
name|evhttp_connection_free
argument_list|(
name|req
operator|->
name|evcon
argument_list|)
expr_stmt|;
return|return;
block|}
name|evhttp_response_code_
argument_list|(
name|req
argument_list|,
name|HTTP_NOTFOUND
argument_list|,
literal|"Not Found"
argument_list|)
expr_stmt|;
name|evbuffer_add_printf
argument_list|(
name|buf
argument_list|,
name|ERR_FORMAT
argument_list|,
name|escaped_html
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|escaped_html
argument_list|)
expr_stmt|;
name|evhttp_send_page_
argument_list|(
name|req
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERR_FORMAT
block|}
block|}
end_function

begin_comment
comment|/* Listener callback when a connection arrives at a server. */
end_comment

begin_function
specifier|static
name|void
name|accept_socket_cb
parameter_list|(
name|struct
name|evconnlistener
modifier|*
name|listener
parameter_list|,
name|evutil_socket_t
name|nfd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|peer_sa
parameter_list|,
name|int
name|peer_socklen
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|arg
decl_stmt|;
name|evhttp_get_request
argument_list|(
name|http
argument_list|,
name|nfd
argument_list|,
name|peer_sa
argument_list|,
name|peer_socklen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evhttp_bind_socket
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|)
block|{
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
init|=
name|evhttp_bind_socket_with_handle
argument_list|(
name|http
argument_list|,
name|address
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|bound
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_bound_socket
modifier|*
name|evhttp_bind_socket_with_handle
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|)
block|{
name|evutil_socket_t
name|fd
decl_stmt|;
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|bind_socket
argument_list|(
name|address
argument_list|,
name|port
argument_list|,
literal|1
comment|/*reuse*/
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
literal|128
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"%s: listen"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bound
operator|=
name|evhttp_accept_socket_with_handle
argument_list|(
name|http
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bound
operator|!=
name|NULL
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"Bound to port %d - Awaiting connections ... "
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|bound
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_accept_socket
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
init|=
name|evhttp_accept_socket_with_handle
argument_list|(
name|http
argument_list|,
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bound
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_foreach_bound_socket
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|evhttp_bound_socket_foreach_fn
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|)
block|{
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bound
argument_list|,
argument|&http->sockets
argument_list|,
argument|next
argument_list|)
name|function
argument_list|(
name|bound
argument_list|,
name|argument
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evhttp_bound_socket
modifier|*
name|evhttp_accept_socket_with_handle
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
decl_stmt|;
name|struct
name|evconnlistener
modifier|*
name|listener
decl_stmt|;
specifier|const
name|int
name|flags
init|=
name|LEV_OPT_REUSEABLE
operator||
name|LEV_OPT_CLOSE_ON_EXEC
operator||
name|LEV_OPT_CLOSE_ON_FREE
decl_stmt|;
name|listener
operator|=
name|evconnlistener_new
argument_list|(
name|http
operator|->
name|base
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
comment|/* Backlog is '0' because we already said 'listen' */
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|listener
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bound
operator|=
name|evhttp_bind_listener
argument_list|(
name|http
argument_list|,
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bound
condition|)
block|{
name|evconnlistener_free
argument_list|(
name|listener
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bound
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_bound_socket
modifier|*
name|evhttp_bind_listener
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evconnlistener
modifier|*
name|listener
parameter_list|)
block|{
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
decl_stmt|;
name|bound
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_bound_socket
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bound
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bound
operator|->
name|listener
operator|=
name|listener
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|http
operator|->
name|sockets
argument_list|,
name|bound
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evconnlistener_set_cb
argument_list|(
name|listener
argument_list|,
name|accept_socket_cb
argument_list|,
name|http
argument_list|)
expr_stmt|;
return|return
name|bound
return|;
block|}
end_function

begin_function
name|evutil_socket_t
name|evhttp_bound_socket_get_fd
parameter_list|(
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
parameter_list|)
block|{
return|return
name|evconnlistener_get_fd
argument_list|(
name|bound
operator|->
name|listener
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|evconnlistener
modifier|*
name|evhttp_bound_socket_get_listener
parameter_list|(
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
parameter_list|)
block|{
return|return
name|bound
operator|->
name|listener
return|;
block|}
end_function

begin_function
name|void
name|evhttp_del_accept_socket
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|sockets
argument_list|,
name|bound
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evconnlistener_free
argument_list|(
name|bound
operator|->
name|listener
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|bound
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|evhttp
modifier|*
name|evhttp_new_object
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|http
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|evutil_timerclear
argument_list|(
operator|&
name|http
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|evhttp_set_max_headers_size
argument_list|(
name|http
argument_list|,
name|EV_SIZE_MAX
argument_list|)
expr_stmt|;
name|evhttp_set_max_body_size
argument_list|(
name|http
argument_list|,
name|EV_SIZE_MAX
argument_list|)
expr_stmt|;
name|evhttp_set_default_content_type
argument_list|(
name|http
argument_list|,
literal|"text/html; charset=ISO-8859-1"
argument_list|)
expr_stmt|;
name|evhttp_set_allowed_methods
argument_list|(
name|http
argument_list|,
name|EVHTTP_REQ_GET
operator||
name|EVHTTP_REQ_POST
operator||
name|EVHTTP_REQ_HEAD
operator||
name|EVHTTP_REQ_PUT
operator||
name|EVHTTP_REQ_DELETE
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http
operator|->
name|sockets
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http
operator|->
name|connections
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http
operator|->
name|virtualhosts
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|http
operator|->
name|aliases
argument_list|)
expr_stmt|;
return|return
operator|(
name|http
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp
modifier|*
name|evhttp_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|NULL
decl_stmt|;
name|http
operator|=
name|evhttp_new_object
argument_list|()
expr_stmt|;
if|if
condition|(
name|http
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|http
operator|->
name|base
operator|=
name|base
expr_stmt|;
return|return
operator|(
name|http
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a web server on the specified address and port.  */
end_comment

begin_function
name|struct
name|evhttp
modifier|*
name|evhttp_start
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|NULL
decl_stmt|;
name|http
operator|=
name|evhttp_new_object
argument_list|()
expr_stmt|;
if|if
condition|(
name|http
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|evhttp_bind_socket
argument_list|(
name|http
argument_list|,
name|address
argument_list|,
name|port
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|mm_free
argument_list|(
name|http
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|http
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_free
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|)
block|{
name|struct
name|evhttp_cb
modifier|*
name|http_cb
decl_stmt|;
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
name|struct
name|evhttp_bound_socket
modifier|*
name|bound
decl_stmt|;
name|struct
name|evhttp
modifier|*
name|vhost
decl_stmt|;
name|struct
name|evhttp_server_alias
modifier|*
name|alias
decl_stmt|;
comment|/* Remove the accepting part */
while|while
condition|(
operator|(
name|bound
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|http
operator|->
name|sockets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|sockets
argument_list|,
name|bound
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|evconnlistener_free
argument_list|(
name|bound
operator|->
name|listener
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|bound
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|evcon
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|http
operator|->
name|connections
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* evhttp_connection_free removes the connection */
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|http_cb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|,
name|http_cb
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|http_cb
operator|->
name|what
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|http_cb
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|vhost
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|http
operator|->
name|virtualhosts
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|virtualhosts
argument_list|,
name|vhost
argument_list|,
name|next_vhost
argument_list|)
expr_stmt|;
name|evhttp_free
argument_list|(
name|vhost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|http
operator|->
name|vhost_pattern
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|http
operator|->
name|vhost_pattern
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|alias
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|http
operator|->
name|aliases
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|aliases
argument_list|,
name|alias
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|alias
operator|->
name|alias
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|http
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evhttp_add_virtual_host
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|struct
name|evhttp
modifier|*
name|vhost
parameter_list|)
block|{
comment|/* a vhost can only be a vhost once and should not have bound sockets */
if|if
condition|(
name|vhost
operator|->
name|vhost_pattern
operator|!=
name|NULL
operator|||
name|TAILQ_FIRST
argument_list|(
operator|&
name|vhost
operator|->
name|sockets
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|vhost
operator|->
name|vhost_pattern
operator|=
name|mm_strdup
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|vhost
operator|->
name|vhost_pattern
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|http
operator|->
name|virtualhosts
argument_list|,
name|vhost
argument_list|,
name|next_vhost
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_remove_virtual_host
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|struct
name|evhttp
modifier|*
name|vhost
parameter_list|)
block|{
if|if
condition|(
name|vhost
operator|->
name|vhost_pattern
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|virtualhosts
argument_list|,
name|vhost
argument_list|,
name|next_vhost
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|vhost
operator|->
name|vhost_pattern
argument_list|)
expr_stmt|;
name|vhost
operator|->
name|vhost_pattern
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_add_server_alias
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|alias
parameter_list|)
block|{
name|struct
name|evhttp_server_alias
modifier|*
name|evalias
decl_stmt|;
name|evalias
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|evalias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evalias
condition|)
return|return
operator|-
literal|1
return|;
name|evalias
operator|->
name|alias
operator|=
name|mm_strdup
argument_list|(
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evalias
operator|->
name|alias
condition|)
block|{
name|mm_free
argument_list|(
name|evalias
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|http
operator|->
name|aliases
argument_list|,
name|evalias
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_remove_server_alias
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|alias
parameter_list|)
block|{
name|struct
name|evhttp_server_alias
modifier|*
name|evalias
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|evalias
argument_list|,
argument|&http->aliases
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|evutil_ascii_strcasecmp
argument_list|(
name|evalias
operator|->
name|alias
argument_list|,
name|alias
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|aliases
argument_list|,
name|evalias
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|evalias
operator|->
name|alias
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|evalias
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|evhttp_set_timeout
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|int
name|timeout_in_secs
parameter_list|)
block|{
if|if
condition|(
name|timeout_in_secs
operator|==
operator|-
literal|1
condition|)
block|{
name|evhttp_set_timeout_tv
argument_list|(
name|http
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|timeout_in_secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|evhttp_set_timeout_tv
argument_list|(
name|http
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_set_timeout_tv
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|tv
condition|)
block|{
name|http
operator|->
name|timeout
operator|=
operator|*
name|tv
expr_stmt|;
block|}
else|else
block|{
name|evutil_timerclear
argument_list|(
operator|&
name|http
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evhttp_set_max_headers_size
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|ev_ssize_t
name|max_headers_size
parameter_list|)
block|{
if|if
condition|(
name|max_headers_size
operator|<
literal|0
condition|)
name|http
operator|->
name|default_max_headers_size
operator|=
name|EV_SIZE_MAX
expr_stmt|;
else|else
name|http
operator|->
name|default_max_headers_size
operator|=
name|max_headers_size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_set_max_body_size
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|ev_ssize_t
name|max_body_size
parameter_list|)
block|{
if|if
condition|(
name|max_body_size
operator|<
literal|0
condition|)
name|http
operator|->
name|default_max_body_size
operator|=
name|EV_UINT64_MAX
expr_stmt|;
else|else
name|http
operator|->
name|default_max_body_size
operator|=
name|max_body_size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_set_default_content_type
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|content_type
parameter_list|)
block|{
name|http
operator|->
name|default_content_type
operator|=
name|content_type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_set_allowed_methods
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|ev_uint16_t
name|methods
parameter_list|)
block|{
name|http
operator|->
name|allowed_methods
operator|=
name|methods
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evhttp_set_cb
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|evhttp_cb
modifier|*
name|http_cb
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|http_cb
argument_list|,
argument|&http->callbacks
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|http_cb
operator|->
name|what
argument_list|,
name|uri
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|http_cb
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_cb
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|http_cb
operator|->
name|what
operator|=
name|mm_strdup
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_cb
operator|->
name|what
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|http_cb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
name|http_cb
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|http_cb
operator|->
name|cbarg
operator|=
name|cbarg
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|,
name|http_cb
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_del_cb
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
specifier|const
name|char
modifier|*
name|uri
parameter_list|)
block|{
name|struct
name|evhttp_cb
modifier|*
name|http_cb
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|http_cb
argument_list|,
argument|&http->callbacks
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|http_cb
operator|->
name|what
argument_list|,
name|uri
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|http_cb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|http
operator|->
name|callbacks
argument_list|,
name|http_cb
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|http_cb
operator|->
name|what
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|http_cb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_set_gencb
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|http
operator|->
name|gencb
operator|=
name|cb
expr_stmt|;
name|http
operator|->
name|gencbarg
operator|=
name|cbarg
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|evhttp_set_bevcb
argument_list|(
expr|struct
name|evhttp
operator|*
name|http
argument_list|,
expr|struct
name|bufferevent
operator|*
call|(
modifier|*
name|cb
call|)
argument_list|(
expr|struct
name|event_base
operator|*
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
name|cbarg
argument_list|)
block|{
name|http
operator|->
name|bevcb
operator|=
name|cb
expr_stmt|;
name|http
operator|->
name|bevcbarg
operator|=
name|cbarg
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Request related functions  */
end_comment

begin_function
name|struct
name|evhttp_request
modifier|*
name|evhttp_request_new
parameter_list|(
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evhttp_request
modifier|*
name|req
init|=
name|NULL
decl_stmt|;
comment|/* Allocate request structure */
if|if
condition|(
operator|(
name|req
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_request
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|req
operator|->
name|headers_size
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|body_size
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|kind
operator|=
name|EVHTTP_RESPONSE
expr_stmt|;
name|req
operator|->
name|input_headers
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evkeyvalq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|input_headers
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TAILQ_INIT
argument_list|(
name|req
operator|->
name|input_headers
argument_list|)
expr_stmt|;
name|req
operator|->
name|output_headers
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evkeyvalq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|output_headers
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|TAILQ_INIT
argument_list|(
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|input_buffer
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: evbuffer_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|req
operator|->
name|output_buffer
operator|=
name|evbuffer_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: evbuffer_new"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|req
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|req
operator|->
name|cb_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|req
operator|)
return|;
name|error
label|:
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|evhttp_request_free
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
if|if
condition|(
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_REQ_DEFER_FREE
operator|)
operator|!=
literal|0
condition|)
block|{
name|req
operator|->
name|flags
operator||=
name|EVHTTP_REQ_NEEDS_FREE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|req
operator|->
name|remote_host
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|remote_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|uri
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|uri_elems
operator|!=
name|NULL
condition|)
name|evhttp_uri_free
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|response_code_line
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|response_code_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|host_cache
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
name|req
operator|->
name|host_cache
argument_list|)
expr_stmt|;
name|evhttp_clear_headers
argument_list|(
name|req
operator|->
name|input_headers
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
operator|->
name|input_headers
argument_list|)
expr_stmt|;
name|evhttp_clear_headers
argument_list|(
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
operator|->
name|output_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|input_buffer
operator|!=
name|NULL
condition|)
name|evbuffer_free
argument_list|(
name|req
operator|->
name|input_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|output_buffer
operator|!=
name|NULL
condition|)
name|evbuffer_free
argument_list|(
name|req
operator|->
name|output_buffer
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_request_own
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
name|req
operator|->
name|flags
operator||=
name|EVHTTP_USER_OWNED
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evhttp_request_is_owned
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|flags
operator|&
name|EVHTTP_USER_OWNED
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_connection
modifier|*
name|evhttp_request_get_connection
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
name|req
operator|->
name|evcon
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|evhttp_connection_get_base
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|conn
parameter_list|)
block|{
return|return
name|conn
operator|->
name|base
return|;
block|}
end_function

begin_function
name|void
name|evhttp_request_set_chunked_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|req
operator|->
name|chunk_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_request_set_header_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|req
operator|->
name|header_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_request_set_error_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|enum
name|evhttp_request_error
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|req
operator|->
name|error_cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evhttp_request_set_on_complete_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|evhttp_request
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|)
block|{
name|req
operator|->
name|on_complete_cb
operator|=
name|cb
expr_stmt|;
name|req
operator|->
name|on_complete_cb_arg
operator|=
name|cb_arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allows for inspection of the request URI  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|evhttp_request_get_uri
parameter_list|(
specifier|const
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
if|if
condition|(
name|req
operator|->
name|uri
operator|==
name|NULL
condition|)
name|event_debug
argument_list|(
operator|(
literal|"%s: request %p has no uri\n"
operator|,
name|__func__
operator|,
name|req
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|req
operator|->
name|uri
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|evhttp_request_get_evhttp_uri
parameter_list|(
specifier|const
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
if|if
condition|(
name|req
operator|->
name|uri_elems
operator|==
name|NULL
condition|)
name|event_debug
argument_list|(
operator|(
literal|"%s: request %p has no uri elems\n"
operator|,
name|__func__
operator|,
name|req
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|req
operator|->
name|uri_elems
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_request_get_host
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|host_cache
condition|)
return|return
name|req
operator|->
name|host_cache
return|;
if|if
condition|(
name|req
operator|->
name|uri_elems
condition|)
name|host
operator|=
name|evhttp_uri_get_host
argument_list|(
name|req
operator|->
name|uri_elems
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
operator|&&
name|req
operator|->
name|input_headers
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|host
operator|=
name|evhttp_find_header
argument_list|(
name|req
operator|->
name|input_headers
argument_list|,
literal|"Host"
argument_list|)
expr_stmt|;
comment|/* The Host: header may include a port. Remove it here 		   to be consistent with uri_elems case above. */
if|if
condition|(
name|host
condition|)
block|{
name|p
operator|=
name|host
operator|+
name|strlen
argument_list|(
name|host
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|host
operator|&&
name|EVUTIL_ISDIGIT_
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|host
operator|&&
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|len
operator|=
name|p
operator|-
name|host
expr_stmt|;
name|req
operator|->
name|host_cache
operator|=
name|mm_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|req
operator|->
name|host_cache
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|req
operator|->
name|host_cache
argument_list|,
name|host
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|req
operator|->
name|host_cache
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|host
operator|=
name|req
operator|->
name|host_cache
expr_stmt|;
block|}
block|}
block|}
return|return
name|host
return|;
block|}
end_function

begin_function
name|enum
name|evhttp_cmd_type
name|evhttp_request_get_command
parameter_list|(
specifier|const
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|evhttp_request_get_response_code
parameter_list|(
specifier|const
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
name|req
operator|->
name|response_code
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_request_get_response_code_line
parameter_list|(
specifier|const
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
name|req
operator|->
name|response_code_line
return|;
block|}
end_function

begin_comment
comment|/** Returns the input headers */
end_comment

begin_function
name|struct
name|evkeyvalq
modifier|*
name|evhttp_request_get_input_headers
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|input_headers
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Returns the output headers */
end_comment

begin_function
name|struct
name|evkeyvalq
modifier|*
name|evhttp_request_get_output_headers
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|output_headers
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Returns the input buffer */
end_comment

begin_function
name|struct
name|evbuffer
modifier|*
name|evhttp_request_get_input_buffer
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|input_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Returns the output buffer */
end_comment

begin_function
name|struct
name|evbuffer
modifier|*
name|evhttp_request_get_output_buffer
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|)
block|{
return|return
operator|(
name|req
operator|->
name|output_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a file descriptor to read a request from.  * The callback is executed once the whole request has been read.  */
end_comment

begin_function
specifier|static
name|struct
name|evhttp_connection
modifier|*
name|evhttp_get_request_connection
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|salen
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
name|char
modifier|*
name|hostname
init|=
name|NULL
decl_stmt|,
modifier|*
name|portname
init|=
name|NULL
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
init|=
name|NULL
decl_stmt|;
name|name_from_addr
argument_list|(
name|sa
argument_list|,
name|salen
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|portname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|||
name|portname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hostname
condition|)
name|mm_free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|portname
condition|)
name|mm_free
argument_list|(
name|portname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: new request from %s:%s on "
name|EV_SOCK_FMT
literal|"\n"
operator|,
name|__func__
operator|,
name|hostname
operator|,
name|portname
operator|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* we need a connection object to put the http request on */
if|if
condition|(
name|http
operator|->
name|bevcb
operator|!=
name|NULL
condition|)
block|{
name|bev
operator|=
call|(
modifier|*
name|http
operator|->
name|bevcb
call|)
argument_list|(
name|http
operator|->
name|base
argument_list|,
name|http
operator|->
name|bevcbarg
argument_list|)
expr_stmt|;
block|}
name|evcon
operator|=
name|evhttp_connection_base_bufferevent_new
argument_list|(
name|http
operator|->
name|base
argument_list|,
name|NULL
argument_list|,
name|bev
argument_list|,
name|hostname
argument_list|,
name|atoi
argument_list|(
name|portname
argument_list|)
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|portname
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|evcon
operator|->
name|max_headers_size
operator|=
name|http
operator|->
name|default_max_headers_size
expr_stmt|;
name|evcon
operator|->
name|max_body_size
operator|=
name|http
operator|->
name|default_max_body_size
expr_stmt|;
name|evcon
operator|->
name|flags
operator||=
name|EVHTTP_CON_INCOMING
expr_stmt|;
name|evcon
operator|->
name|state
operator|=
name|EVCON_READING_FIRSTLINE
expr_stmt|;
name|evcon
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|bufferevent_setfd
argument_list|(
name|evcon
operator|->
name|bufev
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|evcon
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evhttp_associate_new_request_with_connection
parameter_list|(
name|struct
name|evhttp_connection
modifier|*
name|evcon
parameter_list|)
block|{
name|struct
name|evhttp
modifier|*
name|http
init|=
name|evcon
operator|->
name|http_server
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|evhttp_request_new
argument_list|(
name|evhttp_handle_request
argument_list|,
name|http
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|req
operator|->
name|remote_host
operator|=
name|mm_strdup
argument_list|(
name|evcon
operator|->
name|address
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|evhttp_request_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|req
operator|->
name|remote_port
operator|=
name|evcon
operator|->
name|port
expr_stmt|;
name|req
operator|->
name|evcon
operator|=
name|evcon
expr_stmt|;
comment|/* the request ends up owning the connection */
name|req
operator|->
name|flags
operator||=
name|EVHTTP_REQ_OWN_CONNECTION
expr_stmt|;
comment|/* We did not present the request to the user user yet, so treat it as 	 * if the user was done with the request.  This allows us to free the 	 * request on a persistent connection if the client drops it without 	 * sending a request. 	 */
name|req
operator|->
name|userdone
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|evcon
operator|->
name|requests
argument_list|,
name|req
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|req
operator|->
name|kind
operator|=
name|EVHTTP_REQUEST
expr_stmt|;
name|evhttp_start_read_
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|evhttp_get_request
parameter_list|(
name|struct
name|evhttp
modifier|*
name|http
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|salen
parameter_list|)
block|{
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
name|evcon
operator|=
name|evhttp_get_request_connection
argument_list|(
name|http
argument_list|,
name|fd
argument_list|,
name|sa
argument_list|,
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"%s: cannot get connection on "
name|EV_SOCK_FMT
argument_list|,
name|__func__
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* the timeout can be used by the server to close idle connections */
if|if
condition|(
name|evutil_timerisset
argument_list|(
operator|&
name|http
operator|->
name|timeout
argument_list|)
condition|)
name|evhttp_connection_set_timeout_tv
argument_list|(
name|evcon
argument_list|,
operator|&
name|http
operator|->
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	 * if we want to accept more than one request on a connection, 	 * we need to know which http server it belongs to. 	 */
name|evcon
operator|->
name|http_server
operator|=
name|http
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|http
operator|->
name|connections
argument_list|,
name|evcon
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|evhttp_associate_new_request_with_connection
argument_list|(
name|evcon
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Network helper functions that we do not want to export to the rest of  * the world.  */
end_comment

begin_function
specifier|static
name|void
name|name_from_addr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|salen
parameter_list|,
name|char
modifier|*
modifier|*
name|phost
parameter_list|,
name|char
modifier|*
modifier|*
name|pport
parameter_list|)
block|{
name|char
name|ntop
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|ni_result
decl_stmt|;
ifdef|#
directive|ifdef
name|EVENT__HAVE_GETNAMEINFO
name|ni_result
operator|=
name|getnameinfo
argument_list|(
name|sa
argument_list|,
name|salen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni_result
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EAI_SYSTEM
comment|/* Windows doesn't have an EAI_SYSTEM. */
if|if
condition|(
name|ni_result
operator|==
name|EAI_SYSTEM
condition|)
name|event_err
argument_list|(
literal|1
argument_list|,
literal|"getnameinfo failed"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"getnameinfo failed: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ni_result
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|ni_result
operator|=
name|fake_getnameinfo
argument_list|(
name|sa
argument_list|,
name|salen
argument_list|,
name|ntop
argument_list|,
sizeof|sizeof
argument_list|(
name|ntop
argument_list|)
argument_list|,
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni_result
operator|!=
literal|0
condition|)
return|return;
endif|#
directive|endif
operator|*
name|phost
operator|=
name|mm_strdup
argument_list|(
name|ntop
argument_list|)
expr_stmt|;
operator|*
name|pport
operator|=
name|mm_strdup
argument_list|(
name|strport
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a non-blocking socket and bind it */
end_comment

begin_comment
comment|/* todo: rename this function */
end_comment

begin_function
specifier|static
name|evutil_socket_t
name|bind_socket_ai
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|ai
parameter_list|,
name|int
name|reuse
parameter_list|)
block|{
name|evutil_socket_t
name|fd
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|r
decl_stmt|;
name|int
name|serrno
decl_stmt|;
comment|/* Create listen socket */
name|fd
operator|=
name|evutil_socket_
argument_list|(
name|ai
condition|?
name|ai
operator|->
name|ai_family
else|:
name|AF_INET
argument_list|,
name|SOCK_STREAM
operator||
name|EVUTIL_SOCK_NONBLOCK
operator||
name|EVUTIL_SOCK_CLOEXEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|event_sock_warn
argument_list|(
operator|-
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|reuse
condition|)
block|{
if|if
condition|(
name|evutil_make_listen_socket_reuseable
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ai
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|bind
argument_list|(
name|fd
argument_list|,
name|ai
operator|->
name|ai_addr
argument_list|,
operator|(
name|ev_socklen_t
operator|)
name|ai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
name|out
label|:
name|serrno
operator|=
name|EVUTIL_SOCKET_ERROR
argument_list|()
expr_stmt|;
name|evutil_closesocket
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|EVUTIL_SET_SOCKET_ERROR
argument_list|(
name|serrno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|evutil_addrinfo
modifier|*
name|make_addrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|)
block|{
name|struct
name|evutil_addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|struct
name|evutil_addrinfo
name|hints
decl_stmt|;
name|char
name|strport
index|[
name|NI_MAXSERV
index|]
decl_stmt|;
name|int
name|ai_result
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
comment|/* turn NULL hostname into INADDR_ANY, and skip looking up any address 	 * types we don't have an interface to connect to. */
name|hints
operator|.
name|ai_flags
operator|=
name|EVUTIL_AI_PASSIVE
operator||
name|EVUTIL_AI_ADDRCONFIG
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|strport
argument_list|,
sizeof|sizeof
argument_list|(
name|strport
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ai_result
operator|=
name|evutil_getaddrinfo
argument_list|(
name|address
argument_list|,
name|strport
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|ai
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ai_result
operator|==
name|EVUTIL_EAI_SYSTEM
condition|)
name|event_warn
argument_list|(
literal|"getaddrinfo"
argument_list|)
expr_stmt|;
else|else
name|event_warnx
argument_list|(
literal|"getaddrinfo: %s"
argument_list|,
name|evutil_gai_strerror
argument_list|(
name|ai_result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|evutil_socket_t
name|bind_socket
parameter_list|(
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|ev_uint16_t
name|port
parameter_list|,
name|int
name|reuse
parameter_list|)
block|{
name|evutil_socket_t
name|fd
decl_stmt|;
name|struct
name|evutil_addrinfo
modifier|*
name|aitop
init|=
name|NULL
decl_stmt|;
comment|/* just create an unbound socket */
if|if
condition|(
name|address
operator|==
name|NULL
operator|&&
name|port
operator|==
literal|0
condition|)
return|return
name|bind_socket_ai
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
name|aitop
operator|=
name|make_addrinfo
argument_list|(
name|address
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|aitop
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd
operator|=
name|bind_socket_ai
argument_list|(
name|aitop
argument_list|,
name|reuse
argument_list|)
expr_stmt|;
name|evutil_freeaddrinfo
argument_list|(
name|aitop
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|evhttp_uri
block|{
name|unsigned
name|flags
decl_stmt|;
name|char
modifier|*
name|scheme
decl_stmt|;
comment|/* scheme; e.g http, ftp etc */
name|char
modifier|*
name|userinfo
decl_stmt|;
comment|/* userinfo (typically username:pass), or NULL */
name|char
modifier|*
name|host
decl_stmt|;
comment|/* hostname, IP address, or NULL */
name|int
name|port
decl_stmt|;
comment|/* port, or zero */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path, or "". */
name|char
modifier|*
name|query
decl_stmt|;
comment|/* query, or NULL */
name|char
modifier|*
name|fragment
decl_stmt|;
comment|/* fragment or NULL */
block|}
struct|;
end_struct

begin_function
name|struct
name|evhttp_uri
modifier|*
name|evhttp_uri_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|evhttp_uri
modifier|*
name|uri
init|=
name|mm_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_uri
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
condition|)
name|uri
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|uri
return|;
block|}
end_function

begin_function
name|void
name|evhttp_uri_set_flags
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|uri
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the string starting at s and ending immediately before eos  * is a valid URI scheme according to RFC3986  */
end_comment

begin_function
specifier|static
name|int
name|scheme_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|eos
parameter_list|)
block|{
comment|/* scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
name|EVUTIL_ASSERT
argument_list|(
name|eos
operator|>=
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|eos
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|EVUTIL_ISALPHA_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|++
name|s
operator|<
name|eos
condition|)
block|{
if|if
condition|(
operator|!
name|EVUTIL_ISALNUM_
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'+'
operator|&&
operator|*
name|s
operator|!=
literal|'-'
operator|&&
operator|*
name|s
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SUBDELIMS
value|"!$&'()*+,;="
end_define

begin_comment
comment|/* Return true iff [s..eos) is a valid userinfo */
end_comment

begin_function
specifier|static
name|int
name|userinfo_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|eos
parameter_list|)
block|{
while|while
condition|(
name|s
operator|<
name|eos
condition|)
block|{
if|if
condition|(
name|CHAR_IS_UNRESERVED
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
name|SUBDELIMS
argument_list|,
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
operator|&&
name|s
operator|+
literal|2
operator|<
name|eos
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|regname_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|eos
parameter_list|)
block|{
while|while
condition|(
name|s
operator|&&
name|s
operator|<
name|eos
condition|)
block|{
if|if
condition|(
name|CHAR_IS_UNRESERVED
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
name|SUBDELIMS
argument_list|,
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_port
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|eos
parameter_list|)
block|{
name|int
name|portnum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|eos
condition|)
block|{
if|if
condition|(
operator|!
name|EVUTIL_ISDIGIT_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|portnum
operator|=
operator|(
name|portnum
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|portnum
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|++
name|s
expr_stmt|;
block|}
return|return
name|portnum
return|;
block|}
end_function

begin_comment
comment|/* returns 0 for bad, 1 for ipv6, 2 for IPvFuture */
end_comment

begin_function
specifier|static
name|int
name|bracket_addr_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|eos
parameter_list|)
block|{
if|if
condition|(
name|s
operator|+
literal|3
operator|>
name|eos
operator|||
operator|*
name|s
operator|!=
literal|'['
operator|||
operator|*
operator|(
name|eos
operator|-
literal|1
operator|)
operator|!=
literal|']'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'v'
condition|)
block|{
comment|/* IPvFuture, or junk. 		   "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" ) 		 */
name|s
operator|+=
literal|2
expr_stmt|;
comment|/* skip [v */
operator|--
name|eos
expr_stmt|;
if|if
condition|(
operator|!
name|EVUTIL_ISXDIGIT_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/*require at least one*/
return|return
literal|0
return|;
while|while
condition|(
name|s
operator|<
name|eos
operator|&&
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|EVUTIL_ISXDIGIT_
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'.'
condition|)
return|return
literal|0
return|;
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eos
condition|)
block|{
if|if
condition|(
name|CHAR_IS_UNRESERVED
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
name|SUBDELIMS
argument_list|,
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|2
return|;
block|}
else|else
block|{
comment|/* IPv6, or junk */
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|ev_ssize_t
name|n_chars
init|=
name|eos
operator|-
name|s
operator|-
literal|2
decl_stmt|;
name|struct
name|in6_addr
name|in6
decl_stmt|;
if|if
condition|(
name|n_chars
operator|>=
literal|64
condition|)
comment|/* way too long */
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|n_chars
argument_list|)
expr_stmt|;
name|buf
index|[
name|n_chars
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|evutil_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
operator|&
name|in6
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse_authority
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|eos
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|port
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|eos
argument_list|)
expr_stmt|;
if|if
condition|(
name|eos
operator|==
name|s
condition|)
block|{
name|uri
operator|->
name|host
operator|=
name|mm_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|host
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Optionally, we start with "userinfo@" */
name|cp
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|<
name|eos
condition|)
block|{
if|if
condition|(
operator|!
name|userinfo_ok
argument_list|(
name|s
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|uri
operator|->
name|userinfo
operator|=
name|mm_strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|userinfo
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|cp
operator|=
name|s
expr_stmt|;
block|}
comment|/* Optionally, we end with ":port" */
for|for
control|(
name|port
operator|=
name|eos
operator|-
literal|1
init|;
name|port
operator|>=
name|cp
operator|&&
name|EVUTIL_ISDIGIT_
argument_list|(
operator|*
name|port
argument_list|)
condition|;
operator|--
name|port
control|)
empty_stmt|;
if|if
condition|(
name|port
operator|>=
name|cp
operator|&&
operator|*
name|port
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|port
operator|+
literal|1
operator|==
name|eos
condition|)
comment|/* Leave port unspecified; the RFC allows a 				    * nil port */
name|uri
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|uri
operator|->
name|port
operator|=
name|parse_port
argument_list|(
name|port
operator|+
literal|1
argument_list|,
name|eos
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|eos
operator|=
name|port
expr_stmt|;
block|}
comment|/* Now, cp..eos holds the "host" port, which can be an IPv4Address, 	 * an IP-Literal, or a reg-name */
name|EVUTIL_ASSERT
argument_list|(
name|eos
operator|>=
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'['
operator|&&
name|eos
operator|>=
name|cp
operator|+
literal|2
operator|&&
operator|*
operator|(
name|eos
operator|-
literal|1
operator|)
operator|==
literal|']'
condition|)
block|{
comment|/* IPv6address, IP-Literal, or junk. */
if|if
condition|(
operator|!
name|bracket_addr_ok
argument_list|(
name|cp
argument_list|,
name|eos
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Make sure the host part is ok. */
if|if
condition|(
operator|!
name|regname_ok
argument_list|(
name|cp
argument_list|,
name|eos
argument_list|)
condition|)
comment|/* Match IPv4Address or reg-name */
return|return
operator|-
literal|1
return|;
block|}
name|uri
operator|->
name|host
operator|=
name|mm_malloc
argument_list|(
name|eos
operator|-
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|host
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|uri
operator|->
name|host
argument_list|,
name|cp
argument_list|,
name|eos
operator|-
name|cp
argument_list|)
expr_stmt|;
name|uri
operator|->
name|host
index|[
name|eos
operator|-
name|cp
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|end_of_authority
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'#'
operator|||
operator|*
name|cp
operator|==
literal|'/'
condition|)
return|return
name|cp
return|;
operator|++
name|cp
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_enum
enum|enum
name|uri_part
block|{
name|PART_PATH
block|,
name|PART_QUERY
block|,
name|PART_FRAGMENT
block|}
enum|;
end_enum

begin_comment
comment|/* Return the character after the longest prefix of 'cp' that matches...  *   *pchar / "/" if allow_qchars is false, or  *   *(pchar / "/" / "?") if allow_qchars is true.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|end_of_path
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|enum
name|uri_part
name|part
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|EVHTTP_URI_NONCONFORMANT
condition|)
block|{
comment|/* If NONCONFORMANT: 		 *   Path is everything up to a # or ? or nul. 		 *   Query is everything up a # or nul 		 *   Fragment is everything up to a nul. 		 */
switch|switch
condition|(
name|part
condition|)
block|{
case|case
name|PART_PATH
case|:
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
operator|&&
operator|*
name|cp
operator|!=
literal|'?'
condition|)
operator|++
name|cp
expr_stmt|;
break|break;
case|case
name|PART_QUERY
case|:
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
condition|)
operator|++
name|cp
expr_stmt|;
break|break;
case|case
name|PART_FRAGMENT
case|:
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
return|return
name|cp
return|;
block|}
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|CHAR_IS_UNRESERVED
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|strchr
argument_list|(
name|SUBDELIMS
argument_list|,
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|':'
operator|||
operator|*
name|cp
operator|==
literal|'@'
operator|||
operator|*
name|cp
operator|==
literal|'/'
condition|)
operator|++
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|cp
index|[
literal|1
index|]
argument_list|)
operator|&&
name|EVUTIL_ISXDIGIT_
argument_list|(
name|cp
index|[
literal|2
index|]
argument_list|)
condition|)
name|cp
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
operator|&&
name|part
operator|!=
name|PART_PATH
condition|)
operator|++
name|cp
expr_stmt|;
else|else
return|return
name|cp
return|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|path_matches_noscheme
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
return|return
literal|1
return|;
operator|++
name|cp
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_uri
modifier|*
name|evhttp_uri_parse
parameter_list|(
specifier|const
name|char
modifier|*
name|source_uri
parameter_list|)
block|{
return|return
name|evhttp_uri_parse_with_flags
argument_list|(
name|source_uri
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|evhttp_uri
modifier|*
name|evhttp_uri_parse_with_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|source_uri
parameter_list|,
name|unsigned
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|readbuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|readp
init|=
name|NULL
decl_stmt|,
modifier|*
name|token
init|=
name|NULL
decl_stmt|,
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|fragment
init|=
name|NULL
decl_stmt|;
name|int
name|got_authority
init|=
literal|0
decl_stmt|;
name|struct
name|evhttp_uri
modifier|*
name|uri
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evhttp_uri
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|uri
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|uri
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|readbuf
operator|=
name|mm_strdup
argument_list|(
name|source_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|readp
operator|=
name|readbuf
expr_stmt|;
name|token
operator|=
name|NULL
expr_stmt|;
comment|/* We try to follow RFC3986 here as much as we can, and match 	   the productions  	      URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]  	      relative-ref  = relative-part [ "?" query ] [ "#" fragment ] 	 */
comment|/* 1. scheme: */
name|token
operator|=
name|strchr
argument_list|(
name|readp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|&&
name|scheme_ok
argument_list|(
name|readp
argument_list|,
name|token
argument_list|)
condition|)
block|{
operator|*
name|token
operator|=
literal|'\0'
expr_stmt|;
name|uri
operator|->
name|scheme
operator|=
name|mm_strdup
argument_list|(
name|readp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|scheme
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|readp
operator|=
name|token
operator|+
literal|1
expr_stmt|;
comment|/* eat : */
block|}
comment|/* 2. Optionally, "//" then an 'authority' part. */
if|if
condition|(
name|readp
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|readp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|authority
decl_stmt|;
name|readp
operator|+=
literal|2
expr_stmt|;
name|authority
operator|=
name|readp
expr_stmt|;
name|path
operator|=
name|end_of_authority
argument_list|(
name|readp
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_authority
argument_list|(
name|uri
argument_list|,
name|authority
argument_list|,
name|path
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|readp
operator|=
name|path
expr_stmt|;
name|got_authority
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 3. Query: path-abempty, path-absolute, path-rootless, or path-empty 	 */
name|path
operator|=
name|readp
expr_stmt|;
name|readp
operator|=
name|end_of_path
argument_list|(
name|path
argument_list|,
name|PART_PATH
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Query */
if|if
condition|(
operator|*
name|readp
operator|==
literal|'?'
condition|)
block|{
operator|*
name|readp
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|readp
expr_stmt|;
name|query
operator|=
name|readp
expr_stmt|;
name|readp
operator|=
name|end_of_path
argument_list|(
name|readp
argument_list|,
name|PART_QUERY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* fragment */
if|if
condition|(
operator|*
name|readp
operator|==
literal|'#'
condition|)
block|{
operator|*
name|readp
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|readp
expr_stmt|;
name|fragment
operator|=
name|readp
expr_stmt|;
name|readp
operator|=
name|end_of_path
argument_list|(
name|readp
argument_list|,
name|PART_FRAGMENT
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|readp
operator|!=
literal|'\0'
condition|)
block|{
goto|goto
name|err
goto|;
block|}
comment|/* These next two cases may be unreachable; I'm leaving them 	 * in to be defensive. */
comment|/* If you didn't get an authority, the path can't begin with "//" */
if|if
condition|(
operator|!
name|got_authority
operator|&&
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|path
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|err
goto|;
comment|/* If you did get an authority, the path must begin with "/" or be 	 * empty. */
if|if
condition|(
name|got_authority
operator|&&
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|err
goto|;
comment|/* (End of maybe-unreachable cases) */
comment|/* If there was no scheme, the first part of the path (if any) must 	 * have no colon in it. */
if|if
condition|(
operator|!
name|uri
operator|->
name|scheme
operator|&&
operator|!
name|path_matches_noscheme
argument_list|(
name|path
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|EVUTIL_ASSERT
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|uri
operator|->
name|path
operator|=
name|mm_strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|query
condition|)
block|{
name|uri
operator|->
name|query
operator|=
name|mm_strdup
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|query
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|fragment
condition|)
block|{
name|uri
operator|->
name|fragment
operator|=
name|mm_strdup
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|fragment
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: strdup"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|mm_free
argument_list|(
name|readbuf
argument_list|)
expr_stmt|;
return|return
name|uri
return|;
name|err
label|:
if|if
condition|(
name|uri
condition|)
name|evhttp_uri_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf
condition|)
name|mm_free
argument_list|(
name|readbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|evhttp_uri_free
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
define|#
directive|define
name|URI_FREE_STR_
parameter_list|(
name|f
parameter_list|)
define|\
value|if (uri->f) {			\ 		mm_free(uri->f);		\ 	}
name|URI_FREE_STR_
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|URI_FREE_STR_
argument_list|(
name|userinfo
argument_list|)
expr_stmt|;
name|URI_FREE_STR_
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|URI_FREE_STR_
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|URI_FREE_STR_
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|URI_FREE_STR_
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|uri
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|URI_FREE_STR_
block|}
end_function

begin_function
name|char
modifier|*
name|evhttp_uri_join
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|tmp
init|=
literal|0
decl_stmt|;
name|size_t
name|joined_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|URI_ADD_
parameter_list|(
name|f
parameter_list|)
value|evbuffer_add(tmp, uri->f, strlen(uri->f))
if|if
condition|(
operator|!
name|uri
operator|||
operator|!
name|buf
operator|||
operator|!
name|limit
condition|)
return|return
name|NULL
return|;
name|tmp
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|uri
operator|->
name|scheme
condition|)
block|{
name|URI_ADD_
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uri
operator|->
name|host
condition|)
block|{
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|userinfo
condition|)
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|"%s@"
argument_list|,
name|uri
operator|->
name|userinfo
argument_list|)
expr_stmt|;
name|URI_ADD_
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|port
operator|>=
literal|0
condition|)
name|evbuffer_add_printf
argument_list|(
name|tmp
argument_list|,
literal|":%d"
argument_list|,
name|uri
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|path
operator|&&
name|uri
operator|->
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|uri
operator|->
name|path
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|uri
operator|->
name|path
condition|)
name|URI_ADD_
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|uri
operator|->
name|query
condition|)
block|{
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
literal|"?"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|URI_ADD_
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uri
operator|->
name|fragment
condition|)
block|{
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
literal|"#"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|URI_ADD_
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
block|}
name|evbuffer_add
argument_list|(
name|tmp
argument_list|,
literal|"\0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NUL */
name|joined_size
operator|=
name|evbuffer_get_length
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|joined_size
operator|>
name|limit
condition|)
block|{
comment|/* It doesn't fit. */
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|evbuffer_remove
argument_list|(
name|tmp
argument_list|,
name|buf
argument_list|,
name|joined_size
argument_list|)
expr_stmt|;
name|output
operator|=
name|buf
expr_stmt|;
name|err
label|:
name|evbuffer_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|output
return|;
undef|#
directive|undef
name|URI_ADD_
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_scheme
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|scheme
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_userinfo
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|userinfo
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_host
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|host
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_get_port
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|port
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_path
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|path
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_query
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|query
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|evhttp_uri_get_fragment
parameter_list|(
specifier|const
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|)
block|{
return|return
name|uri
operator|->
name|fragment
return|;
block|}
end_function

begin_define
define|#
directive|define
name|URI_SET_STR_
parameter_list|(
name|f
parameter_list|)
value|do {					\ 	if (uri->f)						\ 		mm_free(uri->f);				\ 	if (f) {						\ 		if ((uri->f = mm_strdup(f)) == NULL) {		\ 			event_warn("%s: strdup()", __func__);	\ 			return -1;				\ 		}						\ 	} else {						\ 		uri->f = NULL;					\ 	}							\ 	} while(0)
end_define

begin_function
name|int
name|evhttp_uri_set_scheme
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|)
block|{
if|if
condition|(
name|scheme
operator|&&
operator|!
name|scheme_ok
argument_list|(
name|scheme
argument_list|,
name|scheme
operator|+
name|strlen
argument_list|(
name|scheme
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|URI_SET_STR_
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_set_userinfo
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|userinfo
parameter_list|)
block|{
if|if
condition|(
name|userinfo
operator|&&
operator|!
name|userinfo_ok
argument_list|(
name|userinfo
argument_list|,
name|userinfo
operator|+
name|strlen
argument_list|(
name|userinfo
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|URI_SET_STR_
argument_list|(
name|userinfo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_set_host
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|host
parameter_list|)
block|{
if|if
condition|(
name|host
condition|)
block|{
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
operator|!
name|bracket_addr_ok
argument_list|(
name|host
argument_list|,
name|host
operator|+
name|strlen
argument_list|(
name|host
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|regname_ok
argument_list|(
name|host
argument_list|,
name|host
operator|+
name|strlen
argument_list|(
name|host
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
name|URI_SET_STR_
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_set_port
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|port
operator|<
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|uri
operator|->
name|port
operator|=
name|port
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|end_of_cpath
parameter_list|(
name|cp
parameter_list|,
name|p
parameter_list|,
name|f
parameter_list|)
define|\
value|((const char*)(end_of_path(((char*)(cp)), (p), (f))))
end_define

begin_function
name|int
name|evhttp_uri_set_path
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|&&
name|end_of_cpath
argument_list|(
name|path
argument_list|,
name|PART_PATH
argument_list|,
name|uri
operator|->
name|flags
argument_list|)
operator|!=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|URI_SET_STR_
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_set_query
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|query
parameter_list|)
block|{
if|if
condition|(
name|query
operator|&&
name|end_of_cpath
argument_list|(
name|query
argument_list|,
name|PART_QUERY
argument_list|,
name|uri
operator|->
name|flags
argument_list|)
operator|!=
name|query
operator|+
name|strlen
argument_list|(
name|query
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|URI_SET_STR_
argument_list|(
name|query
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evhttp_uri_set_fragment
parameter_list|(
name|struct
name|evhttp_uri
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
name|fragment
parameter_list|)
block|{
if|if
condition|(
name|fragment
operator|&&
name|end_of_cpath
argument_list|(
name|fragment
argument_list|,
name|PART_FRAGMENT
argument_list|,
name|uri
operator|->
name|flags
argument_list|)
operator|!=
name|fragment
operator|+
name|strlen
argument_list|(
name|fragment
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|URI_SET_STR_
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

