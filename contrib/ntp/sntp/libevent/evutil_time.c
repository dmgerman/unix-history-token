begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__HAVE_GETTIMEOFDAY
end_ifndef

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EVENT__HAVE_NANOSLEEP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EVENT_HAVE_USLEEP
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__HAVE_GETTIMEOFDAY
end_ifndef

begin_comment
comment|/* No gettimeofday; this must be windows. */
end_comment

begin_function
name|int
name|evutil_gettimeofday
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
name|struct
name|timezone
modifier|*
name|tz
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_MSC_VER
define|#
directive|define
name|U64_LITERAL
parameter_list|(
name|n
parameter_list|)
value|n##ui64
else|#
directive|else
define|#
directive|define
name|U64_LITERAL
parameter_list|(
name|n
parameter_list|)
value|n##llu
endif|#
directive|endif
comment|/* Conversion logic taken from Tor, which in turn took it 	 * from Perl.  GetSystemTimeAsFileTime returns its value as 	 * an unaligned (!) 64-bit value containing the number of 	 * 100-nanosecond intervals since 1 January 1601 UTC. */
define|#
directive|define
name|EPOCH_BIAS
value|U64_LITERAL(116444736000000000)
define|#
directive|define
name|UNITS_PER_SEC
value|U64_LITERAL(10000000)
define|#
directive|define
name|USEC_PER_SEC
value|U64_LITERAL(1000000)
define|#
directive|define
name|UNITS_PER_USEC
value|U64_LITERAL(10)
union|union
block|{
name|FILETIME
name|ft_ft
decl_stmt|;
name|ev_uint64_t
name|ft_64
decl_stmt|;
block|}
name|ft
union|;
if|if
condition|(
name|tv
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|ft
operator|.
name|ft_ft
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_UNLIKELY
argument_list|(
name|ft
operator|.
name|ft_64
operator|<
name|EPOCH_BIAS
argument_list|)
condition|)
block|{
comment|/* Time before the unix epoch. */
return|return
operator|-
literal|1
return|;
block|}
name|ft
operator|.
name|ft_64
operator|-=
name|EPOCH_BIAS
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
call|(
name|long
call|)
argument_list|(
name|ft
operator|.
name|ft_64
operator|/
name|UNITS_PER_SEC
argument_list|)
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|ft
operator|.
name|ft_64
operator|/
name|UNITS_PER_USEC
operator|)
operator|%
name|USEC_PER_SEC
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_SECONDS_IN_MSEC_LONG
define|\
value|(((LONG_MAX) - 999) / 1000)
end_define

begin_function
name|long
name|evutil_tv_to_msec_
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
name|tv
operator|->
name|tv_usec
operator|>
literal|1000000
operator|||
name|tv
operator|->
name|tv_sec
operator|>
name|MAX_SECONDS_IN_MSEC_LONG
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|tv
operator|->
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
operator|(
name|tv
operator|->
name|tv_usec
operator|+
literal|999
operator|)
operator|/
literal|1000
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   Replacement for usleep on platforms that don't have one.  Not guaranteed to   be any more finegrained than 1 msec.  */
end_comment

begin_function
name|void
name|evutil_usleep_
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tv
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
block|{
name|long
name|msec
init|=
name|evutil_tv_to_msec_
argument_list|(
name|tv
argument_list|)
decl_stmt|;
name|Sleep
argument_list|(
operator|(
name|DWORD
operator|)
name|msec
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_NANOSLEEP
argument_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
name|tv
operator|->
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|tv
operator|->
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|nanosleep
argument_list|(
operator|&
name|ts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|EVENT__HAVE_USLEEP
argument_list|)
comment|/* Some systems don't like to usleep more than 999999 usec */
name|sleep
argument_list|(
name|tv
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|tv
operator|->
name|tv_usec
argument_list|)
expr_stmt|;
else|#
directive|else
name|select
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*    This function assumes it's called repeatedly with a    not-actually-so-monotonic time source whose outputs are in 'tv'. It    implements a trivial ratcheting mechanism so that the values never go    backwards.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_monotonic_time
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|evutil_timeradd
argument_list|(
name|tv
argument_list|,
operator|&
name|base
operator|->
name|adjust_monotonic_clock
argument_list|,
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_timercmp
argument_list|(
name|tv
argument_list|,
operator|&
name|base
operator|->
name|last_time
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* Guess it wasn't monotonic after all. */
name|struct
name|timeval
name|adjust
decl_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|base
operator|->
name|last_time
argument_list|,
name|tv
argument_list|,
operator|&
name|adjust
argument_list|)
expr_stmt|;
name|evutil_timeradd
argument_list|(
operator|&
name|adjust
argument_list|,
operator|&
name|base
operator|->
name|adjust_monotonic_clock
argument_list|,
operator|&
name|base
operator|->
name|adjust_monotonic_clock
argument_list|)
expr_stmt|;
operator|*
name|tv
operator|=
name|base
operator|->
name|last_time
expr_stmt|;
block|}
name|base
operator|->
name|last_time
operator|=
operator|*
name|tv
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POSIX_MONOTONIC
argument_list|)
end_if

begin_comment
comment|/* =====    The POSIX clock_gettime() interface provides a few ways to get at a    monotonic clock.  CLOCK_MONOTONIC is most widely supported.  Linux also    provides a CLOCK_MONOTONIC_COARSE with accuracy of about 1-4 msec.     On all platforms I'm aware of, CLOCK_MONOTONIC really is monotonic.    Platforms don't agree about whether it should jump on a sleep/resume.  */
end_comment

begin_function
name|int
name|evutil_configure_monotonic_time_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* CLOCK_MONOTONIC exists on FreeBSD, Linux, and Solaris.  You need to 	 * check for it at runtime, because some older kernel versions won't 	 * have it working. */
ifdef|#
directive|ifdef
name|CLOCK_MONOTONIC_COARSE
specifier|const
name|int
name|precise
init|=
name|flags
operator|&
name|EV_MONOT_PRECISE
decl_stmt|;
endif|#
directive|endif
specifier|const
name|int
name|fallback
init|=
name|flags
operator|&
name|EV_MONOT_FALLBACK
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|CLOCK_MONOTONIC_COARSE
if|if
condition|(
name|CLOCK_MONOTONIC_COARSE
operator|<
literal|0
condition|)
block|{
comment|/* Technically speaking, nothing keeps CLOCK_* from being 		 * negative (as far as I know). This check and the one below 		 * make sure that it's safe for us to use -1 as an "unset" 		 * value. */
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"I didn't expect CLOCK_MONOTONIC_COARSE to be< 0"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|precise
operator|&&
operator|!
name|fallback
condition|)
block|{
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC_COARSE
argument_list|,
operator|&
name|ts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|base
operator|->
name|monotonic_clock
operator|=
name|CLOCK_MONOTONIC_COARSE
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|fallback
operator|&&
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|ts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|base
operator|->
name|monotonic_clock
operator|=
name|CLOCK_MONOTONIC
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|CLOCK_MONOTONIC
operator|<
literal|0
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"I didn't expect CLOCK_MONOTONIC to be< 0"
argument_list|)
expr_stmt|;
block|}
name|base
operator|->
name|monotonic_clock
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_gettime_monotonic_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|monotonic_clock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|evutil_gettimeofday
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|adjust_monotonic_time
argument_list|(
name|base
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|clock_gettime
argument_list|(
name|base
operator|->
name|monotonic_clock
argument_list|,
operator|&
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|tp
operator|->
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACH_MONOTONIC
argument_list|)
end_if

begin_comment
comment|/* ======    Apple is a little late to the POSIX party.  And why not?  Instead of    clock_gettime(), they provide mach_absolute_time().  Its units are not    fixed; we need to use mach_timebase_info() to get the right functions to    convert its units into nanoseconds.     To all appearances, mach_absolute_time() seems to be honest-to-goodness    monotonic.  Whether it stops during sleep or not is unspecified in    principle, and dependent on CPU architecture in practice.  */
end_comment

begin_function
name|int
name|evutil_configure_monotonic_time_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|int
name|fallback
init|=
name|flags
operator|&
name|EV_MONOT_FALLBACK
decl_stmt|;
name|struct
name|mach_timebase_info
name|mi
decl_stmt|;
name|memset
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* OSX has mach_absolute_time() */
if|if
condition|(
operator|!
name|fallback
operator|&&
name|mach_timebase_info
argument_list|(
operator|&
name|mi
argument_list|)
operator|==
literal|0
operator|&&
name|mach_absolute_time
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* mach_timebase_info tells us how to convert 		 * mach_absolute_time() into nanoseconds, but we 		 * want to use microseconds instead. */
name|mi
operator|.
name|denom
operator|*=
literal|1000
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|base
operator|->
name|mach_timebase_units
argument_list|,
operator|&
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
name|mi
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|->
name|mach_timebase_units
operator|.
name|numer
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_gettime_monotonic_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|ev_uint64_t
name|abstime
decl_stmt|,
name|usec
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|mach_timebase_units
operator|.
name|numer
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|evutil_gettimeofday
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|adjust_monotonic_time
argument_list|(
name|base
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abstime
operator|=
name|mach_absolute_time
argument_list|()
expr_stmt|;
name|usec
operator|=
operator|(
name|abstime
operator|*
name|base
operator|->
name|mach_timebase_units
operator|.
name|numer
operator|)
operator|/
operator|(
name|base
operator|->
name|mach_timebase_units
operator|.
name|denom
operator|)
expr_stmt|;
name|tp
operator|->
name|tv_sec
operator|=
name|usec
operator|/
literal|1000000
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
name|usec
operator|%
literal|1000000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WIN32_MONOTONIC
argument_list|)
end_if

begin_comment
comment|/* =====    Turn we now to Windows.  Want monontonic time on Windows?     Windows has QueryPerformanceCounter(), which gives time most high-    resolution time.  It's a pity it's not so monotonic in practice; it's    also got some fun bugs, especially: with older Windowses, under    virtualizations, with funny hardware, on multiprocessor systems, and so    on.  PEP418 [1] has a nice roundup of the issues here.     There's GetTickCount64() on Vista and later, which gives a number of 1-msec    ticks since startup.  The accuracy here might be as bad as 10-20 msec, I    hear.  There's an undocumented function (NtSetTimerResolution) that    allegedly increases the accuracy. Good luck!     There's also GetTickCount(), which is only 32 bits, but seems to be    supported on pre-Vista versions of Windows.  Apparently, you can coax    another 14 bits out of it, giving you 2231 years before rollover.     The less said about timeGetTime() the better.     "We don't care.  We don't have to.  We're the Phone Company."             -- Lily Tomlin, SNL     Our strategy, if precise timers are turned off, is to just use the best    GetTickCount equivalent available.  If we've been asked for precise timing,    then we mostly[2] assume that GetTickCount is monotonic, and correct    GetPerformanceCounter to approximate it.     [1] http://www.python.org/dev/peps/pep-0418    [2] Of course, we feed the Windows stuff into adjust_monotonic_time()        anyway, just in case it isn't.   */
end_comment

begin_comment
comment|/*     Parts of our logic in the win32 timer code here are closely based on     BitTorrent's libUTP library.  That code is subject to the following     license:        Copyright (c) 2010 BitTorrent, Inc.        Permission is hereby granted, free of charge, to any person obtaining a       copy of this software and associated documentation files (the       "Software"), to deal in the Software without restriction, including       without limitation the rights to use, copy, modify, merge, publish,       distribute, sublicense, and/or sell copies of the Software, and to       permit persons to whom the Software is furnished to do so, subject to       the following conditions:        The above copyright notice and this permission notice shall be included       in all copies or substantial portions of the Software.        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS       OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND       NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE       LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION       OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION       WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
end_comment

begin_function
specifier|static
name|ev_uint64_t
name|evutil_GetTickCount_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|)
block|{
if|if
condition|(
name|base
operator|->
name|GetTickCount64_fn
condition|)
block|{
comment|/* Let's just use GetTickCount64 if we can. */
return|return
name|base
operator|->
name|GetTickCount64_fn
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|base
operator|->
name|GetTickCount_fn
condition|)
block|{
comment|/* Greg Hazel assures me that this works, that BitTorrent has 		 * done it for years, and this it won't turn around and 		 * bite us.  He says they found it on some game programmers' 		 * forum some time around 2007. 		 */
name|ev_uint64_t
name|v
init|=
name|base
operator|->
name|GetTickCount_fn
argument_list|()
decl_stmt|;
return|return
operator|(
name|DWORD
operator|)
name|v
operator||
operator|(
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0xFFFFFFFF00000000
operator|)
return|;
block|}
else|else
block|{
comment|/* Here's the fallback implementation. We have to use 		 * GetTickCount() with its given signature, so we only get 		 * 32 bits worth of milliseconds, which will roll ove every 		 * 49 days or so.  */
name|DWORD
name|ticks
init|=
name|GetTickCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|ticks
operator|<
name|base
operator|->
name|last_tick_count
condition|)
block|{
name|base
operator|->
name|adjust_tick_count
operator|+=
operator|(
operator|(
name|ev_uint64_t
operator|)
literal|1
operator|)
operator|<<
literal|32
expr_stmt|;
block|}
name|base
operator|->
name|last_tick_count
operator|=
name|ticks
expr_stmt|;
return|return
name|ticks
operator|+
name|base
operator|->
name|adjust_tick_count
return|;
block|}
block|}
end_function

begin_function
name|int
name|evutil_configure_monotonic_time_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|int
name|precise
init|=
name|flags
operator|&
name|EV_MONOT_PRECISE
decl_stmt|;
specifier|const
name|int
name|fallback
init|=
name|flags
operator|&
name|EV_MONOT_FALLBACK
decl_stmt|;
name|HANDLE
name|h
decl_stmt|;
name|memset
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|evutil_load_windows_system_library_
argument_list|(
name|TEXT
argument_list|(
literal|"kernel32.dll"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|fallback
condition|)
block|{
name|base
operator|->
name|GetTickCount64_fn
operator|=
operator|(
name|ev_GetTickCount_func
operator|)
name|GetProcAddress
argument_list|(
name|h
argument_list|,
literal|"GetTickCount64"
argument_list|)
expr_stmt|;
name|base
operator|->
name|GetTickCount_fn
operator|=
operator|(
name|ev_GetTickCount_func
operator|)
name|GetProcAddress
argument_list|(
name|h
argument_list|,
literal|"GetTickCount"
argument_list|)
expr_stmt|;
block|}
name|base
operator|->
name|first_tick
operator|=
name|base
operator|->
name|last_tick_count
operator|=
name|evutil_GetTickCount_
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|precise
operator|&&
operator|!
name|fallback
condition|)
block|{
name|LARGE_INTEGER
name|freq
decl_stmt|;
if|if
condition|(
name|QueryPerformanceFrequency
argument_list|(
operator|&
name|freq
argument_list|)
condition|)
block|{
name|LARGE_INTEGER
name|counter
decl_stmt|;
name|QueryPerformanceCounter
argument_list|(
operator|&
name|counter
argument_list|)
expr_stmt|;
name|base
operator|->
name|first_counter
operator|=
name|counter
operator|.
name|QuadPart
expr_stmt|;
name|base
operator|->
name|usec_per_count
operator|=
literal|1.0e6
operator|/
name|freq
operator|.
name|QuadPart
expr_stmt|;
name|base
operator|->
name|use_performance_counter
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ev_int64_t
name|abs64
parameter_list|(
name|ev_int64_t
name|i
parameter_list|)
block|{
return|return
name|i
operator|<
literal|0
condition|?
operator|-
name|i
else|:
name|i
return|;
block|}
end_function

begin_function
name|int
name|evutil_gettime_monotonic_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|ev_uint64_t
name|ticks
init|=
name|evutil_GetTickCount_
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|use_performance_counter
condition|)
block|{
comment|/* Here's a trick we took from BitTorrent's libutp, at Greg 		 * Hazel's recommendation.  We use QueryPerformanceCounter for 		 * our high-resolution timer, but use GetTickCount*() to keep 		 * it sane, and adjust_monotonic_time() to keep it monotonic. 		 */
name|LARGE_INTEGER
name|counter
decl_stmt|;
name|ev_int64_t
name|counter_elapsed
decl_stmt|,
name|counter_usec_elapsed
decl_stmt|,
name|ticks_elapsed
decl_stmt|;
name|QueryPerformanceCounter
argument_list|(
operator|&
name|counter
argument_list|)
expr_stmt|;
name|counter_elapsed
operator|=
call|(
name|ev_int64_t
call|)
argument_list|(
name|counter
operator|.
name|QuadPart
operator|-
name|base
operator|->
name|first_counter
argument_list|)
expr_stmt|;
name|ticks_elapsed
operator|=
name|ticks
operator|-
name|base
operator|->
name|first_tick
expr_stmt|;
comment|/* TODO: This may upset VC6. If you need this to work with 		 * VC6, please supply an appropriate patch. */
name|counter_usec_elapsed
operator|=
call|(
name|ev_int64_t
call|)
argument_list|(
name|counter_elapsed
operator|*
name|base
operator|->
name|usec_per_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs64
argument_list|(
name|ticks_elapsed
operator|*
literal|1000
operator|-
name|counter_usec_elapsed
argument_list|)
operator|>
literal|1000000
condition|)
block|{
comment|/* It appears that the QueryPerformanceCounter() 			 * result is more than 1 second away from 			 * GetTickCount() result. Let's adjust it to be as 			 * accurate as we can; adjust_monotnonic_time() below 			 * will keep it monotonic. */
name|counter_usec_elapsed
operator|=
name|ticks_elapsed
operator|*
literal|1000
expr_stmt|;
name|base
operator|->
name|first_counter
operator|=
call|(
name|ev_uint64_t
call|)
argument_list|(
name|counter
operator|.
name|QuadPart
operator|-
name|counter_usec_elapsed
operator|/
name|base
operator|->
name|usec_per_count
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|counter_usec_elapsed
operator|/
literal|1000000
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
name|counter_usec_elapsed
operator|%
literal|1000000
expr_stmt|;
block|}
else|else
block|{
comment|/* We're just using GetTickCount(). */
name|tp
operator|->
name|tv_sec
operator|=
call|(
name|time_t
call|)
argument_list|(
name|ticks
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
operator|(
name|ticks
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
name|adjust_monotonic_time
argument_list|(
name|base
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FALLBACK_MONOTONIC
argument_list|)
end_if

begin_comment
comment|/* =====    And if none of the other options work, let's just use gettimeofday(), and    ratchet it forward so that it acts like a monotonic timer, whether it    wants to or not.  */
end_comment

begin_function
name|int
name|evutil_configure_monotonic_time_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|int
name|precise
parameter_list|)
block|{
name|memset
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|base
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|evutil_gettime_monotonic_
parameter_list|(
name|struct
name|evutil_monotonic_timer
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|evutil_gettimeofday
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|adjust_monotonic_time
argument_list|(
name|base
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

