begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**    @file buffer_iocp.c     This module implements overlapped read and write functions for evbuffer    objects on Windows. */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer_compat.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"evbuffer-internal.h"
end_include

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|MAX_WSABUFS
value|16
end_define

begin_comment
comment|/** An evbuffer that can handle overlapped IO. */
end_comment

begin_struct
struct|struct
name|evbuffer_overlapped
block|{
name|struct
name|evbuffer
name|buffer
decl_stmt|;
comment|/** The socket that we're doing overlapped IO on. */
name|evutil_socket_t
name|fd
decl_stmt|;
comment|/** pending I/O type */
name|unsigned
name|read_in_progress
range|:
literal|1
decl_stmt|;
name|unsigned
name|write_in_progress
range|:
literal|1
decl_stmt|;
comment|/** The first pinned chain in the buffer. */
name|struct
name|evbuffer_chain
modifier|*
name|first_pinned
decl_stmt|;
comment|/** How many chains are pinned; how many of the fields in buffers 	 * are we using. */
name|int
name|n_buffers
decl_stmt|;
name|WSABUF
name|buffers
index|[
name|MAX_WSABUFS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** Given an evbuffer, return the correponding evbuffer structure, or NULL if  * the evbuffer isn't overlapped. */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|evbuffer_overlapped
modifier|*
name|upcast_evbuffer
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|buf
operator|||
operator|!
name|buf
operator|->
name|is_overlapped
condition|)
return|return
name|NULL
return|;
return|return
name|EVUTIL_UPCAST
argument_list|(
name|buf
argument_list|,
expr|struct
name|evbuffer_overlapped
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Unpin all the chains noted as pinned in 'eo'. */
end_comment

begin_function
specifier|static
name|void
name|pin_release
parameter_list|(
name|struct
name|evbuffer_overlapped
modifier|*
name|eo
parameter_list|,
name|unsigned
name|flag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|next
decl_stmt|,
modifier|*
name|chain
init|=
name|eo
operator|->
name|first_pinned
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eo
operator|->
name|n_buffers
condition|;
operator|++
name|i
control|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
name|evbuffer_chain_unpin_
argument_list|(
name|chain
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|chain
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|evbuffer_commit_read_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|,
name|ev_ssize_t
name|nBytes
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf
init|=
name|upcast_evbuffer
argument_list|(
name|evbuf
argument_list|)
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|size_t
name|remaining
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|evbuf
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|buf
operator|->
name|read_in_progress
operator|&&
operator|!
name|buf
operator|->
name|write_in_progress
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|nBytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXX Can this be false? */
name|evbuffer_unfreeze
argument_list|(
name|evbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chainp
operator|=
name|evbuf
operator|->
name|last_with_datap
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|chainp
operator|)
operator|->
name|flags
operator|&
name|EVBUFFER_MEM_PINNED_R
operator|)
condition|)
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
expr_stmt|;
name|remaining
operator|=
name|nBytes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|remaining
operator|>
literal|0
operator|&&
name|i
operator|<
operator|(
name|unsigned
operator|)
name|buf
operator|->
name|n_buffers
condition|;
operator|++
name|i
control|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|*
name|chainp
argument_list|)
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|buffers
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|remaining
operator|<
name|len
condition|)
name|len
operator|=
name|remaining
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|off
operator|+=
name|len
expr_stmt|;
name|evbuf
operator|->
name|last_with_datap
operator|=
name|chainp
expr_stmt|;
name|remaining
operator|-=
name|len
expr_stmt|;
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|pin_release
argument_list|(
name|buf
argument_list|,
name|EVBUFFER_MEM_PINNED_R
argument_list|)
expr_stmt|;
name|buf
operator|->
name|read_in_progress
operator|=
literal|0
expr_stmt|;
name|evbuf
operator|->
name|total_len
operator|+=
name|nBytes
expr_stmt|;
name|evbuf
operator|->
name|n_add_for_cb
operator|+=
name|nBytes
expr_stmt|;
name|evbuffer_invoke_callbacks_
argument_list|(
name|evbuf
argument_list|)
expr_stmt|;
name|evbuffer_decref_and_unlock_
argument_list|(
name|evbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|evbuffer_commit_write_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|evbuf
parameter_list|,
name|ev_ssize_t
name|nBytes
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf
init|=
name|upcast_evbuffer
argument_list|(
name|evbuf
argument_list|)
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|evbuf
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|buf
operator|->
name|write_in_progress
operator|&&
operator|!
name|buf
operator|->
name|read_in_progress
argument_list|)
expr_stmt|;
name|evbuffer_unfreeze
argument_list|(
name|evbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_drain
argument_list|(
name|evbuf
argument_list|,
name|nBytes
argument_list|)
expr_stmt|;
name|pin_release
argument_list|(
name|buf
argument_list|,
name|EVBUFFER_MEM_PINNED_W
argument_list|)
expr_stmt|;
name|buf
operator|->
name|write_in_progress
operator|=
literal|0
expr_stmt|;
name|evbuffer_decref_and_unlock_
argument_list|(
name|evbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|evbuffer
modifier|*
name|evbuffer_overlapped_new_
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|evo
decl_stmt|;
name|evo
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evbuffer_overlapped
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|evo
condition|)
return|return
name|NULL
return|;
name|LIST_INIT
argument_list|(
operator|&
name|evo
operator|->
name|buffer
operator|.
name|callbacks
argument_list|)
expr_stmt|;
name|evo
operator|->
name|buffer
operator|.
name|refcnt
operator|=
literal|1
expr_stmt|;
name|evo
operator|->
name|buffer
operator|.
name|last_with_datap
operator|=
operator|&
name|evo
operator|->
name|buffer
operator|.
name|first
expr_stmt|;
name|evo
operator|->
name|buffer
operator|.
name|is_overlapped
operator|=
literal|1
expr_stmt|;
name|evo
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
return|return
operator|&
name|evo
operator|->
name|buffer
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_launch_write_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|ev_ssize_t
name|at_most
parameter_list|,
name|struct
name|event_overlapped
modifier|*
name|ol
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf_o
init|=
name|upcast_evbuffer
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
decl_stmt|;
name|DWORD
name|bytesSent
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
comment|/* No buffer, or it isn't overlapped */
return|return
operator|-
literal|1
return|;
block|}
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|buf_o
operator|->
name|read_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_start
operator|||
name|buf_o
operator|->
name|write_in_progress
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|buf
operator|->
name|total_len
condition|)
block|{
comment|/* Nothing to write */
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|at_most
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|at_most
operator|>
name|buf
operator|->
name|total_len
condition|)
block|{
name|at_most
operator|=
name|buf
operator|->
name|total_len
expr_stmt|;
block|}
name|evbuffer_freeze
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_o
operator|->
name|first_pinned
operator|=
name|NULL
expr_stmt|;
name|buf_o
operator|->
name|n_buffers
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|buf_o
operator|->
name|buffers
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf_o
operator|->
name|buffers
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|buf_o
operator|->
name|first_pinned
operator|=
name|buf
operator|->
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_WSABUFS
operator|&&
name|chain
condition|;
operator|++
name|i
operator|,
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|WSABUF
modifier|*
name|b
init|=
operator|&
name|buf_o
operator|->
name|buffers
index|[
name|i
index|]
decl_stmt|;
name|b
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chain
operator|->
name|buffer
operator|+
name|chain
operator|->
name|misalign
operator|)
expr_stmt|;
name|evbuffer_chain_pin_
argument_list|(
name|chain
argument_list|,
name|EVBUFFER_MEM_PINNED_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|at_most
operator|>
name|chain
operator|->
name|off
condition|)
block|{
comment|/* XXXX Cast is safe for now, since win32 has no 			   mmaped chains.  But later, we need to have this 			   add more WSAbufs if chain->off is greater than 			   ULONG_MAX */
name|b
operator|->
name|len
operator|=
operator|(
name|unsigned
name|long
operator|)
name|chain
operator|->
name|off
expr_stmt|;
name|at_most
operator|-=
name|chain
operator|->
name|off
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|len
operator|=
operator|(
name|unsigned
name|long
operator|)
name|at_most
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
name|buf_o
operator|->
name|n_buffers
operator|=
name|i
expr_stmt|;
name|evbuffer_incref_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSASend
argument_list|(
name|buf_o
operator|->
name|fd
argument_list|,
name|buf_o
operator|->
name|buffers
argument_list|,
name|i
argument_list|,
operator|&
name|bytesSent
argument_list|,
literal|0
argument_list|,
operator|&
name|ol
operator|->
name|overlapped
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|int
name|error
init|=
name|WSAGetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|WSA_IO_PENDING
condition|)
block|{
comment|/* An actual error. */
name|pin_release
argument_list|(
name|buf_o
argument_list|,
name|EVBUFFER_MEM_PINNED_W
argument_list|)
expr_stmt|;
name|evbuffer_unfreeze
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* decref */
goto|goto
name|done
goto|;
block|}
block|}
name|buf_o
operator|->
name|write_in_progress
operator|=
literal|1
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|evbuffer_launch_read_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|size_t
name|at_most
parameter_list|,
name|struct
name|event_overlapped
modifier|*
name|ol
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf_o
init|=
name|upcast_evbuffer
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nvecs
decl_stmt|;
name|int
name|npin
init|=
literal|0
decl_stmt|;
name|struct
name|evbuffer_chain
modifier|*
name|chain
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|DWORD
name|bytesRead
decl_stmt|;
name|DWORD
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|evbuffer_iovec
name|vecs
index|[
name|MAX_WSABUFS
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|buf_o
condition|)
return|return
operator|-
literal|1
return|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|buf_o
operator|->
name|write_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|freeze_end
operator|||
name|buf_o
operator|->
name|read_in_progress
condition|)
goto|goto
name|done
goto|;
name|buf_o
operator|->
name|first_pinned
operator|=
name|NULL
expr_stmt|;
name|buf_o
operator|->
name|n_buffers
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|buf_o
operator|->
name|buffers
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf_o
operator|->
name|buffers
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evbuffer_expand_fast_
argument_list|(
name|buf
argument_list|,
name|at_most
argument_list|,
name|MAX_WSABUFS
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|done
goto|;
name|evbuffer_freeze
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nvecs
operator|=
name|evbuffer_read_setup_vecs_
argument_list|(
name|buf
argument_list|,
name|at_most
argument_list|,
name|vecs
argument_list|,
name|MAX_WSABUFS
argument_list|,
operator|&
name|chainp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvecs
condition|;
operator|++
name|i
control|)
block|{
name|WSABUF_FROM_EVBUFFER_IOV
argument_list|(
operator|&
name|buf_o
operator|->
name|buffers
index|[
name|i
index|]
argument_list|,
operator|&
name|vecs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|buf_o
operator|->
name|n_buffers
operator|=
name|nvecs
expr_stmt|;
name|buf_o
operator|->
name|first_pinned
operator|=
name|chain
operator|=
operator|*
name|chainp
expr_stmt|;
name|npin
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|evbuffer_chain_pin_
argument_list|(
name|chain
argument_list|,
name|EVBUFFER_MEM_PINNED_R
argument_list|)
expr_stmt|;
operator|++
name|npin
expr_stmt|;
block|}
name|EVUTIL_ASSERT
argument_list|(
name|npin
operator|==
name|nvecs
argument_list|)
expr_stmt|;
name|evbuffer_incref_
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|WSARecv
argument_list|(
name|buf_o
operator|->
name|fd
argument_list|,
name|buf_o
operator|->
name|buffers
argument_list|,
name|nvecs
argument_list|,
operator|&
name|bytesRead
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|ol
operator|->
name|overlapped
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|int
name|error
init|=
name|WSAGetLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|error
operator|!=
name|WSA_IO_PENDING
condition|)
block|{
comment|/* An actual error. */
name|pin_release
argument_list|(
name|buf_o
argument_list|,
name|EVBUFFER_MEM_PINNED_R
argument_list|)
expr_stmt|;
name|evbuffer_unfreeze
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evbuffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* decref */
goto|goto
name|done
goto|;
block|}
block|}
name|buf_o
operator|->
name|read_in_progress
operator|=
literal|1
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|evutil_socket_t
name|evbuffer_overlapped_get_fd_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf_o
init|=
name|upcast_evbuffer
argument_list|(
name|buf
argument_list|)
decl_stmt|;
return|return
name|buf_o
condition|?
name|buf_o
operator|->
name|fd
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|evbuffer_overlapped_set_fd_
parameter_list|(
name|struct
name|evbuffer
modifier|*
name|buf
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|)
block|{
name|struct
name|evbuffer_overlapped
modifier|*
name|buf_o
init|=
name|upcast_evbuffer
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|EVBUFFER_LOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX is this right?, should it cancel current I/O operations? */
if|if
condition|(
name|buf_o
condition|)
name|buf_o
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|EVBUFFER_UNLOCK
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

