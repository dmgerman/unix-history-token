begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UTIL_INTERNAL_H_INCLUDED_
end_ifndef

begin_define
define|#
directive|define
name|UTIL_INTERNAL_H_INCLUDED_
end_define

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* For EVUTIL_ASSERT */
end_comment

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_EVENTFD_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/eventfd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"time-internal.h"
end_include

begin_include
include|#
directive|include
file|"ipv6-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* If we need magic to say "inline", get it for free internally. */
ifdef|#
directive|ifdef
name|EVENT__inline
define|#
directive|define
name|inline
value|EVENT__inline
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT____func__
define|#
directive|define
name|__func__
value|EVENT____func__
endif|#
directive|endif
comment|/* A good no-op to use in macro definitions. */
define|#
directive|define
name|EVUTIL_NIL_STMT_
value|((void)0)
comment|/* A no-op that tricks the compiler into thinking a condition is used while  * definitely not making any code for it.  Used to compile out asserts while  * avoiding "unused variable" warnings.  The "!" forces the compiler to  * do the sizeof() on an int, in case "condition" is a bitfield value.  */
define|#
directive|define
name|EVUTIL_NIL_CONDITION_
parameter_list|(
name|condition
parameter_list|)
value|do { \ 	(void)sizeof(!(condition));  \ } while(0)
comment|/* Internal use only: macros to match patterns of error codes in a    cross-platform way.  We need these macros because of two historical    reasons: first, nonblocking IO functions are generally written to give an    error on the "blocked now, try later" case, so sometimes an error from a    read, write, connect, or accept means "no error; just wait for more    data," and we need to look at the error code.  Second, Windows defines    a different set of error codes for sockets. */
ifndef|#
directive|ifndef
name|_WIN32
if|#
directive|if
name|EAGAIN
operator|==
name|EWOULDBLOCK
define|#
directive|define
name|EVUTIL_ERR_IS_EAGAIN
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == EAGAIN)
else|#
directive|else
define|#
directive|define
name|EVUTIL_ERR_IS_EAGAIN
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == EAGAIN || (e) == EWOULDBLOCK)
endif|#
directive|endif
comment|/* True iff e is an error that means a read/write operation can be retried. */
define|#
directive|define
name|EVUTIL_ERR_RW_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == EINTR || EVUTIL_ERR_IS_EAGAIN(e))
comment|/* True iff e is an error that means an connect can be retried. */
define|#
directive|define
name|EVUTIL_ERR_CONNECT_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == EINTR || (e) == EINPROGRESS)
comment|/* True iff e is an error that means a accept can be retried. */
define|#
directive|define
name|EVUTIL_ERR_ACCEPT_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == EINTR || EVUTIL_ERR_IS_EAGAIN(e) || (e) == ECONNABORTED)
comment|/* True iff e is an error that means the connection was refused */
define|#
directive|define
name|EVUTIL_ERR_CONNECT_REFUSED
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == ECONNREFUSED)
else|#
directive|else
comment|/* Win32 */
define|#
directive|define
name|EVUTIL_ERR_IS_EAGAIN
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == WSAEWOULDBLOCK || (e) == EAGAIN)
define|#
directive|define
name|EVUTIL_ERR_RW_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == WSAEWOULDBLOCK ||					\ 	    (e) == WSAEINTR)
define|#
directive|define
name|EVUTIL_ERR_CONNECT_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == WSAEWOULDBLOCK ||					\ 	    (e) == WSAEINTR ||						\ 	    (e) == WSAEINPROGRESS ||					\ 	    (e) == WSAEINVAL)
define|#
directive|define
name|EVUTIL_ERR_ACCEPT_RETRIABLE
parameter_list|(
name|e
parameter_list|)
define|\
value|EVUTIL_ERR_RW_RETRIABLE(e)
define|#
directive|define
name|EVUTIL_ERR_CONNECT_REFUSED
parameter_list|(
name|e
parameter_list|)
define|\
value|((e) == WSAECONNREFUSED)
endif|#
directive|endif
comment|/* Arguments for shutdown() */
ifdef|#
directive|ifdef
name|SHUT_RD
define|#
directive|define
name|EVUTIL_SHUT_RD
value|SHUT_RD
else|#
directive|else
define|#
directive|define
name|EVUTIL_SHUT_RD
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHUT_WR
define|#
directive|define
name|EVUTIL_SHUT_WR
value|SHUT_WR
else|#
directive|else
define|#
directive|define
name|EVUTIL_SHUT_WR
value|1
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHUT_BOTH
define|#
directive|define
name|EVUTIL_SHUT_BOTH
value|SHUT_BOTH
else|#
directive|else
define|#
directive|define
name|EVUTIL_SHUT_BOTH
value|2
endif|#
directive|endif
comment|/* Helper: Verify that all the elements in 'dlist' are internally consistent.  * Checks for circular lists and bad prev/next pointers.  *  * Example usage:  *    EVUTIL_ASSERT_LIST_OK(eventlist, event, ev_next);  */
define|#
directive|define
name|EVUTIL_ASSERT_LIST_OK
parameter_list|(
name|dlist
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|)
value|do {			\ 		struct type *elm1, *elm2, **nextp;			\ 		if (LIST_EMPTY((dlist)))				\ 			break;						\ 									\
comment|/* Check list for circularity using Floyd's */
value|\
comment|/* 'Tortoise and Hare' algorithm */
value|\ 		elm1 = LIST_FIRST((dlist));				\ 		elm2 = LIST_NEXT(elm1, field);				\ 		while (elm1&& elm2) {					\ 			EVUTIL_ASSERT(elm1 != elm2);			\ 			elm1 = LIST_NEXT(elm1, field);			\ 			elm2 = LIST_NEXT(elm2, field);			\ 			if (!elm2)					\ 				break;					\ 			EVUTIL_ASSERT(elm1 != elm2);			\ 			elm2 = LIST_NEXT(elm2, field);			\ 		}							\ 									\
comment|/* Now check next and prev pointers for consistency. */
value|\ 		nextp =&LIST_FIRST((dlist));				\ 		elm1 = LIST_FIRST((dlist));				\ 		while (elm1) {						\ 			EVUTIL_ASSERT(*nextp == elm1);			\ 			EVUTIL_ASSERT(nextp == elm1->field.le_prev);	\ 			nextp =&LIST_NEXT(elm1, field);		\ 			elm1 = *nextp;					\ 		}							\ 	} while (0)
comment|/* Helper: Verify that all the elements in a TAILQ are internally consistent.  * Checks for circular lists and bad prev/next pointers.  *  * Example usage:  *    EVUTIL_ASSERT_TAILQ_OK(activelist, event, ev_active_next);  */
define|#
directive|define
name|EVUTIL_ASSERT_TAILQ_OK
parameter_list|(
name|tailq
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|)
value|do {			\ 		struct type *elm1, *elm2, **nextp;			\ 		if (TAILQ_EMPTY((tailq)))				\ 			break;						\ 									\
comment|/* Check list for circularity using Floyd's */
value|\
comment|/* 'Tortoise and Hare' algorithm */
value|\ 		elm1 = TAILQ_FIRST((tailq));				\ 		elm2 = TAILQ_NEXT(elm1, field);				\ 		while (elm1&& elm2) {					\ 			EVUTIL_ASSERT(elm1 != elm2);			\ 			elm1 = TAILQ_NEXT(elm1, field);			\ 			elm2 = TAILQ_NEXT(elm2, field);			\ 			if (!elm2)					\ 				break;					\ 			EVUTIL_ASSERT(elm1 != elm2);			\ 			elm2 = TAILQ_NEXT(elm2, field);			\ 		}							\ 									\
comment|/* Now check next and prev pointers for consistency. */
value|\ 		nextp =&TAILQ_FIRST((tailq));				\ 		elm1 = TAILQ_FIRST((tailq));				\ 		while (elm1) {						\ 			EVUTIL_ASSERT(*nextp == elm1);			\ 			EVUTIL_ASSERT(nextp == elm1->field.tqe_prev);	\ 			nextp =&TAILQ_NEXT(elm1, field);		\ 			elm1 = *nextp;					\ 		}							\ 		EVUTIL_ASSERT(nextp == (tailq)->tqh_last);		\ 	} while (0)
comment|/* Locale-independent replacements for some ctypes functions.  Use these  * when you care about ASCII's notion of character types, because you are about  * to send those types onto the wire.  */
name|int
name|EVUTIL_ISALPHA_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISALNUM_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISSPACE_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISDIGIT_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISXDIGIT_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISPRINT_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISLOWER_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|int
name|EVUTIL_ISUPPER_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|char
name|EVUTIL_TOUPPER_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|char
name|EVUTIL_TOLOWER_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
comment|/** Remove all trailing horizontal whitespace (space or tab) from the end of a  * string */
name|void
name|evutil_rtrim_lws_
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/** Helper macro.  If we know that a given pointer points to a field in a     structure, return a pointer to the structure itself.  Used to implement     our half-baked C OO.  Example:      struct subtype { 	int x; 	struct supertype common; 	int y;     };     ...     void fn(struct supertype *super) { 	struct subtype *sub = EVUTIL_UPCAST(super, struct subtype, common); 	...     }  */
define|#
directive|define
name|EVUTIL_UPCAST
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|)
define|\
value|((type *)(((char*)(ptr)) - evutil_offsetof(type, field)))
comment|/* As open(pathname, flags, mode), except that the file is always opened with  * the close-on-exec flag set. (And the mode argument is mandatory.)  */
name|int
name|evutil_open_closeonexec_
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|flags
parameter_list|,
name|unsigned
name|mode
parameter_list|)
function_decl|;
name|int
name|evutil_read_file_
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
modifier|*
name|content_out
parameter_list|,
name|size_t
modifier|*
name|len_out
parameter_list|,
name|int
name|is_binary
parameter_list|)
function_decl|;
name|int
name|evutil_socket_connect_
parameter_list|(
name|evutil_socket_t
modifier|*
name|fd_ptr
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|socklen
parameter_list|)
function_decl|;
name|int
name|evutil_socket_finished_connecting_
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|)
function_decl|;
name|int
name|evutil_ersatz_socketpair_
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|evutil_socket_t
index|[]
parameter_list|)
function_decl|;
name|int
name|evutil_resolve_
parameter_list|(
name|int
name|family
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
modifier|*
name|socklen
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|evutil_getenv_
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/* Structure to hold the state of our weak random number generator.  */
struct|struct
name|evutil_weakrand_state
block|{
name|ev_uint32_t
name|seed
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|EVUTIL_WEAKRAND_MAX
value|EV_INT32_MAX
comment|/* Initialize the state of a week random number generator based on 'seed'.  If  * the seed is 0, construct a new seed based on not-very-strong platform  * entropy, like the PID and the time of day.  *  * This function, and the other evutil_weakrand* functions, are meant for  * speed, not security or statistical strength.  If you need a RNG which an  * attacker can't predict, or which passes strong statistical tests, use the  * evutil_secure_rng* functions instead.  */
name|ev_uint32_t
name|evutil_weakrand_seed_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|state
parameter_list|,
name|ev_uint32_t
name|seed
parameter_list|)
function_decl|;
comment|/* Return a pseudorandom value between 0 and EVUTIL_WEAKRAND_MAX inclusive.  * Updates the state in 'seed' as needed -- this value must be protected by a  * lock.  */
name|ev_int32_t
name|evutil_weakrand_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|seed
parameter_list|)
function_decl|;
comment|/* Return a pseudorandom value x such that 0<= x< top. top must be no more  * than EVUTIL_WEAKRAND_MAX. Updates the state in 'seed' as needed -- this  * value must be proteced by a lock */
name|ev_int32_t
name|evutil_weakrand_range_
parameter_list|(
name|struct
name|evutil_weakrand_state
modifier|*
name|seed
parameter_list|,
name|ev_int32_t
name|top
parameter_list|)
function_decl|;
comment|/* Evaluates to the same boolean value as 'p', and hints to the compiler that  * we expect this value to be false. */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|>=
literal|3
comment|/* gcc 3.0 or later */
define|#
directive|define
name|EVUTIL_UNLIKELY
parameter_list|(
name|p
parameter_list|)
value|__builtin_expect(!!(p),0)
else|#
directive|else
define|#
directive|define
name|EVUTIL_UNLIKELY
parameter_list|(
name|p
parameter_list|)
value|(p)
endif|#
directive|endif
comment|/* Replacement for assert() that calls event_errx on failure. */
ifdef|#
directive|ifdef
name|NDEBUG
define|#
directive|define
name|EVUTIL_ASSERT
parameter_list|(
name|cond
parameter_list|)
value|EVUTIL_NIL_CONDITION_(cond)
define|#
directive|define
name|EVUTIL_FAILURE_CHECK
parameter_list|(
name|cond
parameter_list|)
value|0
else|#
directive|else
define|#
directive|define
name|EVUTIL_ASSERT
parameter_list|(
name|cond
parameter_list|)
define|\
value|do {								\ 		if (EVUTIL_UNLIKELY(!(cond))) {				\ 			event_errx(EVENT_ERR_ABORT_,			\ 			    "%s:%d: Assertion %s failed in %s",		\ 			    __FILE__,__LINE__,#cond,__func__);		\
comment|/* In case a user-supplied handler tries to */
value|\
comment|/* return control to us, log and abort here. */
value|\ 			(void)fprintf(stderr,				\ 			    "%s:%d: Assertion %s failed in %s",		\ 			    __FILE__,__LINE__,#cond,__func__);		\ 			abort();					\ 		}							\ 	} while (0)
define|#
directive|define
name|EVUTIL_FAILURE_CHECK
parameter_list|(
name|cond
parameter_list|)
value|EVUTIL_UNLIKELY(cond)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EVENT__HAVE_STRUCT_SOCKADDR_STORAGE
comment|/* Replacement for sockaddr storage that we can use internally on platforms  * that lack it.  It is not space-efficient, but neither is sockaddr_storage.  */
struct|struct
name|sockaddr_storage
block|{
union|union
block|{
name|struct
name|sockaddr
name|ss_sa
decl_stmt|;
name|struct
name|sockaddr_in
name|ss_sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|ss_sin6
decl_stmt|;
name|char
name|ss_padding
index|[
literal|128
index|]
decl_stmt|;
block|}
name|ss_union
union|;
block|}
struct|;
define|#
directive|define
name|ss_family
value|ss_union.ss_sa.sa_family
endif|#
directive|endif
comment|/* Internal addrinfo error code.  This one is returned from only from  * evutil_getaddrinfo_common_, when we are sure that we'll have to hit a DNS  * server. */
define|#
directive|define
name|EVUTIL_EAI_NEED_RESOLVE
value|-90002
struct_decl|struct
name|evdns_base
struct_decl|;
struct_decl|struct
name|evdns_getaddrinfo_request
struct_decl|;
typedef|typedef
name|struct
name|evdns_getaddrinfo_request
modifier|*
function_decl|(
modifier|*
name|evdns_getaddrinfo_fn
function_decl|)
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints_in
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|void
name|evutil_set_evdns_getaddrinfo_fn_
parameter_list|(
name|evdns_getaddrinfo_fn
name|fn
parameter_list|)
function_decl|;
name|struct
name|evutil_addrinfo
modifier|*
name|evutil_new_addrinfo_
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|ev_socklen_t
name|socklen
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
function_decl|;
name|struct
name|evutil_addrinfo
modifier|*
name|evutil_addrinfo_append_
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|first
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|append
parameter_list|)
function_decl|;
name|void
name|evutil_adjust_hints_for_addrconfig_
parameter_list|(
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|)
function_decl|;
name|int
name|evutil_getaddrinfo_common_
parameter_list|(
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
modifier|*
name|res
parameter_list|,
name|int
modifier|*
name|portnum
parameter_list|)
function_decl|;
name|int
name|evutil_getaddrinfo_async_
parameter_list|(
name|struct
name|evdns_base
modifier|*
name|dns_base
parameter_list|,
specifier|const
name|char
modifier|*
name|nodename
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|evutil_addrinfo
modifier|*
name|hints_in
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|evutil_addrinfo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/** Return true iff sa is a looback address. (That is, it is 127.0.0.1/8, or  * ::1). */
name|int
name|evutil_sockaddr_is_loopback_
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
function_decl|;
comment|/**     Formats a sockaddr sa into a string buffer of size outlen stored in out.     Returns a pointer to out.  Always writes something into out, so it's safe     to use the output of this function without checking it for NULL.  */
specifier|const
name|char
modifier|*
name|evutil_format_sockaddr_port_
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|size_t
name|outlen
parameter_list|)
function_decl|;
name|int
name|evutil_hex_char_to_int_
parameter_list|(
name|char
name|c
parameter_list|)
function_decl|;
name|void
name|evutil_free_secure_rng_globals_
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|evutil_free_globals_
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|_WIN32
name|HMODULE
name|evutil_load_windows_system_library_
parameter_list|(
specifier|const
name|TCHAR
modifier|*
name|library_name
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EV_SIZE_FMT
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MINGW64__
argument_list|)
define|#
directive|define
name|EV_U64_FMT
value|"%I64u"
define|#
directive|define
name|EV_I64_FMT
value|"%I64d"
define|#
directive|define
name|EV_I64_ARG
parameter_list|(
name|x
parameter_list|)
value|((__int64)(x))
define|#
directive|define
name|EV_U64_ARG
parameter_list|(
name|x
parameter_list|)
value|((unsigned __int64)(x))
else|#
directive|else
define|#
directive|define
name|EV_U64_FMT
value|"%llu"
define|#
directive|define
name|EV_I64_FMT
value|"%lld"
define|#
directive|define
name|EV_I64_ARG
parameter_list|(
name|x
parameter_list|)
value|((long long)(x))
define|#
directive|define
name|EV_U64_ARG
parameter_list|(
name|x
parameter_list|)
value|((unsigned long long)(x))
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|EV_SOCK_FMT
value|EV_I64_FMT
define|#
directive|define
name|EV_SOCK_ARG
parameter_list|(
name|x
parameter_list|)
value|EV_I64_ARG((x))
else|#
directive|else
define|#
directive|define
name|EV_SOCK_FMT
value|"%d"
define|#
directive|define
name|EV_SOCK_ARG
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
if|#
directive|if
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
define|#
directive|define
name|EV_SIZE_FMT
value|"%zu"
define|#
directive|define
name|EV_SSIZE_FMT
value|"%zd"
define|#
directive|define
name|EV_SIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|(x)
define|#
directive|define
name|EV_SSIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EV_SIZE_FMT
if|#
directive|if
operator|(
name|EVENT__SIZEOF_SIZE_T
operator|<=
name|EVENT__SIZEOF_LONG
operator|)
define|#
directive|define
name|EV_SIZE_FMT
value|"%lu"
define|#
directive|define
name|EV_SSIZE_FMT
value|"%ld"
define|#
directive|define
name|EV_SIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|((unsigned long)(x))
define|#
directive|define
name|EV_SSIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|((long)(x))
else|#
directive|else
define|#
directive|define
name|EV_SIZE_FMT
value|EV_U64_FMT
define|#
directive|define
name|EV_SSIZE_FMT
value|EV_I64_FMT
define|#
directive|define
name|EV_SIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|EV_U64_ARG(x)
define|#
directive|define
name|EV_SSIZE_ARG
parameter_list|(
name|x
parameter_list|)
value|EV_I64_ARG(x)
endif|#
directive|endif
endif|#
directive|endif
name|evutil_socket_t
name|evutil_socket_
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
function_decl|;
name|evutil_socket_t
name|evutil_accept4_
parameter_list|(
name|evutil_socket_t
name|sockfd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|ev_socklen_t
modifier|*
name|addrlen
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
comment|/* used by one of the test programs.. */
name|EVENT2_EXPORT_SYMBOL
name|int
name|evutil_make_internal_pipe_
parameter_list|(
name|evutil_socket_t
name|fd
index|[
literal|2
index|]
parameter_list|)
function_decl|;
name|evutil_socket_t
name|evutil_eventfd_
parameter_list|(
name|unsigned
name|initval
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|SOCK_NONBLOCK
define|#
directive|define
name|EVUTIL_SOCK_NONBLOCK
value|SOCK_NONBLOCK
else|#
directive|else
define|#
directive|define
name|EVUTIL_SOCK_NONBLOCK
value|0x4000000
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOCK_CLOEXEC
define|#
directive|define
name|EVUTIL_SOCK_CLOEXEC
value|SOCK_CLOEXEC
else|#
directive|else
define|#
directive|define
name|EVUTIL_SOCK_CLOEXEC
value|0x80000000
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EFD_NONBLOCK
define|#
directive|define
name|EVUTIL_EFD_NONBLOCK
value|EFD_NONBLOCK
else|#
directive|else
define|#
directive|define
name|EVUTIL_EFD_NONBLOCK
value|0x4000
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EFD_CLOEXEC
define|#
directive|define
name|EVUTIL_EFD_CLOEXEC
value|EFD_CLOEXEC
else|#
directive|else
define|#
directive|define
name|EVUTIL_EFD_CLOEXEC
value|0x8000
endif|#
directive|endif
name|void
name|evutil_memclear_
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

