begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009-2012 Niels Provos, Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_comment
comment|/* Minimum required for InitializeCriticalSectionAndSpinCount */
end_comment

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0403
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<mswsock.h>
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_define
define|#
directive|define
name|NOTIFICATION_KEY
value|((ULONG_PTR)-1)
end_define

begin_function
name|void
name|event_overlapped_init_
parameter_list|(
name|struct
name|event_overlapped
modifier|*
name|o
parameter_list|,
name|iocp_callback
name|cb
parameter_list|)
block|{
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_overlapped
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_entry
parameter_list|(
name|OVERLAPPED
modifier|*
name|o
parameter_list|,
name|ULONG_PTR
name|completion_key
parameter_list|,
name|DWORD
name|nBytes
parameter_list|,
name|int
name|ok
parameter_list|)
block|{
name|struct
name|event_overlapped
modifier|*
name|eo
init|=
name|EVUTIL_UPCAST
argument_list|(
name|o
argument_list|,
expr|struct
name|event_overlapped
argument_list|,
name|overlapped
argument_list|)
decl_stmt|;
name|eo
operator|->
name|cb
argument_list|(
name|eo
argument_list|,
name|completion_key
argument_list|,
name|nBytes
argument_list|,
name|ok
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop
parameter_list|(
name|void
modifier|*
name|port_
parameter_list|)
block|{
name|struct
name|event_iocp_port
modifier|*
name|port
init|=
name|port_
decl_stmt|;
name|long
name|ms
init|=
name|port
operator|->
name|ms
decl_stmt|;
name|HANDLE
name|p
init|=
name|port
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|ms
operator|<=
literal|0
condition|)
name|ms
operator|=
name|INFINITE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|OVERLAPPED
modifier|*
name|overlapped
init|=
name|NULL
decl_stmt|;
name|ULONG_PTR
name|key
init|=
literal|0
decl_stmt|;
name|DWORD
name|bytes
init|=
literal|0
decl_stmt|;
name|int
name|ok
init|=
name|GetQueuedCompletionStatus
argument_list|(
name|p
argument_list|,
operator|&
name|bytes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|overlapped
argument_list|,
name|ms
argument_list|)
decl_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|shutdown
condition|)
block|{
if|if
condition|(
operator|--
name|port
operator|->
name|n_live_threads
operator|==
literal|0
condition|)
name|ReleaseSemaphore
argument_list|(
name|port
operator|->
name|shutdownSemaphore
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|LeaveCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NOTIFICATION_KEY
operator|&&
name|overlapped
condition|)
name|handle_entry
argument_list|(
name|overlapped
argument_list|,
name|key
argument_list|,
name|bytes
argument_list|,
name|ok
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|overlapped
condition|)
break|break;
block|}
name|event_warnx
argument_list|(
literal|"GetQueuedCompletionStatus exited with no event."
argument_list|)
expr_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|port
operator|->
name|n_live_threads
operator|==
literal|0
condition|)
name|ReleaseSemaphore
argument_list|(
name|port
operator|->
name|shutdownSemaphore
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_iocp_port_associate_
parameter_list|(
name|struct
name|event_iocp_port
modifier|*
name|port
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|)
block|{
name|HANDLE
name|h
decl_stmt|;
name|h
operator|=
name|CreateIoCompletionPort
argument_list|(
operator|(
name|HANDLE
operator|)
name|fd
argument_list|,
name|port
operator|->
name|port
argument_list|,
name|key
argument_list|,
name|port
operator|->
name|n_threads
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_extension_function
parameter_list|(
name|SOCKET
name|s
parameter_list|,
specifier|const
name|GUID
modifier|*
name|which_fn
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|NULL
decl_stmt|;
name|DWORD
name|bytes
init|=
literal|0
decl_stmt|;
name|WSAIoctl
argument_list|(
name|s
argument_list|,
name|SIO_GET_EXTENSION_FUNCTION_POINTER
argument_list|,
operator|(
name|GUID
operator|*
operator|)
name|which_fn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|which_fn
argument_list|)
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|&
name|bytes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No need to detect errors here: if ptr is set, then we have a good 	   function pointer.  Otherwise, we should behave as if we had no 	   function pointer. 	*/
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Mingw doesn't have these in its mswsock.h.  The values are copied from    wine.h.   Perhaps if we copy them exactly, the cargo will come again. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WSAID_ACCEPTEX
end_ifndef

begin_define
define|#
directive|define
name|WSAID_ACCEPTEX
define|\
value|{0xb5367df1,0xcbac,0x11cf,{0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WSAID_CONNECTEX
end_ifndef

begin_define
define|#
directive|define
name|WSAID_CONNECTEX
define|\
value|{0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WSAID_GETACCEPTEXSOCKADDRS
end_ifndef

begin_define
define|#
directive|define
name|WSAID_GETACCEPTEXSOCKADDRS
define|\
value|{0xb5367df2,0xcbac,0x11cf,{0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|extension_fns_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_extension_functions
parameter_list|(
name|struct
name|win32_extension_fns
modifier|*
name|ext
parameter_list|)
block|{
specifier|const
name|GUID
name|acceptex
init|=
name|WSAID_ACCEPTEX
decl_stmt|;
specifier|const
name|GUID
name|connectex
init|=
name|WSAID_CONNECTEX
decl_stmt|;
specifier|const
name|GUID
name|getacceptexsockaddrs
init|=
name|WSAID_GETACCEPTEXSOCKADDRS
decl_stmt|;
name|SOCKET
name|s
init|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|INVALID_SOCKET
condition|)
return|return;
name|ext
operator|->
name|AcceptEx
operator|=
name|get_extension_function
argument_list|(
name|s
argument_list|,
operator|&
name|acceptex
argument_list|)
expr_stmt|;
name|ext
operator|->
name|ConnectEx
operator|=
name|get_extension_function
argument_list|(
name|s
argument_list|,
operator|&
name|connectex
argument_list|)
expr_stmt|;
name|ext
operator|->
name|GetAcceptExSockaddrs
operator|=
name|get_extension_function
argument_list|(
name|s
argument_list|,
operator|&
name|getacceptexsockaddrs
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|extension_fns_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|win32_extension_fns
name|the_extension_fns
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|win32_extension_fns
modifier|*
name|event_get_win32_extension_fns_
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|the_extension_fns
return|;
block|}
end_function

begin_define
define|#
directive|define
name|N_CPUS_DEFAULT
value|2
end_define

begin_function
name|struct
name|event_iocp_port
modifier|*
name|event_iocp_port_launch_
parameter_list|(
name|int
name|n_cpus
parameter_list|)
block|{
name|struct
name|event_iocp_port
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|extension_fns_initialized
condition|)
name|init_extension_functions
argument_list|(
operator|&
name|the_extension_fns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|port
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_iocp_port
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n_cpus
operator|<=
literal|0
condition|)
name|n_cpus
operator|=
name|N_CPUS_DEFAULT
expr_stmt|;
name|port
operator|->
name|n_threads
operator|=
name|n_cpus
operator|*
literal|2
expr_stmt|;
name|port
operator|->
name|threads
operator|=
name|mm_calloc
argument_list|(
name|port
operator|->
name|n_threads
argument_list|,
sizeof|sizeof
argument_list|(
name|HANDLE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|threads
condition|)
goto|goto
name|err
goto|;
name|port
operator|->
name|port
operator|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|n_cpus
argument_list|)
expr_stmt|;
name|port
operator|->
name|ms
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|port
condition|)
goto|goto
name|err
goto|;
name|port
operator|->
name|shutdownSemaphore
operator|=
name|CreateSemaphore
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|shutdownSemaphore
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port
operator|->
name|n_threads
condition|;
operator|++
name|i
control|)
block|{
name|ev_uintptr_t
name|th
init|=
name|_beginthread
argument_list|(
name|loop
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|th
operator|==
operator|(
name|ev_uintptr_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|port
operator|->
name|threads
index|[
name|i
index|]
operator|=
operator|(
name|HANDLE
operator|)
name|th
expr_stmt|;
operator|++
name|port
operator|->
name|n_live_threads
expr_stmt|;
block|}
name|InitializeCriticalSectionAndSpinCount
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
return|return
name|port
return|;
name|err
label|:
if|if
condition|(
name|port
operator|->
name|port
condition|)
name|CloseHandle
argument_list|(
name|port
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|threads
condition|)
name|mm_free
argument_list|(
name|port
operator|->
name|threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|shutdownSemaphore
condition|)
name|CloseHandle
argument_list|(
name|port
operator|->
name|shutdownSemaphore
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_iocp_port_unlock_and_free_
parameter_list|(
name|struct
name|event_iocp_port
modifier|*
name|port
parameter_list|)
block|{
name|DeleteCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|port
operator|->
name|port
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
name|port
operator|->
name|shutdownSemaphore
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|port
operator|->
name|threads
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|event_iocp_notify_all
parameter_list|(
name|struct
name|event_iocp_port
modifier|*
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|ok
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port
operator|->
name|n_threads
condition|;
operator|++
name|i
control|)
block|{
name|r
operator|=
name|PostQueuedCompletionStatus
argument_list|(
name|port
operator|->
name|port
argument_list|,
literal|0
argument_list|,
name|NOTIFICATION_KEY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ok
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|event_iocp_shutdown_
parameter_list|(
name|struct
name|event_iocp_port
modifier|*
name|port
parameter_list|,
name|long
name|waitMsec
parameter_list|)
block|{
name|DWORD
name|ms
init|=
name|INFINITE
decl_stmt|;
name|int
name|n
decl_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|port
operator|->
name|shutdown
operator|=
literal|1
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|event_iocp_notify_all
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitMsec
operator|>=
literal|0
condition|)
name|ms
operator|=
name|waitMsec
expr_stmt|;
name|WaitForSingleObject
argument_list|(
name|port
operator|->
name|shutdownSemaphore
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|EnterCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|port
operator|->
name|n_live_threads
expr_stmt|;
name|LeaveCriticalSection
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|event_iocp_port_unlock_and_free_
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|event_iocp_activate_overlapped_
parameter_list|(
name|struct
name|event_iocp_port
modifier|*
name|port
parameter_list|,
name|struct
name|event_overlapped
modifier|*
name|o
parameter_list|,
name|ev_uintptr_t
name|key
parameter_list|,
name|ev_uint32_t
name|n
parameter_list|)
block|{
name|BOOL
name|r
decl_stmt|;
name|r
operator|=
name|PostQueuedCompletionStatus
argument_list|(
name|port
operator|->
name|port
argument_list|,
name|n
argument_list|,
name|key
argument_list|,
operator|&
name|o
operator|->
name|overlapped
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|event_iocp_port
modifier|*
name|event_base_get_iocp_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|base
operator|->
name|iocp
return|;
else|#
directive|else
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

end_unit

