begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  * Copyright (c) 2002-2006 Niels Provos<provos@citi.umich.edu>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent.h"
end_include

begin_include
include|#
directive|include
file|"event2/bufferevent_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/buffer.h"
end_include

begin_include
include|#
directive|include
file|"ratelim-internal.h"
end_include

begin_include
include|#
directive|include
file|"bufferevent-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_function
name|int
name|ev_token_bucket_init_
parameter_list|(
name|struct
name|ev_token_bucket
modifier|*
name|bucket
parameter_list|,
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|,
name|ev_uint32_t
name|current_tick
parameter_list|,
name|int
name|reinitialize
parameter_list|)
block|{
if|if
condition|(
name|reinitialize
condition|)
block|{
comment|/* on reinitialization, we only clip downwards, since we've 		   already used who-knows-how-much bandwidth this tick.  We 		   leave "last_updated" as it is; the next update will add the 		   appropriate amount of bandwidth to the bucket. 		*/
if|if
condition|(
name|bucket
operator|->
name|read_limit
operator|>
operator|(
name|ev_int64_t
operator|)
name|cfg
operator|->
name|read_maximum
condition|)
name|bucket
operator|->
name|read_limit
operator|=
name|cfg
operator|->
name|read_maximum
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|write_limit
operator|>
operator|(
name|ev_int64_t
operator|)
name|cfg
operator|->
name|write_maximum
condition|)
name|bucket
operator|->
name|write_limit
operator|=
name|cfg
operator|->
name|write_maximum
expr_stmt|;
block|}
else|else
block|{
name|bucket
operator|->
name|read_limit
operator|=
name|cfg
operator|->
name|read_rate
expr_stmt|;
name|bucket
operator|->
name|write_limit
operator|=
name|cfg
operator|->
name|write_rate
expr_stmt|;
name|bucket
operator|->
name|last_updated
operator|=
name|current_tick
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ev_token_bucket_update_
parameter_list|(
name|struct
name|ev_token_bucket
modifier|*
name|bucket
parameter_list|,
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|,
name|ev_uint32_t
name|current_tick
parameter_list|)
block|{
comment|/* It's okay if the tick number overflows, since we'll just 	 * wrap around when we do the unsigned substraction. */
name|unsigned
name|n_ticks
init|=
name|current_tick
operator|-
name|bucket
operator|->
name|last_updated
decl_stmt|;
comment|/* Make sure some ticks actually happened, and that time didn't 	 * roll back. */
if|if
condition|(
name|n_ticks
operator|==
literal|0
operator|||
name|n_ticks
operator|>
name|INT_MAX
condition|)
return|return
literal|0
return|;
comment|/* Naively, we would say 		bucket->limit += n_ticks * cfg->rate;  		if (bucket->limit> cfg->maximum) 			bucket->limit = cfg->maximum;  	   But we're worried about overflow, so we do it like this: 	*/
if|if
condition|(
operator|(
name|cfg
operator|->
name|read_maximum
operator|-
name|bucket
operator|->
name|read_limit
operator|)
operator|/
name|n_ticks
operator|<
name|cfg
operator|->
name|read_rate
condition|)
name|bucket
operator|->
name|read_limit
operator|=
name|cfg
operator|->
name|read_maximum
expr_stmt|;
else|else
name|bucket
operator|->
name|read_limit
operator|+=
name|n_ticks
operator|*
name|cfg
operator|->
name|read_rate
expr_stmt|;
if|if
condition|(
operator|(
name|cfg
operator|->
name|write_maximum
operator|-
name|bucket
operator|->
name|write_limit
operator|)
operator|/
name|n_ticks
operator|<
name|cfg
operator|->
name|write_rate
condition|)
name|bucket
operator|->
name|write_limit
operator|=
name|cfg
operator|->
name|write_maximum
expr_stmt|;
else|else
name|bucket
operator|->
name|write_limit
operator|+=
name|n_ticks
operator|*
name|cfg
operator|->
name|write_rate
expr_stmt|;
name|bucket
operator|->
name|last_updated
operator|=
name|current_tick
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bufferevent_update_buckets
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|)
block|{
comment|/* Must hold lock on bev. */
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|tick
decl_stmt|;
name|event_base_gettimeofday_cached
argument_list|(
name|bev
operator|->
name|bev
operator|.
name|ev_base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|tick
operator|=
name|ev_token_bucket_get_tick_
argument_list|(
operator|&
name|now
argument_list|,
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick
operator|!=
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|last_updated
condition|)
name|ev_token_bucket_update_
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
argument_list|,
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|,
name|tick
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ev_uint32_t
name|ev_token_bucket_get_tick_
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|)
block|{
comment|/* This computation uses two multiplies and a divide.  We could do 	 * fewer if we knew that the tick length was an integer number of 	 * seconds, or if we knew it divided evenly into a second.  We should 	 * investigate that more. 	 */
comment|/* We cast to an ev_uint64_t first, since we don't want to overflow 	 * before we do the final divide. */
name|ev_uint64_t
name|msec
init|=
operator|(
name|ev_uint64_t
operator|)
name|tv
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|->
name|tv_usec
operator|/
literal|1000
decl_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|msec
operator|/
name|cfg
operator|->
name|msec_per_tick
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ev_token_bucket_cfg
modifier|*
name|ev_token_bucket_cfg_new
parameter_list|(
name|size_t
name|read_rate
parameter_list|,
name|size_t
name|read_burst
parameter_list|,
name|size_t
name|write_rate
parameter_list|,
name|size_t
name|write_burst
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tick_len
parameter_list|)
block|{
name|struct
name|ev_token_bucket_cfg
modifier|*
name|r
decl_stmt|;
name|struct
name|timeval
name|g
decl_stmt|;
if|if
condition|(
operator|!
name|tick_len
condition|)
block|{
name|g
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|g
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tick_len
operator|=
operator|&
name|g
expr_stmt|;
block|}
if|if
condition|(
name|read_rate
operator|>
name|read_burst
operator|||
name|write_rate
operator|>
name|write_burst
operator|||
name|read_rate
operator|<
literal|1
operator|||
name|write_rate
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|read_rate
operator|>
name|EV_RATE_LIMIT_MAX
operator|||
name|write_rate
operator|>
name|EV_RATE_LIMIT_MAX
operator|||
name|read_burst
operator|>
name|EV_RATE_LIMIT_MAX
operator|||
name|write_burst
operator|>
name|EV_RATE_LIMIT_MAX
condition|)
return|return
name|NULL
return|;
name|r
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ev_token_bucket_cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|NULL
return|;
name|r
operator|->
name|read_rate
operator|=
name|read_rate
expr_stmt|;
name|r
operator|->
name|write_rate
operator|=
name|write_rate
expr_stmt|;
name|r
operator|->
name|read_maximum
operator|=
name|read_burst
expr_stmt|;
name|r
operator|->
name|write_maximum
operator|=
name|write_burst
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|r
operator|->
name|tick_timeout
argument_list|,
name|tick_len
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|msec_per_tick
operator|=
operator|(
name|tick_len
operator|->
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
name|tick_len
operator|->
name|tv_usec
operator|&
name|COMMON_TIMEOUT_MICROSECONDS_MASK
operator|)
operator|/
literal|1000
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|ev_token_bucket_cfg_free
parameter_list|(
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|mm_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default values for max_single_read& max_single_write variables. */
end_comment

begin_define
define|#
directive|define
name|MAX_SINGLE_READ_DEFAULT
value|16384
end_define

begin_define
define|#
directive|define
name|MAX_SINGLE_WRITE_DEFAULT
value|16384
end_define

begin_define
define|#
directive|define
name|LOCK_GROUP
parameter_list|(
name|g
parameter_list|)
value|EVLOCK_LOCK((g)->lock, 0)
end_define

begin_define
define|#
directive|define
name|UNLOCK_GROUP
parameter_list|(
name|g
parameter_list|)
value|EVLOCK_UNLOCK((g)->lock, 0)
end_define

begin_function_decl
specifier|static
name|int
name|bev_group_suspend_reading_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bev_group_suspend_writing_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bev_group_unsuspend_reading_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bev_group_unsuspend_writing_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** Helper: figure out the maximum amount we should write if is_write, or     the maximum amount we should read if is_read.  Return that maximum, or     0 if our bucket is wholly exhausted.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ev_ssize_t
name|bufferevent_get_rlim_max_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|,
name|int
name|is_write
parameter_list|)
block|{
comment|/* needs lock on bev. */
name|ev_ssize_t
name|max_so_far
init|=
name|is_write
condition|?
name|bev
operator|->
name|max_single_write
else|:
name|bev
operator|->
name|max_single_read
decl_stmt|;
define|#
directive|define
name|LIM
parameter_list|(
name|x
parameter_list|)
define|\
value|(is_write ? (x).write_limit : (x).read_limit)
define|#
directive|define
name|GROUP_SUSPENDED
parameter_list|(
name|g
parameter_list|)
define|\
value|(is_write ? (g)->write_suspended : (g)->read_suspended)
comment|/* Sets max_so_far to MIN(x, max_so_far) */
define|#
directive|define
name|CLAMPTO
parameter_list|(
name|x
parameter_list|)
define|\
value|do {					\ 		if (max_so_far> (x))		\ 			max_so_far = (x);	\ 	} while (0);
if|if
condition|(
operator|!
name|bev
operator|->
name|rate_limiting
condition|)
return|return
name|max_so_far
return|;
comment|/* If rate-limiting is enabled at all, update the appropriate 	   bucket, and take the smaller of our rate limit and the group 	   rate limit. 	 */
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|bufferevent_update_buckets
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|max_so_far
operator|=
name|LIM
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
condition|)
block|{
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
init|=
name|bev
operator|->
name|rate_limiting
operator|->
name|group
decl_stmt|;
name|ev_ssize_t
name|share
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|GROUP_SUSPENDED
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|/* We can get here if we failed to lock this 			 * particular bufferevent while suspending the whole 			 * group. */
if|if
condition|(
name|is_write
condition|)
name|bufferevent_suspend_write_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
else|else
name|bufferevent_suspend_read_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
name|share
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXXX probably we should divide among the active 			 * members, not the total members. */
name|share
operator|=
name|LIM
argument_list|(
name|g
operator|->
name|rate_limit
argument_list|)
operator|/
name|g
operator|->
name|n_members
expr_stmt|;
if|if
condition|(
name|share
operator|<
name|g
operator|->
name|min_share
condition|)
name|share
operator|=
name|g
operator|->
name|min_share
expr_stmt|;
block|}
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|CLAMPTO
argument_list|(
name|share
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_so_far
operator|<
literal|0
condition|)
name|max_so_far
operator|=
literal|0
expr_stmt|;
return|return
name|max_so_far
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_read_max_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|)
block|{
return|return
name|bufferevent_get_rlim_max_
argument_list|(
name|bev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_write_max_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|)
block|{
return|return
name|bufferevent_get_rlim_max_
argument_list|(
name|bev
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_decrement_read_buckets_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|,
name|ev_ssize_t
name|bytes
parameter_list|)
block|{
comment|/* XXXXX Make sure all users of this function check its return value */
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* need to hold lock on bev */
if|if
condition|(
operator|!
name|bev
operator|->
name|rate_limiting
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
operator|<=
literal|0
condition|)
block|{
name|bufferevent_suspend_read_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
operator|->
name|tick_timeout
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bev
operator|->
name|read_suspended
operator|&
name|BEV_SUSPEND_BW
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|write_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
condition|)
block|{
name|LOCK_GROUP
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|rate_limit
operator|.
name|read_limit
operator|-=
name|bytes
expr_stmt|;
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|total_read
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|rate_limit
operator|.
name|read_limit
operator|<=
literal|0
condition|)
block|{
name|bev_group_suspend_reading_
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|read_suspended
condition|)
block|{
name|bev_group_unsuspend_reading_
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_GROUP
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_decrement_write_buckets_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|,
name|ev_ssize_t
name|bytes
parameter_list|)
block|{
comment|/* XXXXX Make sure all users of this function check its return value */
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|/* need to hold lock */
if|if
condition|(
operator|!
name|bev
operator|->
name|rate_limiting
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
operator|-=
name|bytes
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
operator|<=
literal|0
condition|)
block|{
name|bufferevent_suspend_write_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
operator|->
name|tick_timeout
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bev
operator|->
name|write_suspended
operator|&
name|BEV_SUSPEND_BW
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bev
operator|->
name|read_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
name|event_del
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_write_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
condition|)
block|{
name|LOCK_GROUP
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|rate_limit
operator|.
name|write_limit
operator|-=
name|bytes
expr_stmt|;
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|total_written
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|rate_limit
operator|.
name|write_limit
operator|<=
literal|0
condition|)
block|{
name|bev_group_suspend_writing_
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
operator|->
name|write_suspended
condition|)
block|{
name|bev_group_unsuspend_writing_
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_GROUP
argument_list|(
name|bev
operator|->
name|rate_limiting
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** Stop reading on every bufferevent in<b>g</b> */
end_comment

begin_function
specifier|static
name|int
name|bev_group_suspend_reading_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
comment|/* Needs group lock */
name|struct
name|bufferevent_private
modifier|*
name|bev
decl_stmt|;
name|g
operator|->
name|read_suspended
operator|=
literal|1
expr_stmt|;
name|g
operator|->
name|pending_unsuspend_read
operator|=
literal|0
expr_stmt|;
comment|/* Note that in this loop we call EVLOCK_TRY_LOCK_ instead of BEV_LOCK, 	   to prevent a deadlock.  (Ordinarily, the group lock nests inside 	   the bufferevent locks.  If we are unable to lock any individual 	   bufferevent, it will find out later when it looks at its limit 	   and sees that its group is suspended.) 	*/
name|LIST_FOREACH
argument_list|(
argument|bev
argument_list|,
argument|&g->members
argument_list|,
argument|rate_limiting->next_in_group
argument_list|)
block|{
if|if
condition|(
name|EVLOCK_TRY_LOCK_
argument_list|(
name|bev
operator|->
name|lock
argument_list|)
condition|)
block|{
name|bufferevent_suspend_read_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|bev
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Stop writing on every bufferevent in<b>g</b> */
end_comment

begin_function
specifier|static
name|int
name|bev_group_suspend_writing_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
comment|/* Needs group lock */
name|struct
name|bufferevent_private
modifier|*
name|bev
decl_stmt|;
name|g
operator|->
name|write_suspended
operator|=
literal|1
expr_stmt|;
name|g
operator|->
name|pending_unsuspend_write
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bev
argument_list|,
argument|&g->members
argument_list|,
argument|rate_limiting->next_in_group
argument_list|)
block|{
if|if
condition|(
name|EVLOCK_TRY_LOCK_
argument_list|(
name|bev
operator|->
name|lock
argument_list|)
condition|)
block|{
name|bufferevent_suspend_write_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
name|EVLOCK_UNLOCK
argument_list|(
name|bev
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Timer callback invoked on a single bufferevent with one or more exhausted     buckets when they are ready to refill. */
end_comment

begin_function
specifier|static
name|void
name|bev_refill_callback_
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|tick
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev
init|=
name|arg
decl_stmt|;
name|int
name|again
init|=
literal|0
decl_stmt|;
name|BEV_LOCK
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bev
operator|->
name|rate_limiting
operator|||
operator|!
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|BEV_UNLOCK
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First, update the bucket */
name|event_base_gettimeofday_cached
argument_list|(
name|bev
operator|->
name|bev
operator|.
name|ev_base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|tick
operator|=
name|ev_token_bucket_get_tick_
argument_list|(
operator|&
name|now
argument_list|,
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|ev_token_bucket_update_
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
argument_list|,
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|,
name|tick
argument_list|)
expr_stmt|;
comment|/* Now unsuspend any read/write operations as appropriate. */
if|if
condition|(
operator|(
name|bev
operator|->
name|read_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
block|{
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
operator|>
literal|0
condition|)
name|bufferevent_unsuspend_read_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
else|else
name|again
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bev
operator|->
name|write_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
block|{
if|if
condition|(
name|bev
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
operator|>
literal|0
condition|)
name|bufferevent_unsuspend_write_
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
else|else
name|again
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|again
condition|)
block|{
comment|/* One or more of the buckets may need another refill if they 		   started negative.  		   XXXX if we need to be quiet for more ticks, we should 		   maybe figure out what timeout we really want. 		*/
comment|/* XXXX Handle event_add failure somehow */
name|event_add
argument_list|(
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|bev
operator|->
name|rate_limiting
operator|->
name|cfg
operator|->
name|tick_timeout
argument_list|)
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
operator|&
name|bev
operator|->
name|bev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Helper: grab a random element from a bufferevent group.  *  * Requires that we hold the lock on the group.  */
end_comment

begin_function
specifier|static
name|struct
name|bufferevent_private
modifier|*
name|bev_group_random_element_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|group
parameter_list|)
block|{
name|int
name|which
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev
decl_stmt|;
comment|/* requires group lock */
if|if
condition|(
operator|!
name|group
operator|->
name|n_members
condition|)
return|return
name|NULL
return|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|group
operator|->
name|members
argument_list|)
argument_list|)
expr_stmt|;
name|which
operator|=
name|evutil_weakrand_range_
argument_list|(
operator|&
name|group
operator|->
name|weakrand_seed
argument_list|,
name|group
operator|->
name|n_members
argument_list|)
expr_stmt|;
name|bev
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|group
operator|->
name|members
argument_list|)
expr_stmt|;
while|while
condition|(
name|which
operator|--
condition|)
name|bev
operator|=
name|LIST_NEXT
argument_list|(
name|bev
argument_list|,
name|rate_limiting
operator|->
name|next_in_group
argument_list|)
expr_stmt|;
return|return
name|bev
return|;
block|}
end_function

begin_comment
comment|/** Iterate over the elements of a rate-limiting group 'g' with a random     starting point, assigning each to the variable 'bev', and executing the     block 'block'.      We do this in a half-baked effort to get fairness among group members.     XXX Round-robin or some kind of priority queue would be even more fair.  */
end_comment

begin_define
define|#
directive|define
name|FOREACH_RANDOM_ORDER
parameter_list|(
name|block
parameter_list|)
define|\
value|do {						\ 		first = bev_group_random_element_(g);	\ 		for (bev = first; bev != LIST_END(&g->members); \ 		    bev = LIST_NEXT(bev, rate_limiting->next_in_group)) { \ 			block ;					 \ 		}						 \ 		for (bev = LIST_FIRST(&g->members); bev&& bev != first; \ 		    bev = LIST_NEXT(bev, rate_limiting->next_in_group)) { \ 			block ;						\ 		}							\ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|bev_group_unsuspend_reading_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
name|int
name|again
init|=
literal|0
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|g
operator|->
name|read_suspended
operator|=
literal|0
expr_stmt|;
name|FOREACH_RANDOM_ORDER
argument_list|(
argument|{ 		if (EVLOCK_TRY_LOCK_(bev->lock)) { 			bufferevent_unsuspend_read_(&bev->bev, 			    BEV_SUSPEND_BW_GROUP); 			EVLOCK_UNLOCK(bev->lock,
literal|0
argument|); 		} else { 			again =
literal|1
argument|; 		} 	}
argument_list|)
empty_stmt|;
name|g
operator|->
name|pending_unsuspend_read
operator|=
name|again
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bev_group_unsuspend_writing_
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
name|int
name|again
init|=
literal|0
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bev
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|g
operator|->
name|write_suspended
operator|=
literal|0
expr_stmt|;
name|FOREACH_RANDOM_ORDER
argument_list|(
argument|{ 		if (EVLOCK_TRY_LOCK_(bev->lock)) { 			bufferevent_unsuspend_write_(&bev->bev, 			    BEV_SUSPEND_BW_GROUP); 			EVLOCK_UNLOCK(bev->lock,
literal|0
argument|); 		} else { 			again =
literal|1
argument|; 		} 	}
argument_list|)
empty_stmt|;
name|g
operator|->
name|pending_unsuspend_write
operator|=
name|again
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Callback invoked every tick to add more elements to the group bucket     and unsuspend group members as needed.  */
end_comment

begin_function
specifier|static
name|void
name|bev_group_refill_callback_
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
init|=
name|arg
decl_stmt|;
name|unsigned
name|tick
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|event_base_gettimeofday_cached
argument_list|(
name|event_get_base
argument_list|(
operator|&
name|g
operator|->
name|master_refill_event
argument_list|)
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|tick
operator|=
name|ev_token_bucket_get_tick_
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|g
operator|->
name|rate_limit_cfg
argument_list|)
expr_stmt|;
name|ev_token_bucket_update_
argument_list|(
operator|&
name|g
operator|->
name|rate_limit
argument_list|,
operator|&
name|g
operator|->
name|rate_limit_cfg
argument_list|,
name|tick
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|pending_unsuspend_read
operator|||
operator|(
name|g
operator|->
name|read_suspended
operator|&&
operator|(
name|g
operator|->
name|rate_limit
operator|.
name|read_limit
operator|>=
name|g
operator|->
name|min_share
operator|)
operator|)
condition|)
block|{
name|bev_group_unsuspend_reading_
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|pending_unsuspend_write
operator|||
operator|(
name|g
operator|->
name|write_suspended
operator|&&
operator|(
name|g
operator|->
name|rate_limit
operator|.
name|write_limit
operator|>=
name|g
operator|->
name|min_share
operator|)
operator|)
condition|)
block|{
name|bev_group_unsuspend_writing_
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
comment|/* XXXX Rather than waiting to the next tick to unsuspend stuff 	 * with pending_unsuspend_write/read, we should do it on the 	 * next iteration of the mainloop. 	 */
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_set_rate_limit
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bevp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|bufferevent_rate_limit
modifier|*
name|rlim
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|ev_uint32_t
name|tick
decl_stmt|;
name|int
name|reinit
init|=
literal|0
decl_stmt|,
name|suspended
init|=
literal|0
decl_stmt|;
comment|/* XXX reference-count cfg */
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
condition|)
block|{
name|rlim
operator|=
name|bevp
operator|->
name|rate_limiting
expr_stmt|;
name|rlim
operator|->
name|cfg
operator|=
name|NULL
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_initialized
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|)
condition|)
name|event_del
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|event_base_gettimeofday_cached
argument_list|(
name|bev
operator|->
name|ev_base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|tick
operator|=
name|ev_token_bucket_get_tick_
argument_list|(
operator|&
name|now
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
operator|==
name|cfg
condition|)
block|{
comment|/* no-op */
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|==
name|NULL
condition|)
block|{
name|rlim
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_rate_limit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rlim
condition|)
goto|goto
name|done
goto|;
name|bevp
operator|->
name|rate_limiting
operator|=
name|rlim
expr_stmt|;
block|}
else|else
block|{
name|rlim
operator|=
name|bevp
operator|->
name|rate_limiting
expr_stmt|;
block|}
name|reinit
operator|=
name|rlim
operator|->
name|cfg
operator|!=
name|NULL
expr_stmt|;
name|rlim
operator|->
name|cfg
operator|=
name|cfg
expr_stmt|;
name|ev_token_bucket_init_
argument_list|(
operator|&
name|rlim
operator|->
name|limit
argument_list|,
name|cfg
argument_list|,
name|tick
argument_list|,
name|reinit
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|event_initialized
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|)
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
block|}
name|event_assign
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_FINALIZE
argument_list|,
name|bev_refill_callback_
argument_list|,
name|bevp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlim
operator|->
name|limit
operator|.
name|read_limit
operator|>
literal|0
condition|)
block|{
name|bufferevent_unsuspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_suspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
name|suspended
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rlim
operator|->
name|limit
operator|.
name|write_limit
operator|>
literal|0
condition|)
block|{
name|bufferevent_unsuspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufferevent_suspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
name|suspended
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|suspended
condition|)
name|event_add
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|cfg
operator|->
name|tick_timeout
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|bufferevent_rate_limit_group_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|ev_uint32_t
name|tick
decl_stmt|;
name|event_base_gettimeofday_cached
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|tick
operator|=
name|ev_token_bucket_get_tick_
argument_list|(
operator|&
name|now
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|g
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_rate_limit_group
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|g
operator|->
name|rate_limit_cfg
argument_list|,
name|cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|g
operator|->
name|rate_limit_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|g
operator|->
name|members
argument_list|)
expr_stmt|;
name|ev_token_bucket_init_
argument_list|(
operator|&
name|g
operator|->
name|rate_limit
argument_list|,
name|cfg
argument_list|,
name|tick
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|g
operator|->
name|master_refill_event
argument_list|,
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_PERSIST
operator||
name|EV_FINALIZE
argument_list|,
name|bev_group_refill_callback_
argument_list|,
name|g
argument_list|)
expr_stmt|;
comment|/*XXXX handle event_add failure */
name|event_add
argument_list|(
operator|&
name|g
operator|->
name|master_refill_event
argument_list|,
operator|&
name|cfg
operator|->
name|tick_timeout
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|g
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|bufferevent_rate_limit_group_set_min_share
argument_list|(
name|g
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|evutil_weakrand_seed_
argument_list|(
operator|&
name|g
operator|->
name|weakrand_seed
argument_list|,
call|(
name|ev_uint32_t
call|)
argument_list|(
operator|(
name|now
operator|.
name|tv_sec
operator|+
name|now
operator|.
name|tv_usec
operator|)
operator|+
operator|(
name|ev_intptr_t
operator|)
name|g
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_rate_limit_group_set_cfg
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|,
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|same_tick
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|||
operator|!
name|cfg
condition|)
return|return
operator|-
literal|1
return|;
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|same_tick
operator|=
name|evutil_timercmp
argument_list|(
operator|&
name|g
operator|->
name|rate_limit_cfg
operator|.
name|tick_timeout
argument_list|,
operator|&
name|cfg
operator|->
name|tick_timeout
argument_list|,
operator|==
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|g
operator|->
name|rate_limit_cfg
argument_list|,
name|cfg
argument_list|,
sizeof|sizeof
argument_list|(
name|g
operator|->
name|rate_limit_cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|rate_limit
operator|.
name|read_limit
operator|>
operator|(
name|ev_ssize_t
operator|)
name|cfg
operator|->
name|read_maximum
condition|)
name|g
operator|->
name|rate_limit
operator|.
name|read_limit
operator|=
name|cfg
operator|->
name|read_maximum
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|rate_limit
operator|.
name|write_limit
operator|>
operator|(
name|ev_ssize_t
operator|)
name|cfg
operator|->
name|write_maximum
condition|)
name|g
operator|->
name|rate_limit
operator|.
name|write_limit
operator|=
name|cfg
operator|->
name|write_maximum
expr_stmt|;
if|if
condition|(
operator|!
name|same_tick
condition|)
block|{
comment|/* This can cause a hiccup in the schedule */
name|event_add
argument_list|(
operator|&
name|g
operator|->
name|master_refill_event
argument_list|,
operator|&
name|cfg
operator|->
name|tick_timeout
argument_list|)
expr_stmt|;
block|}
comment|/* The new limits might force us to adjust min_share differently. */
name|bufferevent_rate_limit_group_set_min_share
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|configured_min_share
argument_list|)
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_rate_limit_group_set_min_share
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|,
name|size_t
name|share
parameter_list|)
block|{
if|if
condition|(
name|share
operator|>
name|EV_SSIZE_MAX
condition|)
return|return
operator|-
literal|1
return|;
name|g
operator|->
name|configured_min_share
operator|=
name|share
expr_stmt|;
comment|/* Can't set share to less than the one-tick maximum.  IOW, at steady 	 * state, at least one connection can go per tick. */
if|if
condition|(
name|share
operator|>
name|g
operator|->
name|rate_limit_cfg
operator|.
name|read_rate
condition|)
name|share
operator|=
name|g
operator|->
name|rate_limit_cfg
operator|.
name|read_rate
expr_stmt|;
if|if
condition|(
name|share
operator|>
name|g
operator|->
name|rate_limit_cfg
operator|.
name|write_rate
condition|)
name|share
operator|=
name|g
operator|->
name|rate_limit_cfg
operator|.
name|write_rate
expr_stmt|;
name|g
operator|->
name|min_share
operator|=
name|share
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_rate_limit_group_free
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
literal|0
operator|==
name|g
operator|->
name|n_members
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
operator|&
name|g
operator|->
name|master_refill_event
argument_list|)
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|g
operator|->
name|lock
argument_list|,
name|EVTHREAD_LOCKTYPE_RECURSIVE
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_add_to_rate_limit_group
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
parameter_list|)
block|{
name|int
name|wsuspend
decl_stmt|,
name|rsuspend
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bevp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bevp
operator|->
name|rate_limiting
condition|)
block|{
name|struct
name|bufferevent_rate_limit
modifier|*
name|rlim
decl_stmt|;
name|rlim
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bufferevent_rate_limit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rlim
condition|)
block|{
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|event_assign
argument_list|(
operator|&
name|rlim
operator|->
name|refill_bucket_event
argument_list|,
name|bev
operator|->
name|ev_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_FINALIZE
argument_list|,
name|bev_refill_callback_
argument_list|,
name|bevp
argument_list|)
expr_stmt|;
name|bevp
operator|->
name|rate_limiting
operator|=
name|rlim
expr_stmt|;
block|}
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
operator|==
name|g
condition|)
block|{
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
condition|)
name|bufferevent_remove_from_rate_limit_group
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
operator|=
name|g
expr_stmt|;
operator|++
name|g
operator|->
name|n_members
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g
operator|->
name|members
argument_list|,
name|bevp
argument_list|,
name|rate_limiting
operator|->
name|next_in_group
argument_list|)
expr_stmt|;
name|rsuspend
operator|=
name|g
operator|->
name|read_suspended
expr_stmt|;
name|wsuspend
operator|=
name|g
operator|->
name|write_suspended
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsuspend
condition|)
name|bufferevent_suspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsuspend
condition|)
name|bufferevent_suspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_remove_from_rate_limit_group
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
return|return
name|bufferevent_remove_from_rate_limit_group_internal_
argument_list|(
name|bev
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_remove_from_rate_limit_group_internal_
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|int
name|unsuspend
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bevp
init|=
name|EVUTIL_UPCAST
argument_list|(
name|bev
argument_list|,
expr|struct
name|bufferevent_private
argument_list|,
name|bev
argument_list|)
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
condition|)
block|{
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|g
init|=
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|bevp
operator|->
name|rate_limiting
operator|->
name|group
operator|=
name|NULL
expr_stmt|;
operator|--
name|g
operator|->
name|n_members
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bevp
argument_list|,
name|rate_limiting
operator|->
name|next_in_group
argument_list|)
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsuspend
condition|)
block|{
name|bufferevent_unsuspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW_GROUP
argument_list|)
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ===  * API functions to expose rate limits.  *  * Don't use these from inside Libevent; they're meant to be for use by  * the program.  * === */
end_comment

begin_comment
comment|/* Mostly you don't want to use this function from inside libevent;  * bufferevent_get_read_max_() is more likely what you want*/
end_comment

begin_function
name|ev_ssize_t
name|bufferevent_get_read_limit
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|bufferevent_update_buckets
argument_list|(
name|bevp
argument_list|)
expr_stmt|;
name|r
operator|=
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|EV_SSIZE_MAX
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Mostly you don't want to use this function from inside libevent;  * bufferevent_get_write_max_() is more likely what you want*/
end_comment

begin_function
name|ev_ssize_t
name|bufferevent_get_write_limit
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
condition|)
block|{
name|bufferevent_update_buckets
argument_list|(
name|bevp
argument_list|)
expr_stmt|;
name|r
operator|=
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|EV_SSIZE_MAX
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_set_max_single_read
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
name|EV_SSIZE_MAX
condition|)
name|bevp
operator|->
name|max_single_read
operator|=
name|MAX_SINGLE_READ_DEFAULT
expr_stmt|;
else|else
name|bevp
operator|->
name|max_single_read
operator|=
name|size
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_set_max_single_write
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|>
name|EV_SSIZE_MAX
condition|)
name|bevp
operator|->
name|max_single_write
operator|=
name|MAX_SINGLE_WRITE_DEFAULT
expr_stmt|;
else|else
name|bevp
operator|->
name|max_single_write
operator|=
name|size
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_max_single_read
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|r
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
operator|->
name|max_single_read
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_max_single_write
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|r
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
operator|->
name|max_single_write
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_max_to_read
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|r
operator|=
name|bufferevent_get_read_max_
argument_list|(
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|ev_ssize_t
name|bufferevent_get_max_to_write
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|r
operator|=
name|bufferevent_get_write_max_
argument_list|(
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
argument_list|)
expr_stmt|;
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ev_token_bucket_cfg
modifier|*
name|bufferevent_get_token_bucket_cfg
parameter_list|(
specifier|const
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|)
block|{
name|struct
name|bufferevent_private
modifier|*
name|bufev_private
init|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
decl_stmt|;
name|struct
name|ev_token_bucket_cfg
modifier|*
name|cfg
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufev_private
operator|->
name|rate_limiting
condition|)
block|{
name|cfg
operator|=
name|bufev_private
operator|->
name|rate_limiting
operator|->
name|cfg
expr_stmt|;
block|}
else|else
block|{
name|cfg
operator|=
name|NULL
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|cfg
return|;
block|}
end_function

begin_comment
comment|/* Mostly you don't want to use this function from inside libevent;  * bufferevent_get_read_max_() is more likely what you want*/
end_comment

begin_function
name|ev_ssize_t
name|bufferevent_rate_limit_group_get_read_limit
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|r
operator|=
name|grp
operator|->
name|rate_limit
operator|.
name|read_limit
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Mostly you don't want to use this function from inside libevent;  * bufferevent_get_write_max_() is more likely what you want. */
end_comment

begin_function
name|ev_ssize_t
name|bufferevent_rate_limit_group_get_write_limit
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|)
block|{
name|ev_ssize_t
name|r
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|r
operator|=
name|grp
operator|->
name|rate_limit
operator|.
name|write_limit
expr_stmt|;
name|UNLOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_decrement_read_limit
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|ev_ssize_t
name|decr
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|ev_ssize_t
name|old_limit
decl_stmt|,
name|new_limit
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|old_limit
operator|=
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
expr_stmt|;
name|new_limit
operator|=
operator|(
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|read_limit
operator|-=
name|decr
operator|)
expr_stmt|;
if|if
condition|(
name|old_limit
operator|>
literal|0
operator|&&
name|new_limit
operator|<=
literal|0
condition|)
block|{
name|bufferevent_suspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
operator|->
name|tick_timeout
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_limit
operator|<=
literal|0
operator|&&
name|new_limit
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bevp
operator|->
name|write_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
name|event_del
argument_list|(
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_read_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_decrement_write_limit
parameter_list|(
name|struct
name|bufferevent
modifier|*
name|bev
parameter_list|,
name|ev_ssize_t
name|decr
parameter_list|)
block|{
comment|/* XXXX this is mostly copy-and-paste from 	 * bufferevent_decrement_read_limit */
name|int
name|r
init|=
literal|0
decl_stmt|;
name|ev_ssize_t
name|old_limit
decl_stmt|,
name|new_limit
decl_stmt|;
name|struct
name|bufferevent_private
modifier|*
name|bevp
decl_stmt|;
name|BEV_LOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|bevp
operator|=
name|BEV_UPCAST
argument_list|(
name|bev
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|bevp
operator|->
name|rate_limiting
operator|&&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|old_limit
operator|=
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
expr_stmt|;
name|new_limit
operator|=
operator|(
name|bevp
operator|->
name|rate_limiting
operator|->
name|limit
operator|.
name|write_limit
operator|-=
name|decr
operator|)
expr_stmt|;
if|if
condition|(
name|old_limit
operator|>
literal|0
operator|&&
name|new_limit
operator|<=
literal|0
condition|)
block|{
name|bufferevent_suspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|,
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|cfg
operator|->
name|tick_timeout
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_limit
operator|<=
literal|0
operator|&&
name|new_limit
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bevp
operator|->
name|read_suspended
operator|&
name|BEV_SUSPEND_BW
operator|)
condition|)
name|event_del
argument_list|(
operator|&
name|bevp
operator|->
name|rate_limiting
operator|->
name|refill_bucket_event
argument_list|)
expr_stmt|;
name|bufferevent_unsuspend_write_
argument_list|(
name|bev
argument_list|,
name|BEV_SUSPEND_BW
argument_list|)
expr_stmt|;
block|}
name|BEV_UNLOCK
argument_list|(
name|bev
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_rate_limit_group_decrement_read
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|,
name|ev_ssize_t
name|decr
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|ev_ssize_t
name|old_limit
decl_stmt|,
name|new_limit
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|old_limit
operator|=
name|grp
operator|->
name|rate_limit
operator|.
name|read_limit
expr_stmt|;
name|new_limit
operator|=
operator|(
name|grp
operator|->
name|rate_limit
operator|.
name|read_limit
operator|-=
name|decr
operator|)
expr_stmt|;
if|if
condition|(
name|old_limit
operator|>
literal|0
operator|&&
name|new_limit
operator|<=
literal|0
condition|)
block|{
name|bev_group_suspend_reading_
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_limit
operator|<=
literal|0
operator|&&
name|new_limit
operator|>
literal|0
condition|)
block|{
name|bev_group_unsuspend_reading_
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|bufferevent_rate_limit_group_decrement_write
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|,
name|ev_ssize_t
name|decr
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|ev_ssize_t
name|old_limit
decl_stmt|,
name|new_limit
decl_stmt|;
name|LOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|old_limit
operator|=
name|grp
operator|->
name|rate_limit
operator|.
name|write_limit
expr_stmt|;
name|new_limit
operator|=
operator|(
name|grp
operator|->
name|rate_limit
operator|.
name|write_limit
operator|-=
name|decr
operator|)
expr_stmt|;
if|if
condition|(
name|old_limit
operator|>
literal|0
operator|&&
name|new_limit
operator|<=
literal|0
condition|)
block|{
name|bev_group_suspend_writing_
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_limit
operator|<=
literal|0
operator|&&
name|new_limit
operator|>
literal|0
condition|)
block|{
name|bev_group_unsuspend_writing_
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_GROUP
argument_list|(
name|grp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|bufferevent_rate_limit_group_get_totals
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|,
name|ev_uint64_t
modifier|*
name|total_read_out
parameter_list|,
name|ev_uint64_t
modifier|*
name|total_written_out
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|grp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_read_out
condition|)
operator|*
name|total_read_out
operator|=
name|grp
operator|->
name|total_read
expr_stmt|;
if|if
condition|(
name|total_written_out
condition|)
operator|*
name|total_written_out
operator|=
name|grp
operator|->
name|total_written
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufferevent_rate_limit_group_reset_totals
parameter_list|(
name|struct
name|bufferevent_rate_limit_group
modifier|*
name|grp
parameter_list|)
block|{
name|grp
operator|->
name|total_read
operator|=
name|grp
operator|->
name|total_written
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bufferevent_ratelim_init_
parameter_list|(
name|struct
name|bufferevent_private
modifier|*
name|bev
parameter_list|)
block|{
name|bev
operator|->
name|rate_limiting
operator|=
name|NULL
expr_stmt|;
name|bev
operator|->
name|max_single_read
operator|=
name|MAX_SINGLE_READ_DEFAULT
expr_stmt|;
name|bev
operator|->
name|max_single_write
operator|=
name|MAX_SINGLE_WRITE_DEFAULT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

