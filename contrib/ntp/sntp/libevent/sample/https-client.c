begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This is an example of how to hook up evhttp with bufferevent_ssl    It just GETs an https URL given on the command-line and prints the response   body to stdout.    Actually, it also accepts plain http URLs to make it easy to compare http vs   https code paths.    Loosely based on le-proxy.c.  */
end_comment

begin_comment
comment|// Get rid of OSX 10.7 and greater deprecation warnings.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|clang
name|diagnostic
name|ignored
literal|"-Wdeprecated-declarations"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_define
define|#
directive|define
name|snprintf
value|_snprintf
end_define

begin_define
define|#
directive|define
name|strcasecmp
value|_stricmp
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<event2/bufferevent_ssl.h>
end_include

begin_include
include|#
directive|include
file|<event2/bufferevent.h>
end_include

begin_include
include|#
directive|include
file|<event2/buffer.h>
end_include

begin_include
include|#
directive|include
file|<event2/listener.h>
end_include

begin_include
include|#
directive|include
file|<event2/util.h>
end_include

begin_include
include|#
directive|include
file|<event2/http.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|"openssl_hostname_validation.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore_cert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|http_request_done
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
comment|/* If req is NULL, it means an error occurred, but 		 * sadly we are mostly left guessing what the error 		 * might have been.  We'll do our best... */
name|struct
name|bufferevent
modifier|*
name|bev
init|=
operator|(
expr|struct
name|bufferevent
operator|*
operator|)
name|ctx
decl_stmt|;
name|unsigned
name|long
name|oslerr
decl_stmt|;
name|int
name|printed_err
init|=
literal|0
decl_stmt|;
name|int
name|errcode
init|=
name|EVUTIL_SOCKET_ERROR
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"some request failed - no idea which one though!\n"
argument_list|)
expr_stmt|;
comment|/* Print out the OpenSSL error queue that libevent 		 * squirreled away for us, if any. */
while|while
condition|(
operator|(
name|oslerr
operator|=
name|bufferevent_get_openssl_error
argument_list|(
name|bev
argument_list|)
operator|)
condition|)
block|{
name|ERR_error_string_n
argument_list|(
name|oslerr
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|printed_err
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the OpenSSL error queue was empty, maybe it was a 		 * socket error; let's try printing that. */
if|if
condition|(
operator|!
name|printed_err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"socket error = %s (%d)\n"
argument_list|,
name|evutil_socket_error_to_string
argument_list|(
name|errcode
argument_list|)
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Response line: %d %s\n"
argument_list|,
name|evhttp_request_get_response_code
argument_list|(
name|req
argument_list|)
argument_list|,
name|evhttp_request_get_response_code_line
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|evbuffer_remove
argument_list|(
name|evhttp_request_get_input_buffer
argument_list|(
name|req
argument_list|)
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* These are just arbitrary chunks of 256 bytes. 		 * They are not lines, so we can't treat them as such. */
name|fwrite
argument_list|(
name|buffer
argument_list|,
name|nread
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|syntax
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"Syntax:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   https-client -url<https-url> [-data data-file.bin] [-ignore-cert]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Example:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   https-client -url https://ip.appspot.com/\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fputs
argument_list|(
name|msg
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|die_openssl
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s failed:\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* This is the OpenSSL function that prints the contents of the 	 * error stack to the specified file handle. */
name|ERR_print_errors_fp
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See http://archives.seul.org/libevent/users/Jan-2013/msg00039.html */
end_comment

begin_function
specifier|static
name|int
name|cert_verify_callback
parameter_list|(
name|X509_STORE_CTX
modifier|*
name|x509_ctx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|cert_str
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|host
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|res_str
init|=
literal|"X509_verify_cert failed"
decl_stmt|;
name|HostnameValidationResult
name|res
init|=
name|Error
decl_stmt|;
comment|/* This is the function that OpenSSL would call if we hadn't called 	 * SSL_CTX_set_cert_verify_callback().  Therefore, we are "wrapping" 	 * the default functionality, rather than replacing it. */
name|int
name|ok_so_far
init|=
literal|0
decl_stmt|;
name|X509
modifier|*
name|server_cert
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ignore_cert
condition|)
block|{
return|return
literal|1
return|;
block|}
name|ok_so_far
operator|=
name|X509_verify_cert
argument_list|(
name|x509_ctx
argument_list|)
expr_stmt|;
name|server_cert
operator|=
name|X509_STORE_CTX_get_current_cert
argument_list|(
name|x509_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok_so_far
condition|)
block|{
name|res
operator|=
name|validate_hostname
argument_list|(
name|host
argument_list|,
name|server_cert
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
name|MatchFound
case|:
name|res_str
operator|=
literal|"MatchFound"
expr_stmt|;
break|break;
case|case
name|MatchNotFound
case|:
name|res_str
operator|=
literal|"MatchNotFound"
expr_stmt|;
break|break;
case|case
name|NoSANPresent
case|:
name|res_str
operator|=
literal|"NoSANPresent"
expr_stmt|;
break|break;
case|case
name|MalformedCertificate
case|:
name|res_str
operator|=
literal|"MalformedCertificate"
expr_stmt|;
break|break;
case|case
name|Error
case|:
name|res_str
operator|=
literal|"Error"
expr_stmt|;
break|break;
default|default:
name|res_str
operator|=
literal|"WTF!"
expr_stmt|;
break|break;
block|}
block|}
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|server_cert
argument_list|)
argument_list|,
name|cert_str
argument_list|,
sizeof|sizeof
argument_list|(
name|cert_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|MatchFound
condition|)
block|{
name|printf
argument_list|(
literal|"https server '%s' has this certificate, "
literal|"which looks good to me:\n%s\n"
argument_list|,
name|host
argument_list|,
name|cert_str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Got '%s' for hostname '%s' and certificate:\n%s\n"
argument_list|,
name|res_str
argument_list|,
name|host
argument_list|,
name|cert_str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|evhttp_uri
modifier|*
name|http_uri
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
init|=
name|NULL
decl_stmt|,
modifier|*
name|data_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|query
decl_stmt|;
name|char
name|uri
index|[
literal|256
index|]
decl_stmt|;
name|int
name|port
decl_stmt|;
name|SSL_CTX
modifier|*
name|ssl_ctx
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|struct
name|bufferevent
modifier|*
name|bev
decl_stmt|;
name|struct
name|evhttp_connection
modifier|*
name|evcon
decl_stmt|;
name|struct
name|evhttp_request
modifier|*
name|req
decl_stmt|;
name|struct
name|evkeyvalq
modifier|*
name|output_headers
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|output_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-url"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|url
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-ignore-cert"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ignore_cert
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-data"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|data_file
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"-help"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|url
condition|)
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_WIN32
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|int
name|err
decl_stmt|;
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"WSAStartup failed with error: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|// _WIN32
name|http_uri
operator|=
name|evhttp_uri_parse
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|http_uri
operator|==
name|NULL
condition|)
block|{
name|die
argument_list|(
literal|"malformed url"
argument_list|)
expr_stmt|;
block|}
name|scheme
operator|=
name|evhttp_uri_get_scheme
argument_list|(
name|http_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheme
operator|==
name|NULL
operator|||
operator|(
name|strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"https"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"http"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|die
argument_list|(
literal|"url must be http or https"
argument_list|)
expr_stmt|;
block|}
name|host
operator|=
name|evhttp_uri_get_host
argument_list|(
name|http_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|die
argument_list|(
literal|"url must have a host"
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|evhttp_uri_get_port
argument_list|(
name|http_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|port
operator|=
operator|(
name|strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"http"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|80
else|:
literal|443
expr_stmt|;
block|}
name|path
operator|=
name|evhttp_uri_get_path
argument_list|(
name|http_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
literal|"/"
expr_stmt|;
block|}
name|query
operator|=
name|evhttp_uri_get_query
argument_list|(
name|http_uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|uri
argument_list|,
sizeof|sizeof
argument_list|(
name|uri
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|uri
argument_list|,
sizeof|sizeof
argument_list|(
name|uri
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s?%s"
argument_list|,
name|path
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
name|uri
index|[
sizeof|sizeof
argument_list|(
name|uri
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// Initialize OpenSSL
name|SSL_library_init
argument_list|()
expr_stmt|;
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
name|OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
comment|/* This isn't strictly necessary... OpenSSL performs RAND_poll 	 * automatically on first use of random number generator. */
name|r
operator|=
name|RAND_poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|die_openssl
argument_list|(
literal|"RAND_poll"
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new OpenSSL context */
name|ssl_ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_method
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssl_ctx
condition|)
name|die_openssl
argument_list|(
literal|"SSL_CTX_new"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
comment|/* TODO: Add certificate loading on Windows as well */
comment|/* Attempt to use the system's trusted root certificates. 	 * (This path is only valid for Debian-based systems.) */
if|if
condition|(
literal|1
operator|!=
name|SSL_CTX_load_verify_locations
argument_list|(
name|ssl_ctx
argument_list|,
literal|"/etc/ssl/certs/ca-certificates.crt"
argument_list|,
name|NULL
argument_list|)
condition|)
name|die_openssl
argument_list|(
literal|"SSL_CTX_load_verify_locations"
argument_list|)
expr_stmt|;
comment|/* Ask OpenSSL to verify the server certificate.  Note that this 	 * does NOT include verifying that the hostname is correct. 	 * So, by itself, this means anyone with any legitimate 	 * CA-issued certificate for any website, can impersonate any 	 * other website in the world.  This is not good.  See "The 	 * Most Dangerous Code in the World" article at 	 * https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html 	 */
name|SSL_CTX_set_verify
argument_list|(
name|ssl_ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* This is how we solve the problem mentioned in the previous 	 * comment.  We "wrap" OpenSSL's validation routine in our 	 * own routine, which also validates the hostname by calling 	 * the code provided by iSECPartners.  Note that even though 	 * the "Everything You've Always Wanted to Know About 	 * Certificate Validation With OpenSSL (But Were Afraid to 	 * Ask)" paper from iSECPartners says very explicitly not to 	 * call SSL_CTX_set_cert_verify_callback (at the bottom of 	 * page 2), what we're doing here is safe because our 	 * cert_verify_callback() calls X509_verify_cert(), which is 	 * OpenSSL's built-in routine which would have been called if 	 * we hadn't set the callback.  Therefore, we're just 	 * "wrapping" OpenSSL's routine, not replacing it. */
name|SSL_CTX_set_cert_verify_callback
argument_list|(
name|ssl_ctx
argument_list|,
name|cert_verify_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// not _WIN32
comment|// Create event base
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
name|perror
argument_list|(
literal|"event_base_new()"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Create OpenSSL bufferevent and stack evhttp on top of it
name|ssl
operator|=
name|SSL_new
argument_list|(
name|ssl_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
operator|==
name|NULL
condition|)
block|{
name|die_openssl
argument_list|(
literal|"SSL_new()"
argument_list|)
expr_stmt|;
block|}
comment|// Set hostname for SNI extension
name|SSL_set_tlsext_host_name
argument_list|(
name|ssl
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|scheme
argument_list|,
literal|"http"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bev
operator|=
name|bufferevent_socket_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bev
operator|=
name|bufferevent_openssl_socket_new
argument_list|(
name|base
argument_list|,
operator|-
literal|1
argument_list|,
name|ssl
argument_list|,
name|BUFFEREVENT_SSL_CONNECTING
argument_list|,
name|BEV_OPT_CLOSE_ON_FREE
operator||
name|BEV_OPT_DEFER_CALLBACKS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bev
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bufferevent_openssl_socket_new() failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bufferevent_openssl_set_allow_dirty_shutdown
argument_list|(
name|bev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// For simplicity, we let DNS resolution block. Everything else should be
comment|// asynchronous though.
name|evcon
operator|=
name|evhttp_connection_base_bufferevent_new
argument_list|(
name|base
argument_list|,
name|NULL
argument_list|,
name|bev
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcon
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"evhttp_connection_base_bufferevent_new() failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Fire off the request
name|req
operator|=
name|evhttp_request_new
argument_list|(
name|http_request_done
argument_list|,
name|bev
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"evhttp_request_new() failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|output_headers
operator|=
name|evhttp_request_get_output_headers
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|output_headers
argument_list|,
literal|"Host"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|output_headers
argument_list|,
literal|"Connection"
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_file
condition|)
block|{
comment|/* NOTE: In production code, you'd probably want to use 		 * evbuffer_add_file() or evbuffer_add_file_segment(), to 		 * avoid needless copying. */
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|data_file
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|size_t
name|bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
name|output_buffer
operator|=
name|evhttp_request_get_output_buffer
argument_list|(
name|req
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|evbuffer_add
argument_list|(
name|output_buffer
argument_list|,
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|s
expr_stmt|;
block|}
name|evutil_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%lu"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|evhttp_add_header
argument_list|(
name|output_headers
argument_list|,
literal|"Content-Length"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|evhttp_make_request
argument_list|(
name|evcon
argument_list|,
name|req
argument_list|,
name|data_file
condition|?
name|EVHTTP_REQ_POST
else|:
name|EVHTTP_REQ_GET
argument_list|,
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"evhttp_make_request() failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|evhttp_connection_free
argument_list|(
name|evcon
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

