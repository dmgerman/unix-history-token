begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   A trivial static http webserver using Libevent's evhttp.    This is not the best code in the world, and it does some fairly stupid stuff   that you would never want to do in a production webserver. Caveat hackor!   */
end_comment

begin_comment
comment|/* Compatibility for possible missing IPv6 declarations */
end_comment

begin_include
include|#
directive|include
file|"../util-internal.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<ws2tcpip.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|x
parameter_list|)
value|(((x)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<event2/event.h>
end_include

begin_include
include|#
directive|include
file|<event2/http.h>
end_include

begin_include
include|#
directive|include
file|<event2/buffer.h>
end_include

begin_include
include|#
directive|include
file|<event2/util.h>
end_include

begin_include
include|#
directive|include
file|<event2/keyvalq_struct.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_NETINET_IN_H
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_XOPEN_SOURCE_EXTENDED
end_ifdef

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|stat
end_ifndef

begin_define
define|#
directive|define
name|stat
value|_stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|fstat
end_ifndef

begin_define
define|#
directive|define
name|fstat
value|_fstat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|open
end_ifndef

begin_define
define|#
directive|define
name|open
value|_open
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|close
end_ifndef

begin_define
define|#
directive|define
name|close
value|_close
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|_O_RDONLY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|uri_root
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|table_entry
block|{
specifier|const
name|char
modifier|*
name|extension
decl_stmt|;
specifier|const
name|char
modifier|*
name|content_type
decl_stmt|;
block|}
name|content_type_table
index|[]
init|=
block|{
block|{
literal|"txt"
block|,
literal|"text/plain"
block|}
block|,
block|{
literal|"c"
block|,
literal|"text/plain"
block|}
block|,
block|{
literal|"h"
block|,
literal|"text/plain"
block|}
block|,
block|{
literal|"html"
block|,
literal|"text/html"
block|}
block|,
block|{
literal|"htm"
block|,
literal|"text/htm"
block|}
block|,
block|{
literal|"css"
block|,
literal|"text/css"
block|}
block|,
block|{
literal|"gif"
block|,
literal|"image/gif"
block|}
block|,
block|{
literal|"jpg"
block|,
literal|"image/jpeg"
block|}
block|,
block|{
literal|"jpeg"
block|,
literal|"image/jpeg"
block|}
block|,
block|{
literal|"png"
block|,
literal|"image/png"
block|}
block|,
block|{
literal|"pdf"
block|,
literal|"application/pdf"
block|}
block|,
block|{
literal|"ps"
block|,
literal|"application/postsript"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* Try to guess a good content-type for 'path' */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|guess_content_type
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|last_period
decl_stmt|,
modifier|*
name|extension
decl_stmt|;
specifier|const
name|struct
name|table_entry
modifier|*
name|ent
decl_stmt|;
name|last_period
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_period
operator|||
name|strchr
argument_list|(
name|last_period
argument_list|,
literal|'/'
argument_list|)
condition|)
goto|goto
name|not_found
goto|;
comment|/* no exension */
name|extension
operator|=
name|last_period
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ent
operator|=
operator|&
name|content_type_table
index|[
literal|0
index|]
init|;
name|ent
operator|->
name|extension
condition|;
operator|++
name|ent
control|)
block|{
if|if
condition|(
operator|!
name|evutil_ascii_strcasecmp
argument_list|(
name|ent
operator|->
name|extension
argument_list|,
name|extension
argument_list|)
condition|)
return|return
name|ent
operator|->
name|content_type
return|;
block|}
name|not_found
label|:
return|return
literal|"application/misc"
return|;
block|}
end_function

begin_comment
comment|/* Callback used for the /dump URI, and for every non-GET request:  * dumps all information to stdout and gives back a trivial 200 ok */
end_comment

begin_function
specifier|static
name|void
name|dump_request_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cmdtype
decl_stmt|;
name|struct
name|evkeyvalq
modifier|*
name|headers
decl_stmt|;
name|struct
name|evkeyval
modifier|*
name|header
decl_stmt|;
name|struct
name|evbuffer
modifier|*
name|buf
decl_stmt|;
switch|switch
condition|(
name|evhttp_request_get_command
argument_list|(
name|req
argument_list|)
condition|)
block|{
case|case
name|EVHTTP_REQ_GET
case|:
name|cmdtype
operator|=
literal|"GET"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_POST
case|:
name|cmdtype
operator|=
literal|"POST"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_HEAD
case|:
name|cmdtype
operator|=
literal|"HEAD"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_PUT
case|:
name|cmdtype
operator|=
literal|"PUT"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_DELETE
case|:
name|cmdtype
operator|=
literal|"DELETE"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_OPTIONS
case|:
name|cmdtype
operator|=
literal|"OPTIONS"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_TRACE
case|:
name|cmdtype
operator|=
literal|"TRACE"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_CONNECT
case|:
name|cmdtype
operator|=
literal|"CONNECT"
expr_stmt|;
break|break;
case|case
name|EVHTTP_REQ_PATCH
case|:
name|cmdtype
operator|=
literal|"PATCH"
expr_stmt|;
break|break;
default|default:
name|cmdtype
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Received a %s request for %s\nHeaders:\n"
argument_list|,
name|cmdtype
argument_list|,
name|evhttp_request_get_uri
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|headers
operator|=
name|evhttp_request_get_input_headers
argument_list|(
name|req
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|headers
operator|->
name|tqh_first
init|;
name|header
condition|;
name|header
operator|=
name|header
operator|->
name|next
operator|.
name|tqe_next
control|)
block|{
name|printf
argument_list|(
literal|"  %s: %s\n"
argument_list|,
name|header
operator|->
name|key
argument_list|,
name|header
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|evhttp_request_get_input_buffer
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Input data:<<<"
argument_list|)
expr_stmt|;
while|while
condition|(
name|evbuffer_get_length
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|char
name|cbuf
index|[
literal|128
index|]
decl_stmt|;
name|n
operator|=
name|evbuffer_remove
argument_list|(
name|buf
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|">>>"
argument_list|)
expr_stmt|;
name|evhttp_send_reply
argument_list|(
name|req
argument_list|,
literal|200
argument_list|,
literal|"OK"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This callback gets invoked when we get any http request that doesn't match  * any other callback.  Like any evhttp server callback, it has a simple job:  * it must eventually call evhttp_send_error() or evhttp_send_reply().  */
end_comment

begin_function
specifier|static
name|void
name|send_document_cb
parameter_list|(
name|struct
name|evhttp_request
modifier|*
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|evbuffer
modifier|*
name|evb
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|docroot
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|uri
init|=
name|evhttp_request_get_uri
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|evhttp_uri
modifier|*
name|decoded
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|decoded_path
decl_stmt|;
name|char
modifier|*
name|whole_path
init|=
name|NULL
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|evhttp_request_get_command
argument_list|(
name|req
argument_list|)
operator|!=
name|EVHTTP_REQ_GET
condition|)
block|{
name|dump_request_cb
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Got a GET request for<%s>\n"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
comment|/* Decode the URI */
name|decoded
operator|=
name|evhttp_uri_parse
argument_list|(
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decoded
condition|)
block|{
name|printf
argument_list|(
literal|"It's not a good URI. Sending BADREQUEST\n"
argument_list|)
expr_stmt|;
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
name|HTTP_BADREQUEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Let's see what path the user asked for. */
name|path
operator|=
name|evhttp_uri_get_path
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"/"
expr_stmt|;
comment|/* We need to decode it, to see what path the user really wanted. */
name|decoded_path
operator|=
name|evhttp_uridecode
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|decoded_path
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* Don't allow any ".."s in the path, to avoid exposing stuff outside 	 * of the docroot.  This test is both overzealous and underzealous: 	 * it forbids aceptable paths like "/this/one..here", but it doesn't 	 * do anything to prevent symlink following." */
if|if
condition|(
name|strstr
argument_list|(
name|decoded_path
argument_list|,
literal|".."
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|len
operator|=
name|strlen
argument_list|(
name|decoded_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|docroot
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|whole_path
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|evutil_snprintf
argument_list|(
name|whole_path
argument_list|,
name|len
argument_list|,
literal|"%s/%s"
argument_list|,
name|docroot
argument_list|,
name|decoded_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|whole_path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|err
goto|;
block|}
comment|/* This holds the content we're sending. */
name|evb
operator|=
name|evbuffer_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* If it's a directory, read the comments and make a little 		 * index page */
ifdef|#
directive|ifdef
name|_WIN32
name|HANDLE
name|d
decl_stmt|;
name|WIN32_FIND_DATAA
name|ent
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|size_t
name|dirlen
decl_stmt|;
else|#
directive|else
name|DIR
modifier|*
name|d
decl_stmt|;
name|struct
name|dirent
modifier|*
name|ent
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|trailing_slash
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|path
argument_list|)
operator|||
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|trailing_slash
operator|=
literal|"/"
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|dirlen
operator|=
name|strlen
argument_list|(
name|whole_path
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|malloc
argument_list|(
name|dirlen
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pattern
argument_list|,
name|whole_path
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|pattern
index|[
name|dirlen
index|]
operator|=
literal|'\\'
expr_stmt|;
name|pattern
index|[
name|dirlen
operator|+
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|pattern
index|[
name|dirlen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|FindFirstFileA
argument_list|(
name|pattern
argument_list|,
operator|&
name|ent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|INVALID_HANDLE_VALUE
condition|)
goto|goto
name|err
goto|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|whole_path
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
endif|#
directive|endif
name|evbuffer_add_printf
argument_list|(
name|evb
argument_list|,
literal|"<html>\n<head>\n"
literal|"<title>%s</title>\n"
literal|"<base href='%s%s'>\n"
literal|"</head>\n"
literal|"<body>\n"
literal|"<h1>%s</h1>\n"
literal|"<ul>\n"
argument_list|,
name|decoded_path
argument_list|,
comment|/* XXX html-escape this. */
name|path
argument_list|,
comment|/* XXX html-escape this? */
name|trailing_slash
argument_list|,
name|decoded_path
comment|/* XXX html-escape this */
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
do|do
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ent
operator|.
name|cFileName
decl_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|ent
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ent
operator|->
name|d_name
decl_stmt|;
endif|#
directive|endif
name|evbuffer_add_printf
argument_list|(
name|evb
argument_list|,
literal|"<li><a href=\"%s\">%s</a>\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* XXX escape this */
ifdef|#
directive|ifdef
name|_WIN32
block|}
while|while
condition|(
name|FindNextFileA
argument_list|(
name|d
argument_list|,
operator|&
name|ent
argument_list|)
condition|)
empty_stmt|;
else|#
directive|else
block|}
endif|#
directive|endif
do|evbuffer_add_printf(evb
operator|,
do|"</ul></body></html>\n"
block|)
empty_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|CloseHandle
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|evhttp_add_header
argument_list|(
name|evhttp_request_get_output_headers
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"Content-Type"
argument_list|,
literal|"text/html"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|else
block|{
comment|/* Otherwise it's a file; add it to the buffer to get 		 * sent via sendfile */
specifier|const
name|char
modifier|*
name|type
init|=
name|guess_content_type
argument_list|(
name|decoded_path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|whole_path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Make sure the length still matches, now that we 			 * opened the file :/ */
name|perror
argument_list|(
literal|"fstat"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|evhttp_add_header
argument_list|(
name|evhttp_request_get_output_headers
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"Content-Type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|evbuffer_add_file
argument_list|(
name|evb
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|evhttp_send_reply
argument_list|(
name|req
argument_list|,
literal|200
argument_list|,
literal|"OK"
argument_list|,
name|evb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|done
goto|;
end_goto

begin_label
name|err
label|:
end_label

begin_expr_stmt
name|evhttp_send_error
argument_list|(
name|req
argument_list|,
literal|404
argument_list|,
literal|"Document was not found"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
end_if

begin_label
name|done
label|:
end_label

begin_if
if|if
condition|(
name|decoded
condition|)
name|evhttp_uri_free
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|decoded_path
condition|)
name|free
argument_list|(
name|decoded_path
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|whole_path
condition|)
name|free
argument_list|(
name|whole_path
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|evb
condition|)
name|evbuffer_free
argument_list|(
name|evb
argument_list|)
expr_stmt|;
end_if

begin_function
unit|}  static
name|void
name|syntax
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Syntax: http-server<docroot>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|struct
name|evhttp
modifier|*
name|http
decl_stmt|;
name|struct
name|evhttp_bound_socket
modifier|*
name|handle
decl_stmt|;
name|unsigned
name|short
name|port
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|WSADATA
name|WSAData
decl_stmt|;
name|WSAStartup
argument_list|(
literal|0x101
argument_list|,
operator|&
name|WSAData
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_ERR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|syntax
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't create an event_base: exiting\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Create a new evhttp object to handle requests. */
name|http
operator|=
name|evhttp_new
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|http
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"couldn't create evhttp. Exiting.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The /dump URI will dump all requests to stdout and say 200 ok. */
name|evhttp_set_cb
argument_list|(
name|http
argument_list|,
literal|"/dump"
argument_list|,
name|dump_request_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We want to accept arbitrary requests, so we need to set a "generic" 	 * cb.  We can also add callbacks for specific paths. */
name|evhttp_set_gencb
argument_list|(
name|http
argument_list|,
name|send_document_cb
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Now we tell the evhttp what port to listen on */
name|handle
operator|=
name|evhttp_bind_socket_with_handle
argument_list|(
name|http
argument_list|,
literal|"0.0.0.0"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|handle
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"couldn't bind to port %d. Exiting.\n"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|{
comment|/* Extract and display the address we're listening on. */
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|evutil_socket_t
name|fd
decl_stmt|;
name|ev_socklen_t
name|socklen
init|=
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
decl_stmt|;
name|char
name|addrbuf
index|[
literal|128
index|]
decl_stmt|;
name|void
modifier|*
name|inaddr
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|got_port
init|=
operator|-
literal|1
decl_stmt|;
name|fd
operator|=
name|evhttp_bound_socket_get_fd
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|socklen
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"getsockname() failed"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
name|got_port
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|got_port
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_addr
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Weird address family %d\n"
argument_list|,
name|ss
operator|.
name|ss_family
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|addr
operator|=
name|evutil_inet_ntop
argument_list|(
name|ss
operator|.
name|ss_family
argument_list|,
name|inaddr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"Listening on %s:%d\n"
argument_list|,
name|addr
argument_list|,
name|got_port
argument_list|)
expr_stmt|;
name|evutil_snprintf
argument_list|(
name|uri_root
argument_list|,
sizeof|sizeof
argument_list|(
name|uri_root
argument_list|)
argument_list|,
literal|"http://%s:%d"
argument_list|,
name|addr
argument_list|,
name|got_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"evutil_inet_ntop failed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

