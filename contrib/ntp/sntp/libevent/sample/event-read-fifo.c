begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This sample code shows how to use Libevent to read from a named pipe.  * XXX This code could make better use of the Libevent interfaces.  *  * XXX This does not work on Windows; ignore everything inside the _WIN32 block.  *  * On UNIX, compile with:  * cc -I/usr/local/include -o event-read-fifo event-read-fifo.c \  *     -L/usr/local/lib -levent  */
end_comment

begin_include
include|#
directive|include
file|<event2/event-config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<event2/event.h>
end_include

begin_function
specifier|static
name|void
name|fifo_read
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|255
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|DWORD
name|dwBytesRead
decl_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fifo_read called with fd: %d, event: %d, arg: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|fd
argument_list|,
name|event
argument_list|,
name|arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|len
operator|=
name|ReadFile
argument_list|(
operator|(
name|HANDLE
operator|)
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|dwBytesRead
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check for end of file. */
if|if
condition|(
name|len
operator|&&
name|dwBytesRead
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End Of File"
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
name|dwBytesRead
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Connection closed\n"
argument_list|)
expr_stmt|;
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_base_loopbreak
argument_list|(
name|event_get_base
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Read: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* On Unix, cleanup event.fifo if SIGINT is received. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_function
specifier|static
name|void
name|signal_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|event_base_loopbreak
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|evfifo
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|HANDLE
name|socket
decl_stmt|;
comment|/* Open a file. */
name|socket
operator|=
name|CreateFileA
argument_list|(
literal|"test.txt"
argument_list|,
comment|/* open File */
name|GENERIC_READ
argument_list|,
comment|/* open for reading */
literal|0
argument_list|,
comment|/* do not share */
name|NULL
argument_list|,
comment|/* no security */
name|OPEN_EXISTING
argument_list|,
comment|/* existing file only */
name|FILE_ATTRIBUTE_NORMAL
argument_list|,
comment|/* normal file */
name|NULL
argument_list|)
expr_stmt|;
comment|/* no attr. template */
if|if
condition|(
name|socket
operator|==
name|INVALID_HANDLE_VALUE
condition|)
return|return
literal|1
return|;
else|#
directive|else
name|struct
name|event
modifier|*
name|signal_int
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|char
modifier|*
name|fifo
init|=
literal|"event.fifo"
decl_stmt|;
name|int
name|socket
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|fifo
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
name|perror
argument_list|(
literal|"lstat"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|unlink
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkfifo
argument_list|(
name|fifo
argument_list|,
literal|0600
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"mkfifo"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|socket
operator|=
name|open
argument_list|(
name|fifo
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Write data to %s\n"
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initalize the event library */
name|base
operator|=
name|event_base_new
argument_list|()
expr_stmt|;
comment|/* Initalize one event */
ifdef|#
directive|ifdef
name|_WIN32
name|evfifo
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
operator|(
name|evutil_socket_t
operator|)
name|socket
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|fifo_read
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* catch SIGINT so that event.fifo can be cleaned up */
name|signal_int
operator|=
name|evsignal_new
argument_list|(
name|base
argument_list|,
name|SIGINT
argument_list|,
name|signal_cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|event_add
argument_list|(
name|signal_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evfifo
operator|=
name|event_new
argument_list|(
name|base
argument_list|,
name|socket
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|fifo_read
argument_list|,
name|event_self_cbarg
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add it to the active events, without a timeout */
name|event_add
argument_list|(
name|evfifo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|event_base_dispatch
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|CloseHandle
argument_list|(
name|socket
argument_list|)
expr_stmt|;
else|#
directive|else
name|close
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|libevent_global_shutdown
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

