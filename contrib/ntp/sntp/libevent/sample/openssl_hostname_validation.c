begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Obtained from: https://github.com/iSECPartners/ssl-conservatory */
end_comment

begin_comment
comment|/* Copyright (C) 2012, iSEC Partners.  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Helper functions to perform basic hostname validation using OpenSSL.  *  * Please read "everything-you-wanted-to-know-about-openssl.pdf" before  * attempting to use this code. This whitepaper describes how the code works,  * how it should be used, and what its limitations are.  *  * Author:  Alban Diquet  * License: See LICENSE  *  */
end_comment

begin_comment
comment|// Get rid of OSX 10.7 and greater deprecation warnings.
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|clang
name|diagnostic
name|ignored
literal|"-Wdeprecated-declarations"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|"openssl_hostname_validation.h"
end_include

begin_include
include|#
directive|include
file|"hostcheck.h"
end_include

begin_define
define|#
directive|define
name|HOSTNAME_MAX_SIZE
value|255
end_define

begin_comment
comment|/** * Tries to find a match for hostname in the certificate's Common Name field. * * Returns MatchFound if a match was found. * Returns MatchNotFound if no matches were found. * Returns MalformedCertificate if the Common Name had a NUL character embedded in it. * Returns Error if the Common Name could not be extracted. */
end_comment

begin_function
specifier|static
name|HostnameValidationResult
name|matches_common_name
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|X509
modifier|*
name|server_cert
parameter_list|)
block|{
name|int
name|common_name_loc
init|=
operator|-
literal|1
decl_stmt|;
name|X509_NAME_ENTRY
modifier|*
name|common_name_entry
init|=
name|NULL
decl_stmt|;
name|ASN1_STRING
modifier|*
name|common_name_asn1
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|common_name_str
init|=
name|NULL
decl_stmt|;
comment|// Find the position of the CN field in the Subject field of the certificate
name|common_name_loc
operator|=
name|X509_NAME_get_index_by_NID
argument_list|(
name|X509_get_subject_name
argument_list|(
operator|(
name|X509
operator|*
operator|)
name|server_cert
argument_list|)
argument_list|,
name|NID_commonName
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_name_loc
operator|<
literal|0
condition|)
block|{
return|return
name|Error
return|;
block|}
comment|// Extract the CN field
name|common_name_entry
operator|=
name|X509_NAME_get_entry
argument_list|(
name|X509_get_subject_name
argument_list|(
operator|(
name|X509
operator|*
operator|)
name|server_cert
argument_list|)
argument_list|,
name|common_name_loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_name_entry
operator|==
name|NULL
condition|)
block|{
return|return
name|Error
return|;
block|}
comment|// Convert the CN field to a C string
name|common_name_asn1
operator|=
name|X509_NAME_ENTRY_get_data
argument_list|(
name|common_name_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_name_asn1
operator|==
name|NULL
condition|)
block|{
return|return
name|Error
return|;
block|}
name|common_name_str
operator|=
operator|(
name|char
operator|*
operator|)
name|ASN1_STRING_data
argument_list|(
name|common_name_asn1
argument_list|)
expr_stmt|;
comment|// Make sure there isn't an embedded NUL character in the CN
if|if
condition|(
operator|(
name|size_t
operator|)
name|ASN1_STRING_length
argument_list|(
name|common_name_asn1
argument_list|)
operator|!=
name|strlen
argument_list|(
name|common_name_str
argument_list|)
condition|)
block|{
return|return
name|MalformedCertificate
return|;
block|}
comment|// Compare expected hostname with the CN
if|if
condition|(
name|Curl_cert_hostcheck
argument_list|(
name|common_name_str
argument_list|,
name|hostname
argument_list|)
operator|==
name|CURL_HOST_MATCH
condition|)
block|{
return|return
name|MatchFound
return|;
block|}
else|else
block|{
return|return
name|MatchNotFound
return|;
block|}
block|}
end_function

begin_comment
comment|/** * Tries to find a match for hostname in the certificate's Subject Alternative Name extension. * * Returns MatchFound if a match was found. * Returns MatchNotFound if no matches were found. * Returns MalformedCertificate if any of the hostnames had a NUL character embedded in it. * Returns NoSANPresent if the SAN extension was not present in the certificate. */
end_comment

begin_function
specifier|static
name|HostnameValidationResult
name|matches_subject_alternative_name
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|X509
modifier|*
name|server_cert
parameter_list|)
block|{
name|HostnameValidationResult
name|result
init|=
name|MatchNotFound
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|san_names_nb
init|=
operator|-
literal|1
decl_stmt|;
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|san_names
operator|=
name|NULL
expr_stmt|;
comment|// Try to extract the names within the SAN extension from the certificate
name|san_names
operator|=
name|X509_get_ext_d2i
argument_list|(
operator|(
name|X509
operator|*
operator|)
name|server_cert
argument_list|,
name|NID_subject_alt_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|san_names
operator|==
name|NULL
condition|)
block|{
return|return
name|NoSANPresent
return|;
block|}
name|san_names_nb
operator|=
name|sk_GENERAL_NAME_num
argument_list|(
name|san_names
argument_list|)
expr_stmt|;
comment|// Check each name within the extension
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|san_names_nb
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|GENERAL_NAME
modifier|*
name|current_name
init|=
name|sk_GENERAL_NAME_value
argument_list|(
name|san_names
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_name
operator|->
name|type
operator|==
name|GEN_DNS
condition|)
block|{
comment|// Current name is a DNS name, let's check it
name|char
modifier|*
name|dns_name
init|=
operator|(
name|char
operator|*
operator|)
name|ASN1_STRING_data
argument_list|(
name|current_name
operator|->
name|d
operator|.
name|dNSName
argument_list|)
decl_stmt|;
comment|// Make sure there isn't an embedded NUL character in the DNS name
if|if
condition|(
operator|(
name|size_t
operator|)
name|ASN1_STRING_length
argument_list|(
name|current_name
operator|->
name|d
operator|.
name|dNSName
argument_list|)
operator|!=
name|strlen
argument_list|(
name|dns_name
argument_list|)
condition|)
block|{
name|result
operator|=
name|MalformedCertificate
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// Compare expected hostname with the DNS name
if|if
condition|(
name|Curl_cert_hostcheck
argument_list|(
name|dns_name
argument_list|,
name|hostname
argument_list|)
operator|==
name|CURL_HOST_MATCH
condition|)
block|{
name|result
operator|=
name|MatchFound
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|sk_GENERAL_NAME_pop_free
argument_list|(
name|san_names
argument_list|,
name|GENERAL_NAME_free
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/** * Validates the server's identity by looking for the expected hostname in the * server's certificate. As described in RFC 6125, it first tries to find a match * in the Subject Alternative Name extension. If the extension is not present in * the certificate, it checks the Common Name instead. * * Returns MatchFound if a match was found. * Returns MatchNotFound if no matches were found. * Returns MalformedCertificate if any of the hostnames had a NUL character embedded in it. * Returns Error if there was an error. */
end_comment

begin_function
name|HostnameValidationResult
name|validate_hostname
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|X509
modifier|*
name|server_cert
parameter_list|)
block|{
name|HostnameValidationResult
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|hostname
operator|==
name|NULL
operator|)
operator|||
operator|(
name|server_cert
operator|==
name|NULL
operator|)
condition|)
return|return
name|Error
return|;
comment|// First try the Subject Alternative Names extension
name|result
operator|=
name|matches_subject_alternative_name
argument_list|(
name|hostname
argument_list|,
name|server_cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NoSANPresent
condition|)
block|{
comment|// Extension was not found: try the Common Name
name|result
operator|=
name|matches_common_name
argument_list|(
name|hostname
argument_list|,
name|server_cert
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

