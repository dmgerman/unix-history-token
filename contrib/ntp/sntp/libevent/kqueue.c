begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: kqueue.c,v 1.5 2002/07/10 14:41:31 art Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright 2000-2007 Niels Provos<provos@citi.umich.edu>  * Copyright 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_KQUEUE
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_INTTYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some platforms apparently define the udata field of struct kevent as  * intptr_t, whereas others define it as void*.  There doesn't seem to be an  * easy way to tell them apart via autoconf, so we need to use OS macros. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_INTTYPES_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__darwin__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_if

begin_define
define|#
directive|define
name|PTR_TO_UDATA
parameter_list|(
name|x
parameter_list|)
value|((intptr_t)(x))
end_define

begin_define
define|#
directive|define
name|INT_TO_UDATA
parameter_list|(
name|x
parameter_list|)
value|((intptr_t)(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTR_TO_UDATA
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_define
define|#
directive|define
name|INT_TO_UDATA
parameter_list|(
name|x
parameter_list|)
value|((void*)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"evmap-internal.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"changelist-internal.h"
end_include

begin_include
include|#
directive|include
file|"kqueue-internal.h"
end_include

begin_define
define|#
directive|define
name|NEVENT
value|64
end_define

begin_struct
struct|struct
name|kqop
block|{
name|struct
name|kevent
modifier|*
name|changes
decl_stmt|;
name|int
name|changes_size
decl_stmt|;
name|struct
name|kevent
modifier|*
name|events
decl_stmt|;
name|int
name|events_size
decl_stmt|;
name|int
name|kq
decl_stmt|;
name|int
name|notify_event_added
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|kqop_free
parameter_list|(
name|struct
name|kqop
modifier|*
name|kqop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|kq_init
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kq_sig_add
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
parameter_list|,
name|short
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kq_sig_del
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
parameter_list|,
name|short
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kq_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kq_dealloc
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|eventop
name|kqops
init|=
block|{
literal|"kqueue"
block|,
name|kq_init
block|,
name|event_changelist_add_
block|,
name|event_changelist_del_
block|,
name|kq_dispatch
block|,
name|kq_dealloc
block|,
literal|1
comment|/* need reinit */
block|,
name|EV_FEATURE_ET
operator||
name|EV_FEATURE_O1
operator||
name|EV_FEATURE_FDS
block|,
name|EVENT_CHANGELIST_FDINFO_SIZE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eventop
name|kqsigops
init|=
block|{
literal|"kqueue_signal"
block|,
name|NULL
block|,
name|kq_sig_add
block|,
name|kq_sig_del
block|,
name|NULL
block|,
name|NULL
block|,
literal|1
comment|/* need reinit */
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|kq_init
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|kq
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|kqop
modifier|*
name|kqueueop
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|kqueueop
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kqop
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Initialize the kernel queue */
if|if
condition|(
operator|(
name|kq
operator|=
name|kqueue
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"kqueue"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|kqueueop
operator|->
name|kq
operator|=
name|kq
expr_stmt|;
name|kqueueop
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* Initialize fields */
name|kqueueop
operator|->
name|changes
operator|=
name|mm_calloc
argument_list|(
name|NEVENT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kqueueop
operator|->
name|changes
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|kqueueop
operator|->
name|events
operator|=
name|mm_calloc
argument_list|(
name|NEVENT
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kqueueop
operator|->
name|events
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|kqueueop
operator|->
name|events_size
operator|=
name|kqueueop
operator|->
name|changes_size
operator|=
name|NEVENT
expr_stmt|;
comment|/* Check for Mac OS X kqueue bug. */
name|memset
argument_list|(
operator|&
name|kqueueop
operator|->
name|changes
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|kqueueop
operator|->
name|changes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|kqueueop
operator|->
name|changes
index|[
literal|0
index|]
operator|.
name|ident
operator|=
operator|-
literal|1
expr_stmt|;
name|kqueueop
operator|->
name|changes
index|[
literal|0
index|]
operator|.
name|filter
operator|=
name|EVFILT_READ
expr_stmt|;
name|kqueueop
operator|->
name|changes
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|EV_ADD
expr_stmt|;
comment|/* 	 * If kqueue works, then kevent will succeed, and it will 	 * stick an error in events[0].  If kqueue is broken, then 	 * kevent will fail. 	 */
if|if
condition|(
name|kevent
argument_list|(
name|kq
argument_list|,
name|kqueueop
operator|->
name|changes
argument_list|,
literal|1
argument_list|,
name|kqueueop
operator|->
name|events
argument_list|,
name|NEVENT
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|int
operator|)
name|kqueueop
operator|->
name|events
index|[
literal|0
index|]
operator|.
name|ident
operator|!=
operator|-
literal|1
operator|||
name|kqueueop
operator|->
name|events
index|[
literal|0
index|]
operator|.
name|flags
operator|!=
name|EV_ERROR
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: detected broken kqueue; not using."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|base
operator|->
name|evsigsel
operator|=
operator|&
name|kqsigops
expr_stmt|;
return|return
operator|(
name|kqueueop
operator|)
return|;
name|err
label|:
if|if
condition|(
name|kqueueop
condition|)
name|kqop_free
argument_list|(
name|kqueueop
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADD_UDATA
value|0x30303
end_define

begin_function
specifier|static
name|void
name|kq_setup_kevent
parameter_list|(
name|struct
name|kevent
modifier|*
name|out
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|int
name|filter
parameter_list|,
name|short
name|change
parameter_list|)
block|{
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|->
name|ident
operator|=
name|fd
expr_stmt|;
name|out
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
if|if
condition|(
name|change
operator|&
name|EV_CHANGE_ADD
condition|)
block|{
name|out
operator|->
name|flags
operator|=
name|EV_ADD
expr_stmt|;
comment|/* We set a magic number here so that we can tell 'add' 		 * errors from 'del' errors. */
name|out
operator|->
name|udata
operator|=
name|INT_TO_UDATA
argument_list|(
name|ADD_UDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|&
name|EV_ET
condition|)
name|out
operator|->
name|flags
operator||=
name|EV_CLEAR
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTE_EOF
comment|/* Make it behave like select() and poll() */
if|if
condition|(
name|filter
operator|==
name|EVFILT_READ
condition|)
name|out
operator|->
name|fflags
operator|=
name|NOTE_EOF
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|EVUTIL_ASSERT
argument_list|(
name|change
operator|&
name|EV_CHANGE_DEL
argument_list|)
expr_stmt|;
name|out
operator|->
name|flags
operator|=
name|EV_DELETE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|kq_build_changes_list
parameter_list|(
specifier|const
name|struct
name|event_changelist
modifier|*
name|changelist
parameter_list|,
name|struct
name|kqop
modifier|*
name|kqop
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|n_changes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changelist
operator|->
name|n_changes
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|event_change
modifier|*
name|in_ch
init|=
operator|&
name|changelist
operator|->
name|changes
index|[
name|i
index|]
decl_stmt|;
name|struct
name|kevent
modifier|*
name|out_ch
decl_stmt|;
if|if
condition|(
name|n_changes
operator|>=
name|kqop
operator|->
name|changes_size
operator|-
literal|1
condition|)
block|{
name|int
name|newsize
init|=
name|kqop
operator|->
name|changes_size
operator|*
literal|2
decl_stmt|;
name|struct
name|kevent
modifier|*
name|newchanges
decl_stmt|;
name|newchanges
operator|=
name|mm_realloc
argument_list|(
name|kqop
operator|->
name|changes
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newchanges
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: realloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kqop
operator|->
name|changes
operator|=
name|newchanges
expr_stmt|;
name|kqop
operator|->
name|changes_size
operator|=
name|newsize
expr_stmt|;
block|}
if|if
condition|(
name|in_ch
operator|->
name|read_change
condition|)
block|{
name|out_ch
operator|=
operator|&
name|kqop
operator|->
name|changes
index|[
name|n_changes
operator|++
index|]
expr_stmt|;
name|kq_setup_kevent
argument_list|(
name|out_ch
argument_list|,
name|in_ch
operator|->
name|fd
argument_list|,
name|EVFILT_READ
argument_list|,
name|in_ch
operator|->
name|read_change
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_ch
operator|->
name|write_change
condition|)
block|{
name|out_ch
operator|=
operator|&
name|kqop
operator|->
name|changes
index|[
name|n_changes
operator|++
index|]
expr_stmt|;
name|kq_setup_kevent
argument_list|(
name|out_ch
argument_list|,
name|in_ch
operator|->
name|fd
argument_list|,
name|EVFILT_WRITE
argument_list|,
name|in_ch
operator|->
name|write_change
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|n_changes
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kq_grow_events
parameter_list|(
name|struct
name|kqop
modifier|*
name|kqop
parameter_list|,
name|size_t
name|new_size
parameter_list|)
block|{
name|struct
name|kevent
modifier|*
name|newresult
decl_stmt|;
name|newresult
operator|=
name|mm_realloc
argument_list|(
name|kqop
operator|->
name|events
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newresult
condition|)
block|{
name|kqop
operator|->
name|events
operator|=
name|newresult
expr_stmt|;
name|kqop
operator|->
name|events_size
operator|=
name|new_size
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|kq_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|kevent
modifier|*
name|events
init|=
name|kqop
operator|->
name|events
decl_stmt|;
name|struct
name|kevent
modifier|*
name|changes
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|ts_p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_changes
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
name|tv
operator|!=
name|NULL
condition|)
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ts_p
operator|=
operator|&
name|ts
expr_stmt|;
block|}
comment|/* Build "changes" from "base->changes" */
name|EVUTIL_ASSERT
argument_list|(
name|kqop
operator|->
name|changes
argument_list|)
expr_stmt|;
name|n_changes
operator|=
name|kq_build_changes_list
argument_list|(
operator|&
name|base
operator|->
name|changelist
argument_list|,
name|kqop
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_changes
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|event_changelist_remove_all_
argument_list|(
operator|&
name|base
operator|->
name|changelist
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* steal the changes array in case some broken code tries to call 	 * dispatch twice at once. */
name|changes
operator|=
name|kqop
operator|->
name|changes
expr_stmt|;
name|kqop
operator|->
name|changes
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure that 'events' is at least as long as the list of changes: 	 * otherwise errors in the changes can get reported as a -1 return 	 * value from kevent() rather than as EV_ERROR events in the events 	 * array. 	 * 	 * (We could instead handle -1 return values from kevent() by 	 * retrying with a smaller changes array or a larger events array, 	 * but this approach seems less risky for now.) 	 */
if|if
condition|(
name|kqop
operator|->
name|events_size
operator|<
name|n_changes
condition|)
block|{
name|int
name|new_size
init|=
name|kqop
operator|->
name|events_size
decl_stmt|;
do|do
block|{
name|new_size
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|new_size
operator|<
name|n_changes
condition|)
do|;
name|kq_grow_events
argument_list|(
name|kqop
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|events
operator|=
name|kqop
operator|->
name|events
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|kevent
argument_list|(
name|kqop
operator|->
name|kq
argument_list|,
name|changes
argument_list|,
name|n_changes
argument_list|,
name|events
argument_list|,
name|kqop
operator|->
name|events_size
argument_list|,
name|ts_p
argument_list|)
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|kqop
operator|->
name|changes
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|kqop
operator|->
name|changes
operator|=
name|changes
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|event_warn
argument_list|(
literal|"kevent"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: kevent reports %d"
operator|,
name|__func__
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
condition|;
name|i
operator|++
control|)
block|{
name|int
name|which
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|EV_ERROR
condition|)
block|{
switch|switch
condition|(
name|events
index|[
name|i
index|]
operator|.
name|data
condition|)
block|{
comment|/* Can occur on delete if we are not currently 			 * watching any events on this fd.  That can 			 * happen when the fd was closed and another 			 * file was opened with that fd. */
case|case
name|ENOENT
case|:
comment|/* Can occur for reasons not fully understood 			 * on FreeBSD. */
case|case
name|EINVAL
case|:
continue|continue;
comment|/* Can occur on a delete if the fd is closed. */
case|case
name|EBADF
case|:
comment|/* XXXX On NetBSD, we can also get EBADF if we 				 * try to add the write side of a pipe, but 				 * the read side has already been closed. 				 * Other BSDs call this situation 'EPIPE'. It 				 * would be good if we had a way to report 				 * this situation. */
continue|continue;
comment|/* These two can occur on an add if the fd was one side 			 * of a pipe, and the other side was closed. */
case|case
name|EPERM
case|:
case|case
name|EPIPE
case|:
comment|/* Report read events, if we're listening for 				 * them, so that the user can learn about any 				 * add errors.  (If the operation was a 				 * delete, then udata should be cleared.) */
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|udata
condition|)
block|{
comment|/* The operation was an add: 					 * report the error as a read. */
name|which
operator||=
name|EV_READ
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* The operation was a del: 					 * report nothing. */
continue|continue;
block|}
comment|/* Other errors shouldn't occur. */
default|default:
name|errno
operator|=
name|events
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_READ
condition|)
block|{
name|which
operator||=
name|EV_READ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_WRITE
condition|)
block|{
name|which
operator||=
name|EV_WRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_SIGNAL
condition|)
block|{
name|which
operator||=
name|EV_SIGNAL
expr_stmt|;
ifdef|#
directive|ifdef
name|EVFILT_USER
block|}
elseif|else
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_USER
condition|)
block|{
name|base
operator|->
name|is_notify_pending
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|which
condition|)
continue|continue;
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_SIGNAL
condition|)
block|{
name|evmap_signal_active_
argument_list|(
name|base
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evmap_io_active_
argument_list|(
name|base
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
name|which
operator||
name|EV_ET
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|==
name|kqop
operator|->
name|events_size
condition|)
block|{
comment|/* We used all the events space that we have. Maybe we should 		   make it bigger. */
name|kq_grow_events
argument_list|(
name|kqop
argument_list|,
name|kqop
operator|->
name|events_size
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqop_free
parameter_list|(
name|struct
name|kqop
modifier|*
name|kqop
parameter_list|)
block|{
if|if
condition|(
name|kqop
operator|->
name|changes
condition|)
name|mm_free
argument_list|(
name|kqop
operator|->
name|changes
argument_list|)
expr_stmt|;
if|if
condition|(
name|kqop
operator|->
name|events
condition|)
name|mm_free
argument_list|(
name|kqop
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
name|kqop
operator|->
name|kq
operator|>=
literal|0
operator|&&
name|kqop
operator|->
name|pid
operator|==
name|getpid
argument_list|()
condition|)
name|close
argument_list|(
name|kqop
operator|->
name|kq
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kqop
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kqop
argument_list|)
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|kqop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kq_dealloc
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|evsig_dealloc_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|kqop_free
argument_list|(
name|kqop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* signal handling */
end_comment

begin_function
specifier|static
name|int
name|kq_sig_add
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|nsignal
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|timespec
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|p
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|nsignal
operator|>=
literal|0
operator|&&
name|nsignal
operator|<
name|NSIG
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|kev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
name|nsignal
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_SIGNAL
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_ADD
expr_stmt|;
comment|/* Be ready for the signal if it is sent any 	 * time between now and the next call to 	 * kq_dispatch. */
if|if
condition|(
name|kevent
argument_list|(
name|kqop
operator|->
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* We can set the handler for most signals to SIG_IGN and          * still have them reported to us in the queue.  However,          * if the handler for SIGCHLD is SIG_IGN, the system reaps          * zombie processes for us, and we don't get any notification.          * This appears to be the only signal with this quirk. */
if|if
condition|(
name|evsig_set_handler_
argument_list|(
name|base
argument_list|,
name|nsignal
argument_list|,
name|nsignal
operator|==
name|SIGCHLD
condition|?
name|SIG_DFL
else|:
name|SIG_IGN
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kq_sig_del
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|nsignal
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|timespec
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|p
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|nsignal
operator|>=
literal|0
operator|&&
name|nsignal
operator|<
name|NSIG
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|kev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
name|nsignal
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_SIGNAL
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_DELETE
expr_stmt|;
comment|/* Because we insert signal events 	 * immediately, we need to delete them 	 * immediately, too */
if|if
condition|(
name|kevent
argument_list|(
name|kqop
operator|->
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|evsig_restore_handler_
argument_list|(
name|base
argument_list|,
name|nsignal
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* OSX 10.6 and FreeBSD 8.1 add support for EVFILT_USER, which we can use  * to wake up the event loop from another thread. */
end_comment

begin_comment
comment|/* Magic number we use for our filter ID. */
end_comment

begin_define
define|#
directive|define
name|NOTIFY_IDENT
value|42
end_define

begin_function
name|int
name|event_kq_add_notify_event_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EVFILT_USER
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTE_TRIGGER
argument_list|)
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|timespec
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|kqop
operator|->
name|notify_event_added
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|EVFILT_USER
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTE_TRIGGER
argument_list|)
name|memset
argument_list|(
operator|&
name|kev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
name|NOTIFY_IDENT
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_USER
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|EV_ADD
operator||
name|EV_CLEAR
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kqop
operator|->
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"kevent: adding EVFILT_USER event"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|kqop
operator|->
name|notify_event_added
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|event_kq_notify_base_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|kqop
modifier|*
name|kqop
init|=
name|base
operator|->
name|evbase
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EVFILT_USER
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTE_TRIGGER
argument_list|)
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|timespec
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|kqop
operator|->
name|notify_event_added
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|defined
argument_list|(
name|EVFILT_USER
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTE_TRIGGER
argument_list|)
name|memset
argument_list|(
operator|&
name|kev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
name|kev
operator|.
name|ident
operator|=
name|NOTIFY_IDENT
expr_stmt|;
name|kev
operator|.
name|filter
operator|=
name|EVFILT_USER
expr_stmt|;
name|kev
operator|.
name|fflags
operator|=
name|NOTE_TRIGGER
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|kqop
operator|->
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|event_warn
argument_list|(
literal|"kevent: triggering EVFILT_USER event"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EVENT__HAVE_KQUEUE */
end_comment

end_unit

