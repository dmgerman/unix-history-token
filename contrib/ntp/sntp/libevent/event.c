begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_include
include|#
directive|include
file|<winsock2.h>
end_include

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|defined
argument_list|(
name|EVENT__HAVE_SYS_TIME_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_SOCKET_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_compat.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"defer-internal.h"
end_include

begin_include
include|#
directive|include
file|"evthread-internal.h"
end_include

begin_include
include|#
directive|include
file|"event2/thread.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"log-internal.h"
end_include

begin_include
include|#
directive|include
file|"evmap-internal.h"
end_include

begin_include
include|#
directive|include
file|"iocp-internal.h"
end_include

begin_include
include|#
directive|include
file|"changelist-internal.h"
end_include

begin_define
define|#
directive|define
name|HT_NO_CACHE_HASH_VALUES
end_define

begin_include
include|#
directive|include
file|"ht-internal.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_WORKING_KQUEUE
end_ifdef

begin_include
include|#
directive|include
file|"kqueue-internal.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENT_PORTS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|evportops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_SELECT
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|selectops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_POLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|pollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_EPOLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|epollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_WORKING_KQUEUE
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|kqops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_DEVPOLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|devpollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|win32ops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Array of backends in order of preference. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eventop
modifier|*
name|eventops
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENT_PORTS
operator|&
name|evportops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_WORKING_KQUEUE
operator|&
name|kqops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_EPOLL
operator|&
name|epollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_DEVPOLL
operator|&
name|devpollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_POLL
operator|&
name|pollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_SELECT
operator|&
name|selectops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
operator|&
name|win32ops
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global state; deprecated */
end_comment

begin_decl_stmt
name|struct
name|event_base
modifier|*
name|event_global_current_base_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|current_base
value|event_global_current_base_
end_define

begin_comment
comment|/* Global state */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|event_self_cbarg_ptr_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|event_queue_insert_active
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_insert_active_later
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_insert_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_insert_inserted
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_remove_active
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_remove_active_later
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event_callback
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_remove_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_remove_inserted
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_make_later_events_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evthread_make_base_notifiable_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|event_del_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|blocking
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_REINSERT_TIMEOUT
end_ifdef

begin_comment
comment|/* This code seems buggy; only turn it on if we find out what the trouble is. */
end_comment

begin_function_decl
specifier|static
name|void
name|event_queue_reinsert_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|,
name|int
name|was_common
parameter_list|,
name|int
name|is_common
parameter_list|,
name|int
name|old_timeout_idx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|event_haveevents
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|event_process_active
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timeout_next
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout_process
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|event_signal_closure
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|event_persist_closure
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|evthread_notify_base
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_common_timeout_inorder
parameter_list|(
name|struct
name|common_timeout_list
modifier|*
name|ctl
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
end_ifndef

begin_comment
comment|/* These functions implement a hashtable of which 'struct event *' structures  * have been setup or added.  We don't want to trust the content of the struct  * event itself, since we're trying to work through cases where an event gets  * clobbered or freed.  Instead, we keep a hashtable indexed by the pointer.  */
end_comment

begin_struct
struct|struct
name|event_debug_entry
block|{
name|HT_ENTRY
argument_list|(
argument|event_debug_entry
argument_list|)
name|node
expr_stmt|;
specifier|const
name|struct
name|event
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|added
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|unsigned
name|hash_debug_entry
parameter_list|(
specifier|const
name|struct
name|event_debug_entry
modifier|*
name|e
parameter_list|)
block|{
comment|/* We need to do this silliness to convince compilers that we 	 * honestly mean to cast e->ptr to an integer, and discard any 	 * part of it that doesn't fit in an unsigned. 	 */
name|unsigned
name|u
init|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|ev_uintptr_t
operator|)
name|e
operator|->
name|ptr
argument_list|)
decl_stmt|;
comment|/* Our hashtable implementation is pretty sensitive to low bits, 	 * and every struct event is over 64 bytes in size, so we can 	 * just say>>6. */
return|return
operator|(
name|u
operator|>>
literal|6
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|eq_debug_entry
parameter_list|(
specifier|const
name|struct
name|event_debug_entry
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|event_debug_entry
modifier|*
name|b
parameter_list|)
block|{
return|return
name|a
operator|->
name|ptr
operator|==
name|b
operator|->
name|ptr
return|;
block|}
end_function

begin_decl_stmt
name|int
name|event_debug_mode_on_
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if it's too late to enable event_debug_mode. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|event_debug_mode_too_late
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifndef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|event_debug_map_lock_
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|HT_HEAD
argument_list|(
argument|event_debug_map
argument_list|,
argument|event_debug_entry
argument_list|)
name|global_debug_map
operator|=
name|HT_INITIALIZER
argument_list|()
expr_stmt|;
end_expr_stmt

begin_macro
name|HT_PROTOTYPE
argument_list|(
argument|event_debug_map
argument_list|,
argument|event_debug_entry
argument_list|,
argument|node
argument_list|,
argument|hash_debug_entry
argument_list|,
argument|eq_debug_entry
argument_list|)
end_macro

begin_macro
name|HT_GENERATE
argument_list|(
argument|event_debug_map
argument_list|,
argument|event_debug_entry
argument_list|,
argument|node
argument_list|,
argument|hash_debug_entry
argument_list|,
argument|eq_debug_entry
argument_list|,
literal|0.5
argument_list|,
argument|mm_malloc
argument_list|,
argument|mm_realloc
argument_list|,
argument|mm_free
argument_list|)
end_macro

begin_comment
comment|/* Macro: record that ev is now setup (that is, ready for an add) */
end_comment

begin_define
define|#
directive|define
name|event_debug_note_setup_
parameter_list|(
name|ev
parameter_list|)
value|do {				\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_FIND(event_debug_map,&global_debug_map,&find); \ 		if (dent) {						\ 			dent->added = 0;				\ 		} else {						\ 			dent = mm_malloc(sizeof(*dent));		\ 			if (!dent)					\ 				event_err(1,				\ 				    "Out of memory in debugging code");	\ 			dent->ptr = (ev);				\ 			dent->added = 0;				\ 			HT_INSERT(event_debug_map,&global_debug_map, dent); \ 		}							\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	event_debug_mode_too_late = 1;					\ 	} while (0)
end_define

begin_comment
comment|/* Macro: record that ev is no longer setup */
end_comment

begin_define
define|#
directive|define
name|event_debug_note_teardown_
parameter_list|(
name|ev
parameter_list|)
value|do {				\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_REMOVE(event_debug_map,&global_debug_map,&find); \ 		if (dent)						\ 			mm_free(dent);					\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	event_debug_mode_too_late = 1;					\ 	} while (0)
end_define

begin_comment
comment|/* Macro: record that ev is now added */
end_comment

begin_define
define|#
directive|define
name|event_debug_note_add_
parameter_list|(
name|ev
parameter_list|)
value|do {				\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_FIND(event_debug_map,&global_debug_map,&find); \ 		if (dent) {						\ 			dent->added = 1;				\ 		} else {						\ 			event_errx(EVENT_ERR_ABORT_,			\ 			    "%s: noting an add on a non-setup event %p" \ 			    " (events: 0x%x, fd: "EV_SOCK_FMT		\ 			    ", flags: 0x%x)",				\ 			    __func__, (ev), (ev)->ev_events,		\ 			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\ 		}							\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	event_debug_mode_too_late = 1;					\ 	} while (0)
end_define

begin_comment
comment|/* Macro: record that ev is no longer added */
end_comment

begin_define
define|#
directive|define
name|event_debug_note_del_
parameter_list|(
name|ev
parameter_list|)
value|do {					\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_FIND(event_debug_map,&global_debug_map,&find); \ 		if (dent) {						\ 			dent->added = 0;				\ 		} else {						\ 			event_errx(EVENT_ERR_ABORT_,			\ 			    "%s: noting a del on a non-setup event %p"	\ 			    " (events: 0x%x, fd: "EV_SOCK_FMT		\ 			    ", flags: 0x%x)",				\ 			    __func__, (ev), (ev)->ev_events,		\ 			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\ 		}							\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	event_debug_mode_too_late = 1;					\ 	} while (0)
end_define

begin_comment
comment|/* Macro: assert that ev is setup (i.e., okay to add or inspect) */
end_comment

begin_define
define|#
directive|define
name|event_debug_assert_is_setup_
parameter_list|(
name|ev
parameter_list|)
value|do {				\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_FIND(event_debug_map,&global_debug_map,&find); \ 		if (!dent) {						\ 			event_errx(EVENT_ERR_ABORT_,			\ 			    "%s called on a non-initialized event %p"	\ 			    " (events: 0x%x, fd: "EV_SOCK_FMT\ 			    ", flags: 0x%x)",				\ 			    __func__, (ev), (ev)->ev_events,		\ 			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\ 		}							\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	} while (0)
end_define

begin_comment
comment|/* Macro: assert that ev is not added (i.e., okay to tear down or set  * up again) */
end_comment

begin_define
define|#
directive|define
name|event_debug_assert_not_added_
parameter_list|(
name|ev
parameter_list|)
value|do {				\ 	if (event_debug_mode_on_) {					\ 		struct event_debug_entry *dent,find;			\ 		find.ptr = (ev);					\ 		EVLOCK_LOCK(event_debug_map_lock_, 0);			\ 		dent = HT_FIND(event_debug_map,&global_debug_map,&find); \ 		if (dent&& dent->added) {				\ 			event_errx(EVENT_ERR_ABORT_,			\ 			    "%s called on an already added event %p"	\ 			    " (events: 0x%x, fd: "EV_SOCK_FMT", "	\ 			    "flags: 0x%x)",				\ 			    __func__, (ev), (ev)->ev_events,		\ 			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\ 		}							\ 		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\ 	}								\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|event_debug_note_setup_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_define
define|#
directive|define
name|event_debug_note_teardown_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_define
define|#
directive|define
name|event_debug_note_add_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_define
define|#
directive|define
name|event_debug_note_del_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_define
define|#
directive|define
name|event_debug_assert_is_setup_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_define
define|#
directive|define
name|event_debug_assert_not_added_
parameter_list|(
name|ev
parameter_list|)
define|\
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EVENT_BASE_ASSERT_LOCKED
parameter_list|(
name|base
parameter_list|)
define|\
value|EVLOCK_ASSERT_LOCKED((base)->th_base_lock)
end_define

begin_comment
comment|/* How often (in seconds) do we check for changes in wall clock time relative  * to monotonic time?  Set this to -1 for 'never.' */
end_comment

begin_define
define|#
directive|define
name|CLOCK_SYNC_INTERVAL
value|5
end_define

begin_comment
comment|/** Set 'tp' to the current time according to 'base'.  We must hold the lock  * on 'base'.  If there is a cached time, return it.  Otherwise, use  * clock_gettime or gettimeofday as appropriate to find out the right time.  * Return 0 on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|gettime
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|tv_cache
operator|.
name|tv_sec
condition|)
block|{
operator|*
name|tp
operator|=
name|base
operator|->
name|tv_cache
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|evutil_gettime_monotonic_
argument_list|(
operator|&
name|base
operator|->
name|monotonic_timer
argument_list|,
name|tp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|base
operator|->
name|last_updated_clock_diff
operator|+
name|CLOCK_SYNC_INTERVAL
operator|<
name|tp
operator|->
name|tv_sec
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|evutil_gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|evutil_timersub
argument_list|(
operator|&
name|tv
argument_list|,
name|tp
argument_list|,
operator|&
name|base
operator|->
name|tv_clock_diff
argument_list|)
expr_stmt|;
name|base
operator|->
name|last_updated_clock_diff
operator|=
name|tp
operator|->
name|tv_sec
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|event_base_gettimeofday_cached
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
block|{
name|base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
operator|!
name|current_base
condition|)
return|return
name|evutil_gettimeofday
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|)
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|tv_cache
operator|.
name|tv_sec
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|evutil_gettimeofday
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evutil_timeradd
argument_list|(
operator|&
name|base
operator|->
name|tv_cache
argument_list|,
operator|&
name|base
operator|->
name|tv_clock_diff
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** Make 'base' have no current cached time. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|clear_time_cache
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|base
operator|->
name|tv_cache
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Replace the cached time in 'base' with the current time. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|update_time_cache
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|base
operator|->
name|tv_cache
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|base
operator|->
name|flags
operator|&
name|EVENT_BASE_FLAG_NO_CACHE_TIME
operator|)
condition|)
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|base
operator|->
name|tv_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_base_update_cache_time
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
if|if
condition|(
operator|!
name|base
condition|)
block|{
name|base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
operator|!
name|current_base
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|running_loop
condition|)
name|update_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|event
modifier|*
name|event_callback_to_event
parameter_list|(
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
operator|)
argument_list|)
expr_stmt|;
return|return
name|EVUTIL_UPCAST
argument_list|(
name|evcb
argument_list|,
expr|struct
name|event
argument_list|,
name|ev_evcallback
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|event_callback
modifier|*
name|event_to_event_callback
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
return|return
operator|&
name|ev
operator|->
name|ev_evcallback
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|event_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|event_base_new_with_config
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Unable to construct event_base"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|current_base
operator|=
name|base
expr_stmt|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|event_base_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|NULL
decl_stmt|;
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|event_config_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
name|base
operator|=
name|event_base_new_with_config
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|event_config_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function

begin_comment
comment|/** Return true iff 'method' is the name of a method that 'cfg' tells us to  * avoid. */
end_comment

begin_function
specifier|static
name|int
name|event_config_is_avoided_method
parameter_list|(
specifier|const
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
name|struct
name|event_config_entry
modifier|*
name|entry
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&cfg->entries
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|avoid_method
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|entry
operator|->
name|avoid_method
argument_list|,
name|method
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Return true iff 'method' is disabled according to the environment. */
end_comment

begin_function
specifier|static
name|int
name|event_is_method_disabled
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|environment
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|evutil_snprintf
argument_list|(
name|environment
argument_list|,
sizeof|sizeof
argument_list|(
name|environment
argument_list|)
argument_list|,
literal|"EVENT_NO%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|environment
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|environment
index|[
name|i
index|]
operator|=
name|EVUTIL_TOUPPER_
argument_list|(
name|environment
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Note that evutil_getenv_() ignores the environment entirely if 	 * we're setuid */
return|return
operator|(
name|evutil_getenv_
argument_list|(
name|environment
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_get_features
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
return|return
name|base
operator|->
name|evsel
operator|->
name|features
return|;
block|}
end_function

begin_function
name|void
name|event_enable_debug_mode
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
if|if
condition|(
name|event_debug_mode_on_
condition|)
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s was called twice!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_debug_mode_too_late
condition|)
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s must be called *before* creating any events "
literal|"or event_bases"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|event_debug_mode_on_
operator|=
literal|1
expr_stmt|;
name|HT_INIT
argument_list|(
name|event_debug_map
argument_list|,
operator|&
name|global_debug_map
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void event_disable_debug_mode(void) { 	struct event_debug_entry **ent, *victim;  	EVLOCK_LOCK(event_debug_map_lock_, 0); 	for (ent = HT_START(event_debug_map,&global_debug_map); ent; ) { 		victim = *ent; 		ent = HT_NEXT_RMV(event_debug_map,&global_debug_map, ent); 		mm_free(victim); 	} 	HT_CLEAR(event_debug_map,&global_debug_map); 	EVLOCK_UNLOCK(event_debug_map_lock_ , 0); }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|event_base
modifier|*
name|event_base_new_with_config
parameter_list|(
specifier|const
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|int
name|should_check_environment
decl_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
name|event_debug_mode_too_late
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|base
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cfg
condition|)
name|base
operator|->
name|flags
operator|=
name|cfg
operator|->
name|flags
expr_stmt|;
name|should_check_environment
operator|=
operator|!
operator|(
name|cfg
operator|&&
operator|(
name|cfg
operator|->
name|flags
operator|&
name|EVENT_BASE_FLAG_IGNORE_ENV
operator|)
operator|)
expr_stmt|;
block|{
name|struct
name|timeval
name|tmp
decl_stmt|;
name|int
name|precise_time
init|=
name|cfg
operator|&&
operator|(
name|cfg
operator|->
name|flags
operator|&
name|EVENT_BASE_FLAG_PRECISE_TIMER
operator|)
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|should_check_environment
operator|&&
operator|!
name|precise_time
condition|)
block|{
name|precise_time
operator|=
name|evutil_getenv_
argument_list|(
literal|"EVENT_PRECISE_TIMER"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|base
operator|->
name|flags
operator||=
name|EVENT_BASE_FLAG_PRECISE_TIMER
expr_stmt|;
block|}
name|flags
operator|=
name|precise_time
condition|?
name|EV_MONOT_PRECISE
else|:
literal|0
expr_stmt|;
name|evutil_configure_monotonic_time_
argument_list|(
operator|&
name|base
operator|->
name|monotonic_timer
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
name|min_heap_ctor_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
expr_stmt|;
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|)
expr_stmt|;
name|evmap_io_initmap_
argument_list|(
operator|&
name|base
operator|->
name|io
argument_list|)
expr_stmt|;
name|evmap_signal_initmap_
argument_list|(
operator|&
name|base
operator|->
name|sigmap
argument_list|)
expr_stmt|;
name|event_changelist_init_
argument_list|(
operator|&
name|base
operator|->
name|changelist
argument_list|)
expr_stmt|;
name|base
operator|->
name|evbase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cfg
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|base
operator|->
name|max_dispatch_time
argument_list|,
operator|&
name|cfg
operator|->
name|max_dispatch_interval
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|->
name|limit_callbacks_after_prio
operator|=
name|cfg
operator|->
name|limit_callbacks_after_prio
expr_stmt|;
block|}
else|else
block|{
name|base
operator|->
name|max_dispatch_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|limit_callbacks_after_prio
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cfg
operator|&&
name|cfg
operator|->
name|max_dispatch_callbacks
operator|>=
literal|0
condition|)
block|{
name|base
operator|->
name|max_dispatch_callbacks
operator|=
name|cfg
operator|->
name|max_dispatch_callbacks
expr_stmt|;
block|}
else|else
block|{
name|base
operator|->
name|max_dispatch_callbacks
operator|=
name|INT_MAX
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|max_dispatch_callbacks
operator|==
name|INT_MAX
operator|&&
name|base
operator|->
name|max_dispatch_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
name|base
operator|->
name|limit_callbacks_after_prio
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|eventops
index|[
name|i
index|]
operator|&&
operator|!
name|base
operator|->
name|evbase
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfg
operator|!=
name|NULL
condition|)
block|{
comment|/* determine if this backend should be avoided */
if|if
condition|(
name|event_config_is_avoided_method
argument_list|(
name|cfg
argument_list|,
name|eventops
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|eventops
index|[
name|i
index|]
operator|->
name|features
operator|&
name|cfg
operator|->
name|require_features
operator|)
operator|!=
name|cfg
operator|->
name|require_features
condition|)
continue|continue;
block|}
comment|/* also obey the environment variables */
if|if
condition|(
name|should_check_environment
operator|&&
name|event_is_method_disabled
argument_list|(
name|eventops
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
continue|continue;
name|base
operator|->
name|evsel
operator|=
name|eventops
index|[
name|i
index|]
expr_stmt|;
name|base
operator|->
name|evbase
operator|=
name|base
operator|->
name|evsel
operator|->
name|init
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|evbase
operator|==
name|NULL
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: no event mechanism available"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|base
operator|->
name|evsel
operator|=
name|NULL
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|evutil_getenv_
argument_list|(
literal|"EVENT_SHOW_METHOD"
argument_list|)
condition|)
name|event_msgx
argument_list|(
literal|"libevent using: %s"
argument_list|,
name|base
operator|->
name|evsel
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* allocate a single active event queue */
if|if
condition|(
name|event_base_priority_init
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* prepare for threading */
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|EVTHREAD_LOCKING_ENABLED
argument_list|()
operator|&&
operator|(
operator|!
name|cfg
operator|||
operator|!
operator|(
name|cfg
operator|->
name|flags
operator|&
name|EVENT_BASE_FLAG_NOLOCK
operator|)
operator|)
condition|)
block|{
name|int
name|r
decl_stmt|;
name|EVTHREAD_ALLOC_LOCK
argument_list|(
name|base
operator|->
name|th_base_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_ALLOC_COND
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|)
expr_stmt|;
name|r
operator|=
name|evthread_make_base_notifiable
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: Unable to make base notifiable."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|event_base_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|cfg
operator|&&
operator|(
name|cfg
operator|->
name|flags
operator|&
name|EVENT_BASE_FLAG_STARTUP_IOCP
operator|)
condition|)
name|event_base_start_iocp_
argument_list|(
name|base
argument_list|,
name|cfg
operator|->
name|n_cpus_hint
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_start_iocp_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|n_cpus
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
if|if
condition|(
name|base
operator|->
name|iocp
condition|)
return|return
literal|0
return|;
name|base
operator|->
name|iocp
operator|=
name|event_iocp_port_launch_
argument_list|(
name|n_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|iocp
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: Couldn't launch IOCP"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|event_base_stop_iocp_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|int
name|rv
decl_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|iocp
condition|)
return|return;
name|rv
operator|=
name|event_iocp_shutdown_
argument_list|(
name|base
operator|->
name|iocp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|rv
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|base
operator|->
name|iocp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|event_base_cancel_single_callback_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|int
name|run_finalizers
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
condition|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
operator|)
condition|)
block|{
name|event_del_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_EVEN_IF_FINALIZING
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_callback_cancel_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|run_finalizers
operator|&&
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_FINALIZING
operator|)
condition|)
block|{
switch|switch
condition|(
name|evcb
operator|->
name|evcb_closure
condition|)
block|{
case|case
name|EV_CLOSURE_EVENT_FINALIZE
case|:
case|case
name|EV_CLOSURE_EVENT_FINALIZE_FREE
case|:
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
decl_stmt|;
name|ev
operator|->
name|ev_evcallback
operator|.
name|evcb_cb_union
operator|.
name|evcb_evfinalize
argument_list|(
name|ev
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_closure
operator|==
name|EV_CLOSURE_EVENT_FINALIZE_FREE
condition|)
name|mm_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EV_CLOSURE_CB_FINALIZE
case|:
name|evcb
operator|->
name|evcb_cb_union
operator|.
name|evcb_cbfinalize
argument_list|(
name|evcb
argument_list|,
name|evcb
operator|->
name|evcb_arg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_base_free_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|run_finalizers
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n_deleted
init|=
literal|0
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
comment|/* XXXX grab the lock? If there is contention when one thread frees 	 * the base, then the contending thread will be very sad soon. */
comment|/* event_base_free(NULL) is how to free the current_base if we 	 * made it with event_init and forgot to hold a reference to it. */
if|if
condition|(
name|base
operator|==
name|NULL
operator|&&
name|current_base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
comment|/* Don't actually free NULL. */
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: no base to free"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX(niels) - check for internal events first */
ifdef|#
directive|ifdef
name|_WIN32
name|event_base_stop_iocp_
argument_list|(
name|base
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* threading fds if we have them */
if|if
condition|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|event_del
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|)
expr_stmt|;
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all non-internal events. */
name|evmap_delete_all_
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ev
operator|=
name|min_heap_top_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
operator|++
name|n_deleted
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_common_timeouts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|base
operator|->
name|common_timeout_queues
index|[
name|i
index|]
decl_stmt|;
name|event_del
argument_list|(
operator|&
name|ctl
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
comment|/* Internal; doesn't count */
name|event_debug_unassign
argument_list|(
operator|&
name|ctl
operator|->
name|timeout_event
argument_list|)
expr_stmt|;
for|for
control|(
name|ev
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|)
init|;
name|ev
condition|;
control|)
block|{
name|struct
name|event
modifier|*
name|next
init|=
name|TAILQ_NEXT
argument_list|(
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
operator|)
condition|)
block|{
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
operator|++
name|n_deleted
expr_stmt|;
block|}
name|ev
operator|=
name|next
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|common_timeout_queues
condition|)
name|mm_free
argument_list|(
name|base
operator|->
name|common_timeout_queues
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|evcb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
init|;
name|evcb
condition|;
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
name|n_deleted
operator|+=
name|event_base_cancel_single_callback_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
name|run_finalizers
argument_list|)
expr_stmt|;
name|evcb
operator|=
name|next
expr_stmt|;
block|}
block|}
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
while|while
condition|(
operator|(
name|evcb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|)
operator|)
condition|)
block|{
name|n_deleted
operator|+=
name|event_base_cancel_single_callback_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
name|run_finalizers
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_deleted
condition|)
name|event_debug
argument_list|(
operator|(
literal|"%s: %d events were still set in base"
operator|,
name|__func__
operator|,
name|n_deleted
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|base
operator|->
name|once_events
argument_list|)
condition|)
block|{
name|struct
name|event_once
modifier|*
name|eonce
init|=
name|LIST_FIRST
argument_list|(
operator|&
name|base
operator|->
name|once_events
argument_list|)
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|eonce
argument_list|,
name|next_once
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|evsel
operator|!=
name|NULL
operator|&&
name|base
operator|->
name|evsel
operator|->
name|dealloc
operator|!=
name|NULL
condition|)
name|base
operator|->
name|evsel
operator|->
name|dealloc
argument_list|(
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
name|EVUTIL_ASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|min_heap_empty_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
argument_list|)
expr_stmt|;
name|min_heap_dtor_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|base
operator|->
name|activequeues
argument_list|)
expr_stmt|;
name|evmap_io_clear_
argument_list|(
operator|&
name|base
operator|->
name|io
argument_list|)
expr_stmt|;
name|evmap_signal_clear_
argument_list|(
operator|&
name|base
operator|->
name|sigmap
argument_list|)
expr_stmt|;
name|event_changelist_freemem_
argument_list|(
operator|&
name|base
operator|->
name|changelist
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_LOCK
argument_list|(
name|base
operator|->
name|th_base_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVTHREAD_FREE_COND
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|)
expr_stmt|;
comment|/* If we're freeing current_base, there won't be a current_base. */
if|if
condition|(
name|base
operator|==
name|current_base
condition|)
name|current_base
operator|=
name|NULL
expr_stmt|;
name|mm_free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_free_nofinalize
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|event_base_free_
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_free
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|event_base_free_
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fake eventop; used to disable the backend temporarily inside event_reinit  * so that we can call event_del() on an event without telling the backend.  */
end_comment

begin_function
specifier|static
name|int
name|nil_backend_del
parameter_list|(
name|struct
name|event_base
modifier|*
name|b
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|old
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|fdinfo
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|eventop
name|nil_eventop
init|=
block|{
literal|"nil"
block|,
name|NULL
block|,
comment|/* init: unused. */
name|NULL
block|,
comment|/* add: unused. */
name|nil_backend_del
block|,
comment|/* del: used, so needs to be killed. */
name|NULL
block|,
comment|/* dispatch: unused. */
name|NULL
block|,
comment|/* dealloc: unused. */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reinitialize the event base after a fork */
end_comment

begin_function
name|int
name|event_reinit
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|int
name|was_notifiable
init|=
literal|0
decl_stmt|;
name|int
name|had_signal_added
init|=
literal|0
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evsel
operator|=
name|base
operator|->
name|evsel
expr_stmt|;
comment|/* check if this event mechanism requires reinit on the backend */
if|if
condition|(
name|evsel
operator|->
name|need_reinit
condition|)
block|{
comment|/* We're going to call event_del() on our notify events (the 		 * ones that tell about signals and wakeup events).  But we 		 * don't actually want to tell the backend to change its 		 * state, since it might still share some resource (a kqueue, 		 * an epoll fd) with the parent process, and we don't want to 		 * delete the fds from _that_ backend, we temporarily stub out 		 * the evsel with a replacement. 		 */
name|base
operator|->
name|evsel
operator|=
operator|&
name|nil_eventop
expr_stmt|;
block|}
comment|/* We need to re-create a new signal-notification fd and a new 	 * thread-notification fd.  Otherwise, we'll still share those with 	 * the parent process, which would make any notification sent to them 	 * get received by one or both of the event loops, more or less at 	 * random. 	 */
if|if
condition|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_added
condition|)
block|{
name|event_del_nolock_
argument_list|(
operator|&
name|base
operator|->
name|sig
operator|.
name|ev_signal
argument_list|,
name|EVENT_DEL_AUTOBLOCK
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|base
operator|->
name|sig
operator|.
name|ev_signal
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|base
operator|->
name|sig
operator|.
name|ev_signal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|base
operator|->
name|sig
operator|.
name|ev_signal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|had_signal_added
operator|=
literal|1
expr_stmt|;
name|base
operator|->
name|sig
operator|.
name|ev_signal_added
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|th_notify_fn
operator|!=
name|NULL
condition|)
block|{
name|was_notifiable
operator|=
literal|1
expr_stmt|;
name|base
operator|->
name|th_notify_fn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|event_del_nolock_
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|,
name|EVENT_DEL_AUTOBLOCK
argument_list|)
expr_stmt|;
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
name|EVUTIL_CLOSESOCKET
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the original evsel. */
name|base
operator|->
name|evsel
operator|=
name|evsel
expr_stmt|;
if|if
condition|(
name|evsel
operator|->
name|need_reinit
condition|)
block|{
comment|/* Reconstruct the backend through brute-force, so that we do 		 * not share any structures with the parent process. For some 		 * backends, this is necessary: epoll and kqueue, for 		 * instance, have events associated with a kernel 		 * structure. If didn't reinitialize, we'd share that 		 * structure with the parent process, and any changes made by 		 * the parent would affect our backend's behavior (and vice 		 * versa). 		 */
if|if
condition|(
name|base
operator|->
name|evsel
operator|->
name|dealloc
operator|!=
name|NULL
condition|)
name|base
operator|->
name|evsel
operator|->
name|dealloc
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|->
name|evbase
operator|=
name|evsel
operator|->
name|init
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|evbase
operator|==
name|NULL
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: could not reinitialize event mechanism"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Empty out the changelist (if any): we are starting from a 		 * blank slate. */
name|event_changelist_freemem_
argument_list|(
operator|&
name|base
operator|->
name|changelist
argument_list|)
expr_stmt|;
comment|/* Tell the event maps to re-inform the backend about all 		 * pending events. This will make the signal notification 		 * event get re-created if necessary. */
if|if
condition|(
name|evmap_reinit_
argument_list|(
name|base
argument_list|)
operator|<
literal|0
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|had_signal_added
condition|)
name|res
operator|=
name|evsig_init_
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
comment|/* If we were notifiable before, and nothing just exploded, become 	 * notifiable again. */
if|if
condition|(
name|was_notifiable
operator|&&
name|res
operator|==
literal|0
condition|)
name|res
operator|=
name|evthread_make_base_notifiable_nolock_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|done
label|:
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
modifier|*
name|event_get_supported_methods
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|methods
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|eventop
modifier|*
modifier|*
name|method
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|k
decl_stmt|;
comment|/* count all methods */
for|for
control|(
name|method
operator|=
operator|&
name|eventops
index|[
literal|0
index|]
init|;
operator|*
name|method
operator|!=
name|NULL
condition|;
operator|++
name|method
control|)
block|{
operator|++
name|i
expr_stmt|;
block|}
comment|/* allocate one more than we need for the NULL pointer */
name|tmp
operator|=
name|mm_calloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* populate the array with the supported methods */
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|eventops
index|[
name|k
index|]
operator|!=
name|NULL
condition|;
operator|++
name|k
control|)
block|{
name|tmp
index|[
name|i
operator|++
index|]
operator|=
name|eventops
index|[
name|k
index|]
operator|->
name|name
expr_stmt|;
block|}
name|tmp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|methods
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|methods
argument_list|)
expr_stmt|;
name|methods
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|methods
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|event_config
modifier|*
name|event_config_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|event_config
modifier|*
name|cfg
init|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cfg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cfg
operator|->
name|entries
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|max_dispatch_interval
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|cfg
operator|->
name|max_dispatch_callbacks
operator|=
name|INT_MAX
expr_stmt|;
name|cfg
operator|->
name|limit_callbacks_after_prio
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|cfg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_config_entry_free
parameter_list|(
name|struct
name|event_config_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|avoid_method
operator|!=
name|NULL
condition|)
name|mm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entry
operator|->
name|avoid_method
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_config_free
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|event_config_entry
modifier|*
name|entry
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cfg
operator|->
name|entries
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cfg
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|event_config_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|mm_free
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_config_set_flag
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|-
literal|1
return|;
name|cfg
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|event_config_avoid_method
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
block|{
name|struct
name|event_config_entry
modifier|*
name|entry
init|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|entry
operator|->
name|avoid_method
operator|=
name|mm_strdup
argument_list|(
name|method
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mm_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cfg
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_config_require_features
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|features
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cfg
operator|->
name|require_features
operator|=
name|features
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_config_set_num_cpus_hint
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|cpus
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cfg
operator|->
name|n_cpus_hint
operator|=
name|cpus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_config_set_max_dispatch_interval
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|max_interval
parameter_list|,
name|int
name|max_callbacks
parameter_list|,
name|int
name|min_priority
parameter_list|)
block|{
if|if
condition|(
name|max_interval
condition|)
name|memcpy
argument_list|(
operator|&
name|cfg
operator|->
name|max_dispatch_interval
argument_list|,
name|max_interval
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cfg
operator|->
name|max_dispatch_interval
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|cfg
operator|->
name|max_dispatch_callbacks
operator|=
name|max_callbacks
operator|>=
literal|0
condition|?
name|max_callbacks
else|:
name|INT_MAX
expr_stmt|;
if|if
condition|(
name|min_priority
operator|<
literal|0
condition|)
name|min_priority
operator|=
literal|0
expr_stmt|;
name|cfg
operator|->
name|limit_callbacks_after_prio
operator|=
name|min_priority
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_priority_init
parameter_list|(
name|int
name|npriorities
parameter_list|)
block|{
return|return
name|event_base_priority_init
argument_list|(
name|current_base
argument_list|,
name|npriorities
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_priority_init
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|npriorities
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_ACTIVE_CALLBACKS
argument_list|(
name|base
argument_list|)
operator|||
name|npriorities
operator|<
literal|1
operator|||
name|npriorities
operator|>=
name|EVENT_MAX_PRIORITIES
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|npriorities
operator|==
name|base
operator|->
name|nactivequeues
condition|)
goto|goto
name|ok
goto|;
if|if
condition|(
name|base
operator|->
name|nactivequeues
condition|)
block|{
name|mm_free
argument_list|(
name|base
operator|->
name|activequeues
argument_list|)
expr_stmt|;
name|base
operator|->
name|nactivequeues
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate our priority queues */
name|base
operator|->
name|activequeues
operator|=
operator|(
expr|struct
name|evcallback_list
operator|*
operator|)
name|mm_calloc
argument_list|(
name|npriorities
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|evcallback_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|activequeues
operator|==
name|NULL
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|base
operator|->
name|nactivequeues
operator|=
name|npriorities
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ok
label|:
name|r
operator|=
literal|0
expr_stmt|;
name|err
label|:
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_get_npriorities
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|base
operator|->
name|nactivequeues
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_get_num_events
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_ACTIVE
condition|)
name|r
operator|+=
name|base
operator|->
name|event_count_active
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_VIRTUAL
condition|)
name|r
operator|+=
name|base
operator|->
name|virtual_event_count
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_ADDED
condition|)
name|r
operator|+=
name|base
operator|->
name|event_count
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_base_get_max_events
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
name|int
name|clear
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_ACTIVE
condition|)
block|{
name|r
operator|+=
name|base
operator|->
name|event_count_active_max
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|base
operator|->
name|event_count_active_max
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_VIRTUAL
condition|)
block|{
name|r
operator|+=
name|base
operator|->
name|virtual_event_count_max
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|base
operator|->
name|virtual_event_count_max
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|&
name|EVENT_BASE_COUNT_ADDED
condition|)
block|{
name|r
operator|+=
name|base
operator|->
name|event_count_max
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|base
operator|->
name|event_count_max
operator|=
literal|0
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff we're currently watching any events. */
end_comment

begin_function
specifier|static
name|int
name|event_haveevents
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
comment|/* Caller must hold th_base_lock */
return|return
operator|(
name|base
operator|->
name|virtual_event_count
operator|>
literal|0
operator|||
name|base
operator|->
name|event_count
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* "closure" function called when processing active signal events */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|event_signal_closure
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|short
name|ncalls
decl_stmt|;
name|int
name|should_break
decl_stmt|;
comment|/* Allows deletes to work */
name|ncalls
operator|=
name|ev
operator|->
name|ev_ncalls
expr_stmt|;
if|if
condition|(
name|ncalls
operator|!=
literal|0
condition|)
name|ev
operator|->
name|ev_pncalls
operator|=
operator|&
name|ncalls
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ncalls
condition|)
block|{
name|ncalls
operator|--
expr_stmt|;
name|ev
operator|->
name|ev_ncalls
operator|=
name|ncalls
expr_stmt|;
if|if
condition|(
name|ncalls
operator|==
literal|0
condition|)
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|ev_callback
call|)
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
operator|->
name|ev_res
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|should_break
operator|=
name|base
operator|->
name|event_break
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_break
condition|)
block|{
if|if
condition|(
name|ncalls
operator|!=
literal|0
condition|)
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Common timeouts are special timeouts that are handled as queues rather than  * in the minheap.  This is more efficient than the minheap if we happen to  * know that we're going to get several thousands of timeout events all with  * the same timeout value.  *  * Since all our timeout handling code assumes timevals can be copied,  * assigned, etc, we can't use "magic pointer" to encode these common  * timeouts.  Searching through a list to see if every timeout is common could  * also get inefficient.  Instead, we take advantage of the fact that tv_usec  * is 32 bits long, but only uses 20 of those bits (since it can never be over  * 999999.)  We use the top bits to encode 4 bites of magic number, and 8 bits  * of index into the event_base's aray of common timeouts.  */
end_comment

begin_define
define|#
directive|define
name|MICROSECONDS_MASK
value|COMMON_TIMEOUT_MICROSECONDS_MASK
end_define

begin_define
define|#
directive|define
name|COMMON_TIMEOUT_IDX_MASK
value|0x0ff00000
end_define

begin_define
define|#
directive|define
name|COMMON_TIMEOUT_IDX_SHIFT
value|20
end_define

begin_define
define|#
directive|define
name|COMMON_TIMEOUT_MASK
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|COMMON_TIMEOUT_MAGIC
value|0x50000000
end_define

begin_define
define|#
directive|define
name|COMMON_TIMEOUT_IDX
parameter_list|(
name|tv
parameter_list|)
define|\
value|(((tv)->tv_usec& COMMON_TIMEOUT_IDX_MASK)>>COMMON_TIMEOUT_IDX_SHIFT)
end_define

begin_comment
comment|/** Return true iff if 'tv' is a common timeout in 'base' */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_common_timeout
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|(
name|tv
operator|->
name|tv_usec
operator|&
name|COMMON_TIMEOUT_MASK
operator|)
operator|!=
name|COMMON_TIMEOUT_MAGIC
condition|)
return|return
literal|0
return|;
name|idx
operator|=
name|COMMON_TIMEOUT_IDX
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
name|idx
operator|<
name|base
operator|->
name|n_common_timeouts
return|;
block|}
end_function

begin_comment
comment|/* True iff tv1 and tv2 have the same common-timeout index, or if neither  * one is a common timeout. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_same_common_timeout
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv1
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv2
parameter_list|)
block|{
return|return
operator|(
name|tv1
operator|->
name|tv_usec
operator|&
operator|~
name|MICROSECONDS_MASK
operator|)
operator|==
operator|(
name|tv2
operator|->
name|tv_usec
operator|&
operator|~
name|MICROSECONDS_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Requires that 'tv' is a common timeout.  Return the corresponding  * common_timeout_list. */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|common_timeout_list
modifier|*
name|get_common_timeout_list
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|base
operator|->
name|common_timeout_queues
index|[
name|COMMON_TIMEOUT_IDX
argument_list|(
name|tv
argument_list|)
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static inline int common_timeout_ok(const struct timeval *tv,     struct event_base *base) { 	const struct timeval *expect =&get_common_timeout_list(base, tv)->duration; 	return tv->tv_sec == expect->tv_sec&& 	    tv->tv_usec == expect->tv_usec; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add the timeout for the first event in given common timeout list to the  * event_base's minheap. */
end_comment

begin_function
specifier|static
name|void
name|common_timeout_schedule
parameter_list|(
name|struct
name|common_timeout_list
modifier|*
name|ctl
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|struct
name|event
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
init|=
name|head
operator|->
name|ev_timeout
decl_stmt|;
name|timeout
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
name|event_add_nolock_
argument_list|(
operator|&
name|ctl
operator|->
name|timeout_event
argument_list|,
operator|&
name|timeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback: invoked when the timeout for a common timeout queue triggers.  * This means that (at least) the first event in that queue should be run,  * and the timeout should be rescheduled if there are more events. */
end_comment

begin_function
specifier|static
name|void
name|common_timeout_callback
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|arg
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|ctl
operator|->
name|base
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ev
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ev
operator|||
name|ev
operator|->
name|ev_timeout
operator|.
name|tv_sec
operator|>
name|now
operator|.
name|tv_sec
operator|||
operator|(
name|ev
operator|->
name|ev_timeout
operator|.
name|tv_sec
operator|==
name|now
operator|.
name|tv_sec
operator|&&
operator|(
name|ev
operator|->
name|ev_timeout
operator|.
name|tv_usec
operator|&
name|MICROSECONDS_MASK
operator|)
operator|>
name|now
operator|.
name|tv_usec
operator|)
condition|)
break|break;
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
expr_stmt|;
name|event_active_nolock_
argument_list|(
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
condition|)
name|common_timeout_schedule
argument_list|(
name|ctl
argument_list|,
operator|&
name|now
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_COMMON_TIMEOUTS
value|256
end_define

begin_function
specifier|const
name|struct
name|timeval
modifier|*
name|event_base_init_common_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|duration
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|const
name|struct
name|timeval
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|struct
name|common_timeout_list
modifier|*
name|new_ctl
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|duration
operator|->
name|tv_usec
operator|>
literal|1000000
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|tv
argument_list|,
name|duration
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_common_timeout
argument_list|(
name|duration
argument_list|,
name|base
argument_list|)
condition|)
name|tv
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|+=
name|tv
operator|.
name|tv_usec
operator|/
literal|1000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|%=
literal|1000000
expr_stmt|;
name|duration
operator|=
operator|&
name|tv
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_common_timeouts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|base
operator|->
name|common_timeout_queues
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|duration
operator|->
name|tv_sec
operator|==
name|ctl
operator|->
name|duration
operator|.
name|tv_sec
operator|&&
name|duration
operator|->
name|tv_usec
operator|==
operator|(
name|ctl
operator|->
name|duration
operator|.
name|tv_usec
operator|&
name|MICROSECONDS_MASK
operator|)
condition|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|is_common_timeout
argument_list|(
operator|&
name|ctl
operator|->
name|duration
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
operator|&
name|ctl
operator|->
name|duration
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|base
operator|->
name|n_common_timeouts
operator|==
name|MAX_COMMON_TIMEOUTS
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: Too many common timeouts already in use; "
literal|"we only support %d per event_base"
argument_list|,
name|__func__
argument_list|,
name|MAX_COMMON_TIMEOUTS
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|base
operator|->
name|n_common_timeouts_allocated
operator|==
name|base
operator|->
name|n_common_timeouts
condition|)
block|{
name|int
name|n
init|=
name|base
operator|->
name|n_common_timeouts
operator|<
literal|16
condition|?
literal|16
else|:
name|base
operator|->
name|n_common_timeouts
operator|*
literal|2
decl_stmt|;
name|struct
name|common_timeout_list
modifier|*
modifier|*
name|newqueues
init|=
name|mm_realloc
argument_list|(
name|base
operator|->
name|common_timeout_queues
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|common_timeout_queue
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newqueues
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: realloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|base
operator|->
name|n_common_timeouts_allocated
operator|=
name|n
expr_stmt|;
name|base
operator|->
name|common_timeout_queues
operator|=
name|newqueues
expr_stmt|;
block|}
name|new_ctl
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|common_timeout_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_ctl
condition|)
block|{
name|event_warn
argument_list|(
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|new_ctl
operator|->
name|events
argument_list|)
expr_stmt|;
name|new_ctl
operator|->
name|duration
operator|.
name|tv_sec
operator|=
name|duration
operator|->
name|tv_sec
expr_stmt|;
name|new_ctl
operator|->
name|duration
operator|.
name|tv_usec
operator|=
name|duration
operator|->
name|tv_usec
operator||
name|COMMON_TIMEOUT_MAGIC
operator||
operator|(
name|base
operator|->
name|n_common_timeouts
operator|<<
name|COMMON_TIMEOUT_IDX_SHIFT
operator|)
expr_stmt|;
name|evtimer_assign
argument_list|(
operator|&
name|new_ctl
operator|->
name|timeout_event
argument_list|,
name|base
argument_list|,
name|common_timeout_callback
argument_list|,
name|new_ctl
argument_list|)
expr_stmt|;
name|new_ctl
operator|->
name|timeout_event
operator|.
name|ev_flags
operator||=
name|EVLIST_INTERNAL
expr_stmt|;
name|event_priority_set
argument_list|(
operator|&
name|new_ctl
operator|->
name|timeout_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_ctl
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|base
operator|->
name|common_timeout_queues
index|[
name|base
operator|->
name|n_common_timeouts
operator|++
index|]
operator|=
name|new_ctl
expr_stmt|;
name|result
operator|=
operator|&
name|new_ctl
operator|->
name|duration
expr_stmt|;
name|done
label|:
if|if
condition|(
name|result
condition|)
name|EVUTIL_ASSERT
argument_list|(
name|is_common_timeout
argument_list|(
name|result
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Closure function invoked when we're activating a persistent event. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|event_persist_closure
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
comment|// Define our callback, we use this to store our callback before it's executed
name|void
function_decl|(
modifier|*
name|evcb_callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* reschedule the persistent event if we have a timeout. */
if|if
condition|(
name|ev
operator|->
name|ev_io_timeout
operator|.
name|tv_sec
operator|||
name|ev
operator|->
name|ev_io_timeout
operator|.
name|tv_usec
condition|)
block|{
comment|/* If there was a timeout, we want it to run at an interval of 		 * ev_io_timeout after the last time it was _scheduled_ for, 		 * not ev_io_timeout after _now_.  If it fired for another 		 * reason, though, the timeout ought to start ticking _now_. */
name|struct
name|timeval
name|run_at
decl_stmt|,
name|relative_to
decl_stmt|,
name|delay
decl_stmt|,
name|now
decl_stmt|;
name|ev_uint32_t
name|usec_mask
init|=
literal|0
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|is_same_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|ev
operator|->
name|ev_io_timeout
argument_list|)
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|base
argument_list|)
condition|)
block|{
name|delay
operator|=
name|ev
operator|->
name|ev_io_timeout
expr_stmt|;
name|usec_mask
operator|=
name|delay
operator|.
name|tv_usec
operator|&
operator|~
name|MICROSECONDS_MASK
expr_stmt|;
name|delay
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_res
operator|&
name|EV_TIMEOUT
condition|)
block|{
name|relative_to
operator|=
name|ev
operator|->
name|ev_timeout
expr_stmt|;
name|relative_to
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
block|}
else|else
block|{
name|relative_to
operator|=
name|now
expr_stmt|;
block|}
block|}
else|else
block|{
name|delay
operator|=
name|ev
operator|->
name|ev_io_timeout
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_res
operator|&
name|EV_TIMEOUT
condition|)
block|{
name|relative_to
operator|=
name|ev
operator|->
name|ev_timeout
expr_stmt|;
block|}
else|else
block|{
name|relative_to
operator|=
name|now
expr_stmt|;
block|}
block|}
name|evutil_timeradd
argument_list|(
operator|&
name|relative_to
argument_list|,
operator|&
name|delay
argument_list|,
operator|&
name|run_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|run_at
argument_list|,
operator|&
name|now
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* Looks like we missed at least one invocation due to 			 * a clock jump, not running the event loop for a 			 * while, really slow callbacks, or 			 * something. Reschedule relative to now. 			 */
name|evutil_timeradd
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|delay
argument_list|,
operator|&
name|run_at
argument_list|)
expr_stmt|;
block|}
name|run_at
operator|.
name|tv_usec
operator||=
name|usec_mask
expr_stmt|;
name|event_add_nolock_
argument_list|(
name|ev
argument_list|,
operator|&
name|run_at
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Save our callback before we release the lock
name|evcb_callback
operator|=
operator|*
name|ev
operator|->
name|ev_callback
expr_stmt|;
comment|// Release the lock
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
comment|// Execute the callback
call|(
name|evcb_callback
call|)
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
operator|->
name|ev_res
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   Helper for event_process_active to process all the events in a single queue,   releasing the lock as we go.  This function requires that the lock be held   when it's invoked.  Returns -1 if we get a signal or an event_break that   means we should stop processing any active events now.  Otherwise returns   the number of non-internal event_callbacks that we processed. */
end_comment

begin_function
specifier|static
name|int
name|event_process_active_single_queue
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|evcallback_list
modifier|*
name|activeq
parameter_list|,
name|int
name|max_to_process
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|endtime
parameter_list|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|activeq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|evcb
operator|=
name|TAILQ_FIRST
argument_list|(
name|activeq
argument_list|)
init|;
name|evcb
condition|;
name|evcb
operator|=
name|TAILQ_FIRST
argument_list|(
name|activeq
argument_list|)
control|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
condition|)
block|{
name|ev
operator|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_PERSIST
operator|||
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_FINALIZING
condition|)
name|event_queue_remove_active
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
else|else
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_process_active: event: %p, %s%s%scall %p"
operator|,
name|ev
operator|,
name|ev
operator|->
name|ev_res
operator|&
name|EV_READ
condition|?
literal|"EV_READ "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_res
operator|&
name|EV_WRITE
condition|?
literal|"EV_WRITE "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_res
operator|&
name|EV_CLOSED
condition|?
literal|"EV_CLOSED "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_queue_remove_active
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_process_active: event_callback %p, "
literal|"closure %d, call %p"
operator|,
name|evcb
operator|,
name|evcb
operator|->
name|evcb_closure
operator|,
name|evcb
operator|->
name|evcb_cb_union
operator|.
name|evcb_callback
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INTERNAL
operator|)
condition|)
operator|++
name|count
expr_stmt|;
name|base
operator|->
name|current_event
operator|=
name|evcb
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
name|base
operator|->
name|current_event_waiters
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|evcb
operator|->
name|evcb_closure
condition|)
block|{
case|case
name|EV_CLOSURE_EVENT_SIGNAL
case|:
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event_signal_closure
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CLOSURE_EVENT_PERSIST
case|:
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|event_persist_closure
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CLOSURE_EVENT
case|:
block|{
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|void
function_decl|(
modifier|*
name|evcb_callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
init|=
operator|*
name|ev
operator|->
name|ev_callback
function_decl|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evcb_callback
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
operator|->
name|ev_res
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EV_CLOSURE_CB_SELF
case|:
block|{
name|void
function_decl|(
modifier|*
name|evcb_selfcb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
init|=
name|evcb
operator|->
name|evcb_cb_union
operator|.
name|evcb_selfcb
function_decl|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evcb_selfcb
argument_list|(
name|evcb
argument_list|,
name|evcb
operator|->
name|evcb_arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EV_CLOSURE_EVENT_FINALIZE
case|:
case|case
name|EV_CLOSURE_EVENT_FINALIZE_FREE
case|:
block|{
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|void
function_decl|(
modifier|*
name|evcb_evfinalize
function_decl|)
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
init|=
name|ev
operator|->
name|ev_evcallback
operator|.
name|evcb_cb_union
operator|.
name|evcb_evfinalize
function_decl|;
name|base
operator|->
name|current_event
operator|=
name|NULL
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_FINALIZING
operator|)
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evcb_evfinalize
argument_list|(
name|ev
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
name|event_debug_note_teardown_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_closure
operator|==
name|EV_CLOSURE_EVENT_FINALIZE_FREE
condition|)
name|mm_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EV_CLOSURE_CB_FINALIZE
case|:
block|{
name|void
function_decl|(
modifier|*
name|evcb_cbfinalize
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
init|=
name|evcb
operator|->
name|evcb_cb_union
operator|.
name|evcb_cbfinalize
function_decl|;
name|base
operator|->
name|current_event
operator|=
name|NULL
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_FINALIZING
operator|)
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evcb_cbfinalize
argument_list|(
name|evcb
argument_list|,
name|evcb
operator|->
name|evcb_arg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|base
operator|->
name|current_event
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|base
operator|->
name|current_event_waiters
condition|)
block|{
name|base
operator|->
name|current_event_waiters
operator|=
literal|0
expr_stmt|;
name|EVTHREAD_COND_BROADCAST
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|base
operator|->
name|event_break
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|count
operator|>=
name|max_to_process
condition|)
return|return
name|count
return|;
if|if
condition|(
name|count
operator|&&
name|endtime
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|update_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|now
argument_list|,
name|endtime
argument_list|,
operator|>=
argument_list|)
condition|)
return|return
name|count
return|;
block|}
if|if
condition|(
name|base
operator|->
name|event_continue
condition|)
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Active events are stored in priority queues.  Lower priorities are always  * process before higher priorities.  Low priority events can starve high  * priority ones.  */
end_comment

begin_function
specifier|static
name|int
name|event_process_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
comment|/* Caller must hold th_base_lock */
name|struct
name|evcallback_list
modifier|*
name|activeq
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|timeval
modifier|*
name|endtime
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|const
name|int
name|maxcb
init|=
name|base
operator|->
name|max_dispatch_callbacks
decl_stmt|;
specifier|const
name|int
name|limit_after_prio
init|=
name|base
operator|->
name|limit_callbacks_after_prio
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|max_dispatch_time
operator|.
name|tv_sec
operator|>=
literal|0
condition|)
block|{
name|update_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|evutil_timeradd
argument_list|(
operator|&
name|base
operator|->
name|max_dispatch_time
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|endtime
operator|=
operator|&
name|tv
expr_stmt|;
block|}
else|else
block|{
name|endtime
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|base
operator|->
name|event_running_priority
operator|=
name|i
expr_stmt|;
name|activeq
operator|=
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|limit_after_prio
condition|)
name|c
operator|=
name|event_process_active_single_queue
argument_list|(
name|base
argument_list|,
name|activeq
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|event_process_active_single_queue
argument_list|(
name|base
argument_list|,
name|activeq
argument_list|,
name|maxcb
argument_list|,
name|endtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
break|break;
comment|/* Processed a real event; do not 					* consider lower-priority events */
comment|/* If we get here, all of the events we processed 			 * were internal.  Continue. */
block|}
block|}
name|done
label|:
name|base
operator|->
name|event_running_priority
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * Wait continuously for events.  We exit only if no events are left.  */
end_comment

begin_function
name|int
name|event_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|event_loop
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
return|return
operator|(
name|event_base_loop
argument_list|(
name|event_base
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|event_base_get_method
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|base
operator|->
name|evsel
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Callback: used to implement event_base_loopexit by telling the event_base  * that it's time to exit its loop. */
end_comment

begin_function
specifier|static
name|void
name|event_loopexit_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|base
operator|->
name|event_gotterm
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_loopexit
parameter_list|(
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
name|event_once
argument_list|(
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|event_loopexit_cb
argument_list|,
name|current_base
argument_list|,
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_loopexit
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
name|event_base_once
argument_list|(
name|event_base
argument_list|,
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|event_loopexit_cb
argument_list|,
name|event_base
argument_list|,
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_loopbreak
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|event_base_loopbreak
argument_list|(
name|current_base
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_loopbreak
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|event_base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_base
operator|->
name|event_break
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EVBASE_NEED_NOTIFY
argument_list|(
name|event_base
argument_list|)
condition|)
block|{
name|r
operator|=
name|evthread_notify_base
argument_list|(
name|event_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
operator|(
literal|0
operator|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_base_loopcontinue
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|event_base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_base
operator|->
name|event_continue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EVBASE_NEED_NOTIFY
argument_list|(
name|event_base
argument_list|)
condition|)
block|{
name|r
operator|=
name|evthread_notify_base
argument_list|(
name|event_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
operator|(
literal|0
operator|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_base_got_break
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|event_base
operator|->
name|event_break
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|event_base_got_exit
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|event_base
operator|->
name|event_gotterm
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|event_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* not thread safe */
end_comment

begin_function
name|int
name|event_loop
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
name|event_base_loop
argument_list|(
name|current_base
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_loop
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
init|=
name|base
operator|->
name|evsel
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv_p
decl_stmt|;
name|int
name|res
decl_stmt|,
name|done
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Grab the lock.  We will release it inside evsel.dispatch, and again 	 * as we invoke user callbacks. */
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|running_loop
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: reentrant invocation.  Only one event_base_loop"
literal|" can run on each event_base at once."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|base
operator|->
name|running_loop
operator|=
literal|1
expr_stmt|;
name|clear_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|sig
operator|.
name|ev_signal_added
operator|&&
name|base
operator|->
name|sig
operator|.
name|ev_n_signals_added
condition|)
name|evsig_set_base_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
name|base
operator|->
name|th_owner_id
operator|=
name|EVTHREAD_GET_ID
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|base
operator|->
name|event_gotterm
operator|=
name|base
operator|->
name|event_break
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|base
operator|->
name|event_continue
operator|=
literal|0
expr_stmt|;
name|base
operator|->
name|n_deferreds_queued
operator|=
literal|0
expr_stmt|;
comment|/* Terminate the loop if we have been asked to */
if|if
condition|(
name|base
operator|->
name|event_gotterm
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|base
operator|->
name|event_break
condition|)
block|{
break|break;
block|}
name|tv_p
operator|=
operator|&
name|tv
expr_stmt|;
if|if
condition|(
operator|!
name|N_ACTIVE_CALLBACKS
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|EVLOOP_NONBLOCK
operator|)
condition|)
block|{
name|timeout_next
argument_list|(
name|base
argument_list|,
operator|&
name|tv_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * if we have active events, we just poll new events 			 * without waiting. 			 */
name|evutil_timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no events, we just exit */
if|if
condition|(
literal|0
operator|==
operator|(
name|flags
operator|&
name|EVLOOP_NO_EXIT_ON_EMPTY
operator|)
operator|&&
operator|!
name|event_haveevents
argument_list|(
name|base
argument_list|)
operator|&&
operator|!
name|N_ACTIVE_CALLBACKS
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: no events registered."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|event_queue_make_later_events_active
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|clear_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|res
operator|=
name|evsel
operator|->
name|dispatch
argument_list|(
name|base
argument_list|,
name|tv_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: dispatch returned unsuccessfully."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|update_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|timeout_process
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_ACTIVE_CALLBACKS
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|int
name|n
init|=
name|event_process_active
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EVLOOP_ONCE
operator|)
operator|&&
name|N_ACTIVE_CALLBACKS
argument_list|(
name|base
argument_list|)
operator|==
literal|0
operator|&&
name|n
operator|!=
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EVLOOP_NONBLOCK
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: asked to terminate loop."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|done
label|:
name|clear_time_cache
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|base
operator|->
name|running_loop
operator|=
literal|0
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* One-time callback to implement event_base_once: invokes the user callback,  * then deletes the allocated storage */
end_comment

begin_function
specifier|static
name|void
name|event_once_cb
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_once
modifier|*
name|eonce
init|=
name|arg
decl_stmt|;
call|(
modifier|*
name|eonce
operator|->
name|cb
call|)
argument_list|(
name|fd
argument_list|,
name|events
argument_list|,
name|eonce
operator|->
name|arg
argument_list|)
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|eonce
operator|->
name|ev
operator|.
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|eonce
argument_list|,
name|next_once
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|eonce
operator|->
name|ev
operator|.
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_debug_unassign
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* not threadsafe, event scheduled once. */
end_comment

begin_function
name|int
name|event_once
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
name|event_base_once
argument_list|(
name|current_base
argument_list|,
name|fd
argument_list|,
name|events
argument_list|,
name|callback
argument_list|,
name|arg
argument_list|,
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Schedules an event once */
end_comment

begin_function
name|int
name|event_base_once
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|event_once
modifier|*
name|eonce
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|int
name|activate
init|=
literal|0
decl_stmt|;
comment|/* We cannot support signals that just fire once, or persistent 	 * events. */
if|if
condition|(
name|events
operator|&
operator|(
name|EV_SIGNAL
operator||
name|EV_PERSIST
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|eonce
operator|=
name|mm_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_once
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|eonce
operator|->
name|cb
operator|=
name|callback
expr_stmt|;
name|eonce
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|EV_TIMEOUT
operator||
name|EV_SIGNAL
operator||
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
operator|)
operator|==
name|EV_TIMEOUT
condition|)
block|{
name|evtimer_assign
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|base
argument_list|,
name|event_once_cb
argument_list|,
name|eonce
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|==
name|NULL
operator|||
operator|!
name|evutil_timerisset
argument_list|(
name|tv
argument_list|)
condition|)
block|{
comment|/* If the event is going to become active immediately, 			 * don't put it on the timeout queue.  This is one 			 * idiom for scheduling a callback, so let's make 			 * it fast (and order-preserving). */
name|activate
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
condition|)
block|{
name|events
operator|&=
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
expr_stmt|;
name|event_assign
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|base
argument_list|,
name|fd
argument_list|,
name|events
argument_list|,
name|event_once_cb
argument_list|,
name|eonce
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bad event combination */
name|mm_free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
condition|)
name|event_active_nolock_
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|event_add_nolock_
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|base
operator|->
name|once_events
argument_list|,
name|eonce
argument_list|,
name|next_once
argument_list|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_assign
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
name|arg
operator|==
operator|&
name|event_self_cbarg_ptr_
condition|)
name|arg
operator|=
name|ev
expr_stmt|;
name|event_debug_assert_not_added_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_base
operator|=
name|base
expr_stmt|;
name|ev
operator|->
name|ev_callback
operator|=
name|callback
expr_stmt|;
name|ev
operator|->
name|ev_arg
operator|=
name|arg
expr_stmt|;
name|ev
operator|->
name|ev_fd
operator|=
name|fd
expr_stmt|;
name|ev
operator|->
name|ev_events
operator|=
name|events
expr_stmt|;
name|ev
operator|->
name|ev_res
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
name|EVLIST_INIT
expr_stmt|;
name|ev
operator|->
name|ev_ncalls
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|EV_SIGNAL
condition|)
block|{
if|if
condition|(
operator|(
name|events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: EV_SIGNAL is not compatible with "
literal|"EV_READ, EV_WRITE or EV_CLOSED"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ev
operator|->
name|ev_closure
operator|=
name|EV_CLOSURE_EVENT_SIGNAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|events
operator|&
name|EV_PERSIST
condition|)
block|{
name|evutil_timerclear
argument_list|(
operator|&
name|ev
operator|->
name|ev_io_timeout
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_closure
operator|=
name|EV_CLOSURE_EVENT_PERSIST
expr_stmt|;
block|}
else|else
block|{
name|ev
operator|->
name|ev_closure
operator|=
name|EV_CLOSURE_EVENT
expr_stmt|;
block|}
block|}
name|min_heap_elem_init_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|NULL
condition|)
block|{
comment|/* by default, we put new events into the middle priority */
name|ev
operator|->
name|ev_pri
operator|=
name|base
operator|->
name|nactivequeues
operator|/
literal|2
expr_stmt|;
block|}
name|event_debug_note_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|event_base_set
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
comment|/* Only innocent events may be assigned to a different base */
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|!=
name|EVLIST_INIT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_base
operator|=
name|base
expr_stmt|;
name|ev
operator|->
name|ev_pri
operator|=
name|base
operator|->
name|nactivequeues
operator|/
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_set
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|event_assign
argument_list|(
name|ev
argument_list|,
name|current_base
argument_list|,
name|fd
argument_list|,
name|events
argument_list|,
name|callback
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|r
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|event_self_cbarg
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|event_self_cbarg_ptr_
return|;
block|}
end_function

begin_function
name|struct
name|event
modifier|*
name|event_base_get_running_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVBASE_IN_THREAD
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
init|=
name|base
operator|->
name|current_event
decl_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
condition|)
name|ev
operator|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|ev
return|;
block|}
end_function

begin_function
name|struct
name|event
modifier|*
name|event_new
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
name|mm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|event_assign
argument_list|(
name|ev
argument_list|,
name|base
argument_list|,
name|fd
argument_list|,
name|events
argument_list|,
name|cb
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mm_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_free
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
comment|/* This is disabled, so that events which have been finalized be a 	 * valid target for event_free(). That's */
comment|// event_debug_assert_is_setup_(ev);
comment|/* make sure that this event won't be coming back to haunt us. */
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_debug_note_teardown_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|mm_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_debug_unassign
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_not_added_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_debug_note_teardown_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|&=
operator|~
name|EVLIST_INIT
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|EVENT_FINALIZE_FREE_
value|0x10000
end_define

begin_function
specifier|static
name|int
name|event_finalize_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|event_finalize_callback_fn
name|cb
parameter_list|)
block|{
name|ev_uint8_t
name|closure
init|=
operator|(
name|flags
operator|&
name|EVENT_FINALIZE_FREE_
operator|)
condition|?
name|EV_CLOSURE_EVENT_FINALIZE_FREE
else|:
name|EV_CLOSURE_EVENT_FINALIZE
decl_stmt|;
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_closure
operator|=
name|closure
expr_stmt|;
name|ev
operator|->
name|ev_evcallback
operator|.
name|evcb_cb_union
operator|.
name|evcb_evfinalize
operator|=
name|cb
expr_stmt|;
name|event_active_nolock_
argument_list|(
name|ev
argument_list|,
name|EV_FINALIZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator||=
name|EVLIST_FINALIZING
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|event_finalize_impl_
parameter_list|(
name|unsigned
name|flags
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|event_finalize_callback_fn
name|cb
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|ev
operator|->
name|ev_base
decl_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
name|base
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_finalize_nolock_
argument_list|(
name|base
argument_list|,
name|flags
argument_list|,
name|ev
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_finalize
parameter_list|(
name|unsigned
name|flags
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|event_finalize_callback_fn
name|cb
parameter_list|)
block|{
return|return
name|event_finalize_impl_
argument_list|(
name|flags
argument_list|,
name|ev
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_free_finalize
parameter_list|(
name|unsigned
name|flags
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|event_finalize_callback_fn
name|cb
parameter_list|)
block|{
return|return
name|event_finalize_impl_
argument_list|(
name|flags
operator||
name|EVENT_FINALIZE_FREE_
argument_list|,
name|ev
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|event_callback_finalize_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
condition|)
block|{
name|ev
operator|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
expr_stmt|;
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|event_callback_cancel_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*XXX can this fail?*/
block|}
name|evcb
operator|->
name|evcb_closure
operator|=
name|EV_CLOSURE_CB_FINALIZE
expr_stmt|;
name|evcb
operator|->
name|evcb_cb_union
operator|.
name|evcb_cbfinalize
operator|=
name|cb
expr_stmt|;
name|event_callback_activate_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
comment|/* XXX can this really fail?*/
name|evcb
operator|->
name|evcb_flags
operator||=
name|EVLIST_FINALIZING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_callback_finalize_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_callback_finalize_nolock_
argument_list|(
name|base
argument_list|,
name|flags
argument_list|,
name|evcb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Internal: Finalize all of the n_cbs callbacks in evcbs.  The provided  * callback will be invoked on *one of them*, after they have *all* been  * finalized. */
end_comment

begin_function
name|int
name|event_callback_finalize_many_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|n_cbs
parameter_list|,
name|struct
name|event_callback
modifier|*
modifier|*
name|evcbs
parameter_list|,
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|struct
name|event_callback
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|n_pending
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"%s: %d events finalizing"
operator|,
name|__func__
operator|,
name|n_cbs
operator|)
argument_list|)
expr_stmt|;
comment|/* At most one can be currently executing; the rest we just 	 * cancel... But we always make sure that the finalize callback 	 * runs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_cbs
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
init|=
name|evcbs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|evcb
operator|==
name|base
operator|->
name|current_event
condition|)
block|{
name|event_callback_finalize_nolock_
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|evcb
argument_list|,
name|cb
argument_list|)
expr_stmt|;
operator|++
name|n_pending
expr_stmt|;
block|}
else|else
block|{
name|event_callback_cancel_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_pending
operator|==
literal|0
condition|)
block|{
comment|/* Just do the first one. */
name|event_callback_finalize_nolock_
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|evcbs
index|[
literal|0
index|]
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set's the priority of an event - if an event is already scheduled  * changing the priority is going to fail.  */
end_comment

begin_function
name|int
name|event_priority_set
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pri
operator|<
literal|0
operator|||
name|pri
operator|>=
name|ev
operator|->
name|ev_base
operator|->
name|nactivequeues
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ev
operator|->
name|ev_pri
operator|=
name|pri
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if a specific event is pending or scheduled.  */
end_comment

begin_function
name|int
name|event_pending
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|short
name|event
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
name|ev
operator|->
name|ev_base
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
name|flags
operator||=
operator|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator||
name|EV_SIGNAL
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
condition|)
name|flags
operator||=
name|ev
operator|->
name|ev_res
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
name|flags
operator||=
name|EV_TIMEOUT
expr_stmt|;
name|event
operator|&=
operator|(
name|EV_TIMEOUT
operator||
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator||
name|EV_SIGNAL
operator|)
expr_stmt|;
comment|/* See if there is a timeout that we should report */
if|if
condition|(
name|tv
operator|!=
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|event
operator|&
name|EV_TIMEOUT
operator|)
condition|)
block|{
name|struct
name|timeval
name|tmp
init|=
name|ev
operator|->
name|ev_timeout
decl_stmt|;
name|tmp
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
comment|/* correctly remamp to real time */
name|evutil_timeradd
argument_list|(
operator|&
name|ev
operator|->
name|ev_base
operator|->
name|tv_clock_diff
argument_list|,
operator|&
name|tmp
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|event
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_initialized
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INIT
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|event_get_assignment
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|event
parameter_list|,
name|struct
name|event_base
modifier|*
modifier|*
name|base_out
parameter_list|,
name|evutil_socket_t
modifier|*
name|fd_out
parameter_list|,
name|short
modifier|*
name|events_out
parameter_list|,
name|event_callback_fn
modifier|*
name|callback_out
parameter_list|,
name|void
modifier|*
modifier|*
name|arg_out
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_out
condition|)
operator|*
name|base_out
operator|=
name|event
operator|->
name|ev_base
expr_stmt|;
if|if
condition|(
name|fd_out
condition|)
operator|*
name|fd_out
operator|=
name|event
operator|->
name|ev_fd
expr_stmt|;
if|if
condition|(
name|events_out
condition|)
operator|*
name|events_out
operator|=
name|event
operator|->
name|ev_events
expr_stmt|;
if|if
condition|(
name|callback_out
condition|)
operator|*
name|callback_out
operator|=
name|event
operator|->
name|ev_callback
expr_stmt|;
if|if
condition|(
name|arg_out
condition|)
operator|*
name|arg_out
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|event_get_struct_event_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|event
argument_list|)
return|;
block|}
end_function

begin_function
name|evutil_socket_t
name|event_get_fd
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_fd
return|;
block|}
end_function

begin_function
name|struct
name|event_base
modifier|*
name|event_get_base
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_base
return|;
block|}
end_function

begin_function
name|short
name|event_get_events
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_events
return|;
block|}
end_function

begin_function
name|event_callback_fn
name|event_get_callback
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_callback
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|event_get_callback_arg
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_arg
return|;
block|}
end_function

begin_function
name|int
name|event_get_priority
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
name|ev
operator|->
name|ev_pri
return|;
block|}
end_function

begin_function
name|int
name|event_add
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
name|ev
operator|->
name|ev_base
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|event_add_nolock_
argument_list|(
name|ev
argument_list|,
name|tv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper callback: wake an event_base from another thread.  This version  * works by writing a byte to one end of a socketpair, so that the event_base  * listening on the other end will wake up as the corresponding event  * triggers */
end_comment

begin_function
specifier|static
name|int
name|evthread_notify_base_default
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|r
operator|=
name|send
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|r
operator|=
name|write
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|<
literal|0
operator|&&
operator|!
name|EVUTIL_ERR_IS_EAGAIN
argument_list|(
name|errno
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENTFD
end_ifdef

begin_comment
comment|/* Helper callback: wake an event_base from another thread.  This version  * assumes that you have a working eventfd() implementation. */
end_comment

begin_function
specifier|static
name|int
name|evthread_notify_base_eventfd
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|ev_uint64_t
name|msg
init|=
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|;
do|do
block|{
name|r
operator|=
name|write
argument_list|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
do|;
return|return
operator|(
name|r
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** Tell the thread currently running the event_loop for base (if any) that it  * needs to stop waiting in its dispatch function (if it is) and process all  * active callbacks. */
end_comment

begin_function
specifier|static
name|int
name|evthread_notify_base
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|th_notify_fn
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|base
operator|->
name|is_notify_pending
condition|)
return|return
literal|0
return|;
name|base
operator|->
name|is_notify_pending
operator|=
literal|1
expr_stmt|;
return|return
name|base
operator|->
name|th_notify_fn
argument_list|(
name|base
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implementation function to remove a timeout on a currently pending event.  */
end_comment

begin_function
name|int
name|event_remove_timer_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|ev
operator|->
name|ev_base
decl_stmt|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_remove_timer_nolock: event: %p"
operator|,
name|ev
operator|)
argument_list|)
expr_stmt|;
comment|/* If it's not pending on a timeout, we don't need to do anything. */
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
block|{
name|event_queue_remove_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|evutil_timerclear
argument_list|(
operator|&
name|ev
operator|->
name|ev_
operator|.
name|ev_io
operator|.
name|ev_timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_remove_timer
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
name|ev
operator|->
name|ev_base
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|event_remove_timer_nolock_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Implementation function to add an event.  Works just like event_add,  * except: 1) it requires that we have the lock.  2) if tv_is_absolute is set,  * we treat tv as an absolute time, not as an interval to add to the current  * time */
end_comment

begin_function
name|int
name|event_add_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|tv
parameter_list|,
name|int
name|tv_is_absolute
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|ev
operator|->
name|ev_base
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|int
name|notify
init|=
literal|0
decl_stmt|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_add: event: %p (fd "
name|EV_SOCK_FMT
literal|"), %s%s%s%scall %p"
operator|,
name|ev
operator|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
operator|,
name|ev
operator|->
name|ev_events
operator|&
name|EV_READ
condition|?
literal|"EV_READ "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_events
operator|&
name|EV_WRITE
condition|?
literal|"EV_WRITE "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_events
operator|&
name|EV_CLOSED
condition|?
literal|"EV_CLOSED "
else|:
literal|" "
operator|,
name|tv
condition|?
literal|"EV_TIMEOUT "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|~
name|EVLIST_ALL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_FINALIZING
condition|)
block|{
comment|/* XXXX debug */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * prepare for timeout insertion further below, if we get a 	 * failure on any step, we should not change any state. 	 */
if|if
condition|(
name|tv
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|min_heap_reserve_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
literal|1
operator|+
name|min_heap_size_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* ENOMEM == errno */
block|}
comment|/* If the main thread is currently executing a signal event's 	 * callback, and we are not the main thread, then we want to wait 	 * until the callback is done before we mess with the event, or else 	 * we can race on ev_ncalls and ev_pncalls below. */
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|base
operator|->
name|current_event
operator|==
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
operator|&&
operator|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
operator|)
operator|&&
operator|!
name|EVBASE_IN_THREAD
argument_list|(
name|base
argument_list|)
condition|)
block|{
operator|++
name|base
operator|->
name|current_event_waiters
expr_stmt|;
name|EVTHREAD_COND_WAIT
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|,
name|base
operator|->
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator||
name|EV_SIGNAL
operator|)
operator|)
operator|&&
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_INSERTED
operator||
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
condition|)
name|res
operator|=
name|evmap_io_add_
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
condition|)
name|res
operator|=
name|evmap_signal_add_
argument_list|(
name|base
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
name|event_queue_insert_inserted
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
comment|/* evmap says we need to notify the main thread. */
name|notify
operator|=
literal|1
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * we should change the timeout state only if the previous event 	 * addition succeeded. 	 */
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
operator|&&
name|tv
operator|!=
name|NULL
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|common_timeout
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_REINSERT_TIMEOUT
name|int
name|was_common
decl_stmt|;
name|int
name|old_timeout_idx
decl_stmt|;
endif|#
directive|endif
comment|/* 		 * for persistent timeout events, we remember the 		 * timeout value and re-add the event. 		 * 		 * If tv_is_absolute, this was already set. 		 */
if|if
condition|(
name|ev
operator|->
name|ev_closure
operator|==
name|EV_CLOSURE_EVENT_PERSIST
operator|&&
operator|!
name|tv_is_absolute
condition|)
name|ev
operator|->
name|ev_io_timeout
operator|=
operator|*
name|tv
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_REINSERT_TIMEOUT
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
block|{
name|event_queue_remove_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check if it is active due to a timeout.  Rescheduling 		 * this timeout before the callback can be executed 		 * removes it from the active list. */
if|if
condition|(
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
operator|)
operator|&&
operator|(
name|ev
operator|->
name|ev_res
operator|&
name|EV_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
condition|)
block|{
comment|/* See if we are just active executing 				 * this event in a loop 				 */
if|if
condition|(
name|ev
operator|->
name|ev_ncalls
operator|&&
name|ev
operator|->
name|ev_pncalls
condition|)
block|{
comment|/* Abort loop */
operator|*
name|ev
operator|->
name|ev_pncalls
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|event_queue_remove_active
argument_list|(
name|base
argument_list|,
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|common_timeout
operator|=
name|is_common_timeout
argument_list|(
name|tv
argument_list|,
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_REINSERT_TIMEOUT
name|was_common
operator|=
name|is_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|old_timeout_idx
operator|=
name|COMMON_TIMEOUT_IDX
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tv_is_absolute
condition|)
block|{
name|ev
operator|->
name|ev_timeout
operator|=
operator|*
name|tv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|common_timeout
condition|)
block|{
name|struct
name|timeval
name|tmp
init|=
operator|*
name|tv
decl_stmt|;
name|tmp
operator|.
name|tv_usec
operator|&=
name|MICROSECONDS_MASK
expr_stmt|;
name|evutil_timeradd
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_timeout
operator|.
name|tv_usec
operator||=
operator|(
name|tv
operator|->
name|tv_usec
operator|&
operator|~
name|MICROSECONDS_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|evutil_timeradd
argument_list|(
operator|&
name|now
argument_list|,
name|tv
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"event_add: event %p, timeout in %d seconds %d useconds, call %p"
operator|,
name|ev
operator|,
operator|(
name|int
operator|)
name|tv
operator|->
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|tv
operator|->
name|tv_usec
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_REINSERT_TIMEOUT
name|event_queue_reinsert_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|was_common
argument_list|,
name|common_timeout
argument_list|,
name|old_timeout_idx
argument_list|)
expr_stmt|;
else|#
directive|else
name|event_queue_insert_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|common_timeout
condition|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|get_common_timeout_list
argument_list|(
name|base
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|ev
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|)
condition|)
block|{
name|common_timeout_schedule
argument_list|(
name|ctl
argument_list|,
operator|&
name|now
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|event
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
comment|/* See if the earliest timeout is now earlier than it 			 * was before: if so, we will need to tell the main 			 * thread to wake up earlier than it would otherwise. 			 * We double check the timeout of the top element to 			 * handle time distortions due to system suspension. 			 */
if|if
condition|(
name|min_heap_elt_is_top_
argument_list|(
name|ev
argument_list|)
condition|)
name|notify
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|top
operator|=
name|min_heap_top_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|evutil_timercmp
argument_list|(
operator|&
name|top
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|<
argument_list|)
condition|)
name|notify
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if we are not in the right thread, we need to wake up the loop */
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
operator|&&
name|notify
operator|&&
name|EVBASE_NEED_NOTIFY
argument_list|(
name|base
argument_list|)
condition|)
name|evthread_notify_base
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_debug_note_add_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|event_del_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|blocking
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
name|ev
operator|->
name|ev_base
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|res
operator|=
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_del
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|event_del_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_AUTOBLOCK
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_del_block
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|event_del_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_BLOCK
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_del_noblock
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
return|return
name|event_del_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Helper for event_del: always called with th_base_lock held.  *  * "blocking" must be one of the EVENT_DEL_{BLOCK, NOBLOCK, AUTOBLOCK,  * EVEN_IF_FINALIZING} values. See those for more information.  */
end_comment

begin_function
name|int
name|event_del_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|blocking
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|,
name|notify
init|=
literal|0
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_del: %p (fd "
name|EV_SOCK_FMT
literal|"), callback %p"
operator|,
name|ev
operator|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
comment|/* An event without a base has not been added */
if|if
condition|(
name|ev
operator|->
name|ev_base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocking
operator|!=
name|EVENT_DEL_EVEN_IF_FINALIZING
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_FINALIZING
condition|)
block|{
comment|/* XXXX Debug */
return|return
literal|0
return|;
block|}
block|}
comment|/* If the main thread is currently executing this event's callback, 	 * and we are not the main thread, then we want to wait until the 	 * callback is done before we start removing the event.  That way, 	 * when this function returns, it will be safe to free the 	 * user-supplied argument. */
name|base
operator|=
name|ev
operator|->
name|ev_base
expr_stmt|;
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|blocking
operator|!=
name|EVENT_DEL_NOBLOCK
operator|&&
name|base
operator|->
name|current_event
operator|==
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
operator|&&
operator|!
name|EVBASE_IN_THREAD
argument_list|(
name|base
argument_list|)
operator|&&
operator|(
name|blocking
operator|==
name|EVENT_DEL_BLOCK
operator|||
operator|!
operator|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_FINALIZE
operator|)
operator|)
condition|)
block|{
operator|++
name|base
operator|->
name|current_event_waiters
expr_stmt|;
name|EVTHREAD_COND_WAIT
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|,
name|base
operator|->
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|EVUTIL_ASSERT
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|~
name|EVLIST_ALL
operator|)
argument_list|)
expr_stmt|;
comment|/* See if we are just active executing this event in a loop */
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_ncalls
operator|&&
name|ev
operator|->
name|ev_pncalls
condition|)
block|{
comment|/* Abort loop */
operator|*
name|ev
operator|->
name|ev_pncalls
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
block|{
comment|/* NOTE: We never need to notify the main thread because of a 		 * deleted timeout event: all that could happen if we don't is 		 * that the dispatch loop might wake up too early.  But the 		 * point of notifying the main thread _is_ to wake up the 		 * dispatch loop early anyway, so we wouldn't gain anything by 		 * doing it. 		 */
name|event_queue_remove_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
name|event_queue_remove_active
argument_list|(
name|base
argument_list|,
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE_LATER
condition|)
name|event_queue_remove_active_later
argument_list|(
name|base
argument_list|,
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
block|{
name|event_queue_remove_inserted
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
condition|)
name|res
operator|=
name|evmap_io_del_
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|evmap_signal_del_
argument_list|(
name|base
argument_list|,
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
comment|/* evmap says we need to notify the main thread. */
name|notify
operator|=
literal|1
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* if we are not in the right thread, we need to wake up the loop */
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
operator|&&
name|notify
operator|&&
name|EVBASE_NEED_NOTIFY
argument_list|(
name|base
argument_list|)
condition|)
name|evthread_notify_base
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|event_debug_note_del_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_active
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|,
name|short
name|ncalls
parameter_list|)
block|{
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
name|ev
operator|->
name|ev_base
argument_list|)
condition|)
block|{
name|event_warnx
argument_list|(
literal|"%s: event has no event_base set."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_debug_assert_is_setup_
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_active_nolock_
argument_list|(
name|ev
argument_list|,
name|res
argument_list|,
name|ncalls
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_active_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|,
name|short
name|ncalls
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_active: %p (fd "
name|EV_SOCK_FMT
literal|"), res %d, callback %p"
operator|,
name|ev
operator|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
operator|,
operator|(
name|int
operator|)
name|res
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|ev
operator|->
name|ev_base
expr_stmt|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_FINALIZING
condition|)
block|{
comment|/* XXXX debug */
return|return;
block|}
switch|switch
condition|(
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
condition|)
block|{
default|default:
case|case
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
case|:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_ACTIVE
case|:
comment|/* We get different kinds of events, add them together */
name|ev
operator|->
name|ev_res
operator||=
name|res
expr_stmt|;
return|return;
case|case
name|EVLIST_ACTIVE_LATER
case|:
name|ev
operator|->
name|ev_res
operator||=
name|res
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ev
operator|->
name|ev_res
operator|=
name|res
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ev
operator|->
name|ev_pri
operator|<
name|base
operator|->
name|event_running_priority
condition|)
name|base
operator|->
name|event_continue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
condition|)
block|{
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
if|if
condition|(
name|base
operator|->
name|current_event
operator|==
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
operator|&&
operator|!
name|EVBASE_IN_THREAD
argument_list|(
name|base
argument_list|)
condition|)
block|{
operator|++
name|base
operator|->
name|current_event_waiters
expr_stmt|;
name|EVTHREAD_COND_WAIT
argument_list|(
name|base
operator|->
name|current_event_cond
argument_list|,
name|base
operator|->
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ev
operator|->
name|ev_ncalls
operator|=
name|ncalls
expr_stmt|;
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
block|}
name|event_callback_activate_nolock_
argument_list|(
name|base
argument_list|,
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_active_later_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_active_later_nolock_
argument_list|(
name|ev
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_active_later_nolock_
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|ev
operator|->
name|ev_base
decl_stmt|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
condition|)
block|{
comment|/* We get different kinds of events, add them together */
name|ev
operator|->
name|ev_res
operator||=
name|res
expr_stmt|;
return|return;
block|}
name|ev
operator|->
name|ev_res
operator|=
name|res
expr_stmt|;
name|event_callback_activate_later_nolock_
argument_list|(
name|base
argument_list|,
name|event_to_event_callback
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_callback_activate_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_callback_activate_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_callback_activate_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_FINALIZING
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
condition|)
block|{
default|default:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|EVLIST_ACTIVE_LATER
case|:
name|event_queue_remove_active_later
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EVLIST_ACTIVE
case|:
return|return
literal|0
return|;
case|case
literal|0
case|:
break|break;
block|}
name|event_queue_insert_active
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVBASE_NEED_NOTIFY
argument_list|(
name|base
argument_list|)
condition|)
name|evthread_notify_base
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|event_callback_activate_later_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
condition|)
return|return;
name|event_queue_insert_active_later
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVBASE_NEED_NOTIFY
argument_list|(
name|base
argument_list|)
condition|)
name|evthread_notify_base
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_callback_init_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|)
block|{
name|memset
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|evcb_pri
operator|=
name|base
operator|->
name|nactivequeues
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_callback_cancel_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_callback_cancel_nolock_
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|event_callback_cancel_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|,
name|int
name|even_if_finalizing
parameter_list|)
block|{
if|if
condition|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_FINALIZING
operator|)
operator|&&
operator|!
name|even_if_finalizing
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_INIT
condition|)
return|return
name|event_del_nolock_
argument_list|(
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
argument_list|,
name|even_if_finalizing
condition|?
name|EVENT_DEL_EVEN_IF_FINALIZING
else|:
name|EVENT_DEL_AUTOBLOCK
argument_list|)
return|;
switch|switch
condition|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
condition|)
block|{
default|default:
case|case
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
case|:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_ACTIVE
case|:
comment|/* We get different kinds of events, add them together */
name|event_queue_remove_active
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|EVLIST_ACTIVE_LATER
case|:
name|event_queue_remove_active_later
argument_list|(
name|base
argument_list|,
name|evcb
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|event_deferred_cb_init_
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|ev_uint8_t
name|priority
parameter_list|,
name|deferred_cb_fn
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|memset
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|evcb_cb_union
operator|.
name|evcb_selfcb
operator|=
name|fn
expr_stmt|;
name|cb
operator|->
name|evcb_arg
operator|=
name|arg
expr_stmt|;
name|cb
operator|->
name|evcb_pri
operator|=
name|priority
expr_stmt|;
name|cb
operator|->
name|evcb_closure
operator|=
name|EV_CLOSURE_CB_SELF
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_deferred_cb_set_priority_
parameter_list|(
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|,
name|ev_uint8_t
name|priority
parameter_list|)
block|{
name|cb
operator|->
name|evcb_pri
operator|=
name|priority
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_deferred_cb_cancel_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
name|event_callback_cancel_
argument_list|(
name|base
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_DEFERREDS_QUEUED
value|32
end_define

begin_function
name|int
name|event_deferred_cb_schedule_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|r
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|n_deferreds_queued
operator|>
name|MAX_DEFERREDS_QUEUED
condition|)
block|{
name|event_callback_activate_later_nolock_
argument_list|(
name|base
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|base
operator|->
name|n_deferreds_queued
expr_stmt|;
name|r
operator|=
name|event_callback_activate_nolock_
argument_list|(
name|base
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timeout_next
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
modifier|*
name|tv_p
parameter_list|)
block|{
comment|/* Caller must hold th_base_lock */
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|*
name|tv_p
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|ev
operator|=
name|min_heap_top_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
block|{
comment|/* if no time-based events are active wait for I/O */
operator|*
name|tv_p
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|evutil_timerclear
argument_list|(
name|tv
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|evutil_timersub
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|tv
operator|->
name|tv_sec
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|tv
operator|->
name|tv_usec
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"timeout_next: event: %p, in %d seconds, %d useconds"
operator|,
name|ev
operator|,
operator|(
name|int
operator|)
name|tv
operator|->
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|tv
operator|->
name|tv_usec
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Activate every event whose timeout has elapsed. */
end_comment

begin_function
specifier|static
name|void
name|timeout_process
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
comment|/* Caller must hold lock. */
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
if|if
condition|(
name|min_heap_empty_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
condition|)
block|{
return|return;
block|}
name|gettime
argument_list|(
name|base
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ev
operator|=
name|min_heap_top_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
break|break;
comment|/* delete this event from the I/O queues */
name|event_del_nolock_
argument_list|(
name|ev
argument_list|,
name|EVENT_DEL_NOBLOCK
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"timeout_process: event: %p, call %p"
operator|,
name|ev
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|event_active_nolock_
argument_list|(
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|EVLIST_INTERNAL
operator|>
name|>
literal|4
operator|)
operator|!=
literal|1
end_if

begin_error
error|#
directive|error
literal|"Mismatch for value of EVLIST_INTERNAL"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_EVENT_COUNT
parameter_list|(
name|var
parameter_list|,
name|v
parameter_list|)
value|var = MAX(var, v)
end_define

begin_comment
comment|/* These are a fancy way to spell      if (flags& EVLIST_INTERNAL)          base->event_count--/++; */
end_comment

begin_define
define|#
directive|define
name|DECR_EVENT_COUNT
parameter_list|(
name|base
parameter_list|,
name|flags
parameter_list|)
define|\
value|((base)->event_count -= (~((flags)>> 4)& 1))
end_define

begin_define
define|#
directive|define
name|INCR_EVENT_COUNT
parameter_list|(
name|base
parameter_list|,
name|flags
parameter_list|)
value|do {					\ 	((base)->event_count += (~((flags)>> 4)& 1));				\ 	MAX_EVENT_COUNT((base)->event_count_max, (base)->event_count);		\ } while (0)
end_define

begin_function
specifier|static
name|void
name|event_queue_remove_inserted
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
operator|)
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd "
name|EV_SOCK_FMT
literal|") not on queue %x"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
argument_list|,
name|EVLIST_INSERTED
argument_list|)
expr_stmt|;
return|return;
block|}
name|DECR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_flags
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|&=
operator|~
name|EVLIST_INSERTED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_remove_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_ACTIVE
operator|)
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p not on queue %x"
argument_list|,
name|__func__
argument_list|,
name|evcb
argument_list|,
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
return|return;
block|}
name|DECR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|evcb
operator|->
name|evcb_flags
argument_list|)
expr_stmt|;
name|evcb
operator|->
name|evcb_flags
operator|&=
operator|~
name|EVLIST_ACTIVE
expr_stmt|;
name|base
operator|->
name|event_count_active
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|evcb
operator|->
name|evcb_pri
index|]
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_remove_active_later
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_ACTIVE_LATER
operator|)
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p not on queue %x"
argument_list|,
name|__func__
argument_list|,
name|evcb
argument_list|,
name|EVLIST_ACTIVE_LATER
argument_list|)
expr_stmt|;
return|return;
block|}
name|DECR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|evcb
operator|->
name|evcb_flags
argument_list|)
expr_stmt|;
name|evcb
operator|->
name|evcb_flags
operator|&=
operator|~
name|EVLIST_ACTIVE_LATER
expr_stmt|;
name|base
operator|->
name|event_count_active
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_remove_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
operator|)
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd "
name|EV_SOCK_FMT
literal|") not on queue %x"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
argument_list|,
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|DECR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_flags
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|&=
operator|~
name|EVLIST_TIMEOUT
expr_stmt|;
if|if
condition|(
name|is_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|base
argument_list|)
condition|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|get_common_timeout_list
argument_list|(
name|base
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_heap_erase_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_REINSERT_TIMEOUT
end_ifdef

begin_comment
comment|/* Remove and reinsert 'ev' into the timeout queue. */
end_comment

begin_function
specifier|static
name|void
name|event_queue_reinsert_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|was_common
parameter_list|,
name|int
name|is_common
parameter_list|,
name|int
name|old_timeout_idx
parameter_list|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
operator|)
condition|)
block|{
name|event_queue_insert_timeout
argument_list|(
name|base
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|(
name|was_common
operator|<<
literal|1
operator|)
operator||
name|is_common
condition|)
block|{
case|case
literal|3
case|:
comment|/* Changing from one common timeout to another */
name|ctl
operator|=
name|base
operator|->
name|common_timeout_queues
index|[
name|old_timeout_idx
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|get_common_timeout_list
argument_list|(
name|base
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
name|insert_common_timeout_inorder
argument_list|(
name|ctl
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Was common; is no longer common */
name|ctl
operator|=
name|base
operator|->
name|common_timeout_queues
index|[
name|old_timeout_idx
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
name|min_heap_push_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Wasn't common; has become common. */
name|min_heap_erase_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|get_common_timeout_list
argument_list|(
name|base
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
name|insert_common_timeout_inorder
argument_list|(
name|ctl
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* was in heap; is still on heap. */
name|min_heap_adjust_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EVUTIL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* unreachable */
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add 'ev' to the common timeout list in 'ev'. */
end_comment

begin_function
specifier|static
name|void
name|insert_common_timeout_inorder
parameter_list|(
name|struct
name|common_timeout_list
modifier|*
name|ctl
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|e
decl_stmt|;
comment|/* By all logic, we should just be able to append 'ev' to the end of 	 * ctl->events, since the timeout on each 'ev' is set to {the common 	 * timeout} + {the time when we add the event}, and so the events 	 * should arrive in order of their timeeouts.  But just in case 	 * there's some wacky threading issue going on, we do a search from 	 * the end of 'ev' to find the right insertion point. 	 */
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|e
argument_list|,
argument|&ctl->events
argument_list|,
argument|event_list
argument_list|,
argument|ev_timeout_pos.ev_next_with_common_timeout
argument_list|)
block|{
comment|/* This timercmp is a little sneaky, since both ev and e have 		 * magic values in tv_usec.  Fortunately, they ought to have 		 * the _same_ magic values in tv_usec.  Let's assert for that. 		 */
name|EVUTIL_ASSERT
argument_list|(
name|is_same_common_timeout
argument_list|(
operator|&
name|e
operator|->
name|ev_timeout
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|evutil_timercmp
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|e
operator|->
name|ev_timeout
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|e
argument_list|,
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|ev
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_insert_inserted
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd "
name|EV_SOCK_FMT
literal|") already inserted"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|INCR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_flags
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator||=
name|EVLIST_INSERTED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_insert_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
name|EVLIST_ACTIVE
condition|)
block|{
comment|/* Double insertion is possible for active events */
return|return;
block|}
name|INCR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|evcb
operator|->
name|evcb_flags
argument_list|)
expr_stmt|;
name|evcb
operator|->
name|evcb_flags
operator||=
name|EVLIST_ACTIVE
expr_stmt|;
name|base
operator|->
name|event_count_active
operator|++
expr_stmt|;
name|MAX_EVENT_COUNT
argument_list|(
name|base
operator|->
name|event_count_active_max
argument_list|,
name|base
operator|->
name|event_count_active
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcb
operator|->
name|evcb_pri
operator|<
name|base
operator|->
name|nactivequeues
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|evcb
operator|->
name|evcb_pri
index|]
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_insert_active_later
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event_callback
modifier|*
name|evcb
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE_LATER
operator||
name|EVLIST_ACTIVE
operator|)
condition|)
block|{
comment|/* Double insertion is possible */
return|return;
block|}
name|INCR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|evcb
operator|->
name|evcb_flags
argument_list|)
expr_stmt|;
name|evcb
operator|->
name|evcb_flags
operator||=
name|EVLIST_ACTIVE_LATER
expr_stmt|;
name|base
operator|->
name|event_count_active
operator|++
expr_stmt|;
name|MAX_EVENT_COUNT
argument_list|(
name|base
operator|->
name|event_count_active_max
argument_list|,
name|base
operator|->
name|event_count_active
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcb
operator|->
name|evcb_pri
operator|<
name|base
operator|->
name|nactivequeues
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_insert_timeout
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVUTIL_FAILURE_CHECK
argument_list|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
argument_list|)
condition|)
block|{
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd "
name|EV_SOCK_FMT
literal|") already on timeout"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|ev
operator|->
name|ev_fd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|INCR_EVENT_COUNT
argument_list|(
name|base
argument_list|,
name|ev
operator|->
name|ev_flags
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator||=
name|EVLIST_TIMEOUT
expr_stmt|;
if|if
condition|(
name|is_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|base
argument_list|)
condition|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|get_common_timeout_list
argument_list|(
name|base
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
decl_stmt|;
name|insert_common_timeout_inorder
argument_list|(
name|ctl
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_heap_push_
argument_list|(
operator|&
name|base
operator|->
name|timeheap
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|event_queue_make_later_events_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
name|EVENT_BASE_ASSERT_LOCKED
argument_list|(
name|base
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|evcb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|active_later_queue
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
name|evcb
operator|->
name|evcb_flags
operator|=
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|~
name|EVLIST_ACTIVE_LATER
operator|)
operator||
name|EVLIST_ACTIVE
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcb
operator|->
name|evcb_pri
operator|<
name|base
operator|->
name|nactivequeues
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|evcb
operator|->
name|evcb_pri
index|]
argument_list|,
name|evcb
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
name|base
operator|->
name|n_deferreds_queued
operator|+=
operator|(
name|evcb
operator|->
name|evcb_closure
operator|==
name|EV_CLOSURE_CB_SELF
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions for debugging */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|event_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|EVENT__VERSION
operator|)
return|;
block|}
end_function

begin_function
name|ev_uint32_t
name|event_get_version_number
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|EVENT__NUMERIC_VERSION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * No thread-safe interface needed - the information should be the same  * for all threads.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|event_get_method
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|current_base
operator|->
name|evsel
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_MM_REPLACEMENT
end_ifndef

begin_function_decl
specifier|static
name|void
modifier|*
function_decl|(
modifier|*
name|mm_malloc_fn_
function_decl|)
parameter_list|(
name|size_t
name|sz
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
function_decl|(
modifier|*
name|mm_realloc_fn_
function_decl|)
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|mm_free_fn_
function_decl|)
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|event_mm_malloc_
parameter_list|(
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mm_malloc_fn_
condition|)
return|return
name|mm_malloc_fn_
argument_list|(
name|sz
argument_list|)
return|;
else|else
return|return
name|malloc
argument_list|(
name|sz
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|event_mm_calloc_
parameter_list|(
name|size_t
name|count
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mm_malloc_fn_
condition|)
block|{
name|size_t
name|sz
init|=
name|count
operator|*
name|size
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|>
name|EV_SIZE_MAX
operator|/
name|size
condition|)
goto|goto
name|error
goto|;
name|p
operator|=
name|mm_malloc_fn_
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
return|;
block|}
else|else
block|{
name|void
modifier|*
name|p
init|=
name|calloc
argument_list|(
name|count
argument_list|,
name|size
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
comment|/* Windows calloc doesn't reliably set ENOMEM */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
endif|#
directive|endif
return|return
name|p
return|;
block|}
name|error
label|:
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|event_mm_strdup_
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mm_malloc_fn_
condition|)
block|{
name|size_t
name|ln
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ln
operator|==
name|EV_SIZE_MAX
condition|)
goto|goto
name|error
goto|;
name|p
operator|=
name|mm_malloc_fn_
argument_list|(
name|ln
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|memcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|,
name|ln
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|_strdup
argument_list|(
name|str
argument_list|)
return|;
else|#
directive|else
return|return
name|strdup
argument_list|(
name|str
argument_list|)
return|;
endif|#
directive|endif
name|error
label|:
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|event_mm_realloc_
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|mm_realloc_fn_
condition|)
return|return
name|mm_realloc_fn_
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
return|;
else|else
return|return
name|realloc
argument_list|(
name|ptr
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|event_mm_free_
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|mm_free_fn_
condition|)
name|mm_free_fn_
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_set_mem_functions
parameter_list|(
name|void
modifier|*
function_decl|(
modifier|*
name|malloc_fn
function_decl|)
parameter_list|(
name|size_t
name|sz
parameter_list|)
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|realloc_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
parameter_list|)
block|{
name|mm_malloc_fn_
operator|=
name|malloc_fn
expr_stmt|;
name|mm_realloc_fn_
operator|=
name|realloc_fn
expr_stmt|;
name|mm_free_fn_
operator|=
name|free_fn
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENTFD
end_ifdef

begin_function
specifier|static
name|void
name|evthread_notify_drain_eventfd
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ev_uint64_t
name|msg
decl_stmt|;
name|ev_ssize_t
name|r
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|event_sock_warn
argument_list|(
name|fd
argument_list|,
literal|"Error reading from eventfd"
argument_list|)
expr_stmt|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|base
operator|->
name|is_notify_pending
operator|=
literal|0
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|evthread_notify_drain_default
parameter_list|(
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
while|while
condition|(
name|recv
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
else|#
directive|else
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|base
operator|->
name|is_notify_pending
operator|=
literal|0
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evthread_make_base_notifiable
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
operator|-
literal|1
return|;
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|evthread_make_base_notifiable_nolock_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|evthread_make_base_notifiable_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|notify
function_decl|)
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
if|if
condition|(
name|base
operator|->
name|th_notify_fn
operator|!=
name|NULL
condition|)
block|{
comment|/* The base is already notifiable: we're doing fine. */
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|EVENT__HAVE_WORKING_KQUEUE
argument_list|)
if|if
condition|(
name|base
operator|->
name|evsel
operator|==
operator|&
name|kqops
operator|&&
name|event_kq_add_notify_event_
argument_list|(
name|base
argument_list|)
operator|==
literal|0
condition|)
block|{
name|base
operator|->
name|th_notify_fn
operator|=
name|event_kq_notify_base_
expr_stmt|;
comment|/* No need to add an event here; the backend can wake 		 * itself up just fine. */
return|return
literal|0
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_EVENTFD
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|=
name|evutil_eventfd_
argument_list|(
literal|0
argument_list|,
name|EVUTIL_EFD_CLOEXEC
operator||
name|EVUTIL_EFD_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|base
operator|->
name|th_notify_fd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|notify
operator|=
name|evthread_notify_base_eventfd
expr_stmt|;
name|cb
operator|=
name|evthread_notify_drain_eventfd
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|evutil_make_internal_pipe_
argument_list|(
name|base
operator|->
name|th_notify_fd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notify
operator|=
name|evthread_notify_base_default
expr_stmt|;
name|cb
operator|=
name|evthread_notify_drain_default
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
name|base
operator|->
name|th_notify_fn
operator|=
name|notify
expr_stmt|;
comment|/* prepare an event that we can use for wakeup */
name|event_assign
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|,
name|base
argument_list|,
name|base
operator|->
name|th_notify_fd
index|[
literal|0
index|]
argument_list|,
name|EV_READ
operator||
name|EV_PERSIST
argument_list|,
name|cb
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* we need to mark this as internal event */
name|base
operator|->
name|th_notify
operator|.
name|ev_flags
operator||=
name|EVLIST_INTERNAL
expr_stmt|;
name|event_priority_set
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|event_add_nolock_
argument_list|(
operator|&
name|base
operator|->
name|th_notify
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_foreach_event_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|event_base_foreach_event_cb
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
comment|/* Start out with all the EVLIST_INSERTED events. */
if|if
condition|(
operator|(
name|r
operator|=
name|evmap_foreach_event_
argument_list|(
name|base
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
comment|/* Okay, now we deal with those events that have timeouts and are in 	 * the min-heap. */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|base
operator|->
name|timeheap
operator|.
name|n
condition|;
operator|++
name|u
control|)
block|{
name|ev
operator|=
name|base
operator|->
name|timeheap
operator|.
name|p
index|[
name|u
index|]
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
block|{
comment|/* we already processed this one */
continue|continue;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|fn
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
block|}
comment|/* Now for the events in one of the timeout queues. 	 * the min-heap. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_common_timeouts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|base
operator|->
name|common_timeout_queues
index|[
name|i
index|]
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ev
argument_list|,
argument|&ctl->events
argument_list|,
argument|ev_timeout_pos.ev_next_with_common_timeout
argument_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
block|{
comment|/* we already processed this one */
continue|continue;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|fn
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
block|}
block|}
comment|/* Finally, we deal wit all the active events that we haven't touched 	 * yet. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|evcb
argument_list|,
argument|&base->activequeues[i]
argument_list|,
argument|evcb_active_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_INIT
operator||
name|EVLIST_INSERTED
operator||
name|EVLIST_TIMEOUT
operator|)
operator|)
operator|!=
name|EVLIST_INIT
condition|)
block|{
comment|/* This isn't an event (evlist_init clear), or 				 * we already processed it. (inserted or 				 * timeout set */
continue|continue;
block|}
name|ev
operator|=
name|event_callback_to_event
argument_list|(
name|evcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|fn
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|arg
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper for event_base_dump_events: called on each event in the event base;  * dumps only the inserted events. */
end_comment

begin_function
specifier|static
name|int
name|dump_inserted_event_fn
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|event
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|FILE
modifier|*
name|output
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|gloss
init|=
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
operator|)
condition|?
literal|"sig"
else|:
literal|"fd "
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_INSERTED
operator||
name|EVLIST_TIMEOUT
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"  %p [%s "
name|EV_SOCK_FMT
literal|"]%s%s%s%s%s%s"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|e
argument_list|,
name|gloss
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|e
operator|->
name|ev_fd
argument_list|)
argument_list|,
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_READ
operator|)
condition|?
literal|" Read"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_WRITE
operator|)
condition|?
literal|" Write"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_CLOSED
operator|)
condition|?
literal|" EOF"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
operator|)
condition|?
literal|" Signal"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_PERSIST
operator|)
condition|?
literal|" Persist"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
operator|)
condition|?
literal|" Internal"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|e
operator|->
name|ev_timeout
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|e
operator|->
name|ev_timeout
operator|.
name|tv_usec
operator|&
name|MICROSECONDS_MASK
expr_stmt|;
name|evutil_timeradd
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|base
operator|->
name|tv_clock_diff
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|" Timeout=%ld.%06d"
argument_list|,
operator|(
name|long
operator|)
name|tv
operator|.
name|tv_sec
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tv
operator|.
name|tv_usec
operator|&
name|MICROSECONDS_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper for event_base_dump_events: called on each event in the event base;  * dumps only the active events. */
end_comment

begin_function
specifier|static
name|int
name|dump_active_event_fn
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
specifier|const
name|struct
name|event
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|FILE
modifier|*
name|output
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|gloss
init|=
operator|(
name|e
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
operator|)
condition|?
literal|"sig"
else|:
literal|"fd "
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"  %p [%s "
name|EV_SOCK_FMT
literal|", priority=%d]%s%s%s%s%s active%s%s\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|e
argument_list|,
name|gloss
argument_list|,
name|EV_SOCK_ARG
argument_list|(
name|e
operator|->
name|ev_fd
argument_list|)
argument_list|,
name|e
operator|->
name|ev_pri
argument_list|,
operator|(
name|e
operator|->
name|ev_res
operator|&
name|EV_READ
operator|)
condition|?
literal|" Read"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_res
operator|&
name|EV_WRITE
operator|)
condition|?
literal|" Write"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_res
operator|&
name|EV_CLOSED
operator|)
condition|?
literal|" EOF"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_res
operator|&
name|EV_SIGNAL
operator|)
condition|?
literal|" Signal"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_res
operator|&
name|EV_TIMEOUT
operator|)
condition|?
literal|" Timeout"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
operator|)
condition|?
literal|" [Internal]"
else|:
literal|""
argument_list|,
operator|(
name|e
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE_LATER
operator|)
condition|?
literal|" [NextTime]"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|event_base_foreach_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|event_base_foreach_event_cb
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|fn
operator|)
operator|||
operator|(
operator|!
name|base
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|event_base_foreach_event_nolock_
argument_list|(
name|base
argument_list|,
name|fn
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|event_base_dump_events
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|FILE
modifier|*
name|output
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"Inserted events:\n"
argument_list|)
expr_stmt|;
name|event_base_foreach_event_nolock_
argument_list|(
name|base
argument_list|,
name|dump_inserted_event_fn
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"Active events:\n"
argument_list|)
expr_stmt|;
name|event_base_foreach_event_nolock_
argument_list|(
name|base
argument_list|,
name|dump_active_event_fn
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_active_by_fd
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evmap_io_active_
argument_list|(
name|base
argument_list|,
name|fd
argument_list|,
name|events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_CLOSED
operator|)
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_active_by_signal
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|evmap_signal_active_
argument_list|(
name|base
argument_list|,
name|sig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_add_virtual_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|base
operator|->
name|virtual_event_count
operator|++
expr_stmt|;
name|MAX_EVENT_COUNT
argument_list|(
name|base
operator|->
name|virtual_event_count_max
argument_list|,
name|base
operator|->
name|virtual_event_count
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_del_virtual_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|base
operator|->
name|virtual_event_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|base
operator|->
name|virtual_event_count
operator|--
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|virtual_event_count
operator|==
literal|0
operator|&&
name|EVBASE_NEED_NOTIFY
argument_list|(
name|base
argument_list|)
condition|)
name|evthread_notify_base
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_free_debug_globals_locks
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
if|if
condition|(
name|event_debug_map_lock_
operator|!=
name|NULL
condition|)
block|{
name|EVTHREAD_FREE_LOCK
argument_list|(
name|event_debug_map_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|event_debug_map_lock_
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EVENT__DISABLE_DEBUG_MODE */
endif|#
directive|endif
comment|/* EVENT__DISABLE_THREAD_SUPPORT */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|event_free_debug_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|event_free_debug_globals_locks
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_free_evsig_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|evsig_free_globals_
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_free_evutil_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|evutil_free_globals_
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_free_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|event_free_debug_globals
argument_list|()
expr_stmt|;
name|event_free_evsig_globals
argument_list|()
expr_stmt|;
name|event_free_evutil_globals
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libevent_global_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|event_free_globals
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT__DISABLE_THREAD_SUPPORT
end_ifndef

begin_function
name|int
name|event_global_setup_locks_
parameter_list|(
specifier|const
name|int
name|enable_locks
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|EVENT__DISABLE_DEBUG_MODE
name|EVTHREAD_SETUP_GLOBAL_LOCK
argument_list|(
name|event_debug_map_lock_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|evsig_global_setup_locks_
argument_list|(
name|enable_locks
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|evutil_global_setup_locks_
argument_list|(
name|enable_locks
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|evutil_secure_rng_global_setup_locks_
argument_list|(
name|enable_locks
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|event_base_assert_ok_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|EVBASE_ACQUIRE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
name|event_base_assert_ok_nolock_
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|EVBASE_RELEASE_LOCK
argument_list|(
name|base
argument_list|,
name|th_base_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|event_base_assert_ok_nolock_
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* First do checks on the per-fd and per-signal lists */
name|evmap_check_integrity_
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Check the heap property */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|base
operator|->
name|timeheap
operator|.
name|n
condition|;
operator|++
name|i
control|)
block|{
name|int
name|parent
init|=
operator|(
name|i
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|,
modifier|*
name|p_ev
decl_stmt|;
name|ev
operator|=
name|base
operator|->
name|timeheap
operator|.
name|p
index|[
name|i
index|]
expr_stmt|;
name|p_ev
operator|=
name|base
operator|->
name|timeheap
operator|.
name|p
index|[
name|parent
index|]
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|p_ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|<=
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|==
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the common timeouts are fine */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|n_common_timeouts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|common_timeout_list
modifier|*
name|ctl
init|=
name|base
operator|->
name|common_timeout_queues
index|[
name|i
index|]
decl_stmt|;
name|struct
name|event
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|ev
decl_stmt|;
name|EVUTIL_ASSERT_TAILQ_OK
argument_list|(
operator|&
name|ctl
operator|->
name|events
argument_list|,
name|event
argument_list|,
name|ev_timeout_pos
operator|.
name|ev_next_with_common_timeout
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ev
argument_list|,
argument|&ctl->events
argument_list|,
argument|ev_timeout_pos.ev_next_with_common_timeout
argument_list|)
block|{
if|if
condition|(
name|last
condition|)
name|EVUTIL_ASSERT
argument_list|(
name|evutil_timercmp
argument_list|(
operator|&
name|last
operator|->
name|ev_timeout
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|<=
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|is_common_timeout
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|COMMON_TIMEOUT_IDX
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
operator|==
name|i
argument_list|)
expr_stmt|;
name|last
operator|=
name|ev
expr_stmt|;
block|}
block|}
comment|/* Check the active queues. */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
name|EVUTIL_ASSERT_TAILQ_OK
argument_list|(
operator|&
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|,
name|event_callback
argument_list|,
name|evcb_active_next
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|evcb
argument_list|,
argument|&base->activequeues[i]
argument_list|,
argument|evcb_active_next
argument_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
operator|==
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
name|EVUTIL_ASSERT
argument_list|(
name|evcb
operator|->
name|evcb_pri
operator|==
name|i
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|{
name|struct
name|event_callback
modifier|*
name|evcb
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|evcb
argument_list|,
argument|&base->active_later_queue
argument_list|,
argument|evcb_active_next
argument_list|)
block|{
name|EVUTIL_ASSERT
argument_list|(
operator|(
name|evcb
operator|->
name|evcb_flags
operator|&
operator|(
name|EVLIST_ACTIVE
operator||
name|EVLIST_ACTIVE_LATER
operator|)
operator|)
operator|==
name|EVLIST_ACTIVE_LATER
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
name|EVUTIL_ASSERT
argument_list|(
name|count
operator|==
name|base
operator|->
name|event_count_active
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

