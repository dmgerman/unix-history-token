begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Copyright (c) 2006 Maxim Yegorushkin<maxim.yegorushkin@gmail.com>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MINHEAP_INTERNAL_H_INCLUDED_
end_ifndef

begin_define
define|#
directive|define
name|MINHEAP_INTERNAL_H_INCLUDED_
end_define

begin_include
include|#
directive|include
file|"event2/event-config.h"
end_include

begin_include
include|#
directive|include
file|"evconfig-private.h"
end_include

begin_include
include|#
directive|include
file|"event2/event.h"
end_include

begin_include
include|#
directive|include
file|"event2/event_struct.h"
end_include

begin_include
include|#
directive|include
file|"event2/util.h"
end_include

begin_include
include|#
directive|include
file|"util-internal.h"
end_include

begin_include
include|#
directive|include
file|"mm-internal.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|min_heap
block|{
name|struct
name|event
modifier|*
modifier|*
name|p
decl_stmt|;
name|unsigned
name|n
decl_stmt|,
name|a
decl_stmt|;
block|}
name|min_heap_t
typedef|;
end_typedef

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_ctor_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_dtor_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_elem_init_
parameter_list|(
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_elt_is_top_
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_empty_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|min_heap_size_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|event
modifier|*
name|min_heap_top_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_reserve_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_push_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|event
modifier|*
name|min_heap_pop_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_adjust_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|min_heap_erase_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_shift_up_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_shift_up_unconditional_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|min_heap_shift_down_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|min_heap_elem_greater
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|(evutil_timercmp(&(a)->ev_timeout,&(b)->ev_timeout,>))
end_define

begin_function
name|void
name|min_heap_ctor_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|p
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|a
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|min_heap_dtor_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|p
condition|)
name|mm_free
argument_list|(
name|s
operator|->
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|min_heap_elem_init_
parameter_list|(
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|min_heap_empty_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
return|return
literal|0u
operator|==
name|s
operator|->
name|n
return|;
block|}
end_function

begin_function
name|unsigned
name|min_heap_size_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|n
return|;
block|}
end_function

begin_function
name|struct
name|event
modifier|*
name|min_heap_top_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
return|return
name|s
operator|->
name|n
condition|?
operator|*
name|s
operator|->
name|p
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|min_heap_push_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|min_heap_reserve_
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|n
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|min_heap_shift_up_
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|n
operator|++
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|event
modifier|*
name|min_heap_pop_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|n
condition|)
block|{
name|struct
name|event
modifier|*
name|e
init|=
operator|*
name|s
operator|->
name|p
decl_stmt|;
name|min_heap_shift_down_
argument_list|(
name|s
argument_list|,
literal|0u
argument_list|,
name|s
operator|->
name|p
index|[
operator|--
name|s
operator|->
name|n
index|]
argument_list|)
expr_stmt|;
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|min_heap_elt_is_top_
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
return|return
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|int
name|min_heap_erase_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
condition|)
block|{
name|struct
name|event
modifier|*
name|last
init|=
name|s
operator|->
name|p
index|[
operator|--
name|s
operator|->
name|n
index|]
decl_stmt|;
name|unsigned
name|parent
init|=
operator|(
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
comment|/* we replace e with the last element in the heap.  We might need to 		   shift it upward if it is less than its parent, or downward if it is 		   greater than one or both its children. Since the children are known 		   to be less than the parent, it can't need to shift both up and 		   down. */
if|if
condition|(
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|>
literal|0
operator|&&
name|min_heap_elem_greater
argument_list|(
name|s
operator|->
name|p
index|[
name|parent
index|]
argument_list|,
name|last
argument_list|)
condition|)
name|min_heap_shift_up_unconditional_
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
name|min_heap_shift_down_
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|min_heap_adjust_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
condition|)
block|{
return|return
name|min_heap_push_
argument_list|(
name|s
argument_list|,
name|e
argument_list|)
return|;
block|}
else|else
block|{
name|unsigned
name|parent
init|=
operator|(
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
comment|/* The position of e has changed; we shift it up or down 		 * as needed.  We can't need to do both. */
if|if
condition|(
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|>
literal|0
operator|&&
name|min_heap_elem_greater
argument_list|(
name|s
operator|->
name|p
index|[
name|parent
index|]
argument_list|,
name|e
argument_list|)
condition|)
name|min_heap_shift_up_unconditional_
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|min_heap_shift_down_
argument_list|(
name|s
argument_list|,
name|e
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|min_heap_reserve_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|n
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|a
operator|<
name|n
condition|)
block|{
name|struct
name|event
modifier|*
modifier|*
name|p
decl_stmt|;
name|unsigned
name|a
init|=
name|s
operator|->
name|a
condition|?
name|s
operator|->
name|a
operator|*
literal|2
else|:
literal|8
decl_stmt|;
if|if
condition|(
name|a
operator|<
name|n
condition|)
name|a
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
expr|struct
name|event
operator|*
operator|*
operator|)
name|mm_realloc
argument_list|(
name|s
operator|->
name|p
argument_list|,
name|a
operator|*
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|s
operator|->
name|a
operator|=
name|a
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|min_heap_shift_up_unconditional_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|parent
init|=
operator|(
name|hole_index
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
do|do
block|{
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|s
operator|->
name|p
index|[
name|parent
index|]
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
name|hole_index
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
operator|(
name|hole_index
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|hole_index
operator|&&
name|min_heap_elem_greater
argument_list|(
name|s
operator|->
name|p
index|[
name|parent
index|]
argument_list|,
name|e
argument_list|)
condition|)
do|;
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|e
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
block|}
end_function

begin_function
name|void
name|min_heap_shift_up_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|parent
init|=
operator|(
name|hole_index
operator|-
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
while|while
condition|(
name|hole_index
operator|&&
name|min_heap_elem_greater
argument_list|(
name|s
operator|->
name|p
index|[
name|parent
index|]
argument_list|,
name|e
argument_list|)
condition|)
block|{
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|s
operator|->
name|p
index|[
name|parent
index|]
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
name|hole_index
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
operator|(
name|hole_index
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|e
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
block|}
end_function

begin_function
name|void
name|min_heap_shift_down_
parameter_list|(
name|min_heap_t
modifier|*
name|s
parameter_list|,
name|unsigned
name|hole_index
parameter_list|,
name|struct
name|event
modifier|*
name|e
parameter_list|)
block|{
name|unsigned
name|min_child
init|=
literal|2
operator|*
operator|(
name|hole_index
operator|+
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|min_child
operator|<=
name|s
operator|->
name|n
condition|)
block|{
name|min_child
operator|-=
name|min_child
operator|==
name|s
operator|->
name|n
operator|||
name|min_heap_elem_greater
argument_list|(
name|s
operator|->
name|p
index|[
name|min_child
index|]
argument_list|,
name|s
operator|->
name|p
index|[
name|min_child
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|min_heap_elem_greater
argument_list|(
name|e
argument_list|,
name|s
operator|->
name|p
index|[
name|min_child
index|]
argument_list|)
operator|)
condition|)
break|break;
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|s
operator|->
name|p
index|[
name|min_child
index|]
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
name|hole_index
operator|=
name|min_child
expr_stmt|;
name|min_child
operator|=
literal|2
operator|*
operator|(
name|hole_index
operator|+
literal|1
operator|)
expr_stmt|;
block|}
operator|(
name|s
operator|->
name|p
index|[
name|hole_index
index|]
operator|=
name|e
operator|)
operator|->
name|ev_timeout_pos
operator|.
name|min_heap_idx
operator|=
name|hole_index
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINHEAP_INTERNAL_H_INCLUDED_ */
end_comment

end_unit

