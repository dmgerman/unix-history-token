begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2007 Niels Provos<provos@citi.umich.edu>  * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EVENT2_EVENT_H_INCLUDED_
end_ifndef

begin_define
define|#
directive|define
name|EVENT2_EVENT_H_INCLUDED_
end_define

begin_comment
comment|/**    @mainpage    @section intro Introduction    Libevent is an event notification library for developing scalable network   servers.  The Libevent API provides a mechanism to execute a callback   function when a specific event occurs on a file descriptor or after a   timeout has been reached. Furthermore, Libevent also support callbacks due   to signals or regular timeouts.    Libevent is meant to replace the event loop found in event driven network   servers. An application just needs to call event_base_dispatch() and then add or   remove events dynamically without having to change the event loop.     Currently, Libevent supports /dev/poll, kqueue(2), select(2), poll(2),   epoll(4), and evports. The internal event mechanism is completely   independent of the exposed event API, and a simple update of Libevent can   provide new functionality without having to redesign the applications. As a   result, Libevent allows for portable application development and provides   the most scalable event notification mechanism available on an operating   system.  Libevent can also be used for multithreaded programs.  Libevent   should compile on Linux, *BSD, Mac OS X, Solaris and, Windows.    @section usage Standard usage    Every program that uses Libevent must include the<event2/event.h>   header, and pass the -levent flag to the linker.  (You can instead link   -levent_core if you only want the main event and buffered IO-based code,   and don't want to link any protocol code.)    @section setup Library setup    Before you call any other Libevent functions, you need to set up the   library.  If you're going to use Libevent from multiple threads in a   multithreaded application, you need to initialize thread support --   typically by using evthread_use_pthreads() or   evthread_use_windows_threads().  See<event2/thread.h> for more   information.    This is also the point where you can replace Libevent's memory   management functions with event_set_mem_functions, and enable debug mode   with event_enable_debug_mode().    @section base Creating an event base    Next, you need to create an event_base structure, using event_base_new()   or event_base_new_with_config().  The event_base is responsible for   keeping track of which events are "pending" (that is to say, being   watched to see if they become active) and which events are "active".   Every event is associated with a single event_base.    @section event Event notification    For each file descriptor that you wish to monitor, you must create an   event structure with event_new().  (You may also declare an event   structure and call event_assign() to initialize the members of the   structure.)  To enable notification, you add the structure to the list   of monitored events by calling event_add().  The event structure must   remain allocated as long as it is active, so it should generally be   allocated on the heap.    @section loop Dispatching events.    Finally, you call event_base_dispatch() to loop and dispatch events.   You can also use event_base_loop() for more fine-grained control.    Currently, only one thread can be dispatching a given event_base at a   time.  If you want to run events in multiple threads at once, you can   either have a single event_base whose events add work to a work queue,   or you can create multiple event_base objects.    @section bufferevent I/O Buffers    Libevent provides a buffered I/O abstraction on top of the regular event   callbacks. This abstraction is called a bufferevent. A bufferevent   provides input and output buffers that get filled and drained   automatically. The user of a buffered event no longer deals directly   with the I/O, but instead is reading from input and writing to output   buffers.    Once initialized via bufferevent_socket_new(), the bufferevent structure   can be used repeatedly with bufferevent_enable() and   bufferevent_disable().  Instead of reading and writing directly to a   socket, you would call bufferevent_read() and bufferevent_write().    When read enabled the bufferevent will try to read from the file descriptor   and call the read callback. The write callback is executed whenever the   output buffer is drained below the write low watermark, which is 0 by   default.    See<event2/bufferevent*.h> for more information.    @section timers Timers    Libevent can also be used to create timers that invoke a callback after a   certain amount of time has expired. The evtimer_new() macro returns   an event struct to use as a timer. To activate the timer, call   evtimer_add(). Timers can be deactivated by calling evtimer_del().   (These macros are thin wrappers around event_new(), event_add(),   and event_del(); you can also use those instead.)    @section evdns Asynchronous DNS resolution    Libevent provides an asynchronous DNS resolver that should be used instead   of the standard DNS resolver functions.  See the<event2/dns.h>   functions for more detail.    @section evhttp Event-driven HTTP servers    Libevent provides a very simple event-driven HTTP server that can be   embedded in your program and used to service HTTP requests.    To use this capability, you need to include the<event2/http.h> header in your   program.  See that header for more information.    @section evrpc A framework for RPC servers and clients    Libevent provides a framework for creating RPC servers and clients.  It   takes care of marshaling and unmarshaling all data structures.    @section api API Reference    To browse the complete documentation of the libevent API, click on any of   the following links.    event2/event.h   The primary libevent header    event2/thread.h   Functions for use by multithreaded programs    event2/buffer.h and event2/bufferevent.h   Buffer management for network reading and writing    event2/util.h   Utility functions for portable nonblocking network code    event2/dns.h   Asynchronous DNS resolution    event2/http.h   An embedded libevent-based HTTP server    event2/rpc.h   A framework for creating RPC servers and clients   */
end_comment

begin_comment
comment|/** @file event2/event.h    Core functions for waiting for and receiving events, and using event bases. */
end_comment

begin_include
include|#
directive|include
file|<event2/visibility.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|<event2/event-config.h>
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TYPES_H
include|#
directive|include
file|<sys/types.h>
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EVENT__HAVE_SYS_TIME_H
include|#
directive|include
file|<sys/time.h>
endif|#
directive|endif
include|#
directive|include
file|<stdio.h>
comment|/* For int types. */
include|#
directive|include
file|<event2/util.h>
comment|/**  * Structure to hold information and state for a Libevent dispatch loop.  *  * The event_base lies at the center of Libevent; every application will  * have one.  It keeps track of all pending and active events, and  * notifies your application of the active ones.  *  * This is an opaque structure; you can allocate one using  * event_base_new() or event_base_new_with_config().  *  * @see event_base_new(), event_base_free(), event_base_loop(),  *    event_base_new_with_config()  */
struct|struct
name|event_base
ifdef|#
directive|ifdef
name|EVENT_IN_DOXYGEN_
block|{
comment|/*Empty body so that doxygen will generate documentation here.*/
block|}
endif|#
directive|endif
struct|;
comment|/**  * @struct event  *  * Structure to represent a single event.  *  * An event can have some underlying condition it represents: a socket  * becoming readable or writeable (or both), or a signal becoming raised.  * (An event that represents no underlying condition is still useful: you  * can use one to implement a timer, or to communicate between threads.)  *  * Generally, you can create events with event_new(), then make them  * pending with event_add().  As your event_base runs, it will run the  * callbacks of an events whose conditions are triggered.  When you  * longer want the event, free it with event_free().  *  * In more depth:  *  * An event may be "pending" (one whose condition we are watching),  * "active" (one whose condition has triggered and whose callback is about  * to run), neither, or both.  Events come into existence via  * event_assign() or event_new(), and are then neither active nor pending.  *  * To make an event pending, pass it to event_add().  When doing so, you  * can also set a timeout for the event.  *  * Events become active during an event_base_loop() call when either their  * condition has triggered, or when their timeout has elapsed.  You can  * also activate an event manually using event_active().  The even_base  * loop will run the callbacks of active events; after it has done so, it  * marks them as no longer active.  *  * You can make an event non-pending by passing it to event_del().  This  * also makes the event non-active.  *  * Events can be "persistent" or "non-persistent".  A non-persistent event  * becomes non-pending as soon as it is triggered: thus, it only runs at  * most once per call to event_add().  A persistent event remains pending  * even when it becomes active: you'll need to event_del() it manually in  * order to make it non-pending.  When a persistent event with a timeout  * becomes active, its timeout is reset: this means you can use persistent  * events to implement periodic timeouts.  *  * This should be treated as an opaque structure; you should never read or  * write any of its fields directly.  For backward compatibility with old  * code, it is defined in the event2/event_struct.h header; including this  * header may make your code incompatible with other versions of Libevent.  *  * @see event_new(), event_free(), event_assign(), event_get_assignment(),  *    event_add(), event_del(), event_active(), event_pending(),  *    event_get_fd(), event_get_base(), event_get_events(),  *    event_get_callback(), event_get_callback_arg(),  *    event_priority_set()  */
struct|struct
name|event
ifdef|#
directive|ifdef
name|EVENT_IN_DOXYGEN_
block|{
comment|/*Empty body so that doxygen will generate documentation here.*/
block|}
endif|#
directive|endif
struct|;
comment|/**  * Configuration for an event_base.  *  * There are many options that can be used to alter the behavior and  * implementation of an event_base.  To avoid having to pass them all in a  * complex many-argument constructor, we provide an abstract data type  * wrhere you set up configation information before passing it to  * event_base_new_with_config().  *  * @see event_config_new(), event_config_free(), event_base_new_with_config(),  *   event_config_avoid_method(), event_config_require_features(),  *   event_config_set_flag(), event_config_set_num_cpus_hint()  */
struct|struct
name|event_config
ifdef|#
directive|ifdef
name|EVENT_IN_DOXYGEN_
block|{
comment|/*Empty body so that doxygen will generate documentation here.*/
block|}
endif|#
directive|endif
struct|;
comment|/**  * Enable some relatively expensive debugging checks in Libevent that  * would normally be turned off.  Generally, these checks cause code that  * would otherwise crash mysteriously to fail earlier with an assertion  * failure.  Note that this method MUST be called before any events or  * event_bases have been created.  *  * Debug mode can currently catch the following errors:  *    An event is re-assigned while it is added  *    Any function is called on a non-assigned event  *  * Note that debugging mode uses memory to track every event that has been  * initialized (via event_assign, event_set, or event_new) but not yet  * released (via event_free or event_debug_unassign).  If you want to use  * debug mode, and you find yourself running out of memory, you will need  * to use event_debug_unassign to explicitly stop tracking events that  * are no longer considered set-up.  *  * @see event_debug_unassign()  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_enable_debug_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * When debugging mode is enabled, informs Libevent that an event should no  * longer be considered as assigned. When debugging mode is not enabled, does  * nothing.  *  * This function must only be called on a non-added event.  *  * @see event_enable_debug_mode()  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_debug_unassign
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
comment|/**  * Create and return a new event_base to use with the rest of Libevent.  *  * @return a new event_base on success, or NULL on failure.  *  * @see event_base_free(), event_base_new_with_config()  */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event_base
modifier|*
name|event_base_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**   Reinitialize the event base after a fork    Some event mechanisms do not survive across fork.   The event base needs   to be reinitialized with the event_reinit() function.    @param base the event base that needs to be re-initialized   @return 0 if successful, or -1 if some events could not be re-added.   @see event_base_new() */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_reinit
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**    Event dispatching loop    This loop will run the event base until either there are no more pending or   active, or until something calls event_base_loopbreak() or   event_base_loopexit().    @param base the event_base structure returned by event_base_new() or      event_base_new_with_config()   @return 0 if successful, -1 if an error occurred, or 1 if we exited because      no events were pending or active.   @see event_base_loop()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**  Get the kernel event notification mechanism used by Libevent.   @param eb the event_base structure returned by event_base_new()  @return a string identifying the kernel event mechanism (kqueue, epoll, etc.)  */
name|EVENT2_EXPORT_SYMBOL
specifier|const
name|char
modifier|*
name|event_base_get_method
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**    Gets all event notification mechanisms supported by Libevent.     This functions returns the event mechanism in order preferred by    Libevent.  Note that this list will include all backends that    Libevent has compiled-in support for, and will not necessarily check    your OS to see whether it has the required resources.     @return an array with pointers to the names of support methods.      The end of the array is indicated by a NULL pointer.  If an      error is encountered NULL is returned. */
name|EVENT2_EXPORT_SYMBOL
specifier|const
name|char
modifier|*
modifier|*
name|event_get_supported_methods
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/** Query the current monotonic time from a the timer for a struct  * event_base.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_gettime_monotonic
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
function_decl|;
comment|/**    @name event type flag     Flags to pass to event_base_get_num_events() to specify the kinds of events    we want to aggregate counts for */
comment|/**@{*/
comment|/** count the number of active events, which have been triggered.*/
define|#
directive|define
name|EVENT_BASE_COUNT_ACTIVE
value|1U
comment|/** count the number of virtual events, which is used to represent an internal  * condition, other than a pending event, that keeps the loop from exiting. */
define|#
directive|define
name|EVENT_BASE_COUNT_VIRTUAL
value|2U
comment|/** count the number of events which have been added to event base, including  * internal events. */
define|#
directive|define
name|EVENT_BASE_COUNT_ADDED
value|4U
comment|/**@}*/
comment|/**    Gets the number of events in event_base, as specified in the flags.     Since event base has some internal events added to make some of its    functionalities work, EVENT_BASE_COUNT_ADDED may return more than the    number of events you added using event_add().     If you pass EVENT_BASE_COUNT_ACTIVE and EVENT_BASE_COUNT_ADDED together, an    active event will be counted twice. However, this might not be the case in    future libevent versions.  The return value is an indication of the work    load, but the user shouldn't rely on the exact value as this may change in    the future.     @param eb the event_base structure returned by event_base_new()    @param flags a bitwise combination of the kinds of events to aggregate        counts for    @return the number of events specified in the flags */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_get_num_events
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
comment|/**   Get the maximum number of events in a given event_base as specified in the   flags.    @param eb the event_base structure returned by event_base_new()   @param flags a bitwise combination of the kinds of events to aggregate          counts for   @param clear option used to reset the maximum count.   @return the number of events specified in the flags  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_get_max_events
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/**    Allocates a new event configuration object.     The event configuration object can be used to change the behavior of    an event base.     @return an event_config object that can be used to store configuration, or      NULL if an error is encountered.    @see event_base_new_with_config(), event_config_free(), event_config */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event_config
modifier|*
name|event_config_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**    Deallocates all memory associated with an event configuration object     @param cfg the event configuration object to be freed. */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_config_free
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|)
function_decl|;
comment|/**    Enters an event method that should be avoided into the configuration.     This can be used to avoid event mechanisms that do not support certain    file descriptor types, or for debugging to avoid certain event    mechanisms.  An application can make use of multiple event bases to    accommodate incompatible file descriptor types.     @param cfg the event configuration object    @param method the name of the event method to avoid    @return 0 on success, -1 on failure. */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_config_avoid_method
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
specifier|const
name|char
modifier|*
name|method
parameter_list|)
function_decl|;
comment|/**    A flag used to describe which features an event_base (must) provide.     Because of OS limitations, not every Libevent backend supports every    possible feature.  You can use this type with    event_config_require_features() to tell Libevent to only proceed if your    event_base implements a given feature, and you can receive this type from    event_base_get_features() to see which features are available. */
enum|enum
name|event_method_feature
block|{
comment|/** Require an event method that allows edge-triggered events with EV_ET. */
name|EV_FEATURE_ET
init|=
literal|0x01
block|,
comment|/** Require an event method where having one event triggered among      * many is [approximately] an O(1) operation. This excludes (for      * example) select and poll, which are approximately O(N) for N      * equal to the total number of possible events. */
name|EV_FEATURE_O1
init|=
literal|0x02
block|,
comment|/** Require an event method that allows file descriptors as well as      * sockets. */
name|EV_FEATURE_FDS
init|=
literal|0x04
block|,
comment|/** Require an event method that allows you to use EV_CLOSED to detect      * connection close without the necessity of reading all the pending data.      *      * Methods that do support EV_CLOSED may not be able to provide support on      * all kernel versions.      **/
name|EV_FEATURE_EARLY_CLOSE
init|=
literal|0x08
block|}
enum|;
comment|/**    A flag passed to event_config_set_flag().      These flags change the behavior of an allocated event_base.      @see event_config_set_flag(), event_base_new_with_config(),        event_method_feature  */
enum|enum
name|event_base_config_flag
block|{
comment|/** Do not allocate a lock for the event base, even if we have 	    locking set up.  	    Setting this option will make it unsafe and nonfunctional to call 	    functions on the base concurrently from multiple threads. 	*/
name|EVENT_BASE_FLAG_NOLOCK
init|=
literal|0x01
block|,
comment|/** Do not check the EVENT_* environment variables when configuring 	    an event_base  */
name|EVENT_BASE_FLAG_IGNORE_ENV
init|=
literal|0x02
block|,
comment|/** Windows only: enable the IOCP dispatcher at startup  	    If this flag is set then bufferevent_socket_new() and 	    evconn_listener_new() will use IOCP-backed implementations 	    instead of the usual select-based one on Windows. 	 */
name|EVENT_BASE_FLAG_STARTUP_IOCP
init|=
literal|0x04
block|,
comment|/** Instead of checking the current time every time the event loop is 	    ready to run timeout callbacks, check after each timeout callback. 	 */
name|EVENT_BASE_FLAG_NO_CACHE_TIME
init|=
literal|0x08
block|,
comment|/** If we are using the epoll backend, this flag says that it is 	    safe to use Libevent's internal change-list code to batch up 	    adds and deletes in order to try to do as few syscalls as 	    possible.  Setting this flag can make your code run faster, but 	    it may trigger a Linux bug: it is not safe to use this flag 	    if you have any fds cloned by dup() or its variants.  Doing so 	    will produce strange and hard-to-diagnose bugs.  	    This flag can also be activated by setting the 	    EVENT_EPOLL_USE_CHANGELIST environment variable.  	    This flag has no effect if you wind up using a backend other than 	    epoll. 	 */
name|EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST
init|=
literal|0x10
block|,
comment|/** Ordinarily, Libevent implements its time and timeout code using 	    the fastest monotonic timer that we have.  If this flag is set, 	    however, we use less efficient more precise timer, assuming one is 	    present. 	 */
name|EVENT_BASE_FLAG_PRECISE_TIMER
init|=
literal|0x20
block|}
enum|;
comment|/**    Return a bitmask of the features implemented by an event base.  This    will be a bitwise OR of one or more of the values of    event_method_feature     @see event_method_feature  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_get_features
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**    Enters a required event method feature that the application demands.     Note that not every feature or combination of features is supported    on every platform.  Code that requests features should be prepared    to handle the case where event_base_new_with_config() returns NULL, as in:<pre>      event_config_require_features(cfg, EV_FEATURE_ET);      base = event_base_new_with_config(cfg);      if (base == NULL) {        // We can't get edge-triggered behavior here.        event_config_require_features(cfg, 0);        base = event_base_new_with_config(cfg);      }</pre>     @param cfg the event configuration object    @param feature a bitfield of one or more event_method_feature values.           Replaces values from previous calls to this function.    @return 0 on success, -1 on failure.    @see event_method_feature, event_base_new_with_config() */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_config_require_features
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|feature
parameter_list|)
function_decl|;
comment|/**  * Sets one or more flags to configure what parts of the eventual event_base  * will be initialized, and how they'll work.  *  * @see event_base_config_flags, event_base_new_with_config()  **/
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_config_set_flag
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
comment|/**  * Records a hint for the number of CPUs in the system. This is used for  * tuning thread pools, etc, for optimal performance.  In Libevent 2.0,  * it is only on Windows, and only when IOCP is in use.  *  * @param cfg the event configuration object  * @param cpus the number of cpus  * @return 0 on success, -1 on failure.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_config_set_num_cpus_hint
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
name|int
name|cpus
parameter_list|)
function_decl|;
comment|/**  * Record an interval and/or a number of callbacks after which the event base  * should check for new events.  By default, the event base will run as many  * events are as activated at the higest activated priority before checking  * for new events.  If you configure it by setting max_interval, it will check  * the time after each callback, and not allow more than max_interval to  * elapse before checking for new events.  If you configure it by setting  * max_callbacks to a value>= 0, it will run no more than max_callbacks  * callbacks before checking for new events.  *  * This option can decrease the latency of high-priority events, and  * avoid priority inversions where multiple low-priority events keep us from  * polling for high-priority events, but at the expense of slightly decreasing  * the throughput.  Use it with caution!  *  * @param cfg The event_base configuration object.  * @param max_interval An interval after which Libevent should stop running  *     callbacks and check for more events, or NULL if there should be  *     no such interval.  * @param max_callbacks A number of callbacks after which Libevent should  *     stop running callbacks and check for more events, or -1 if there  *     should be no such limit.  * @param min_priority A priority below which max_interval and max_callbacks  *     should not be enforced.  If this is set to 0, they are enforced  *     for events of every priority; if it's set to 1, they're enforced  *     for events of priority 1 and above, and so on.  * @return 0 on success, -1 on failure.  **/
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_config_set_max_dispatch_interval
parameter_list|(
name|struct
name|event_config
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|max_interval
parameter_list|,
name|int
name|max_callbacks
parameter_list|,
name|int
name|min_priority
parameter_list|)
function_decl|;
comment|/**   Initialize the event API.    Use event_base_new_with_config() to initialize a new event base, taking   the specified configuration under consideration.  The configuration object   can currently be used to avoid certain event notification mechanisms.    @param cfg the event configuration object   @return an initialized event_base that can be used to registering events,      or NULL if no event base can be created with the requested event_config.   @see event_base_new(), event_base_free(), event_init(), event_assign() */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event_base
modifier|*
name|event_base_new_with_config
parameter_list|(
specifier|const
name|struct
name|event_config
modifier|*
parameter_list|)
function_decl|;
comment|/**   Deallocate all memory associated with an event_base, and free the base.    Note that this function will not close any fds or free any memory passed   to event_new as the argument to callback.    If there are any pending finalizer callbacks, this function will invoke   them.    @param eb an event_base to be freed  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_base_free
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**    As event_free, but do not run finalizers.     THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES    BECOMES STABLE.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_base_free_nofinalize
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/** @name Log severities  */
comment|/**@{*/
define|#
directive|define
name|EVENT_LOG_DEBUG
value|0
define|#
directive|define
name|EVENT_LOG_MSG
value|1
define|#
directive|define
name|EVENT_LOG_WARN
value|2
define|#
directive|define
name|EVENT_LOG_ERR
value|3
comment|/**@}*/
comment|/* Obsolete names: these are deprecated, but older programs might use them.  * They violate the reserved-identifier namespace. */
define|#
directive|define
name|_EVENT_LOG_DEBUG
value|EVENT_LOG_DEBUG
define|#
directive|define
name|_EVENT_LOG_MSG
value|EVENT_LOG_MSG
define|#
directive|define
name|_EVENT_LOG_WARN
value|EVENT_LOG_WARN
define|#
directive|define
name|_EVENT_LOG_ERR
value|EVENT_LOG_ERR
comment|/**   A callback function used to intercept Libevent's log messages.    @see event_set_log_callback  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|event_log_cb
function_decl|)
parameter_list|(
name|int
name|severity
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
comment|/**   Redirect Libevent's log messages.    @param cb a function taking two arguments: an integer severity between      EVENT_LOG_DEBUG and EVENT_LOG_ERR, and a string.  If cb is NULL, 	 then the default log is used.    NOTE: The function you provide *must not* call any other libevent   functionality.  Doing so can produce undefined behavior.   */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_set_log_callback
parameter_list|(
name|event_log_cb
name|cb
parameter_list|)
function_decl|;
comment|/**    A function to be called if Libevent encounters a fatal internal error.     @see event_set_fatal_callback  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|event_fatal_cb
function_decl|)
parameter_list|(
name|int
name|err
parameter_list|)
function_decl|;
comment|/**  Override Libevent's behavior in the event of a fatal internal error.   By default, Libevent will call exit(1) if a programming error makes it  impossible to continue correct operation.  This function allows you to supply  another callback instead.  Note that if the function is ever invoked,  something is wrong with your program, or with Libevent: any subsequent calls  to Libevent may result in undefined behavior.   Libevent will (almost) always log an EVENT_LOG_ERR message before calling  this function; look at the last log message to see why Libevent has died.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_set_fatal_callback
parameter_list|(
name|event_fatal_cb
name|cb
parameter_list|)
function_decl|;
define|#
directive|define
name|EVENT_DBG_ALL
value|0xffffffffu
define|#
directive|define
name|EVENT_DBG_NONE
value|0
comment|/**  Turn on debugging logs and have them sent to the default log handler.   This is a global setting; if you are going to call it, you must call this  before any calls that create an event-base.  You must call it before any  multithreaded use of Libevent.   Debug logs are verbose.   @param which Controls which debug messages are turned on.  This option is    unused for now; for forward compatibility, you must pass in the constant    "EVENT_DBG_ALL" to turn debugging logs on, or "EVENT_DBG_NONE" to turn    debugging logs off.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_enable_debug_logging
parameter_list|(
name|ev_uint32_t
name|which
parameter_list|)
function_decl|;
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_disable_debug_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**   Associate a different event base with an event.    The event to be associated must not be currently active or pending.    @param eb the event base   @param ev the event   @return 0 on success, -1 on failure.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_set
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
comment|/** @name Loop flags      These flags control the behavior of event_base_loop().  */
comment|/**@{*/
comment|/** Block until we have an active event, then exit once all active events  * have had their callbacks run. */
define|#
directive|define
name|EVLOOP_ONCE
value|0x01
comment|/** Do not block: see which events are ready now, run the callbacks  * of the highest-priority ones, then exit. */
define|#
directive|define
name|EVLOOP_NONBLOCK
value|0x02
comment|/** Do not exit the loop because we have no pending events.  Instead, keep  * running until event_base_loopexit() or event_base_loopbreak() makes us  * stop.  */
define|#
directive|define
name|EVLOOP_NO_EXIT_ON_EMPTY
value|0x04
comment|/**@}*/
comment|/**   Wait for events to become active, and run their callbacks.    This is a more flexible version of event_base_dispatch().    By default, this loop will run the event base until either there are no more   pending or active events, or until something calls event_base_loopbreak() or   event_base_loopexit().  You can override this behavior with the 'flags'   argument.    @param eb the event_base structure returned by event_base_new() or      event_base_new_with_config()   @param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK   @return 0 if successful, -1 if an error occurred, or 1 if we exited because      no events were pending or active.   @see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,      EVLOOP_NONBLOCK   */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_loop
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/**   Exit the event loop after the specified time    The next event_base_loop() iteration after the given timer expires will   complete normally (handling all queued events) then exit without   blocking for events again.    Subsequent invocations of event_base_loop() will proceed normally.    @param eb the event_base structure returned by event_init()   @param tv the amount of time after which the loop should terminate,     or NULL to exit after running all currently active events.   @return 0 if successful, or -1 if an error occurred   @see event_base_loopbreak()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_loopexit
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/**   Abort the active event_base_loop() immediately.    event_base_loop() will abort the loop after the next event is completed;   event_base_loopbreak() is typically invoked from this event's callback.   This behavior is analogous to the "break;" statement.    Subsequent invocations of event_base_loop() will proceed normally.    @param eb the event_base structure returned by event_init()   @return 0 if successful, or -1 if an error occurred   @see event_base_loopexit()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_loopbreak
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**   Tell the active event_base_loop() to scan for new events immediately.    Calling this function makes the currently active event_base_loop()   start the loop over again (scanning for new events) after the current   event callback finishes.  If the event loop is not running, this   function has no effect.    event_base_loopbreak() is typically invoked from this event's callback.   This behavior is analogous to the "continue;" statement.    Subsequent invocations of event loop will proceed normally.    @param eb the event_base structure returned by event_init()   @return 0 if successful, or -1 if an error occurred   @see event_base_loopbreak()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_loopcontinue
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**   Checks if the event loop was told to exit by event_base_loopexit().    This function will return true for an event_base at every point after   event_loopexit() is called, until the event loop is next entered.    @param eb the event_base structure returned by event_init()   @return true if event_base_loopexit() was called on this event base,     or 0 otherwise   @see event_base_loopexit()   @see event_base_got_break()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_got_exit
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**   Checks if the event loop was told to abort immediately by event_base_loopbreak().    This function will return true for an event_base at every point after   event_base_loopbreak() is called, until the event loop is next entered.    @param eb the event_base structure returned by event_init()   @return true if event_base_loopbreak() was called on this event base,     or 0 otherwise   @see event_base_loopbreak()   @see event_base_got_exit()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_got_break
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
comment|/**  * @name event flags  *  * Flags to pass to event_new(), event_assign(), event_pending(), and  * anything else with an argument of the form "short events"  */
comment|/**@{*/
comment|/** Indicates that a timeout has occurred.  It's not necessary to pass  * this flag to event_for new()/event_assign() to get a timeout. */
define|#
directive|define
name|EV_TIMEOUT
value|0x01
comment|/** Wait for a socket or FD to become readable */
define|#
directive|define
name|EV_READ
value|0x02
comment|/** Wait for a socket or FD to become writeable */
define|#
directive|define
name|EV_WRITE
value|0x04
comment|/** Wait for a POSIX signal to be raised*/
define|#
directive|define
name|EV_SIGNAL
value|0x08
comment|/**  * Persistent event: won't get removed automatically when activated.  *  * When a persistent event with a timeout becomes activated, its timeout  * is reset to 0.  */
define|#
directive|define
name|EV_PERSIST
value|0x10
comment|/** Select edge-triggered behavior, if supported by the backend. */
define|#
directive|define
name|EV_ET
value|0x20
comment|/**  * If this option is provided, then event_del() will not block in one thread  * while waiting for the event callback to complete in another thread.  *  * To use this option safely, you may need to use event_finalize() or  * event_free_finalize() in order to safely tear down an event in a  * multithreaded application.  See those functions for more information.  *  * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES  * BECOMES STABLE.  **/
define|#
directive|define
name|EV_FINALIZE
value|0x40
comment|/**  * Detects connection close events.  You can use this to detect when a  * connection has been closed, without having to read all the pending data  * from a connection.  *  * Not all backends support EV_CLOSED.  To detect or require it, use the  * feature flag EV_FEATURE_EARLY_CLOSE.  **/
define|#
directive|define
name|EV_CLOSED
value|0x80
comment|/**@}*/
comment|/**    @name evtimer_* macros      Aliases for working with one-shot timer events */
comment|/**@{*/
define|#
directive|define
name|evtimer_assign
parameter_list|(
name|ev
parameter_list|,
name|b
parameter_list|,
name|cb
parameter_list|,
name|arg
parameter_list|)
define|\
value|event_assign((ev), (b), -1, 0, (cb), (arg))
define|#
directive|define
name|evtimer_new
parameter_list|(
name|b
parameter_list|,
name|cb
parameter_list|,
name|arg
parameter_list|)
value|event_new((b), -1, 0, (cb), (arg))
define|#
directive|define
name|evtimer_add
parameter_list|(
name|ev
parameter_list|,
name|tv
parameter_list|)
value|event_add((ev), (tv))
define|#
directive|define
name|evtimer_del
parameter_list|(
name|ev
parameter_list|)
value|event_del(ev)
define|#
directive|define
name|evtimer_pending
parameter_list|(
name|ev
parameter_list|,
name|tv
parameter_list|)
value|event_pending((ev), EV_TIMEOUT, (tv))
define|#
directive|define
name|evtimer_initialized
parameter_list|(
name|ev
parameter_list|)
value|event_initialized(ev)
comment|/**@}*/
comment|/**    @name evsignal_* macros     Aliases for working with signal events  */
comment|/**@{*/
define|#
directive|define
name|evsignal_add
parameter_list|(
name|ev
parameter_list|,
name|tv
parameter_list|)
value|event_add((ev), (tv))
define|#
directive|define
name|evsignal_assign
parameter_list|(
name|ev
parameter_list|,
name|b
parameter_list|,
name|x
parameter_list|,
name|cb
parameter_list|,
name|arg
parameter_list|)
define|\
value|event_assign((ev), (b), (x), EV_SIGNAL|EV_PERSIST, cb, (arg))
define|#
directive|define
name|evsignal_new
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|,
name|cb
parameter_list|,
name|arg
parameter_list|)
define|\
value|event_new((b), (x), EV_SIGNAL|EV_PERSIST, (cb), (arg))
define|#
directive|define
name|evsignal_del
parameter_list|(
name|ev
parameter_list|)
value|event_del(ev)
define|#
directive|define
name|evsignal_pending
parameter_list|(
name|ev
parameter_list|,
name|tv
parameter_list|)
value|event_pending((ev), EV_SIGNAL, (tv))
define|#
directive|define
name|evsignal_initialized
parameter_list|(
name|ev
parameter_list|)
value|event_initialized(ev)
comment|/**@}*/
comment|/**    A callback function for an event.     It receives three arguments:     @param fd An fd or signal    @param events One or more EV_* flags    @param arg A user-supplied argument.     @see event_new()  */
typedef|typedef
name|void
function_decl|(
modifier|*
name|event_callback_fn
function_decl|)
parameter_list|(
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/**   Return a value used to specify that the event itself must be used as the callback argument.    The function event_new() takes a callback argument which is passed   to the event's callback function. To specify that the argument to be   passed to the callback function is the event that event_new() returns,   pass in the return value of event_self_cbarg() as the callback argument   for event_new().    For example:<pre>       struct event *ev = event_new(base, sock, events, callback, %event_self_cbarg());</pre>    For consistency with event_new(), it is possible to pass the return value   of this function as the callback argument for event_assign()&ndash; this   achieves the same result as passing the event in directly.    @return a value to be passed as the callback argument to event_new() or   event_assign().   @see event_new(), event_assign()  */
name|EVENT2_EXPORT_SYMBOL
name|void
modifier|*
name|event_self_cbarg
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**   Allocate and asssign a new event structure, ready to be added.    The function event_new() returns a new event that can be used in   future calls to event_add() and event_del().  The fd and events   arguments determine which conditions will trigger the event; the   callback and callback_arg arguments tell Libevent what to do when the   event becomes active.    If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then   fd is a file descriptor or socket that should get monitored for   readiness to read, readiness to write, or readiness for either operation   (respectively).  If events contains EV_SIGNAL, then fd is a signal   number to wait for.  If events contains none of those flags, then the   event can be triggered only by a timeout or by manual activation with   event_active(): In this case, fd must be -1.    The EV_PERSIST flag can also be passed in the events argument: it makes   event_add() persistent until event_del() is called.    The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported   only by certain backends.  It tells Libevent to use edge-triggered   events.    The EV_TIMEOUT flag has no effect here.    It is okay to have multiple events all listening on the same fds; but   they must either all be edge-triggered, or all not be edge triggerd.    When the event becomes active, the event loop will run the provided   callbuck function, with three arguments.  The first will be the provided   fd value.  The second will be a bitfield of the events that triggered:   EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates   that a timeout occurred, and EV_ET indicates that an edge-triggered   event occurred.  The third event will be the callback_arg pointer that   you provide.    @param base the event base to which the event should be attached.   @param fd the file descriptor or signal to be monitored, or -1.   @param events desired events to monitor: bitfield of EV_READ, EV_WRITE,       EV_SIGNAL, EV_PERSIST, EV_ET.   @param callback callback function to be invoked when the event occurs   @param callback_arg an argument to be passed to the callback function    @return a newly allocated struct event that must later be freed with     event_free().   @see event_free(), event_add(), event_del(), event_assign()  */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event
modifier|*
name|event_new
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|event_callback_fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/**   Prepare a new, already-allocated event structure to be added.    The function event_assign() prepares the event structure ev to be used   in future calls to event_add() and event_del().  Unlike event_new(), it   doesn't allocate memory itself: it requires that you have already   allocated a struct event, probably on the heap.  Doing this will   typically make your code depend on the size of the event structure, and   thereby create incompatibility with future versions of Libevent.    The easiest way to avoid this problem is just to use event_new() and   event_free() instead.    A slightly harder way to future-proof your code is to use   event_get_struct_event_size() to determine the required size of an event   at runtime.    Note that it is NOT safe to call this function on an event that is   active or pending.  Doing so WILL corrupt internal data structures in   Libevent, and lead to strange, hard-to-diagnose bugs.  You _can_ use   event_assign to change an existing event, but only if it is not active   or pending!    The arguments for this function, and the behavior of the events that it   makes, are as for event_new().    @param ev an event struct to be modified   @param base the event base to which ev should be attached.   @param fd the file descriptor to be monitored   @param events desired events to monitor; can be EV_READ and/or EV_WRITE   @param callback callback function to be invoked when the event occurs   @param callback_arg an argument to be passed to the callback function    @return 0 if success, or -1 on invalid arguments.    @see event_new(), event_add(), event_del(), event_base_once(),     event_get_struct_event_size()   */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_assign
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|,
name|struct
name|event_base
modifier|*
parameter_list|,
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|event_callback_fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/**    Deallocate a struct event * returned by event_new().     If the event is pending or active, first make it non-pending and    non-active.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_free
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
comment|/**  * Callback type for event_finalize and event_free_finalize().  *  * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES  * BECOMES STABLE.  *  **/
typedef|typedef
name|void
function_decl|(
modifier|*
name|event_finalize_callback_fn
function_decl|)
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/**    @name Finalization functions     These functions are used to safely tear down an event in a multithreaded    application.  If you construct your events with EV_FINALIZE to avoid    deadlocks, you will need a way to remove an event in the certainty that    it will definitely not be running its callback when you deallocate it    and its callback argument.     To do this, call one of event_finalize() or event_free_finalize with    0 for its first argument, the event to tear down as its second argument,    and a callback function as its third argument.  The callback will be    invoked as part of the event loop, with the event's priority.     After you call a finalizer function, event_add() and event_active() will    no longer work on the event, and event_del() will produce a no-op. You    must not try to change the event's fields with event_assign() or    event_set() while the finalize callback is in progress.  Once the    callback has been invoked, you should treat the event structure as    containing uninitialized memory.     The event_free_finalize() function frees the event after it's finalized;    event_finalize() does not.     A finalizer callback must not make events pending or active.  It must not    add events, activate events, or attempt to "resucitate" the event being    finalized in any way.     THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES    BECOMES STABLE.     @return 0 on succes, -1 on failure.  */
comment|/**@{*/
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_finalize
parameter_list|(
name|unsigned
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|,
name|event_finalize_callback_fn
parameter_list|)
function_decl|;
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_free_finalize
parameter_list|(
name|unsigned
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|,
name|event_finalize_callback_fn
parameter_list|)
function_decl|;
comment|/**@}*/
comment|/**   Schedule a one-time event    The function event_base_once() is similar to event_new().  However, it   schedules a callback to be called exactly once, and does not require the   caller to prepare an event structure.    Note that in Libevent 2.0 and earlier, if the event is never triggered, the   internal memory used to hold it will never be freed.  In Libevent 2.1,   the internal memory will get freed by event_base_free() if the event   is never triggered.  The 'arg' value, however, will not get freed in either   case--you'll need to free that on your own if you want it to go away.    @param base an event_base   @param fd a file descriptor to monitor, or -1 for no fd.   @param events event(s) to monitor; can be any of EV_READ |          EV_WRITE, or EV_TIMEOUT   @param callback callback function to be invoked when the event occurs   @param arg an argument to be passed to the callback function   @param timeout the maximum amount of time to wait for the event. NULL          makes an EV_READ/EV_WRITE event make forever; NULL makes an         EV_TIMEOUT event succees immediately.   @return 0 if successful, or -1 if an error occurred  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_once
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|evutil_socket_t
parameter_list|,
name|short
parameter_list|,
name|event_callback_fn
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
comment|/**   Add an event to the set of pending events.    The function event_add() schedules the execution of the event 'ev' when the   condition specified by event_assign() or event_new() occurs, or when the time   specified in timeout has elapesed.  If atimeout is NULL, no timeout   occurs and the function will only be   called if a matching event occurs.  The event in the   ev argument must be already initialized by event_assign() or event_new()   and may not be used   in calls to event_assign() until it is no longer pending.    If the event in the ev argument already has a scheduled timeout, calling   event_add() replaces the old timeout with the new one if tv is non-NULL.    @param ev an event struct initialized via event_assign() or event_new()   @param timeout the maximum amount of time to wait for the event, or NULL          to wait forever   @return 0 if successful, or -1 if an error occurred   @see event_del(), event_assign(), event_new()   */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_add
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
specifier|const
name|struct
name|timeval
modifier|*
name|timeout
parameter_list|)
function_decl|;
comment|/**    Remove a timer from a pending event without removing the event itself.     If the event has a scheduled timeout, this function unschedules it but    leaves the event otherwise pending.     @param ev an event struct initialized via event_assign() or event_new()    @return 0 on success, or -1 if  an error occurrect. */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_remove_timer
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**   Remove an event from the set of monitored events.    The function event_del() will cancel the event in the argument ev.  If the   event has already executed or has never been added the call will have no   effect.    @param ev an event struct to be removed from the working set   @return 0 if successful, or -1 if an error occurred   @see event_add()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_del
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|)
function_decl|;
comment|/**    As event_del(), but never blocks while the event's callback is running    in another thread, even if the event was constructed without the    EV_FINALIZE flag.     THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES    BECOMES STABLE.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_del_noblock
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    As event_del(), but always blocks while the event's callback is running    in another thread, even if the event was constructed with the    EV_FINALIZE flag.     THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES    BECOMES STABLE.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_del_block
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**   Make an event active.    You can use this function on a pending or a non-pending event to make it   active, so that its callback will be run by event_base_dispatch() or   event_base_loop().    One common use in multithreaded programs is to wake the thread running   event_base_loop() from another thread.    @param ev an event to make active.   @param res a set of flags to pass to the event's callback.   @param ncalls an obsolete argument: this is ignored.  **/
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_active
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|,
name|short
name|ncalls
parameter_list|)
function_decl|;
comment|/**   Checks if a specific event is pending or scheduled.    @param ev an event struct previously passed to event_add()   @param events the requested event type; any of EV_TIMEOUT|EV_READ|          EV_WRITE|EV_SIGNAL   @param tv if this field is not NULL, and the event has a timeout,          this field is set to hold the time at which the timeout will 	 expire.    @return true if the event is pending on any of the events in 'what', (that   is to say, it has been added), or 0 if the event is not added.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_pending
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|short
name|events
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
function_decl|;
comment|/**    If called from within the callback for an event, returns that event.     The behavior of this function is not defined when called from outside the    callback function for an event.  */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event
modifier|*
name|event_base_get_running_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/**   Test if an event structure might be initialized.    The event_initialized() function can be used to check if an event has been   initialized.    Warning: This function is only useful for distinguishing a a zeroed-out     piece of memory from an initialized event, it can easily be confused by     uninitialized memory.  Thus, it should ONLY be used to distinguish an     initialized event from zero.    @param ev an event structure to be tested   @return 1 if the structure might be initialized, or 0 if it has not been           initialized  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_initialized
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Get the signal number assigned to a signal event */
define|#
directive|define
name|event_get_signal
parameter_list|(
name|ev
parameter_list|)
value|((int)event_get_fd(ev))
comment|/**    Get the socket or signal assigned to an event, or -1 if the event has    no socket. */
name|EVENT2_EXPORT_SYMBOL
name|evutil_socket_t
name|event_get_fd
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Get the event_base associated with an event. */
name|EVENT2_EXPORT_SYMBOL
name|struct
name|event_base
modifier|*
name|event_get_base
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Return the events (EV_READ, EV_WRITE, etc) assigned to an event. */
name|EVENT2_EXPORT_SYMBOL
name|short
name|event_get_events
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Return the callback assigned to an event. */
name|EVENT2_EXPORT_SYMBOL
name|event_callback_fn
name|event_get_callback
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Return the callback argument assigned to an event. */
name|EVENT2_EXPORT_SYMBOL
name|void
modifier|*
name|event_get_callback_arg
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Return the priority of an event.    @see event_priority_init(), event_get_priority() */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_get_priority
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|ev
parameter_list|)
function_decl|;
comment|/**    Extract _all_ of arguments given to construct a given event.  The    event_base is copied into *base_out, the fd is copied into *fd_out, and so    on.     If any of the "_out" arguments is NULL, it will be ignored.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_get_assignment
parameter_list|(
specifier|const
name|struct
name|event
modifier|*
name|event
parameter_list|,
name|struct
name|event_base
modifier|*
modifier|*
name|base_out
parameter_list|,
name|evutil_socket_t
modifier|*
name|fd_out
parameter_list|,
name|short
modifier|*
name|events_out
parameter_list|,
name|event_callback_fn
modifier|*
name|callback_out
parameter_list|,
name|void
modifier|*
modifier|*
name|arg_out
parameter_list|)
function_decl|;
comment|/**    Return the size of struct event that the Libevent library was compiled    with.     This will be NO GREATER than sizeof(struct event) if you're running with    the same version of Libevent that your application was built with, but    otherwise might not.     Note that it might be SMALLER than sizeof(struct event) if some future    version of Libevent adds extra padding to the end of struct event.    We might do this to help ensure ABI-compatibility between different    versions of Libevent.  */
name|EVENT2_EXPORT_SYMBOL
name|size_t
name|event_get_struct_event_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**    Get the Libevent version.     Note that this will give you the version of the library that you're    currently linked against, not the version of the headers that you've    compiled against.     @return a string containing the version number of Libevent */
name|EVENT2_EXPORT_SYMBOL
specifier|const
name|char
modifier|*
name|event_get_version
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**    Return a numeric representation of Libevent's version.     Note that this will give you the version of the library that you're    currently linked against, not the version of the headers you've used to    compile.     The format uses one byte each for the major, minor, and patchlevel parts of    the version number.  The low-order byte is unused.  For example, version    2.0.1-alpha has a numeric representation of 0x02000100 */
name|EVENT2_EXPORT_SYMBOL
name|ev_uint32_t
name|event_get_version_number
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/** As event_get_version, but gives the version of Libevent's headers. */
define|#
directive|define
name|LIBEVENT_VERSION
value|EVENT__VERSION
comment|/** As event_get_version_number, but gives the version number of Libevent's  * headers. */
define|#
directive|define
name|LIBEVENT_VERSION_NUMBER
value|EVENT__NUMERIC_VERSION
comment|/** Largest number of priorities that Libevent can support. */
define|#
directive|define
name|EVENT_MAX_PRIORITIES
value|256
comment|/**   Set the number of different event priorities    By default Libevent schedules all active events with the same priority.   However, some time it is desirable to process some events with a higher   priority than others.  For that reason, Libevent supports strict priority   queues.  Active events with a lower priority are always processed before   events with a higher priority.    The number of different priorities can be set initially with the   event_base_priority_init() function.  This function should be called   before the first call to event_base_dispatch().  The   event_priority_set() function can be used to assign a priority to an   event.  By default, Libevent assigns the middle priority to all events   unless their priority is explicitly set.    Note that urgent-priority events can starve less-urgent events: after   running all urgent-priority callbacks, Libevent checks for more urgent   events again, before running less-urgent events.  Less-urgent events   will not have their callbacks run until there are no events more urgent   than them that want to be active.    @param eb the event_base structure returned by event_base_new()   @param npriorities the maximum number of priorities   @return 0 if successful, or -1 if an error occurred   @see event_priority_set()  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_priority_init
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/**   Get the number of different event priorities.    @param eb the event_base structure returned by event_base_new()   @return Number of different event priorities   @see event_base_priority_init() */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_get_npriorities
parameter_list|(
name|struct
name|event_base
modifier|*
name|eb
parameter_list|)
function_decl|;
comment|/**   Assign a priority to an event.    @param ev an event struct   @param priority the new priority to be assigned   @return 0 if successful, or -1 if an error occurred   @see event_priority_init(), event_get_priority()   */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_priority_set
parameter_list|(
name|struct
name|event
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/**    Prepare an event_base to use a large number of timeouts with the same    duration.     Libevent's default scheduling algorithm is optimized for having a large    number of timeouts with their durations more or less randomly    distributed.  But if you have a large number of timeouts that all have    the same duration (for example, if you have a large number of    connections that all have a 10-second timeout), then you can improve    Libevent's performance by telling Libevent about it.     To do this, call this function with the common duration.  It will return a    pointer to a different, opaque timeout value.  (Don't depend on its actual    contents!)  When you use this timeout value in event_add(), Libevent will    schedule the event more efficiently.     (This optimization probably will not be worthwhile until you have thousands    or tens of thousands of events with the same timeout.)  */
name|EVENT2_EXPORT_SYMBOL
specifier|const
expr|struct
name|timeval
operator|*
name|event_base_init_common_timeout
argument_list|(
expr|struct
name|event_base
operator|*
name|base
argument_list|,
specifier|const
expr|struct
name|timeval
operator|*
name|duration
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EVENT__DISABLE_MM_REPLACEMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|EVENT_IN_DOXYGEN_
argument_list|)
comment|/**  Override the functions that Libevent uses for memory management.   Usually, Libevent uses the standard libc functions malloc, realloc, and  free to allocate memory.  Passing replacements for those functions to  event_set_mem_functions() overrides this behavior.   Note that all memory returned from Libevent will be allocated by the  replacement functions rather than by malloc() and realloc().  Thus, if you  have replaced those functions, it will not be appropriate to free() memory  that you get from Libevent.  Instead, you must use the free_fn replacement  that you provided.   Note also that if you are going to call this function, you should do so  before any call to any Libevent function that does allocation.  Otherwise, those funtions will allocate their memory using malloc(), but  then later free it using your provided free_fn.   @param malloc_fn A replacement for malloc.  @param realloc_fn A replacement for realloc  @param free_fn A replacement for free.  **/
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_set_mem_functions
parameter_list|(
name|void
modifier|*
function_decl|(
modifier|*
name|malloc_fn
function_decl|)
parameter_list|(
name|size_t
name|sz
parameter_list|)
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|realloc_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|sz
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_fn
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
parameter_list|)
function_decl|;
comment|/** This definition is present if Libevent was built with support for     event_set_mem_functions() */
define|#
directive|define
name|EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
endif|#
directive|endif
comment|/**    Writes a human-readable description of all inserted and/or active    events to a provided stdio stream.     This is intended for debugging; its format is not guaranteed to be the same    between libevent versions.     @param base An event_base on which to scan the events.    @param output A stdio file to write on.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_base_dump_events
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/**    Activates all pending events for the given fd and event mask.     This function activates pending events only.  Events which have not been    added will not become active.     @param base the event_base on which to activate the events.    @param fd An fd to active events on.    @param events One or more of EV_{READ,WRITE}.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_base_active_by_fd
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|evutil_socket_t
name|fd
parameter_list|,
name|short
name|events
parameter_list|)
function_decl|;
comment|/**    Activates all pending signals with a given signal number     This function activates pending events only.  Events which have not been    added will not become active.     @param base the event_base on which to activate the events.    @param fd The signal to active events on.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|event_base_active_by_signal
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|sig
parameter_list|)
function_decl|;
comment|/**  * Callback for iterating events in an event base via event_base_foreach_event  */
typedef|typedef
name|int
function_decl|(
modifier|*
name|event_base_foreach_event_cb
function_decl|)
parameter_list|(
specifier|const
name|struct
name|event_base
modifier|*
parameter_list|,
specifier|const
name|struct
name|event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/**    Iterate over all added or active events events in an event loop, and invoke    a given callback on each one.     The callback must not call any function that modifies the event base, that    modifies any event in the event base, or that adds or removes any event to    the event base.  Doing so is unsupported and will lead to undefined    behavior -- likely, to crashes.     event_base_foreach_event() holds a lock on the event_base() for the whole    time it's running: slow callbacks are not advisable.     Note that Libevent adds some events of its own to make pieces of its    functionality work.  You must not assume that the only events you'll    encounter will be the ones you added yourself.     The callback function must return 0 to continue iteration, or some other    integer to stop iterating.     @param base An event_base on which to scan the events.    @param fn   A callback function to receive the events.    @param arg  An argument passed to the callback function.    @return 0 if we iterated over every event, or the value returned by the       callback function if the loop exited early. */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_foreach_event
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|event_base_foreach_event_cb
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/** Sets 'tv' to the current time (as returned by gettimeofday()),     looking at the cached value in 'base' if possible, and calling     gettimeofday() or clock_gettime() as appropriate if there is no     cached time.      Generally, this value will only be cached while actually     processing event callbacks, and may be very inaccuate if your     callbacks take a long time to execute.      Returns 0 on success, negative on failure.  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_gettimeofday_cached
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
function_decl|;
comment|/** Update cached_tv in the 'base' to the current time  *  * You can use this function is useful for selectively increasing  * the accuracy of the cached time value in 'base' during callbacks  * that take a long time to execute.  *  * This function has no effect if the base is currently not in its  * event loop, or if timeval caching is disabled via  * EVENT_BASE_FLAG_NO_CACHE_TIME.  *  * @return 0 on success, -1 on failure  */
name|EVENT2_EXPORT_SYMBOL
name|int
name|event_base_update_cache_time
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
function_decl|;
comment|/** Release up all globally-allocated resources allocated by Libevent.      This function does not free developer-controlled resources like     event_bases, events, bufferevents, listeners, and so on.  It only releases     resources like global locks that there is no other way to free.      It is not actually necessary to call this function before exit: every     resource that it frees would be released anyway on exit.  It mainly exists     so that resource-leak debugging tools don't see Libevent as holding     resources at exit.      You should only call this function when no other Libevent functions will     be invoked -- e.g., when cleanly exiting a program.  */
name|EVENT2_EXPORT_SYMBOL
name|void
name|libevent_global_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EVENT2_EVENT_H_INCLUDED_ */
end_comment

end_unit

